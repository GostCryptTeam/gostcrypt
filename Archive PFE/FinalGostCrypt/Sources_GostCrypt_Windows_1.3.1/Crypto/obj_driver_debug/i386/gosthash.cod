; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\crypto\gosthash.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_C_3	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
_GostR3411_94_CryptoProParamSet DB 01H
	DB	03H
	DB	0aH
	DB	09H
	DB	05H
	DB	0bH
	DB	04H
	DB	0fH
	DB	08H
	DB	06H
	DB	07H
	DB	0eH
	DB	0dH
	DB	00H
	DB	02H
	DB	0cH
	DB	0dH
	DB	0eH
	DB	04H
	DB	01H
	DB	07H
	DB	00H
	DB	05H
	DB	0aH
	DB	03H
	DB	0cH
	DB	08H
	DB	0fH
	DB	06H
	DB	02H
	DB	09H
	DB	0bH
	DB	07H
	DB	06H
	DB	02H
	DB	04H
	DB	0dH
	DB	09H
	DB	0fH
	DB	00H
	DB	0aH
	DB	01H
	DB	05H
	DB	0bH
	DB	08H
	DB	0eH
	DB	0cH
	DB	03H
	DB	07H
	DB	06H
	DB	04H
	DB	0bH
	DB	09H
	DB	0cH
	DB	02H
	DB	0aH
	DB	01H
	DB	08H
	DB	00H
	DB	0eH
	DB	0fH
	DB	0dH
	DB	03H
	DB	05H
	DB	04H
	DB	0aH
	DB	07H
	DB	0cH
	DB	00H
	DB	0fH
	DB	02H
	DB	08H
	DB	0eH
	DB	01H
	DB	06H
	DB	05H
	DB	0dH
	DB	0bH
	DB	09H
	DB	03H
	DB	07H
	DB	0fH
	DB	0cH
	DB	0eH
	DB	09H
	DB	04H
	DB	01H
	DB	00H
	DB	03H
	DB	0bH
	DB	05H
	DB	02H
	DB	06H
	DB	0aH
	DB	08H
	DB	0dH
	DB	05H
	DB	0fH
	DB	04H
	DB	00H
	DB	02H
	DB	0dH
	DB	0bH
	DB	09H
	DB	01H
	DB	07H
	DB	06H
	DB	03H
	DB	0cH
	DB	0eH
	DB	0aH
	DB	08H
	DB	0aH
	DB	04H
	DB	05H
	DB	06H
	DB	08H
	DB	01H
	DB	03H
	DB	07H
	DB	0dH
	DB	0cH
	DB	0eH
	DB	00H
	DB	09H
	DB	02H
	DB	0bH
	DB	0fH
_DATA	ENDS
PUBLIC	_GOSTHASH_init@4
; Function compile flags: /Odtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\crypto\gosthash.c
;	COMDAT _GOSTHASH_init@4
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_GOSTHASH_init@4 PROC					; COMDAT

; 324  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 325  : 	set_blocks((byte *)ctx, 0, sizeof(gost_hash_ctx));

  00005	6a 68		 push	 104			; 00000068H
  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _set_blocks@12

; 326  : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
_GOSTHASH_init@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _set_blocks@12
_TEXT	SEGMENT
_i$ = -4						; size = 4
_ptr$ = 8						; size = 4
_val$ = 12						; size = 1
_len$ = 16						; size = 4
_set_blocks@12 PROC					; COMDAT

; 204  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 205  : 	gst_dword i;
; 206  : 	for (i = 0; i < len; i++)

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN3@set_blocks
$LN2@set_blocks:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@set_blocks:
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001b	3b 4d 10	 cmp	 ecx, DWORD PTR _len$[ebp]
  0001e	7d 0d		 jge	 SHORT $LN4@set_blocks

; 207  : 		ptr[i] = val;

  00020	8b 55 08	 mov	 edx, DWORD PTR _ptr$[ebp]
  00023	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00026	8a 45 0c	 mov	 al, BYTE PTR _val$[ebp]
  00029	88 02		 mov	 BYTE PTR [edx], al
  0002b	eb e2		 jmp	 SHORT $LN2@set_blocks
$LN4@set_blocks:

; 208  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
_set_blocks@12 ENDP
_TEXT	ENDS
PUBLIC	_GOSTHASH_add@12
; Function compile flags: /Odtp
;	COMDAT _GOSTHASH_add@12
_TEXT	SEGMENT
tv73 = -16						; size = 4
_add_bytes$ = -12					; size = 4
_barrier$ = -8						; size = 4
_curptr$ = -4						; size = 4
_block$ = 8						; size = 4
_len$ = 12						; size = 4
_ctx$ = 16						; size = 4
_GOSTHASH_add@12 PROC					; COMDAT

; 396  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 397  : 	gst_udword add_bytes;
; 398  : 
; 399  : 	byte *curptr = block;

  00008	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  0000b	89 45 fc	 mov	 DWORD PTR _curptr$[ebp], eax

; 400  : 	byte *barrier = block + (len - 32); //In order that curptr += 32 won't overshoot len.

  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  00011	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00014	8d 44 0a e0	 lea	 eax, DWORD PTR [edx+ecx-32]
  00018	89 45 f8	 mov	 DWORD PTR _barrier$[ebp], eax

; 401  : 
; 402  : 	if (ctx->left) //There are unsigned chars left from the last GOSTHASH_add

  0001b	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  0001e	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00022	0f 84 a9 00 00
	00		 je	 $LN7@GOSTHASH_a

; 403  : 	{
; 404  : 		add_bytes = (32 - ctx->left) > len ? len : (32 - ctx->left);

  00028	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  0002b	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00030	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00033	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  00036	76 08		 jbe	 SHORT $LN10@GOSTHASH_a
  00038	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  0003b	89 4d f0	 mov	 DWORD PTR tv73[ebp], ecx
  0003e	eb 0e		 jmp	 SHORT $LN11@GOSTHASH_a
$LN10@GOSTHASH_a:
  00040	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  00043	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00048	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  0004b	89 45 f0	 mov	 DWORD PTR tv73[ebp], eax
$LN11@GOSTHASH_a:
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR tv73[ebp]
  00051	89 4d f4	 mov	 DWORD PTR _add_bytes$[ebp], ecx

; 405  : 		copy_blocks(ctx->remainder + (byte)ctx->left, block, (gst_dword)add_bytes);

  00054	8b 55 f4	 mov	 edx, DWORD PTR _add_bytes$[ebp]
  00057	52		 push	 edx
  00058	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  0005b	50		 push	 eax
  0005c	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  0005f	0f b6 51 04	 movzx	 edx, BYTE PTR [ecx+4]
  00063	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  00066	8d 4c 10 48	 lea	 ecx, DWORD PTR [eax+edx+72]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 _copy_blocks@12

; 406  : 		if ((ctx->left + add_bytes) < 32) //This can be finished in the finalize stage if needed

  00070	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  00073	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00076	03 45 f4	 add	 eax, DWORD PTR _add_bytes$[ebp]
  00079	83 f8 20	 cmp	 eax, 32			; 00000020H
  0007c	73 05		 jae	 SHORT $LN6@GOSTHASH_a

; 407  : 		{
; 408  : 			return;

  0007e	e9 00 01 00 00	 jmp	 $LN8@GOSTHASH_a
$LN6@GOSTHASH_a:

; 409  : 		}
; 410  : 		
; 411  : 		curptr += add_bytes;

  00083	8b 4d fc	 mov	 ecx, DWORD PTR _curptr$[ebp]
  00086	03 4d f4	 add	 ecx, DWORD PTR _add_bytes$[ebp]
  00089	89 4d fc	 mov	 DWORD PTR _curptr$[ebp], ecx

; 412  : 		step (ctx->H, ctx->remainder, ctx);

  0008c	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  0008f	52		 push	 edx
  00090	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  00093	83 c0 48	 add	 eax, 72			; 00000048H
  00096	50		 push	 eax
  00097	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  0009a	83 c1 08	 add	 ecx, 8
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 _step@12

; 413  : 		add_blocks(ctx->S, ctx->remainder, 32);

  000a3	6a 20		 push	 32			; 00000020H
  000a5	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  000a8	83 c2 48	 add	 edx, 72			; 00000048H
  000ab	52		 push	 edx
  000ac	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  000af	83 c0 28	 add	 eax, 40			; 00000028H
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 _add_blocks@12

; 414  : 		ctx->len += 32;

  000b8	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  000bb	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bd	83 c2 20	 add	 edx, 32			; 00000020H
  000c0	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  000c3	89 10		 mov	 DWORD PTR [eax], edx

; 415  : 		ctx->left = 0;

  000c5	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  000c8	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  000cf	eb 3b		 jmp	 SHORT $LN3@GOSTHASH_a
$LN7@GOSTHASH_a:

; 416  : 	}
; 417  : /**
; 418  :  *
; 419  :  *	\fn else if (ctx->left + len < 32)
; 420  :  *	\brief
; 421  :  *	\param[in] ctx->left +
; 422  :  *	\return
; 423  :  *
; 424  :  */
; 425  : 	else if (ctx->left + len < 32)

  000d1	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  000d4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000d7	03 45 0c	 add	 eax, DWORD PTR _len$[ebp]
  000da	83 f8 20	 cmp	 eax, 32			; 00000020H
  000dd	73 2d		 jae	 SHORT $LN3@GOSTHASH_a

; 426  : 	{
; 427  : 		copy_blocks(ctx->remainder + (byte)ctx->left, block, (gst_dword)len);

  000df	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  000e2	51		 push	 ecx
  000e3	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  000e6	52		 push	 edx
  000e7	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  000ea	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  000ee	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  000f1	8d 44 0a 48	 lea	 eax, DWORD PTR [edx+ecx+72]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _copy_blocks@12

; 428  : 		ctx->left += len;

  000fb	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  000fe	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00101	03 55 0c	 add	 edx, DWORD PTR _len$[ebp]
  00104	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  00107	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 429  : 		return;

  0010a	eb 77		 jmp	 SHORT $LN8@GOSTHASH_a
$LN3@GOSTHASH_a:

; 430  : 	}
; 431  : 
; 432  : 	while (curptr <= barrier) //Add the input block to the hash

  0010c	8b 4d fc	 mov	 ecx, DWORD PTR _curptr$[ebp]
  0010f	3b 4d f8	 cmp	 ecx, DWORD PTR _barrier$[ebp]
  00112	77 3e		 ja	 SHORT $LN2@GOSTHASH_a

; 433  : 	{
; 434  : 		step(ctx->H, curptr, ctx);

  00114	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  00117	52		 push	 edx
  00118	8b 45 fc	 mov	 eax, DWORD PTR _curptr$[ebp]
  0011b	50		 push	 eax
  0011c	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  0011f	83 c1 08	 add	 ecx, 8
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 _step@12

; 435  : 		
; 436  : 		add_blocks(ctx->S, curptr, 32); //Add 32 unsigned chars of the message to the encrypted message

  00128	6a 20		 push	 32			; 00000020H
  0012a	8b 55 fc	 mov	 edx, DWORD PTR _curptr$[ebp]
  0012d	52		 push	 edx
  0012e	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  00131	83 c0 28	 add	 eax, 40			; 00000028H
  00134	50		 push	 eax
  00135	e8 00 00 00 00	 call	 _add_blocks@12

; 437  : 		
; 438  : 		ctx->len += 32; //We've processed 32 unsigned chars

  0013a	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  0013d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0013f	83 c2 20	 add	 edx, 32			; 00000020H
  00142	8b 45 10	 mov	 eax, DWORD PTR _ctx$[ebp]
  00145	89 10		 mov	 DWORD PTR [eax], edx

; 439  : 		curptr += 32; //Advance the block-pointer 32 unsigned chars

  00147	8b 4d fc	 mov	 ecx, DWORD PTR _curptr$[ebp]
  0014a	83 c1 20	 add	 ecx, 32			; 00000020H
  0014d	89 4d fc	 mov	 DWORD PTR _curptr$[ebp], ecx

; 440  : 	}

  00150	eb ba		 jmp	 SHORT $LN3@GOSTHASH_a
$LN2@GOSTHASH_a:

; 441  : 
; 442  : 	if (curptr != block + len) //If we have unsigned chars remaining, add them for the next GOSTHASH_add of _finalize

  00152	8b 55 08	 mov	 edx, DWORD PTR _block$[ebp]
  00155	03 55 0c	 add	 edx, DWORD PTR _len$[ebp]
  00158	39 55 fc	 cmp	 DWORD PTR _curptr$[ebp], edx
  0015b	74 26		 je	 SHORT $LN8@GOSTHASH_a

; 443  : 	{
; 444  : 		ctx->left = (gst_udword)(block + len - curptr);

  0015d	8b 45 08	 mov	 eax, DWORD PTR _block$[ebp]
  00160	03 45 0c	 add	 eax, DWORD PTR _len$[ebp]
  00163	2b 45 fc	 sub	 eax, DWORD PTR _curptr$[ebp]
  00166	8b 4d 10	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00169	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 445  : 		copy_blocks(ctx->remainder, curptr, (gst_dword)ctx->left);

  0016c	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  0016f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00172	50		 push	 eax
  00173	8b 4d fc	 mov	 ecx, DWORD PTR _curptr$[ebp]
  00176	51		 push	 ecx
  00177	8b 55 10	 mov	 edx, DWORD PTR _ctx$[ebp]
  0017a	83 c2 48	 add	 edx, 72			; 00000048H
  0017d	52		 push	 edx
  0017e	e8 00 00 00 00	 call	 _copy_blocks@12
$LN8@GOSTHASH_a:

; 446  : 	}
; 447  : }

  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c2 0c 00	 ret	 12			; 0000000cH
_GOSTHASH_add@12 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _copy_blocks@12
_TEXT	SEGMENT
_i$ = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_len$ = 16						; size = 4
_copy_blocks@12 PROC					; COMDAT

; 166  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 167  : 	gst_dword i;
; 168  : 	for (i = 0; i < len; i++)

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN3@copy_block
$LN2@copy_block:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@copy_block:
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001b	3b 4d 10	 cmp	 ecx, DWORD PTR _len$[ebp]
  0001e	7d 12		 jge	 SHORT $LN4@copy_block

; 169  : 		dst[i] = src[i];

  00020	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  00023	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00026	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00029	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0002c	8a 08		 mov	 cl, BYTE PTR [eax]
  0002e	88 0a		 mov	 BYTE PTR [edx], cl
  00030	eb dd		 jmp	 SHORT $LN2@copy_block
$LN4@copy_block:

; 170  : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 0c 00	 ret	 12			; 0000000cH
_copy_blocks@12 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _add_blocks@12
_TEXT	SEGMENT
_sum$ = -12						; size = 2
_carry$ = -8						; size = 2
_i$ = -4						; size = 4
_T$ = 8							; size = 4
_F$ = 12						; size = 4
_len$ = 16						; size = 4
_add_blocks@12 PROC					; COMDAT

; 222  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 223  : 	gst_dword i;
; 224  : 	gst_word carry = 0;

  00008	33 c0		 xor	 eax, eax
  0000a	66 89 45 f8	 mov	 WORD PTR _carry$[ebp], ax

; 225  : 	gst_word sum;
; 226  : 	for (i = 0; i < len; i++)

  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00015	eb 09		 jmp	 SHORT $LN3@add_blocks
$LN2@add_blocks:
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001a	83 c1 01	 add	 ecx, 1
  0001d	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN3@add_blocks:
  00020	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00023	3b 55 10	 cmp	 edx, DWORD PTR _len$[ebp]
  00026	7d 3c		 jge	 SHORT $LN4@add_blocks

; 227  : 	{
; 228  : 		sum = (gst_word)T[i] + (gst_word)F[i] + carry;

  00028	8b 45 08	 mov	 eax, DWORD PTR _T$[ebp]
  0002b	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0002e	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00031	8b 55 0c	 mov	 edx, DWORD PTR _F$[ebp]
  00034	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00037	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0003a	03 c8		 add	 ecx, eax
  0003c	0f bf 55 f8	 movsx	 edx, WORD PTR _carry$[ebp]
  00040	03 ca		 add	 ecx, edx
  00042	66 89 4d f4	 mov	 WORD PTR _sum$[ebp], cx

; 229  : 		T[i] = (byte)sum & 0xFF;

  00046	0f b6 45 f4	 movzx	 eax, BYTE PTR _sum$[ebp]
  0004a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _T$[ebp]
  00052	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00055	88 01		 mov	 BYTE PTR [ecx], al

; 230  : 		carry = sum >> 8;

  00057	0f bf 55 f4	 movsx	 edx, WORD PTR _sum$[ebp]
  0005b	c1 fa 08	 sar	 edx, 8
  0005e	66 89 55 f8	 mov	 WORD PTR _carry$[ebp], dx

; 231  : 	}

  00062	eb b3		 jmp	 SHORT $LN2@add_blocks
$LN4@add_blocks:

; 232  : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 0c 00	 ret	 12			; 0000000cH
_add_blocks@12 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp
;	COMDAT _step@12
_TEXT	SEGMENT
_U$ = -264						; size = 32
_K$ = -232						; size = 128
_V$ = -104						; size = 32
_S$ = -72						; size = 32
_i$ = -40						; size = 4
_W$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_H$ = 8							; size = 4
_M$ = 12						; size = 4
_ctx$ = 16						; size = 4
_step@12 PROC						; COMDAT

; 339  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 340  : 	byte U[32], W[32], V[32], S[32], K[4][32];
; 341  : 	gst_dword i;
; 342  : 	
; 343  : 	xor_blocks(W, H, M, 32);

  00015	6a 20		 push	 32			; 00000020H
  00017	8b 45 0c	 mov	 eax, DWORD PTR _M$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _H$[ebp]
  0001e	51		 push	 ecx
  0001f	8d 55 dc	 lea	 edx, DWORD PTR _W$[ebp]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 _xor_blocks@16

; 344  : 	P_transform(W, K[0]); //First key

  00028	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _K$[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d dc	 lea	 ecx, DWORD PTR _W$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 _P_transform@8

; 345  : 
; 346  : 	gost_encrypt_with_key (H, S, K[0]);

  00038	8d 95 18 ff ff
	ff		 lea	 edx, DWORD PTR _K$[ebp]
  0003e	52		 push	 edx
  0003f	8d 45 b8	 lea	 eax, DWORD PTR _S$[ebp]
  00042	50		 push	 eax
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _H$[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 _gost_encrypt_with_key@12

; 347  : 
; 348  : 	A (H, U);

  0004c	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _U$[ebp]
  00052	52		 push	 edx
  00053	8b 45 08	 mov	 eax, DWORD PTR _H$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _A@8

; 349  : 	A (M, V);

  0005c	8d 4d 98	 lea	 ecx, DWORD PTR _V$[ebp]
  0005f	51		 push	 ecx
  00060	8b 55 0c	 mov	 edx, DWORD PTR _M$[ebp]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 _A@8

; 350  : 	A (V, V);

  00069	8d 45 98	 lea	 eax, DWORD PTR _V$[ebp]
  0006c	50		 push	 eax
  0006d	8d 4d 98	 lea	 ecx, DWORD PTR _V$[ebp]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 _A@8

; 351  : 	xor_blocks(W, U, V, 32);

  00076	6a 20		 push	 32			; 00000020H
  00078	8d 55 98	 lea	 edx, DWORD PTR _V$[ebp]
  0007b	52		 push	 edx
  0007c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _U$[ebp]
  00082	50		 push	 eax
  00083	8d 4d dc	 lea	 ecx, DWORD PTR _W$[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 _xor_blocks@16

; 352  : 	P_transform(W, K[1]); //Second key

  0008c	8d 95 38 ff ff
	ff		 lea	 edx, DWORD PTR _K$[ebp+32]
  00092	52		 push	 edx
  00093	8d 45 dc	 lea	 eax, DWORD PTR _W$[ebp]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 _P_transform@8

; 353  : 
; 354  : 	gost_encrypt_with_key (H + 8, S + 8, K[1]);

  0009c	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _K$[ebp+32]
  000a2	51		 push	 ecx
  000a3	8d 55 c0	 lea	 edx, DWORD PTR _S$[ebp+8]
  000a6	52		 push	 edx
  000a7	8b 45 08	 mov	 eax, DWORD PTR _H$[ebp]
  000aa	83 c0 08	 add	 eax, 8
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 _gost_encrypt_with_key@12

; 355  : 
; 356  : 	A (U, U);

  000b3	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _U$[ebp]
  000b9	51		 push	 ecx
  000ba	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _U$[ebp]
  000c0	52		 push	 edx
  000c1	e8 00 00 00 00	 call	 _A@8

; 357  : 	/* As the other C values are all 0's, we only need to XOR
; 358  :      * with C[3] */
; 359  : 	xor_blocks(U, U, C_3, 32);

  000c6	6a 20		 push	 32			; 00000020H
  000c8	68 00 00 00 00	 push	 OFFSET _C_3
  000cd	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _U$[ebp]
  000d3	50		 push	 eax
  000d4	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _U$[ebp]
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 _xor_blocks@16

; 360  : 	A (V, V);

  000e0	8d 55 98	 lea	 edx, DWORD PTR _V$[ebp]
  000e3	52		 push	 edx
  000e4	8d 45 98	 lea	 eax, DWORD PTR _V$[ebp]
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 _A@8

; 361  : 	A (V, V);

  000ed	8d 4d 98	 lea	 ecx, DWORD PTR _V$[ebp]
  000f0	51		 push	 ecx
  000f1	8d 55 98	 lea	 edx, DWORD PTR _V$[ebp]
  000f4	52		 push	 edx
  000f5	e8 00 00 00 00	 call	 _A@8

; 362  : 	xor_blocks (W, U, V, 32);

  000fa	6a 20		 push	 32			; 00000020H
  000fc	8d 45 98	 lea	 eax, DWORD PTR _V$[ebp]
  000ff	50		 push	 eax
  00100	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _U$[ebp]
  00106	51		 push	 ecx
  00107	8d 55 dc	 lea	 edx, DWORD PTR _W$[ebp]
  0010a	52		 push	 edx
  0010b	e8 00 00 00 00	 call	 _xor_blocks@16

; 363  : 	P_transform (W, K[2]); //Third key

  00110	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _K$[ebp+64]
  00116	50		 push	 eax
  00117	8d 4d dc	 lea	 ecx, DWORD PTR _W$[ebp]
  0011a	51		 push	 ecx
  0011b	e8 00 00 00 00	 call	 _P_transform@8

; 364  : 	
; 365  : 	gost_encrypt_with_key (H + 16, S + 16, K[2]);

  00120	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR _K$[ebp+64]
  00126	52		 push	 edx
  00127	8d 45 c8	 lea	 eax, DWORD PTR _S$[ebp+16]
  0012a	50		 push	 eax
  0012b	8b 4d 08	 mov	 ecx, DWORD PTR _H$[ebp]
  0012e	83 c1 10	 add	 ecx, 16			; 00000010H
  00131	51		 push	 ecx
  00132	e8 00 00 00 00	 call	 _gost_encrypt_with_key@12

; 366  : 	
; 367  : 	A (U, U);

  00137	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _U$[ebp]
  0013d	52		 push	 edx
  0013e	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _U$[ebp]
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 _A@8

; 368  : 	A (V, V);

  0014a	8d 4d 98	 lea	 ecx, DWORD PTR _V$[ebp]
  0014d	51		 push	 ecx
  0014e	8d 55 98	 lea	 edx, DWORD PTR _V$[ebp]
  00151	52		 push	 edx
  00152	e8 00 00 00 00	 call	 _A@8

; 369  : 	A (V, V);

  00157	8d 45 98	 lea	 eax, DWORD PTR _V$[ebp]
  0015a	50		 push	 eax
  0015b	8d 4d 98	 lea	 ecx, DWORD PTR _V$[ebp]
  0015e	51		 push	 ecx
  0015f	e8 00 00 00 00	 call	 _A@8

; 370  : 	xor_blocks (W, U, V, 32);

  00164	6a 20		 push	 32			; 00000020H
  00166	8d 55 98	 lea	 edx, DWORD PTR _V$[ebp]
  00169	52		 push	 edx
  0016a	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _U$[ebp]
  00170	50		 push	 eax
  00171	8d 4d dc	 lea	 ecx, DWORD PTR _W$[ebp]
  00174	51		 push	 ecx
  00175	e8 00 00 00 00	 call	 _xor_blocks@16

; 371  : 	P_transform (W, K[3]); //Fourth key

  0017a	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _K$[ebp+96]
  00180	52		 push	 edx
  00181	8d 45 dc	 lea	 eax, DWORD PTR _W$[ebp]
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 _P_transform@8

; 372  : 	
; 373  : 	gost_encrypt_with_key (H + 24, S + 24, K[3]);

  0018a	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _K$[ebp+96]
  00190	51		 push	 ecx
  00191	8d 55 d0	 lea	 edx, DWORD PTR _S$[ebp+24]
  00194	52		 push	 edx
  00195	8b 45 08	 mov	 eax, DWORD PTR _H$[ebp]
  00198	83 c0 18	 add	 eax, 24			; 00000018H
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 _gost_encrypt_with_key@12

; 374  : 
; 375  : 	for (i = 0; i < 12; i++)

  001a1	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001a8	eb 09		 jmp	 SHORT $LN6@step
$LN5@step:
  001aa	8b 4d d8	 mov	 ecx, DWORD PTR _i$[ebp]
  001ad	83 c1 01	 add	 ecx, 1
  001b0	89 4d d8	 mov	 DWORD PTR _i$[ebp], ecx
$LN6@step:
  001b3	83 7d d8 0c	 cmp	 DWORD PTR _i$[ebp], 12	; 0000000cH
  001b7	7d 0b		 jge	 SHORT $LN4@step

; 376  : 		PSI (S);

  001b9	8d 55 b8	 lea	 edx, DWORD PTR _S$[ebp]
  001bc	52		 push	 edx
  001bd	e8 00 00 00 00	 call	 _PSI@4
  001c2	eb e6		 jmp	 SHORT $LN5@step
$LN4@step:

; 377  : 	xor_blocks (S, S, M, 32);

  001c4	6a 20		 push	 32			; 00000020H
  001c6	8b 45 0c	 mov	 eax, DWORD PTR _M$[ebp]
  001c9	50		 push	 eax
  001ca	8d 4d b8	 lea	 ecx, DWORD PTR _S$[ebp]
  001cd	51		 push	 ecx
  001ce	8d 55 b8	 lea	 edx, DWORD PTR _S$[ebp]
  001d1	52		 push	 edx
  001d2	e8 00 00 00 00	 call	 _xor_blocks@16

; 378  : 	PSI (S);

  001d7	8d 45 b8	 lea	 eax, DWORD PTR _S$[ebp]
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 _PSI@4

; 379  : 	xor_blocks (S, S, H, 32);

  001e0	6a 20		 push	 32			; 00000020H
  001e2	8b 4d 08	 mov	 ecx, DWORD PTR _H$[ebp]
  001e5	51		 push	 ecx
  001e6	8d 55 b8	 lea	 edx, DWORD PTR _S$[ebp]
  001e9	52		 push	 edx
  001ea	8d 45 b8	 lea	 eax, DWORD PTR _S$[ebp]
  001ed	50		 push	 eax
  001ee	e8 00 00 00 00	 call	 _xor_blocks@16

; 380  : 	for (i = 0; i < 61; i++)

  001f3	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001fa	eb 09		 jmp	 SHORT $LN3@step
$LN2@step:
  001fc	8b 4d d8	 mov	 ecx, DWORD PTR _i$[ebp]
  001ff	83 c1 01	 add	 ecx, 1
  00202	89 4d d8	 mov	 DWORD PTR _i$[ebp], ecx
$LN3@step:
  00205	83 7d d8 3d	 cmp	 DWORD PTR _i$[ebp], 61	; 0000003dH
  00209	7d 0b		 jge	 SHORT $LN1@step

; 381  : 		PSI (S);

  0020b	8d 55 b8	 lea	 edx, DWORD PTR _S$[ebp]
  0020e	52		 push	 edx
  0020f	e8 00 00 00 00	 call	 _PSI@4
  00214	eb e6		 jmp	 SHORT $LN2@step
$LN1@step:

; 382  : 	copy_blocks (H, S, 32);

  00216	6a 20		 push	 32			; 00000020H
  00218	8d 45 b8	 lea	 eax, DWORD PTR _S$[ebp]
  0021b	50		 push	 eax
  0021c	8b 4d 08	 mov	 ecx, DWORD PTR _H$[ebp]
  0021f	51		 push	 ecx
  00220	e8 00 00 00 00	 call	 _copy_blocks@12

; 383  : }

  00225	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00228	33 cd		 xor	 ecx, ebp
  0022a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022f	8b e5		 mov	 esp, ebp
  00231	5d		 pop	 ebp
  00232	c2 0c 00	 ret	 12			; 0000000cH
_step@12 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gost_encrypt_with_key@12
_TEXT	SEGMENT
_n2$ = -44						; size = 4
_X4$ = -40						; size = 4
_X1$ = -36						; size = 4
_X2$ = -32						; size = 4
_X7$ = -28						; size = 4
_n1$ = -24						; size = 4
_X3$ = -20						; size = 4
_X6$ = -16						; size = 4
_i$ = -12						; size = 4
_X0$ = -8						; size = 4
_X5$ = -4						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_key$ = 16						; size = 4
_gost_encrypt_with_key@12 PROC				; COMDAT

; 81   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 82   : 	gst_dword i;
; 83   : 	gst_udword n1, n2;
; 84   : 	gst_udword X0, X1, X2, X3, X4, X5, X6, X7;
; 85   : 
; 86   : 	n1 = (gst_udword)in[3] << 24 | (gst_udword)in[2] << 16 | (gst_udword)in[1] << 8 | (gst_udword)in[0];

  00008	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  0000b	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0000f	c1 e1 18	 shl	 ecx, 24			; 00000018H
  00012	8b 55 08	 mov	 edx, DWORD PTR _in$[ebp]
  00015	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00019	c1 e0 10	 shl	 eax, 16			; 00000010H
  0001c	0b c8		 or	 ecx, eax
  0001e	8b 55 08	 mov	 edx, DWORD PTR _in$[ebp]
  00021	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  00025	c1 e0 08	 shl	 eax, 8
  00028	0b c8		 or	 ecx, eax
  0002a	8b 55 08	 mov	 edx, DWORD PTR _in$[ebp]
  0002d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00030	0b c8		 or	 ecx, eax
  00032	89 4d e8	 mov	 DWORD PTR _n1$[ebp], ecx

; 87   : 	n2 = (gst_udword)in[7] << 24 | (gst_udword)in[6] << 16 | (gst_udword)in[5] << 8 | (gst_udword)in[4];

  00035	8b 4d 08	 mov	 ecx, DWORD PTR _in$[ebp]
  00038	0f b6 51 07	 movzx	 edx, BYTE PTR [ecx+7]
  0003c	c1 e2 18	 shl	 edx, 24			; 00000018H
  0003f	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00042	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00046	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00049	0b d1		 or	 edx, ecx
  0004b	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  0004e	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00052	c1 e1 08	 shl	 ecx, 8
  00055	0b d1		 or	 edx, ecx
  00057	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  0005a	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0005e	0b d1		 or	 edx, ecx
  00060	89 55 d4	 mov	 DWORD PTR _n2$[ebp], edx

; 88   : 
; 89   : 	/* Set the 8 round keys */
; 90   : 	X0 = 0;

  00063	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _X0$[ebp], 0

; 91   : 	X1 = 0;

  0006a	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _X1$[ebp], 0

; 92   : 	X2 = 0;

  00071	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _X2$[ebp], 0

; 93   : 	X3 = 0;

  00078	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _X3$[ebp], 0

; 94   : 	X4 = 0;

  0007f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _X4$[ebp], 0

; 95   : 	X5 = 0;

  00086	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _X5$[ebp], 0

; 96   : 	X6 = 0;

  0008d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _X6$[ebp], 0

; 97   : 	X7 = 0;

  00094	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _X7$[ebp], 0

; 98   : 	
; 99   : 	for (i = 0; i < GOSTHASH_GOST_KEYSIZE / 8; i++)

  0009b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000a2	eb 09		 jmp	 SHORT $LN3@gost_encry
$LN2@gost_encry:
  000a4	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  000a7	83 c2 01	 add	 edx, 1
  000aa	89 55 f4	 mov	 DWORD PTR _i$[ebp], edx
$LN3@gost_encry:
  000ad	83 7d f4 04	 cmp	 DWORD PTR _i$[ebp], 4
  000b1	0f 8d c4 00 00
	00		 jge	 $LN1@gost_encry

; 100  : 	{
; 101  : 		X0 |= (gst_udword)key[i + 0] << (i * 8);

  000b7	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  000ba	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  000bd	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  000c0	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000c3	c1 e1 03	 shl	 ecx, 3
  000c6	d3 e2		 shl	 edx, cl
  000c8	0b 55 f8	 or	 edx, DWORD PTR _X0$[ebp]
  000cb	89 55 f8	 mov	 DWORD PTR _X0$[ebp], edx

; 102  : 		X1 |= (gst_udword)key[i + 4] << (i * 8);

  000ce	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  000d1	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  000d4	0f b6 50 04	 movzx	 edx, BYTE PTR [eax+4]
  000d8	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000db	c1 e1 03	 shl	 ecx, 3
  000de	d3 e2		 shl	 edx, cl
  000e0	0b 55 dc	 or	 edx, DWORD PTR _X1$[ebp]
  000e3	89 55 dc	 mov	 DWORD PTR _X1$[ebp], edx

; 103  : 		X2 |= (gst_udword)key[i + 8] << (i * 8);

  000e6	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  000e9	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  000ec	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  000f0	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  000f3	c1 e1 03	 shl	 ecx, 3
  000f6	d3 e2		 shl	 edx, cl
  000f8	0b 55 e0	 or	 edx, DWORD PTR _X2$[ebp]
  000fb	89 55 e0	 mov	 DWORD PTR _X2$[ebp], edx

; 104  : 		X3 |= (gst_udword)key[i + 12] << (i * 8);

  000fe	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00101	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  00104	0f b6 50 0c	 movzx	 edx, BYTE PTR [eax+12]
  00108	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0010b	c1 e1 03	 shl	 ecx, 3
  0010e	d3 e2		 shl	 edx, cl
  00110	0b 55 ec	 or	 edx, DWORD PTR _X3$[ebp]
  00113	89 55 ec	 mov	 DWORD PTR _X3$[ebp], edx

; 105  : 		X4 |= (gst_udword)key[i + 16] << (i * 8);

  00116	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00119	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  0011c	0f b6 50 10	 movzx	 edx, BYTE PTR [eax+16]
  00120	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00123	c1 e1 03	 shl	 ecx, 3
  00126	d3 e2		 shl	 edx, cl
  00128	0b 55 d8	 or	 edx, DWORD PTR _X4$[ebp]
  0012b	89 55 d8	 mov	 DWORD PTR _X4$[ebp], edx

; 106  : 		X5 |= (gst_udword)key[i + 20] << (i * 8);

  0012e	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00131	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  00134	0f b6 50 14	 movzx	 edx, BYTE PTR [eax+20]
  00138	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0013b	c1 e1 03	 shl	 ecx, 3
  0013e	d3 e2		 shl	 edx, cl
  00140	0b 55 fc	 or	 edx, DWORD PTR _X5$[ebp]
  00143	89 55 fc	 mov	 DWORD PTR _X5$[ebp], edx

; 107  : 		X6 |= (gst_udword)key[i + 24] << (i * 8);

  00146	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00149	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  0014c	0f b6 50 18	 movzx	 edx, BYTE PTR [eax+24]
  00150	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00153	c1 e1 03	 shl	 ecx, 3
  00156	d3 e2		 shl	 edx, cl
  00158	0b 55 f0	 or	 edx, DWORD PTR _X6$[ebp]
  0015b	89 55 f0	 mov	 DWORD PTR _X6$[ebp], edx

; 108  : 		X7 |= (gst_udword)key[i + 28] << (i * 8);

  0015e	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  00161	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  00164	0f b6 50 1c	 movzx	 edx, BYTE PTR [eax+28]
  00168	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0016b	c1 e1 03	 shl	 ecx, 3
  0016e	d3 e2		 shl	 edx, cl
  00170	0b 55 e4	 or	 edx, DWORD PTR _X7$[ebp]
  00173	89 55 e4	 mov	 DWORD PTR _X7$[ebp], edx

; 109  : 	}

  00176	e9 29 ff ff ff	 jmp	 $LN2@gost_encry
$LN1@gost_encry:

; 110  : 
; 111  : 	/* Encryption rounds 1-24 */
; 112  : 	n2 = r(n1, n2, X0);

  0017b	8b 45 f8	 mov	 eax, DWORD PTR _X0$[ebp]
  0017e	50		 push	 eax
  0017f	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  00182	51		 push	 ecx
  00183	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  00186	52		 push	 edx
  00187	e8 00 00 00 00	 call	 _r@12
  0018c	89 45 d4	 mov	 DWORD PTR _n2$[ebp], eax

; 113  : 	n1 = r(n2, n1, X1);

  0018f	8b 45 dc	 mov	 eax, DWORD PTR _X1$[ebp]
  00192	50		 push	 eax
  00193	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  00196	51		 push	 ecx
  00197	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  0019a	52		 push	 edx
  0019b	e8 00 00 00 00	 call	 _r@12
  001a0	89 45 e8	 mov	 DWORD PTR _n1$[ebp], eax

; 114  : 	n2 = r(n1, n2, X2);

  001a3	8b 45 e0	 mov	 eax, DWORD PTR _X2$[ebp]
  001a6	50		 push	 eax
  001a7	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  001aa	51		 push	 ecx
  001ab	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  001ae	52		 push	 edx
  001af	e8 00 00 00 00	 call	 _r@12
  001b4	89 45 d4	 mov	 DWORD PTR _n2$[ebp], eax

; 115  : 	n1 = r(n2, n1, X3);

  001b7	8b 45 ec	 mov	 eax, DWORD PTR _X3$[ebp]
  001ba	50		 push	 eax
  001bb	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  001be	51		 push	 ecx
  001bf	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  001c2	52		 push	 edx
  001c3	e8 00 00 00 00	 call	 _r@12
  001c8	89 45 e8	 mov	 DWORD PTR _n1$[ebp], eax

; 116  : 	n2 = r(n1, n2, X4);

  001cb	8b 45 d8	 mov	 eax, DWORD PTR _X4$[ebp]
  001ce	50		 push	 eax
  001cf	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  001d2	51		 push	 ecx
  001d3	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  001d6	52		 push	 edx
  001d7	e8 00 00 00 00	 call	 _r@12
  001dc	89 45 d4	 mov	 DWORD PTR _n2$[ebp], eax

; 117  : 	n1 = r(n2, n1, X5);

  001df	8b 45 fc	 mov	 eax, DWORD PTR _X5$[ebp]
  001e2	50		 push	 eax
  001e3	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  001e6	51		 push	 ecx
  001e7	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  001ea	52		 push	 edx
  001eb	e8 00 00 00 00	 call	 _r@12
  001f0	89 45 e8	 mov	 DWORD PTR _n1$[ebp], eax

; 118  : 	n2 = r(n1, n2, X6);

  001f3	8b 45 f0	 mov	 eax, DWORD PTR _X6$[ebp]
  001f6	50		 push	 eax
  001f7	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  001fa	51		 push	 ecx
  001fb	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  001fe	52		 push	 edx
  001ff	e8 00 00 00 00	 call	 _r@12
  00204	89 45 d4	 mov	 DWORD PTR _n2$[ebp], eax

; 119  : 	n1 = r(n2, n1, X7);

  00207	8b 45 e4	 mov	 eax, DWORD PTR _X7$[ebp]
  0020a	50		 push	 eax
  0020b	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  0020e	51		 push	 ecx
  0020f	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  00212	52		 push	 edx
  00213	e8 00 00 00 00	 call	 _r@12
  00218	89 45 e8	 mov	 DWORD PTR _n1$[ebp], eax

; 120  : 	
; 121  : 	n2 = r(n1, n2, X0);

  0021b	8b 45 f8	 mov	 eax, DWORD PTR _X0$[ebp]
  0021e	50		 push	 eax
  0021f	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  00222	51		 push	 ecx
  00223	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  00226	52		 push	 edx
  00227	e8 00 00 00 00	 call	 _r@12
  0022c	89 45 d4	 mov	 DWORD PTR _n2$[ebp], eax

; 122  : 	n1 = r(n2, n1, X1);

  0022f	8b 45 dc	 mov	 eax, DWORD PTR _X1$[ebp]
  00232	50		 push	 eax
  00233	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  00236	51		 push	 ecx
  00237	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  0023a	52		 push	 edx
  0023b	e8 00 00 00 00	 call	 _r@12
  00240	89 45 e8	 mov	 DWORD PTR _n1$[ebp], eax

; 123  : 	n2 = r(n1, n2, X2);

  00243	8b 45 e0	 mov	 eax, DWORD PTR _X2$[ebp]
  00246	50		 push	 eax
  00247	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  0024a	51		 push	 ecx
  0024b	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  0024e	52		 push	 edx
  0024f	e8 00 00 00 00	 call	 _r@12
  00254	89 45 d4	 mov	 DWORD PTR _n2$[ebp], eax

; 124  : 	n1 = r(n2, n1, X3);

  00257	8b 45 ec	 mov	 eax, DWORD PTR _X3$[ebp]
  0025a	50		 push	 eax
  0025b	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  0025e	51		 push	 ecx
  0025f	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  00262	52		 push	 edx
  00263	e8 00 00 00 00	 call	 _r@12
  00268	89 45 e8	 mov	 DWORD PTR _n1$[ebp], eax

; 125  : 	n2 = r(n1, n2, X4);

  0026b	8b 45 d8	 mov	 eax, DWORD PTR _X4$[ebp]
  0026e	50		 push	 eax
  0026f	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  00272	51		 push	 ecx
  00273	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  00276	52		 push	 edx
  00277	e8 00 00 00 00	 call	 _r@12
  0027c	89 45 d4	 mov	 DWORD PTR _n2$[ebp], eax

; 126  : 	n1 = r(n2, n1, X5);

  0027f	8b 45 fc	 mov	 eax, DWORD PTR _X5$[ebp]
  00282	50		 push	 eax
  00283	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  00286	51		 push	 ecx
  00287	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  0028a	52		 push	 edx
  0028b	e8 00 00 00 00	 call	 _r@12
  00290	89 45 e8	 mov	 DWORD PTR _n1$[ebp], eax

; 127  : 	n2 = r(n1, n2, X6);

  00293	8b 45 f0	 mov	 eax, DWORD PTR _X6$[ebp]
  00296	50		 push	 eax
  00297	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  0029a	51		 push	 ecx
  0029b	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  0029e	52		 push	 edx
  0029f	e8 00 00 00 00	 call	 _r@12
  002a4	89 45 d4	 mov	 DWORD PTR _n2$[ebp], eax

; 128  : 	n1 = r(n2, n1, X7);

  002a7	8b 45 e4	 mov	 eax, DWORD PTR _X7$[ebp]
  002aa	50		 push	 eax
  002ab	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  002ae	51		 push	 ecx
  002af	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  002b2	52		 push	 edx
  002b3	e8 00 00 00 00	 call	 _r@12
  002b8	89 45 e8	 mov	 DWORD PTR _n1$[ebp], eax

; 129  : 
; 130  : 	n2 = r(n1, n2, X0);

  002bb	8b 45 f8	 mov	 eax, DWORD PTR _X0$[ebp]
  002be	50		 push	 eax
  002bf	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  002c2	51		 push	 ecx
  002c3	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  002c6	52		 push	 edx
  002c7	e8 00 00 00 00	 call	 _r@12
  002cc	89 45 d4	 mov	 DWORD PTR _n2$[ebp], eax

; 131  : 	n1 = r(n2, n1, X1);

  002cf	8b 45 dc	 mov	 eax, DWORD PTR _X1$[ebp]
  002d2	50		 push	 eax
  002d3	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  002d6	51		 push	 ecx
  002d7	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  002da	52		 push	 edx
  002db	e8 00 00 00 00	 call	 _r@12
  002e0	89 45 e8	 mov	 DWORD PTR _n1$[ebp], eax

; 132  : 	n2 = r(n1, n2, X2);

  002e3	8b 45 e0	 mov	 eax, DWORD PTR _X2$[ebp]
  002e6	50		 push	 eax
  002e7	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  002ea	51		 push	 ecx
  002eb	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  002ee	52		 push	 edx
  002ef	e8 00 00 00 00	 call	 _r@12
  002f4	89 45 d4	 mov	 DWORD PTR _n2$[ebp], eax

; 133  : 	n1 = r(n2, n1, X3);

  002f7	8b 45 ec	 mov	 eax, DWORD PTR _X3$[ebp]
  002fa	50		 push	 eax
  002fb	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  002fe	51		 push	 ecx
  002ff	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  00302	52		 push	 edx
  00303	e8 00 00 00 00	 call	 _r@12
  00308	89 45 e8	 mov	 DWORD PTR _n1$[ebp], eax

; 134  : 	n2 = r(n1, n2, X4);

  0030b	8b 45 d8	 mov	 eax, DWORD PTR _X4$[ebp]
  0030e	50		 push	 eax
  0030f	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  00312	51		 push	 ecx
  00313	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  00316	52		 push	 edx
  00317	e8 00 00 00 00	 call	 _r@12
  0031c	89 45 d4	 mov	 DWORD PTR _n2$[ebp], eax

; 135  : 	n1 = r(n2, n1, X5);

  0031f	8b 45 fc	 mov	 eax, DWORD PTR _X5$[ebp]
  00322	50		 push	 eax
  00323	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  00326	51		 push	 ecx
  00327	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  0032a	52		 push	 edx
  0032b	e8 00 00 00 00	 call	 _r@12
  00330	89 45 e8	 mov	 DWORD PTR _n1$[ebp], eax

; 136  : 	n2 = r(n1, n2, X6);

  00333	8b 45 f0	 mov	 eax, DWORD PTR _X6$[ebp]
  00336	50		 push	 eax
  00337	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  0033a	51		 push	 ecx
  0033b	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  0033e	52		 push	 edx
  0033f	e8 00 00 00 00	 call	 _r@12
  00344	89 45 d4	 mov	 DWORD PTR _n2$[ebp], eax

; 137  : 	n1 = r(n2, n1, X7);

  00347	8b 45 e4	 mov	 eax, DWORD PTR _X7$[ebp]
  0034a	50		 push	 eax
  0034b	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  0034e	51		 push	 ecx
  0034f	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  00352	52		 push	 edx
  00353	e8 00 00 00 00	 call	 _r@12
  00358	89 45 e8	 mov	 DWORD PTR _n1$[ebp], eax

; 138  : 
; 139  : 	/* Encryption rounds 25-32 */
; 140  : 	n2 = r(n1, n2, X7);

  0035b	8b 45 e4	 mov	 eax, DWORD PTR _X7$[ebp]
  0035e	50		 push	 eax
  0035f	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  00362	51		 push	 ecx
  00363	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  00366	52		 push	 edx
  00367	e8 00 00 00 00	 call	 _r@12
  0036c	89 45 d4	 mov	 DWORD PTR _n2$[ebp], eax

; 141  : 	n1 = r(n2, n1, X6);

  0036f	8b 45 f0	 mov	 eax, DWORD PTR _X6$[ebp]
  00372	50		 push	 eax
  00373	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  00376	51		 push	 ecx
  00377	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  0037a	52		 push	 edx
  0037b	e8 00 00 00 00	 call	 _r@12
  00380	89 45 e8	 mov	 DWORD PTR _n1$[ebp], eax

; 142  : 	n2 = r(n1, n2, X5);

  00383	8b 45 fc	 mov	 eax, DWORD PTR _X5$[ebp]
  00386	50		 push	 eax
  00387	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  0038a	51		 push	 ecx
  0038b	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  0038e	52		 push	 edx
  0038f	e8 00 00 00 00	 call	 _r@12
  00394	89 45 d4	 mov	 DWORD PTR _n2$[ebp], eax

; 143  : 	n1 = r(n2, n1, X4);

  00397	8b 45 d8	 mov	 eax, DWORD PTR _X4$[ebp]
  0039a	50		 push	 eax
  0039b	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  0039e	51		 push	 ecx
  0039f	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  003a2	52		 push	 edx
  003a3	e8 00 00 00 00	 call	 _r@12
  003a8	89 45 e8	 mov	 DWORD PTR _n1$[ebp], eax

; 144  : 	n2 = r(n1, n2, X3);

  003ab	8b 45 ec	 mov	 eax, DWORD PTR _X3$[ebp]
  003ae	50		 push	 eax
  003af	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  003b2	51		 push	 ecx
  003b3	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  003b6	52		 push	 edx
  003b7	e8 00 00 00 00	 call	 _r@12
  003bc	89 45 d4	 mov	 DWORD PTR _n2$[ebp], eax

; 145  : 	n1 = r(n2, n1, X2);

  003bf	8b 45 e0	 mov	 eax, DWORD PTR _X2$[ebp]
  003c2	50		 push	 eax
  003c3	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  003c6	51		 push	 ecx
  003c7	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  003ca	52		 push	 edx
  003cb	e8 00 00 00 00	 call	 _r@12
  003d0	89 45 e8	 mov	 DWORD PTR _n1$[ebp], eax

; 146  : 	n2 = r(n1, n2, X1);

  003d3	8b 45 dc	 mov	 eax, DWORD PTR _X1$[ebp]
  003d6	50		 push	 eax
  003d7	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  003da	51		 push	 ecx
  003db	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  003de	52		 push	 edx
  003df	e8 00 00 00 00	 call	 _r@12
  003e4	89 45 d4	 mov	 DWORD PTR _n2$[ebp], eax

; 147  : 	n1 = r(n2, n1, X0);

  003e7	8b 45 f8	 mov	 eax, DWORD PTR _X0$[ebp]
  003ea	50		 push	 eax
  003eb	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  003ee	51		 push	 ecx
  003ef	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  003f2	52		 push	 edx
  003f3	e8 00 00 00 00	 call	 _r@12
  003f8	89 45 e8	 mov	 DWORD PTR _n1$[ebp], eax

; 148  : 
; 149  : 	out[0] = (byte)(n2 & 0xFF); out[1] = (byte)((n2 >> 8) & 0xFF); out[2] = (byte)((n2 >> 16) & 0xFF); out[3] = (byte)((n2 >> 24) & 0xFF);

  003fb	8b 45 d4	 mov	 eax, DWORD PTR _n2$[ebp]
  003fe	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00403	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  00406	88 01		 mov	 BYTE PTR [ecx], al
  00408	8b 55 d4	 mov	 edx, DWORD PTR _n2$[ebp]
  0040b	c1 ea 08	 shr	 edx, 8
  0040e	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00414	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00417	88 50 01	 mov	 BYTE PTR [eax+1], dl
  0041a	8b 4d d4	 mov	 ecx, DWORD PTR _n2$[ebp]
  0041d	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00420	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00426	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  00429	88 4a 02	 mov	 BYTE PTR [edx+2], cl
  0042c	8b 45 d4	 mov	 eax, DWORD PTR _n2$[ebp]
  0042f	c1 e8 18	 shr	 eax, 24			; 00000018H
  00432	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00437	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  0043a	88 41 03	 mov	 BYTE PTR [ecx+3], al

; 150  : 	out[4] = (byte)(n1 & 0xFF); out[5] = (byte)((n1 >> 8) & 0xFF); out[6] = (byte)((n1 >> 16) & 0xFF); out[7] = (byte)((n1 >> 24) & 0xFF);

  0043d	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  00440	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00446	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00449	88 50 04	 mov	 BYTE PTR [eax+4], dl
  0044c	8b 4d e8	 mov	 ecx, DWORD PTR _n1$[ebp]
  0044f	c1 e9 08	 shr	 ecx, 8
  00452	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00458	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  0045b	88 4a 05	 mov	 BYTE PTR [edx+5], cl
  0045e	8b 45 e8	 mov	 eax, DWORD PTR _n1$[ebp]
  00461	c1 e8 10	 shr	 eax, 16			; 00000010H
  00464	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00469	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  0046c	88 41 06	 mov	 BYTE PTR [ecx+6], al
  0046f	8b 55 e8	 mov	 edx, DWORD PTR _n1$[ebp]
  00472	c1 ea 18	 shr	 edx, 24			; 00000018H
  00475	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0047b	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  0047e	88 50 07	 mov	 BYTE PTR [eax+7], dl

; 151  : }

  00481	8b e5		 mov	 esp, ebp
  00483	5d		 pop	 ebp
  00484	c2 0c 00	 ret	 12			; 0000000cH
_gost_encrypt_with_key@12 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _r@12
_TEXT	SEGMENT
_sbox$ = -4						; size = 4
_n1$ = 8						; size = 4
_n2$ = 12						; size = 4
_X$ = 16						; size = 4
_r@12	PROC						; COMDAT

; 58   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 59   : 	gosthash_s_box *sbox = &GostR3411_94_CryptoProParamSet;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _sbox$[ebp], OFFSET _GostR3411_94_CryptoProParamSet

; 60   : 	n1 += X;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _n1$[ebp]
  00010	03 45 10	 add	 eax, DWORD PTR _X$[ebp]
  00013	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax

; 61   : 	n1 =  (gst_udword)sbox->k8[(n1>>28)&0xF]<<28 | (gst_udword)sbox->k7[(n1>>24)&0xF]<<24
; 62   : 				| (gst_udword)sbox->k6[(n1>>20)&0xF]<<20 | (gst_udword)sbox->k5[(n1>>16)&0xF]<<16
; 63   : 				| (gst_udword)sbox->k4[(n1>>12)&0xF]<<12 | (gst_udword)sbox->k3[(n1>>8)&0xF]<<8
; 64   : 				| (gst_udword)sbox->k2[(n1>>4)&0xF]<<4 | (gst_udword)sbox->k1[n1&0xF];

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _n1$[ebp]
  00019	c1 e9 1c	 shr	 ecx, 28			; 0000001cH
  0001c	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _sbox$[ebp]
  00022	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00026	c1 e0 1c	 shl	 eax, 28			; 0000001cH
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _n1$[ebp]
  0002c	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0002f	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00032	8b 55 fc	 mov	 edx, DWORD PTR _sbox$[ebp]
  00035	0f b6 4c 0a 10	 movzx	 ecx, BYTE PTR [edx+ecx+16]
  0003a	c1 e1 18	 shl	 ecx, 24			; 00000018H
  0003d	0b c1		 or	 eax, ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR _n1$[ebp]
  00042	c1 ea 14	 shr	 edx, 20			; 00000014H
  00045	83 e2 0f	 and	 edx, 15			; 0000000fH
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _sbox$[ebp]
  0004b	0f b6 54 11 20	 movzx	 edx, BYTE PTR [ecx+edx+32]
  00050	c1 e2 14	 shl	 edx, 20			; 00000014H
  00053	0b c2		 or	 eax, edx
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _n1$[ebp]
  00058	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0005b	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _sbox$[ebp]
  00061	0f b6 4c 0a 30	 movzx	 ecx, BYTE PTR [edx+ecx+48]
  00066	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00069	0b c1		 or	 eax, ecx
  0006b	8b 55 08	 mov	 edx, DWORD PTR _n1$[ebp]
  0006e	c1 ea 0c	 shr	 edx, 12			; 0000000cH
  00071	83 e2 0f	 and	 edx, 15			; 0000000fH
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _sbox$[ebp]
  00077	0f b6 54 11 40	 movzx	 edx, BYTE PTR [ecx+edx+64]
  0007c	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  0007f	0b c2		 or	 eax, edx
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _n1$[ebp]
  00084	c1 e9 08	 shr	 ecx, 8
  00087	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0008a	8b 55 fc	 mov	 edx, DWORD PTR _sbox$[ebp]
  0008d	0f b6 4c 0a 50	 movzx	 ecx, BYTE PTR [edx+ecx+80]
  00092	c1 e1 08	 shl	 ecx, 8
  00095	0b c1		 or	 eax, ecx
  00097	8b 55 08	 mov	 edx, DWORD PTR _n1$[ebp]
  0009a	c1 ea 04	 shr	 edx, 4
  0009d	83 e2 0f	 and	 edx, 15			; 0000000fH
  000a0	8b 4d fc	 mov	 ecx, DWORD PTR _sbox$[ebp]
  000a3	0f b6 54 11 60	 movzx	 edx, BYTE PTR [ecx+edx+96]
  000a8	c1 e2 04	 shl	 edx, 4
  000ab	0b c2		 or	 eax, edx
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _n1$[ebp]
  000b0	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000b3	8b 55 fc	 mov	 edx, DWORD PTR _sbox$[ebp]
  000b6	0f b6 4c 0a 70	 movzx	 ecx, BYTE PTR [edx+ecx+112]
  000bb	0b c1		 or	 eax, ecx
  000bd	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax

; 65   : 	n1 = gosthash_rotl32(n1, 11);

  000c0	8b 55 08	 mov	 edx, DWORD PTR _n1$[ebp]
  000c3	c1 e2 0b	 shl	 edx, 11			; 0000000bH
  000c6	8b 45 08	 mov	 eax, DWORD PTR _n1$[ebp]
  000c9	c1 e8 15	 shr	 eax, 21			; 00000015H
  000cc	0b d0		 or	 edx, eax
  000ce	89 55 08	 mov	 DWORD PTR _n1$[ebp], edx

; 66   : 	n2 ^= n1;

  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR _n2$[ebp]
  000d4	33 4d 08	 xor	 ecx, DWORD PTR _n1$[ebp]
  000d7	89 4d 0c	 mov	 DWORD PTR _n2$[ebp], ecx

; 67   : 	return n2;

  000da	8b 45 0c	 mov	 eax, DWORD PTR _n2$[ebp]

; 68   : }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c2 0c 00	 ret	 12			; 0000000cH
_r@12	ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _xor_blocks@16
_TEXT	SEGMENT
_i$ = -4						; size = 4
_T$ = 8							; size = 4
_F$ = 12						; size = 4
_S$ = 16						; size = 4
_len$ = 20						; size = 4
_xor_blocks@16 PROC					; COMDAT

; 246  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 247  : 	gst_dword i;
; 248  : 	for (i = 0; i < len; i++)

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN3@xor_blocks
$LN2@xor_blocks:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@xor_blocks:
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001b	3b 4d 14	 cmp	 ecx, DWORD PTR _len$[ebp]
  0001e	7d 1e		 jge	 SHORT $LN4@xor_blocks

; 249  : 		T[i] = F[i] ^ S[i];

  00020	8b 55 0c	 mov	 edx, DWORD PTR _F$[ebp]
  00023	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00026	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00029	8b 4d 10	 mov	 ecx, DWORD PTR _S$[ebp]
  0002c	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  0002f	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00032	33 c2		 xor	 eax, edx
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _T$[ebp]
  00037	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  0003a	88 01		 mov	 BYTE PTR [ecx], al
  0003c	eb d1		 jmp	 SHORT $LN2@xor_blocks
$LN4@xor_blocks:

; 250  : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 10 00	 ret	 16			; 00000010H
_xor_blocks@16 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _P_transform@8
_TEXT	SEGMENT
_k$ = -8						; size = 4
_i$ = -4						; size = 4
_F$ = 8							; size = 4
_T$ = 12						; size = 4
_P_transform@8 PROC					; COMDAT

; 268  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8
  00008	56		 push	 esi

; 269  : 	gst_dword i, k;
; 270  : 	for (i = 0; i < 4; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN6@P_transfor
$LN5@P_transfor:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN6@P_transfor:
  0001b	83 7d fc 04	 cmp	 DWORD PTR _i$[ebp], 4
  0001f	7d 3a		 jge	 SHORT $LN7@P_transfor

; 271  : 		for (k = 0; k < 8; k++)

  00021	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  00028	eb 09		 jmp	 SHORT $LN3@P_transfor
$LN2@P_transfor:
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _k$[ebp]
  0002d	83 c1 01	 add	 ecx, 1
  00030	89 4d f8	 mov	 DWORD PTR _k$[ebp], ecx
$LN3@P_transfor:
  00033	83 7d f8 08	 cmp	 DWORD PTR _k$[ebp], 8
  00037	7d 20		 jge	 SHORT $LN1@P_transfor

; 272  : 			T[i+4*k] = F[8*i+k];

  00039	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0003c	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  0003f	8d 0c d0	 lea	 ecx, DWORD PTR [eax+edx*8]
  00042	8b 55 f8	 mov	 edx, DWORD PTR _k$[ebp]
  00045	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00048	8d 14 90	 lea	 edx, DWORD PTR [eax+edx*4]
  0004b	8b 45 0c	 mov	 eax, DWORD PTR _T$[ebp]
  0004e	8b 75 08	 mov	 esi, DWORD PTR _F$[ebp]
  00051	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  00054	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  00057	eb d1		 jmp	 SHORT $LN2@P_transfor
$LN1@P_transfor:
  00059	eb b7		 jmp	 SHORT $LN5@P_transfor
$LN7@P_transfor:

; 273  : }

  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 08 00	 ret	 8
_P_transform@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _A@8
_TEXT	SEGMENT
_i$ = -1						; size = 1
_F$ = 8							; size = 4
_T$ = 12						; size = 4
_A@8	PROC						; COMDAT

; 288  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx
  00006	56		 push	 esi

; 289  : 	byte i;
; 290  : 	for (i = 0; i < 24; i++)

  00007	c6 45 ff 00	 mov	 BYTE PTR _i$[ebp], 0
  0000b	eb 08		 jmp	 SHORT $LN6@A
$LN5@A:
  0000d	8a 45 ff	 mov	 al, BYTE PTR _i$[ebp]
  00010	04 01		 add	 al, 1
  00012	88 45 ff	 mov	 BYTE PTR _i$[ebp], al
$LN6@A:
  00015	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$[ebp]
  00019	83 f9 18	 cmp	 ecx, 24			; 00000018H
  0001c	7d 17		 jge	 SHORT $LN4@A

; 291  : 		T[i] = F[i+8];

  0001e	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  00022	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _T$[ebp]
  00029	8b 75 08	 mov	 esi, DWORD PTR _F$[ebp]
  0002c	8a 54 16 08	 mov	 dl, BYTE PTR [esi+edx+8]
  00030	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  00033	eb d8		 jmp	 SHORT $LN5@A
$LN4@A:

; 292  : 	for (i = 0; i < 8; i++)

  00035	c6 45 ff 00	 mov	 BYTE PTR _i$[ebp], 0
  00039	eb 08		 jmp	 SHORT $LN3@A
$LN2@A:
  0003b	8a 45 ff	 mov	 al, BYTE PTR _i$[ebp]
  0003e	04 01		 add	 al, 1
  00040	88 45 ff	 mov	 BYTE PTR _i$[ebp], al
$LN3@A:
  00043	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$[ebp]
  00047	83 f9 08	 cmp	 ecx, 8
  0004a	7d 26		 jge	 SHORT $LN7@A

; 293  : 		T[i+24] = F[i] ^ F[i+8];

  0004c	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  00050	8b 45 08	 mov	 eax, DWORD PTR _F$[ebp]
  00053	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00057	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  0005b	8b 45 08	 mov	 eax, DWORD PTR _F$[ebp]
  0005e	0f b6 54 10 08	 movzx	 edx, BYTE PTR [eax+edx+8]
  00063	33 ca		 xor	 ecx, edx
  00065	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  00069	8b 55 0c	 mov	 edx, DWORD PTR _T$[ebp]
  0006c	88 4c 02 18	 mov	 BYTE PTR [edx+eax+24], cl
  00070	eb c9		 jmp	 SHORT $LN2@A
$LN7@A:

; 294  : }

  00072	5e		 pop	 esi
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 08 00	 ret	 8
_A@8	ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _PSI@4
_TEXT	SEGMENT
_T$ = -4						; size = 2
_X$ = 8							; size = 4
_PSI@4	PROC						; COMDAT

; 305  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 306  : 	gst_word T;
; 307  : 
; 308  : 	T = (gst_word)(X[0]^X[2]^X[4]^X[6]^X[24]^X[30])|
; 309  : 		((gst_word)(X[1]^X[3]^X[5]^X[7]^X[25]^X[31])<<8);

  00006	8b 45 08	 mov	 eax, DWORD PTR _X$[ebp]
  00009	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0000c	8b 55 08	 mov	 edx, DWORD PTR _X$[ebp]
  0000f	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00013	33 c8		 xor	 ecx, eax
  00015	8b 55 08	 mov	 edx, DWORD PTR _X$[ebp]
  00018	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	8b 55 08	 mov	 edx, DWORD PTR _X$[ebp]
  00021	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  00025	33 c8		 xor	 ecx, eax
  00027	8b 55 08	 mov	 edx, DWORD PTR _X$[ebp]
  0002a	0f b6 42 18	 movzx	 eax, BYTE PTR [edx+24]
  0002e	33 c8		 xor	 ecx, eax
  00030	8b 55 08	 mov	 edx, DWORD PTR _X$[ebp]
  00033	0f b6 42 1e	 movzx	 eax, BYTE PTR [edx+30]
  00037	33 c8		 xor	 ecx, eax
  00039	0f bf c9	 movsx	 ecx, cx
  0003c	8b 55 08	 mov	 edx, DWORD PTR _X$[ebp]
  0003f	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  00043	8b 55 08	 mov	 edx, DWORD PTR _X$[ebp]
  00046	0f b6 52 03	 movzx	 edx, BYTE PTR [edx+3]
  0004a	33 c2		 xor	 eax, edx
  0004c	8b 55 08	 mov	 edx, DWORD PTR _X$[ebp]
  0004f	0f b6 52 05	 movzx	 edx, BYTE PTR [edx+5]
  00053	33 c2		 xor	 eax, edx
  00055	8b 55 08	 mov	 edx, DWORD PTR _X$[ebp]
  00058	0f b6 52 07	 movzx	 edx, BYTE PTR [edx+7]
  0005c	33 c2		 xor	 eax, edx
  0005e	8b 55 08	 mov	 edx, DWORD PTR _X$[ebp]
  00061	0f b6 52 19	 movzx	 edx, BYTE PTR [edx+25]
  00065	33 c2		 xor	 eax, edx
  00067	8b 55 08	 mov	 edx, DWORD PTR _X$[ebp]
  0006a	0f b6 52 1f	 movzx	 edx, BYTE PTR [edx+31]
  0006e	33 c2		 xor	 eax, edx
  00070	98		 cwde
  00071	c1 e0 08	 shl	 eax, 8
  00074	0b c8		 or	 ecx, eax
  00076	66 89 4d fc	 mov	 WORD PTR _T$[ebp], cx

; 310  : 	move_blocks(X, X+2, 30);

  0007a	6a 1e		 push	 30			; 0000001eH
  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _X$[ebp]
  0007f	83 c1 02	 add	 ecx, 2
  00082	51		 push	 ecx
  00083	8b 55 08	 mov	 edx, DWORD PTR _X$[ebp]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 _move_blocks@12

; 311  : 	X[30] = (byte)(T&0xFF);

  0008c	0f bf 45 fc	 movsx	 eax, WORD PTR _T$[ebp]
  00090	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00095	8b 4d 08	 mov	 ecx, DWORD PTR _X$[ebp]
  00098	88 41 1e	 mov	 BYTE PTR [ecx+30], al

; 312  : 	X[31] = (byte)(T>>8);

  0009b	0f bf 55 fc	 movsx	 edx, WORD PTR _T$[ebp]
  0009f	c1 fa 08	 sar	 edx, 8
  000a2	8b 45 08	 mov	 eax, DWORD PTR _X$[ebp]
  000a5	88 50 1f	 mov	 BYTE PTR [eax+31], dl

; 313  : }

  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c2 04 00	 ret	 4
_PSI@4	ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _move_blocks@12
_TEXT	SEGMENT
_i$ = -4						; size = 4
_to$ = 8						; size = 4
_from$ = 12						; size = 4
_len$ = 16						; size = 4
_move_blocks@12 PROC					; COMDAT

; 183  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 184  : 	gst_dword i;
; 185  : 	if (from < to)

  00006	8b 45 0c	 mov	 eax, DWORD PTR _from$[ebp]
  00009	3b 45 08	 cmp	 eax, DWORD PTR _to$[ebp]
  0000c	73 2e		 jae	 SHORT $LN8@move_block

; 186  : 		for (i = len-1; i >= 0; i--)

  0000e	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  00011	83 e9 01	 sub	 ecx, 1
  00014	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  00017	eb 09		 jmp	 SHORT $LN7@move_block
$LN6@move_block:
  00019	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0001c	83 ea 01	 sub	 edx, 1
  0001f	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN7@move_block:
  00022	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00026	7c 12		 jl	 SHORT $LN5@move_block

; 187  : 			to[i] = from[i];

  00028	8b 45 08	 mov	 eax, DWORD PTR _to$[ebp]
  0002b	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _from$[ebp]
  00031	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00034	8a 11		 mov	 dl, BYTE PTR [ecx]
  00036	88 10		 mov	 BYTE PTR [eax], dl
  00038	eb df		 jmp	 SHORT $LN6@move_block
$LN5@move_block:

; 188  : 	else

  0003a	eb 2c		 jmp	 SHORT $LN9@move_block
$LN8@move_block:

; 189  : 		for (i = 0; i < len; i++)

  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00043	eb 09		 jmp	 SHORT $LN3@move_block
$LN2@move_block:
  00045	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00048	83 c0 01	 add	 eax, 1
  0004b	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@move_block:
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00051	3b 4d 10	 cmp	 ecx, DWORD PTR _len$[ebp]
  00054	7d 12		 jge	 SHORT $LN9@move_block

; 190  : 			to[i] = from[i];

  00056	8b 55 08	 mov	 edx, DWORD PTR _to$[ebp]
  00059	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0005c	8b 45 0c	 mov	 eax, DWORD PTR _from$[ebp]
  0005f	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00062	8a 08		 mov	 cl, BYTE PTR [eax]
  00064	88 0a		 mov	 BYTE PTR [edx], cl
  00066	eb dd		 jmp	 SHORT $LN2@move_block
$LN9@move_block:

; 191  : }

  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 0c 00	 ret	 12			; 0000000cH
_move_blocks@12 ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_GOSTHASH_finalize@8
; Function compile flags: /Odtp
;	COMDAT _GOSTHASH_finalize@8
_TEXT	SEGMENT
_bptr$ = -108						; size = 4
_buf$ = -104						; size = 32
_final_len$ = -72					; size = 4
_S$ = -68						; size = 32
_H$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_ctx$ = 8						; size = 4
_out$ = 12						; size = 4
_GOSTHASH_finalize@8 PROC				; COMDAT

; 459  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 460  : 	byte buf[32];
; 461  : 	byte H[32];
; 462  : 	byte S[32];
; 463  : 	gst_dword final_len;
; 464  : 	gst_dword bptr;
; 465  : 
; 466  : 	final_len = ctx->len;

  00012	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	89 4d b8	 mov	 DWORD PTR _final_len$[ebp], ecx

; 467  : 	
; 468  : 	copy_blocks(H, ctx->H, 32);

  0001a	6a 20		 push	 32			; 00000020H
  0001c	8b 55 08	 mov	 edx, DWORD PTR _ctx$[ebp]
  0001f	83 c2 08	 add	 edx, 8
  00022	52		 push	 edx
  00023	8d 45 dc	 lea	 eax, DWORD PTR _H$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _copy_blocks@12

; 469  : 	copy_blocks(S, ctx->S, 32);

  0002c	6a 20		 push	 32			; 00000020H
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _ctx$[ebp]
  00031	83 c1 28	 add	 ecx, 40			; 00000028H
  00034	51		 push	 ecx
  00035	8d 55 bc	 lea	 edx, DWORD PTR _S$[ebp]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 _copy_blocks@12

; 470  : 
; 471  : 	if (ctx->left) //Handle any remaining bytes

  0003e	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  00041	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00045	74 50		 je	 SHORT $LN3@GOSTHASH_f

; 472  : 	{
; 473  : 		set_blocks(buf, 0, 32);

  00047	6a 20		 push	 32			; 00000020H
  00049	6a 00		 push	 0
  0004b	8d 4d 98	 lea	 ecx, DWORD PTR _buf$[ebp]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _set_blocks@12

; 474  : 		copy_blocks(buf, ctx->remainder, (gst_dword)ctx->left);

  00054	8b 55 08	 mov	 edx, DWORD PTR _ctx$[ebp]
  00057	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005a	50		 push	 eax
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _ctx$[ebp]
  0005e	83 c1 48	 add	 ecx, 72			; 00000048H
  00061	51		 push	 ecx
  00062	8d 55 98	 lea	 edx, DWORD PTR _buf$[ebp]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 _copy_blocks@12

; 475  : 		step (H, buf, ctx);

  0006b	8b 45 08	 mov	 eax, DWORD PTR _ctx$[ebp]
  0006e	50		 push	 eax
  0006f	8d 4d 98	 lea	 ecx, DWORD PTR _buf$[ebp]
  00072	51		 push	 ecx
  00073	8d 55 dc	 lea	 edx, DWORD PTR _H$[ebp]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 _step@12

; 476  : 		add_blocks (S, buf, 32);

  0007c	6a 20		 push	 32			; 00000020H
  0007e	8d 45 98	 lea	 eax, DWORD PTR _buf$[ebp]
  00081	50		 push	 eax
  00082	8d 4d bc	 lea	 ecx, DWORD PTR _S$[ebp]
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 _add_blocks@12

; 477  : 		final_len += ctx->left;

  0008b	8b 55 08	 mov	 edx, DWORD PTR _ctx$[ebp]
  0008e	8b 45 b8	 mov	 eax, DWORD PTR _final_len$[ebp]
  00091	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00094	89 45 b8	 mov	 DWORD PTR _final_len$[ebp], eax
$LN3@GOSTHASH_f:

; 478  : 	}
; 479  : 
; 480  : 	set_blocks(buf, 0, 32);

  00097	6a 20		 push	 32			; 00000020H
  00099	6a 00		 push	 0
  0009b	8d 4d 98	 lea	 ecx, DWORD PTR _buf$[ebp]
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 _set_blocks@12

; 481  : 	bptr = 0;

  000a4	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _bptr$[ebp], 0

; 482  : 	final_len <<= 3;

  000ab	8b 55 b8	 mov	 edx, DWORD PTR _final_len$[ebp]
  000ae	c1 e2 03	 shl	 edx, 3
  000b1	89 55 b8	 mov	 DWORD PTR _final_len$[ebp], edx
$LN2@GOSTHASH_f:

; 483  : 	while (final_len > 0)

  000b4	83 7d b8 00	 cmp	 DWORD PTR _final_len$[ebp], 0
  000b8	7e 23		 jle	 SHORT $LN1@GOSTHASH_f

; 484  : 	{
; 485  : 		buf[bptr++] = (byte)(final_len & 0xFF);

  000ba	8b 45 b8	 mov	 eax, DWORD PTR _final_len$[ebp]
  000bd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c2	8b 4d 94	 mov	 ecx, DWORD PTR _bptr$[ebp]
  000c5	88 44 0d 98	 mov	 BYTE PTR _buf$[ebp+ecx], al
  000c9	8b 55 94	 mov	 edx, DWORD PTR _bptr$[ebp]
  000cc	83 c2 01	 add	 edx, 1
  000cf	89 55 94	 mov	 DWORD PTR _bptr$[ebp], edx

; 486  : 		final_len >>= 8;

  000d2	8b 45 b8	 mov	 eax, DWORD PTR _final_len$[ebp]
  000d5	c1 f8 08	 sar	 eax, 8
  000d8	89 45 b8	 mov	 DWORD PTR _final_len$[ebp], eax

; 487  : 	}

  000db	eb d7		 jmp	 SHORT $LN2@GOSTHASH_f
$LN1@GOSTHASH_f:

; 488  : 
; 489  : 	step (H, buf, ctx);

  000dd	8b 4d 08	 mov	 ecx, DWORD PTR _ctx$[ebp]
  000e0	51		 push	 ecx
  000e1	8d 55 98	 lea	 edx, DWORD PTR _buf$[ebp]
  000e4	52		 push	 edx
  000e5	8d 45 dc	 lea	 eax, DWORD PTR _H$[ebp]
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 _step@12

; 490  : 	step (H, S, ctx);

  000ee	8b 4d 08	 mov	 ecx, DWORD PTR _ctx$[ebp]
  000f1	51		 push	 ecx
  000f2	8d 55 bc	 lea	 edx, DWORD PTR _S$[ebp]
  000f5	52		 push	 edx
  000f6	8d 45 dc	 lea	 eax, DWORD PTR _H$[ebp]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _step@12

; 491  : 	copy_blocks (out, H, 32);

  000ff	6a 20		 push	 32			; 00000020H
  00101	8d 4d dc	 lea	 ecx, DWORD PTR _H$[ebp]
  00104	51		 push	 ecx
  00105	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  00108	52		 push	 edx
  00109	e8 00 00 00 00	 call	 _copy_blocks@12

; 492  : }

  0010e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00111	33 cd		 xor	 ecx, ebp
  00113	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c2 08 00	 ret	 8
_GOSTHASH_finalize@8 ENDP
_TEXT	ENDS
END
