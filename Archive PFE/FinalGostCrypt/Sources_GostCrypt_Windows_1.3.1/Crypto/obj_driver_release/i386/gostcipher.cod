; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\crypto\gostcipher.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_GostR3411_94_CryptoProParamSet DD 01H
	DD	03H
	DD	0aH
	DD	09H
	DD	05H
	DD	0bH
	DD	04H
	DD	0fH
	DD	08H
	DD	06H
	DD	07H
	DD	0eH
	DD	0dH
	DD	00H
	DD	02H
	DD	0cH
	DD	0dH
	DD	0eH
	DD	04H
	DD	01H
	DD	07H
	DD	00H
	DD	05H
	DD	0aH
	DD	03H
	DD	0cH
	DD	08H
	DD	0fH
	DD	06H
	DD	02H
	DD	09H
	DD	0bH
	DD	07H
	DD	06H
	DD	02H
	DD	04H
	DD	0dH
	DD	09H
	DD	0fH
	DD	00H
	DD	0aH
	DD	01H
	DD	05H
	DD	0bH
	DD	08H
	DD	0eH
	DD	0cH
	DD	03H
	DD	07H
	DD	06H
	DD	04H
	DD	0bH
	DD	09H
	DD	0cH
	DD	02H
	DD	0aH
	DD	01H
	DD	08H
	DD	00H
	DD	0eH
	DD	0fH
	DD	0dH
	DD	03H
	DD	05H
	DD	04H
	DD	0aH
	DD	07H
	DD	0cH
	DD	00H
	DD	0fH
	DD	02H
	DD	08H
	DD	0eH
	DD	01H
	DD	06H
	DD	05H
	DD	0dH
	DD	0bH
	DD	09H
	DD	03H
	DD	07H
	DD	0fH
	DD	0cH
	DD	0eH
	DD	09H
	DD	04H
	DD	01H
	DD	00H
	DD	03H
	DD	0bH
	DD	05H
	DD	02H
	DD	06H
	DD	0aH
	DD	08H
	DD	0dH
	DD	05H
	DD	0fH
	DD	04H
	DD	00H
	DD	02H
	DD	0dH
	DD	0bH
	DD	09H
	DD	01H
	DD	07H
	DD	06H
	DD	03H
	DD	0cH
	DD	0eH
	DD	0aH
	DD	08H
	DD	0aH
	DD	04H
	DD	05H
	DD	06H
	DD	08H
	DD	01H
	DD	03H
	DD	07H
	DD	0dH
	DD	0cH
	DD	0eH
	DD	00H
	DD	09H
	DD	02H
	DD	0bH
	DD	0fH
; Function compile flags: /Ogsp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\crypto\gostcipher.c
_DATA	ENDS
;	COMDAT _xor_s_box@8
_TEXT	SEGMENT
_xor_s_box@8 PROC					; COMDAT
; _s_box$ = eax
; _seed$ = ecx

; 46   : {

  00000	8b ff		 npad	 2
  00002	56		 push	 esi
  00003	57		 push	 edi

; 47   :    int i;
; 48   :    for (i = 0; i < 16; i++)

  00004	6a 10		 push	 16			; 00000010H
  00006	5e		 pop	 esi
  00007	6a 0f		 push	 15			; 0000000fH
  00009	83 c1 02	 add	 ecx, 2
  0000c	05 80 01 00 00	 add	 eax, 384		; 00000180H
  00011	5a		 pop	 edx
$LL3@xor_s_box:

; 49   :    {
; 50   :       s_box->k1[i] ^= (seed[ (i * 4) + 0 ]   ) & 0xF;

  00012	0f b6 79 fe	 movzx	 edi, BYTE PTR [ecx-2]
  00016	23 fa		 and	 edi, edx
  00018	31 78 40	 xor	 DWORD PTR [eax+64], edi

; 51   :       s_box->k2[i] ^= (seed[ (i * 4) + 0 ]>>4) & 0xF;

  0001b	0f b6 79 fe	 movzx	 edi, BYTE PTR [ecx-2]
  0001f	c1 ef 04	 shr	 edi, 4
  00022	31 38		 xor	 DWORD PTR [eax], edi

; 52   :       s_box->k3[i] ^= (seed[ (i * 4) + 1 ]   ) & 0xF;

  00024	0f b6 79 ff	 movzx	 edi, BYTE PTR [ecx-1]
  00028	23 fa		 and	 edi, edx
  0002a	31 78 c0	 xor	 DWORD PTR [eax-64], edi

; 53   :       s_box->k4[i] ^= (seed[ (i * 4) + 1 ]>>4) & 0xF;

  0002d	0f b6 79 ff	 movzx	 edi, BYTE PTR [ecx-1]
  00031	c1 ef 04	 shr	 edi, 4
  00034	31 78 80	 xor	 DWORD PTR [eax-128], edi

; 54   :       s_box->k5[i] ^= (seed[ (i * 4) + 2 ]   ) & 0xF;

  00037	0f b6 39	 movzx	 edi, BYTE PTR [ecx]
  0003a	23 fa		 and	 edi, edx
  0003c	31 b8 40 ff ff
	ff		 xor	 DWORD PTR [eax-192], edi

; 55   :       s_box->k6[i] ^= (seed[ (i * 4) + 2 ]>>4) & 0xF;

  00042	0f b6 39	 movzx	 edi, BYTE PTR [ecx]
  00045	c1 ef 04	 shr	 edi, 4
  00048	31 b8 00 ff ff
	ff		 xor	 DWORD PTR [eax-256], edi

; 56   :       s_box->k7[i] ^= (seed[ (i * 4) + 3 ]   ) & 0xF;

  0004e	0f b6 79 01	 movzx	 edi, BYTE PTR [ecx+1]
  00052	23 fa		 and	 edi, edx
  00054	31 b8 c0 fe ff
	ff		 xor	 DWORD PTR [eax-320], edi

; 57   :       s_box->k8[i] ^= (seed[ (i * 4) + 3 ]>>4) & 0xF;

  0005a	0f b6 79 01	 movzx	 edi, BYTE PTR [ecx+1]
  0005e	c1 ef 04	 shr	 edi, 4
  00061	31 b8 80 fe ff
	ff		 xor	 DWORD PTR [eax-384], edi
  00067	83 c0 04	 add	 eax, 4
  0006a	83 c1 04	 add	 ecx, 4
  0006d	4e		 dec	 esi
  0006e	75 a2		 jne	 SHORT $LL3@xor_s_box
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi

; 58   :    }
; 59   : }

  00072	c3		 ret	 0
_xor_s_box@8 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _r@16
_TEXT	SEGMENT
_n2$ = 8						; size = 4
_X$ = 12						; size = 4
_r@16	PROC						; COMDAT
; _n1$ = edx
; _sbox$ = ecx

; 74   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 75   : 	n1 += X;

  00005	03 55 0c	 add	 edx, DWORD PTR _X$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi

; 76   : #ifdef GOST_DYNAMIC_SBOXES
; 77   : 	n1 =  sbox->k8[(n1>>28)&0xF] | sbox->k7[(n1>>24)&0xF]
; 78   : 				| sbox->k6[(n1>>20)&0xF] | sbox->k5[(n1>>16)&0xF]
; 79   : 				| sbox->k4[(n1>>12)&0xF] | sbox->k3[(n1>>8)&0xF]
; 80   : 				| sbox->k2[(n1>>4)&0xF] | sbox->k1[n1&0xF];
; 81   : #else
; 82   : 	n1 =  (gst_udword)sbox->k8[(n1>>28)&0xF]<<28 | (gst_udword)sbox->k7[(n1>>24)&0xF]<<24
; 83   : 				| (gst_udword)sbox->k6[(n1>>20)&0xF]<<20 | (gst_udword)sbox->k5[(n1>>16)&0xF]<<16
; 84   : 				| (gst_udword)sbox->k4[(n1>>12)&0xF]<<12 | (gst_udword)sbox->k3[(n1>>8)&0xF]<<8
; 85   : 				| (gst_udword)sbox->k2[(n1>>4)&0xF]<<4 | (gst_udword)sbox->k1[n1&0xF];
; 86   : #endif
; 87   : 	n1 = rotl32(n1, 11);
; 88   : 	n2 ^= n1;
; 89   : 	return n2;

  0000a	6a 0f		 push	 15			; 0000000fH
  0000c	5e		 pop	 esi
  0000d	8b c2		 mov	 eax, edx
  0000f	c1 e8 04	 shr	 eax, 4
  00012	23 c6		 and	 eax, esi
  00014	8b 84 81 80 01
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+384]
  0001b	8b fa		 mov	 edi, edx
  0001d	c1 ef 08	 shr	 edi, 8
  00020	23 fe		 and	 edi, esi
  00022	0b 84 b9 40 01
	00 00		 or	 eax, DWORD PTR [ecx+edi*4+320]
  00029	8b fa		 mov	 edi, edx
  0002b	c1 ef 0c	 shr	 edi, 12			; 0000000cH
  0002e	23 fe		 and	 edi, esi
  00030	0b 84 b9 00 01
	00 00		 or	 eax, DWORD PTR [ecx+edi*4+256]
  00037	8b fa		 mov	 edi, edx
  00039	c1 ef 10	 shr	 edi, 16			; 00000010H
  0003c	23 fe		 and	 edi, esi
  0003e	0b 84 b9 c0 00
	00 00		 or	 eax, DWORD PTR [ecx+edi*4+192]
  00045	8b fa		 mov	 edi, edx
  00047	c1 ef 14	 shr	 edi, 20			; 00000014H
  0004a	23 fe		 and	 edi, esi
  0004c	0b 84 b9 80 00
	00 00		 or	 eax, DWORD PTR [ecx+edi*4+128]
  00053	8b fa		 mov	 edi, edx
  00055	c1 ef 18	 shr	 edi, 24			; 00000018H
  00058	23 fe		 and	 edi, esi
  0005a	0b 44 b9 40	 or	 eax, DWORD PTR [ecx+edi*4+64]
  0005e	8b fa		 mov	 edi, edx
  00060	23 fe		 and	 edi, esi
  00062	0b 84 b9 c0 01
	00 00		 or	 eax, DWORD PTR [ecx+edi*4+448]
  00069	c1 ea 1c	 shr	 edx, 28			; 0000001cH
  0006c	0b 04 91	 or	 eax, DWORD PTR [ecx+edx*4]
  0006f	5f		 pop	 edi
  00070	c1 c0 0b	 rol	 eax, 11			; 0000000bH
  00073	33 45 08	 xor	 eax, DWORD PTR _n2$[ebp]
  00076	5e		 pop	 esi

; 90   : }

  00077	5d		 pop	 ebp
  00078	c2 08 00	 ret	 8
_r@16	ENDP
_TEXT	ENDS
PUBLIC	_gost_encrypt@12
; Function compile flags: /Ogsp
;	COMDAT _gost_encrypt@12
_TEXT	SEGMENT
tv407 = -20						; size = 4
tv438 = -16						; size = 4
tv441 = -12						; size = 4
tv444 = -8						; size = 4
tv447 = -4						; size = 4
_n1$ = 8						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_n2$ = 16						; size = 4
_ks$ = 16						; size = 4
_gost_encrypt@12 PROC					; COMDAT

; 103  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 104  : 	gst_udword n1, n2;
; 105  : 	gost_s_box *sbox;
; 106  : 	n1 = 0;
; 107  : 	n2 = 0;
; 108  : 
; 109  : 	n1 = (gst_udword)in[3] << 24 | (gst_udword)in[2] << 16 | (gst_udword)in[1] << 8 | (gst_udword)in[0];

  00008	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  0000b	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0000f	53		 push	 ebx

; 110  : 	n2 = (gst_udword)in[7] << 24 | (gst_udword)in[6] << 16 | (gst_udword)in[5] << 8 | (gst_udword)in[4];
; 111  : #ifdef GOST_DYNAMIC_SBOXES
; 112  : 	sbox = &ks->sbox;
; 113  : #else
; 114  : 	sbox = ks->sbox;
; 115  : #endif
; 116  : 
; 117  : 	//Rounds 1-24
; 118  : 	n2 = r(n1, n2, ks->X0, sbox);

  00010	0f b6 58 06	 movzx	 ebx, BYTE PTR [eax+6]
  00014	56		 push	 esi
  00015	8b 75 10	 mov	 esi, DWORD PTR _ks$[ebp]
  00018	8b 16		 mov	 edx, DWORD PTR [esi]
  0001a	57		 push	 edi
  0001b	0f b6 78 03	 movzx	 edi, BYTE PTR [eax+3]
  0001f	52		 push	 edx
  00020	89 55 ec	 mov	 DWORD PTR tv407[ebp], edx
  00023	0f b6 50 07	 movzx	 edx, BYTE PTR [eax+7]
  00027	c1 e7 08	 shl	 edi, 8
  0002a	0b f9		 or	 edi, ecx
  0002c	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00030	c1 e2 08	 shl	 edx, 8
  00033	0b d3		 or	 edx, ebx
  00035	0f b6 58 05	 movzx	 ebx, BYTE PTR [eax+5]
  00039	c1 e7 08	 shl	 edi, 8
  0003c	c1 e2 08	 shl	 edx, 8
  0003f	0b f9		 or	 edi, ecx
  00041	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00044	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  00048	0b d3		 or	 edx, ebx
  0004a	c1 e2 08	 shl	 edx, 8
  0004d	0b d0		 or	 edx, eax
  0004f	c1 e7 08	 shl	 edi, 8
  00052	0b f9		 or	 edi, ecx
  00054	52		 push	 edx
  00055	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00058	8b d7		 mov	 edx, edi
  0005a	e8 00 00 00 00	 call	 _r@16

; 119  : 	n1 = r(n2, n1, ks->X1, sbox);

  0005f	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00062	53		 push	 ebx
  00063	57		 push	 edi
  00064	8b d0		 mov	 edx, eax
  00066	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  00069	e8 00 00 00 00	 call	 _r@16

; 120  : 	n2 = r(n1, n2, ks->X2, sbox);

  0006e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00071	57		 push	 edi
  00072	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  00075	8b d0		 mov	 edx, eax
  00077	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  0007a	e8 00 00 00 00	 call	 _r@16
  0007f	8b d0		 mov	 edx, eax

; 121  : 	n1 = r(n2, n1, ks->X3, sbox);

  00081	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00084	50		 push	 eax
  00085	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  00088	89 55 10	 mov	 DWORD PTR _n2$[ebp], edx
  0008b	89 45 f0	 mov	 DWORD PTR tv438[ebp], eax
  0008e	e8 00 00 00 00	 call	 _r@16
  00093	8b d0		 mov	 edx, eax

; 122  : 	n2 = r(n1, n2, ks->X4, sbox);

  00095	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00098	50		 push	 eax
  00099	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  0009c	89 55 08	 mov	 DWORD PTR _n1$[ebp], edx
  0009f	89 45 f4	 mov	 DWORD PTR tv441[ebp], eax
  000a2	e8 00 00 00 00	 call	 _r@16
  000a7	8b d0		 mov	 edx, eax

; 123  : 	n1 = r(n2, n1, ks->X5, sbox);

  000a9	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000ac	50		 push	 eax
  000ad	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  000b0	89 55 10	 mov	 DWORD PTR _n2$[ebp], edx
  000b3	89 45 f8	 mov	 DWORD PTR tv444[ebp], eax
  000b6	e8 00 00 00 00	 call	 _r@16
  000bb	8b d0		 mov	 edx, eax

; 124  : 	n2 = r(n1, n2, ks->X6, sbox);

  000bd	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000c0	50		 push	 eax
  000c1	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  000c4	89 55 08	 mov	 DWORD PTR _n1$[ebp], edx
  000c7	89 45 fc	 mov	 DWORD PTR tv447[ebp], eax
  000ca	e8 00 00 00 00	 call	 _r@16

; 125  : 	n1 = r(n2, n1, ks->X7, sbox);

  000cf	8b 76 1c	 mov	 esi, DWORD PTR [esi+28]
  000d2	56		 push	 esi
  000d3	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  000d6	8b d0		 mov	 edx, eax
  000d8	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  000db	e8 00 00 00 00	 call	 _r@16

; 126  : 
; 127  : 	n2 = r(n1, n2, ks->X0, sbox);

  000e0	ff 75 ec	 push	 DWORD PTR tv407[ebp]
  000e3	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  000e6	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  000e9	8b d0		 mov	 edx, eax
  000eb	e8 00 00 00 00	 call	 _r@16

; 128  : 	n1 = r(n2, n1, ks->X1, sbox);

  000f0	53		 push	 ebx
  000f1	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  000f4	8b d0		 mov	 edx, eax
  000f6	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  000f9	e8 00 00 00 00	 call	 _r@16

; 129  : 	n2 = r(n1, n2, ks->X2, sbox);

  000fe	57		 push	 edi
  000ff	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  00102	8b d0		 mov	 edx, eax
  00104	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  00107	e8 00 00 00 00	 call	 _r@16

; 130  : 	n1 = r(n2, n1, ks->X3, sbox);

  0010c	ff 75 f0	 push	 DWORD PTR tv438[ebp]
  0010f	8b d0		 mov	 edx, eax
  00111	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  00114	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  00117	e8 00 00 00 00	 call	 _r@16

; 131  : 	n2 = r(n1, n2, ks->X4, sbox);

  0011c	ff 75 f4	 push	 DWORD PTR tv441[ebp]
  0011f	8b d0		 mov	 edx, eax
  00121	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  00124	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  00127	e8 00 00 00 00	 call	 _r@16

; 132  : 	n1 = r(n2, n1, ks->X5, sbox);

  0012c	ff 75 f8	 push	 DWORD PTR tv444[ebp]
  0012f	8b d0		 mov	 edx, eax
  00131	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  00134	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  00137	e8 00 00 00 00	 call	 _r@16

; 133  : 	n2 = r(n1, n2, ks->X6, sbox);

  0013c	ff 75 fc	 push	 DWORD PTR tv447[ebp]
  0013f	8b d0		 mov	 edx, eax
  00141	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  00144	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  00147	e8 00 00 00 00	 call	 _r@16

; 134  : 	n1 = r(n2, n1, ks->X7, sbox);

  0014c	56		 push	 esi
  0014d	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  00150	8b d0		 mov	 edx, eax
  00152	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  00155	e8 00 00 00 00	 call	 _r@16

; 135  : 
; 136  : 	n2 = r(n1, n2, ks->X0, sbox);

  0015a	ff 75 ec	 push	 DWORD PTR tv407[ebp]
  0015d	8b d0		 mov	 edx, eax
  0015f	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  00162	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  00165	e8 00 00 00 00	 call	 _r@16

; 137  : 	n1 = r(n2, n1, ks->X1, sbox);

  0016a	53		 push	 ebx
  0016b	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  0016e	8b d0		 mov	 edx, eax
  00170	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  00173	e8 00 00 00 00	 call	 _r@16

; 138  : 	n2 = r(n1, n2, ks->X2, sbox);

  00178	57		 push	 edi
  00179	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  0017c	8b d0		 mov	 edx, eax
  0017e	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  00181	e8 00 00 00 00	 call	 _r@16

; 139  : 	n1 = r(n2, n1, ks->X3, sbox);

  00186	ff 75 f0	 push	 DWORD PTR tv438[ebp]
  00189	8b d0		 mov	 edx, eax
  0018b	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  0018e	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  00191	e8 00 00 00 00	 call	 _r@16

; 140  : 	n2 = r(n1, n2, ks->X4, sbox);

  00196	ff 75 f4	 push	 DWORD PTR tv441[ebp]
  00199	8b d0		 mov	 edx, eax
  0019b	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  0019e	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  001a1	e8 00 00 00 00	 call	 _r@16

; 141  : 	n1 = r(n2, n1, ks->X5, sbox);

  001a6	ff 75 f8	 push	 DWORD PTR tv444[ebp]
  001a9	8b d0		 mov	 edx, eax
  001ab	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  001ae	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  001b1	e8 00 00 00 00	 call	 _r@16

; 142  : 	n2 = r(n1, n2, ks->X6, sbox);

  001b6	ff 75 fc	 push	 DWORD PTR tv447[ebp]
  001b9	8b d0		 mov	 edx, eax
  001bb	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  001be	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  001c1	e8 00 00 00 00	 call	 _r@16

; 143  : 	n1 = r(n2, n1, ks->X7, sbox);

  001c6	56		 push	 esi
  001c7	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  001ca	8b d0		 mov	 edx, eax
  001cc	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  001cf	e8 00 00 00 00	 call	 _r@16

; 144  : 
; 145  : 	//Rounds 25-32
; 146  : 	n2 = r(n1, n2, ks->X7, sbox);

  001d4	56		 push	 esi
  001d5	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  001d8	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  001db	8b d0		 mov	 edx, eax
  001dd	e8 00 00 00 00	 call	 _r@16

; 147  : 	n1 = r(n2, n1, ks->X6, sbox);

  001e2	ff 75 fc	 push	 DWORD PTR tv447[ebp]
  001e5	8b f0		 mov	 esi, eax
  001e7	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  001ea	8b d6		 mov	 edx, esi
  001ec	e8 00 00 00 00	 call	 _r@16

; 148  : 	n2 = r(n1, n2, ks->X5, sbox);

  001f1	ff 75 f8	 push	 DWORD PTR tv444[ebp]
  001f4	8b d0		 mov	 edx, eax
  001f6	56		 push	 esi
  001f7	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  001fa	e8 00 00 00 00	 call	 _r@16

; 149  : 	n1 = r(n2, n1, ks->X4, sbox);

  001ff	ff 75 f4	 push	 DWORD PTR tv441[ebp]
  00202	8b f0		 mov	 esi, eax
  00204	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  00207	8b d6		 mov	 edx, esi
  00209	e8 00 00 00 00	 call	 _r@16

; 150  : 	n2 = r(n1, n2, ks->X3, sbox);

  0020e	ff 75 f0	 push	 DWORD PTR tv438[ebp]
  00211	8b d0		 mov	 edx, eax
  00213	56		 push	 esi
  00214	89 55 08	 mov	 DWORD PTR _n1$[ebp], edx
  00217	e8 00 00 00 00	 call	 _r@16

; 151  : 	n1 = r(n2, n1, ks->X2, sbox);

  0021c	57		 push	 edi
  0021d	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  00220	8b f0		 mov	 esi, eax
  00222	8b d6		 mov	 edx, esi
  00224	e8 00 00 00 00	 call	 _r@16
  00229	8b f8		 mov	 edi, eax

; 152  : 	n2 = r(n1, n2, ks->X1, sbox);

  0022b	53		 push	 ebx
  0022c	56		 push	 esi
  0022d	8b d7		 mov	 edx, edi
  0022f	e8 00 00 00 00	 call	 _r@16

; 153  : 	n1 = r(n2, n1, ks->X0, sbox);

  00234	ff 75 ec	 push	 DWORD PTR tv407[ebp]
  00237	8b d8		 mov	 ebx, eax
  00239	57		 push	 edi
  0023a	8b d3		 mov	 edx, ebx
  0023c	e8 00 00 00 00	 call	 _r@16

; 154  : 
; 155  : 	out[0] = (byte)(n2 & 0xFF); out[1] = (byte)((n2 >> 8) & 0xFF); out[2] = (byte)((n2 >> 16) & 0xFF); out[3] = (byte)((n2 >> 24) & 0xFF);

  00241	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  00244	8b d3		 mov	 edx, ebx
  00246	c1 ea 08	 shr	 edx, 8
  00249	88 51 01	 mov	 BYTE PTR [ecx+1], dl
  0024c	8b d3		 mov	 edx, ebx
  0024e	c1 ea 10	 shr	 edx, 16			; 00000010H
  00251	88 51 02	 mov	 BYTE PTR [ecx+2], dl

; 156  : 	out[4] = (byte)(n1 & 0xFF); out[5] = (byte)((n1 >> 8) & 0xFF); out[6] = (byte)((n1 >> 16) & 0xFF); out[7] = (byte)((n1 >> 24) & 0xFF);

  00254	8b d0		 mov	 edx, eax
  00256	c1 ea 08	 shr	 edx, 8
  00259	88 51 05	 mov	 BYTE PTR [ecx+5], dl
  0025c	8b d0		 mov	 edx, eax
  0025e	88 19		 mov	 BYTE PTR [ecx], bl
  00260	c1 eb 18	 shr	 ebx, 24			; 00000018H
  00263	5f		 pop	 edi
  00264	c1 ea 10	 shr	 edx, 16			; 00000010H
  00267	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0026a	c1 e8 18	 shr	 eax, 24			; 00000018H
  0026d	5e		 pop	 esi
  0026e	88 59 03	 mov	 BYTE PTR [ecx+3], bl
  00271	88 51 06	 mov	 BYTE PTR [ecx+6], dl
  00274	88 41 07	 mov	 BYTE PTR [ecx+7], al
  00277	5b		 pop	 ebx

; 157  : }

  00278	c9		 leave
  00279	c2 0c 00	 ret	 12			; 0000000cH
_gost_encrypt@12 ENDP
_TEXT	ENDS
PUBLIC	_gost_decrypt@12
; Function compile flags: /Ogsp
;	COMDAT _gost_decrypt@12
_TEXT	SEGMENT
tv407 = -20						; size = 4
tv438 = -16						; size = 4
tv441 = -12						; size = 4
tv444 = -8						; size = 4
tv447 = -4						; size = 4
_n1$ = 8						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_n2$ = 16						; size = 4
_ks$ = 16						; size = 4
_gost_decrypt@12 PROC					; COMDAT

; 170  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 171  : 	gst_udword n1, n2;
; 172  : 	gost_s_box *sbox;
; 173  : 	n1 = 0;
; 174  : 	n2 = 0;
; 175  : 
; 176  : 	n1 = (gst_udword)in[3] << 24 | (gst_udword)in[2] << 16 | (gst_udword)in[1] << 8 | (gst_udword)in[0];

  00008	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  0000b	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0000f	53		 push	 ebx

; 177  : 	n2 = (gst_udword)in[7] << 24 | (gst_udword)in[6] << 16 | (gst_udword)in[5] << 8 | (gst_udword)in[4];
; 178  : #ifdef GOST_DYNAMIC_SBOXES
; 179  : 	sbox = &ks->sbox;
; 180  : #else
; 181  : 	sbox = ks->sbox;
; 182  : #endif
; 183  : 
; 184  : 	//Rounds 1-8
; 185  : 	n2 = r(n1, n2, ks->X0, sbox);

  00010	0f b6 58 06	 movzx	 ebx, BYTE PTR [eax+6]
  00014	56		 push	 esi
  00015	8b 75 10	 mov	 esi, DWORD PTR _ks$[ebp]
  00018	8b 16		 mov	 edx, DWORD PTR [esi]
  0001a	57		 push	 edi
  0001b	0f b6 78 03	 movzx	 edi, BYTE PTR [eax+3]
  0001f	52		 push	 edx
  00020	89 55 ec	 mov	 DWORD PTR tv407[ebp], edx
  00023	0f b6 50 07	 movzx	 edx, BYTE PTR [eax+7]
  00027	c1 e7 08	 shl	 edi, 8
  0002a	0b f9		 or	 edi, ecx
  0002c	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00030	c1 e2 08	 shl	 edx, 8
  00033	0b d3		 or	 edx, ebx
  00035	0f b6 58 05	 movzx	 ebx, BYTE PTR [eax+5]
  00039	c1 e7 08	 shl	 edi, 8
  0003c	c1 e2 08	 shl	 edx, 8
  0003f	0b f9		 or	 edi, ecx
  00041	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00044	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  00048	0b d3		 or	 edx, ebx
  0004a	c1 e2 08	 shl	 edx, 8
  0004d	0b d0		 or	 edx, eax
  0004f	c1 e7 08	 shl	 edi, 8
  00052	0b f9		 or	 edi, ecx
  00054	52		 push	 edx
  00055	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00058	8b d7		 mov	 edx, edi
  0005a	e8 00 00 00 00	 call	 _r@16

; 186  : 	n1 = r(n2, n1, ks->X1, sbox);

  0005f	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00062	53		 push	 ebx
  00063	57		 push	 edi
  00064	8b d0		 mov	 edx, eax
  00066	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  00069	e8 00 00 00 00	 call	 _r@16

; 187  : 	n2 = r(n1, n2, ks->X2, sbox);

  0006e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00071	57		 push	 edi
  00072	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  00075	8b d0		 mov	 edx, eax
  00077	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  0007a	e8 00 00 00 00	 call	 _r@16
  0007f	8b d0		 mov	 edx, eax

; 188  : 	n1 = r(n2, n1, ks->X3, sbox);

  00081	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00084	50		 push	 eax
  00085	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  00088	89 55 10	 mov	 DWORD PTR _n2$[ebp], edx
  0008b	89 45 f0	 mov	 DWORD PTR tv438[ebp], eax
  0008e	e8 00 00 00 00	 call	 _r@16
  00093	8b d0		 mov	 edx, eax

; 189  : 	n2 = r(n1, n2, ks->X4, sbox);

  00095	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00098	50		 push	 eax
  00099	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  0009c	89 55 08	 mov	 DWORD PTR _n1$[ebp], edx
  0009f	89 45 f4	 mov	 DWORD PTR tv441[ebp], eax
  000a2	e8 00 00 00 00	 call	 _r@16
  000a7	8b d0		 mov	 edx, eax

; 190  : 	n1 = r(n2, n1, ks->X5, sbox);

  000a9	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000ac	50		 push	 eax
  000ad	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  000b0	89 55 10	 mov	 DWORD PTR _n2$[ebp], edx
  000b3	89 45 f8	 mov	 DWORD PTR tv444[ebp], eax
  000b6	e8 00 00 00 00	 call	 _r@16
  000bb	8b d0		 mov	 edx, eax

; 191  : 	n2 = r(n1, n2, ks->X6, sbox);

  000bd	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000c0	50		 push	 eax
  000c1	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  000c4	89 55 08	 mov	 DWORD PTR _n1$[ebp], edx
  000c7	89 45 fc	 mov	 DWORD PTR tv447[ebp], eax
  000ca	e8 00 00 00 00	 call	 _r@16

; 192  : 	n1 = r(n2, n1, ks->X7, sbox);

  000cf	8b 76 1c	 mov	 esi, DWORD PTR [esi+28]
  000d2	56		 push	 esi
  000d3	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  000d6	8b d0		 mov	 edx, eax
  000d8	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  000db	e8 00 00 00 00	 call	 _r@16

; 193  : 
; 194  : 	//Rounds 9-32
; 195  : 	n2 = r(n1, n2, ks->X7, sbox);

  000e0	56		 push	 esi
  000e1	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  000e4	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  000e7	8b d0		 mov	 edx, eax
  000e9	e8 00 00 00 00	 call	 _r@16

; 196  : 	n1 = r(n2, n1, ks->X6, sbox);

  000ee	ff 75 fc	 push	 DWORD PTR tv447[ebp]
  000f1	8b d0		 mov	 edx, eax
  000f3	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  000f6	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  000f9	e8 00 00 00 00	 call	 _r@16

; 197  : 	n2 = r(n1, n2, ks->X5, sbox);

  000fe	ff 75 f8	 push	 DWORD PTR tv444[ebp]
  00101	8b d0		 mov	 edx, eax
  00103	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  00106	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  00109	e8 00 00 00 00	 call	 _r@16

; 198  : 	n1 = r(n2, n1, ks->X4, sbox);

  0010e	ff 75 f4	 push	 DWORD PTR tv441[ebp]
  00111	8b d0		 mov	 edx, eax
  00113	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  00116	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  00119	e8 00 00 00 00	 call	 _r@16

; 199  : 	n2 = r(n1, n2, ks->X3, sbox);

  0011e	ff 75 f0	 push	 DWORD PTR tv438[ebp]
  00121	8b d0		 mov	 edx, eax
  00123	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  00126	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  00129	e8 00 00 00 00	 call	 _r@16

; 200  : 	n1 = r(n2, n1, ks->X2, sbox);

  0012e	57		 push	 edi
  0012f	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  00132	8b d0		 mov	 edx, eax
  00134	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  00137	e8 00 00 00 00	 call	 _r@16

; 201  : 	n2 = r(n1, n2, ks->X1, sbox);

  0013c	53		 push	 ebx
  0013d	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  00140	8b d0		 mov	 edx, eax
  00142	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  00145	e8 00 00 00 00	 call	 _r@16

; 202  : 	n1 = r(n2, n1, ks->X0, sbox);

  0014a	ff 75 ec	 push	 DWORD PTR tv407[ebp]
  0014d	8b d0		 mov	 edx, eax
  0014f	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  00152	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  00155	e8 00 00 00 00	 call	 _r@16

; 203  : 
; 204  : 	n2 = r(n1, n2, ks->X7, sbox);

  0015a	56		 push	 esi
  0015b	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  0015e	8b d0		 mov	 edx, eax
  00160	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  00163	e8 00 00 00 00	 call	 _r@16

; 205  : 	n1 = r(n2, n1, ks->X6, sbox);

  00168	ff 75 fc	 push	 DWORD PTR tv447[ebp]
  0016b	8b d0		 mov	 edx, eax
  0016d	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  00170	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  00173	e8 00 00 00 00	 call	 _r@16

; 206  : 	n2 = r(n1, n2, ks->X5, sbox);

  00178	ff 75 f8	 push	 DWORD PTR tv444[ebp]
  0017b	8b d0		 mov	 edx, eax
  0017d	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  00180	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  00183	e8 00 00 00 00	 call	 _r@16

; 207  : 	n1 = r(n2, n1, ks->X4, sbox);

  00188	ff 75 f4	 push	 DWORD PTR tv441[ebp]
  0018b	8b d0		 mov	 edx, eax
  0018d	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  00190	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  00193	e8 00 00 00 00	 call	 _r@16

; 208  : 	n2 = r(n1, n2, ks->X3, sbox);

  00198	ff 75 f0	 push	 DWORD PTR tv438[ebp]
  0019b	8b d0		 mov	 edx, eax
  0019d	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  001a0	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  001a3	e8 00 00 00 00	 call	 _r@16

; 209  : 	n1 = r(n2, n1, ks->X2, sbox);

  001a8	57		 push	 edi
  001a9	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  001ac	8b d0		 mov	 edx, eax
  001ae	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  001b1	e8 00 00 00 00	 call	 _r@16

; 210  : 	n2 = r(n1, n2, ks->X1, sbox);

  001b6	53		 push	 ebx
  001b7	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  001ba	8b d0		 mov	 edx, eax
  001bc	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  001bf	e8 00 00 00 00	 call	 _r@16

; 211  : 	n1 = r(n2, n1, ks->X0, sbox);

  001c4	ff 75 ec	 push	 DWORD PTR tv407[ebp]
  001c7	8b d0		 mov	 edx, eax
  001c9	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  001cc	89 45 10	 mov	 DWORD PTR _n2$[ebp], eax
  001cf	e8 00 00 00 00	 call	 _r@16

; 212  : 
; 213  : 	n2 = r(n1, n2, ks->X7, sbox);

  001d4	56		 push	 esi
  001d5	ff 75 10	 push	 DWORD PTR _n2$[ebp]
  001d8	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  001db	8b d0		 mov	 edx, eax
  001dd	e8 00 00 00 00	 call	 _r@16

; 214  : 	n1 = r(n2, n1, ks->X6, sbox);

  001e2	ff 75 fc	 push	 DWORD PTR tv447[ebp]
  001e5	8b f0		 mov	 esi, eax
  001e7	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  001ea	8b d6		 mov	 edx, esi
  001ec	e8 00 00 00 00	 call	 _r@16

; 215  : 	n2 = r(n1, n2, ks->X5, sbox);

  001f1	ff 75 f8	 push	 DWORD PTR tv444[ebp]
  001f4	8b d0		 mov	 edx, eax
  001f6	56		 push	 esi
  001f7	89 45 08	 mov	 DWORD PTR _n1$[ebp], eax
  001fa	e8 00 00 00 00	 call	 _r@16

; 216  : 	n1 = r(n2, n1, ks->X4, sbox);

  001ff	ff 75 f4	 push	 DWORD PTR tv441[ebp]
  00202	8b f0		 mov	 esi, eax
  00204	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  00207	8b d6		 mov	 edx, esi
  00209	e8 00 00 00 00	 call	 _r@16

; 217  : 	n2 = r(n1, n2, ks->X3, sbox);

  0020e	ff 75 f0	 push	 DWORD PTR tv438[ebp]
  00211	8b d0		 mov	 edx, eax
  00213	56		 push	 esi
  00214	89 55 08	 mov	 DWORD PTR _n1$[ebp], edx
  00217	e8 00 00 00 00	 call	 _r@16

; 218  : 	n1 = r(n2, n1, ks->X2, sbox);

  0021c	57		 push	 edi
  0021d	ff 75 08	 push	 DWORD PTR _n1$[ebp]
  00220	8b f0		 mov	 esi, eax
  00222	8b d6		 mov	 edx, esi
  00224	e8 00 00 00 00	 call	 _r@16
  00229	8b f8		 mov	 edi, eax

; 219  : 	n2 = r(n1, n2, ks->X1, sbox);

  0022b	53		 push	 ebx
  0022c	56		 push	 esi
  0022d	8b d7		 mov	 edx, edi
  0022f	e8 00 00 00 00	 call	 _r@16

; 220  : 	n1 = r(n2, n1, ks->X0, sbox);

  00234	ff 75 ec	 push	 DWORD PTR tv407[ebp]
  00237	8b d8		 mov	 ebx, eax
  00239	57		 push	 edi
  0023a	8b d3		 mov	 edx, ebx
  0023c	e8 00 00 00 00	 call	 _r@16

; 221  : 	
; 222  : 	out[0] = (byte)(n2 & 0xFF); out[1] = (byte)((n2 >> 8) & 0xFF); out[2] = (byte)((n2 >> 16) & 0xFF); out[3] = (byte)((n2 >> 24) & 0xFF);

  00241	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  00244	8b d3		 mov	 edx, ebx
  00246	c1 ea 08	 shr	 edx, 8
  00249	88 51 01	 mov	 BYTE PTR [ecx+1], dl
  0024c	8b d3		 mov	 edx, ebx
  0024e	c1 ea 10	 shr	 edx, 16			; 00000010H
  00251	88 51 02	 mov	 BYTE PTR [ecx+2], dl

; 223  : 	out[4] = (byte)(n1 & 0xFF); out[5] = (byte)((n1 >> 8) & 0xFF); out[6] = (byte)((n1 >> 16) & 0xFF); out[7] = (byte)((n1 >> 24) & 0xFF);

  00254	8b d0		 mov	 edx, eax
  00256	c1 ea 08	 shr	 edx, 8
  00259	88 51 05	 mov	 BYTE PTR [ecx+5], dl
  0025c	8b d0		 mov	 edx, eax
  0025e	88 19		 mov	 BYTE PTR [ecx], bl
  00260	c1 eb 18	 shr	 ebx, 24			; 00000018H
  00263	5f		 pop	 edi
  00264	c1 ea 10	 shr	 edx, 16			; 00000010H
  00267	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0026a	c1 e8 18	 shr	 eax, 24			; 00000018H
  0026d	5e		 pop	 esi
  0026e	88 59 03	 mov	 BYTE PTR [ecx+3], bl
  00271	88 51 06	 mov	 BYTE PTR [ecx+6], dl
  00274	88 41 07	 mov	 BYTE PTR [ecx+7], al
  00277	5b		 pop	 ebx

; 224  : }

  00278	c9		 leave
  00279	c2 0c 00	 ret	 12			; 0000000cH
_gost_decrypt@12 ENDP
_TEXT	ENDS
PUBLIC	_key$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_gost_set_key@8
EXTRN	_STRIBOG_finalize@8:PROC
EXTRN	_STRIBOG_add@12:PROC
EXTRN	_STRIBOG_init@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _gost_set_key@8
_TEXT	SEGMENT
_key$GSCopy$ = -460					; size = 4
_sctx$ = -456						; size = 385
_sbox_seed$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_key$ = 8						; size = 4
_ks$ = 12						; size = 4
_gost_set_key@8 PROC					; COMDAT

; 237  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec cc 01 00
	00		 sub	 esp, 460		; 000001ccH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00018	53		 push	 ebx
  00019	8b 5d 0c	 mov	 ebx, DWORD PTR _ks$[ebp]
  0001c	56		 push	 esi
  0001d	57		 push	 edi

; 238  :     gst_udword i;
; 239  : 
; 240  : #ifdef GOST_DYNAMIC_SBOXES
; 241  : 	STRIBOG_CTX sctx;
; 242  : 	byte sbox_seed[64];
; 243  : 
; 244  : 	ks->sbox = GostR3411_94_CryptoProParamSet;
; 245  : 
; 246  : 	//Generate pseudorandom data based on the key
; 247  : 	STRIBOG_init(&sctx);
; 248  : 	STRIBOG_add(&sctx, key, 32);
; 249  : 	STRIBOG_finalize(&sctx, sbox_seed);
; 250  : 
; 251  : 	xor_s_box(&ks->sbox, sbox_seed);
; 252  : 
; 253  : 	/* In order to avoid 7 bitshift operations on each pass through the S-Box,
; 254  : 	* this step is pre-processed once during the set_key phase. If memory contraints
; 255  : 	* become a problem, this step can be skipped and the sbox struct can change its
; 256  : 	* unsigned int arrays to unsigned char arrays, going from 512 unsigned chars to 128.
; 257  : 	*/
; 258  : 	for (i = 0; i < GOST_SBOX_SIZE; i++)
; 259  : 	{
; 260  : 		ks->sbox.k8[i] <<= 28;
; 261  : 		ks->sbox.k7[i] <<= 24;
; 262  : 		ks->sbox.k6[i] <<= 20;
; 263  : 		ks->sbox.k5[i] <<= 16;
; 264  : 		ks->sbox.k4[i] <<= 12;
; 265  : 		ks->sbox.k3[i] <<= 8;
; 266  : 		ks->sbox.k2[i] <<= 4;
; 267  : 	}
; 268  : #else
; 269  : 	ks->sbox = &GostR3411_94_CryptoProParamSet;
; 270  : #endif
; 271  : 
; 272  : 	ks->X0 = 0;
; 273  : 	ks->X1 = 0;
; 274  : 	ks->X2 = 0;
; 275  : 	ks->X3 = 0;
; 276  : 	ks->X4 = 0;
; 277  : 	ks->X5 = 0;
; 278  : 	ks->X6 = 0;
; 279  : 	ks->X7 = 0;
; 280  : 
; 281  : 	//Set the key
; 282  : 	for (i = 0; i < GOST_KEYSIZE / 8; i++)
; 283  : 	{
; 284  : 		ks->X0 |= (gst_udword)key[i + 0] << (i * 8);

  0001e	89 85 34 fe ff
	ff		 mov	 DWORD PTR _key$GSCopy$[ebp], eax
  00024	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _sctx$[ebp]
  0002a	8d 7b 20	 lea	 edi, DWORD PTR [ebx+32]
  0002d	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00032	be 00 00 00 00	 mov	 esi, OFFSET _GostR3411_94_CryptoProParamSet
  00037	50		 push	 eax
  00038	f3 a5		 rep movsd
  0003a	e8 00 00 00 00	 call	 _STRIBOG_init@4
  0003f	8b b5 34 fe ff
	ff		 mov	 esi, DWORD PTR _key$GSCopy$[ebp]
  00045	6a 20		 push	 32			; 00000020H
  00047	56		 push	 esi
  00048	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _sctx$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _STRIBOG_add@12
  00054	8d 45 bc	 lea	 eax, DWORD PTR _sbox_seed$[ebp]
  00057	50		 push	 eax
  00058	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _sctx$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _STRIBOG_finalize@8
  00064	8d 4d bc	 lea	 ecx, DWORD PTR _sbox_seed$[ebp]
  00067	8d 43 20	 lea	 eax, DWORD PTR [ebx+32]
  0006a	e8 00 00 00 00	 call	 _xor_s_box@8
  0006f	6a 10		 push	 16			; 00000010H
  00071	59		 pop	 ecx
  00072	6a 04		 push	 4
  00074	8d 43 60	 lea	 eax, DWORD PTR [ebx+96]
  00077	5a		 pop	 edx
$LL6@gost_set_k:
  00078	c1 60 c0 1c	 shl	 DWORD PTR [eax-64], 28	; 0000001cH
  0007c	c1 20 18	 shl	 DWORD PTR [eax], 24	; 00000018H
  0007f	c1 60 40 14	 shl	 DWORD PTR [eax+64], 20	; 00000014H
  00083	c1 a0 80 00 00
	00 10		 shl	 DWORD PTR [eax+128], 16	; 00000010H
  0008a	c1 a0 c0 00 00
	00 0c		 shl	 DWORD PTR [eax+192], 12	; 0000000cH
  00091	c1 a0 00 01 00
	00 08		 shl	 DWORD PTR [eax+256], 8
  00098	c1 a0 40 01 00
	00 04		 shl	 DWORD PTR [eax+320], 4
  0009f	03 c2		 add	 eax, edx
  000a1	49		 dec	 ecx
  000a2	75 d4		 jne	 SHORT $LL6@gost_set_k
  000a4	33 c0		 xor	 eax, eax
  000a6	89 03		 mov	 DWORD PTR [ebx], eax
  000a8	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  000ab	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  000ae	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  000b1	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  000b4	89 43 14	 mov	 DWORD PTR [ebx+20], eax
  000b7	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  000ba	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  000bd	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
$LL3@gost_set_k:
  000c0	0f b6 70 fc	 movzx	 esi, BYTE PTR [eax-4]
  000c4	d3 e6		 shl	 esi, cl
  000c6	09 33		 or	 DWORD PTR [ebx], esi

; 285  : 		ks->X1 |= (gst_udword)key[i + 4] << (i * 8);

  000c8	0f b6 30	 movzx	 esi, BYTE PTR [eax]
  000cb	d3 e6		 shl	 esi, cl
  000cd	09 73 04	 or	 DWORD PTR [ebx+4], esi

; 286  : 		ks->X2 |= (gst_udword)key[i + 8] << (i * 8);

  000d0	0f b6 70 04	 movzx	 esi, BYTE PTR [eax+4]
  000d4	d3 e6		 shl	 esi, cl
  000d6	09 73 08	 or	 DWORD PTR [ebx+8], esi

; 287  : 		ks->X3 |= (gst_udword)key[i + 12] << (i * 8);

  000d9	0f b6 70 08	 movzx	 esi, BYTE PTR [eax+8]
  000dd	d3 e6		 shl	 esi, cl
  000df	09 73 0c	 or	 DWORD PTR [ebx+12], esi

; 288  : 		ks->X4 |= (gst_udword)key[i + 16] << (i * 8);

  000e2	0f b6 70 0c	 movzx	 esi, BYTE PTR [eax+12]
  000e6	d3 e6		 shl	 esi, cl
  000e8	09 73 10	 or	 DWORD PTR [ebx+16], esi

; 289  : 		ks->X5 |= (gst_udword)key[i + 20] << (i * 8);

  000eb	0f b6 70 10	 movzx	 esi, BYTE PTR [eax+16]
  000ef	d3 e6		 shl	 esi, cl
  000f1	09 73 14	 or	 DWORD PTR [ebx+20], esi

; 290  : 		ks->X6 |= (gst_udword)key[i + 24] << (i * 8);

  000f4	0f b6 70 14	 movzx	 esi, BYTE PTR [eax+20]
  000f8	d3 e6		 shl	 esi, cl
  000fa	09 73 18	 or	 DWORD PTR [ebx+24], esi

; 291  : 		ks->X7 |= (gst_udword)key[i + 28] << (i * 8);

  000fd	0f b6 70 18	 movzx	 esi, BYTE PTR [eax+24]
  00101	d3 e6		 shl	 esi, cl
  00103	83 c1 08	 add	 ecx, 8
  00106	09 73 1c	 or	 DWORD PTR [ebx+28], esi
  00109	40		 inc	 eax
  0010a	4a		 dec	 edx
  0010b	75 b3		 jne	 SHORT $LL3@gost_set_k

; 292  : 	}
; 293  : }

  0010d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	33 cd		 xor	 ecx, ebp
  00114	5b		 pop	 ebx
  00115	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011a	c9		 leave
  0011b	c2 08 00	 ret	 8
_gost_set_key@8 ENDP
_TEXT	ENDS
PUBLIC	_gost_xor_ks@16
; Function compile flags: /Ogsp
;	COMDAT _gost_xor_ks@16
_TEXT	SEGMENT
_ks$ = 8						; size = 4
_out_ks$ = 12						; size = 4
_in$ = 16						; size = 4
_len$ = 20						; size = 4
_gost_xor_ks@16 PROC					; COMDAT

; 307  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 308  : 	gst_dword i;
; 309  : 	if (!len)

  00005	83 7d 14 00	 cmp	 DWORD PTR _len$[ebp], 0
  00009	0f 84 83 00 00
	00		 je	 $LN1@gost_xor_k

; 310  : 		return;
; 311  : 
; 312  : 	out_ks->X0 = ks->X0 ^ in[0];

  0000f	8b 55 08	 mov	 edx, DWORD PTR _ks$[ebp]
  00012	8b 4d 10	 mov	 ecx, DWORD PTR _in$[ebp]
  00015	8b 45 0c	 mov	 eax, DWORD PTR _out_ks$[ebp]
  00018	56		 push	 esi
  00019	8b 32		 mov	 esi, DWORD PTR [edx]
  0001b	33 31		 xor	 esi, DWORD PTR [ecx]
  0001d	89 30		 mov	 DWORD PTR [eax], esi

; 313  : 	out_ks->X1 = ks->X1 ^ in[0];

  0001f	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00022	33 31		 xor	 esi, DWORD PTR [ecx]
  00024	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 314  : 	out_ks->X2 = ks->X2 ^ in[0];

  00027	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  0002a	33 31		 xor	 esi, DWORD PTR [ecx]
  0002c	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 315  : 	out_ks->X3 = ks->X3 ^ in[0];

  0002f	8b 72 0c	 mov	 esi, DWORD PTR [edx+12]
  00032	33 31		 xor	 esi, DWORD PTR [ecx]
  00034	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 316  : 	out_ks->X4 = ks->X4 ^ in[0];

  00037	8b 72 10	 mov	 esi, DWORD PTR [edx+16]
  0003a	33 31		 xor	 esi, DWORD PTR [ecx]
  0003c	89 70 10	 mov	 DWORD PTR [eax+16], esi

; 317  : 	out_ks->X5 = ks->X5 ^ in[0];

  0003f	8b 72 14	 mov	 esi, DWORD PTR [edx+20]
  00042	33 31		 xor	 esi, DWORD PTR [ecx]
  00044	89 70 14	 mov	 DWORD PTR [eax+20], esi

; 318  : 	out_ks->X6 = ks->X6 ^ in[0];

  00047	8b 72 18	 mov	 esi, DWORD PTR [edx+24]
  0004a	33 31		 xor	 esi, DWORD PTR [ecx]
  0004c	89 70 18	 mov	 DWORD PTR [eax+24], esi

; 319  : 	out_ks->X7 = ks->X7 ^ in[0];

  0004f	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  00052	33 11		 xor	 edx, DWORD PTR [ecx]

; 320  : 
; 321  : 	for (i = 1; i < len; i++)

  00054	33 f6		 xor	 esi, esi
  00056	46		 inc	 esi
  00057	39 75 14	 cmp	 DWORD PTR _len$[ebp], esi
  0005a	89 50 1c	 mov	 DWORD PTR [eax+28], edx
  0005d	7e 32		 jle	 SHORT $LN9@gost_xor_k
  0005f	57		 push	 edi
$LL3@gost_xor_k:
  00060	8d 14 b1	 lea	 edx, DWORD PTR [ecx+esi*4]

; 322  : 	{
; 323  : 		out_ks->X0 ^= in[i];

  00063	8b 3a		 mov	 edi, DWORD PTR [edx]
  00065	31 38		 xor	 DWORD PTR [eax], edi

; 324  : 		out_ks->X1 ^= in[i];

  00067	8b 3a		 mov	 edi, DWORD PTR [edx]
  00069	31 78 04	 xor	 DWORD PTR [eax+4], edi

; 325  : 		out_ks->X2 ^= in[i];

  0006c	8b 3a		 mov	 edi, DWORD PTR [edx]
  0006e	31 78 08	 xor	 DWORD PTR [eax+8], edi

; 326  : 		out_ks->X3 ^= in[i];

  00071	8b 3a		 mov	 edi, DWORD PTR [edx]
  00073	31 78 0c	 xor	 DWORD PTR [eax+12], edi

; 327  : 		out_ks->X4 ^= in[i];

  00076	8b 3a		 mov	 edi, DWORD PTR [edx]
  00078	31 78 10	 xor	 DWORD PTR [eax+16], edi

; 328  : 		out_ks->X5 ^= in[i];

  0007b	8b 3a		 mov	 edi, DWORD PTR [edx]
  0007d	31 78 14	 xor	 DWORD PTR [eax+20], edi

; 329  : 		out_ks->X6 ^= in[i];

  00080	8b 3a		 mov	 edi, DWORD PTR [edx]
  00082	31 78 18	 xor	 DWORD PTR [eax+24], edi

; 330  : 		out_ks->X7 ^= in[i];

  00085	8b 12		 mov	 edx, DWORD PTR [edx]
  00087	31 50 1c	 xor	 DWORD PTR [eax+28], edx
  0008a	46		 inc	 esi
  0008b	3b 75 14	 cmp	 esi, DWORD PTR _len$[ebp]
  0008e	7c d0		 jl	 SHORT $LL3@gost_xor_k
  00090	5f		 pop	 edi
$LN9@gost_xor_k:
  00091	5e		 pop	 esi
$LN1@gost_xor_k:

; 331  : 	}
; 332  : }

  00092	5d		 pop	 ebp
  00093	c2 10 00	 ret	 16			; 00000010H
_gost_xor_ks@16 ENDP
_TEXT	ENDS
END
