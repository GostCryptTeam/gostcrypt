; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\crypto\gosthash.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_C_3	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
_GostR3411_94_CryptoProParamSet DB 01H
	DB	03H
	DB	0aH
	DB	09H
	DB	05H
	DB	0bH
	DB	04H
	DB	0fH
	DB	08H
	DB	06H
	DB	07H
	DB	0eH
	DB	0dH
	DB	00H
	DB	02H
	DB	0cH
	DB	0dH
	DB	0eH
	DB	04H
	DB	01H
	DB	07H
	DB	00H
	DB	05H
	DB	0aH
	DB	03H
	DB	0cH
	DB	08H
	DB	0fH
	DB	06H
	DB	02H
	DB	09H
	DB	0bH
	DB	07H
	DB	06H
	DB	02H
	DB	04H
	DB	0dH
	DB	09H
	DB	0fH
	DB	00H
	DB	0aH
	DB	01H
	DB	05H
	DB	0bH
	DB	08H
	DB	0eH
	DB	0cH
	DB	03H
	DB	07H
	DB	06H
	DB	04H
	DB	0bH
	DB	09H
	DB	0cH
	DB	02H
	DB	0aH
	DB	01H
	DB	08H
	DB	00H
	DB	0eH
	DB	0fH
	DB	0dH
	DB	03H
	DB	05H
	DB	04H
	DB	0aH
	DB	07H
	DB	0cH
	DB	00H
	DB	0fH
	DB	02H
	DB	08H
	DB	0eH
	DB	01H
	DB	06H
	DB	05H
	DB	0dH
	DB	0bH
	DB	09H
	DB	03H
	DB	07H
	DB	0fH
	DB	0cH
	DB	0eH
	DB	09H
	DB	04H
	DB	01H
	DB	00H
	DB	03H
	DB	0bH
	DB	05H
	DB	02H
	DB	06H
	DB	0aH
	DB	08H
	DB	0dH
	DB	05H
	DB	0fH
	DB	04H
	DB	00H
	DB	02H
	DB	0dH
	DB	0bH
	DB	09H
	DB	01H
	DB	07H
	DB	06H
	DB	03H
	DB	0cH
	DB	0eH
	DB	0aH
	DB	08H
	DB	0aH
	DB	04H
	DB	05H
	DB	06H
	DB	08H
	DB	01H
	DB	03H
	DB	07H
	DB	0dH
	DB	0cH
	DB	0eH
	DB	00H
	DB	09H
	DB	02H
	DB	0bH
	DB	0fH
; Function compile flags: /Ogsp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\crypto\gosthash.c
_DATA	ENDS
;	COMDAT _r@12
_TEXT	SEGMENT
_n2$ = 8						; size = 4
_X$ = 12						; size = 4
_r@12	PROC						; COMDAT
; _n1$ = ecx

; 53   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 54   : 	gosthash_s_box *sbox = &GostR3411_94_CryptoProParamSet;
; 55   : 	n1 += X;

  00005	03 4d 0c	 add	 ecx, DWORD PTR _X$[ebp]
  00008	56		 push	 esi

; 56   : 	n1 =  (gst_udword)sbox->k8[(n1>>28)&0xF]<<28 | (gst_udword)sbox->k7[(n1>>24)&0xF]<<24
; 57   : 				| (gst_udword)sbox->k6[(n1>>20)&0xF]<<20 | (gst_udword)sbox->k5[(n1>>16)&0xF]<<16
; 58   : 				| (gst_udword)sbox->k4[(n1>>12)&0xF]<<12 | (gst_udword)sbox->k3[(n1>>8)&0xF]<<8
; 59   : 				| (gst_udword)sbox->k2[(n1>>4)&0xF]<<4 | (gst_udword)sbox->k1[n1&0xF];
; 60   : 	n1 = gosthash_rotl32(n1, 11);
; 61   : 	n2 ^= n1;
; 62   : 	return n2;

  00009	8b c1		 mov	 eax, ecx
  0000b	c1 e8 18	 shr	 eax, 24			; 00000018H
  0000e	8b f1		 mov	 esi, ecx
  00010	c1 ee 1c	 shr	 esi, 28			; 0000001cH
  00013	0f b6 b6 00 00
	00 00		 movzx	 esi, BYTE PTR _GostR3411_94_CryptoProParamSet[esi]
  0001a	c1 e6 04	 shl	 esi, 4
  0001d	6a 0f		 push	 15			; 0000000fH
  0001f	5a		 pop	 edx
  00020	23 c2		 and	 eax, edx
  00022	0f b6 80 10 00
	00 00		 movzx	 eax, BYTE PTR _GostR3411_94_CryptoProParamSet[eax+16]
  00029	0b c6		 or	 eax, esi
  0002b	c1 e0 04	 shl	 eax, 4
  0002e	8b f1		 mov	 esi, ecx
  00030	c1 ee 14	 shr	 esi, 20			; 00000014H
  00033	23 f2		 and	 esi, edx
  00035	0f b6 b6 20 00
	00 00		 movzx	 esi, BYTE PTR _GostR3411_94_CryptoProParamSet[esi+32]
  0003c	0b c6		 or	 eax, esi
  0003e	c1 e0 04	 shl	 eax, 4
  00041	8b f1		 mov	 esi, ecx
  00043	c1 ee 10	 shr	 esi, 16			; 00000010H
  00046	23 f2		 and	 esi, edx
  00048	0f b6 b6 30 00
	00 00		 movzx	 esi, BYTE PTR _GostR3411_94_CryptoProParamSet[esi+48]
  0004f	0b c6		 or	 eax, esi
  00051	8b f1		 mov	 esi, ecx
  00053	c1 ee 0c	 shr	 esi, 12			; 0000000cH
  00056	23 f2		 and	 esi, edx
  00058	0f b6 b6 40 00
	00 00		 movzx	 esi, BYTE PTR _GostR3411_94_CryptoProParamSet[esi+64]
  0005f	c1 e0 04	 shl	 eax, 4
  00062	0b c6		 or	 eax, esi
  00064	8b f1		 mov	 esi, ecx
  00066	c1 ee 08	 shr	 esi, 8
  00069	23 f2		 and	 esi, edx
  0006b	0f b6 b6 50 00
	00 00		 movzx	 esi, BYTE PTR _GostR3411_94_CryptoProParamSet[esi+80]
  00072	c1 e0 04	 shl	 eax, 4
  00075	0b c6		 or	 eax, esi
  00077	8b f1		 mov	 esi, ecx
  00079	c1 ee 04	 shr	 esi, 4
  0007c	23 f2		 and	 esi, edx
  0007e	0f b6 b6 60 00
	00 00		 movzx	 esi, BYTE PTR _GostR3411_94_CryptoProParamSet[esi+96]
  00085	c1 e0 04	 shl	 eax, 4
  00088	0b c6		 or	 eax, esi
  0008a	23 ca		 and	 ecx, edx
  0008c	0f b6 89 70 00
	00 00		 movzx	 ecx, BYTE PTR _GostR3411_94_CryptoProParamSet[ecx+112]
  00093	c1 e0 04	 shl	 eax, 4
  00096	0b c1		 or	 eax, ecx
  00098	c1 c0 0b	 rol	 eax, 11			; 0000000bH
  0009b	33 45 08	 xor	 eax, DWORD PTR _n2$[ebp]
  0009e	5e		 pop	 esi

; 63   : }

  0009f	5d		 pop	 ebp
  000a0	c2 08 00	 ret	 8
_r@12	ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _gost_encrypt_with_key@12
_TEXT	SEGMENT
_X2$ = -36						; size = 4
_X0$ = -32						; size = 4
_X1$ = -28						; size = 4
_X3$ = -24						; size = 4
_X4$ = -20						; size = 4
_X5$ = -16						; size = 4
_X6$ = -12						; size = 4
_X7$ = -8						; size = 4
tv601 = -4						; size = 4
_n1$ = -4						; size = 4
tv160 = 8						; size = 4
_n2$ = 8						; size = 4
_key$ = 8						; size = 4
_gost_encrypt_with_key@12 PROC				; COMDAT
; _in$ = eax
; _out$ = esi

; 76   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 24	 sub	 esp, 36			; 00000024H

; 82   : 	n2 = (gst_udword)in[7] << 24 | (gst_udword)in[6] << 16 | (gst_udword)in[5] << 8 | (gst_udword)in[4];

  00008	53		 push	 ebx

; 92   : 	X7 = 0;

  00009	57		 push	 edi

; 77   : 	gst_dword i;
; 78   : 	gst_udword n1, n2;
; 79   : 	gst_udword X0, X1, X2, X3, X4, X5, X6, X7;
; 80   : 
; 81   : 	n1 = (gst_udword)in[3] << 24 | (gst_udword)in[2] << 16 | (gst_udword)in[1] << 8 | (gst_udword)in[0];

  0000a	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]

; 82   : 	n2 = (gst_udword)in[7] << 24 | (gst_udword)in[6] << 16 | (gst_udword)in[5] << 8 | (gst_udword)in[4];

  0000e	0f b6 50 07	 movzx	 edx, BYTE PTR [eax+7]
  00012	0f b6 58 03	 movzx	 ebx, BYTE PTR [eax+3]
  00016	c1 e3 08	 shl	 ebx, 8
  00019	0b d9		 or	 ebx, ecx
  0001b	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0001f	c1 e3 08	 shl	 ebx, 8
  00022	0b d9		 or	 ebx, ecx
  00024	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00027	c1 e3 08	 shl	 ebx, 8
  0002a	0b d9		 or	 ebx, ecx
  0002c	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00030	c1 e2 08	 shl	 edx, 8
  00033	0b d1		 or	 edx, ecx
  00035	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00039	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0003d	c1 e2 08	 shl	 edx, 8
  00040	0b d1		 or	 edx, ecx
  00042	c1 e2 08	 shl	 edx, 8
  00045	0b d0		 or	 edx, eax

; 83   : 
; 84   : 	/* Set the 8 round keys */
; 85   : 	X0 = 0;

  00047	33 c0		 xor	 eax, eax
  00049	89 45 e0	 mov	 DWORD PTR _X0$[ebp], eax

; 86   : 	X1 = 0;

  0004c	89 45 e4	 mov	 DWORD PTR _X1$[ebp], eax

; 87   : 	X2 = 0;

  0004f	89 45 dc	 mov	 DWORD PTR _X2$[ebp], eax

; 88   : 	X3 = 0;

  00052	89 45 e8	 mov	 DWORD PTR _X3$[ebp], eax

; 89   : 	X4 = 0;

  00055	89 45 ec	 mov	 DWORD PTR _X4$[ebp], eax

; 90   : 	X5 = 0;

  00058	89 45 f0	 mov	 DWORD PTR _X5$[ebp], eax

; 91   : 	X6 = 0;

  0005b	89 45 f4	 mov	 DWORD PTR _X6$[ebp], eax

; 92   : 	X7 = 0;

  0005e	89 45 f8	 mov	 DWORD PTR _X7$[ebp], eax
  00061	89 45 fc	 mov	 DWORD PTR tv601[ebp], eax
  00064	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00067	83 c0 04	 add	 eax, 4
  0006a	c7 45 08 04 00
	00 00		 mov	 DWORD PTR tv160[ebp], 4
$LL3@gost_encry:

; 93   : 	
; 94   : 	for (i = 0; i < GOSTHASH_GOST_KEYSIZE / 8; i++)
; 95   : 	{
; 96   : 		X0 |= (gst_udword)key[i + 0] << (i * 8);

  00071	8b 4d fc	 mov	 ecx, DWORD PTR tv601[ebp]
  00074	0f b6 78 fc	 movzx	 edi, BYTE PTR [eax-4]
  00078	d3 e7		 shl	 edi, cl
  0007a	83 45 fc 08	 add	 DWORD PTR tv601[ebp], 8
  0007e	09 7d e0	 or	 DWORD PTR _X0$[ebp], edi

; 97   : 		X1 |= (gst_udword)key[i + 4] << (i * 8);

  00081	0f b6 38	 movzx	 edi, BYTE PTR [eax]
  00084	d3 e7		 shl	 edi, cl
  00086	09 7d e4	 or	 DWORD PTR _X1$[ebp], edi

; 98   : 		X2 |= (gst_udword)key[i + 8] << (i * 8);

  00089	0f b6 78 04	 movzx	 edi, BYTE PTR [eax+4]
  0008d	d3 e7		 shl	 edi, cl
  0008f	09 7d dc	 or	 DWORD PTR _X2$[ebp], edi

; 99   : 		X3 |= (gst_udword)key[i + 12] << (i * 8);

  00092	0f b6 78 08	 movzx	 edi, BYTE PTR [eax+8]
  00096	d3 e7		 shl	 edi, cl
  00098	09 7d e8	 or	 DWORD PTR _X3$[ebp], edi

; 100  : 		X4 |= (gst_udword)key[i + 16] << (i * 8);

  0009b	0f b6 78 0c	 movzx	 edi, BYTE PTR [eax+12]
  0009f	d3 e7		 shl	 edi, cl
  000a1	09 7d ec	 or	 DWORD PTR _X4$[ebp], edi

; 101  : 		X5 |= (gst_udword)key[i + 20] << (i * 8);

  000a4	0f b6 78 10	 movzx	 edi, BYTE PTR [eax+16]
  000a8	d3 e7		 shl	 edi, cl
  000aa	09 7d f0	 or	 DWORD PTR _X5$[ebp], edi

; 102  : 		X6 |= (gst_udword)key[i + 24] << (i * 8);

  000ad	0f b6 78 14	 movzx	 edi, BYTE PTR [eax+20]
  000b1	d3 e7		 shl	 edi, cl
  000b3	09 7d f4	 or	 DWORD PTR _X6$[ebp], edi

; 103  : 		X7 |= (gst_udword)key[i + 28] << (i * 8);

  000b6	0f b6 78 18	 movzx	 edi, BYTE PTR [eax+24]
  000ba	d3 e7		 shl	 edi, cl
  000bc	09 7d f8	 or	 DWORD PTR _X7$[ebp], edi
  000bf	40		 inc	 eax
  000c0	ff 4d 08	 dec	 DWORD PTR tv160[ebp]
  000c3	75 ac		 jne	 SHORT $LL3@gost_encry

; 104  : 	}
; 105  : 
; 106  : 	/* Encryption rounds 1-24 */
; 107  : 	n2 = r(n1, n2, X0);

  000c5	8b 7d e0	 mov	 edi, DWORD PTR _X0$[ebp]
  000c8	57		 push	 edi
  000c9	52		 push	 edx
  000ca	8b cb		 mov	 ecx, ebx
  000cc	e8 00 00 00 00	 call	 _r@12

; 108  : 	n1 = r(n2, n1, X1);

  000d1	ff 75 e4	 push	 DWORD PTR _X1$[ebp]
  000d4	8b c8		 mov	 ecx, eax
  000d6	53		 push	 ebx
  000d7	89 45 08	 mov	 DWORD PTR _n2$[ebp], eax
  000da	e8 00 00 00 00	 call	 _r@12

; 109  : 	n2 = r(n1, n2, X2);

  000df	8b 5d dc	 mov	 ebx, DWORD PTR _X2$[ebp]
  000e2	53		 push	 ebx
  000e3	ff 75 08	 push	 DWORD PTR _n2$[ebp]
  000e6	8b c8		 mov	 ecx, eax
  000e8	89 4d fc	 mov	 DWORD PTR _n1$[ebp], ecx
  000eb	e8 00 00 00 00	 call	 _r@12

; 110  : 	n1 = r(n2, n1, X3);

  000f0	ff 75 e8	 push	 DWORD PTR _X3$[ebp]
  000f3	8b c8		 mov	 ecx, eax
  000f5	ff 75 fc	 push	 DWORD PTR _n1$[ebp]
  000f8	89 4d 08	 mov	 DWORD PTR _n2$[ebp], ecx
  000fb	e8 00 00 00 00	 call	 _r@12

; 111  : 	n2 = r(n1, n2, X4);

  00100	ff 75 ec	 push	 DWORD PTR _X4$[ebp]
  00103	8b c8		 mov	 ecx, eax
  00105	ff 75 08	 push	 DWORD PTR _n2$[ebp]
  00108	89 4d fc	 mov	 DWORD PTR _n1$[ebp], ecx
  0010b	e8 00 00 00 00	 call	 _r@12

; 112  : 	n1 = r(n2, n1, X5);

  00110	ff 75 f0	 push	 DWORD PTR _X5$[ebp]
  00113	8b c8		 mov	 ecx, eax
  00115	ff 75 fc	 push	 DWORD PTR _n1$[ebp]
  00118	89 4d 08	 mov	 DWORD PTR _n2$[ebp], ecx
  0011b	e8 00 00 00 00	 call	 _r@12

; 113  : 	n2 = r(n1, n2, X6);

  00120	ff 75 f4	 push	 DWORD PTR _X6$[ebp]
  00123	8b c8		 mov	 ecx, eax
  00125	ff 75 08	 push	 DWORD PTR _n2$[ebp]
  00128	89 4d fc	 mov	 DWORD PTR _n1$[ebp], ecx
  0012b	e8 00 00 00 00	 call	 _r@12

; 114  : 	n1 = r(n2, n1, X7);

  00130	ff 75 f8	 push	 DWORD PTR _X7$[ebp]
  00133	8b c8		 mov	 ecx, eax
  00135	ff 75 fc	 push	 DWORD PTR _n1$[ebp]
  00138	89 4d 08	 mov	 DWORD PTR _n2$[ebp], ecx
  0013b	e8 00 00 00 00	 call	 _r@12

; 115  : 	
; 116  : 	n2 = r(n1, n2, X0);

  00140	57		 push	 edi
  00141	ff 75 08	 push	 DWORD PTR _n2$[ebp]
  00144	8b c8		 mov	 ecx, eax
  00146	89 4d fc	 mov	 DWORD PTR _n1$[ebp], ecx
  00149	e8 00 00 00 00	 call	 _r@12

; 117  : 	n1 = r(n2, n1, X1);

  0014e	ff 75 e4	 push	 DWORD PTR _X1$[ebp]
  00151	8b c8		 mov	 ecx, eax
  00153	ff 75 fc	 push	 DWORD PTR _n1$[ebp]
  00156	89 4d 08	 mov	 DWORD PTR _n2$[ebp], ecx
  00159	e8 00 00 00 00	 call	 _r@12

; 118  : 	n2 = r(n1, n2, X2);

  0015e	53		 push	 ebx
  0015f	ff 75 08	 push	 DWORD PTR _n2$[ebp]
  00162	8b c8		 mov	 ecx, eax
  00164	89 4d fc	 mov	 DWORD PTR _n1$[ebp], ecx
  00167	e8 00 00 00 00	 call	 _r@12

; 119  : 	n1 = r(n2, n1, X3);

  0016c	ff 75 e8	 push	 DWORD PTR _X3$[ebp]
  0016f	8b c8		 mov	 ecx, eax
  00171	ff 75 fc	 push	 DWORD PTR _n1$[ebp]
  00174	89 4d 08	 mov	 DWORD PTR _n2$[ebp], ecx
  00177	e8 00 00 00 00	 call	 _r@12

; 120  : 	n2 = r(n1, n2, X4);

  0017c	ff 75 ec	 push	 DWORD PTR _X4$[ebp]
  0017f	8b c8		 mov	 ecx, eax
  00181	ff 75 08	 push	 DWORD PTR _n2$[ebp]
  00184	89 4d fc	 mov	 DWORD PTR _n1$[ebp], ecx
  00187	e8 00 00 00 00	 call	 _r@12

; 121  : 	n1 = r(n2, n1, X5);

  0018c	ff 75 f0	 push	 DWORD PTR _X5$[ebp]
  0018f	8b c8		 mov	 ecx, eax
  00191	ff 75 fc	 push	 DWORD PTR _n1$[ebp]
  00194	89 4d 08	 mov	 DWORD PTR _n2$[ebp], ecx
  00197	e8 00 00 00 00	 call	 _r@12

; 122  : 	n2 = r(n1, n2, X6);

  0019c	ff 75 f4	 push	 DWORD PTR _X6$[ebp]
  0019f	8b c8		 mov	 ecx, eax
  001a1	ff 75 08	 push	 DWORD PTR _n2$[ebp]
  001a4	89 4d fc	 mov	 DWORD PTR _n1$[ebp], ecx
  001a7	e8 00 00 00 00	 call	 _r@12

; 123  : 	n1 = r(n2, n1, X7);

  001ac	ff 75 f8	 push	 DWORD PTR _X7$[ebp]
  001af	8b c8		 mov	 ecx, eax
  001b1	ff 75 fc	 push	 DWORD PTR _n1$[ebp]
  001b4	89 4d 08	 mov	 DWORD PTR _n2$[ebp], ecx
  001b7	e8 00 00 00 00	 call	 _r@12

; 124  : 
; 125  : 	n2 = r(n1, n2, X0);

  001bc	57		 push	 edi
  001bd	ff 75 08	 push	 DWORD PTR _n2$[ebp]
  001c0	8b c8		 mov	 ecx, eax
  001c2	89 4d fc	 mov	 DWORD PTR _n1$[ebp], ecx
  001c5	e8 00 00 00 00	 call	 _r@12

; 126  : 	n1 = r(n2, n1, X1);

  001ca	ff 75 e4	 push	 DWORD PTR _X1$[ebp]
  001cd	8b c8		 mov	 ecx, eax
  001cf	ff 75 fc	 push	 DWORD PTR _n1$[ebp]
  001d2	89 4d 08	 mov	 DWORD PTR _n2$[ebp], ecx
  001d5	e8 00 00 00 00	 call	 _r@12

; 127  : 	n2 = r(n1, n2, X2);

  001da	53		 push	 ebx
  001db	ff 75 08	 push	 DWORD PTR _n2$[ebp]
  001de	8b c8		 mov	 ecx, eax
  001e0	89 4d fc	 mov	 DWORD PTR _n1$[ebp], ecx
  001e3	e8 00 00 00 00	 call	 _r@12

; 128  : 	n1 = r(n2, n1, X3);

  001e8	ff 75 e8	 push	 DWORD PTR _X3$[ebp]
  001eb	8b c8		 mov	 ecx, eax
  001ed	ff 75 fc	 push	 DWORD PTR _n1$[ebp]
  001f0	89 4d 08	 mov	 DWORD PTR _n2$[ebp], ecx
  001f3	e8 00 00 00 00	 call	 _r@12

; 129  : 	n2 = r(n1, n2, X4);

  001f8	ff 75 ec	 push	 DWORD PTR _X4$[ebp]
  001fb	8b c8		 mov	 ecx, eax
  001fd	ff 75 08	 push	 DWORD PTR _n2$[ebp]
  00200	89 4d fc	 mov	 DWORD PTR _n1$[ebp], ecx
  00203	e8 00 00 00 00	 call	 _r@12

; 130  : 	n1 = r(n2, n1, X5);

  00208	ff 75 f0	 push	 DWORD PTR _X5$[ebp]
  0020b	8b c8		 mov	 ecx, eax
  0020d	ff 75 fc	 push	 DWORD PTR _n1$[ebp]
  00210	89 4d 08	 mov	 DWORD PTR _n2$[ebp], ecx
  00213	e8 00 00 00 00	 call	 _r@12

; 131  : 	n2 = r(n1, n2, X6);

  00218	ff 75 f4	 push	 DWORD PTR _X6$[ebp]
  0021b	8b c8		 mov	 ecx, eax
  0021d	ff 75 08	 push	 DWORD PTR _n2$[ebp]
  00220	89 4d fc	 mov	 DWORD PTR _n1$[ebp], ecx
  00223	e8 00 00 00 00	 call	 _r@12

; 132  : 	n1 = r(n2, n1, X7);

  00228	ff 75 f8	 push	 DWORD PTR _X7$[ebp]
  0022b	8b c8		 mov	 ecx, eax
  0022d	ff 75 fc	 push	 DWORD PTR _n1$[ebp]
  00230	89 4d 08	 mov	 DWORD PTR _n2$[ebp], ecx
  00233	e8 00 00 00 00	 call	 _r@12

; 133  : 
; 134  : 	/* Encryption rounds 25-32 */
; 135  : 	n2 = r(n1, n2, X7);

  00238	ff 75 f8	 push	 DWORD PTR _X7$[ebp]
  0023b	8b c8		 mov	 ecx, eax
  0023d	ff 75 08	 push	 DWORD PTR _n2$[ebp]
  00240	89 4d fc	 mov	 DWORD PTR _n1$[ebp], ecx
  00243	e8 00 00 00 00	 call	 _r@12

; 136  : 	n1 = r(n2, n1, X6);

  00248	ff 75 f4	 push	 DWORD PTR _X6$[ebp]
  0024b	8b c8		 mov	 ecx, eax
  0024d	ff 75 fc	 push	 DWORD PTR _n1$[ebp]
  00250	89 4d 08	 mov	 DWORD PTR _n2$[ebp], ecx
  00253	e8 00 00 00 00	 call	 _r@12

; 137  : 	n2 = r(n1, n2, X5);

  00258	ff 75 f0	 push	 DWORD PTR _X5$[ebp]
  0025b	8b c8		 mov	 ecx, eax
  0025d	ff 75 08	 push	 DWORD PTR _n2$[ebp]
  00260	89 4d fc	 mov	 DWORD PTR _n1$[ebp], ecx
  00263	e8 00 00 00 00	 call	 _r@12

; 138  : 	n1 = r(n2, n1, X4);

  00268	ff 75 ec	 push	 DWORD PTR _X4$[ebp]
  0026b	8b c8		 mov	 ecx, eax
  0026d	ff 75 fc	 push	 DWORD PTR _n1$[ebp]
  00270	89 4d 08	 mov	 DWORD PTR _n2$[ebp], ecx
  00273	e8 00 00 00 00	 call	 _r@12

; 139  : 	n2 = r(n1, n2, X3);

  00278	ff 75 e8	 push	 DWORD PTR _X3$[ebp]
  0027b	8b c8		 mov	 ecx, eax
  0027d	ff 75 08	 push	 DWORD PTR _n2$[ebp]
  00280	89 4d fc	 mov	 DWORD PTR _n1$[ebp], ecx
  00283	e8 00 00 00 00	 call	 _r@12

; 140  : 	n1 = r(n2, n1, X2);

  00288	53		 push	 ebx
  00289	ff 75 fc	 push	 DWORD PTR _n1$[ebp]
  0028c	8b c8		 mov	 ecx, eax
  0028e	89 4d 08	 mov	 DWORD PTR _n2$[ebp], ecx
  00291	e8 00 00 00 00	 call	 _r@12

; 141  : 	n2 = r(n1, n2, X1);

  00296	ff 75 e4	 push	 DWORD PTR _X1$[ebp]
  00299	8b c8		 mov	 ecx, eax
  0029b	ff 75 08	 push	 DWORD PTR _n2$[ebp]
  0029e	89 45 fc	 mov	 DWORD PTR _n1$[ebp], eax
  002a1	e8 00 00 00 00	 call	 _r@12

; 142  : 	n1 = r(n2, n1, X0);

  002a6	57		 push	 edi
  002a7	ff 75 fc	 push	 DWORD PTR _n1$[ebp]
  002aa	8b d8		 mov	 ebx, eax
  002ac	8b cb		 mov	 ecx, ebx
  002ae	e8 00 00 00 00	 call	 _r@12

; 143  : 
; 144  : 	out[0] = (byte)(n2 & 0xFF); out[1] = (byte)((n2 >> 8) & 0xFF); out[2] = (byte)((n2 >> 16) & 0xFF); out[3] = (byte)((n2 >> 24) & 0xFF);

  002b3	88 1e		 mov	 BYTE PTR [esi], bl
  002b5	8b cb		 mov	 ecx, ebx
  002b7	c1 e9 08	 shr	 ecx, 8
  002ba	88 4e 01	 mov	 BYTE PTR [esi+1], cl
  002bd	8b cb		 mov	 ecx, ebx
  002bf	c1 e9 10	 shr	 ecx, 16			; 00000010H
  002c2	88 4e 02	 mov	 BYTE PTR [esi+2], cl

; 145  : 	out[4] = (byte)(n1 & 0xFF); out[5] = (byte)((n1 >> 8) & 0xFF); out[6] = (byte)((n1 >> 16) & 0xFF); out[7] = (byte)((n1 >> 24) & 0xFF);

  002c5	8b c8		 mov	 ecx, eax
  002c7	c1 e9 08	 shr	 ecx, 8
  002ca	88 4e 05	 mov	 BYTE PTR [esi+5], cl
  002cd	8b c8		 mov	 ecx, eax
  002cf	c1 eb 18	 shr	 ebx, 24			; 00000018H
  002d2	c1 e9 10	 shr	 ecx, 16			; 00000010H
  002d5	88 46 04	 mov	 BYTE PTR [esi+4], al
  002d8	c1 e8 18	 shr	 eax, 24			; 00000018H
  002db	5f		 pop	 edi
  002dc	88 5e 03	 mov	 BYTE PTR [esi+3], bl
  002df	88 4e 06	 mov	 BYTE PTR [esi+6], cl
  002e2	88 46 07	 mov	 BYTE PTR [esi+7], al
  002e5	5b		 pop	 ebx

; 146  : }

  002e6	c9		 leave
  002e7	c2 04 00	 ret	 4
_gost_encrypt_with_key@12 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _copy_blocks@12
_TEXT	SEGMENT
_copy_blocks@12 PROC					; COMDAT
; _dst$ = eax
; _src$ = ecx
; _len$ = edx

; 160  : {

  00000	8b ff		 npad	 2
  00002	56		 push	 esi
  00003	8b f2		 mov	 esi, edx

; 161  : 	gst_dword i;
; 162  : 	for (i = 0; i < len; i++)

  00005	85 f6		 test	 esi, esi
  00007	7e 0b		 jle	 SHORT $LN1@copy_block
  00009	2b c8		 sub	 ecx, eax
$LL3@copy_block:

; 163  : 		dst[i] = src[i];

  0000b	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  0000e	88 10		 mov	 BYTE PTR [eax], dl
  00010	40		 inc	 eax
  00011	4e		 dec	 esi
  00012	75 f7		 jne	 SHORT $LL3@copy_block
$LN1@copy_block:
  00014	5e		 pop	 esi

; 164  : }

  00015	c3		 ret	 0
_copy_blocks@12 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _move_blocks@12
_TEXT	SEGMENT
_from$ = 8						; size = 4
_move_blocks@12 PROC					; COMDAT
; _to$ = edx
; _len$ = eax

; 177  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi
  00006	8b f0		 mov	 esi, eax

; 178  : 	gst_dword i;
; 179  : 	if (from < to)

  00008	39 55 08	 cmp	 DWORD PTR _from$[ebp], edx
  0000b	73 1c		 jae	 SHORT $LN8@move_block

; 180  : 		for (i = len-1; i >= 0; i--)

  0000d	8d 4e ff	 lea	 ecx, DWORD PTR [esi-1]
  00010	85 c9		 test	 ecx, ecx
  00012	7c 29		 jl	 SHORT $LN1@move_block
  00014	8b 75 08	 mov	 esi, DWORD PTR _from$[ebp]
  00017	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  0001a	2b f2		 sub	 esi, edx
$LL7@move_block:

; 181  : 			to[i] = from[i];

  0001c	8a 14 06	 mov	 dl, BYTE PTR [esi+eax]
  0001f	49		 dec	 ecx
  00020	88 10		 mov	 BYTE PTR [eax], dl
  00022	48		 dec	 eax
  00023	85 c9		 test	 ecx, ecx
  00025	7d f5		 jge	 SHORT $LL7@move_block

; 182  : 	else

  00027	eb 14		 jmp	 SHORT $LN1@move_block
$LN8@move_block:

; 183  : 		for (i = 0; i < len; i++)

  00029	85 f6		 test	 esi, esi
  0002b	7e 10		 jle	 SHORT $LN1@move_block
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  00030	8b c2		 mov	 eax, edx
  00032	2b ca		 sub	 ecx, edx
$LL3@move_block:

; 184  : 			to[i] = from[i];

  00034	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  00037	88 10		 mov	 BYTE PTR [eax], dl
  00039	40		 inc	 eax
  0003a	4e		 dec	 esi
  0003b	75 f7		 jne	 SHORT $LL3@move_block
$LN1@move_block:
  0003d	5e		 pop	 esi

; 185  : }

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
_move_blocks@12 ENDP
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT _set_blocks@12
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_val$ = 12						; size = 1
_len$ = 16						; size = 4
_set_blocks@12 PROC					; COMDAT

; 198  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 199  : 	gst_dword i;
; 200  : 	for (i = 0; i < len; i++)

  00005	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00009	7e 11		 jle	 SHORT $LN3@set_blocks
  0000b	ff 75 10	 push	 DWORD PTR _len$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR _val$[ebp]
  00011	ff 75 08	 push	 DWORD PTR _ptr$[ebp]
  00014	e8 00 00 00 00	 call	 _memset
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@set_blocks:

; 201  : 		ptr[i] = val;
; 202  : }

  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
_set_blocks@12 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _add_blocks@12
_TEXT	SEGMENT
_add_blocks@12 PROC					; COMDAT
; _T$ = ecx
; _F$ = edx
; _len$ = eax

; 216  : {

  00000	8b ff		 npad	 2
  00002	56		 push	 esi
  00003	8b f0		 mov	 esi, eax

; 217  : 	gst_dword i;
; 218  : 	gst_word carry = 0;

  00005	33 c0		 xor	 eax, eax

; 219  : 	gst_word sum;
; 220  : 	for (i = 0; i < len; i++)

  00007	85 f6		 test	 esi, esi
  00009	7e 25		 jle	 SHORT $LN1@add_blocks
  0000b	53		 push	 ebx
  0000c	2b d1		 sub	 edx, ecx
  0000e	57		 push	 edi
$LL3@add_blocks:

; 221  : 	{
; 222  : 		sum = (gst_word)T[i] + (gst_word)F[i] + carry;

  0000f	66 0f b6 3c 0a	 movzx	 di, BYTE PTR [edx+ecx]
  00014	66 0f b6 19	 movzx	 bx, BYTE PTR [ecx]
  00018	66 03 fb	 add	 di, bx
  0001b	66 03 f8	 add	 di, ax
  0001e	0f b7 c7	 movzx	 eax, di

; 223  : 		T[i] = (byte)sum & 0xFF;

  00021	88 01		 mov	 BYTE PTR [ecx], al

; 224  : 		carry = sum >> 8;

  00023	66 c1 f8 08	 sar	 ax, 8
  00027	41		 inc	 ecx
  00028	4e		 dec	 esi
  00029	0f b7 c0	 movzx	 eax, ax
  0002c	75 e1		 jne	 SHORT $LL3@add_blocks
  0002e	5f		 pop	 edi
  0002f	5b		 pop	 ebx
$LN1@add_blocks:
  00030	5e		 pop	 esi

; 225  : 	}
; 226  : }

  00031	c3		 ret	 0
_add_blocks@12 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _xor_blocks@16
_TEXT	SEGMENT
_T$ = 8							; size = 4
_xor_blocks@16 PROC					; COMDAT
; _F$ = ecx
; _S$ = eax
; _len$ = edx

; 240  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	57		 push	 edi
  00006	8b fa		 mov	 edi, edx

; 241  : 	gst_dword i;
; 242  : 	for (i = 0; i < len; i++)

  00008	85 ff		 test	 edi, edi
  0000a	7e 15		 jle	 SHORT $LN1@xor_blocks
  0000c	56		 push	 esi
  0000d	8b 75 08	 mov	 esi, DWORD PTR _T$[ebp]
  00010	2b c8		 sub	 ecx, eax
  00012	2b f0		 sub	 esi, eax
$LL3@xor_blocks:

; 243  : 		T[i] = F[i] ^ S[i];

  00014	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00017	32 10		 xor	 dl, BYTE PTR [eax]
  00019	88 14 06	 mov	 BYTE PTR [esi+eax], dl
  0001c	40		 inc	 eax
  0001d	4f		 dec	 edi
  0001e	75 f4		 jne	 SHORT $LL3@xor_blocks
  00020	5e		 pop	 esi
$LN1@xor_blocks:
  00021	5f		 pop	 edi

; 244  : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
_xor_blocks@16 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _P_transform@8
_TEXT	SEGMENT
_T$ = 8							; size = 4
_P_transform@8 PROC					; COMDAT
; _F$ = eax

; 260  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 261  : 	gst_dword i, k;
; 262  : 	for (i = 0; i < 4; i++)

  00007	33 f6		 xor	 esi, esi
  00009	8b f8		 mov	 edi, eax
$LL6@P_transfor:

; 263  : 		for (k = 0; k < 8; k++)

  0000b	8b 45 08	 mov	 eax, DWORD PTR _T$[ebp]
  0000e	33 c9		 xor	 ecx, ecx
  00010	03 c6		 add	 eax, esi
$LL3@P_transfor:

; 264  : 			T[i+4*k] = F[8*i+k];

  00012	8a 14 0f	 mov	 dl, BYTE PTR [edi+ecx]
  00015	88 10		 mov	 BYTE PTR [eax], dl
  00017	41		 inc	 ecx
  00018	83 c0 04	 add	 eax, 4
  0001b	83 f9 08	 cmp	 ecx, 8
  0001e	7c f2		 jl	 SHORT $LL3@P_transfor
  00020	46		 inc	 esi
  00021	83 c7 08	 add	 edi, 8
  00024	83 fe 04	 cmp	 esi, 4
  00027	7c e2		 jl	 SHORT $LL6@P_transfor
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi

; 265  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
_P_transform@8 ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _A@8
_TEXT	SEGMENT
_A@8	PROC						; COMDAT
; _F$ = edi
; _T$ = eax

; 279  : {

  00000	8b ff		 npad	 2
  00002	56		 push	 esi

; 280  : 	byte i;
; 281  : 	for (i = 0; i < 24; i++)

  00003	6a 18		 push	 24			; 00000018H
  00005	8b f0		 mov	 esi, eax
  00007	59		 pop	 ecx
  00008	8b d6		 mov	 edx, esi
  0000a	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  0000d	53		 push	 ebx
$LL6@A:

; 282  : 		T[i] = F[i+8];

  0000e	8a 18		 mov	 bl, BYTE PTR [eax]
  00010	40		 inc	 eax
  00011	88 1a		 mov	 BYTE PTR [edx], bl
  00013	42		 inc	 edx
  00014	49		 dec	 ecx
  00015	75 f7		 jne	 SHORT $LL6@A

; 283  : 	for (i = 0; i < 8; i++)

  00017	6a 08		 push	 8
  00019	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  0001c	5e		 pop	 esi
  0001d	8b cf		 mov	 ecx, edi
  0001f	5b		 pop	 ebx
$LL3@A:

; 284  : 		T[i+24] = F[i] ^ F[i+8];

  00020	8a 51 08	 mov	 dl, BYTE PTR [ecx+8]
  00023	32 11		 xor	 dl, BYTE PTR [ecx]
  00025	41		 inc	 ecx
  00026	88 10		 mov	 BYTE PTR [eax], dl
  00028	40		 inc	 eax
  00029	4e		 dec	 esi
  0002a	75 f4		 jne	 SHORT $LL3@A
  0002c	5e		 pop	 esi

; 285  : }

  0002d	c3		 ret	 0
_A@8	ENDP
; Function compile flags: /Ogsp
_TEXT	ENDS
;	COMDAT _PSI@4
_TEXT	SEGMENT
_PSI@4	PROC						; COMDAT
; _X$ = eax

; 297  : 	gst_word T;
; 298  : 
; 299  : 	T = (gst_word)(X[0]^X[2]^X[4]^X[6]^X[24]^X[30])|
; 300  : 		((gst_word)(X[1]^X[3]^X[5]^X[7]^X[25]^X[31])<<8);

  00000	8a 48 19	 mov	 cl, BYTE PTR [eax+25]
  00003	32 48 07	 xor	 cl, BYTE PTR [eax+7]
  00006	53		 push	 ebx
  00007	32 48 05	 xor	 cl, BYTE PTR [eax+5]
  0000a	8a 58 18	 mov	 bl, BYTE PTR [eax+24]
  0000d	32 58 06	 xor	 bl, BYTE PTR [eax+6]
  00010	32 48 03	 xor	 cl, BYTE PTR [eax+3]
  00013	32 58 04	 xor	 bl, BYTE PTR [eax+4]
  00016	32 48 01	 xor	 cl, BYTE PTR [eax+1]
  00019	32 58 1e	 xor	 bl, BYTE PTR [eax+30]
  0001c	32 48 1f	 xor	 cl, BYTE PTR [eax+31]
  0001f	32 18		 xor	 bl, BYTE PTR [eax]
  00021	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  00024	32 1a		 xor	 bl, BYTE PTR [edx]
  00026	56		 push	 esi
  00027	66 0f b6 c9	 movzx	 cx, cl
  0002b	66 0f b6 f3	 movzx	 si, bl
  0002f	66 c1 e1 08	 shl	 cx, 8
  00033	66 0b ce	 or	 cx, si

; 301  : 	move_blocks(X, X+2, 30);

  00036	8b f2		 mov	 esi, edx
  00038	2b f0		 sub	 esi, eax
  0003a	57		 push	 edi
  0003b	0f b7 d9	 movzx	 ebx, cx
  0003e	3b d0		 cmp	 edx, eax
  00040	73 13		 jae	 SHORT $LN10@PSI
  00042	6a 1d		 push	 29			; 0000001dH
  00044	5f		 pop	 edi
  00045	8d 48 1d	 lea	 ecx, DWORD PTR [eax+29]
$LL9@PSI:
  00048	8a 14 0e	 mov	 dl, BYTE PTR [esi+ecx]
  0004b	4f		 dec	 edi
  0004c	88 11		 mov	 BYTE PTR [ecx], dl
  0004e	49		 dec	 ecx
  0004f	85 ff		 test	 edi, edi
  00051	7d f5		 jge	 SHORT $LL9@PSI
  00053	eb 0e		 jmp	 SHORT $LN3@PSI
$LN10@PSI:
  00055	6a 1e		 push	 30			; 0000001eH
  00057	8b c8		 mov	 ecx, eax
  00059	5f		 pop	 edi
$LL5@PSI:
  0005a	8a 14 31	 mov	 dl, BYTE PTR [ecx+esi]
  0005d	88 11		 mov	 BYTE PTR [ecx], dl
  0005f	41		 inc	 ecx
  00060	4f		 dec	 edi
  00061	75 f7		 jne	 SHORT $LL5@PSI
$LN3@PSI:

; 302  : 	X[30] = (byte)(T&0xFF);

  00063	88 58 1e	 mov	 BYTE PTR [eax+30], bl
  00066	5f		 pop	 edi

; 303  : 	X[31] = (byte)(T>>8);

  00067	c1 fb 08	 sar	 ebx, 8
  0006a	5e		 pop	 esi
  0006b	88 58 1f	 mov	 BYTE PTR [eax+31], bl
  0006e	5b		 pop	 ebx

; 304  : }

  0006f	c3		 ret	 0
_PSI@4	ENDP
_TEXT	ENDS
PUBLIC	_GOSTHASH_init@4
; Function compile flags: /Ogsp
;	COMDAT _GOSTHASH_init@4
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_GOSTHASH_init@4 PROC					; COMDAT

; 315  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 316  : 	set_blocks((byte *)ctx, 0, sizeof(gost_hash_ctx));

  00005	6a 68		 push	 104			; 00000068H
  00007	6a 00		 push	 0
  00009	ff 75 08	 push	 DWORD PTR _ctx$[ebp]
  0000c	e8 00 00 00 00	 call	 _memset
  00011	83 c4 0c	 add	 esp, 12			; 0000000cH

; 317  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
_GOSTHASH_init@4 ENDP
_TEXT	ENDS
PUBLIC	_M$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Ogsp
;	COMDAT _step@12
_TEXT	SEGMENT
_M$GSCopy$ = -264					; size = 4
_K$ = -260						; size = 128
_W$ = -132						; size = 32
_U$ = -100						; size = 32
_S$ = -68						; size = 32
_V$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_M$ = 8							; size = 4
_step@12 PROC						; COMDAT
; _H$ = ebx

; 330  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 08	 mov	 eax, DWORD PTR _M$[ebp]
  00018	56		 push	 esi
  00019	57		 push	 edi

; 331  : 	byte U[32], W[32], V[32], S[32], K[4][32];
; 332  : 	gst_dword i;
; 333  : 	
; 334  : 	xor_blocks(W, H, M, 32);

  0001a	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _W$[ebp]
  00020	51		 push	 ecx
  00021	6a 20		 push	 32			; 00000020H
  00023	5a		 pop	 edx
  00024	8b cb		 mov	 ecx, ebx

; 335  : 	P_transform(W, K[0]); //First key
; 336  : 
; 337  : 	gost_encrypt_with_key (H, S, K[0]);
; 338  : 
; 339  : 	A (H, U);
; 340  : 	A (M, V);
; 341  : 	A (V, V);
; 342  : 	xor_blocks(W, U, V, 32);
; 343  : 	P_transform(W, K[1]); //Second key
; 344  : 
; 345  : 	gost_encrypt_with_key (H + 8, S + 8, K[1]);
; 346  : 
; 347  : 	A (U, U);
; 348  : 	/* As the other C values are all 0's, we only need to XOR
; 349  :      * with C[3] */
; 350  : 	xor_blocks(U, U, C_3, 32);
; 351  : 	A (V, V);
; 352  : 	A (V, V);
; 353  : 	xor_blocks (W, U, V, 32);
; 354  : 	P_transform (W, K[2]); //Third key
; 355  : 	
; 356  : 	gost_encrypt_with_key (H + 16, S + 16, K[2]);
; 357  : 	
; 358  : 	A (U, U);
; 359  : 	A (V, V);
; 360  : 	A (V, V);
; 361  : 	xor_blocks (W, U, V, 32);
; 362  : 	P_transform (W, K[3]); //Fourth key
; 363  : 	
; 364  : 	gost_encrypt_with_key (H + 24, S + 24, K[3]);
; 365  : 
; 366  : 	for (i = 0; i < 12; i++)
; 367  : 		PSI (S);
; 368  : 	xor_blocks (S, S, M, 32);
; 369  : 	PSI (S);
; 370  : 	xor_blocks (S, S, H, 32);
; 371  : 	for (i = 0; i < 61; i++)
; 372  : 		PSI (S);
; 373  : 	copy_blocks (H, S, 32);

  00026	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _M$GSCopy$[ebp], eax
  0002c	e8 00 00 00 00	 call	 _xor_blocks@16
  00031	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _K$[ebp]
  00037	50		 push	 eax
  00038	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _W$[ebp]
  0003e	e8 00 00 00 00	 call	 _P_transform@8
  00043	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _K$[ebp]
  00049	50		 push	 eax
  0004a	8d 75 bc	 lea	 esi, DWORD PTR _S$[ebp]
  0004d	8b c3		 mov	 eax, ebx
  0004f	e8 00 00 00 00	 call	 _gost_encrypt_with_key@12
  00054	8d 45 9c	 lea	 eax, DWORD PTR _U$[ebp]
  00057	8b fb		 mov	 edi, ebx
  00059	e8 00 00 00 00	 call	 _A@8
  0005e	8b bd f8 fe ff
	ff		 mov	 edi, DWORD PTR _M$GSCopy$[ebp]
  00064	8d 45 dc	 lea	 eax, DWORD PTR _V$[ebp]
  00067	e8 00 00 00 00	 call	 _A@8
  0006c	8d 45 dc	 lea	 eax, DWORD PTR _V$[ebp]
  0006f	8b f8		 mov	 edi, eax
  00071	e8 00 00 00 00	 call	 _A@8
  00076	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _W$[ebp]
  0007c	50		 push	 eax
  0007d	6a 20		 push	 32			; 00000020H
  0007f	5a		 pop	 edx
  00080	8b c7		 mov	 eax, edi
  00082	8d 4d 9c	 lea	 ecx, DWORD PTR _U$[ebp]
  00085	e8 00 00 00 00	 call	 _xor_blocks@16
  0008a	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _K$[ebp+32]
  00090	50		 push	 eax
  00091	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _W$[ebp]
  00097	e8 00 00 00 00	 call	 _P_transform@8
  0009c	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _K$[ebp+32]
  000a2	50		 push	 eax
  000a3	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  000a6	8d 75 c4	 lea	 esi, DWORD PTR _S$[ebp+8]
  000a9	e8 00 00 00 00	 call	 _gost_encrypt_with_key@12
  000ae	8d 45 9c	 lea	 eax, DWORD PTR _U$[ebp]
  000b1	8b f8		 mov	 edi, eax
  000b3	e8 00 00 00 00	 call	 _A@8
  000b8	8b c7		 mov	 eax, edi
  000ba	50		 push	 eax
  000bb	6a 20		 push	 32			; 00000020H
  000bd	5a		 pop	 edx
  000be	b8 00 00 00 00	 mov	 eax, OFFSET _C_3
  000c3	8b cf		 mov	 ecx, edi
  000c5	e8 00 00 00 00	 call	 _xor_blocks@16
  000ca	8d 45 dc	 lea	 eax, DWORD PTR _V$[ebp]
  000cd	8b f8		 mov	 edi, eax
  000cf	e8 00 00 00 00	 call	 _A@8
  000d4	8b c7		 mov	 eax, edi
  000d6	e8 00 00 00 00	 call	 _A@8
  000db	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _W$[ebp]
  000e1	50		 push	 eax
  000e2	6a 20		 push	 32			; 00000020H
  000e4	5a		 pop	 edx
  000e5	8b c7		 mov	 eax, edi
  000e7	8d 4d 9c	 lea	 ecx, DWORD PTR _U$[ebp]
  000ea	e8 00 00 00 00	 call	 _xor_blocks@16
  000ef	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _K$[ebp+64]
  000f5	50		 push	 eax
  000f6	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _W$[ebp]
  000fc	e8 00 00 00 00	 call	 _P_transform@8
  00101	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _K$[ebp+64]
  00107	50		 push	 eax
  00108	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  0010b	8d 75 cc	 lea	 esi, DWORD PTR _S$[ebp+16]
  0010e	e8 00 00 00 00	 call	 _gost_encrypt_with_key@12
  00113	8d 45 9c	 lea	 eax, DWORD PTR _U$[ebp]
  00116	8b f8		 mov	 edi, eax
  00118	e8 00 00 00 00	 call	 _A@8
  0011d	8d 45 dc	 lea	 eax, DWORD PTR _V$[ebp]
  00120	8b f8		 mov	 edi, eax
  00122	e8 00 00 00 00	 call	 _A@8
  00127	8b c7		 mov	 eax, edi
  00129	e8 00 00 00 00	 call	 _A@8
  0012e	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _W$[ebp]
  00134	50		 push	 eax
  00135	6a 20		 push	 32			; 00000020H
  00137	5f		 pop	 edi
  00138	8b d7		 mov	 edx, edi
  0013a	8d 45 dc	 lea	 eax, DWORD PTR _V$[ebp]
  0013d	8d 4d 9c	 lea	 ecx, DWORD PTR _U$[ebp]
  00140	e8 00 00 00 00	 call	 _xor_blocks@16
  00145	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _K$[ebp+96]
  0014b	50		 push	 eax
  0014c	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _W$[ebp]
  00152	e8 00 00 00 00	 call	 _P_transform@8
  00157	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _K$[ebp+96]
  0015d	50		 push	 eax
  0015e	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
  00161	8d 75 d4	 lea	 esi, DWORD PTR _S$[ebp+24]
  00164	e8 00 00 00 00	 call	 _gost_encrypt_with_key@12
  00169	6a 0c		 push	 12			; 0000000cH
  0016b	5e		 pop	 esi
$LL6@step:
  0016c	8d 45 bc	 lea	 eax, DWORD PTR _S$[ebp]
  0016f	e8 00 00 00 00	 call	 _PSI@4
  00174	4e		 dec	 esi
  00175	75 f5		 jne	 SHORT $LL6@step
  00177	50		 push	 eax
  00178	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _M$GSCopy$[ebp]
  0017e	8b d7		 mov	 edx, edi
  00180	8d 4d bc	 lea	 ecx, DWORD PTR _S$[ebp]
  00183	e8 00 00 00 00	 call	 _xor_blocks@16
  00188	8d 45 bc	 lea	 eax, DWORD PTR _S$[ebp]
  0018b	e8 00 00 00 00	 call	 _PSI@4
  00190	50		 push	 eax
  00191	8b d7		 mov	 edx, edi
  00193	8b c3		 mov	 eax, ebx
  00195	8d 4d bc	 lea	 ecx, DWORD PTR _S$[ebp]
  00198	e8 00 00 00 00	 call	 _xor_blocks@16
  0019d	6a 3d		 push	 61			; 0000003dH
  0019f	5e		 pop	 esi
$LL3@step:
  001a0	8d 45 bc	 lea	 eax, DWORD PTR _S$[ebp]
  001a3	e8 00 00 00 00	 call	 _PSI@4
  001a8	4e		 dec	 esi
  001a9	75 f5		 jne	 SHORT $LL3@step
  001ab	57		 push	 edi
  001ac	50		 push	 eax
  001ad	53		 push	 ebx
  001ae	e8 00 00 00 00	 call	 _memcpy

; 374  : }

  001b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b9	5f		 pop	 edi
  001ba	33 cd		 xor	 ecx, ebp
  001bc	5e		 pop	 esi
  001bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c2	c9		 leave
  001c3	c2 04 00	 ret	 4
_step@12 ENDP
_TEXT	ENDS
PUBLIC	_GOSTHASH_add@12
; Function compile flags: /Ogsp
;	COMDAT _GOSTHASH_add@12
_TEXT	SEGMENT
_curptr$ = 8						; size = 4
_block$ = 8						; size = 4
_len$ = 12						; size = 4
_ctx$ = 16						; size = 4
_GOSTHASH_add@12 PROC					; COMDAT

; 387  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	53		 push	 ebx
  00006	56		 push	 esi

; 388  : 	gst_udword add_bytes;
; 389  : 
; 390  : 	byte *curptr = block;
; 391  : 	byte *barrier = block + (len - 32); //In order that curptr += 32 won't overshoot len.
; 392  : 
; 393  : 	if (ctx->left) //There are unsigned chars left from the last GOSTHASH_add

  00007	8b 75 10	 mov	 esi, DWORD PTR _ctx$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	57		 push	 edi
  0000e	8b 7d 08	 mov	 edi, DWORD PTR _block$[ebp]
  00011	89 7d 08	 mov	 DWORD PTR _curptr$[ebp], edi
  00014	85 c0		 test	 eax, eax
  00016	0f 84 ab 00 00
	00		 je	 $LN7@GOSTHASH_a

; 394  : 	{
; 395  : 		add_bytes = (32 - ctx->left) > len ? len : (32 - ctx->left);

  0001c	6a 20		 push	 32			; 00000020H
  0001e	5b		 pop	 ebx
  0001f	2b d8		 sub	 ebx, eax
  00021	3b 5d 0c	 cmp	 ebx, DWORD PTR _len$[ebp]
  00024	76 03		 jbe	 SHORT $LN10@GOSTHASH_a
  00026	8b 5d 0c	 mov	 ebx, DWORD PTR _len$[ebp]
$LN10@GOSTHASH_a:

; 396  : 		copy_blocks(ctx->remainder + (byte)ctx->left, block, (gst_dword)add_bytes);

  00029	0f b6 c0	 movzx	 eax, al
  0002c	8d 44 30 48	 lea	 eax, DWORD PTR [eax+esi+72]
  00030	8b d3		 mov	 edx, ebx
  00032	8b cf		 mov	 ecx, edi
  00034	e8 00 00 00 00	 call	 _copy_blocks@12

; 397  : 		if ((ctx->left + add_bytes) < 32) //This can be finished in the finalize stage if needed

  00039	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003c	03 c3		 add	 eax, ebx
  0003e	83 f8 20	 cmp	 eax, 32			; 00000020H
  00041	72 7d		 jb	 SHORT $LN1@GOSTHASH_a

; 398  : 		{
; 399  : 			return;
; 400  : 		}
; 401  : 		
; 402  : 		curptr += add_bytes;

  00043	03 df		 add	 ebx, edi

; 403  : 		step (ctx->H, ctx->remainder, ctx);

  00045	8d 46 48	 lea	 eax, DWORD PTR [esi+72]
  00048	89 5d 08	 mov	 DWORD PTR _curptr$[ebp], ebx
  0004b	50		 push	 eax
  0004c	8d 5e 08	 lea	 ebx, DWORD PTR [esi+8]
  0004f	e8 00 00 00 00	 call	 _step@12

; 404  : 		add_blocks(ctx->S, ctx->remainder, 32);

  00054	6a 20		 push	 32			; 00000020H
  00056	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  00059	58		 pop	 eax
  0005a	8d 56 48	 lea	 edx, DWORD PTR [esi+72]
  0005d	e8 00 00 00 00	 call	 _add_blocks@12

; 405  : 		ctx->len += 32;

  00062	83 06 20	 add	 DWORD PTR [esi], 32	; 00000020H

; 406  : 		ctx->left = 0;

  00065	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00069	8b 5d 0c	 mov	 ebx, DWORD PTR _len$[ebp]
$LN12@GOSTHASH_a:

; 413  : 	}
; 414  : 
; 415  : 	while (curptr <= barrier) //Add the input block to the hash

  0006c	8d 44 1f e0	 lea	 eax, DWORD PTR [edi+ebx-32]
  00070	39 45 08	 cmp	 DWORD PTR _curptr$[ebp], eax
  00073	77 30		 ja	 SHORT $LN2@GOSTHASH_a
  00075	8d 5e 08	 lea	 ebx, DWORD PTR [esi+8]
$LL3@GOSTHASH_a:

; 416  : 	{
; 417  : 		step(ctx->H, curptr, ctx);

  00078	ff 75 08	 push	 DWORD PTR _curptr$[ebp]
  0007b	e8 00 00 00 00	 call	 _step@12

; 418  : 		
; 419  : 		add_blocks(ctx->S, curptr, 32); //Add 32 unsigned chars of the message to the encrypted message

  00080	8b 55 08	 mov	 edx, DWORD PTR _curptr$[ebp]
  00083	6a 20		 push	 32			; 00000020H
  00085	58		 pop	 eax
  00086	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  00089	e8 00 00 00 00	 call	 _add_blocks@12
  0008e	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]

; 420  : 		
; 421  : 		ctx->len += 32; //We've processed 32 unsigned chars
; 422  : 		curptr += 32; //Advance the block-pointer 32 unsigned chars

  00091	83 45 08 20	 add	 DWORD PTR _curptr$[ebp], 32 ; 00000020H
  00095	83 06 20	 add	 DWORD PTR [esi], 32	; 00000020H
  00098	03 c7		 add	 eax, edi
  0009a	83 c0 e0	 add	 eax, -32		; ffffffe0H
  0009d	39 45 08	 cmp	 DWORD PTR _curptr$[ebp], eax
  000a0	76 d6		 jbe	 SHORT $LL3@GOSTHASH_a

; 413  : 	}
; 414  : 
; 415  : 	while (curptr <= barrier) //Add the input block to the hash

  000a2	8b 5d 0c	 mov	 ebx, DWORD PTR _len$[ebp]
$LN2@GOSTHASH_a:

; 423  : 	}
; 424  : 
; 425  : 	if (curptr != block + len) //If we have unsigned chars remaining, add them for the next GOSTHASH_add of _finalize

  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _curptr$[ebp]
  000a8	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  000ab	3b c8		 cmp	 ecx, eax
  000ad	74 11		 je	 SHORT $LN1@GOSTHASH_a

; 426  : 	{
; 427  : 		ctx->left = (gst_udword)(block + len - curptr);

  000af	2b f9		 sub	 edi, ecx
  000b1	03 fb		 add	 edi, ebx

; 428  : 		copy_blocks(ctx->remainder, curptr, (gst_dword)ctx->left);

  000b3	8d 46 48	 lea	 eax, DWORD PTR [esi+72]
  000b6	8b d7		 mov	 edx, edi
  000b8	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  000bb	e8 00 00 00 00	 call	 _copy_blocks@12
$LN1@GOSTHASH_a:
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx

; 429  : 	}
; 430  : }

  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH
$LN7@GOSTHASH_a:

; 407  : 	}
; 408  : 	else if (ctx->left + len < 32)

  000c7	8b 5d 0c	 mov	 ebx, DWORD PTR _len$[ebp]
  000ca	83 fb 20	 cmp	 ebx, 32			; 00000020H
  000cd	73 9d		 jae	 SHORT $LN12@GOSTHASH_a

; 409  : 	{
; 410  : 		copy_blocks(ctx->remainder + (byte)ctx->left, block, (gst_dword)len);

  000cf	0f b6 c0	 movzx	 eax, al
  000d2	8d 44 30 48	 lea	 eax, DWORD PTR [eax+esi+72]
  000d6	8b d3		 mov	 edx, ebx
  000d8	8b cf		 mov	 ecx, edi
  000da	e8 00 00 00 00	 call	 _copy_blocks@12

; 411  : 		ctx->left += len;

  000df	01 5e 04	 add	 DWORD PTR [esi+4], ebx

; 412  : 		return;

  000e2	eb dc		 jmp	 SHORT $LN1@GOSTHASH_a
_GOSTHASH_add@12 ENDP
_TEXT	ENDS
PUBLIC	_out$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_GOSTHASH_finalize@8
; Function compile flags: /Ogsp
;	COMDAT _GOSTHASH_finalize@8
_TEXT	SEGMENT
_out$GSCopy$ = -108					; size = 4
_final_len$ = -104					; size = 4
_S$ = -100						; size = 32
_H$ = -68						; size = 32
_buf$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_ctx$ = 8						; size = 4
_out$ = 12						; size = 4
_GOSTHASH_finalize@8 PROC				; COMDAT

; 442  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000d	33 c5		 xor	 eax, ebp
  0000f	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00012	8b 45 0c	 mov	 eax, DWORD PTR _out$[ebp]
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR _ctx$[ebp]

; 443  : 	byte buf[32];
; 444  : 	byte H[32];
; 445  : 	byte S[32];
; 446  : 	gst_dword final_len;
; 447  : 	gst_dword bptr;
; 448  : 
; 449  : 	final_len = ctx->len;

  0001a	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001c	57		 push	 edi

; 450  : 	
; 451  : 	copy_blocks(H, ctx->H, 32);
; 452  : 	copy_blocks(S, ctx->S, 32);
; 453  : 
; 454  : 	if (ctx->left) //Handle any remaining bytes
; 455  : 	{
; 456  : 		set_blocks(buf, 0, 32);

  0001d	89 45 94	 mov	 DWORD PTR _out$GSCopy$[ebp], eax
  00020	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00023	6a 20		 push	 32			; 00000020H
  00025	50		 push	 eax
  00026	8d 45 bc	 lea	 eax, DWORD PTR _H$[ebp]
  00029	50		 push	 eax
  0002a	89 5d 98	 mov	 DWORD PTR _final_len$[ebp], ebx
  0002d	e8 00 00 00 00	 call	 _memcpy
  00032	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  00035	6a 20		 push	 32			; 00000020H
  00037	50		 push	 eax
  00038	8d 45 9c	 lea	 eax, DWORD PTR _S$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _memcpy
  00041	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00044	83 c4 18	 add	 esp, 24			; 00000018H
  00047	85 d2		 test	 edx, edx
  00049	74 38		 je	 SHORT $LN3@GOSTHASH_f
  0004b	6a 08		 push	 8
  0004d	33 c0		 xor	 eax, eax
  0004f	59		 pop	 ecx
  00050	8d 7d dc	 lea	 edi, DWORD PTR _buf$[ebp]
  00053	f3 ab		 rep stosd

; 457  : 		copy_blocks(buf, ctx->remainder, (gst_dword)ctx->left);

  00055	8d 4e 48	 lea	 ecx, DWORD PTR [esi+72]
  00058	8d 45 dc	 lea	 eax, DWORD PTR _buf$[ebp]
  0005b	e8 00 00 00 00	 call	 _copy_blocks@12

; 458  : 		step (H, buf, ctx);

  00060	8d 45 dc	 lea	 eax, DWORD PTR _buf$[ebp]
  00063	50		 push	 eax
  00064	8d 5d bc	 lea	 ebx, DWORD PTR _H$[ebp]
  00067	e8 00 00 00 00	 call	 _step@12

; 459  : 		add_blocks (S, buf, 32);

  0006c	6a 20		 push	 32			; 00000020H
  0006e	58		 pop	 eax
  0006f	8d 55 dc	 lea	 edx, DWORD PTR _buf$[ebp]
  00072	8d 4d 9c	 lea	 ecx, DWORD PTR _S$[ebp]
  00075	e8 00 00 00 00	 call	 _add_blocks@12

; 460  : 		final_len += ctx->left;

  0007a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0007d	01 45 98	 add	 DWORD PTR _final_len$[ebp], eax
  00080	8b 5d 98	 mov	 ebx, DWORD PTR _final_len$[ebp]
$LN3@GOSTHASH_f:

; 461  : 	}
; 462  : 
; 463  : 	set_blocks(buf, 0, 32);

  00083	6a 08		 push	 8
  00085	33 c0		 xor	 eax, eax

; 465  : 	final_len <<= 3;

  00087	c1 e3 03	 shl	 ebx, 3
  0008a	59		 pop	 ecx
  0008b	8d 7d dc	 lea	 edi, DWORD PTR _buf$[ebp]
  0008e	f3 ab		 rep stosd

; 466  : 	while (final_len > 0)

  00090	85 db		 test	 ebx, ebx
  00092	7e 0d		 jle	 SHORT $LN1@GOSTHASH_f

; 464  : 	bptr = 0;

  00094	8d 45 dc	 lea	 eax, DWORD PTR _buf$[ebp]
$LL2@GOSTHASH_f:

; 467  : 	{
; 468  : 		buf[bptr++] = (byte)(final_len & 0xFF);

  00097	88 18		 mov	 BYTE PTR [eax], bl

; 469  : 		final_len >>= 8;

  00099	c1 fb 08	 sar	 ebx, 8
  0009c	40		 inc	 eax
  0009d	85 db		 test	 ebx, ebx
  0009f	7f f6		 jg	 SHORT $LL2@GOSTHASH_f
$LN1@GOSTHASH_f:

; 470  : 	}
; 471  : 
; 472  : 	step (H, buf, ctx);

  000a1	8d 45 dc	 lea	 eax, DWORD PTR _buf$[ebp]
  000a4	50		 push	 eax
  000a5	8d 5d bc	 lea	 ebx, DWORD PTR _H$[ebp]
  000a8	e8 00 00 00 00	 call	 _step@12

; 473  : 	step (H, S, ctx);

  000ad	8d 45 9c	 lea	 eax, DWORD PTR _S$[ebp]
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 _step@12

; 474  : 	copy_blocks (out, H, 32);

  000b6	6a 20		 push	 32			; 00000020H
  000b8	8b c3		 mov	 eax, ebx
  000ba	50		 push	 eax
  000bb	ff 75 94	 push	 DWORD PTR _out$GSCopy$[ebp]
  000be	e8 00 00 00 00	 call	 _memcpy

; 475  : }

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi
  000cb	33 cd		 xor	 ecx, ebp
  000cd	5b		 pop	 ebx
  000ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d3	c9		 leave
  000d4	c2 08 00	 ret	 8
_GOSTHASH_finalize@8 ENDP
_TEXT	ENDS
END
