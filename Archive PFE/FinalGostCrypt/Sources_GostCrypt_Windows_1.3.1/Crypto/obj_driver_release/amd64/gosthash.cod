; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

C_3	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
GostR3411_94_CryptoProParamSet DB 01H
	DB	03H
	DB	0aH
	DB	09H
	DB	05H
	DB	0bH
	DB	04H
	DB	0fH
	DB	08H
	DB	06H
	DB	07H
	DB	0eH
	DB	0dH
	DB	00H
	DB	02H
	DB	0cH
	DB	0dH
	DB	0eH
	DB	04H
	DB	01H
	DB	07H
	DB	00H
	DB	05H
	DB	0aH
	DB	03H
	DB	0cH
	DB	08H
	DB	0fH
	DB	06H
	DB	02H
	DB	09H
	DB	0bH
	DB	07H
	DB	06H
	DB	02H
	DB	04H
	DB	0dH
	DB	09H
	DB	0fH
	DB	00H
	DB	0aH
	DB	01H
	DB	05H
	DB	0bH
	DB	08H
	DB	0eH
	DB	0cH
	DB	03H
	DB	07H
	DB	06H
	DB	04H
	DB	0bH
	DB	09H
	DB	0cH
	DB	02H
	DB	0aH
	DB	01H
	DB	08H
	DB	00H
	DB	0eH
	DB	0fH
	DB	0dH
	DB	03H
	DB	05H
	DB	04H
	DB	0aH
	DB	07H
	DB	0cH
	DB	00H
	DB	0fH
	DB	02H
	DB	08H
	DB	0eH
	DB	01H
	DB	06H
	DB	05H
	DB	0dH
	DB	0bH
	DB	09H
	DB	03H
	DB	07H
	DB	0fH
	DB	0cH
	DB	0eH
	DB	09H
	DB	04H
	DB	01H
	DB	00H
	DB	03H
	DB	0bH
	DB	05H
	DB	02H
	DB	06H
	DB	0aH
	DB	08H
	DB	0dH
	DB	05H
	DB	0fH
	DB	04H
	DB	00H
	DB	02H
	DB	0dH
	DB	0bH
	DB	09H
	DB	01H
	DB	07H
	DB	06H
	DB	03H
	DB	0cH
	DB	0eH
	DB	0aH
	DB	08H
	DB	0aH
	DB	04H
	DB	05H
	DB	06H
	DB	08H
	DB	01H
	DB	03H
	DB	07H
	DB	0dH
	DB	0cH
	DB	0eH
	DB	00H
	DB	09H
	DB	02H
	DB	0bH
	DB	0fH
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\crypto\gosthash.c
;	COMDAT A
_TEXT	SEGMENT
F$ = 8
T$ = 16
A	PROC						; COMDAT

; 288  : {

  00000	4c 8b c1	 mov	 r8, rcx

; 289  : 	byte i;
; 290  : 	for (i = 0; i < 24; i++)

  00003	41 ba 18 00 00
	00		 mov	 r10d, 24
  00009	48 8b ca	 mov	 rcx, rdx
  0000c	4d 8d 48 08	 lea	 r9, QWORD PTR [r8+8]
$LL6@A:

; 291  : 		T[i] = F[i+8];

  00010	41 8a 01	 mov	 al, BYTE PTR [r9]
  00013	49 ff c1	 inc	 r9
  00016	88 01		 mov	 BYTE PTR [rcx], al
  00018	48 ff c1	 inc	 rcx
  0001b	49 83 ea 01	 sub	 r10, 1
  0001f	75 ef		 jne	 SHORT $LL6@A

; 292  : 	for (i = 0; i < 8; i++)

  00021	48 8d 4a 18	 lea	 rcx, QWORD PTR [rdx+24]
  00025	41 8d 52 08	 lea	 edx, QWORD PTR [r10+8]
$LL3@A:

; 293  : 		T[i+24] = F[i] ^ F[i+8];

  00029	41 8a 40 08	 mov	 al, BYTE PTR [r8+8]
  0002d	41 32 00	 xor	 al, BYTE PTR [r8]
  00030	49 ff c0	 inc	 r8
  00033	88 01		 mov	 BYTE PTR [rcx], al
  00035	48 ff c1	 inc	 rcx
  00038	48 83 ea 01	 sub	 rdx, 1
  0003c	75 eb		 jne	 SHORT $LL3@A

; 294  : }

  0003e	f3 c3		 fatret	 0
A	ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT P_transform
_TEXT	SEGMENT
F$ = 8
T$ = 16
P_transform PROC					; COMDAT

; 269  : 	gst_dword i, k;
; 270  : 	for (i = 0; i < 4; i++)

  00000	45 33 c0	 xor	 r8d, r8d
$LL6@P_transfor:

; 271  : 		for (k = 0; k < 8; k++)

  00003	45 33 c9	 xor	 r9d, r9d
  00006	4d 8d 14 10	 lea	 r10, QWORD PTR [r8+rdx]
$LL3@P_transfor:

; 272  : 			T[i+4*k] = F[8*i+k];

  0000a	42 8a 04 09	 mov	 al, BYTE PTR [rcx+r9]
  0000e	49 ff c1	 inc	 r9
  00011	41 88 02	 mov	 BYTE PTR [r10], al
  00014	49 83 c2 04	 add	 r10, 4
  00018	49 83 f9 08	 cmp	 r9, 8
  0001c	7c ec		 jl	 SHORT $LL3@P_transfor
  0001e	49 ff c0	 inc	 r8
  00021	48 83 c1 08	 add	 rcx, 8
  00025	49 83 f8 04	 cmp	 r8, 4
  00029	7c d8		 jl	 SHORT $LL6@P_transfor

; 273  : }

  0002b	f3 c3		 fatret	 0
P_transform ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT xor_blocks
_TEXT	SEGMENT
T$ = 8
F$ = 16
S$ = 24
len$ = 32
xor_blocks PROC						; COMDAT

; 247  : 	gst_dword i;
; 248  : 	for (i = 0; i < len; i++)

  00000	49 2b d0	 sub	 rdx, r8
  00003	41 b9 20 00 00
	00		 mov	 r9d, 32			; 00000020H
  00009	49 2b c8	 sub	 rcx, r8
$LL3@xor_blocks:

; 249  : 		T[i] = F[i] ^ S[i];

  0000c	42 8a 04 02	 mov	 al, BYTE PTR [rdx+r8]
  00010	41 32 00	 xor	 al, BYTE PTR [r8]
  00013	42 88 04 01	 mov	 BYTE PTR [rcx+r8], al
  00017	49 ff c0	 inc	 r8
  0001a	49 83 e9 01	 sub	 r9, 1
  0001e	75 ec		 jne	 SHORT $LL3@xor_blocks

; 250  : }

  00020	f3 c3		 fatret	 0
xor_blocks ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT add_blocks
_TEXT	SEGMENT
T$ = 8
F$ = 16
len$ = 24
add_blocks PROC						; COMDAT

; 223  : 	gst_dword i;
; 224  : 	gst_word carry = 0;

  00000	45 33 d2	 xor	 r10d, r10d

; 225  : 	gst_word sum;
; 226  : 	for (i = 0; i < len; i++)

  00003	48 2b d1	 sub	 rdx, rcx
  00006	45 8d 4a 20	 lea	 r9d, QWORD PTR [r10+32]
$LL3@add_blocks:

; 227  : 	{
; 228  : 		sum = (gst_word)T[i] + (gst_word)F[i] + carry;

  0000a	44 0f b6 04 0a	 movzx	 r8d, BYTE PTR [rdx+rcx]
  0000f	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00012	66 44 03 c0	 add	 r8w, ax
  00016	66 45 03 c2	 add	 r8w, r10w

; 229  : 		T[i] = (byte)sum & 0xFF;

  0001a	44 88 01	 mov	 BYTE PTR [rcx], r8b

; 230  : 		carry = sum >> 8;

  0001d	66 41 c1 f8 08	 sar	 r8w, 8
  00022	48 ff c1	 inc	 rcx
  00025	49 83 e9 01	 sub	 r9, 1
  00029	66 45 8b d0	 mov	 r10w, r8w
  0002d	75 db		 jne	 SHORT $LL3@add_blocks

; 231  : 	}
; 232  : }

  0002f	f3 c3		 fatret	 0
add_blocks ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_blocks DD imagerel set_blocks
	DD	imagerel set_blocks+24
	DD	imagerel $unwind$set_blocks
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_blocks DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT set_blocks
_TEXT	SEGMENT
ptr$ = 48
val$ = 56
len$ = 64
set_blocks PROC						; COMDAT

; 204  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 205  : 	gst_dword i;
; 206  : 	for (i = 0; i < len; i++)

  00004	4d 63 c0	 movsxd	 r8, r8d
  00007	4d 85 c0	 test	 r8, r8
  0000a	7e 07		 jle	 SHORT $LN3@set_blocks@2
  0000c	33 d2		 xor	 edx, edx
  0000e	e8 00 00 00 00	 call	 memset
$LN3@set_blocks@2:

; 207  : 		ptr[i] = val;
; 208  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
set_blocks ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT move_blocks
_TEXT	SEGMENT
to$ = 8
from$ = 16
len$ = 24
move_blocks PROC					; COMDAT

; 184  : 	gst_dword i;
; 185  : 	if (from < to)

  00000	48 3b d1	 cmp	 rdx, rcx
  00003	73 1f		 jae	 SHORT $LN8@move_block

; 186  : 		for (i = len-1; i >= 0; i--)

  00005	41 b9 1d 00 00
	00		 mov	 r9d, 29
  0000b	4c 8d 41 1d	 lea	 r8, QWORD PTR [rcx+29]

; 187  : 			to[i] = from[i];

  0000f	48 2b d1	 sub	 rdx, rcx
$LL7@move_block:
  00012	42 8a 04 02	 mov	 al, BYTE PTR [rdx+r8]
  00016	41 88 00	 mov	 BYTE PTR [r8], al
  00019	49 ff c8	 dec	 r8
  0001c	49 83 e9 01	 sub	 r9, 1
  00020	79 f0		 jns	 SHORT $LL7@move_block

; 191  : }

  00022	f3 c3		 fatret	 0
$LN8@move_block:

; 188  : 	else
; 189  : 		for (i = 0; i < len; i++)
; 190  : 			to[i] = from[i];

  00024	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00027	48 89 01	 mov	 QWORD PTR [rcx], rax
  0002a	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0002e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00032	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  00036	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0003a	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  0003d	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  00040	0f b7 42 1c	 movzx	 eax, WORD PTR [rdx+28]
  00044	66 89 41 1c	 mov	 WORD PTR [rcx+28], ax

; 191  : }

  00048	c3		 ret	 0
move_blocks ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT copy_blocks
_TEXT	SEGMENT
dst$ = 8
src$ = 16
len$ = 24
copy_blocks PROC					; COMDAT

; 167  : 	gst_dword i;
; 168  : 	for (i = 0; i < len; i++)

  00000	4d 63 c8	 movsxd	 r9, r8d
  00003	45 85 c0	 test	 r8d, r8d
  00006	7e 11		 jle	 SHORT $LN1@copy_block@2
  00008	48 2b d1	 sub	 rdx, rcx
$LL3@copy_block@2:

; 169  : 		dst[i] = src[i];

  0000b	8a 04 0a	 mov	 al, BYTE PTR [rdx+rcx]
  0000e	88 01		 mov	 BYTE PTR [rcx], al
  00010	48 ff c1	 inc	 rcx
  00013	49 83 e9 01	 sub	 r9, 1
  00017	75 f2		 jne	 SHORT $LL3@copy_block@2
$LN1@copy_block@2:

; 170  : }

  00019	f3 c3		 fatret	 0
copy_blocks ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT r
_TEXT	SEGMENT
n1$ = 8
n2$ = 16
X$ = 24
r	PROC						; COMDAT

; 59   : 	gosthash_s_box *sbox = &GostR3411_94_CryptoProParamSet;
; 60   : 	n1 += X;

  00000	41 03 c8	 add	 ecx, r8d

; 61   : 	n1 =  (gst_udword)sbox->k8[(n1>>28)&0xF]<<28 | (gst_udword)sbox->k7[(n1>>24)&0xF]<<24
; 62   : 				| (gst_udword)sbox->k6[(n1>>20)&0xF]<<20 | (gst_udword)sbox->k5[(n1>>16)&0xF]<<16
; 63   : 				| (gst_udword)sbox->k4[(n1>>12)&0xF]<<12 | (gst_udword)sbox->k3[(n1>>8)&0xF]<<8
; 64   : 				| (gst_udword)sbox->k2[(n1>>4)&0xF]<<4 | (gst_udword)sbox->k1[n1&0xF];
; 65   : 	n1 = gosthash_rotl32(n1, 11);
; 66   : 	n2 ^= n1;
; 67   : 	return n2;

  00003	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:GostR3411_94_CryptoProParamSet
  0000a	8b c1		 mov	 eax, ecx
  0000c	44 8b c9	 mov	 r9d, ecx
  0000f	48 c1 e8 18	 shr	 rax, 24
  00013	41 83 e1 0f	 and	 r9d, 15
  00017	83 e0 0f	 and	 eax, 15
  0001a	46 0f b6 44 10
	10		 movzx	 r8d, BYTE PTR [rax+r10+16]
  00020	8b c1		 mov	 eax, ecx
  00022	48 c1 e8 1c	 shr	 rax, 28
  00026	42 0f b6 04 10	 movzx	 eax, BYTE PTR [rax+r10]
  0002b	c1 e0 04	 shl	 eax, 4
  0002e	44 0b c0	 or	 r8d, eax
  00031	8b c1		 mov	 eax, ecx
  00033	48 c1 e8 14	 shr	 rax, 20
  00037	41 c1 e0 04	 shl	 r8d, 4
  0003b	83 e0 0f	 and	 eax, 15
  0003e	42 0f b6 44 10
	20		 movzx	 eax, BYTE PTR [rax+r10+32]
  00044	44 0b c0	 or	 r8d, eax
  00047	8b c1		 mov	 eax, ecx
  00049	48 c1 e8 10	 shr	 rax, 16
  0004d	41 c1 e0 04	 shl	 r8d, 4
  00051	83 e0 0f	 and	 eax, 15
  00054	42 0f b6 44 10
	30		 movzx	 eax, BYTE PTR [rax+r10+48]
  0005a	44 0b c0	 or	 r8d, eax
  0005d	8b c1		 mov	 eax, ecx
  0005f	48 c1 e8 0c	 shr	 rax, 12
  00063	41 c1 e0 04	 shl	 r8d, 4
  00067	83 e0 0f	 and	 eax, 15
  0006a	42 0f b6 44 10
	40		 movzx	 eax, BYTE PTR [rax+r10+64]
  00070	44 0b c0	 or	 r8d, eax
  00073	8b c1		 mov	 eax, ecx
  00075	48 c1 e8 08	 shr	 rax, 8
  00079	41 c1 e0 04	 shl	 r8d, 4
  0007d	83 e0 0f	 and	 eax, 15
  00080	42 0f b6 44 10
	50		 movzx	 eax, BYTE PTR [rax+r10+80]
  00086	44 0b c0	 or	 r8d, eax
  00089	8b c1		 mov	 eax, ecx
  0008b	43 0f b6 4c 11
	70		 movzx	 ecx, BYTE PTR [r9+r10+112]
  00091	48 c1 e8 04	 shr	 rax, 4
  00095	41 c1 e0 04	 shl	 r8d, 4
  00099	83 e0 0f	 and	 eax, 15
  0009c	42 0f b6 44 10
	60		 movzx	 eax, BYTE PTR [rax+r10+96]
  000a2	41 0b c0	 or	 eax, r8d
  000a5	c1 e0 04	 shl	 eax, 4
  000a8	0b c1		 or	 eax, ecx
  000aa	c1 c0 0b	 rol	 eax, 11
  000ad	33 c2		 xor	 eax, edx

; 68   : }

  000af	c3		 ret	 0
r	ENDP
PUBLIC	GOSTHASH_init
; Function compile flags: /Ogspy
;	COMDAT GOSTHASH_init
_TEXT	SEGMENT
ctx$ = 8
GOSTHASH_init PROC					; COMDAT

; 325  : 	set_blocks((byte *)ctx, 0, sizeof(gost_hash_ctx));

  00000	33 d2		 xor	 edx, edx
  00002	44 8d 42 68	 lea	 r8d, QWORD PTR [rdx+104]

; 326  : }

  00006	e9 00 00 00 00	 jmp	 memset
GOSTHASH_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PSI DD	imagerel PSI
	DD	imagerel PSI+142
	DD	imagerel $unwind$PSI
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PSI DD	020501H
	DD	013405H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT PSI
_TEXT	SEGMENT
X$ = 8
PSI	PROC						; COMDAT

; 305  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 306  : 	gst_word T;
; 307  : 
; 308  : 	T = (gst_word)(X[0]^X[2]^X[4]^X[6]^X[24]^X[30])|
; 309  : 		((gst_word)(X[1]^X[3]^X[5]^X[7]^X[25]^X[31])<<8);

  00005	8a 41 19	 mov	 al, BYTE PTR [rcx+25]
  00008	4c 8d 59 1f	 lea	 r11, QWORD PTR [rcx+31]
  0000c	48 8d 51 02	 lea	 rdx, QWORD PTR [rcx+2]
  00010	32 41 07	 xor	 al, BYTE PTR [rcx+7]
  00013	48 8d 59 1e	 lea	 rbx, QWORD PTR [rcx+30]
  00017	32 41 05	 xor	 al, BYTE PTR [rcx+5]
  0001a	32 41 03	 xor	 al, BYTE PTR [rcx+3]
  0001d	32 41 01	 xor	 al, BYTE PTR [rcx+1]
  00020	41 32 03	 xor	 al, BYTE PTR [r11]
  00023	44 0f b6 c0	 movzx	 r8d, al
  00027	8a 41 18	 mov	 al, BYTE PTR [rcx+24]
  0002a	32 41 06	 xor	 al, BYTE PTR [rcx+6]
  0002d	66 41 c1 e0 08	 shl	 r8w, 8
  00032	32 41 04	 xor	 al, BYTE PTR [rcx+4]
  00035	32 03		 xor	 al, BYTE PTR [rbx]
  00037	32 01		 xor	 al, BYTE PTR [rcx]
  00039	32 02		 xor	 al, BYTE PTR [rdx]
  0003b	0f b6 c0	 movzx	 eax, al
  0003e	66 44 0b c0	 or	 r8w, ax

; 310  : 	move_blocks(X, X+2, 30);

  00042	48 3b d1	 cmp	 rdx, rcx
  00045	73 1f		 jae	 SHORT $LN10@PSI
  00047	41 ba 1d 00 00
	00		 mov	 r10d, 29
  0004d	4c 8d 49 1d	 lea	 r9, QWORD PTR [rcx+29]
  00051	48 2b d1	 sub	 rdx, rcx
$LL9@PSI:
  00054	42 8a 04 0a	 mov	 al, BYTE PTR [rdx+r9]
  00058	41 88 01	 mov	 BYTE PTR [r9], al
  0005b	49 ff c9	 dec	 r9
  0005e	49 83 ea 01	 sub	 r10, 1
  00062	79 f0		 jns	 SHORT $LL9@PSI
  00064	eb 17		 jmp	 SHORT $LN3@PSI
$LN10@PSI:
  00066	48 2b d1	 sub	 rdx, rcx
  00069	41 b9 1e 00 00
	00		 mov	 r9d, 30
$LL5@PSI:
  0006f	8a 04 11	 mov	 al, BYTE PTR [rcx+rdx]
  00072	88 01		 mov	 BYTE PTR [rcx], al
  00074	48 ff c1	 inc	 rcx
  00077	49 83 e9 01	 sub	 r9, 1
  0007b	75 f2		 jne	 SHORT $LL5@PSI
$LN3@PSI:

; 311  : 	X[30] = (byte)(T&0xFF);

  0007d	44 88 03	 mov	 BYTE PTR [rbx], r8b

; 312  : 	X[31] = (byte)(T>>8);
; 313  : }

  00080	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00085	66 41 c1 f8 08	 sar	 r8w, 8
  0008a	45 88 03	 mov	 BYTE PTR [r11], r8b
  0008d	c3		 ret	 0
PSI	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gost_encrypt_with_key DD imagerel gost_encrypt_with_key
	DD	imagerel gost_encrypt_with_key+774
	DD	imagerel $unwind$gost_encrypt_with_key
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gost_encrypt_with_key DD 0a1901H
	DD	0e3419H
	DD	0f0153219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT gost_encrypt_with_key
_TEXT	SEGMENT
X7$1$ = 96
in$ = 96
out$ = 104
key$ = 112
gost_encrypt_with_key PROC				; COMDAT

; 81   : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 82   : 	gst_dword i;
; 83   : 	gst_udword n1, n2;
; 84   : 	gst_udword X0, X1, X2, X3, X4, X5, X6, X7;
; 85   : 
; 86   : 	n1 = (gst_udword)in[3] << 24 | (gst_udword)in[2] << 16 | (gst_udword)in[1] << 8 | (gst_udword)in[0];

  00019	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  0001d	0f b6 59 03	 movzx	 ebx, BYTE PTR [rcx+3]

; 87   : 	n2 = (gst_udword)in[7] << 24 | (gst_udword)in[6] << 16 | (gst_udword)in[5] << 8 | (gst_udword)in[4];

  00021	0f b6 51 07	 movzx	 edx, BYTE PTR [rcx+7]

; 88   : 
; 89   : 	/* Set the 8 round keys */
; 90   : 	X0 = 0;

  00025	33 ff		 xor	 edi, edi
  00027	c1 e3 08	 shl	 ebx, 8
  0002a	c1 e2 08	 shl	 edx, 8
  0002d	0b d8		 or	 ebx, eax
  0002f	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 91   : 	X1 = 0;

  00033	8b f7		 mov	 esi, edi
  00035	c1 e3 08	 shl	 ebx, 8

; 92   : 	X2 = 0;

  00038	8b ef		 mov	 ebp, edi

; 93   : 	X3 = 0;

  0003a	44 8b e7	 mov	 r12d, edi
  0003d	0b d8		 or	 ebx, eax
  0003f	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 94   : 	X4 = 0;

  00042	44 8b ef	 mov	 r13d, edi
  00045	c1 e3 08	 shl	 ebx, 8

; 95   : 	X5 = 0;

  00048	44 8b f7	 mov	 r14d, edi

; 96   : 	X6 = 0;

  0004b	44 8b ff	 mov	 r15d, edi
  0004e	0b d8		 or	 ebx, eax
  00050	0f b6 41 06	 movzx	 eax, BYTE PTR [rcx+6]

; 97   : 	X7 = 0;

  00054	44 8b cf	 mov	 r9d, edi
  00057	0b d0		 or	 edx, eax
  00059	0f b6 41 05	 movzx	 eax, BYTE PTR [rcx+5]
  0005d	c1 e2 08	 shl	 edx, 8
  00060	0b d0		 or	 edx, eax
  00062	0f b6 41 04	 movzx	 eax, BYTE PTR [rcx+4]
  00066	8b cf		 mov	 ecx, edi
  00068	c1 e2 08	 shl	 edx, 8
  0006b	0b d0		 or	 edx, eax
  0006d	49 83 c0 04	 add	 r8, 4
$LL3@gost_encry:

; 98   : 	
; 99   : 	for (i = 0; i < GOSTHASH_GOST_KEYSIZE / 8; i++)
; 100  : 	{
; 101  : 		X0 |= (gst_udword)key[i + 0] << (i * 8);

  00071	41 0f b6 40 fc	 movzx	 eax, BYTE PTR [r8-4]
  00076	d3 e0		 shl	 eax, cl
  00078	0b f8		 or	 edi, eax

; 102  : 		X1 |= (gst_udword)key[i + 4] << (i * 8);

  0007a	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  0007e	49 ff c0	 inc	 r8
  00081	d3 e0		 shl	 eax, cl
  00083	0b f0		 or	 esi, eax

; 103  : 		X2 |= (gst_udword)key[i + 8] << (i * 8);

  00085	41 0f b6 40 03	 movzx	 eax, BYTE PTR [r8+3]
  0008a	d3 e0		 shl	 eax, cl
  0008c	0b e8		 or	 ebp, eax

; 104  : 		X3 |= (gst_udword)key[i + 12] << (i * 8);

  0008e	41 0f b6 40 07	 movzx	 eax, BYTE PTR [r8+7]
  00093	d3 e0		 shl	 eax, cl
  00095	44 0b e0	 or	 r12d, eax

; 105  : 		X4 |= (gst_udword)key[i + 16] << (i * 8);

  00098	41 0f b6 40 0b	 movzx	 eax, BYTE PTR [r8+11]
  0009d	d3 e0		 shl	 eax, cl
  0009f	44 0b e8	 or	 r13d, eax

; 106  : 		X5 |= (gst_udword)key[i + 20] << (i * 8);

  000a2	41 0f b6 40 0f	 movzx	 eax, BYTE PTR [r8+15]
  000a7	d3 e0		 shl	 eax, cl
  000a9	44 0b f0	 or	 r14d, eax

; 107  : 		X6 |= (gst_udword)key[i + 24] << (i * 8);

  000ac	41 0f b6 40 13	 movzx	 eax, BYTE PTR [r8+19]
  000b1	d3 e0		 shl	 eax, cl
  000b3	44 0b f8	 or	 r15d, eax

; 108  : 		X7 |= (gst_udword)key[i + 28] << (i * 8);

  000b6	41 0f b6 40 17	 movzx	 eax, BYTE PTR [r8+23]
  000bb	d3 e0		 shl	 eax, cl
  000bd	83 c1 08	 add	 ecx, 8
  000c0	44 0b c8	 or	 r9d, eax
  000c3	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000c6	7c a9		 jl	 SHORT $LL3@gost_encry

; 109  : 	}
; 110  : 
; 111  : 	/* Encryption rounds 1-24 */
; 112  : 	n2 = r(n1, n2, X0);

  000c8	44 8b c7	 mov	 r8d, edi
  000cb	8b cb		 mov	 ecx, ebx
  000cd	44 89 4c 24 60	 mov	 DWORD PTR X7$1$[rsp], r9d
  000d2	e8 00 00 00 00	 call	 r

; 113  : 	n1 = r(n2, n1, X1);

  000d7	44 8b c6	 mov	 r8d, esi
  000da	8b d3		 mov	 edx, ebx
  000dc	8b c8		 mov	 ecx, eax
  000de	44 8b d8	 mov	 r11d, eax
  000e1	e8 00 00 00 00	 call	 r

; 114  : 	n2 = r(n1, n2, X2);

  000e6	44 8b c5	 mov	 r8d, ebp
  000e9	41 8b d3	 mov	 edx, r11d
  000ec	8b c8		 mov	 ecx, eax
  000ee	8b d8		 mov	 ebx, eax
  000f0	e8 00 00 00 00	 call	 r

; 115  : 	n1 = r(n2, n1, X3);

  000f5	45 8b c4	 mov	 r8d, r12d
  000f8	8b d3		 mov	 edx, ebx
  000fa	8b c8		 mov	 ecx, eax
  000fc	44 8b d8	 mov	 r11d, eax
  000ff	e8 00 00 00 00	 call	 r

; 116  : 	n2 = r(n1, n2, X4);

  00104	45 8b c5	 mov	 r8d, r13d
  00107	41 8b d3	 mov	 edx, r11d
  0010a	8b c8		 mov	 ecx, eax
  0010c	8b d8		 mov	 ebx, eax
  0010e	e8 00 00 00 00	 call	 r

; 117  : 	n1 = r(n2, n1, X5);

  00113	45 8b c6	 mov	 r8d, r14d
  00116	8b d3		 mov	 edx, ebx
  00118	8b c8		 mov	 ecx, eax
  0011a	44 8b d8	 mov	 r11d, eax
  0011d	e8 00 00 00 00	 call	 r

; 118  : 	n2 = r(n1, n2, X6);

  00122	45 8b c7	 mov	 r8d, r15d
  00125	41 8b d3	 mov	 edx, r11d
  00128	8b c8		 mov	 ecx, eax
  0012a	8b d8		 mov	 ebx, eax
  0012c	e8 00 00 00 00	 call	 r

; 119  : 	n1 = r(n2, n1, X7);

  00131	44 8b 44 24 60	 mov	 r8d, DWORD PTR X7$1$[rsp]
  00136	8b d3		 mov	 edx, ebx
  00138	8b c8		 mov	 ecx, eax
  0013a	44 8b d8	 mov	 r11d, eax
  0013d	e8 00 00 00 00	 call	 r

; 120  : 	
; 121  : 	n2 = r(n1, n2, X0);

  00142	44 8b c7	 mov	 r8d, edi
  00145	41 8b d3	 mov	 edx, r11d
  00148	8b c8		 mov	 ecx, eax
  0014a	8b d8		 mov	 ebx, eax
  0014c	e8 00 00 00 00	 call	 r

; 122  : 	n1 = r(n2, n1, X1);

  00151	44 8b c6	 mov	 r8d, esi
  00154	8b d3		 mov	 edx, ebx
  00156	8b c8		 mov	 ecx, eax
  00158	44 8b d8	 mov	 r11d, eax
  0015b	e8 00 00 00 00	 call	 r

; 123  : 	n2 = r(n1, n2, X2);

  00160	44 8b c5	 mov	 r8d, ebp
  00163	41 8b d3	 mov	 edx, r11d
  00166	8b c8		 mov	 ecx, eax
  00168	8b d8		 mov	 ebx, eax
  0016a	e8 00 00 00 00	 call	 r

; 124  : 	n1 = r(n2, n1, X3);

  0016f	45 8b c4	 mov	 r8d, r12d
  00172	8b d3		 mov	 edx, ebx
  00174	8b c8		 mov	 ecx, eax
  00176	44 8b d8	 mov	 r11d, eax
  00179	e8 00 00 00 00	 call	 r

; 125  : 	n2 = r(n1, n2, X4);

  0017e	45 8b c5	 mov	 r8d, r13d
  00181	41 8b d3	 mov	 edx, r11d
  00184	8b c8		 mov	 ecx, eax
  00186	8b d8		 mov	 ebx, eax
  00188	e8 00 00 00 00	 call	 r

; 126  : 	n1 = r(n2, n1, X5);

  0018d	45 8b c6	 mov	 r8d, r14d
  00190	8b d3		 mov	 edx, ebx
  00192	8b c8		 mov	 ecx, eax
  00194	44 8b d8	 mov	 r11d, eax
  00197	e8 00 00 00 00	 call	 r

; 127  : 	n2 = r(n1, n2, X6);

  0019c	45 8b c7	 mov	 r8d, r15d
  0019f	41 8b d3	 mov	 edx, r11d
  001a2	8b c8		 mov	 ecx, eax
  001a4	8b d8		 mov	 ebx, eax
  001a6	e8 00 00 00 00	 call	 r

; 128  : 	n1 = r(n2, n1, X7);

  001ab	44 8b 44 24 60	 mov	 r8d, DWORD PTR X7$1$[rsp]
  001b0	8b d3		 mov	 edx, ebx
  001b2	8b c8		 mov	 ecx, eax
  001b4	44 8b d8	 mov	 r11d, eax
  001b7	e8 00 00 00 00	 call	 r

; 129  : 
; 130  : 	n2 = r(n1, n2, X0);

  001bc	44 8b c7	 mov	 r8d, edi
  001bf	8b d8		 mov	 ebx, eax
  001c1	41 8b d3	 mov	 edx, r11d
  001c4	8b c8		 mov	 ecx, eax
  001c6	e8 00 00 00 00	 call	 r

; 131  : 	n1 = r(n2, n1, X1);

  001cb	44 8b c6	 mov	 r8d, esi
  001ce	8b d3		 mov	 edx, ebx
  001d0	8b c8		 mov	 ecx, eax
  001d2	44 8b d8	 mov	 r11d, eax
  001d5	e8 00 00 00 00	 call	 r

; 132  : 	n2 = r(n1, n2, X2);

  001da	44 8b c5	 mov	 r8d, ebp
  001dd	41 8b d3	 mov	 edx, r11d
  001e0	8b c8		 mov	 ecx, eax
  001e2	8b d8		 mov	 ebx, eax
  001e4	e8 00 00 00 00	 call	 r

; 133  : 	n1 = r(n2, n1, X3);

  001e9	45 8b c4	 mov	 r8d, r12d
  001ec	8b d3		 mov	 edx, ebx
  001ee	8b c8		 mov	 ecx, eax
  001f0	44 8b d8	 mov	 r11d, eax
  001f3	e8 00 00 00 00	 call	 r

; 134  : 	n2 = r(n1, n2, X4);

  001f8	45 8b c5	 mov	 r8d, r13d
  001fb	41 8b d3	 mov	 edx, r11d
  001fe	8b c8		 mov	 ecx, eax
  00200	8b d8		 mov	 ebx, eax
  00202	e8 00 00 00 00	 call	 r

; 135  : 	n1 = r(n2, n1, X5);

  00207	45 8b c6	 mov	 r8d, r14d
  0020a	8b d3		 mov	 edx, ebx
  0020c	8b c8		 mov	 ecx, eax
  0020e	44 8b d8	 mov	 r11d, eax
  00211	e8 00 00 00 00	 call	 r

; 136  : 	n2 = r(n1, n2, X6);

  00216	45 8b c7	 mov	 r8d, r15d
  00219	41 8b d3	 mov	 edx, r11d
  0021c	8b c8		 mov	 ecx, eax
  0021e	8b d8		 mov	 ebx, eax
  00220	e8 00 00 00 00	 call	 r

; 137  : 	n1 = r(n2, n1, X7);

  00225	44 8b 44 24 60	 mov	 r8d, DWORD PTR X7$1$[rsp]
  0022a	8b d3		 mov	 edx, ebx
  0022c	8b c8		 mov	 ecx, eax
  0022e	44 8b d8	 mov	 r11d, eax
  00231	e8 00 00 00 00	 call	 r

; 138  : 
; 139  : 	/* Encryption rounds 25-32 */
; 140  : 	n2 = r(n1, n2, X7);

  00236	44 8b 44 24 60	 mov	 r8d, DWORD PTR X7$1$[rsp]
  0023b	41 8b d3	 mov	 edx, r11d
  0023e	8b c8		 mov	 ecx, eax
  00240	8b d8		 mov	 ebx, eax
  00242	e8 00 00 00 00	 call	 r

; 141  : 	n1 = r(n2, n1, X6);

  00247	45 8b c7	 mov	 r8d, r15d
  0024a	8b d3		 mov	 edx, ebx
  0024c	8b c8		 mov	 ecx, eax
  0024e	44 8b d8	 mov	 r11d, eax
  00251	e8 00 00 00 00	 call	 r

; 142  : 	n2 = r(n1, n2, X5);

  00256	45 8b c6	 mov	 r8d, r14d
  00259	41 8b d3	 mov	 edx, r11d
  0025c	8b c8		 mov	 ecx, eax
  0025e	8b d8		 mov	 ebx, eax
  00260	e8 00 00 00 00	 call	 r

; 143  : 	n1 = r(n2, n1, X4);

  00265	45 8b c5	 mov	 r8d, r13d
  00268	8b d3		 mov	 edx, ebx
  0026a	8b c8		 mov	 ecx, eax
  0026c	44 8b d8	 mov	 r11d, eax
  0026f	e8 00 00 00 00	 call	 r

; 144  : 	n2 = r(n1, n2, X3);

  00274	45 8b c4	 mov	 r8d, r12d
  00277	41 8b d3	 mov	 edx, r11d
  0027a	8b c8		 mov	 ecx, eax
  0027c	8b d8		 mov	 ebx, eax
  0027e	e8 00 00 00 00	 call	 r

; 145  : 	n1 = r(n2, n1, X2);

  00283	44 8b c5	 mov	 r8d, ebp
  00286	8b d3		 mov	 edx, ebx
  00288	8b c8		 mov	 ecx, eax
  0028a	44 8b d8	 mov	 r11d, eax
  0028d	e8 00 00 00 00	 call	 r

; 146  : 	n2 = r(n1, n2, X1);

  00292	44 8b c6	 mov	 r8d, esi
  00295	41 8b d3	 mov	 edx, r11d
  00298	8b c8		 mov	 ecx, eax
  0029a	8b d8		 mov	 ebx, eax
  0029c	e8 00 00 00 00	 call	 r

; 147  : 	n1 = r(n2, n1, X0);

  002a1	44 8b c7	 mov	 r8d, edi
  002a4	8b d3		 mov	 edx, ebx
  002a6	8b c8		 mov	 ecx, eax
  002a8	44 8b d8	 mov	 r11d, eax
  002ab	e8 00 00 00 00	 call	 r

; 148  : 
; 149  : 	out[0] = (byte)(n2 & 0xFF); out[1] = (byte)((n2 >> 8) & 0xFF); out[2] = (byte)((n2 >> 16) & 0xFF); out[3] = (byte)((n2 >> 24) & 0xFF);

  002b0	4c 8b 44 24 68	 mov	 r8, QWORD PTR out$[rsp]
  002b5	45 88 18	 mov	 BYTE PTR [r8], r11b
  002b8	8b d0		 mov	 edx, eax

; 150  : 	out[4] = (byte)(n1 & 0xFF); out[5] = (byte)((n1 >> 8) & 0xFF); out[6] = (byte)((n1 >> 16) & 0xFF); out[7] = (byte)((n1 >> 24) & 0xFF);
; 151  : }

  002ba	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  002bf	41 8b cb	 mov	 ecx, r11d
  002c2	41 88 40 04	 mov	 BYTE PTR [r8+4], al
  002c6	c1 e9 08	 shr	 ecx, 8
  002c9	41 88 48 01	 mov	 BYTE PTR [r8+1], cl
  002cd	41 8b cb	 mov	 ecx, r11d
  002d0	41 c1 eb 18	 shr	 r11d, 24
  002d4	c1 e9 10	 shr	 ecx, 16
  002d7	45 88 58 03	 mov	 BYTE PTR [r8+3], r11b
  002db	41 88 48 02	 mov	 BYTE PTR [r8+2], cl
  002df	8b c8		 mov	 ecx, eax
  002e1	c1 e8 10	 shr	 eax, 16
  002e4	c1 e9 08	 shr	 ecx, 8
  002e7	c1 ea 18	 shr	 edx, 24
  002ea	41 88 40 06	 mov	 BYTE PTR [r8+6], al
  002ee	41 88 50 07	 mov	 BYTE PTR [r8+7], dl
  002f2	41 88 48 05	 mov	 BYTE PTR [r8+5], cl
  002f6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002fa	41 5f		 pop	 r15
  002fc	41 5e		 pop	 r14
  002fe	41 5d		 pop	 r13
  00300	41 5c		 pop	 r12
  00302	5f		 pop	 rdi
  00303	5e		 pop	 rsi
  00304	5d		 pop	 rbp
  00305	c3		 ret	 0
gost_encrypt_with_key ENDP
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$step DD	imagerel step
	DD	imagerel step+815
	DD	imagerel $unwind$step
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$step DD	072119H
	DD	02c340fH
	DD	026010fH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0120H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT step
_TEXT	SEGMENT
V$ = 32
S$ = 64
U$ = 96
W$ = 128
K$ = 160
__$ArrayPad$ = 288
H$ = 336
M$ = 344
ctx$ = 352
step	PROC						; COMDAT

; 339  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H
  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00016	48 33 c4	 xor	 rax, rsp
  00019	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 340  : 	byte U[32], W[32], V[32], S[32], K[4][32];
; 341  : 	gst_dword i;
; 342  : 	
; 343  : 	xor_blocks(W, H, M, 32);

  00021	4c 8d 94 24 80
	00 00 00	 lea	 r10, QWORD PTR W$[rsp]
  00029	4c 8b ca	 mov	 r9, rdx
  0002c	48 8b f1	 mov	 rsi, rcx
  0002f	4c 2b c9	 sub	 r9, rcx
  00032	4c 8b c1	 mov	 r8, rcx
  00035	4c 2b d1	 sub	 r10, rcx
  00038	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0003d	48 8b ea	 mov	 rbp, rdx
$LL11@step:
  00040	43 8a 04 01	 mov	 al, BYTE PTR [r9+r8]
  00044	41 32 00	 xor	 al, BYTE PTR [r8]
  00047	43 88 04 02	 mov	 BYTE PTR [r10+r8], al
  0004b	49 ff c0	 inc	 r8
  0004e	48 83 e9 01	 sub	 rcx, 1
  00052	75 ec		 jne	 SHORT $LL11@step

; 344  : 	P_transform(W, K[0]); //First key

  00054	33 db		 xor	 ebx, ebx
  00056	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR W$[rsp]
  0005e	48 8b cb	 mov	 rcx, rbx
$LL19@step:
  00061	48 8b d3	 mov	 rdx, rbx
  00064	4c 8d 8c 0c a0
	00 00 00	 lea	 r9, QWORD PTR K$[rsp+rcx]
$LL16@step:
  0006c	41 8a 04 10	 mov	 al, BYTE PTR [r8+rdx]
  00070	48 ff c2	 inc	 rdx
  00073	41 88 01	 mov	 BYTE PTR [r9], al
  00076	49 83 c1 04	 add	 r9, 4
  0007a	48 83 fa 08	 cmp	 rdx, 8
  0007e	7c ec		 jl	 SHORT $LL16@step
  00080	48 ff c1	 inc	 rcx
  00083	49 83 c0 08	 add	 r8, 8
  00087	48 83 f9 04	 cmp	 rcx, 4
  0008b	7c d4		 jl	 SHORT $LL19@step

; 345  : 
; 346  : 	gost_encrypt_with_key (H, S, K[0]);

  0008d	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR K$[rsp]
  00095	48 8d 54 24 40	 lea	 rdx, QWORD PTR S$[rsp]
  0009a	48 8b ce	 mov	 rcx, rsi
  0009d	e8 00 00 00 00	 call	 gost_encrypt_with_key

; 347  : 
; 348  : 	A (H, U);

  000a2	48 8d 54 24 60	 lea	 rdx, QWORD PTR U$[rsp]
  000a7	48 8b ce	 mov	 rcx, rsi
  000aa	e8 00 00 00 00	 call	 A

; 349  : 	A (M, V);

  000af	48 8d 54 24 20	 lea	 rdx, QWORD PTR V$[rsp]
  000b4	48 8b cd	 mov	 rcx, rbp
  000b7	e8 00 00 00 00	 call	 A

; 350  : 	A (V, V);

  000bc	48 8d 54 24 20	 lea	 rdx, QWORD PTR V$[rsp]
  000c1	48 8d 4c 24 20	 lea	 rcx, QWORD PTR V$[rsp]
  000c6	e8 00 00 00 00	 call	 A

; 351  : 	xor_blocks(W, U, V, 32);

  000cb	4c 8b db	 mov	 r11, rbx
$LL24@step:
  000ce	42 8a 44 1c 20	 mov	 al, BYTE PTR V$[rsp+r11]
  000d3	49 ff c3	 inc	 r11
  000d6	42 32 44 1c 5f	 xor	 al, BYTE PTR U$[rsp+r11-1]
  000db	49 83 fb 20	 cmp	 r11, 32			; 00000020H
  000df	42 88 44 1c 7f	 mov	 BYTE PTR W$[rsp+r11-1], al
  000e4	7c e8		 jl	 SHORT $LL24@step

; 352  : 	P_transform(W, K[1]); //Second key

  000e6	48 8b cb	 mov	 rcx, rbx
  000e9	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR W$[rsp]
$LL32@step:
  000f1	48 8b d3	 mov	 rdx, rbx
  000f4	4c 8d 8c 0c c0
	00 00 00	 lea	 r9, QWORD PTR K$[rsp+rcx+32]
$LL29@step:
  000fc	41 8a 04 10	 mov	 al, BYTE PTR [r8+rdx]
  00100	48 ff c2	 inc	 rdx
  00103	41 88 01	 mov	 BYTE PTR [r9], al
  00106	49 83 c1 04	 add	 r9, 4
  0010a	48 83 fa 08	 cmp	 rdx, 8
  0010e	7c ec		 jl	 SHORT $LL29@step
  00110	48 ff c1	 inc	 rcx
  00113	49 83 c0 08	 add	 r8, 8
  00117	48 83 f9 04	 cmp	 rcx, 4
  0011b	7c d4		 jl	 SHORT $LL32@step

; 353  : 
; 354  : 	gost_encrypt_with_key (H + 8, S + 8, K[1]);

  0011d	48 8d 4e 08	 lea	 rcx, QWORD PTR [rsi+8]
  00121	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR K$[rsp+32]
  00129	48 8d 54 24 48	 lea	 rdx, QWORD PTR S$[rsp+8]
  0012e	e8 00 00 00 00	 call	 gost_encrypt_with_key

; 355  : 
; 356  : 	A (U, U);

  00133	48 8d 54 24 60	 lea	 rdx, QWORD PTR U$[rsp]
  00138	48 8d 4c 24 60	 lea	 rcx, QWORD PTR U$[rsp]
  0013d	e8 00 00 00 00	 call	 A

; 357  : 	/* As the other C values are all 0's, we only need to XOR
; 358  :      * with C[3] */
; 359  : 	xor_blocks(U, U, C_3, 32);

  00142	4c 8b db	 mov	 r11, rbx
$LL37@step:
  00145	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:C_3
  0014c	41 8a 04 03	 mov	 al, BYTE PTR [r11+rax]
  00150	49 ff c3	 inc	 r11
  00153	42 30 44 1c 5f	 xor	 BYTE PTR U$[rsp+r11-1], al
  00158	49 83 fb 20	 cmp	 r11, 32			; 00000020H
  0015c	7c e7		 jl	 SHORT $LL37@step

; 360  : 	A (V, V);

  0015e	48 8d 54 24 20	 lea	 rdx, QWORD PTR V$[rsp]
  00163	48 8d 4c 24 20	 lea	 rcx, QWORD PTR V$[rsp]
  00168	e8 00 00 00 00	 call	 A

; 361  : 	A (V, V);

  0016d	48 8d 54 24 20	 lea	 rdx, QWORD PTR V$[rsp]
  00172	48 8d 4c 24 20	 lea	 rcx, QWORD PTR V$[rsp]
  00177	e8 00 00 00 00	 call	 A

; 362  : 	xor_blocks (W, U, V, 32);

  0017c	4c 8b db	 mov	 r11, rbx
$LL42@step:
  0017f	42 8a 44 1c 20	 mov	 al, BYTE PTR V$[rsp+r11]
  00184	49 ff c3	 inc	 r11
  00187	42 32 44 1c 5f	 xor	 al, BYTE PTR U$[rsp+r11-1]
  0018c	49 83 fb 20	 cmp	 r11, 32			; 00000020H
  00190	42 88 44 1c 7f	 mov	 BYTE PTR W$[rsp+r11-1], al
  00195	7c e8		 jl	 SHORT $LL42@step

; 363  : 	P_transform (W, K[2]); //Third key

  00197	48 8b cb	 mov	 rcx, rbx
  0019a	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR W$[rsp]
$LL50@step:
  001a2	48 8b d3	 mov	 rdx, rbx
  001a5	4c 8d 8c 0c e0
	00 00 00	 lea	 r9, QWORD PTR K$[rsp+rcx+64]
$LL47@step:
  001ad	42 8a 04 02	 mov	 al, BYTE PTR [rdx+r8]
  001b1	48 ff c2	 inc	 rdx
  001b4	41 88 01	 mov	 BYTE PTR [r9], al
  001b7	49 83 c1 04	 add	 r9, 4
  001bb	48 83 fa 08	 cmp	 rdx, 8
  001bf	7c ec		 jl	 SHORT $LL47@step
  001c1	48 ff c1	 inc	 rcx
  001c4	49 83 c0 08	 add	 r8, 8
  001c8	48 83 f9 04	 cmp	 rcx, 4
  001cc	7c d4		 jl	 SHORT $LL50@step

; 364  : 	
; 365  : 	gost_encrypt_with_key (H + 16, S + 16, K[2]);

  001ce	48 8d 4e 10	 lea	 rcx, QWORD PTR [rsi+16]
  001d2	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR K$[rsp+64]
  001da	48 8d 54 24 50	 lea	 rdx, QWORD PTR S$[rsp+16]
  001df	e8 00 00 00 00	 call	 gost_encrypt_with_key

; 366  : 	
; 367  : 	A (U, U);

  001e4	48 8d 54 24 60	 lea	 rdx, QWORD PTR U$[rsp]
  001e9	48 8d 4c 24 60	 lea	 rcx, QWORD PTR U$[rsp]
  001ee	e8 00 00 00 00	 call	 A

; 368  : 	A (V, V);

  001f3	48 8d 54 24 20	 lea	 rdx, QWORD PTR V$[rsp]
  001f8	48 8d 4c 24 20	 lea	 rcx, QWORD PTR V$[rsp]
  001fd	e8 00 00 00 00	 call	 A

; 369  : 	A (V, V);

  00202	48 8d 54 24 20	 lea	 rdx, QWORD PTR V$[rsp]
  00207	48 8d 4c 24 20	 lea	 rcx, QWORD PTR V$[rsp]
  0020c	e8 00 00 00 00	 call	 A

; 370  : 	xor_blocks (W, U, V, 32);

  00211	4c 8b db	 mov	 r11, rbx
$LL55@step:
  00214	42 8a 44 1c 20	 mov	 al, BYTE PTR V$[rsp+r11]
  00219	49 ff c3	 inc	 r11
  0021c	42 32 44 1c 5f	 xor	 al, BYTE PTR U$[rsp+r11-1]
  00221	49 83 fb 20	 cmp	 r11, 32			; 00000020H
  00225	42 88 44 1c 7f	 mov	 BYTE PTR W$[rsp+r11-1], al
  0022a	7c e8		 jl	 SHORT $LL55@step

; 371  : 	P_transform (W, K[3]); //Fourth key

  0022c	48 8b cb	 mov	 rcx, rbx
  0022f	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR W$[rsp]
$LL63@step:
  00237	48 8b d3	 mov	 rdx, rbx
  0023a	4c 8d 8c 0c 00
	01 00 00	 lea	 r9, QWORD PTR K$[rsp+rcx+96]
$LL60@step:
  00242	41 8a 04 10	 mov	 al, BYTE PTR [r8+rdx]
  00246	48 ff c2	 inc	 rdx
  00249	41 88 01	 mov	 BYTE PTR [r9], al
  0024c	49 83 c1 04	 add	 r9, 4
  00250	48 83 fa 08	 cmp	 rdx, 8
  00254	7c ec		 jl	 SHORT $LL60@step
  00256	48 ff c1	 inc	 rcx
  00259	49 83 c0 08	 add	 r8, 8
  0025d	48 83 f9 04	 cmp	 rcx, 4
  00261	7c d4		 jl	 SHORT $LL63@step

; 372  : 	
; 373  : 	gost_encrypt_with_key (H + 24, S + 24, K[3]);

  00263	48 8d 4e 18	 lea	 rcx, QWORD PTR [rsi+24]
  00267	4c 8d 84 24 00
	01 00 00	 lea	 r8, QWORD PTR K$[rsp+96]
  0026f	48 8d 54 24 58	 lea	 rdx, QWORD PTR S$[rsp+24]
  00274	e8 00 00 00 00	 call	 gost_encrypt_with_key
  00279	bf 0c 00 00 00	 mov	 edi, 12
$LL6@step:

; 374  : 
; 375  : 	for (i = 0; i < 12; i++)
; 376  : 		PSI (S);

  0027e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR S$[rsp]
  00283	e8 00 00 00 00	 call	 PSI
  00288	48 83 ef 01	 sub	 rdi, 1
  0028c	75 f0		 jne	 SHORT $LL6@step

; 377  : 	xor_blocks (S, S, M, 32);

  0028e	48 8d 44 24 40	 lea	 rax, QWORD PTR S$[rsp]
  00293	48 8b d3	 mov	 rdx, rbx
  00296	48 2b e8	 sub	 rbp, rax
$LL68@step:
  00299	48 8d 4c 14 40	 lea	 rcx, QWORD PTR S$[rsp+rdx]
  0029e	48 ff c2	 inc	 rdx
  002a1	8a 04 29	 mov	 al, BYTE PTR [rcx+rbp]
  002a4	30 01		 xor	 BYTE PTR [rcx], al
  002a6	48 83 fa 20	 cmp	 rdx, 32			; 00000020H
  002aa	7c ed		 jl	 SHORT $LL68@step

; 378  : 	PSI (S);

  002ac	48 8d 4c 24 40	 lea	 rcx, QWORD PTR S$[rsp]
  002b1	e8 00 00 00 00	 call	 PSI

; 379  : 	xor_blocks (S, S, H, 32);

  002b6	48 8d 44 24 40	 lea	 rax, QWORD PTR S$[rsp]
  002bb	48 8b d6	 mov	 rdx, rsi
  002be	48 2b d0	 sub	 rdx, rax
$LL73@step:
  002c1	48 8d 4c 1c 40	 lea	 rcx, QWORD PTR S$[rsp+rbx]
  002c6	48 ff c3	 inc	 rbx
  002c9	8a 04 11	 mov	 al, BYTE PTR [rcx+rdx]
  002cc	30 01		 xor	 BYTE PTR [rcx], al
  002ce	48 83 fb 20	 cmp	 rbx, 32			; 00000020H
  002d2	7c ed		 jl	 SHORT $LL73@step

; 380  : 	for (i = 0; i < 61; i++)

  002d4	bb 3d 00 00 00	 mov	 ebx, 61			; 0000003dH
$LL3@step:

; 381  : 		PSI (S);

  002d9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR S$[rsp]
  002de	e8 00 00 00 00	 call	 PSI
  002e3	48 83 eb 01	 sub	 rbx, 1
  002e7	75 f0		 jne	 SHORT $LL3@step

; 382  : 	copy_blocks (H, S, 32);

  002e9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR S$[rsp]
  002ee	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  002f1	48 89 06	 mov	 QWORD PTR [rsi], rax
  002f4	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  002f8	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax
  002fc	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00300	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax
  00304	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00308	48 89 46 18	 mov	 QWORD PTR [rsi+24], rax

; 383  : }

  0030c	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00314	48 33 cc	 xor	 rcx, rsp
  00317	e8 00 00 00 00	 call	 __security_check_cookie
  0031c	48 8b 9c 24 60
	01 00 00	 mov	 rbx, QWORD PTR [rsp+352]
  00324	48 81 c4 30 01
	00 00		 add	 rsp, 304		; 00000130H
  0032b	5f		 pop	 rdi
  0032c	5e		 pop	 rsi
  0032d	5d		 pop	 rbp
  0032e	c3		 ret	 0
step	ENDP
PUBLIC	__$ArrayPad$
PUBLIC	GOSTHASH_finalize
;	COMDAT pdata
pdata	SEGMENT
$pdata$GOSTHASH_finalize DD imagerel $LN57
	DD	imagerel $LN57+381
	DD	imagerel $unwind$GOSTHASH_finalize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GOSTHASH_finalize DD 092919H
	DD	0176417H
	DD	0165417H
	DD	0143417H
	DD	0120117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	080H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GOSTHASH_finalize
_TEXT	SEGMENT
buf$ = 32
H$ = 64
S$ = 96
__$ArrayPad$ = 128
ctx$ = 160
out$ = 168
GOSTHASH_finalize PROC					; COMDAT

; 459  : {

$LN57:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	49 89 6b 18	 mov	 QWORD PTR [r11+24], rbp
  0000b	49 89 73 20	 mov	 QWORD PTR [r11+32], rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 460  : 	byte buf[32];
; 461  : 	byte H[32];
; 462  : 	byte S[32];
; 463  : 	gst_dword final_len;
; 464  : 	gst_dword bptr;
; 465  : 
; 466  : 	final_len = ctx->len;
; 467  : 	
; 468  : 	copy_blocks(H, ctx->H, 32);

  00029	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  0002d	8b 19		 mov	 ebx, DWORD PTR [rcx]

; 469  : 	copy_blocks(S, ctx->S, 32);
; 470  : 
; 471  : 	if (ctx->left) //Handle any remaining bytes

  0002f	33 ed		 xor	 ebp, ebp
  00031	49 89 43 a8	 mov	 QWORD PTR [r11-88], rax
  00035	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00039	48 8b f2	 mov	 rsi, rdx
  0003c	49 89 43 b0	 mov	 QWORD PTR [r11-80], rax
  00040	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00044	48 8b f9	 mov	 rdi, rcx
  00047	49 89 43 b8	 mov	 QWORD PTR [r11-72], rax
  0004b	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
  0004f	49 89 43 c0	 mov	 QWORD PTR [r11-64], rax
  00053	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00057	49 89 43 c8	 mov	 QWORD PTR [r11-56], rax
  0005b	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  0005f	49 89 43 d0	 mov	 QWORD PTR [r11-48], rax
  00063	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00067	49 89 43 d8	 mov	 QWORD PTR [r11-40], rax
  0006b	48 8b 41 40	 mov	 rax, QWORD PTR [rcx+64]
  0006f	49 89 43 e0	 mov	 QWORD PTR [r11-32], rax
  00073	39 69 04	 cmp	 DWORD PTR [rcx+4], ebp
  00076	74 69		 je	 SHORT $LN3@GOSTHASH_f

; 472  : 	{
; 473  : 		set_blocks(buf, 0, 32);
; 474  : 		copy_blocks(buf, ctx->remainder, (gst_dword)ctx->left);

  00078	4c 63 41 04	 movsxd	 r8, DWORD PTR [rcx+4]
  0007c	49 89 6b 88	 mov	 QWORD PTR [r11-120], rbp
  00080	49 89 6b 90	 mov	 QWORD PTR [r11-112], rbp
  00084	4c 3b c5	 cmp	 r8, rbp
  00087	49 89 6b 98	 mov	 QWORD PTR [r11-104], rbp
  0008b	49 89 6b a0	 mov	 QWORD PTR [r11-96], rbp
  0008f	7e 0d		 jle	 SHORT $LN23@GOSTHASH_f
  00091	48 8d 51 48	 lea	 rdx, QWORD PTR [rcx+72]
  00095	49 8d 4b 88	 lea	 rcx, QWORD PTR [r11-120]
  00099	e8 00 00 00 00	 call	 memcpy
$LN23@GOSTHASH_f:

; 475  : 		step (H, buf, ctx);

  0009e	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  000a3	48 8d 4c 24 40	 lea	 rcx, QWORD PTR H$[rsp]
  000a8	4c 8b c7	 mov	 r8, rdi
  000ab	e8 00 00 00 00	 call	 step

; 476  : 		add_blocks (S, buf, 32);

  000b0	44 0f b7 c5	 movzx	 r8d, bp
  000b4	48 8b d5	 mov	 rdx, rbp
$LL28@GOSTHASH_f:
  000b7	0f b6 44 14 60	 movzx	 eax, BYTE PTR S$[rsp+rdx]
  000bc	0f b6 4c 14 20	 movzx	 ecx, BYTE PTR buf$[rsp+rdx]
  000c1	48 ff c2	 inc	 rdx
  000c4	66 03 c8	 add	 cx, ax
  000c7	66 41 03 c8	 add	 cx, r8w
  000cb	66 44 8b c1	 mov	 r8w, cx
  000cf	88 4c 14 5f	 mov	 BYTE PTR S$[rsp+rdx-1], cl
  000d3	66 41 c1 f8 08	 sar	 r8w, 8
  000d8	48 83 fa 20	 cmp	 rdx, 32			; 00000020H
  000dc	7c d9		 jl	 SHORT $LL28@GOSTHASH_f

; 477  : 		final_len += ctx->left;

  000de	03 5f 04	 add	 ebx, DWORD PTR [rdi+4]
$LN3@GOSTHASH_f:

; 478  : 	}
; 479  : 
; 480  : 	set_blocks(buf, 0, 32);
; 481  : 	bptr = 0;
; 482  : 	final_len <<= 3;

  000e1	c1 e3 03	 shl	 ebx, 3
  000e4	48 89 6c 24 20	 mov	 QWORD PTR buf$[rsp], rbp
  000e9	48 89 6c 24 28	 mov	 QWORD PTR buf$[rsp+8], rbp

; 483  : 	while (final_len > 0)

  000ee	3b dd		 cmp	 ebx, ebp
  000f0	48 89 6c 24 30	 mov	 QWORD PTR buf$[rsp+16], rbp
  000f5	48 89 6c 24 38	 mov	 QWORD PTR buf$[rsp+24], rbp
  000fa	7e 11		 jle	 SHORT $LN1@GOSTHASH_f

; 478  : 	}
; 479  : 
; 480  : 	set_blocks(buf, 0, 32);
; 481  : 	bptr = 0;
; 482  : 	final_len <<= 3;

  000fc	48 8d 44 24 20	 lea	 rax, QWORD PTR buf$[rsp]
$LL2@GOSTHASH_f:

; 484  : 	{
; 485  : 		buf[bptr++] = (byte)(final_len & 0xFF);

  00101	88 18		 mov	 BYTE PTR [rax], bl

; 486  : 		final_len >>= 8;

  00103	c1 fb 08	 sar	 ebx, 8
  00106	48 ff c0	 inc	 rax
  00109	3b dd		 cmp	 ebx, ebp
  0010b	7f f4		 jg	 SHORT $LL2@GOSTHASH_f
$LN1@GOSTHASH_f:

; 487  : 	}
; 488  : 
; 489  : 	step (H, buf, ctx);

  0010d	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  00112	48 8d 4c 24 40	 lea	 rcx, QWORD PTR H$[rsp]
  00117	4c 8b c7	 mov	 r8, rdi
  0011a	e8 00 00 00 00	 call	 step

; 490  : 	step (H, S, ctx);

  0011f	48 8d 54 24 60	 lea	 rdx, QWORD PTR S$[rsp]
  00124	48 8d 4c 24 40	 lea	 rcx, QWORD PTR H$[rsp]
  00129	4c 8b c7	 mov	 r8, rdi
  0012c	e8 00 00 00 00	 call	 step

; 491  : 	copy_blocks (out, H, 32);

  00131	4c 8d 5c 24 40	 lea	 r11, QWORD PTR H$[rsp]
  00136	49 8b 03	 mov	 rax, QWORD PTR [r11]
  00139	48 89 06	 mov	 QWORD PTR [rsi], rax
  0013c	49 8b 43 08	 mov	 rax, QWORD PTR [r11+8]
  00140	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax
  00144	49 8b 43 10	 mov	 rax, QWORD PTR [r11+16]
  00148	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax
  0014c	49 8b 43 18	 mov	 rax, QWORD PTR [r11+24]
  00150	48 89 46 18	 mov	 QWORD PTR [rsi+24], rax

; 492  : }

  00154	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0015c	48 33 cc	 xor	 rcx, rsp
  0015f	e8 00 00 00 00	 call	 __security_check_cookie
  00164	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  0016c	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00170	49 8b 6b 20	 mov	 rbp, QWORD PTR [r11+32]
  00174	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  00178	49 8b e3	 mov	 rsp, r11
  0017b	5f		 pop	 rdi
  0017c	c3		 ret	 0
GOSTHASH_finalize ENDP
_TEXT	ENDS
PUBLIC	GOSTHASH_add
;	COMDAT pdata
pdata	SEGMENT
$pdata$GOSTHASH_add DD imagerel $LN49
	DD	imagerel $LN49+411
	DD	imagerel $unwind$GOSTHASH_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GOSTHASH_add DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GOSTHASH_add
_TEXT	SEGMENT
block$ = 80
len$ = 88
ctx$ = 96
GOSTHASH_add PROC					; COMDAT

; 396  : {

$LN49:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001c	44 8b e2	 mov	 r12d, edx

; 397  : 	gst_udword add_bytes;
; 398  : 
; 399  : 	byte *curptr = block;
; 400  : 	byte *barrier = block + (len - 32); //In order that curptr += 32 won't overshoot len.
; 401  : 
; 402  : 	if (ctx->left) //There are unsigned chars left from the last GOSTHASH_add

  0001f	33 ff		 xor	 edi, edi
  00021	49 8b d8	 mov	 rbx, r8
  00024	45 8d 6c 24 e0	 lea	 r13d, DWORD PTR [r12-32]
  00029	48 8b f1	 mov	 rsi, rcx
  0002c	48 8b e9	 mov	 rbp, rcx
  0002f	4c 03 e9	 add	 r13, rcx
  00032	41 39 78 04	 cmp	 DWORD PTR [r8+4], edi
  00036	0f 84 2c 01 00
	00		 je	 $LN7@GOSTHASH_a

; 403  : 	{
; 404  : 		add_bytes = (32 - ctx->left) > len ? len : (32 - ctx->left);
; 405  : 		copy_blocks(ctx->remainder + (byte)ctx->left, block, (gst_dword)add_bytes);

  0003c	41 0f b6 40 04	 movzx	 eax, BYTE PTR [r8+4]
  00041	8d 57 20	 lea	 edx, QWORD PTR [rdi+32]
  00044	41 2b 50 04	 sub	 edx, DWORD PTR [r8+4]
  00048	4a 8d 4c 00 48	 lea	 rcx, QWORD PTR [rax+r8+72]
  0004d	41 3b d4	 cmp	 edx, r12d
  00050	41 0f 47 d4	 cmova	 edx, r12d
  00054	3b d7		 cmp	 edx, edi
  00056	7e 18		 jle	 SHORT $LN12@GOSTHASH_a
  00058	4c 8b c5	 mov	 r8, rbp
  0005b	44 8b ca	 mov	 r9d, edx
  0005e	4c 2b c1	 sub	 r8, rcx
$LL14@GOSTHASH_a:
  00061	41 8a 04 08	 mov	 al, BYTE PTR [r8+rcx]
  00065	88 01		 mov	 BYTE PTR [rcx], al
  00067	48 ff c1	 inc	 rcx
  0006a	49 83 e9 01	 sub	 r9, 1
  0006e	75 f1		 jne	 SHORT $LL14@GOSTHASH_a
$LN12@GOSTHASH_a:

; 406  : 		if ((ctx->left + add_bytes) < 32) //This can be finished in the finalize stage if needed

  00070	8b 43 04	 mov	 eax, DWORD PTR [rbx+4]
  00073	8d 0c 02	 lea	 ecx, DWORD PTR [rdx+rax]
  00076	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00079	0f 82 cc 00 00
	00		 jb	 $LN32@GOSTHASH_a

; 407  : 		{
; 408  : 			return;
; 409  : 		}
; 410  : 		
; 411  : 		curptr += add_bytes;

  0007f	8b ea		 mov	 ebp, edx

; 412  : 		step (ctx->H, ctx->remainder, ctx);

  00081	48 8d 4b 08	 lea	 rcx, QWORD PTR [rbx+8]
  00085	48 8d 53 48	 lea	 rdx, QWORD PTR [rbx+72]
  00089	4c 8b c3	 mov	 r8, rbx
  0008c	48 03 ee	 add	 rbp, rsi
  0008f	e8 00 00 00 00	 call	 step

; 413  : 		add_blocks(ctx->S, ctx->remainder, 32);

  00094	44 0f b7 c7	 movzx	 r8d, di
  00098	48 8b d7	 mov	 rdx, rdi
$LL19@GOSTHASH_a:
  0009b	0f b6 4c 13 48	 movzx	 ecx, BYTE PTR [rbx+rdx+72]
  000a0	0f b6 44 1a 28	 movzx	 eax, BYTE PTR [rdx+rbx+40]
  000a5	48 ff c2	 inc	 rdx
  000a8	66 03 c8	 add	 cx, ax
  000ab	66 41 03 c8	 add	 cx, r8w
  000af	66 44 8b c1	 mov	 r8w, cx
  000b3	88 4c 1a 27	 mov	 BYTE PTR [rdx+rbx+39], cl
  000b7	66 41 c1 f8 08	 sar	 r8w, 8
  000bc	48 83 fa 20	 cmp	 rdx, 32			; 00000020H
  000c0	7c d9		 jl	 SHORT $LL19@GOSTHASH_a

; 414  : 		ctx->len += 32;

  000c2	83 03 20	 add	 DWORD PTR [rbx], 32	; 00000020H

; 415  : 		ctx->left = 0;

  000c5	89 7b 04	 mov	 DWORD PTR [rbx+4], edi
$LN40@GOSTHASH_a:

; 430  : 	}
; 431  : 
; 432  : 	while (curptr <= barrier) //Add the input block to the hash

  000c8	49 3b ed	 cmp	 rbp, r13
  000cb	77 55		 ja	 SHORT $LN2@GOSTHASH_a
  000cd	4c 8d 73 28	 lea	 r14, QWORD PTR [rbx+40]
$LL3@GOSTHASH_a:

; 433  : 	{
; 434  : 		step(ctx->H, curptr, ctx);

  000d1	48 8d 4b 08	 lea	 rcx, QWORD PTR [rbx+8]
  000d5	4c 8b c3	 mov	 r8, rbx
  000d8	48 8b d5	 mov	 rdx, rbp
  000db	e8 00 00 00 00	 call	 step

; 435  : 		
; 436  : 		add_blocks(ctx->S, curptr, 32); //Add 32 unsigned chars of the message to the encrypted message

  000e0	4c 8b c5	 mov	 r8, rbp
  000e3	44 0f b7 cf	 movzx	 r9d, di
  000e7	49 8b d6	 mov	 rdx, r14
  000ea	41 ba 20 00 00
	00		 mov	 r10d, 32		; 00000020H
  000f0	4d 2b c6	 sub	 r8, r14
$LL29@GOSTHASH_a:
  000f3	41 0f b6 0c 10	 movzx	 ecx, BYTE PTR [r8+rdx]
  000f8	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  000fb	66 03 c8	 add	 cx, ax
  000fe	66 41 03 c9	 add	 cx, r9w
  00102	66 44 8b c9	 mov	 r9w, cx
  00106	88 0a		 mov	 BYTE PTR [rdx], cl
  00108	48 ff c2	 inc	 rdx
  0010b	66 41 c1 f9 08	 sar	 r9w, 8
  00110	49 83 ea 01	 sub	 r10, 1
  00114	75 dd		 jne	 SHORT $LL29@GOSTHASH_a

; 437  : 		
; 438  : 		ctx->len += 32; //We've processed 32 unsigned chars

  00116	83 03 20	 add	 DWORD PTR [rbx], 32	; 00000020H

; 439  : 		curptr += 32; //Advance the block-pointer 32 unsigned chars

  00119	48 83 c5 20	 add	 rbp, 32			; 00000020H
  0011d	49 3b ed	 cmp	 rbp, r13
  00120	76 af		 jbe	 SHORT $LL3@GOSTHASH_a
$LN2@GOSTHASH_a:

; 440  : 	}
; 441  : 
; 442  : 	if (curptr != block + len) //If we have unsigned chars remaining, add them for the next GOSTHASH_add of _finalize

  00122	4a 8d 04 26	 lea	 rax, QWORD PTR [rsi+r12]
  00126	48 3b e8	 cmp	 rbp, rax
  00129	74 20		 je	 SHORT $LN32@GOSTHASH_a

; 443  : 	{
; 444  : 		ctx->left = (gst_udword)(block + len - curptr);

  0012b	2b f5		 sub	 esi, ebp
  0012d	42 8d 04 26	 lea	 eax, DWORD PTR [rsi+r12]

; 445  : 		copy_blocks(ctx->remainder, curptr, (gst_dword)ctx->left);

  00131	48 63 c8	 movsxd	 rcx, eax
  00134	89 43 04	 mov	 DWORD PTR [rbx+4], eax
  00137	48 3b cf	 cmp	 rcx, rdi
  0013a	7e 0f		 jle	 SHORT $LN32@GOSTHASH_a
$LL34@GOSTHASH_a:
  0013c	8a 04 2f	 mov	 al, BYTE PTR [rdi+rbp]
  0013f	48 ff c7	 inc	 rdi
  00142	48 3b f9	 cmp	 rdi, rcx
  00145	88 44 3b 47	 mov	 BYTE PTR [rbx+rdi+71], al
  00149	7c f1		 jl	 SHORT $LL34@GOSTHASH_a
$LN32@GOSTHASH_a:

; 446  : 	}
; 447  : }

  0014b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00150	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00155	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0015a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0015e	41 5f		 pop	 r15
  00160	41 5e		 pop	 r14
  00162	41 5d		 pop	 r13
  00164	41 5c		 pop	 r12
  00166	5f		 pop	 rdi
  00167	c3		 ret	 0
$LN7@GOSTHASH_a:

; 416  : 	}
; 417  : /**
; 418  :  *
; 419  :  *	\fn else if (ctx->left + len < 32)
; 420  :  *	\brief
; 421  :  *	\param[in] ctx->left +
; 422  :  *	\return
; 423  :  *
; 424  :  */
; 425  : 	else if (ctx->left + len < 32)

  00168	41 83 fc 20	 cmp	 r12d, 32		; 00000020H
  0016c	0f 83 56 ff ff
	ff		 jae	 $LN40@GOSTHASH_a

; 426  : 	{
; 427  : 		copy_blocks(ctx->remainder + (byte)ctx->left, block, (gst_dword)len);

  00172	44 3b e7	 cmp	 r12d, edi
  00175	41 0f b6 40 04	 movzx	 eax, BYTE PTR [r8+4]
  0017a	4a 8d 4c 00 48	 lea	 rcx, QWORD PTR [rax+r8+72]
  0017f	7e 14		 jle	 SHORT $LN22@GOSTHASH_a
  00181	48 2b f1	 sub	 rsi, rcx
  00184	49 8b d4	 mov	 rdx, r12
$LL24@GOSTHASH_a:
  00187	8a 04 0e	 mov	 al, BYTE PTR [rsi+rcx]
  0018a	88 01		 mov	 BYTE PTR [rcx], al
  0018c	48 ff c1	 inc	 rcx
  0018f	48 83 ea 01	 sub	 rdx, 1
  00193	75 f2		 jne	 SHORT $LL24@GOSTHASH_a
$LN22@GOSTHASH_a:

; 428  : 		ctx->left += len;

  00195	45 01 60 04	 add	 DWORD PTR [r8+4], r12d

; 429  : 		return;

  00199	eb b0		 jmp	 SHORT $LN32@GOSTHASH_a
GOSTHASH_add ENDP
END
