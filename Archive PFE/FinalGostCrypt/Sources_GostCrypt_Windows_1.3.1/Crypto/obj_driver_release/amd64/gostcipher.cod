; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

GostR3411_94_CryptoProParamSet DD 01H
	DD	03H
	DD	0aH
	DD	09H
	DD	05H
	DD	0bH
	DD	04H
	DD	0fH
	DD	08H
	DD	06H
	DD	07H
	DD	0eH
	DD	0dH
	DD	00H
	DD	02H
	DD	0cH
	DD	0dH
	DD	0eH
	DD	04H
	DD	01H
	DD	07H
	DD	00H
	DD	05H
	DD	0aH
	DD	03H
	DD	0cH
	DD	08H
	DD	0fH
	DD	06H
	DD	02H
	DD	09H
	DD	0bH
	DD	07H
	DD	06H
	DD	02H
	DD	04H
	DD	0dH
	DD	09H
	DD	0fH
	DD	00H
	DD	0aH
	DD	01H
	DD	05H
	DD	0bH
	DD	08H
	DD	0eH
	DD	0cH
	DD	03H
	DD	07H
	DD	06H
	DD	04H
	DD	0bH
	DD	09H
	DD	0cH
	DD	02H
	DD	0aH
	DD	01H
	DD	08H
	DD	00H
	DD	0eH
	DD	0fH
	DD	0dH
	DD	03H
	DD	05H
	DD	04H
	DD	0aH
	DD	07H
	DD	0cH
	DD	00H
	DD	0fH
	DD	02H
	DD	08H
	DD	0eH
	DD	01H
	DD	06H
	DD	05H
	DD	0dH
	DD	0bH
	DD	09H
	DD	03H
	DD	07H
	DD	0fH
	DD	0cH
	DD	0eH
	DD	09H
	DD	04H
	DD	01H
	DD	00H
	DD	03H
	DD	0bH
	DD	05H
	DD	02H
	DD	06H
	DD	0aH
	DD	08H
	DD	0dH
	DD	05H
	DD	0fH
	DD	04H
	DD	00H
	DD	02H
	DD	0dH
	DD	0bH
	DD	09H
	DD	01H
	DD	07H
	DD	06H
	DD	03H
	DD	0cH
	DD	0eH
	DD	0aH
	DD	08H
	DD	0aH
	DD	04H
	DD	05H
	DD	06H
	DD	08H
	DD	01H
	DD	03H
	DD	07H
	DD	0dH
	DD	0cH
	DD	0eH
	DD	00H
	DD	09H
	DD	02H
	DD	0bH
	DD	0fH
PUBLIC	gost_xor_ks
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\crypto\gostcipher.c
;	COMDAT gost_xor_ks
_TEXT	SEGMENT
ks$ = 8
out_ks$ = 16
in$ = 24
len$ = 32
gost_xor_ks PROC					; COMDAT

; 298  : 	gst_dword i;
; 299  : 	if (!len)
; 300  : 		return;
; 301  : 
; 302  : 	out_ks->X0 = ks->X0 ^ in[0];

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]
  00002	41 33 00	 xor	 eax, DWORD PTR [r8]
  00005	89 02		 mov	 DWORD PTR [rdx], eax

; 303  : 	out_ks->X1 = ks->X1 ^ in[0];

  00007	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  0000a	41 33 00	 xor	 eax, DWORD PTR [r8]
  0000d	89 42 04	 mov	 DWORD PTR [rdx+4], eax

; 304  : 	out_ks->X2 = ks->X2 ^ in[0];

  00010	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00013	41 33 00	 xor	 eax, DWORD PTR [r8]
  00016	89 42 08	 mov	 DWORD PTR [rdx+8], eax

; 305  : 	out_ks->X3 = ks->X3 ^ in[0];

  00019	8b 41 0c	 mov	 eax, DWORD PTR [rcx+12]
  0001c	41 33 00	 xor	 eax, DWORD PTR [r8]
  0001f	89 42 0c	 mov	 DWORD PTR [rdx+12], eax

; 306  : 	out_ks->X4 = ks->X4 ^ in[0];

  00022	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  00025	41 33 00	 xor	 eax, DWORD PTR [r8]
  00028	89 42 10	 mov	 DWORD PTR [rdx+16], eax

; 307  : 	out_ks->X5 = ks->X5 ^ in[0];

  0002b	8b 41 14	 mov	 eax, DWORD PTR [rcx+20]
  0002e	41 33 00	 xor	 eax, DWORD PTR [r8]
  00031	89 42 14	 mov	 DWORD PTR [rdx+20], eax

; 308  : 	out_ks->X6 = ks->X6 ^ in[0];

  00034	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  00037	41 33 00	 xor	 eax, DWORD PTR [r8]
  0003a	89 42 18	 mov	 DWORD PTR [rdx+24], eax

; 309  : 	out_ks->X7 = ks->X7 ^ in[0];

  0003d	8b 41 1c	 mov	 eax, DWORD PTR [rcx+28]
  00040	41 33 00	 xor	 eax, DWORD PTR [r8]
  00043	89 42 1c	 mov	 DWORD PTR [rdx+28], eax

; 310  : 
; 311  : 	for (i = 1; i < len; i++)
; 312  : 	{
; 313  : 		out_ks->X0 ^= in[i];

  00046	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  0004a	31 02		 xor	 DWORD PTR [rdx], eax

; 314  : 		out_ks->X1 ^= in[i];

  0004c	31 42 04	 xor	 DWORD PTR [rdx+4], eax

; 315  : 		out_ks->X2 ^= in[i];

  0004f	31 42 08	 xor	 DWORD PTR [rdx+8], eax

; 316  : 		out_ks->X3 ^= in[i];

  00052	31 42 0c	 xor	 DWORD PTR [rdx+12], eax

; 317  : 		out_ks->X4 ^= in[i];

  00055	31 42 10	 xor	 DWORD PTR [rdx+16], eax

; 318  : 		out_ks->X5 ^= in[i];

  00058	31 42 14	 xor	 DWORD PTR [rdx+20], eax

; 319  : 		out_ks->X6 ^= in[i];

  0005b	31 42 18	 xor	 DWORD PTR [rdx+24], eax

; 320  : 		out_ks->X7 ^= in[i];

  0005e	31 42 1c	 xor	 DWORD PTR [rdx+28], eax

; 321  : 	}
; 322  : }

  00061	c3		 ret	 0
gost_xor_ks ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT r
_TEXT	SEGMENT
n1$ = 8
n2$ = 16
X$ = 24
sbox$ = 32
r	PROC						; COMDAT

; 66   : 	n1 += X;

  00000	41 03 c8	 add	 ecx, r8d
  00003	44 8b d2	 mov	 r10d, edx

; 67   : #ifdef GOST_DYNAMIC_SBOXES
; 68   : 	n1 =  sbox->k8[(n1>>28)&0xF] | sbox->k7[(n1>>24)&0xF]
; 69   : 				| sbox->k6[(n1>>20)&0xF] | sbox->k5[(n1>>16)&0xF]
; 70   : 				| sbox->k4[(n1>>12)&0xF] | sbox->k3[(n1>>8)&0xF]
; 71   : 				| sbox->k2[(n1>>4)&0xF] | sbox->k1[n1&0xF];
; 72   : #else
; 73   : 	n1 =  (gst_udword)sbox->k8[(n1>>28)&0xF]<<28 | (gst_udword)sbox->k7[(n1>>24)&0xF]<<24
; 74   : 				| (gst_udword)sbox->k6[(n1>>20)&0xF]<<20 | (gst_udword)sbox->k5[(n1>>16)&0xF]<<16
; 75   : 				| (gst_udword)sbox->k4[(n1>>12)&0xF]<<12 | (gst_udword)sbox->k3[(n1>>8)&0xF]<<8
; 76   : 				| (gst_udword)sbox->k2[(n1>>4)&0xF]<<4 | (gst_udword)sbox->k1[n1&0xF];
; 77   : #endif
; 78   : 	n1 = rotl32(n1, 11);

  00006	44 8b c1	 mov	 r8d, ecx

; 79   : 	n2 ^= n1;
; 80   : 	return n2;

  00009	48 c1 e9 04	 shr	 rcx, 4
  0000d	83 e1 0f	 and	 ecx, 15
  00010	49 8b c0	 mov	 rax, r8
  00013	41 8b 94 89 80
	01 00 00	 mov	 edx, DWORD PTR [r9+rcx*4+384]
  0001b	48 c1 e8 08	 shr	 rax, 8
  0001f	49 8b c8	 mov	 rcx, r8
  00022	83 e0 0f	 and	 eax, 15
  00025	48 c1 e9 18	 shr	 rcx, 24
  00029	41 0b 94 81 40
	01 00 00	 or	 edx, DWORD PTR [r9+rax*4+320]
  00031	83 e1 0f	 and	 ecx, 15
  00034	49 8b c0	 mov	 rax, r8
  00037	48 c1 e8 0c	 shr	 rax, 12
  0003b	83 e0 0f	 and	 eax, 15
  0003e	41 0b 94 81 00
	01 00 00	 or	 edx, DWORD PTR [r9+rax*4+256]
  00046	49 8b c0	 mov	 rax, r8
  00049	48 c1 e8 10	 shr	 rax, 16
  0004d	83 e0 0f	 and	 eax, 15
  00050	41 0b 94 81 c0
	00 00 00	 or	 edx, DWORD PTR [r9+rax*4+192]
  00058	49 8b c0	 mov	 rax, r8
  0005b	48 c1 e8 14	 shr	 rax, 20
  0005f	83 e0 0f	 and	 eax, 15
  00062	41 0b 94 81 80
	00 00 00	 or	 edx, DWORD PTR [r9+rax*4+128]
  0006a	41 0b 54 89 40	 or	 edx, DWORD PTR [r9+rcx*4+64]
  0006f	49 8b c8	 mov	 rcx, r8
  00072	49 c1 e8 1c	 shr	 r8, 28
  00076	83 e1 0f	 and	 ecx, 15
  00079	41 0b 94 89 c0
	01 00 00	 or	 edx, DWORD PTR [r9+rcx*4+448]
  00081	43 0b 14 81	 or	 edx, DWORD PTR [r9+r8*4]
  00085	c1 c2 0b	 rol	 edx, 11
  00088	41 33 d2	 xor	 edx, r10d
  0008b	8b c2		 mov	 eax, edx

; 81   : }

  0008d	c3		 ret	 0
r	ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT xor_s_box
_TEXT	SEGMENT
s_box$ = 8
seed$ = 16
xor_s_box PROC						; COMDAT

; 38   :    int i;
; 39   :    for (i = 0; i < 16; i++)

  00000	4c 8d 42 02	 lea	 r8, QWORD PTR [rdx+2]
  00004	41 b9 10 00 00
	00		 mov	 r9d, 16
  0000a	48 8d 91 80 01
	00 00		 lea	 rdx, QWORD PTR [rcx+384]
$LL3@xor_s_box:

; 40   :    {
; 41   :       s_box->k1[i] ^= (seed[ (i * 4) + 0 ]   ) & 0xF;

  00011	41 0f b6 48 fe	 movzx	 ecx, BYTE PTR [r8-2]
  00016	8b c1		 mov	 eax, ecx

; 42   :       s_box->k2[i] ^= (seed[ (i * 4) + 0 ]>>4) & 0xF;

  00018	c1 e9 04	 shr	 ecx, 4
  0001b	31 0a		 xor	 DWORD PTR [rdx], ecx

; 43   :       s_box->k3[i] ^= (seed[ (i * 4) + 1 ]   ) & 0xF;

  0001d	41 0f b6 48 ff	 movzx	 ecx, BYTE PTR [r8-1]
  00022	83 e0 0f	 and	 eax, 15
  00025	31 42 40	 xor	 DWORD PTR [rdx+64], eax
  00028	8b c1		 mov	 eax, ecx

; 44   :       s_box->k4[i] ^= (seed[ (i * 4) + 1 ]>>4) & 0xF;

  0002a	c1 e9 04	 shr	 ecx, 4
  0002d	31 4a 80	 xor	 DWORD PTR [rdx-128], ecx

; 45   :       s_box->k5[i] ^= (seed[ (i * 4) + 2 ]   ) & 0xF;

  00030	41 0f b6 08	 movzx	 ecx, BYTE PTR [r8]
  00034	83 e0 0f	 and	 eax, 15
  00037	31 42 c0	 xor	 DWORD PTR [rdx-64], eax
  0003a	8b c1		 mov	 eax, ecx

; 46   :       s_box->k6[i] ^= (seed[ (i * 4) + 2 ]>>4) & 0xF;

  0003c	c1 e9 04	 shr	 ecx, 4
  0003f	31 8a 00 ff ff
	ff		 xor	 DWORD PTR [rdx-256], ecx

; 47   :       s_box->k7[i] ^= (seed[ (i * 4) + 3 ]   ) & 0xF;

  00045	41 0f b6 48 01	 movzx	 ecx, BYTE PTR [r8+1]
  0004a	83 e0 0f	 and	 eax, 15
  0004d	31 82 40 ff ff
	ff		 xor	 DWORD PTR [rdx-192], eax
  00053	8b c1		 mov	 eax, ecx

; 48   :       s_box->k8[i] ^= (seed[ (i * 4) + 3 ]>>4) & 0xF;

  00055	c1 e9 04	 shr	 ecx, 4
  00058	31 8a 80 fe ff
	ff		 xor	 DWORD PTR [rdx-384], ecx
  0005e	83 e0 0f	 and	 eax, 15
  00061	48 83 c2 04	 add	 rdx, 4
  00065	31 82 bc fe ff
	ff		 xor	 DWORD PTR [rdx-324], eax
  0006b	49 83 c0 04	 add	 r8, 4
  0006f	49 83 e9 01	 sub	 r9, 1
  00073	75 9c		 jne	 SHORT $LL3@xor_s_box

; 49   :    }
; 50   : }

  00075	f3 c3		 fatret	 0
xor_s_box ENDP
PUBLIC	gost_decrypt
;	COMDAT pdata
pdata	SEGMENT
$pdata$gost_decrypt DD imagerel $LN3
	DD	imagerel $LN3+690
	DD	imagerel $unwind$gost_decrypt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gost_decrypt DD 0a1901H
	DD	0f3419H
	DD	0f0153219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT gost_decrypt
_TEXT	SEGMENT
tv385 = 96
in$ = 96
out$ = 104
tv384 = 112
ks$ = 112
gost_decrypt PROC					; COMDAT

; 161  : {

$LN3:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 162  : 	gst_udword n1, n2;
; 163  : 	gost_s_box *sbox;
; 164  : 	n1 = 0;
; 165  : 	n2 = 0;
; 166  : 
; 167  : 	n1 = (gst_udword)in[3] << 24 | (gst_udword)in[2] << 16 | (gst_udword)in[1] << 8 | (gst_udword)in[0];

  00019	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  0001d	0f b6 59 03	 movzx	 ebx, BYTE PTR [rcx+3]

; 168  : 	n2 = (gst_udword)in[7] << 24 | (gst_udword)in[6] << 16 | (gst_udword)in[5] << 8 | (gst_udword)in[4];
; 169  : #ifdef GOST_DYNAMIC_SBOXES
; 170  : 	sbox = &ks->sbox;
; 171  : #else
; 172  : 	sbox = ks->sbox;
; 173  : #endif
; 174  : 
; 175  : 	//Rounds 1-8
; 176  : 	n2 = r(n1, n2, ks->X0, sbox);

  00021	0f b6 51 07	 movzx	 edx, BYTE PTR [rcx+7]
  00025	c1 e2 08	 shl	 edx, 8
  00028	c1 e3 08	 shl	 ebx, 8
  0002b	49 8b f0	 mov	 rsi, r8
  0002e	0b d8		 or	 ebx, eax
  00030	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00034	4d 8d 48 20	 lea	 r9, QWORD PTR [r8+32]
  00038	45 8b 00	 mov	 r8d, DWORD PTR [r8]
  0003b	c1 e3 08	 shl	 ebx, 8
  0003e	0b d8		 or	 ebx, eax
  00040	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00043	44 89 44 24 60	 mov	 DWORD PTR tv385[rsp], r8d
  00048	c1 e3 08	 shl	 ebx, 8
  0004b	0b d8		 or	 ebx, eax
  0004d	0f b6 41 06	 movzx	 eax, BYTE PTR [rcx+6]
  00051	0b d0		 or	 edx, eax
  00053	0f b6 41 05	 movzx	 eax, BYTE PTR [rcx+5]
  00057	c1 e2 08	 shl	 edx, 8
  0005a	0b d0		 or	 edx, eax
  0005c	0f b6 41 04	 movzx	 eax, BYTE PTR [rcx+4]
  00060	8b cb		 mov	 ecx, ebx
  00062	c1 e2 08	 shl	 edx, 8
  00065	0b d0		 or	 edx, eax
  00067	e8 00 00 00 00	 call	 r

; 177  : 	n1 = r(n2, n1, ks->X1, sbox);

  0006c	8b d3		 mov	 edx, ebx
  0006e	44 8b d8	 mov	 r11d, eax
  00071	8b 46 04	 mov	 eax, DWORD PTR [rsi+4]
  00074	44 8b c0	 mov	 r8d, eax
  00077	41 8b cb	 mov	 ecx, r11d
  0007a	89 44 24 70	 mov	 DWORD PTR tv384[rsp], eax
  0007e	e8 00 00 00 00	 call	 r

; 178  : 	n2 = r(n1, n2, ks->X2, sbox);

  00083	44 8b 7e 08	 mov	 r15d, DWORD PTR [rsi+8]
  00087	41 8b d3	 mov	 edx, r11d
  0008a	45 8b c7	 mov	 r8d, r15d
  0008d	8b c8		 mov	 ecx, eax
  0008f	8b d8		 mov	 ebx, eax
  00091	e8 00 00 00 00	 call	 r

; 179  : 	n1 = r(n2, n1, ks->X3, sbox);

  00096	44 8b 76 0c	 mov	 r14d, DWORD PTR [rsi+12]
  0009a	8b d3		 mov	 edx, ebx
  0009c	45 8b c6	 mov	 r8d, r14d
  0009f	8b c8		 mov	 ecx, eax
  000a1	44 8b d8	 mov	 r11d, eax
  000a4	e8 00 00 00 00	 call	 r

; 180  : 	n2 = r(n1, n2, ks->X4, sbox);

  000a9	44 8b 6e 10	 mov	 r13d, DWORD PTR [rsi+16]
  000ad	41 8b d3	 mov	 edx, r11d
  000b0	45 8b c5	 mov	 r8d, r13d
  000b3	8b c8		 mov	 ecx, eax
  000b5	8b d8		 mov	 ebx, eax
  000b7	e8 00 00 00 00	 call	 r

; 181  : 	n1 = r(n2, n1, ks->X5, sbox);

  000bc	44 8b 66 14	 mov	 r12d, DWORD PTR [rsi+20]
  000c0	8b d3		 mov	 edx, ebx
  000c2	45 8b c4	 mov	 r8d, r12d
  000c5	8b c8		 mov	 ecx, eax
  000c7	44 8b d8	 mov	 r11d, eax
  000ca	e8 00 00 00 00	 call	 r

; 182  : 	n2 = r(n1, n2, ks->X6, sbox);

  000cf	8b 6e 18	 mov	 ebp, DWORD PTR [rsi+24]
  000d2	41 8b d3	 mov	 edx, r11d
  000d5	44 8b c5	 mov	 r8d, ebp
  000d8	8b c8		 mov	 ecx, eax
  000da	8b f8		 mov	 edi, eax
  000dc	e8 00 00 00 00	 call	 r

; 183  : 	n1 = r(n2, n1, ks->X7, sbox);

  000e1	8b 76 1c	 mov	 esi, DWORD PTR [rsi+28]
  000e4	8b d7		 mov	 edx, edi
  000e6	44 8b c6	 mov	 r8d, esi
  000e9	8b c8		 mov	 ecx, eax
  000eb	8b d8		 mov	 ebx, eax
  000ed	e8 00 00 00 00	 call	 r

; 184  : 
; 185  : 	//Rounds 9-32
; 186  : 	n2 = r(n1, n2, ks->X7, sbox);

  000f2	44 8b c6	 mov	 r8d, esi
  000f5	8b d3		 mov	 edx, ebx
  000f7	8b c8		 mov	 ecx, eax
  000f9	44 8b d8	 mov	 r11d, eax
  000fc	e8 00 00 00 00	 call	 r

; 187  : 	n1 = r(n2, n1, ks->X6, sbox);

  00101	44 8b c5	 mov	 r8d, ebp
  00104	41 8b d3	 mov	 edx, r11d
  00107	8b c8		 mov	 ecx, eax
  00109	8b d8		 mov	 ebx, eax
  0010b	e8 00 00 00 00	 call	 r

; 188  : 	n2 = r(n1, n2, ks->X5, sbox);

  00110	45 8b c4	 mov	 r8d, r12d
  00113	44 8b d8	 mov	 r11d, eax
  00116	8b d3		 mov	 edx, ebx
  00118	8b c8		 mov	 ecx, eax
  0011a	e8 00 00 00 00	 call	 r

; 189  : 	n1 = r(n2, n1, ks->X4, sbox);

  0011f	45 8b c5	 mov	 r8d, r13d
  00122	41 8b d3	 mov	 edx, r11d
  00125	8b c8		 mov	 ecx, eax
  00127	8b d8		 mov	 ebx, eax
  00129	e8 00 00 00 00	 call	 r

; 190  : 	n2 = r(n1, n2, ks->X3, sbox);

  0012e	45 8b c6	 mov	 r8d, r14d
  00131	8b d3		 mov	 edx, ebx
  00133	8b c8		 mov	 ecx, eax
  00135	44 8b d8	 mov	 r11d, eax
  00138	e8 00 00 00 00	 call	 r

; 191  : 	n1 = r(n2, n1, ks->X2, sbox);

  0013d	45 8b c7	 mov	 r8d, r15d
  00140	41 8b d3	 mov	 edx, r11d
  00143	8b c8		 mov	 ecx, eax
  00145	8b d8		 mov	 ebx, eax
  00147	e8 00 00 00 00	 call	 r

; 192  : 	n2 = r(n1, n2, ks->X1, sbox);

  0014c	8b 7c 24 70	 mov	 edi, DWORD PTR tv384[rsp]
  00150	8b d3		 mov	 edx, ebx
  00152	44 8b c7	 mov	 r8d, edi
  00155	8b c8		 mov	 ecx, eax
  00157	44 8b d8	 mov	 r11d, eax
  0015a	e8 00 00 00 00	 call	 r

; 193  : 	n1 = r(n2, n1, ks->X0, sbox);

  0015f	44 8b 44 24 60	 mov	 r8d, DWORD PTR tv385[rsp]
  00164	41 8b d3	 mov	 edx, r11d
  00167	8b c8		 mov	 ecx, eax
  00169	8b d8		 mov	 ebx, eax
  0016b	e8 00 00 00 00	 call	 r

; 194  : 
; 195  : 	n2 = r(n1, n2, ks->X7, sbox);

  00170	44 8b c6	 mov	 r8d, esi
  00173	8b d3		 mov	 edx, ebx
  00175	8b c8		 mov	 ecx, eax
  00177	44 8b d8	 mov	 r11d, eax
  0017a	e8 00 00 00 00	 call	 r

; 196  : 	n1 = r(n2, n1, ks->X6, sbox);

  0017f	44 8b c5	 mov	 r8d, ebp
  00182	41 8b d3	 mov	 edx, r11d
  00185	8b c8		 mov	 ecx, eax
  00187	8b d8		 mov	 ebx, eax
  00189	e8 00 00 00 00	 call	 r

; 197  : 	n2 = r(n1, n2, ks->X5, sbox);

  0018e	45 8b c4	 mov	 r8d, r12d
  00191	8b d3		 mov	 edx, ebx
  00193	8b c8		 mov	 ecx, eax
  00195	44 8b d8	 mov	 r11d, eax
  00198	e8 00 00 00 00	 call	 r

; 198  : 	n1 = r(n2, n1, ks->X4, sbox);

  0019d	45 8b c5	 mov	 r8d, r13d
  001a0	41 8b d3	 mov	 edx, r11d
  001a3	8b c8		 mov	 ecx, eax
  001a5	8b d8		 mov	 ebx, eax
  001a7	e8 00 00 00 00	 call	 r

; 199  : 	n2 = r(n1, n2, ks->X3, sbox);

  001ac	45 8b c6	 mov	 r8d, r14d
  001af	8b d3		 mov	 edx, ebx
  001b1	8b c8		 mov	 ecx, eax
  001b3	44 8b d8	 mov	 r11d, eax
  001b6	e8 00 00 00 00	 call	 r

; 200  : 	n1 = r(n2, n1, ks->X2, sbox);

  001bb	45 8b c7	 mov	 r8d, r15d
  001be	41 8b d3	 mov	 edx, r11d
  001c1	8b c8		 mov	 ecx, eax
  001c3	8b d8		 mov	 ebx, eax
  001c5	e8 00 00 00 00	 call	 r

; 201  : 	n2 = r(n1, n2, ks->X1, sbox);

  001ca	44 8b c7	 mov	 r8d, edi
  001cd	8b d3		 mov	 edx, ebx
  001cf	8b c8		 mov	 ecx, eax
  001d1	44 8b d8	 mov	 r11d, eax
  001d4	e8 00 00 00 00	 call	 r

; 202  : 	n1 = r(n2, n1, ks->X0, sbox);

  001d9	44 8b 44 24 60	 mov	 r8d, DWORD PTR tv385[rsp]
  001de	41 8b d3	 mov	 edx, r11d
  001e1	8b c8		 mov	 ecx, eax
  001e3	8b d8		 mov	 ebx, eax
  001e5	e8 00 00 00 00	 call	 r

; 203  : 
; 204  : 	n2 = r(n1, n2, ks->X7, sbox);

  001ea	44 8b c6	 mov	 r8d, esi
  001ed	8b d3		 mov	 edx, ebx
  001ef	8b c8		 mov	 ecx, eax
  001f1	44 8b d8	 mov	 r11d, eax
  001f4	e8 00 00 00 00	 call	 r

; 205  : 	n1 = r(n2, n1, ks->X6, sbox);

  001f9	44 8b c5	 mov	 r8d, ebp
  001fc	41 8b d3	 mov	 edx, r11d
  001ff	8b c8		 mov	 ecx, eax
  00201	8b d8		 mov	 ebx, eax
  00203	e8 00 00 00 00	 call	 r

; 206  : 	n2 = r(n1, n2, ks->X5, sbox);

  00208	45 8b c4	 mov	 r8d, r12d
  0020b	44 8b d8	 mov	 r11d, eax
  0020e	8b d3		 mov	 edx, ebx
  00210	8b c8		 mov	 ecx, eax
  00212	e8 00 00 00 00	 call	 r

; 207  : 	n1 = r(n2, n1, ks->X4, sbox);

  00217	45 8b c5	 mov	 r8d, r13d
  0021a	41 8b d3	 mov	 edx, r11d
  0021d	8b c8		 mov	 ecx, eax
  0021f	8b d8		 mov	 ebx, eax
  00221	e8 00 00 00 00	 call	 r

; 208  : 	n2 = r(n1, n2, ks->X3, sbox);

  00226	45 8b c6	 mov	 r8d, r14d
  00229	8b d3		 mov	 edx, ebx
  0022b	8b c8		 mov	 ecx, eax
  0022d	44 8b d8	 mov	 r11d, eax
  00230	e8 00 00 00 00	 call	 r

; 209  : 	n1 = r(n2, n1, ks->X2, sbox);

  00235	45 8b c7	 mov	 r8d, r15d
  00238	41 8b d3	 mov	 edx, r11d
  0023b	8b c8		 mov	 ecx, eax
  0023d	8b d8		 mov	 ebx, eax
  0023f	e8 00 00 00 00	 call	 r

; 210  : 	n2 = r(n1, n2, ks->X1, sbox);

  00244	44 8b c7	 mov	 r8d, edi
  00247	8b d3		 mov	 edx, ebx
  00249	8b c8		 mov	 ecx, eax
  0024b	44 8b d8	 mov	 r11d, eax
  0024e	e8 00 00 00 00	 call	 r

; 211  : 	n1 = r(n2, n1, ks->X0, sbox);

  00253	44 8b 44 24 60	 mov	 r8d, DWORD PTR tv385[rsp]
  00258	41 8b d3	 mov	 edx, r11d
  0025b	8b c8		 mov	 ecx, eax
  0025d	8b d8		 mov	 ebx, eax
  0025f	e8 00 00 00 00	 call	 r

; 212  : 	
; 213  : 	out[0] = (byte)(n2 & 0xFF); out[1] = (byte)((n2 >> 8) & 0xFF); out[2] = (byte)((n2 >> 16) & 0xFF); out[3] = (byte)((n2 >> 24) & 0xFF);

  00264	48 8b 54 24 68	 mov	 rdx, QWORD PTR out$[rsp]
  00269	8b cb		 mov	 ecx, ebx
  0026b	c1 e9 08	 shr	 ecx, 8
  0026e	44 8b c8	 mov	 r9d, eax
  00271	88 1a		 mov	 BYTE PTR [rdx], bl
  00273	88 4a 01	 mov	 BYTE PTR [rdx+1], cl
  00276	8b cb		 mov	 ecx, ebx
  00278	c1 eb 18	 shr	 ebx, 24
  0027b	c1 e9 10	 shr	 ecx, 16

; 214  : 	out[4] = (byte)(n1 & 0xFF); out[5] = (byte)((n1 >> 8) & 0xFF); out[6] = (byte)((n1 >> 16) & 0xFF); out[7] = (byte)((n1 >> 24) & 0xFF);

  0027e	88 42 04	 mov	 BYTE PTR [rdx+4], al
  00281	88 5a 03	 mov	 BYTE PTR [rdx+3], bl

; 215  : }

  00284	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  00289	88 4a 02	 mov	 BYTE PTR [rdx+2], cl
  0028c	8b c8		 mov	 ecx, eax
  0028e	c1 e9 08	 shr	 ecx, 8
  00291	c1 e8 10	 shr	 eax, 16
  00294	41 c1 e9 18	 shr	 r9d, 24
  00298	44 88 4a 07	 mov	 BYTE PTR [rdx+7], r9b
  0029c	88 4a 05	 mov	 BYTE PTR [rdx+5], cl
  0029f	88 42 06	 mov	 BYTE PTR [rdx+6], al
  002a2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002a6	41 5f		 pop	 r15
  002a8	41 5e		 pop	 r14
  002aa	41 5d		 pop	 r13
  002ac	41 5c		 pop	 r12
  002ae	5f		 pop	 rdi
  002af	5e		 pop	 rsi
  002b0	5d		 pop	 rbp
  002b1	c3		 ret	 0
gost_decrypt ENDP
_TEXT	ENDS
PUBLIC	gost_encrypt
;	COMDAT pdata
pdata	SEGMENT
$pdata$gost_encrypt DD imagerel $LN3
	DD	imagerel $LN3+690
	DD	imagerel $unwind$gost_encrypt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gost_encrypt DD 0a1901H
	DD	0f3419H
	DD	0f0153219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT gost_encrypt
_TEXT	SEGMENT
tv385 = 96
in$ = 96
out$ = 104
tv384 = 112
ks$ = 112
gost_encrypt PROC					; COMDAT

; 94   : {

$LN3:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 95   : 	gst_udword n1, n2;
; 96   : 	gost_s_box *sbox;
; 97   : 	n1 = 0;
; 98   : 	n2 = 0;
; 99   : 
; 100  : 	n1 = (gst_udword)in[3] << 24 | (gst_udword)in[2] << 16 | (gst_udword)in[1] << 8 | (gst_udword)in[0];

  00019	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  0001d	0f b6 59 03	 movzx	 ebx, BYTE PTR [rcx+3]

; 101  : 	n2 = (gst_udword)in[7] << 24 | (gst_udword)in[6] << 16 | (gst_udword)in[5] << 8 | (gst_udword)in[4];
; 102  : #ifdef GOST_DYNAMIC_SBOXES
; 103  : 	sbox = &ks->sbox;
; 104  : #else
; 105  : 	sbox = ks->sbox;
; 106  : #endif
; 107  : 
; 108  : 	//Rounds 1-24
; 109  : 	n2 = r(n1, n2, ks->X0, sbox);

  00021	0f b6 51 07	 movzx	 edx, BYTE PTR [rcx+7]
  00025	c1 e2 08	 shl	 edx, 8
  00028	c1 e3 08	 shl	 ebx, 8
  0002b	49 8b f0	 mov	 rsi, r8
  0002e	0b d8		 or	 ebx, eax
  00030	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00034	4d 8d 48 20	 lea	 r9, QWORD PTR [r8+32]
  00038	45 8b 00	 mov	 r8d, DWORD PTR [r8]
  0003b	c1 e3 08	 shl	 ebx, 8
  0003e	0b d8		 or	 ebx, eax
  00040	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00043	44 89 44 24 60	 mov	 DWORD PTR tv385[rsp], r8d
  00048	c1 e3 08	 shl	 ebx, 8
  0004b	0b d8		 or	 ebx, eax
  0004d	0f b6 41 06	 movzx	 eax, BYTE PTR [rcx+6]
  00051	0b d0		 or	 edx, eax
  00053	0f b6 41 05	 movzx	 eax, BYTE PTR [rcx+5]
  00057	c1 e2 08	 shl	 edx, 8
  0005a	0b d0		 or	 edx, eax
  0005c	0f b6 41 04	 movzx	 eax, BYTE PTR [rcx+4]
  00060	8b cb		 mov	 ecx, ebx
  00062	c1 e2 08	 shl	 edx, 8
  00065	0b d0		 or	 edx, eax
  00067	e8 00 00 00 00	 call	 r

; 110  : 	n1 = r(n2, n1, ks->X1, sbox);

  0006c	8b d3		 mov	 edx, ebx
  0006e	44 8b d8	 mov	 r11d, eax
  00071	8b 46 04	 mov	 eax, DWORD PTR [rsi+4]
  00074	44 8b c0	 mov	 r8d, eax
  00077	41 8b cb	 mov	 ecx, r11d
  0007a	89 44 24 70	 mov	 DWORD PTR tv384[rsp], eax
  0007e	e8 00 00 00 00	 call	 r

; 111  : 	n2 = r(n1, n2, ks->X2, sbox);

  00083	44 8b 7e 08	 mov	 r15d, DWORD PTR [rsi+8]
  00087	41 8b d3	 mov	 edx, r11d
  0008a	45 8b c7	 mov	 r8d, r15d
  0008d	8b c8		 mov	 ecx, eax
  0008f	8b d8		 mov	 ebx, eax
  00091	e8 00 00 00 00	 call	 r

; 112  : 	n1 = r(n2, n1, ks->X3, sbox);

  00096	44 8b 76 0c	 mov	 r14d, DWORD PTR [rsi+12]
  0009a	8b d3		 mov	 edx, ebx
  0009c	45 8b c6	 mov	 r8d, r14d
  0009f	8b c8		 mov	 ecx, eax
  000a1	44 8b d8	 mov	 r11d, eax
  000a4	e8 00 00 00 00	 call	 r

; 113  : 	n2 = r(n1, n2, ks->X4, sbox);

  000a9	44 8b 6e 10	 mov	 r13d, DWORD PTR [rsi+16]
  000ad	41 8b d3	 mov	 edx, r11d
  000b0	45 8b c5	 mov	 r8d, r13d
  000b3	8b c8		 mov	 ecx, eax
  000b5	8b d8		 mov	 ebx, eax
  000b7	e8 00 00 00 00	 call	 r

; 114  : 	n1 = r(n2, n1, ks->X5, sbox);

  000bc	44 8b 66 14	 mov	 r12d, DWORD PTR [rsi+20]
  000c0	8b d3		 mov	 edx, ebx
  000c2	45 8b c4	 mov	 r8d, r12d
  000c5	8b c8		 mov	 ecx, eax
  000c7	44 8b d8	 mov	 r11d, eax
  000ca	e8 00 00 00 00	 call	 r

; 115  : 	n2 = r(n1, n2, ks->X6, sbox);

  000cf	8b 6e 18	 mov	 ebp, DWORD PTR [rsi+24]
  000d2	41 8b d3	 mov	 edx, r11d
  000d5	44 8b c5	 mov	 r8d, ebp
  000d8	8b c8		 mov	 ecx, eax
  000da	8b f8		 mov	 edi, eax
  000dc	e8 00 00 00 00	 call	 r

; 116  : 	n1 = r(n2, n1, ks->X7, sbox);

  000e1	8b 76 1c	 mov	 esi, DWORD PTR [rsi+28]
  000e4	8b d7		 mov	 edx, edi
  000e6	44 8b c6	 mov	 r8d, esi
  000e9	8b c8		 mov	 ecx, eax
  000eb	8b d8		 mov	 ebx, eax
  000ed	e8 00 00 00 00	 call	 r

; 117  : 
; 118  : 	n2 = r(n1, n2, ks->X0, sbox);

  000f2	44 8b 44 24 60	 mov	 r8d, DWORD PTR tv385[rsp]
  000f7	8b d3		 mov	 edx, ebx
  000f9	8b c8		 mov	 ecx, eax
  000fb	44 8b d8	 mov	 r11d, eax
  000fe	e8 00 00 00 00	 call	 r

; 119  : 	n1 = r(n2, n1, ks->X1, sbox);

  00103	8b 7c 24 70	 mov	 edi, DWORD PTR tv384[rsp]
  00107	41 8b d3	 mov	 edx, r11d
  0010a	44 8b c7	 mov	 r8d, edi
  0010d	8b c8		 mov	 ecx, eax
  0010f	8b d8		 mov	 ebx, eax
  00111	e8 00 00 00 00	 call	 r
  00116	44 8b d8	 mov	 r11d, eax

; 120  : 	n2 = r(n1, n2, ks->X2, sbox);

  00119	45 8b c7	 mov	 r8d, r15d
  0011c	8b d3		 mov	 edx, ebx
  0011e	8b c8		 mov	 ecx, eax
  00120	e8 00 00 00 00	 call	 r

; 121  : 	n1 = r(n2, n1, ks->X3, sbox);

  00125	45 8b c6	 mov	 r8d, r14d
  00128	41 8b d3	 mov	 edx, r11d
  0012b	8b c8		 mov	 ecx, eax
  0012d	8b d8		 mov	 ebx, eax
  0012f	e8 00 00 00 00	 call	 r

; 122  : 	n2 = r(n1, n2, ks->X4, sbox);

  00134	45 8b c5	 mov	 r8d, r13d
  00137	8b d3		 mov	 edx, ebx
  00139	8b c8		 mov	 ecx, eax
  0013b	44 8b d8	 mov	 r11d, eax
  0013e	e8 00 00 00 00	 call	 r

; 123  : 	n1 = r(n2, n1, ks->X5, sbox);

  00143	45 8b c4	 mov	 r8d, r12d
  00146	41 8b d3	 mov	 edx, r11d
  00149	8b c8		 mov	 ecx, eax
  0014b	8b d8		 mov	 ebx, eax
  0014d	e8 00 00 00 00	 call	 r

; 124  : 	n2 = r(n1, n2, ks->X6, sbox);

  00152	44 8b c5	 mov	 r8d, ebp
  00155	8b d3		 mov	 edx, ebx
  00157	8b c8		 mov	 ecx, eax
  00159	44 8b d8	 mov	 r11d, eax
  0015c	e8 00 00 00 00	 call	 r

; 125  : 	n1 = r(n2, n1, ks->X7, sbox);

  00161	44 8b c6	 mov	 r8d, esi
  00164	41 8b d3	 mov	 edx, r11d
  00167	8b c8		 mov	 ecx, eax
  00169	8b d8		 mov	 ebx, eax
  0016b	e8 00 00 00 00	 call	 r

; 126  : 
; 127  : 	n2 = r(n1, n2, ks->X0, sbox);

  00170	44 8b 44 24 60	 mov	 r8d, DWORD PTR tv385[rsp]
  00175	8b d3		 mov	 edx, ebx
  00177	8b c8		 mov	 ecx, eax
  00179	44 8b d8	 mov	 r11d, eax
  0017c	e8 00 00 00 00	 call	 r

; 128  : 	n1 = r(n2, n1, ks->X1, sbox);

  00181	44 8b c7	 mov	 r8d, edi
  00184	41 8b d3	 mov	 edx, r11d
  00187	8b c8		 mov	 ecx, eax
  00189	8b d8		 mov	 ebx, eax
  0018b	e8 00 00 00 00	 call	 r

; 129  : 	n2 = r(n1, n2, ks->X2, sbox);

  00190	45 8b c7	 mov	 r8d, r15d
  00193	8b d3		 mov	 edx, ebx
  00195	8b c8		 mov	 ecx, eax
  00197	44 8b d8	 mov	 r11d, eax
  0019a	e8 00 00 00 00	 call	 r

; 130  : 	n1 = r(n2, n1, ks->X3, sbox);

  0019f	45 8b c6	 mov	 r8d, r14d
  001a2	41 8b d3	 mov	 edx, r11d
  001a5	8b c8		 mov	 ecx, eax
  001a7	8b d8		 mov	 ebx, eax
  001a9	e8 00 00 00 00	 call	 r

; 131  : 	n2 = r(n1, n2, ks->X4, sbox);

  001ae	45 8b c5	 mov	 r8d, r13d
  001b1	8b d3		 mov	 edx, ebx
  001b3	8b c8		 mov	 ecx, eax
  001b5	44 8b d8	 mov	 r11d, eax
  001b8	e8 00 00 00 00	 call	 r

; 132  : 	n1 = r(n2, n1, ks->X5, sbox);

  001bd	45 8b c4	 mov	 r8d, r12d
  001c0	41 8b d3	 mov	 edx, r11d
  001c3	8b c8		 mov	 ecx, eax
  001c5	8b d8		 mov	 ebx, eax
  001c7	e8 00 00 00 00	 call	 r

; 133  : 	n2 = r(n1, n2, ks->X6, sbox);

  001cc	44 8b c5	 mov	 r8d, ebp
  001cf	8b d3		 mov	 edx, ebx
  001d1	8b c8		 mov	 ecx, eax
  001d3	44 8b d8	 mov	 r11d, eax
  001d6	e8 00 00 00 00	 call	 r

; 134  : 	n1 = r(n2, n1, ks->X7, sbox);

  001db	44 8b c6	 mov	 r8d, esi
  001de	41 8b d3	 mov	 edx, r11d
  001e1	8b c8		 mov	 ecx, eax
  001e3	8b d8		 mov	 ebx, eax
  001e5	e8 00 00 00 00	 call	 r

; 135  : 
; 136  : 	//Rounds 25-32
; 137  : 	n2 = r(n1, n2, ks->X7, sbox);

  001ea	44 8b c6	 mov	 r8d, esi
  001ed	8b d3		 mov	 edx, ebx
  001ef	8b c8		 mov	 ecx, eax
  001f1	44 8b d8	 mov	 r11d, eax
  001f4	e8 00 00 00 00	 call	 r

; 138  : 	n1 = r(n2, n1, ks->X6, sbox);

  001f9	44 8b c5	 mov	 r8d, ebp
  001fc	41 8b d3	 mov	 edx, r11d
  001ff	8b c8		 mov	 ecx, eax
  00201	8b d8		 mov	 ebx, eax
  00203	e8 00 00 00 00	 call	 r

; 139  : 	n2 = r(n1, n2, ks->X5, sbox);

  00208	45 8b c4	 mov	 r8d, r12d
  0020b	44 8b d8	 mov	 r11d, eax
  0020e	8b d3		 mov	 edx, ebx
  00210	8b c8		 mov	 ecx, eax
  00212	e8 00 00 00 00	 call	 r

; 140  : 	n1 = r(n2, n1, ks->X4, sbox);

  00217	45 8b c5	 mov	 r8d, r13d
  0021a	41 8b d3	 mov	 edx, r11d
  0021d	8b c8		 mov	 ecx, eax
  0021f	8b d8		 mov	 ebx, eax
  00221	e8 00 00 00 00	 call	 r

; 141  : 	n2 = r(n1, n2, ks->X3, sbox);

  00226	45 8b c6	 mov	 r8d, r14d
  00229	8b d3		 mov	 edx, ebx
  0022b	8b c8		 mov	 ecx, eax
  0022d	44 8b d8	 mov	 r11d, eax
  00230	e8 00 00 00 00	 call	 r

; 142  : 	n1 = r(n2, n1, ks->X2, sbox);

  00235	45 8b c7	 mov	 r8d, r15d
  00238	41 8b d3	 mov	 edx, r11d
  0023b	8b c8		 mov	 ecx, eax
  0023d	8b d8		 mov	 ebx, eax
  0023f	e8 00 00 00 00	 call	 r

; 143  : 	n2 = r(n1, n2, ks->X1, sbox);

  00244	44 8b c7	 mov	 r8d, edi
  00247	8b d3		 mov	 edx, ebx
  00249	8b c8		 mov	 ecx, eax
  0024b	44 8b d8	 mov	 r11d, eax
  0024e	e8 00 00 00 00	 call	 r

; 144  : 	n1 = r(n2, n1, ks->X0, sbox);

  00253	44 8b 44 24 60	 mov	 r8d, DWORD PTR tv385[rsp]
  00258	41 8b d3	 mov	 edx, r11d
  0025b	8b c8		 mov	 ecx, eax
  0025d	8b d8		 mov	 ebx, eax
  0025f	e8 00 00 00 00	 call	 r

; 145  : 
; 146  : 	out[0] = (byte)(n2 & 0xFF); out[1] = (byte)((n2 >> 8) & 0xFF); out[2] = (byte)((n2 >> 16) & 0xFF); out[3] = (byte)((n2 >> 24) & 0xFF);

  00264	48 8b 54 24 68	 mov	 rdx, QWORD PTR out$[rsp]
  00269	8b cb		 mov	 ecx, ebx
  0026b	c1 e9 08	 shr	 ecx, 8
  0026e	44 8b c8	 mov	 r9d, eax
  00271	88 1a		 mov	 BYTE PTR [rdx], bl
  00273	88 4a 01	 mov	 BYTE PTR [rdx+1], cl
  00276	8b cb		 mov	 ecx, ebx
  00278	c1 eb 18	 shr	 ebx, 24
  0027b	c1 e9 10	 shr	 ecx, 16

; 147  : 	out[4] = (byte)(n1 & 0xFF); out[5] = (byte)((n1 >> 8) & 0xFF); out[6] = (byte)((n1 >> 16) & 0xFF); out[7] = (byte)((n1 >> 24) & 0xFF);

  0027e	88 42 04	 mov	 BYTE PTR [rdx+4], al
  00281	88 5a 03	 mov	 BYTE PTR [rdx+3], bl

; 148  : }

  00284	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  00289	88 4a 02	 mov	 BYTE PTR [rdx+2], cl
  0028c	8b c8		 mov	 ecx, eax
  0028e	c1 e9 08	 shr	 ecx, 8
  00291	c1 e8 10	 shr	 eax, 16
  00294	41 c1 e9 18	 shr	 r9d, 24
  00298	44 88 4a 07	 mov	 BYTE PTR [rdx+7], r9b
  0029c	88 4a 05	 mov	 BYTE PTR [rdx+5], cl
  0029f	88 42 06	 mov	 BYTE PTR [rdx+6], al
  002a2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002a6	41 5f		 pop	 r15
  002a8	41 5e		 pop	 r14
  002aa	41 5d		 pop	 r13
  002ac	41 5c		 pop	 r12
  002ae	5f		 pop	 rdi
  002af	5e		 pop	 rsi
  002b0	5d		 pop	 rbp
  002b1	c3		 ret	 0
gost_encrypt ENDP
PUBLIC	__$ArrayPad$
PUBLIC	gost_set_key
;	COMDAT pdata
pdata	SEGMENT
$pdata$gost_set_key DD imagerel $LN29
	DD	imagerel $LN29+469
	DD	imagerel $unwind$gost_set_key
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gost_set_key DD 072419H
	DD	0456412H
	DD	0443412H
	DD	0400112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	01f0H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT gost_set_key
_TEXT	SEGMENT
sctx$ = 32
sbox_seed$ = 432
__$ArrayPad$ = 496
key$ = 528
ks$ = 536
gost_set_key PROC					; COMDAT

; 227  : {

$LN29:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 00 02
	00 00		 sub	 rsp, 512		; 00000200H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 228  :     gst_udword i;
; 229  : 
; 230  : #ifdef GOST_DYNAMIC_SBOXES
; 231  : 	STRIBOG_CTX sctx;
; 232  : 	byte sbox_seed[64];
; 233  : 
; 234  : 	ks->sbox = GostR3411_94_CryptoProParamSet;

  00024	48 8d 5a 20	 lea	 rbx, QWORD PTR [rdx+32]
  00028	48 8b fa	 mov	 rdi, rdx
  0002b	48 8b f1	 mov	 rsi, rcx
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:GostR3411_94_CryptoProParamSet
  00035	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	e8 00 00 00 00	 call	 memcpy

; 235  : 
; 236  : 	//Generate pseudorandom data based on the key
; 237  : 	STRIBOG_init(&sctx);

  00043	48 8d 4c 24 20	 lea	 rcx, QWORD PTR sctx$[rsp]
  00048	33 d2		 xor	 edx, edx
  0004a	41 b8 81 01 00
	00		 mov	 r8d, 385		; 00000181H
  00050	e8 00 00 00 00	 call	 memset

; 238  : 	STRIBOG_add(&sctx, key, 32);

  00055	48 8d 4c 24 20	 lea	 rcx, QWORD PTR sctx$[rsp]
  0005a	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00060	48 8b d6	 mov	 rdx, rsi
  00063	c6 84 24 1f 01
	00 00 02	 mov	 BYTE PTR sctx$[rsp+255], 2
  0006b	e8 00 00 00 00	 call	 STRIBOG_add

; 239  : 	STRIBOG_finalize(&sctx, sbox_seed);

  00070	48 8d 94 24 b0
	01 00 00	 lea	 rdx, QWORD PTR sbox_seed$[rsp]
  00078	48 8d 4c 24 20	 lea	 rcx, QWORD PTR sctx$[rsp]
  0007d	e8 00 00 00 00	 call	 STRIBOG_finalize

; 240  : 
; 241  : 	xor_s_box(&ks->sbox, sbox_seed);

  00082	33 d2		 xor	 edx, edx
  00084	48 81 c3 80 01
	00 00		 add	 rbx, 384		; 00000180H
  0008b	44 8d 42 10	 lea	 r8d, QWORD PTR [rdx+16]
  0008f	4c 8b ca	 mov	 r9, rdx
$LL18@gost_set_k:
  00092	42 0f b6 8c 8c
	b0 01 00 00	 movzx	 ecx, BYTE PTR sbox_seed$[rsp+r9*4]
  0009b	49 ff c1	 inc	 r9
  0009e	8b c1		 mov	 eax, ecx
  000a0	c1 e9 04	 shr	 ecx, 4
  000a3	31 0b		 xor	 DWORD PTR [rbx], ecx
  000a5	42 0f b6 8c 8c
	ad 01 00 00	 movzx	 ecx, BYTE PTR sbox_seed$[rsp+r9*4-3]
  000ae	83 e0 0f	 and	 eax, 15
  000b1	31 43 40	 xor	 DWORD PTR [rbx+64], eax
  000b4	8b c1		 mov	 eax, ecx
  000b6	c1 e9 04	 shr	 ecx, 4
  000b9	31 4b 80	 xor	 DWORD PTR [rbx-128], ecx
  000bc	42 0f b6 8c 8c
	ae 01 00 00	 movzx	 ecx, BYTE PTR sbox_seed$[rsp+r9*4-2]
  000c5	83 e0 0f	 and	 eax, 15
  000c8	31 43 c0	 xor	 DWORD PTR [rbx-64], eax
  000cb	8b c1		 mov	 eax, ecx
  000cd	c1 e9 04	 shr	 ecx, 4
  000d0	31 8b 00 ff ff
	ff		 xor	 DWORD PTR [rbx-256], ecx
  000d6	42 0f b6 8c 8c
	af 01 00 00	 movzx	 ecx, BYTE PTR sbox_seed$[rsp+r9*4-1]
  000df	83 e0 0f	 and	 eax, 15
  000e2	31 83 40 ff ff
	ff		 xor	 DWORD PTR [rbx-192], eax
  000e8	8b c1		 mov	 eax, ecx
  000ea	c1 e9 04	 shr	 ecx, 4
  000ed	31 8b 80 fe ff
	ff		 xor	 DWORD PTR [rbx-384], ecx
  000f3	83 e0 0f	 and	 eax, 15
  000f6	48 83 c3 04	 add	 rbx, 4
  000fa	31 83 bc fe ff
	ff		 xor	 DWORD PTR [rbx-324], eax
  00100	4d 3b c8	 cmp	 r9, r8
  00103	7c 8d		 jl	 SHORT $LL18@gost_set_k

; 242  : 
; 243  : 	/* In order to avoid 7 bitshift operations on each pass through the S-Box,
; 244  : 	* this step is pre-processed once during the set_key phase. If memory contraints
; 245  : 	* become a problem, this step can be skipped and the sbox struct can change its
; 246  : 	* unsigned int arrays to unsigned char arrays, going from 512 unsigned chars to 128.
; 247  : 	*/
; 248  : 	for (i = 0; i < GOST_SBOX_SIZE; i++)

  00105	48 8d 47 60	 lea	 rax, QWORD PTR [rdi+96]
$LL6@gost_set_k:

; 249  : 	{
; 250  : 		ks->sbox.k8[i] <<= 28;

  00109	c1 60 c0 1c	 shl	 DWORD PTR [rax-64], 28

; 251  : 		ks->sbox.k7[i] <<= 24;

  0010d	c1 20 18	 shl	 DWORD PTR [rax], 24

; 252  : 		ks->sbox.k6[i] <<= 20;

  00110	c1 60 40 14	 shl	 DWORD PTR [rax+64], 20

; 253  : 		ks->sbox.k5[i] <<= 16;

  00114	c1 a0 80 00 00
	00 10		 shl	 DWORD PTR [rax+128], 16

; 254  : 		ks->sbox.k4[i] <<= 12;

  0011b	c1 a0 c0 00 00
	00 0c		 shl	 DWORD PTR [rax+192], 12

; 255  : 		ks->sbox.k3[i] <<= 8;

  00122	c1 a0 00 01 00
	00 08		 shl	 DWORD PTR [rax+256], 8

; 256  : 		ks->sbox.k2[i] <<= 4;

  00129	c1 a0 40 01 00
	00 04		 shl	 DWORD PTR [rax+320], 4
  00130	48 83 c0 04	 add	 rax, 4
  00134	49 83 e8 01	 sub	 r8, 1
  00138	75 cf		 jne	 SHORT $LL6@gost_set_k

; 257  : 	}
; 258  : #else
; 259  : 	ks->sbox = &GostR3411_94_CryptoProParamSet;
; 260  : #endif
; 261  : 
; 262  : 	ks->X0 = 0;

  0013a	89 17		 mov	 DWORD PTR [rdi], edx

; 263  : 	ks->X1 = 0;

  0013c	89 57 04	 mov	 DWORD PTR [rdi+4], edx

; 264  : 	ks->X2 = 0;

  0013f	89 57 08	 mov	 DWORD PTR [rdi+8], edx

; 265  : 	ks->X3 = 0;

  00142	89 57 0c	 mov	 DWORD PTR [rdi+12], edx

; 266  : 	ks->X4 = 0;

  00145	89 57 10	 mov	 DWORD PTR [rdi+16], edx

; 267  : 	ks->X5 = 0;

  00148	89 57 14	 mov	 DWORD PTR [rdi+20], edx

; 268  : 	ks->X6 = 0;

  0014b	89 57 18	 mov	 DWORD PTR [rdi+24], edx

; 269  : 	ks->X7 = 0;

  0014e	89 57 1c	 mov	 DWORD PTR [rdi+28], edx
  00151	4c 8d 46 04	 lea	 r8, QWORD PTR [rsi+4]
$LL3@gost_set_k:

; 270  : 
; 271  : 	//Set the key
; 272  : 	for (i = 0; i < GOST_KEYSIZE / 8; i++)
; 273  : 	{
; 274  : 		ks->X0 |= (gst_udword)key[i + 0] << (i * 8);

  00155	41 0f b6 40 fc	 movzx	 eax, BYTE PTR [r8-4]
  0015a	8b ca		 mov	 ecx, edx
  0015c	83 c2 08	 add	 edx, 8
  0015f	d3 e0		 shl	 eax, cl
  00161	09 07		 or	 DWORD PTR [rdi], eax

; 275  : 		ks->X1 |= (gst_udword)key[i + 4] << (i * 8);

  00163	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00167	49 ff c0	 inc	 r8
  0016a	d3 e0		 shl	 eax, cl
  0016c	09 47 04	 or	 DWORD PTR [rdi+4], eax

; 276  : 		ks->X2 |= (gst_udword)key[i + 8] << (i * 8);

  0016f	41 0f b6 40 03	 movzx	 eax, BYTE PTR [r8+3]
  00174	d3 e0		 shl	 eax, cl
  00176	09 47 08	 or	 DWORD PTR [rdi+8], eax

; 277  : 		ks->X3 |= (gst_udword)key[i + 12] << (i * 8);

  00179	41 0f b6 40 07	 movzx	 eax, BYTE PTR [r8+7]
  0017e	d3 e0		 shl	 eax, cl
  00180	09 47 0c	 or	 DWORD PTR [rdi+12], eax

; 278  : 		ks->X4 |= (gst_udword)key[i + 16] << (i * 8);

  00183	41 0f b6 40 0b	 movzx	 eax, BYTE PTR [r8+11]
  00188	d3 e0		 shl	 eax, cl
  0018a	09 47 10	 or	 DWORD PTR [rdi+16], eax

; 279  : 		ks->X5 |= (gst_udword)key[i + 20] << (i * 8);

  0018d	41 0f b6 40 0f	 movzx	 eax, BYTE PTR [r8+15]
  00192	d3 e0		 shl	 eax, cl
  00194	09 47 14	 or	 DWORD PTR [rdi+20], eax

; 280  : 		ks->X6 |= (gst_udword)key[i + 24] << (i * 8);

  00197	41 0f b6 40 13	 movzx	 eax, BYTE PTR [r8+19]
  0019c	d3 e0		 shl	 eax, cl
  0019e	09 47 18	 or	 DWORD PTR [rdi+24], eax

; 281  : 		ks->X7 |= (gst_udword)key[i + 28] << (i * 8);

  001a1	41 0f b6 40 17	 movzx	 eax, BYTE PTR [r8+23]
  001a6	d3 e0		 shl	 eax, cl
  001a8	09 47 1c	 or	 DWORD PTR [rdi+28], eax
  001ab	83 fa 20	 cmp	 edx, 32			; 00000020H
  001ae	72 a5		 jb	 SHORT $LL3@gost_set_k

; 282  : 	}
; 283  : }

  001b0	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001b8	48 33 cc	 xor	 rcx, rsp
  001bb	e8 00 00 00 00	 call	 __security_check_cookie
  001c0	4c 8d 9c 24 00
	02 00 00	 lea	 r11, QWORD PTR [rsp+512]
  001c8	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  001cc	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  001d0	49 8b e3	 mov	 rsp, r11
  001d3	5f		 pop	 rdi
  001d4	c3		 ret	 0
gost_set_key ENDP
END
