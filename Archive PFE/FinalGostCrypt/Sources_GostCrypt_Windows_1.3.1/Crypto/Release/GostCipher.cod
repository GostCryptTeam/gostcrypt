; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Crypto\GostCipher.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_gost_encrypt
PUBLIC	_gost_decrypt
PUBLIC	_gost_set_key
PUBLIC	_gost_xor_ks
EXTRN	_STRIBOG_init:PROC
EXTRN	_STRIBOG_add:PROC
EXTRN	_STRIBOG_finalize:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
_GostR3411_94_CryptoProParamSet DD 01H
	DD	03H
	DD	0aH
	DD	09H
	DD	05H
	DD	0bH
	DD	04H
	DD	0fH
	DD	08H
	DD	06H
	DD	07H
	DD	0eH
	DD	0dH
	DD	00H
	DD	02H
	DD	0cH
	DD	0dH
	DD	0eH
	DD	04H
	DD	01H
	DD	07H
	DD	00H
	DD	05H
	DD	0aH
	DD	03H
	DD	0cH
	DD	08H
	DD	0fH
	DD	06H
	DD	02H
	DD	09H
	DD	0bH
	DD	07H
	DD	06H
	DD	02H
	DD	04H
	DD	0dH
	DD	09H
	DD	0fH
	DD	00H
	DD	0aH
	DD	01H
	DD	05H
	DD	0bH
	DD	08H
	DD	0eH
	DD	0cH
	DD	03H
	DD	07H
	DD	06H
	DD	04H
	DD	0bH
	DD	09H
	DD	0cH
	DD	02H
	DD	0aH
	DD	01H
	DD	08H
	DD	00H
	DD	0eH
	DD	0fH
	DD	0dH
	DD	03H
	DD	05H
	DD	04H
	DD	0aH
	DD	07H
	DD	0cH
	DD	00H
	DD	0fH
	DD	02H
	DD	08H
	DD	0eH
	DD	01H
	DD	06H
	DD	05H
	DD	0dH
	DD	0bH
	DD	09H
	DD	03H
	DD	07H
	DD	0fH
	DD	0cH
	DD	0eH
	DD	09H
	DD	04H
	DD	01H
	DD	00H
	DD	03H
	DD	0bH
	DD	05H
	DD	02H
	DD	06H
	DD	0aH
	DD	08H
	DD	0dH
	DD	05H
	DD	0fH
	DD	04H
	DD	00H
	DD	02H
	DD	0dH
	DD	0bH
	DD	09H
	DD	01H
	DD	07H
	DD	06H
	DD	03H
	DD	0cH
	DD	0eH
	DD	0aH
	DD	08H
	DD	0aH
	DD	04H
	DD	05H
	DD	06H
	DD	08H
	DD	01H
	DD	03H
	DD	07H
	DD	0dH
	DD	0cH
	DD	0eH
	DD	00H
	DD	09H
	DD	02H
	DD	0bH
	DD	0fH
_DATA	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\crypto\gostcipher.c
;	COMDAT _r
_TEXT	SEGMENT
_n1$ = 8						; size = 4
_n2$ = 12						; size = 4
_X$ = 16						; size = 4
_sbox$ = 20						; size = 4
_r	PROC						; COMDAT

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 75   : 	n1 += X;
; 76   : #ifdef GOST_DYNAMIC_SBOXES
; 77   : 	n1 =  sbox->k8[(n1>>28)&0xF] | sbox->k7[(n1>>24)&0xF]

  00003	8b 55 14	 mov	 edx, DWORD PTR _sbox$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR _n1$[ebp]
  0000b	03 7d 10	 add	 edi, DWORD PTR _X$[ebp]

; 78   : 				| sbox->k6[(n1>>20)&0xF] | sbox->k5[(n1>>16)&0xF]
; 79   : 				| sbox->k4[(n1>>12)&0xF] | sbox->k3[(n1>>8)&0xF]
; 80   : 				| sbox->k2[(n1>>4)&0xF] | sbox->k1[n1&0xF];
; 81   : #else
; 82   : 	n1 =  (gst_udword)sbox->k8[(n1>>28)&0xF]<<28 | (gst_udword)sbox->k7[(n1>>24)&0xF]<<24
; 83   : 				| (gst_udword)sbox->k6[(n1>>20)&0xF]<<20 | (gst_udword)sbox->k5[(n1>>16)&0xF]<<16
; 84   : 				| (gst_udword)sbox->k4[(n1>>12)&0xF]<<12 | (gst_udword)sbox->k3[(n1>>8)&0xF]<<8
; 85   : 				| (gst_udword)sbox->k2[(n1>>4)&0xF]<<4 | (gst_udword)sbox->k1[n1&0xF];
; 86   : #endif
; 87   : 	n1 = rotl32(n1, 11);
; 88   : 	n2 ^= n1;
; 89   : 	return n2;

  0000e	8b cf		 mov	 ecx, edi
  00010	8b c7		 mov	 eax, edi
  00012	c1 e8 08	 shr	 eax, 8
  00015	83 e0 0f	 and	 eax, 15			; 0000000fH
  00018	c1 e9 04	 shr	 ecx, 4
  0001b	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0001e	8b b4 8a 80 01
	00 00		 mov	 esi, DWORD PTR [edx+ecx*4+384]
  00025	8b cf		 mov	 ecx, edi
  00027	0b b4 82 40 01
	00 00		 or	 esi, DWORD PTR [edx+eax*4+320]
  0002e	8b c7		 mov	 eax, edi
  00030	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  00033	83 e0 0f	 and	 eax, 15			; 0000000fH
  00036	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00039	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0003c	0b b4 82 00 01
	00 00		 or	 esi, DWORD PTR [edx+eax*4+256]
  00043	8b c7		 mov	 eax, edi
  00045	c1 e8 10	 shr	 eax, 16			; 00000010H
  00048	83 e0 0f	 and	 eax, 15			; 0000000fH
  0004b	0b b4 82 c0 00
	00 00		 or	 esi, DWORD PTR [edx+eax*4+192]
  00052	8b c7		 mov	 eax, edi
  00054	c1 e8 14	 shr	 eax, 20			; 00000014H
  00057	83 e0 0f	 and	 eax, 15			; 0000000fH
  0005a	0b b4 82 80 00
	00 00		 or	 esi, DWORD PTR [edx+eax*4+128]
  00061	0b 74 8a 40	 or	 esi, DWORD PTR [edx+ecx*4+64]
  00065	8b cf		 mov	 ecx, edi
  00067	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0006a	c1 ef 1c	 shr	 edi, 28			; 0000001cH
  0006d	0b b4 8a c0 01
	00 00		 or	 esi, DWORD PTR [edx+ecx*4+448]
  00074	0b 34 ba	 or	 esi, DWORD PTR [edx+edi*4]
  00077	c1 c6 0b	 rol	 esi, 11			; 0000000bH
  0007a	33 75 0c	 xor	 esi, DWORD PTR _n2$[ebp]
  0007d	5f		 pop	 edi
  0007e	8b c6		 mov	 eax, esi
  00080	5e		 pop	 esi

; 90   : }

  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
_r	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\crypto\gostcipher.c
;	COMDAT _xor_s_box
_TEXT	SEGMENT
_s_box$ = 8						; size = 4
_seed$ = 12						; size = 4
_xor_s_box PROC						; COMDAT

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   :    int i;
; 48   :    for (i = 0; i < 16; i++)

  00003	8b 55 0c	 mov	 edx, DWORD PTR _seed$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _s_box$[ebp]
  00009	83 c2 02	 add	 edx, 2
  0000c	56		 push	 esi
  0000d	05 80 01 00 00	 add	 eax, 384		; 00000180H
  00012	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  00017	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@xor_s_box:

; 49   :    {
; 50   :       s_box->k1[i] ^= (seed[ (i * 4) + 0 ]   ) & 0xF;

  00020	0f b6 4a fe	 movzx	 ecx, BYTE PTR [edx-2]
  00024	8d 40 04	 lea	 eax, DWORD PTR [eax+4]
  00027	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0002a	8d 52 04	 lea	 edx, DWORD PTR [edx+4]
  0002d	31 48 3c	 xor	 DWORD PTR [eax+60], ecx

; 51   :       s_box->k2[i] ^= (seed[ (i * 4) + 0 ]>>4) & 0xF;

  00030	0f b6 4a fa	 movzx	 ecx, BYTE PTR [edx-6]
  00034	c1 e9 04	 shr	 ecx, 4
  00037	31 48 fc	 xor	 DWORD PTR [eax-4], ecx

; 52   :       s_box->k3[i] ^= (seed[ (i * 4) + 1 ]   ) & 0xF;

  0003a	0f b6 4a fb	 movzx	 ecx, BYTE PTR [edx-5]
  0003e	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00041	31 48 bc	 xor	 DWORD PTR [eax-68], ecx

; 53   :       s_box->k4[i] ^= (seed[ (i * 4) + 1 ]>>4) & 0xF;

  00044	0f b6 4a fb	 movzx	 ecx, BYTE PTR [edx-5]
  00048	c1 e9 04	 shr	 ecx, 4
  0004b	31 88 7c ff ff
	ff		 xor	 DWORD PTR [eax-132], ecx

; 54   :       s_box->k5[i] ^= (seed[ (i * 4) + 2 ]   ) & 0xF;

  00051	0f b6 4a fc	 movzx	 ecx, BYTE PTR [edx-4]
  00055	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00058	31 88 3c ff ff
	ff		 xor	 DWORD PTR [eax-196], ecx

; 55   :       s_box->k6[i] ^= (seed[ (i * 4) + 2 ]>>4) & 0xF;

  0005e	0f b6 4a fc	 movzx	 ecx, BYTE PTR [edx-4]
  00062	c1 e9 04	 shr	 ecx, 4
  00065	31 88 fc fe ff
	ff		 xor	 DWORD PTR [eax-260], ecx

; 56   :       s_box->k7[i] ^= (seed[ (i * 4) + 3 ]   ) & 0xF;

  0006b	0f b6 4a fd	 movzx	 ecx, BYTE PTR [edx-3]
  0006f	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00072	31 88 bc fe ff
	ff		 xor	 DWORD PTR [eax-324], ecx

; 57   :       s_box->k8[i] ^= (seed[ (i * 4) + 3 ]>>4) & 0xF;

  00078	0f b6 4a fd	 movzx	 ecx, BYTE PTR [edx-3]
  0007c	c1 e9 04	 shr	 ecx, 4
  0007f	31 88 7c fe ff
	ff		 xor	 DWORD PTR [eax-388], ecx
  00085	83 ee 01	 sub	 esi, 1
  00088	75 96		 jne	 SHORT $LL4@xor_s_box
  0008a	5e		 pop	 esi

; 58   :    }
; 59   : }

  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_xor_s_box ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\crypto\gostcipher.c
;	COMDAT _gost_xor_ks
_TEXT	SEGMENT
_ks$ = 8						; size = 4
_out_ks$ = 12						; size = 4
_in$ = 16						; size = 4
_len$ = 20						; size = 4
_gost_xor_ks PROC					; COMDAT

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 308  : 	gst_dword i;
; 309  : 	if (!len)

  00004	8b 75 14	 mov	 esi, DWORD PTR _len$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	0f 84 86 00 00
	00		 je	 $LN3@gost_xor_k

; 310  : 		return;
; 311  : 
; 312  : 	out_ks->X0 = ks->X0 ^ in[0];

  0000f	8b 55 08	 mov	 edx, DWORD PTR _ks$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR _out_ks$[ebp]
  00015	57		 push	 edi
  00016	8b 7d 10	 mov	 edi, DWORD PTR _in$[ebp]
  00019	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0001b	33 0f		 xor	 ecx, DWORD PTR [edi]
  0001d	89 08		 mov	 DWORD PTR [eax], ecx
  0001f	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00022	33 0f		 xor	 ecx, DWORD PTR [edi]
  00024	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00027	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0002a	33 0f		 xor	 ecx, DWORD PTR [edi]
  0002c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0002f	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00032	33 0f		 xor	 ecx, DWORD PTR [edi]
  00034	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00037	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  0003a	33 0f		 xor	 ecx, DWORD PTR [edi]
  0003c	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0003f	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00042	33 0f		 xor	 ecx, DWORD PTR [edi]
  00044	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00047	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  0004a	33 0f		 xor	 ecx, DWORD PTR [edi]
  0004c	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  0004f	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]

; 313  : 	out_ks->X1 = ks->X1 ^ in[0];
; 314  : 	out_ks->X2 = ks->X2 ^ in[0];
; 315  : 	out_ks->X3 = ks->X3 ^ in[0];
; 316  : 	out_ks->X4 = ks->X4 ^ in[0];
; 317  : 	out_ks->X5 = ks->X5 ^ in[0];
; 318  : 	out_ks->X6 = ks->X6 ^ in[0];
; 319  : 	out_ks->X7 = ks->X7 ^ in[0];
; 320  : 
; 321  : 	for (i = 1; i < len; i++)

  00052	ba 01 00 00 00	 mov	 edx, 1
  00057	33 0f		 xor	 ecx, DWORD PTR [edi]
  00059	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  0005c	3b f2		 cmp	 esi, edx
  0005e	7e 34		 jle	 SHORT $LN38@gost_xor_k
$LL4@gost_xor_k:

; 322  : 	{
; 323  : 		out_ks->X0 ^= in[i];

  00060	8b 0c 97	 mov	 ecx, DWORD PTR [edi+edx*4]
  00063	31 08		 xor	 DWORD PTR [eax], ecx
  00065	8b 0c 97	 mov	 ecx, DWORD PTR [edi+edx*4]
  00068	31 48 04	 xor	 DWORD PTR [eax+4], ecx
  0006b	8b 0c 97	 mov	 ecx, DWORD PTR [edi+edx*4]
  0006e	31 48 08	 xor	 DWORD PTR [eax+8], ecx
  00071	8b 0c 97	 mov	 ecx, DWORD PTR [edi+edx*4]
  00074	31 48 0c	 xor	 DWORD PTR [eax+12], ecx
  00077	8b 0c 97	 mov	 ecx, DWORD PTR [edi+edx*4]
  0007a	31 48 10	 xor	 DWORD PTR [eax+16], ecx
  0007d	8b 0c 97	 mov	 ecx, DWORD PTR [edi+edx*4]
  00080	31 48 14	 xor	 DWORD PTR [eax+20], ecx
  00083	8b 0c 97	 mov	 ecx, DWORD PTR [edi+edx*4]
  00086	31 48 18	 xor	 DWORD PTR [eax+24], ecx
  00089	8b 0c 97	 mov	 ecx, DWORD PTR [edi+edx*4]
  0008c	42		 inc	 edx
  0008d	31 48 1c	 xor	 DWORD PTR [eax+28], ecx
  00090	3b d6		 cmp	 edx, esi
  00092	7c cc		 jl	 SHORT $LL4@gost_xor_k
$LN38@gost_xor_k:
  00094	5f		 pop	 edi
$LN3@gost_xor_k:
  00095	5e		 pop	 esi

; 324  : 		out_ks->X1 ^= in[i];
; 325  : 		out_ks->X2 ^= in[i];
; 326  : 		out_ks->X3 ^= in[i];
; 327  : 		out_ks->X4 ^= in[i];
; 328  : 		out_ks->X5 ^= in[i];
; 329  : 		out_ks->X6 ^= in[i];
; 330  : 		out_ks->X7 ^= in[i];
; 331  : 	}
; 332  : }

  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
_gost_xor_ks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\crypto\gostcipher.c
;	COMDAT _gost_set_key
_TEXT	SEGMENT
_ks$GSCopy$1$ = -464					; size = 4
_key$GSCopy$1$ = -460					; size = 4
_sctx$ = -456						; size = 385
_sbox_seed$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_key$ = 8						; size = 4
_ks$ = 12						; size = 4
_gost_set_key PROC					; COMDAT

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 01 00
	00		 sub	 esp, 464		; 000001d0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]

; 238  :     gst_udword i;
; 239  : 
; 240  : #ifdef GOST_DYNAMIC_SBOXES
; 241  : 	STRIBOG_CTX sctx;
; 242  : 	byte sbox_seed[64];
; 243  : 
; 244  : 	ks->sbox = GostR3411_94_CryptoProParamSet;

  00016	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0001b	53		 push	 ebx
  0001c	8b 5d 0c	 mov	 ebx, DWORD PTR _ks$[ebp]
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	89 9d 30 fe ff
	ff		 mov	 DWORD PTR _ks$GSCopy$1$[ebp], ebx
  00027	be 00 00 00 00	 mov	 esi, OFFSET _GostR3411_94_CryptoProParamSet
  0002c	89 85 34 fe ff
	ff		 mov	 DWORD PTR _key$GSCopy$1$[ebp], eax
  00032	83 c3 20	 add	 ebx, 32			; 00000020H

; 245  : 
; 246  : 	//Generate pseudorandom data based on the key
; 247  : 	STRIBOG_init(&sctx);

  00035	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _sctx$[ebp]
  0003b	8b fb		 mov	 edi, ebx
  0003d	f3 a5		 rep movsd
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _STRIBOG_init

; 248  : 	STRIBOG_add(&sctx, key, 32);

  00045	8b bd 34 fe ff
	ff		 mov	 edi, DWORD PTR _key$GSCopy$1$[ebp]
  0004b	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _sctx$[ebp]
  00051	6a 20		 push	 32			; 00000020H
  00053	57		 push	 edi
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _STRIBOG_add

; 249  : 	STRIBOG_finalize(&sctx, sbox_seed);

  0005a	8d 45 bc	 lea	 eax, DWORD PTR _sbox_seed$[ebp]
  0005d	50		 push	 eax
  0005e	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR _sctx$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _STRIBOG_finalize

; 250  : 
; 251  : 	xor_s_box(&ks->sbox, sbox_seed);

  0006a	8d 45 bc	 lea	 eax, DWORD PTR _sbox_seed$[ebp]
  0006d	50		 push	 eax
  0006e	53		 push	 ebx
  0006f	e8 00 00 00 00	 call	 _xor_s_box
  00074	8b 95 30 fe ff
	ff		 mov	 edx, DWORD PTR _ks$GSCopy$1$[ebp]
  0007a	83 c4 20	 add	 esp, 32			; 00000020H
  0007d	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00082	8d 42 60	 lea	 eax, DWORD PTR [edx+96]
$LL4@gost_set_k:

; 252  : 
; 253  : 	/* In order to avoid 7 bitshift operations on each pass through the S-Box,
; 254  : 	* this step is pre-processed once during the set_key phase. If memory contraints
; 255  : 	* become a problem, this step can be skipped and the sbox struct can change its
; 256  : 	* unsigned int arrays to unsigned char arrays, going from 512 unsigned chars to 128.
; 257  : 	*/
; 258  : 	for (i = 0; i < GOST_SBOX_SIZE; i++)
; 259  : 	{
; 260  : 		ks->sbox.k8[i] <<= 28;

  00085	c1 60 c0 1c	 shl	 DWORD PTR [eax-64], 28	; 0000001cH
  00089	8d 40 04	 lea	 eax, DWORD PTR [eax+4]

; 261  : 		ks->sbox.k7[i] <<= 24;

  0008c	c1 60 fc 18	 shl	 DWORD PTR [eax-4], 24	; 00000018H

; 262  : 		ks->sbox.k6[i] <<= 20;

  00090	c1 60 3c 14	 shl	 DWORD PTR [eax+60], 20	; 00000014H

; 263  : 		ks->sbox.k5[i] <<= 16;

  00094	c1 60 7c 10	 shl	 DWORD PTR [eax+124], 16	; 00000010H

; 264  : 		ks->sbox.k4[i] <<= 12;

  00098	c1 a0 bc 00 00
	00 0c		 shl	 DWORD PTR [eax+188], 12	; 0000000cH

; 265  : 		ks->sbox.k3[i] <<= 8;

  0009f	c1 a0 fc 00 00
	00 08		 shl	 DWORD PTR [eax+252], 8

; 266  : 		ks->sbox.k2[i] <<= 4;

  000a6	c1 a0 3c 01 00
	00 04		 shl	 DWORD PTR [eax+316], 4
  000ad	83 e9 01	 sub	 ecx, 1
  000b0	75 d3		 jne	 SHORT $LL4@gost_set_k

; 267  : 	}
; 268  : #else
; 269  : 	ks->sbox = &GostR3411_94_CryptoProParamSet;
; 270  : #endif
; 271  : 
; 272  : 	ks->X0 = 0;

  000b2	89 0a		 mov	 DWORD PTR [edx], ecx

; 273  : 	ks->X1 = 0;
; 274  : 	ks->X2 = 0;
; 275  : 	ks->X3 = 0;
; 276  : 	ks->X4 = 0;
; 277  : 	ks->X5 = 0;
; 278  : 	ks->X6 = 0;
; 279  : 	ks->X7 = 0;
; 280  : 
; 281  : 	//Set the key
; 282  : 	for (i = 0; i < GOST_KEYSIZE / 8; i++)

  000b4	33 f6		 xor	 esi, esi
  000b6	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  000b9	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  000bc	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  000bf	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  000c2	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
  000c5	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  000c8	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx
  000cb	0f 1f 44 00 00	 npad	 5
$LL7@gost_set_k:

; 283  : 	{
; 284  : 		ks->X0 |= (gst_udword)key[i + 0] << (i * 8);

  000d0	0f b6 04 37	 movzx	 eax, BYTE PTR [edi+esi]
  000d4	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  000d7	d3 e0		 shl	 eax, cl
  000d9	09 02		 or	 DWORD PTR [edx], eax
  000db	0f b6 44 37 03	 movzx	 eax, BYTE PTR [edi+esi+3]
  000e0	d3 e0		 shl	 eax, cl
  000e2	09 42 04	 or	 DWORD PTR [edx+4], eax
  000e5	0f b6 44 37 07	 movzx	 eax, BYTE PTR [edi+esi+7]
  000ea	d3 e0		 shl	 eax, cl
  000ec	09 42 08	 or	 DWORD PTR [edx+8], eax
  000ef	0f b6 44 37 0b	 movzx	 eax, BYTE PTR [edi+esi+11]
  000f4	d3 e0		 shl	 eax, cl
  000f6	09 42 0c	 or	 DWORD PTR [edx+12], eax
  000f9	0f b6 44 37 0f	 movzx	 eax, BYTE PTR [edi+esi+15]
  000fe	d3 e0		 shl	 eax, cl
  00100	09 42 10	 or	 DWORD PTR [edx+16], eax
  00103	0f b6 44 37 13	 movzx	 eax, BYTE PTR [edi+esi+19]
  00108	d3 e0		 shl	 eax, cl
  0010a	09 42 14	 or	 DWORD PTR [edx+20], eax
  0010d	0f b6 44 37 17	 movzx	 eax, BYTE PTR [edi+esi+23]
  00112	d3 e0		 shl	 eax, cl
  00114	09 42 18	 or	 DWORD PTR [edx+24], eax
  00117	0f b6 44 37 1b	 movzx	 eax, BYTE PTR [edi+esi+27]
  0011c	d3 e0		 shl	 eax, cl
  0011e	83 c1 08	 add	 ecx, 8
  00121	09 42 1c	 or	 DWORD PTR [edx+28], eax
  00124	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00127	72 a7		 jb	 SHORT $LL7@gost_set_k

; 285  : 		ks->X1 |= (gst_udword)key[i + 4] << (i * 8);
; 286  : 		ks->X2 |= (gst_udword)key[i + 8] << (i * 8);
; 287  : 		ks->X3 |= (gst_udword)key[i + 12] << (i * 8);
; 288  : 		ks->X4 |= (gst_udword)key[i + 16] << (i * 8);
; 289  : 		ks->X5 |= (gst_udword)key[i + 20] << (i * 8);
; 290  : 		ks->X6 |= (gst_udword)key[i + 24] << (i * 8);
; 291  : 		ks->X7 |= (gst_udword)key[i + 28] << (i * 8);
; 292  : 	}
; 293  : }

  00129	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012c	5f		 pop	 edi
  0012d	5e		 pop	 esi
  0012e	33 cd		 xor	 ecx, ebp
  00130	5b		 pop	 ebx
  00131	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c3		 ret	 0
_gost_set_key ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\crypto\gostcipher.c
;	COMDAT _gost_decrypt
_TEXT	SEGMENT
tv490 = -28						; size = 4
tv489 = -24						; size = 4
tv488 = -20						; size = 4
tv330 = -16						; size = 4
tv487 = -12						; size = 4
tv486 = -8						; size = 4
tv485 = -4						; size = 4
_sbox$1$ = 8						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
tv404 = 16						; size = 4
_n1$17$ = 16						; size = 4
_ks$ = 16						; size = 4
_gost_decrypt PROC					; COMDAT

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 171  : 	gst_udword n1, n2;
; 172  : 	gost_s_box *sbox;
; 173  : 	n1 = 0;
; 174  : 	n2 = 0;
; 175  : 
; 176  : 	n1 = (gst_udword)in[3] << 24 | (gst_udword)in[2] << 16 | (gst_udword)in[1] << 8 | (gst_udword)in[0];

  00006	8b 55 08	 mov	 edx, DWORD PTR _in$[ebp]
  00009	53		 push	 ebx

; 177  : 	n2 = (gst_udword)in[7] << 24 | (gst_udword)in[6] << 16 | (gst_udword)in[5] << 8 | (gst_udword)in[4];
; 178  : #ifdef GOST_DYNAMIC_SBOXES
; 179  : 	sbox = &ks->sbox;

  0000a	8b 5d 10	 mov	 ebx, DWORD PTR _ks$[ebp]
  0000d	56		 push	 esi
  0000e	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00012	57		 push	 edi
  00013	0f b6 7a 03	 movzx	 edi, BYTE PTR [edx+3]
  00017	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  0001a	c1 e7 08	 shl	 edi, 8
  0001d	0b f8		 or	 edi, eax
  0001f	89 4d 08	 mov	 DWORD PTR _sbox$1$[ebp], ecx
  00022	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]

; 180  : #else
; 181  : 	sbox = ks->sbox;
; 182  : #endif
; 183  : 
; 184  : 	//Rounds 1-8
; 185  : 	n2 = r(n1, n2, ks->X0, sbox);

  00026	51		 push	 ecx
  00027	0f b6 4a 07	 movzx	 ecx, BYTE PTR [edx+7]
  0002b	c1 e7 08	 shl	 edi, 8
  0002e	0b f8		 or	 edi, eax
  00030	c1 e1 08	 shl	 ecx, 8
  00033	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00036	c1 e7 08	 shl	 edi, 8
  00039	0b f8		 or	 edi, eax
  0003b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0003d	50		 push	 eax
  0003e	89 45 e4	 mov	 DWORD PTR tv490[ebp], eax
  00041	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  00045	0b c8		 or	 ecx, eax
  00047	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  0004b	c1 e1 08	 shl	 ecx, 8
  0004e	0b c8		 or	 ecx, eax
  00050	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00054	c1 e1 08	 shl	 ecx, 8
  00057	0b c8		 or	 ecx, eax
  00059	51		 push	 ecx
  0005a	57		 push	 edi
  0005b	e8 00 00 00 00	 call	 _r

; 186  : 	n1 = r(n2, n1, ks->X1, sbox);

  00060	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  00063	8b f0		 mov	 esi, eax
  00065	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00068	51		 push	 ecx
  00069	50		 push	 eax
  0006a	57		 push	 edi
  0006b	56		 push	 esi
  0006c	89 45 e8	 mov	 DWORD PTR tv489[ebp], eax
  0006f	e8 00 00 00 00	 call	 _r

; 187  : 	n2 = r(n1, n2, ks->X2, sbox);

  00074	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  00077	8b f8		 mov	 edi, eax
  00079	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0007c	51		 push	 ecx
  0007d	50		 push	 eax
  0007e	56		 push	 esi
  0007f	57		 push	 edi
  00080	89 45 ec	 mov	 DWORD PTR tv488[ebp], eax
  00083	e8 00 00 00 00	 call	 _r

; 188  : 	n1 = r(n2, n1, ks->X3, sbox);

  00088	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  0008b	8b f0		 mov	 esi, eax
  0008d	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00090	51		 push	 ecx
  00091	50		 push	 eax
  00092	57		 push	 edi
  00093	56		 push	 esi
  00094	89 45 f0	 mov	 DWORD PTR tv330[ebp], eax
  00097	e8 00 00 00 00	 call	 _r
  0009c	83 c4 40	 add	 esp, 64			; 00000040H

; 189  : 	n2 = r(n1, n2, ks->X4, sbox);

  0009f	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  000a2	8b f8		 mov	 edi, eax
  000a4	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  000a7	89 45 f4	 mov	 DWORD PTR tv487[ebp], eax
  000aa	51		 push	 ecx
  000ab	50		 push	 eax
  000ac	56		 push	 esi
  000ad	57		 push	 edi
  000ae	e8 00 00 00 00	 call	 _r

; 190  : 	n1 = r(n2, n1, ks->X5, sbox);

  000b3	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  000b6	8b f0		 mov	 esi, eax
  000b8	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  000bb	51		 push	 ecx
  000bc	50		 push	 eax
  000bd	57		 push	 edi
  000be	56		 push	 esi
  000bf	89 45 f8	 mov	 DWORD PTR tv486[ebp], eax
  000c2	e8 00 00 00 00	 call	 _r
  000c7	8b d8		 mov	 ebx, eax

; 191  : 	n2 = r(n1, n2, ks->X6, sbox);

  000c9	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  000cc	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  000cf	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  000d2	50		 push	 eax
  000d3	56		 push	 esi
  000d4	53		 push	 ebx
  000d5	89 45 fc	 mov	 DWORD PTR tv485[ebp], eax
  000d8	e8 00 00 00 00	 call	 _r

; 192  : 	n1 = r(n2, n1, ks->X7, sbox);

  000dd	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  000e0	8b f8		 mov	 edi, eax
  000e2	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  000e5	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  000e8	50		 push	 eax
  000e9	53		 push	 ebx
  000ea	57		 push	 edi
  000eb	89 45 10	 mov	 DWORD PTR tv404[ebp], eax
  000ee	e8 00 00 00 00	 call	 _r

; 193  : 
; 194  : 	//Rounds 9-32
; 195  : 	n2 = r(n1, n2, ks->X7, sbox);

  000f3	8b 5d 10	 mov	 ebx, DWORD PTR tv404[ebp]
  000f6	83 c4 40	 add	 esp, 64			; 00000040H
  000f9	8b f0		 mov	 esi, eax
  000fb	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  000fe	53		 push	 ebx
  000ff	57		 push	 edi
  00100	56		 push	 esi
  00101	e8 00 00 00 00	 call	 _r

; 196  : 	n1 = r(n2, n1, ks->X6, sbox);

  00106	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  00109	8b f8		 mov	 edi, eax
  0010b	ff 75 fc	 push	 DWORD PTR tv485[ebp]
  0010e	56		 push	 esi
  0010f	57		 push	 edi
  00110	e8 00 00 00 00	 call	 _r

; 197  : 	n2 = r(n1, n2, ks->X5, sbox);

  00115	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  00118	8b f0		 mov	 esi, eax
  0011a	ff 75 f8	 push	 DWORD PTR tv486[ebp]
  0011d	57		 push	 edi
  0011e	56		 push	 esi
  0011f	e8 00 00 00 00	 call	 _r

; 198  : 	n1 = r(n2, n1, ks->X4, sbox);

  00124	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  00127	8b f8		 mov	 edi, eax
  00129	ff 75 f4	 push	 DWORD PTR tv487[ebp]
  0012c	56		 push	 esi
  0012d	57		 push	 edi
  0012e	e8 00 00 00 00	 call	 _r
  00133	83 c4 40	 add	 esp, 64			; 00000040H
  00136	8b f0		 mov	 esi, eax

; 199  : 	n2 = r(n1, n2, ks->X3, sbox);

  00138	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  0013b	ff 75 f0	 push	 DWORD PTR tv330[ebp]
  0013e	57		 push	 edi
  0013f	56		 push	 esi
  00140	e8 00 00 00 00	 call	 _r

; 200  : 	n1 = r(n2, n1, ks->X2, sbox);

  00145	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  00148	8b f8		 mov	 edi, eax
  0014a	ff 75 ec	 push	 DWORD PTR tv488[ebp]
  0014d	56		 push	 esi
  0014e	57		 push	 edi
  0014f	e8 00 00 00 00	 call	 _r

; 201  : 	n2 = r(n1, n2, ks->X1, sbox);

  00154	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  00157	8b f0		 mov	 esi, eax
  00159	ff 75 e8	 push	 DWORD PTR tv489[ebp]
  0015c	57		 push	 edi
  0015d	56		 push	 esi
  0015e	e8 00 00 00 00	 call	 _r

; 202  : 	n1 = r(n2, n1, ks->X0, sbox);

  00163	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  00166	8b f8		 mov	 edi, eax
  00168	ff 75 e4	 push	 DWORD PTR tv490[ebp]
  0016b	56		 push	 esi
  0016c	57		 push	 edi
  0016d	e8 00 00 00 00	 call	 _r
  00172	83 c4 40	 add	 esp, 64			; 00000040H
  00175	8b f0		 mov	 esi, eax

; 203  : 
; 204  : 	n2 = r(n1, n2, ks->X7, sbox);

  00177	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  0017a	53		 push	 ebx
  0017b	57		 push	 edi
  0017c	56		 push	 esi
  0017d	e8 00 00 00 00	 call	 _r

; 205  : 	n1 = r(n2, n1, ks->X6, sbox);

  00182	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  00185	8b f8		 mov	 edi, eax
  00187	ff 75 fc	 push	 DWORD PTR tv485[ebp]
  0018a	56		 push	 esi
  0018b	57		 push	 edi
  0018c	e8 00 00 00 00	 call	 _r

; 206  : 	n2 = r(n1, n2, ks->X5, sbox);

  00191	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  00194	8b f0		 mov	 esi, eax
  00196	ff 75 f8	 push	 DWORD PTR tv486[ebp]
  00199	57		 push	 edi
  0019a	56		 push	 esi
  0019b	e8 00 00 00 00	 call	 _r

; 207  : 	n1 = r(n2, n1, ks->X4, sbox);

  001a0	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  001a3	8b f8		 mov	 edi, eax
  001a5	ff 75 f4	 push	 DWORD PTR tv487[ebp]
  001a8	56		 push	 esi
  001a9	57		 push	 edi
  001aa	e8 00 00 00 00	 call	 _r
  001af	83 c4 40	 add	 esp, 64			; 00000040H
  001b2	8b f0		 mov	 esi, eax

; 208  : 	n2 = r(n1, n2, ks->X3, sbox);

  001b4	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  001b7	ff 75 f0	 push	 DWORD PTR tv330[ebp]
  001ba	57		 push	 edi
  001bb	56		 push	 esi
  001bc	e8 00 00 00 00	 call	 _r

; 209  : 	n1 = r(n2, n1, ks->X2, sbox);

  001c1	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  001c4	8b f8		 mov	 edi, eax
  001c6	ff 75 ec	 push	 DWORD PTR tv488[ebp]
  001c9	56		 push	 esi
  001ca	57		 push	 edi
  001cb	e8 00 00 00 00	 call	 _r

; 210  : 	n2 = r(n1, n2, ks->X1, sbox);

  001d0	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  001d3	8b f0		 mov	 esi, eax
  001d5	ff 75 e8	 push	 DWORD PTR tv489[ebp]
  001d8	57		 push	 edi
  001d9	56		 push	 esi
  001da	e8 00 00 00 00	 call	 _r

; 211  : 	n1 = r(n2, n1, ks->X0, sbox);

  001df	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  001e2	8b f8		 mov	 edi, eax
  001e4	ff 75 e4	 push	 DWORD PTR tv490[ebp]
  001e7	56		 push	 esi
  001e8	57		 push	 edi
  001e9	e8 00 00 00 00	 call	 _r
  001ee	83 c4 40	 add	 esp, 64			; 00000040H
  001f1	8b f0		 mov	 esi, eax

; 212  : 
; 213  : 	n2 = r(n1, n2, ks->X7, sbox);

  001f3	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  001f6	53		 push	 ebx
  001f7	57		 push	 edi
  001f8	56		 push	 esi
  001f9	e8 00 00 00 00	 call	 _r

; 214  : 	n1 = r(n2, n1, ks->X6, sbox);

  001fe	8b 5d 08	 mov	 ebx, DWORD PTR _sbox$1$[ebp]
  00201	8b f8		 mov	 edi, eax
  00203	53		 push	 ebx
  00204	ff 75 fc	 push	 DWORD PTR tv485[ebp]
  00207	56		 push	 esi
  00208	57		 push	 edi
  00209	e8 00 00 00 00	 call	 _r

; 215  : 	n2 = r(n1, n2, ks->X5, sbox);

  0020e	53		 push	 ebx
  0020f	ff 75 f8	 push	 DWORD PTR tv486[ebp]
  00212	8b f0		 mov	 esi, eax
  00214	57		 push	 edi
  00215	56		 push	 esi
  00216	e8 00 00 00 00	 call	 _r

; 216  : 	n1 = r(n2, n1, ks->X4, sbox);

  0021b	53		 push	 ebx
  0021c	ff 75 f4	 push	 DWORD PTR tv487[ebp]
  0021f	8b f8		 mov	 edi, eax
  00221	56		 push	 esi
  00222	57		 push	 edi
  00223	e8 00 00 00 00	 call	 _r
  00228	83 c4 40	 add	 esp, 64			; 00000040H
  0022b	8b f0		 mov	 esi, eax

; 217  : 	n2 = r(n1, n2, ks->X3, sbox);

  0022d	53		 push	 ebx
  0022e	ff 75 f0	 push	 DWORD PTR tv330[ebp]
  00231	57		 push	 edi
  00232	56		 push	 esi
  00233	e8 00 00 00 00	 call	 _r

; 218  : 	n1 = r(n2, n1, ks->X2, sbox);

  00238	53		 push	 ebx
  00239	ff 75 ec	 push	 DWORD PTR tv488[ebp]
  0023c	8b f8		 mov	 edi, eax
  0023e	56		 push	 esi
  0023f	57		 push	 edi
  00240	e8 00 00 00 00	 call	 _r

; 219  : 	n2 = r(n1, n2, ks->X1, sbox);

  00245	53		 push	 ebx
  00246	ff 75 e8	 push	 DWORD PTR tv489[ebp]
  00249	8b f0		 mov	 esi, eax
  0024b	57		 push	 edi
  0024c	56		 push	 esi
  0024d	e8 00 00 00 00	 call	 _r

; 220  : 	n1 = r(n2, n1, ks->X0, sbox);

  00252	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  00255	8b d8		 mov	 ebx, eax
  00257	ff 75 e4	 push	 DWORD PTR tv490[ebp]
  0025a	56		 push	 esi
  0025b	53		 push	 ebx
  0025c	e8 00 00 00 00	 call	 _r

; 221  : 	
; 222  : 	out[0] = (byte)(n2 & 0xFF); out[1] = (byte)((n2 >> 8) & 0xFF); out[2] = (byte)((n2 >> 16) & 0xFF); out[3] = (byte)((n2 >> 24) & 0xFF);

  00261	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  00264	8b cb		 mov	 ecx, ebx
  00266	c1 e9 08	 shr	 ecx, 8
  00269	83 c4 40	 add	 esp, 64			; 00000040H
  0026c	89 45 10	 mov	 DWORD PTR _n1$17$[ebp], eax
  0026f	88 4a 01	 mov	 BYTE PTR [edx+1], cl
  00272	8b cb		 mov	 ecx, ebx
  00274	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00277	88 4a 02	 mov	 BYTE PTR [edx+2], cl

; 223  : 	out[4] = (byte)(n1 & 0xFF); out[5] = (byte)((n1 >> 8) & 0xFF); out[6] = (byte)((n1 >> 16) & 0xFF); out[7] = (byte)((n1 >> 24) & 0xFF);

  0027a	8b c8		 mov	 ecx, eax
  0027c	c1 e8 08	 shr	 eax, 8
  0027f	88 42 05	 mov	 BYTE PTR [edx+5], al
  00282	8b c1		 mov	 eax, ecx
  00284	88 1a		 mov	 BYTE PTR [edx], bl
  00286	c1 eb 18	 shr	 ebx, 24			; 00000018H
  00289	5f		 pop	 edi
  0028a	c1 e8 10	 shr	 eax, 16			; 00000010H
  0028d	88 4a 04	 mov	 BYTE PTR [edx+4], cl
  00290	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00293	5e		 pop	 esi
  00294	88 5a 03	 mov	 BYTE PTR [edx+3], bl
  00297	88 42 06	 mov	 BYTE PTR [edx+6], al
  0029a	88 4a 07	 mov	 BYTE PTR [edx+7], cl
  0029d	5b		 pop	 ebx

; 224  : }

  0029e	8b e5		 mov	 esp, ebp
  002a0	5d		 pop	 ebp
  002a1	c3		 ret	 0
_gost_decrypt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\crypto\gostcipher.c
;	COMDAT _gost_encrypt
_TEXT	SEGMENT
tv490 = -28						; size = 4
tv489 = -24						; size = 4
tv488 = -20						; size = 4
tv330 = -16						; size = 4
tv487 = -12						; size = 4
tv486 = -8						; size = 4
tv485 = -4						; size = 4
_sbox$1$ = 8						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
tv404 = 16						; size = 4
_n1$17$ = 16						; size = 4
_ks$ = 16						; size = 4
_gost_encrypt PROC					; COMDAT

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 104  : 	gst_udword n1, n2;
; 105  : 	gost_s_box *sbox;
; 106  : 	n1 = 0;
; 107  : 	n2 = 0;
; 108  : 
; 109  : 	n1 = (gst_udword)in[3] << 24 | (gst_udword)in[2] << 16 | (gst_udword)in[1] << 8 | (gst_udword)in[0];

  00006	8b 55 08	 mov	 edx, DWORD PTR _in$[ebp]
  00009	53		 push	 ebx

; 110  : 	n2 = (gst_udword)in[7] << 24 | (gst_udword)in[6] << 16 | (gst_udword)in[5] << 8 | (gst_udword)in[4];
; 111  : #ifdef GOST_DYNAMIC_SBOXES
; 112  : 	sbox = &ks->sbox;

  0000a	8b 5d 10	 mov	 ebx, DWORD PTR _ks$[ebp]
  0000d	56		 push	 esi
  0000e	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00012	57		 push	 edi
  00013	0f b6 7a 03	 movzx	 edi, BYTE PTR [edx+3]
  00017	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  0001a	c1 e7 08	 shl	 edi, 8
  0001d	0b f8		 or	 edi, eax
  0001f	89 4d 08	 mov	 DWORD PTR _sbox$1$[ebp], ecx
  00022	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]

; 113  : #else
; 114  : 	sbox = ks->sbox;
; 115  : #endif
; 116  : 
; 117  : 	//Rounds 1-24
; 118  : 	n2 = r(n1, n2, ks->X0, sbox);

  00026	51		 push	 ecx
  00027	0f b6 4a 07	 movzx	 ecx, BYTE PTR [edx+7]
  0002b	c1 e7 08	 shl	 edi, 8
  0002e	0b f8		 or	 edi, eax
  00030	c1 e1 08	 shl	 ecx, 8
  00033	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00036	c1 e7 08	 shl	 edi, 8
  00039	0b f8		 or	 edi, eax
  0003b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0003d	50		 push	 eax
  0003e	89 45 e4	 mov	 DWORD PTR tv490[ebp], eax
  00041	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  00045	0b c8		 or	 ecx, eax
  00047	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  0004b	c1 e1 08	 shl	 ecx, 8
  0004e	0b c8		 or	 ecx, eax
  00050	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00054	c1 e1 08	 shl	 ecx, 8
  00057	0b c8		 or	 ecx, eax
  00059	51		 push	 ecx
  0005a	57		 push	 edi
  0005b	e8 00 00 00 00	 call	 _r

; 119  : 	n1 = r(n2, n1, ks->X1, sbox);

  00060	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  00063	8b f0		 mov	 esi, eax
  00065	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00068	51		 push	 ecx
  00069	50		 push	 eax
  0006a	57		 push	 edi
  0006b	56		 push	 esi
  0006c	89 45 e8	 mov	 DWORD PTR tv489[ebp], eax
  0006f	e8 00 00 00 00	 call	 _r

; 120  : 	n2 = r(n1, n2, ks->X2, sbox);

  00074	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  00077	8b f8		 mov	 edi, eax
  00079	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0007c	51		 push	 ecx
  0007d	50		 push	 eax
  0007e	56		 push	 esi
  0007f	57		 push	 edi
  00080	89 45 ec	 mov	 DWORD PTR tv488[ebp], eax
  00083	e8 00 00 00 00	 call	 _r

; 121  : 	n1 = r(n2, n1, ks->X3, sbox);

  00088	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  0008b	8b f0		 mov	 esi, eax
  0008d	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00090	51		 push	 ecx
  00091	50		 push	 eax
  00092	57		 push	 edi
  00093	56		 push	 esi
  00094	89 45 f0	 mov	 DWORD PTR tv330[ebp], eax
  00097	e8 00 00 00 00	 call	 _r
  0009c	83 c4 40	 add	 esp, 64			; 00000040H

; 122  : 	n2 = r(n1, n2, ks->X4, sbox);

  0009f	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  000a2	8b f8		 mov	 edi, eax
  000a4	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  000a7	89 45 f4	 mov	 DWORD PTR tv487[ebp], eax
  000aa	51		 push	 ecx
  000ab	50		 push	 eax
  000ac	56		 push	 esi
  000ad	57		 push	 edi
  000ae	e8 00 00 00 00	 call	 _r

; 123  : 	n1 = r(n2, n1, ks->X5, sbox);

  000b3	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  000b6	8b f0		 mov	 esi, eax
  000b8	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  000bb	51		 push	 ecx
  000bc	50		 push	 eax
  000bd	57		 push	 edi
  000be	56		 push	 esi
  000bf	89 45 f8	 mov	 DWORD PTR tv486[ebp], eax
  000c2	e8 00 00 00 00	 call	 _r
  000c7	8b d8		 mov	 ebx, eax

; 124  : 	n2 = r(n1, n2, ks->X6, sbox);

  000c9	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  000cc	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  000cf	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  000d2	50		 push	 eax
  000d3	56		 push	 esi
  000d4	53		 push	 ebx
  000d5	89 45 fc	 mov	 DWORD PTR tv485[ebp], eax
  000d8	e8 00 00 00 00	 call	 _r

; 125  : 	n1 = r(n2, n1, ks->X7, sbox);

  000dd	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  000e0	8b f8		 mov	 edi, eax
  000e2	8b 45 10	 mov	 eax, DWORD PTR _ks$[ebp]
  000e5	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  000e8	50		 push	 eax
  000e9	53		 push	 ebx
  000ea	57		 push	 edi
  000eb	89 45 10	 mov	 DWORD PTR tv404[ebp], eax
  000ee	e8 00 00 00 00	 call	 _r

; 126  : 
; 127  : 	n2 = r(n1, n2, ks->X0, sbox);

  000f3	8b 5d 08	 mov	 ebx, DWORD PTR _sbox$1$[ebp]
  000f6	83 c4 40	 add	 esp, 64			; 00000040H
  000f9	8b f0		 mov	 esi, eax
  000fb	53		 push	 ebx
  000fc	ff 75 e4	 push	 DWORD PTR tv490[ebp]
  000ff	57		 push	 edi
  00100	56		 push	 esi
  00101	e8 00 00 00 00	 call	 _r

; 128  : 	n1 = r(n2, n1, ks->X1, sbox);

  00106	53		 push	 ebx
  00107	ff 75 e8	 push	 DWORD PTR tv489[ebp]
  0010a	8b f8		 mov	 edi, eax
  0010c	56		 push	 esi
  0010d	57		 push	 edi
  0010e	e8 00 00 00 00	 call	 _r

; 129  : 	n2 = r(n1, n2, ks->X2, sbox);

  00113	53		 push	 ebx
  00114	ff 75 ec	 push	 DWORD PTR tv488[ebp]
  00117	8b f0		 mov	 esi, eax
  00119	57		 push	 edi
  0011a	56		 push	 esi
  0011b	e8 00 00 00 00	 call	 _r

; 130  : 	n1 = r(n2, n1, ks->X3, sbox);

  00120	53		 push	 ebx
  00121	ff 75 f0	 push	 DWORD PTR tv330[ebp]
  00124	8b f8		 mov	 edi, eax
  00126	56		 push	 esi
  00127	57		 push	 edi
  00128	e8 00 00 00 00	 call	 _r
  0012d	83 c4 40	 add	 esp, 64			; 00000040H
  00130	8b f0		 mov	 esi, eax

; 131  : 	n2 = r(n1, n2, ks->X4, sbox);

  00132	53		 push	 ebx
  00133	ff 75 f4	 push	 DWORD PTR tv487[ebp]
  00136	57		 push	 edi
  00137	56		 push	 esi
  00138	e8 00 00 00 00	 call	 _r

; 132  : 	n1 = r(n2, n1, ks->X5, sbox);

  0013d	53		 push	 ebx
  0013e	ff 75 f8	 push	 DWORD PTR tv486[ebp]
  00141	8b f8		 mov	 edi, eax
  00143	56		 push	 esi
  00144	57		 push	 edi
  00145	e8 00 00 00 00	 call	 _r

; 133  : 	n2 = r(n1, n2, ks->X6, sbox);

  0014a	53		 push	 ebx
  0014b	ff 75 fc	 push	 DWORD PTR tv485[ebp]
  0014e	8b f0		 mov	 esi, eax
  00150	57		 push	 edi
  00151	56		 push	 esi
  00152	e8 00 00 00 00	 call	 _r

; 134  : 	n1 = r(n2, n1, ks->X7, sbox);

  00157	53		 push	 ebx
  00158	8b 5d 10	 mov	 ebx, DWORD PTR tv404[ebp]
  0015b	8b f8		 mov	 edi, eax
  0015d	53		 push	 ebx
  0015e	56		 push	 esi
  0015f	57		 push	 edi
  00160	e8 00 00 00 00	 call	 _r
  00165	83 c4 40	 add	 esp, 64			; 00000040H
  00168	8b f0		 mov	 esi, eax

; 135  : 
; 136  : 	n2 = r(n1, n2, ks->X0, sbox);

  0016a	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  0016d	ff 75 e4	 push	 DWORD PTR tv490[ebp]
  00170	57		 push	 edi
  00171	56		 push	 esi
  00172	e8 00 00 00 00	 call	 _r

; 137  : 	n1 = r(n2, n1, ks->X1, sbox);

  00177	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  0017a	8b f8		 mov	 edi, eax
  0017c	ff 75 e8	 push	 DWORD PTR tv489[ebp]
  0017f	56		 push	 esi
  00180	57		 push	 edi
  00181	e8 00 00 00 00	 call	 _r

; 138  : 	n2 = r(n1, n2, ks->X2, sbox);

  00186	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  00189	8b f0		 mov	 esi, eax
  0018b	ff 75 ec	 push	 DWORD PTR tv488[ebp]
  0018e	57		 push	 edi
  0018f	56		 push	 esi
  00190	e8 00 00 00 00	 call	 _r

; 139  : 	n1 = r(n2, n1, ks->X3, sbox);

  00195	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  00198	8b f8		 mov	 edi, eax
  0019a	ff 75 f0	 push	 DWORD PTR tv330[ebp]
  0019d	56		 push	 esi
  0019e	57		 push	 edi
  0019f	e8 00 00 00 00	 call	 _r
  001a4	83 c4 40	 add	 esp, 64			; 00000040H
  001a7	8b f0		 mov	 esi, eax

; 140  : 	n2 = r(n1, n2, ks->X4, sbox);

  001a9	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  001ac	ff 75 f4	 push	 DWORD PTR tv487[ebp]
  001af	57		 push	 edi
  001b0	56		 push	 esi
  001b1	e8 00 00 00 00	 call	 _r

; 141  : 	n1 = r(n2, n1, ks->X5, sbox);

  001b6	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  001b9	8b f8		 mov	 edi, eax
  001bb	ff 75 f8	 push	 DWORD PTR tv486[ebp]
  001be	56		 push	 esi
  001bf	57		 push	 edi
  001c0	e8 00 00 00 00	 call	 _r

; 142  : 	n2 = r(n1, n2, ks->X6, sbox);

  001c5	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  001c8	8b f0		 mov	 esi, eax
  001ca	ff 75 fc	 push	 DWORD PTR tv485[ebp]
  001cd	57		 push	 edi
  001ce	56		 push	 esi
  001cf	e8 00 00 00 00	 call	 _r

; 143  : 	n1 = r(n2, n1, ks->X7, sbox);

  001d4	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  001d7	8b f8		 mov	 edi, eax
  001d9	53		 push	 ebx
  001da	56		 push	 esi
  001db	57		 push	 edi
  001dc	e8 00 00 00 00	 call	 _r
  001e1	83 c4 40	 add	 esp, 64			; 00000040H
  001e4	8b f0		 mov	 esi, eax

; 144  : 
; 145  : 	//Rounds 25-32
; 146  : 	n2 = r(n1, n2, ks->X7, sbox);

  001e6	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  001e9	53		 push	 ebx
  001ea	57		 push	 edi
  001eb	56		 push	 esi
  001ec	e8 00 00 00 00	 call	 _r

; 147  : 	n1 = r(n2, n1, ks->X6, sbox);

  001f1	8b 5d 08	 mov	 ebx, DWORD PTR _sbox$1$[ebp]
  001f4	8b f8		 mov	 edi, eax
  001f6	53		 push	 ebx
  001f7	ff 75 fc	 push	 DWORD PTR tv485[ebp]
  001fa	56		 push	 esi
  001fb	57		 push	 edi
  001fc	e8 00 00 00 00	 call	 _r

; 148  : 	n2 = r(n1, n2, ks->X5, sbox);

  00201	53		 push	 ebx
  00202	ff 75 f8	 push	 DWORD PTR tv486[ebp]
  00205	8b f0		 mov	 esi, eax
  00207	57		 push	 edi
  00208	56		 push	 esi
  00209	e8 00 00 00 00	 call	 _r

; 149  : 	n1 = r(n2, n1, ks->X4, sbox);

  0020e	53		 push	 ebx
  0020f	ff 75 f4	 push	 DWORD PTR tv487[ebp]
  00212	8b f8		 mov	 edi, eax
  00214	56		 push	 esi
  00215	57		 push	 edi
  00216	e8 00 00 00 00	 call	 _r
  0021b	83 c4 40	 add	 esp, 64			; 00000040H
  0021e	8b f0		 mov	 esi, eax

; 150  : 	n2 = r(n1, n2, ks->X3, sbox);

  00220	53		 push	 ebx
  00221	ff 75 f0	 push	 DWORD PTR tv330[ebp]
  00224	57		 push	 edi
  00225	56		 push	 esi
  00226	e8 00 00 00 00	 call	 _r

; 151  : 	n1 = r(n2, n1, ks->X2, sbox);

  0022b	53		 push	 ebx
  0022c	ff 75 ec	 push	 DWORD PTR tv488[ebp]
  0022f	8b f8		 mov	 edi, eax
  00231	56		 push	 esi
  00232	57		 push	 edi
  00233	e8 00 00 00 00	 call	 _r

; 152  : 	n2 = r(n1, n2, ks->X1, sbox);

  00238	53		 push	 ebx
  00239	ff 75 e8	 push	 DWORD PTR tv489[ebp]
  0023c	8b f0		 mov	 esi, eax
  0023e	57		 push	 edi
  0023f	56		 push	 esi
  00240	e8 00 00 00 00	 call	 _r

; 153  : 	n1 = r(n2, n1, ks->X0, sbox);

  00245	ff 75 08	 push	 DWORD PTR _sbox$1$[ebp]
  00248	8b d8		 mov	 ebx, eax
  0024a	ff 75 e4	 push	 DWORD PTR tv490[ebp]
  0024d	56		 push	 esi
  0024e	53		 push	 ebx
  0024f	e8 00 00 00 00	 call	 _r

; 154  : 
; 155  : 	out[0] = (byte)(n2 & 0xFF); out[1] = (byte)((n2 >> 8) & 0xFF); out[2] = (byte)((n2 >> 16) & 0xFF); out[3] = (byte)((n2 >> 24) & 0xFF);

  00254	8b 55 0c	 mov	 edx, DWORD PTR _out$[ebp]
  00257	8b cb		 mov	 ecx, ebx
  00259	c1 e9 08	 shr	 ecx, 8
  0025c	83 c4 40	 add	 esp, 64			; 00000040H
  0025f	89 45 10	 mov	 DWORD PTR _n1$17$[ebp], eax
  00262	88 4a 01	 mov	 BYTE PTR [edx+1], cl
  00265	8b cb		 mov	 ecx, ebx
  00267	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0026a	88 4a 02	 mov	 BYTE PTR [edx+2], cl

; 156  : 	out[4] = (byte)(n1 & 0xFF); out[5] = (byte)((n1 >> 8) & 0xFF); out[6] = (byte)((n1 >> 16) & 0xFF); out[7] = (byte)((n1 >> 24) & 0xFF);

  0026d	8b c8		 mov	 ecx, eax
  0026f	c1 e8 08	 shr	 eax, 8
  00272	88 42 05	 mov	 BYTE PTR [edx+5], al
  00275	8b c1		 mov	 eax, ecx
  00277	88 1a		 mov	 BYTE PTR [edx], bl
  00279	c1 eb 18	 shr	 ebx, 24			; 00000018H
  0027c	5f		 pop	 edi
  0027d	c1 e8 10	 shr	 eax, 16			; 00000010H
  00280	88 4a 04	 mov	 BYTE PTR [edx+4], cl
  00283	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00286	5e		 pop	 esi
  00287	88 5a 03	 mov	 BYTE PTR [edx+3], bl
  0028a	88 42 06	 mov	 BYTE PTR [edx+6], al
  0028d	88 4a 07	 mov	 BYTE PTR [edx+7], cl
  00290	5b		 pop	 ebx

; 157  : }

  00291	8b e5		 mov	 esp, ebp
  00293	5d		 pop	 ebp
  00294	c3		 ret	 0
_gost_encrypt ENDP
_TEXT	ENDS
END
