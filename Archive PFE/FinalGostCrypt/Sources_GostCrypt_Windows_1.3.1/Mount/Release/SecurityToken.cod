; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Common\SecurityToken.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?Initialized@SecurityToken@GostCrypt@@1_NA	; GostCrypt::SecurityToken::Initialized
PUBLIC	?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
PUBLIC	?Pkcs11LibraryHandle@SecurityToken@GostCrypt@@1PAUHINSTANCE__@@A ; GostCrypt::SecurityToken::Pkcs11LibraryHandle
_BSS	SEGMENT
?Initialized@SecurityToken@GostCrypt@@1_NA DB 01H DUP (?) ; GostCrypt::SecurityToken::Initialized
	ALIGN	4

?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A DD 01H DUP (?) ; GostCrypt::SecurityToken::Pkcs11Functions
?Pkcs11LibraryHandle@SecurityToken@GostCrypt@@1PAUHINSTANCE__@@A DD 01H DUP (?) ; GostCrypt::SecurityToken::Pkcs11LibraryHandle
_BSS	ENDS
CONST	SEGMENT
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ ; __vcrt_va_start_verify_argument_type<wchar_t const * const>
PUBLIC	_swscanf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf_s
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?find_last_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_not_of
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	??1?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	??1_Facet_base@std@@UAE@XZ			; std::_Facet_base::~_Facet_base
PUBLIC	??_G_Facet_base@std@@UAEPAXI@Z			; std::_Facet_base::`scalar deleting destructor'
PUBLIC	?_Incref@facet@locale@std@@UAEXXZ		; std::locale::facet::_Incref
PUBLIC	?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	??1facet@locale@std@@MAE@XZ			; std::locale::facet::~facet
PUBLIC	??_Gfacet@locale@std@@MAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??0?$ctype@_W@std@@QAE@ABV_Locinfo@1@I@Z	; std::ctype<wchar_t>::ctype<wchar_t>
PUBLIC	?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<wchar_t>::_Getcat
PUBLIC	??1?$ctype@_W@std@@MAE@XZ			; std::ctype<wchar_t>::~ctype<wchar_t>
PUBLIC	?do_is@?$ctype@_W@std@@MBE_NF_W@Z		; std::ctype<wchar_t>::do_is
PUBLIC	?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z	; std::ctype<wchar_t>::do_is
PUBLIC	?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z	; std::ctype<wchar_t>::do_scan_is
PUBLIC	?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z	; std::ctype<wchar_t>::do_scan_not
PUBLIC	?do_tolower@?$ctype@_W@std@@MBE_W_W@Z		; std::ctype<wchar_t>::do_tolower
PUBLIC	?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z	; std::ctype<wchar_t>::do_tolower
PUBLIC	?do_toupper@?$ctype@_W@std@@MBE_W_W@Z		; std::ctype<wchar_t>::do_toupper
PUBLIC	?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z	; std::ctype<wchar_t>::do_toupper
PUBLIC	?do_widen@?$ctype@_W@std@@MBE_WD@Z		; std::ctype<wchar_t>::do_widen
PUBLIC	?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z	; std::ctype<wchar_t>::do_widen
PUBLIC	?do_narrow@?$ctype@_W@std@@MBED_WD@Z		; std::ctype<wchar_t>::do_narrow
PUBLIC	?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z	; std::ctype<wchar_t>::do_narrow
PUBLIC	??_G?$ctype@_W@std@@MAEPAXI@Z			; std::ctype<wchar_t>::`scalar deleting destructor'
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
PUBLIC	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	??0_System_error@std@@QAE@ABV01@@Z		; std::_System_error::_System_error
PUBLIC	??_G_System_error@std@@UAEPAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QAE@Verror_code@1@PBD@Z	; std::system_error::system_error
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	??_Gsystem_error@std@@UAEPAXI@Z			; std::system_error::`scalar deleting destructor'
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	?clear@ios_base@std@@QAEXH@Z			; std::ios_base::clear
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	??1ios_base@std@@UAE@XZ				; std::ios_base::~ios_base
PUBLIC	?_Init@ios_base@std@@IAEXXZ			; std::ios_base::_Init
PUBLIC	??_Gios_base@std@@UAEPAXI@Z			; std::ios_base::`scalar deleting destructor'
PUBLIC	?hex@std@@YAAAVios_base@1@AAV21@@Z		; std::hex
PUBLIC	?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?allocate@?$allocator@_W@std@@QAEPA_WI@Z	; std::allocator<wchar_t>::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
PUBLIC	?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
PUBLIC	?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
PUBLIC	?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
PUBLIC	?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
PUBLIC	?_Traits_compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAHQB_WI0I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Traits_compare
PUBLIC	?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Chassign
PUBLIC	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
PUBLIC	??1Container@ForEach@GostCrypt@@UAE@XZ		; GostCrypt::ForEach::Container::~Container
PUBLIC	??_GContainer@ForEach@GostCrypt@@UAEPAXI@Z	; GostCrypt::ForEach::Container::`scalar deleting destructor'
PUBLIC	??0Exception@GostCrypt@@QAE@ABU01@@Z		; GostCrypt::Exception::Exception
PUBLIC	?Show@SystemException@GostCrypt@@UBEXPAUHWND__@@@Z ; GostCrypt::SystemException::Show
PUBLIC	??0SystemException@GostCrypt@@QAE@ABU01@@Z	; GostCrypt::SystemException::SystemException
PUBLIC	?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z ; GostCrypt::ParameterIncorrect::Show
PUBLIC	??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z	; GostCrypt::ParameterIncorrect::ParameterIncorrect
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1SecurityTokenInfo@GostCrypt@@QAE@XZ		; GostCrypt::SecurityTokenInfo::~SecurityTokenInfo
PUBLIC	??0SecurityTokenInfo@GostCrypt@@QAE@ABU01@@Z	; GostCrypt::SecurityTokenInfo::SecurityTokenInfo
PUBLIC	??4SecurityTokenInfo@GostCrypt@@QAEAAU01@$$QAU01@@Z ; GostCrypt::SecurityTokenInfo::operator=
PUBLIC	??BSecurityTokenKeyfilePath@GostCrypt@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; GostCrypt::SecurityTokenKeyfilePath::operator std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z ; GostCrypt::SecurityTokenKeyfile::SecurityTokenKeyfile
PUBLIC	??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ ; GostCrypt::SecurityTokenKeyfile::operator GostCrypt::SecurityTokenKeyfilePath
PUBLIC	??1SecurityTokenKeyfile@GostCrypt@@QAE@XZ	; GostCrypt::SecurityTokenKeyfile::~SecurityTokenKeyfile
PUBLIC	??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z	; GostCrypt::SecurityTokenKeyfile::SecurityTokenKeyfile
PUBLIC	??0SecurityTokenKeyfile@GostCrypt@@QAE@$$QAU01@@Z ; GostCrypt::SecurityTokenKeyfile::SecurityTokenKeyfile
PUBLIC	??4SecurityTokenKeyfile@GostCrypt@@QAEAAU01@ABU01@@Z ; GostCrypt::SecurityTokenKeyfile::operator=
PUBLIC	?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z ; GostCrypt::Pkcs11Exception::Show
PUBLIC	??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GostCrypt::Pkcs11Exception::operator std::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0Pkcs11Exception@GostCrypt@@QAE@ABU01@@Z	; GostCrypt::Pkcs11Exception::Pkcs11Exception
PUBLIC	?Show@SecurityTokenLibraryNotInitialized@GostCrypt@@UBEXPAUHWND__@@@Z ; GostCrypt::SecurityTokenLibraryNotInitialized::Show
PUBLIC	??0SecurityTokenLibraryNotInitialized@GostCrypt@@QAE@ABU01@@Z ; GostCrypt::SecurityTokenLibraryNotInitialized::SecurityTokenLibraryNotInitialized
PUBLIC	?Show@InvalidSecurityTokenKeyfilePath@GostCrypt@@UBEXPAUHWND__@@@Z ; GostCrypt::InvalidSecurityTokenKeyfilePath::Show
PUBLIC	??0InvalidSecurityTokenKeyfilePath@GostCrypt@@QAE@ABU01@@Z ; GostCrypt::InvalidSecurityTokenKeyfilePath::InvalidSecurityTokenKeyfilePath
PUBLIC	?Show@SecurityTokenKeyfileAlreadyExists@GostCrypt@@UBEXPAUHWND__@@@Z ; GostCrypt::SecurityTokenKeyfileAlreadyExists::Show
PUBLIC	??0SecurityTokenKeyfileAlreadyExists@GostCrypt@@QAE@ABU01@@Z ; GostCrypt::SecurityTokenKeyfileAlreadyExists::SecurityTokenKeyfileAlreadyExists
PUBLIC	?Show@SecurityTokenKeyfileNotFound@GostCrypt@@UBEXPAUHWND__@@@Z ; GostCrypt::SecurityTokenKeyfileNotFound::Show
PUBLIC	??0SecurityTokenKeyfileNotFound@GostCrypt@@QAE@ABU01@@Z ; GostCrypt::SecurityTokenKeyfileNotFound::SecurityTokenKeyfileNotFound
PUBLIC	?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ ; GostCrypt::SecurityToken::CloseAllSessions
PUBLIC	?CloseLibrary@SecurityToken@GostCrypt@@SAXXZ	; GostCrypt::SecurityToken::CloseLibrary
PUBLIC	?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z ; GostCrypt::SecurityToken::CreateKeyfile
PUBLIC	?DeleteKeyfile@SecurityToken@GostCrypt@@SAXABUSecurityTokenKeyfile@2@@Z ; GostCrypt::SecurityToken::DeleteKeyfile
PUBLIC	?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z ; GostCrypt::SecurityToken::GetAvailableKeyfiles
PUBLIC	?GetKeyfileData@SecurityToken@GostCrypt@@SAXABUSecurityTokenKeyfile@2@AAV?$vector@EV?$allocator@E@std@@@std@@@Z ; GostCrypt::SecurityToken::GetKeyfileData
PUBLIC	?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ ; GostCrypt::SecurityToken::GetAvailableTokens
PUBLIC	?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z ; GostCrypt::SecurityToken::GetTokenInfo
PUBLIC	?InitLibrary@SecurityToken@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$auto_ptr@UGetPinFunctor@GostCrypt@@@4@V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@4@@Z ; GostCrypt::SecurityToken::InitLibrary
PUBLIC	?IsKeyfilePathValid@SecurityToken@GostCrypt@@SA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; GostCrypt::SecurityToken::IsKeyfilePathValid
PUBLIC	?CloseSession@SecurityToken@GostCrypt@@KAXK@Z	; GostCrypt::SecurityToken::CloseSession
PUBLIC	?GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z ; GostCrypt::SecurityToken::GetObjects
PUBLIC	?GetObjectAttribute@SecurityToken@GostCrypt@@KAXKKKAAV?$vector@EV?$allocator@E@std@@@std@@@Z ; GostCrypt::SecurityToken::GetObjectAttribute
PUBLIC	?GetTokenSlots@SecurityToken@GostCrypt@@KA?AV?$list@KV?$allocator@K@std@@@std@@XZ ; GostCrypt::SecurityToken::GetTokenSlots
PUBLIC	?Login@SecurityToken@GostCrypt@@KAXKABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GostCrypt::SecurityToken::Login
PUBLIC	?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z ; GostCrypt::SecurityToken::LoginUserIfRequired
PUBLIC	?OpenSession@SecurityToken@GostCrypt@@KAXK@Z	; GostCrypt::SecurityToken::OpenSession
PUBLIC	?CheckLibraryStatus@SecurityToken@GostCrypt@@KAXXZ ; GostCrypt::SecurityToken::CheckLibraryStatus
PUBLIC	?allocate@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEPAUSecurityTokenKeyfile@GostCrypt@@I@Z ; std::allocator<GostCrypt::SecurityTokenKeyfile>::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@I@Z ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::deallocate
PUBLIC	??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >
PUBLIC	??1?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@XZ ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::~vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >
PUBLIC	?push_back@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXABUSecurityTokenKeyfile@GostCrypt@@@Z ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::push_back
PUBLIC	?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Reallocate
PUBLIC	?_Reserve@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Reserve
PUBLIC	?_Tidy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Tidy
PUBLIC	??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init
PUBLIC	??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??1?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::~basic_ostream<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
PUBLIC	??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<
PUBLIC	??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<
PUBLIC	?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
PUBLIC	??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::~basic_iostream<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??_G?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
PUBLIC	??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
PUBLIC	??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Lock
PUBLIC	?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Unlock
PUBLIC	?_Gnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gnavail
PUBLIC	?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pnavail
PUBLIC	?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::overflow
PUBLIC	?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbackfail
PUBLIC	?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::showmanyc
PUBLIC	?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::underflow
PUBLIC	?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::uflow
PUBLIC	?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsgetn
PUBLIC	?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsputn
PUBLIC	?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekoff
PUBLIC	?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekpos
PUBLIC	?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setbuf
PUBLIC	?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sync
PUBLIC	?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::imbue
PUBLIC	??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?str@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
PUBLIC	?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekpos
PUBLIC	?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
PUBLIC	??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor'
PUBLIC	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$GetContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >
PUBLIC	?IsNotEnd@?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UBE_NXZ ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::IsNotEnd
PUBLIC	?Next@?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UBEXXZ ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::Next
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >
PUBLIC	??1?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >
PUBLIC	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buyheadnode
PUBLIC	?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode0
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::erase
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::clear
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Erase
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Rrotate
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::operator--
PUBLIC	??1?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::~ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >
PUBLIC	??_G?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UAEPAXI@Z ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::`scalar deleting destructor'
PUBLIC	??$GetContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >
PUBLIC	?IsNotEnd@?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::IsNotEnd
PUBLIC	?Next@?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::Next
PUBLIC	??1?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::~ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >
PUBLIC	??_G?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::`scalar deleting destructor'
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEPAEI@Z ; std::_Wrap_alloc<std::allocator<unsigned char> >::allocate
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@I@Z	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@$$QAV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=
PUBLIC	?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate
PUBLIC	?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reserve
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
PUBLIC	?allocate@?$allocator@K@std@@QAEPAKI@Z		; std::allocator<unsigned long>::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
PUBLIC	?_Buynode0@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Buynode0
PUBLIC	??1?$_List_buy@KV?$allocator@K@std@@@std@@QAE@XZ ; std::_List_buy<unsigned long,std::allocator<unsigned long> >::~_List_buy<unsigned long,std::allocator<unsigned long> >
PUBLIC	??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z ; std::list<unsigned long,std::allocator<unsigned long> >::list<unsigned long,std::allocator<unsigned long> >
PUBLIC	??1?$list@KV?$allocator@K@std@@@std@@QAE@XZ	; std::list<unsigned long,std::allocator<unsigned long> >::~list<unsigned long,std::allocator<unsigned long> >
PUBLIC	?push_back@?$list@KV?$allocator@K@std@@@std@@QAEXABK@Z ; std::list<unsigned long,std::allocator<unsigned long> >::push_back
PUBLIC	?_Unchecked_erase@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::list<unsigned long,std::allocator<unsigned long> >::_Unchecked_erase
PUBLIC	?_Tidy@?$list@KV?$allocator@K@std@@@std@@QAEXXZ	; std::list<unsigned long,std::allocator<unsigned long> >::_Tidy
PUBLIC	??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >
PUBLIC	?IsNotEnd@?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::IsNotEnd
PUBLIC	?Next@?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBEXXZ ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::Next
PUBLIC	??1?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::~ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >
PUBLIC	??_G?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::`scalar deleting destructor'
PUBLIC	??0?$vector@KV?$allocator@K@std@@@std@@QAE@I@Z	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
PUBLIC	??0?$vector@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
PUBLIC	??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
PUBLIC	?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reallocate
PUBLIC	?_Reserve@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reserve
PUBLIC	??$GetContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@01@ABV?$vector@KV?$allocator@K@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >
PUBLIC	?IsNotEnd@?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::IsNotEnd
PUBLIC	?Next@?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBEXXZ ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::Next
PUBLIC	??1?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::~ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >
PUBLIC	??_G?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::`scalar deleting destructor'
PUBLIC	?_Buynode0@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Buynode0
PUBLIC	??1?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::~list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >
PUBLIC	?clear@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::clear
PUBLIC	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
PUBLIC	?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
PUBLIC	??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
PUBLIC	??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
PUBLIC	??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
PUBLIC	??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_iostream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_iostream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
PUBLIC	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
PUBLIC	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
PUBLIC	?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
PUBLIC	?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::uflow
PUBLIC	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
PUBLIC	?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_streambuf<char,std::char_traits<char> >::imbue
PUBLIC	??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
PUBLIC	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??1?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAE@XZ ; std::auto_ptr<GostCrypt::GetPinFunctor>::~auto_ptr<GostCrypt::GetPinFunctor>
PUBLIC	??1?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAE@XZ ; std::auto_ptr<GostCrypt::SendExceptionFunctor>::~auto_ptr<GostCrypt::SendExceptionFunctor>
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W$$QAV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >
PUBLIC	?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getcat
PUBLIC	??1?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAE@XZ ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::~num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WJ@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBX@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
PUBLIC	?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ffmt
PUBLIC	?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Fput
PUBLIC	?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ifmt
PUBLIC	?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput
PUBLIC	?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
PUBLIC	?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
PUBLIC	??_G?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`scalar deleting destructor'
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
PUBLIC	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
PUBLIC	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
PUBLIC	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
PUBLIC	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
PUBLIC	??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
PUBLIC	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
PUBLIC	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
PUBLIC	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
PUBLIC	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
PUBLIC	??1?$numpunct@D@std@@MAE@XZ			; std::numpunct<char>::~numpunct<char>
PUBLIC	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z	; std::numpunct<char>::_Init
PUBLIC	?do_decimal_point@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_grouping
PUBLIC	?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_falsename
PUBLIC	?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_truename
PUBLIC	?_Tidy@?$numpunct@D@std@@AAEXXZ			; std::numpunct<char>::_Tidy
PUBLIC	??_G?$numpunct@D@std@@MAEPAXI@Z			; std::numpunct<char>::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<wchar_t> >
PUBLIC	?grouping@?$numpunct@_W@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<wchar_t>::grouping
PUBLIC	?falsename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::numpunct<wchar_t>::falsename
PUBLIC	?truename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::numpunct<wchar_t>::truename
PUBLIC	?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<wchar_t>::_Getcat
PUBLIC	??1?$numpunct@_W@std@@MAE@XZ			; std::numpunct<wchar_t>::~numpunct<wchar_t>
PUBLIC	?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<wchar_t>::_Init
PUBLIC	?do_decimal_point@?$numpunct@_W@std@@MBE_WXZ	; std::numpunct<wchar_t>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@_W@std@@MBE_WXZ	; std::numpunct<wchar_t>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@_W@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<wchar_t>::do_grouping
PUBLIC	?do_falsename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::numpunct<wchar_t>::do_falsename
PUBLIC	?do_truename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::numpunct<wchar_t>::do_truename
PUBLIC	?_Tidy@?$numpunct@_W@std@@AAEXXZ		; std::numpunct<wchar_t>::_Tidy
PUBLIC	??_G?$numpunct@_W@std@@MAEPAXI@Z		; std::numpunct<wchar_t>::`scalar deleting destructor'
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
PUBLIC	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$_Destroy_range@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@PAUSecurityTokenKeyfile@GostCrypt@@@std@@YAXPAUSecurityTokenKeyfile@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<GostCrypt::SecurityTokenKeyfile>,GostCrypt::SecurityTokenKeyfile *>
PUBLIC	??__F_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ@YAXXZ ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::`dynamic atexit destructor for '_Static''
PUBLIC	??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
PUBLIC	??$_Buynode@ABK@?$_List_buy@KV?$allocator@K@std@@@std@@QAEPAU?$_List_node@KPAX@1@PAU21@0ABK@Z ; std::_List_buy<unsigned long,std::allocator<unsigned long> >::_Buynode<unsigned long const &>
PUBLIC	??$_Buynode@USecurityTokenInfo@GostCrypt@@@?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@PAU21@0$$QAUSecurityTokenInfo@GostCrypt@@@Z ; std::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Buynode<GostCrypt::SecurityTokenInfo>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > > >
PUBLIC	??$_Copy@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy<std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_tag>
PUBLIC	??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::list<unsigned long,std::allocator<unsigned long> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > > >
PUBLIC	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
PUBLIC	??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_hint<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
PUBLIC	??$_Uninitialized_move_al_unchecked1@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<GostCrypt::SecurityTokenKeyfile *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >
PUBLIC	??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_tag>
PUBLIC	??$_Insert_at@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_at<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
PUBLIC	??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_nohint<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
PUBLIC	??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::SecurityTokenKeyfile const *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >
PUBLIC	??$_Buynode@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &>
PUBLIC	??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_iostream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
PUBLIC	??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
PUBLIC	??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception?$AA@	; `string'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	__CTA2?AVruntime_error@std@@
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@	; `string'
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7?$ctype@_W@std@@6B@				; std::ctype<wchar_t>::`vftable'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_7ios_base@std@@6B@				; std::ios_base::`vftable'
PUBLIC	__TI5?AVfailure@ios_base@std@@
PUBLIC	__CTA5?AVfailure@ios_base@std@@
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ ; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@	; `string'
PUBLIC	??_7Container@ForEach@GostCrypt@@6B@		; GostCrypt::ForEach::Container::`vftable'
PUBLIC	??_7Exception@GostCrypt@@6B@			; GostCrypt::Exception::`vftable'
PUBLIC	??_7SystemException@GostCrypt@@6B@		; GostCrypt::SystemException::`vftable'
PUBLIC	??_7ParameterIncorrect@GostCrypt@@6B@		; GostCrypt::ParameterIncorrect::`vftable'
PUBLIC	??_C@_01PKGAHCOL@?$CJ?$AA@			; `string'
PUBLIC	??_C@_0IM@CKBKFPJM@Parameter?5incorrect?4?6?6?6?$CIIf?5you?5r@ ; `string'
PUBLIC	??_C@_09NKHKFHLH@GostCrypt?$AA@			; `string'
PUBLIC	??_7Pkcs11Exception@GostCrypt@@6B@		; GostCrypt::Pkcs11Exception::`vftable'
PUBLIC	??_7SecurityTokenLibraryNotInitialized@GostCrypt@@6B@ ; GostCrypt::SecurityTokenLibraryNotInitialized::`vftable'
PUBLIC	??_C@_0BL@NECJIJNL@NO_PKCS11_MODULE_SPECIFIED?$AA@ ; `string'
PUBLIC	??_C@_0BK@OPPAPAFF@PKCS11_MODULE_INIT_FAILED?$AA@ ; `string'
PUBLIC	??_7InvalidSecurityTokenKeyfilePath@GostCrypt@@6B@ ; GostCrypt::InvalidSecurityTokenKeyfilePath::`vftable'
PUBLIC	??_C@_0BL@JIBHLIDC@INVALID_TOKEN_KEYFILE_PATH?$AA@ ; `string'
PUBLIC	??_7SecurityTokenKeyfileAlreadyExists@GostCrypt@@6B@ ; GostCrypt::SecurityTokenKeyfileAlreadyExists::`vftable'
PUBLIC	??_C@_0BN@LMLDGKPH@TOKEN_KEYFILE_ALREADY_EXISTS?$AA@ ; `string'
PUBLIC	??_7SecurityTokenKeyfileNotFound@GostCrypt@@6B@	; GostCrypt::SecurityTokenKeyfileNotFound::`vftable'
PUBLIC	??_C@_0BI@BBCBGCML@TOKEN_KEYFILE_NOT_FOUND?$AA@	; `string'
PUBLIC	?PinCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@A ; GostCrypt::SecurityToken::PinCallback
PUBLIC	?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
PUBLIC	?WarningCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@A ; GostCrypt::SecurityToken::WarningCallback
PUBLIC	??_C@_1CC@OMDFECBP@?$AAt?$AAo?$AAk?$AAe?$AAn?$AA?3?$AA?1?$AA?1?$AAs?$AAl?$AAo?$AAt?$AA?1?$AA?$CF?$AAl?$AAu?$AA?$AA@ ; `string'
PUBLIC	__TI2?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@
PUBLIC	__CTA2?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@
PUBLIC	??_R0?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@@8 ; GostCrypt::InvalidSecurityTokenKeyfilePath `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@@8??0InvalidSecurityTokenKeyfilePath@GostCrypt@@QAE@ABU01@@Z4
PUBLIC	??_R0?AUException@GostCrypt@@@8			; GostCrypt::Exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
PUBLIC	??_C@_1O@HIAFDIDB@?$AA?1?$AAf?$AAi?$AAl?$AAe?$AA?1?$AA?$AA@ ; `string'
PUBLIC	__TI2?AUSecurityTokenKeyfileNotFound@GostCrypt@@
PUBLIC	__CTA2?AUSecurityTokenKeyfileNotFound@GostCrypt@@
PUBLIC	??_R0?AUSecurityTokenKeyfileNotFound@GostCrypt@@@8 ; GostCrypt::SecurityTokenKeyfileNotFound `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUSecurityTokenKeyfileNotFound@GostCrypt@@@8??0SecurityTokenKeyfileNotFound@GostCrypt@@QAE@ABU01@@Z4
PUBLIC	??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_istream@_WU?$char_traits@_W@std@@@std@@7B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
PUBLIC	??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_ostream@_WU?$char_traits@_W@std@@@std@@7B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
PUBLIC	??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
PUBLIC	??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
PUBLIC	??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
PUBLIC	??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
PUBLIC	??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
PUBLIC	??_C@_1BM@IPMKACB@?$AAt?$AAo?$AAk?$AAe?$AAn?$AA?3?$AA?1?$AA?1?$AAs?$AAl?$AAo?$AAt?$AA?1?$AA?$AA@ ; `string'
PUBLIC	__TI2?AUSecurityTokenLibraryNotInitialized@GostCrypt@@
PUBLIC	__CTA2?AUSecurityTokenLibraryNotInitialized@GostCrypt@@
PUBLIC	??_R0?AUSecurityTokenLibraryNotInitialized@GostCrypt@@@8 ; GostCrypt::SecurityTokenLibraryNotInitialized `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUSecurityTokenLibraryNotInitialized@GostCrypt@@@8??0SecurityTokenLibraryNotInitialized@GostCrypt@@QAE@ABU01@@Z4
PUBLIC	??_7?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::`vftable'
PUBLIC	__TI2?AUParameterIncorrect@GostCrypt@@
PUBLIC	__CTA2?AUParameterIncorrect@GostCrypt@@
PUBLIC	??_R0?AUParameterIncorrect@GostCrypt@@@8	; GostCrypt::ParameterIncorrect `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUParameterIncorrect@GostCrypt@@@8??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z8
PUBLIC	??_C@_0CL@GPMOMIPC@GostCrypt?3?3SecurityToken?3?3CloseS@ ; `string'
PUBLIC	??_7?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::`vftable'
PUBLIC	??_C@_0CM@EILIPAOO@GostCrypt?3?3SecurityToken?3?3Create@ ; `string'
PUBLIC	__TI2?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@
PUBLIC	__CTA2?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@
PUBLIC	??_R0?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@@8 ; GostCrypt::SecurityTokenKeyfileAlreadyExists `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@@8??0SecurityTokenKeyfileAlreadyExists@GostCrypt@@QAE@ABU01@@Z4
PUBLIC	__TI2?AUPkcs11Exception@GostCrypt@@
PUBLIC	__CTA2?AUPkcs11Exception@GostCrypt@@
PUBLIC	??_R0?AUPkcs11Exception@GostCrypt@@@8		; GostCrypt::Pkcs11Exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUPkcs11Exception@GostCrypt@@@8??0Pkcs11Exception@GostCrypt@@QAE@ABU01@@Z24
PUBLIC	??_7?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::`vftable'
PUBLIC	??_7?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::`vftable'
PUBLIC	??_R0?AUUserAbort@GostCrypt@@@8			; GostCrypt::UserAbort `RTTI Type Descriptor'
PUBLIC	??_C@_0CJ@KMNLDKPC@GostCrypt?3?3SecurityToken?3?3GetObj@ ; `string'
PUBLIC	??_C@_0DB@KHBANPMA@GostCrypt?3?3SecurityToken?3?3GetObj@ ; `string'
PUBLIC	??_C@_1BC@ELBDEFGA@?$AAt?$AAo?$AAk?$AAe?$AAn?$AA?3?$AA?1?$AA?1?$AA?$AA@ ; `string'
PUBLIC	??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_istream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_iostream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_C@_01IPJKGB@?$CD?$AA@			; `string'
PUBLIC	__TI2?AUSystemException@GostCrypt@@
PUBLIC	__CTA2?AUSystemException@GostCrypt@@
PUBLIC	??_R0?AUSystemException@GostCrypt@@@8		; GostCrypt::SystemException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUSystemException@GostCrypt@@@8??0SystemException@GostCrypt@@QAE@ABU01@@Z8
PUBLIC	??_C@_0BC@GHFGDNNP@C_GetFunctionList?$AA@	; `string'
PUBLIC	??_C@_0L@JIDCKNME@CKR_CANCEL?$AA@		; `string'
PUBLIC	??_C@_0BA@HHDKGBBP@CKR_HOST_MEMORY?$AA@		; `string'
PUBLIC	??_C@_0BE@FOAEJLLC@CKR_SLOT_ID_INVALID?$AA@	; `string'
PUBLIC	??_C@_0BC@BPPOLCIH@CKR_GENERAL_ERROR?$AA@	; `string'
PUBLIC	??_C@_0BE@DIFKEOGI@CKR_FUNCTION_FAILED?$AA@	; `string'
PUBLIC	??_C@_0BC@LNHMJFHC@CKR_ARGUMENTS_BAD?$AA@	; `string'
PUBLIC	??_C@_0N@KFPEOGN@CKR_NO_EVENT?$AA@		; `string'
PUBLIC	??_C@_0BL@NDINCBKJ@CKR_NEED_TO_CREATE_THREADS?$AA@ ; `string'
PUBLIC	??_C@_0O@OHMKMDKB@CKR_CANT_LOCK?$AA@		; `string'
PUBLIC	??_C@_0BI@IDDIMLAI@CKR_ATTRIBUTE_READ_ONLY?$AA@	; `string'
PUBLIC	??_C@_0BI@LPANBEIN@CKR_ATTRIBUTE_SENSITIVE?$AA@	; `string'
PUBLIC	??_C@_0BL@CJHMMHEH@CKR_ATTRIBUTE_TYPE_INVALID?$AA@ ; `string'
PUBLIC	??_C@_0BM@LMONJDMA@CKR_ATTRIBUTE_VALUE_INVALID?$AA@ ; `string'
PUBLIC	??_C@_0BB@HONBBNLK@CKR_DATA_INVALID?$AA@	; `string'
PUBLIC	??_C@_0BD@BPCFCEOF@CKR_DATA_LEN_RANGE?$AA@	; `string'
PUBLIC	??_C@_0BB@OAEPJIAO@CKR_DEVICE_ERROR?$AA@	; `string'
PUBLIC	??_C@_0BC@EDKNPIJF@CKR_DEVICE_MEMORY?$AA@	; `string'
PUBLIC	??_C@_0BD@CLPGKOPG@CKR_DEVICE_REMOVED?$AA@	; `string'
PUBLIC	??_C@_0BL@HMMBAKLE@CKR_ENCRYPTED_DATA_INVALID?$AA@ ; `string'
PUBLIC	??_C@_0BN@CHFIOLM@CKR_ENCRYPTED_DATA_LEN_RANGE?$AA@ ; `string'
PUBLIC	??_C@_0BG@GFNGJBLD@CKR_FUNCTION_CANCELED?$AA@	; `string'
PUBLIC	??_C@_0BK@CPMALGEH@CKR_FUNCTION_NOT_PARALLEL?$AA@ ; `string'
PUBLIC	??_C@_0BL@FLCFPGMF@CKR_FUNCTION_NOT_SUPPORTED?$AA@ ; `string'
PUBLIC	??_C@_0BH@JBCBCIHC@CKR_KEY_HANDLE_INVALID?$AA@	; `string'
PUBLIC	??_C@_0BD@DCCEPOIK@CKR_KEY_SIZE_RANGE?$AA@	; `string'
PUBLIC	??_C@_0BK@FBLHAPGA@CKR_KEY_TYPE_INCONSISTENT?$AA@ ; `string'
PUBLIC	??_C@_0BD@CADJPHKC@CKR_KEY_NOT_NEEDED?$AA@	; `string'
PUBLIC	??_C@_0BA@PBNACHHM@CKR_KEY_CHANGED?$AA@		; `string'
PUBLIC	??_C@_0P@CIJPGKMN@CKR_KEY_NEEDED?$AA@		; `string'
PUBLIC	??_C@_0BF@GCBGIGLD@CKR_KEY_INDIGESTIBLE?$AA@	; `string'
PUBLIC	??_C@_0BP@PCNBFOEJ@CKR_KEY_FUNCTION_NOT_PERMITTED?$AA@ ; `string'
PUBLIC	??_C@_0BG@IEKNAGOL@CKR_KEY_NOT_WRAPPABLE?$AA@	; `string'
PUBLIC	??_C@_0BG@OIKHBDLJ@CKR_KEY_UNEXTRACTABLE?$AA@	; `string'
PUBLIC	??_C@_0BG@FIBINAPL@CKR_MECHANISM_INVALID?$AA@	; `string'
PUBLIC	??_C@_0BM@NHMBLBHF@CKR_MECHANISM_PARAM_INVALID?$AA@ ; `string'
PUBLIC	??_C@_0BK@NIGFIGL@CKR_OBJECT_HANDLE_INVALID?$AA@ ; `string'
PUBLIC	??_C@_0BF@LACBDJFM@CKR_OPERATION_ACTIVE?$AA@	; `string'
PUBLIC	??_C@_0BO@NIGNIKB@CKR_OPERATION_NOT_INITIALIZED?$AA@ ; `string'
PUBLIC	??_C@_0BC@PIDGDJNE@CKR_PIN_INCORRECT?$AA@	; `string'
PUBLIC	??_C@_0BA@PDLKJELN@CKR_PIN_INVALID?$AA@		; `string'
PUBLIC	??_C@_0BC@MEAAAEMN@CKR_PIN_LEN_RANGE?$AA@	; `string'
PUBLIC	??_C@_0BA@PPOOFJBC@CKR_PIN_EXPIRED?$AA@		; `string'
PUBLIC	??_C@_0P@JGPCDBMN@CKR_PIN_LOCKED?$AA@		; `string'
PUBLIC	??_C@_0BD@EFPEBFCO@CKR_SESSION_CLOSED?$AA@	; `string'
PUBLIC	??_C@_0BC@GFNLAALM@CKR_SESSION_COUNT?$AA@	; `string'
PUBLIC	??_C@_0BL@JFEIAJEO@CKR_SESSION_HANDLE_INVALID?$AA@ ; `string'
PUBLIC	??_C@_0CD@CNJKDODF@CKR_SESSION_PARALLEL_NOT_SUPPORT@ ; `string'
PUBLIC	??_C@_0BG@NACFPKBK@CKR_SESSION_READ_ONLY?$AA@	; `string'
PUBLIC	??_C@_0BD@CJEENIOI@CKR_SESSION_EXISTS?$AA@	; `string'
PUBLIC	??_C@_0BN@FEECMDLD@CKR_SESSION_READ_ONLY_EXISTS?$AA@ ; `string'
PUBLIC	??_C@_0CB@MOHOJDLI@CKR_SESSION_READ_WRITE_SO_EXISTS@ ; `string'
PUBLIC	??_C@_0BG@FJFGJBPL@CKR_SIGNATURE_INVALID?$AA@	; `string'
PUBLIC	??_C@_0BI@BCEJLCCN@CKR_SIGNATURE_LEN_RANGE?$AA@	; `string'
PUBLIC	??_C@_0BI@OKLBFCJN@CKR_TEMPLATE_INCOMPLETE?$AA@	; `string'
PUBLIC	??_C@_0BK@NFOMODKD@CKR_TEMPLATE_INCONSISTENT?$AA@ ; `string'
PUBLIC	??_C@_0BG@GJCOFLCP@CKR_TOKEN_NOT_PRESENT?$AA@	; `string'
PUBLIC	??_C@_0BJ@DKIDJOKM@CKR_TOKEN_NOT_RECOGNIZED?$AA@ ; `string'
PUBLIC	??_C@_0BK@LICPHIEK@CKR_TOKEN_WRITE_PROTECTED?$AA@ ; `string'
PUBLIC	??_C@_0CC@BHIKKBJK@CKR_UNWRAPPING_KEY_HANDLE_INVALI@ ; `string'
PUBLIC	??_C@_0BO@EDNGDMCF@CKR_UNWRAPPING_KEY_SIZE_RANGE?$AA@ ; `string'
PUBLIC	??_C@_0CF@FNADNHJM@CKR_UNWRAPPING_KEY_TYPE_INCONSIS@ ; `string'
PUBLIC	??_C@_0BL@HHCLDMIB@CKR_USER_ALREADY_LOGGED_IN?$AA@ ; `string'
PUBLIC	??_C@_0BH@PHIJDFPC@CKR_USER_NOT_LOGGED_IN?$AA@	; `string'
PUBLIC	??_C@_0BN@CJFMMEDO@CKR_USER_PIN_NOT_INITIALIZED?$AA@ ; `string'
PUBLIC	??_C@_0BG@ECPOFDO@CKR_USER_TYPE_INVALID?$AA@	; `string'
PUBLIC	??_C@_0CD@GJCCPLNL@CKR_USER_ANOTHER_ALREADY_LOGGED_@ ; `string'
PUBLIC	??_C@_0BI@MGNIFGMM@CKR_USER_TOO_MANY_TYPES?$AA@	; `string'
PUBLIC	??_C@_0BI@CPLHFH@CKR_WRAPPED_KEY_INVALID?$AA@	; `string'
PUBLIC	??_C@_0BK@MCPGJNEM@CKR_WRAPPED_KEY_LEN_RANGE?$AA@ ; `string'
PUBLIC	??_C@_0CA@DLBMIHED@CKR_WRAPPING_KEY_HANDLE_INVALID?$AA@ ; `string'
PUBLIC	??_C@_0BM@OCCHBGKK@CKR_WRAPPING_KEY_SIZE_RANGE?$AA@ ; `string'
PUBLIC	??_C@_0CD@FOJGMFK@CKR_WRAPPING_KEY_TYPE_INCONSISTE@ ; `string'
PUBLIC	??_C@_0BO@GILEANPO@CKR_RANDOM_SEED_NOT_SUPPORTED?$AA@ ; `string'
PUBLIC	??_C@_0BC@JEFNGGNK@CKR_RANDOM_NO_RNG?$AA@	; `string'
PUBLIC	??_C@_0BK@MMHDGADE@CKR_DOMAIN_PARAMS_INVALID?$AA@ ; `string'
PUBLIC	??_C@_0BF@DHOMKFCE@CKR_BUFFER_TOO_SMALL?$AA@	; `string'
PUBLIC	??_C@_0BI@JPLEOJGD@CKR_SAVED_STATE_INVALID?$AA@	; `string'
PUBLIC	??_C@_0BK@NJDKONLD@CKR_INFORMATION_SENSITIVE?$AA@ ; `string'
PUBLIC	??_C@_0BF@EAMMCHLP@CKR_STATE_UNSAVEABLE?$AA@	; `string'
PUBLIC	??_C@_0BN@ODFNBLKM@CKR_CRYPTOKI_NOT_INITIALIZED?$AA@ ; `string'
PUBLIC	??_C@_0CB@JBBGANIO@CKR_CRYPTOKI_ALREADY_INITIALIZED@ ; `string'
PUBLIC	??_C@_0O@GIMOJHGA@CKR_MUTEX_BAD?$AA@		; `string'
PUBLIC	??_C@_0BF@NLNAHNBM@CKR_MUTEX_NOT_LOCKED?$AA@	; `string'
PUBLIC	??_C@_0BB@NJDNOJFN@CKR_NEW_PIN_MODE?$AA@	; `string'
PUBLIC	??_C@_0N@IBMCNMKC@CKR_NEXT_OTP?$AA@		; `string'
PUBLIC	??_C@_0BG@GCNMIEKF@CKR_FUNCTION_REJECTED?$AA@	; `string'
PUBLIC	??_C@_02MDDDDAID@0x?$AA@			; `string'
PUBLIC	??_C@_15ELOONFKJ@?$AA?3?$AA?5?$AA?$AA@		; `string'
PUBLIC	??_C@_04DIIAEOAC@CKR_?$AA@			; `string'
PUBLIC	??_C@_0BF@NKGFDJIN@SECURITY_TOKEN_ERROR?$AA@	; `string'
PUBLIC	??_C@_1BG@PNNJJJBG@?$AA?$CF?$AAs?$AA?3?$AA?6?$AA?6?$AA?$CF?$AAh?$AAs?$AA?$CF?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@FLCMNAGD@?$AA?6?$AA?6?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAc?$AAo?$AAd?$AAe?$AA?$AA@ ; `string'
PUBLIC	?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
PUBLIC	??_7?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@ ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`vftable'
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	??_C@_02BBAHNLBA@?$CFp?$AA@			; `string'
PUBLIC	??_C@_02CLHGNPPK@Lu?$AA@			; `string'
PUBLIC	??_C@_02HIKPPMOK@Ld?$AA@			; `string'
PUBLIC	??_C@_02BDDLJJBK@lu?$AA@			; `string'
PUBLIC	??_C@_02EAOCLKAK@ld?$AA@			; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	??_7?$numpunct@D@std@@6B@			; std::numpunct<char>::`vftable'
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_7?$numpunct@_W@std@@6B@			; std::numpunct<wchar_t>::`vftable'
PUBLIC	??_C@_02MDKMJEGG@eE?$AA@			; `string'
PUBLIC	??_C@_02OOPEBDOJ@pP?$AA@			; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Static
PUBLIC	?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<wchar_t> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ios_base@std@@6B@				; std::ios_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R4?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@_W@std@@6B@			; std::ctype<wchar_t>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@_W@std@@@8			; std::ctype<wchar_t> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@_W@std@@8				; std::ctype<wchar_t>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@_W@std@@8				; std::ctype<wchar_t>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@_W@std@@8			; std::ctype<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Container@ForEach@GostCrypt@@6B@		; GostCrypt::ForEach::Container::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUContainer@ForEach@GostCrypt@@@8		; GostCrypt::ForEach::Container `RTTI Type Descriptor'
PUBLIC	??_R3Container@ForEach@GostCrypt@@8		; GostCrypt::ForEach::Container::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Container@ForEach@GostCrypt@@8		; GostCrypt::ForEach::Container::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8	; GostCrypt::ForEach::Container::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Exception@GostCrypt@@6B@			; GostCrypt::Exception::`RTTI Complete Object Locator'
PUBLIC	??_R3Exception@GostCrypt@@8			; GostCrypt::Exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Exception@GostCrypt@@8			; GostCrypt::Exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Exception@GostCrypt@@8		; GostCrypt::Exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4SystemException@GostCrypt@@6B@		; GostCrypt::SystemException::`RTTI Complete Object Locator'
PUBLIC	??_R3SystemException@GostCrypt@@8		; GostCrypt::SystemException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SystemException@GostCrypt@@8		; GostCrypt::SystemException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SystemException@GostCrypt@@8	; GostCrypt::SystemException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ParameterIncorrect@GostCrypt@@6B@		; GostCrypt::ParameterIncorrect::`RTTI Complete Object Locator'
PUBLIC	??_R3ParameterIncorrect@GostCrypt@@8		; GostCrypt::ParameterIncorrect::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ParameterIncorrect@GostCrypt@@8		; GostCrypt::ParameterIncorrect::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ParameterIncorrect@GostCrypt@@8	; GostCrypt::ParameterIncorrect::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Pkcs11Exception@GostCrypt@@6B@		; GostCrypt::Pkcs11Exception::`RTTI Complete Object Locator'
PUBLIC	??_R3Pkcs11Exception@GostCrypt@@8		; GostCrypt::Pkcs11Exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Pkcs11Exception@GostCrypt@@8		; GostCrypt::Pkcs11Exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Pkcs11Exception@GostCrypt@@8	; GostCrypt::Pkcs11Exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4SecurityTokenLibraryNotInitialized@GostCrypt@@6B@ ; GostCrypt::SecurityTokenLibraryNotInitialized::`RTTI Complete Object Locator'
PUBLIC	??_R3SecurityTokenLibraryNotInitialized@GostCrypt@@8 ; GostCrypt::SecurityTokenLibraryNotInitialized::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SecurityTokenLibraryNotInitialized@GostCrypt@@8 ; GostCrypt::SecurityTokenLibraryNotInitialized::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SecurityTokenLibraryNotInitialized@GostCrypt@@8 ; GostCrypt::SecurityTokenLibraryNotInitialized::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4InvalidSecurityTokenKeyfilePath@GostCrypt@@6B@ ; GostCrypt::InvalidSecurityTokenKeyfilePath::`RTTI Complete Object Locator'
PUBLIC	??_R3InvalidSecurityTokenKeyfilePath@GostCrypt@@8 ; GostCrypt::InvalidSecurityTokenKeyfilePath::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2InvalidSecurityTokenKeyfilePath@GostCrypt@@8 ; GostCrypt::InvalidSecurityTokenKeyfilePath::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@InvalidSecurityTokenKeyfilePath@GostCrypt@@8 ; GostCrypt::InvalidSecurityTokenKeyfilePath::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4SecurityTokenKeyfileAlreadyExists@GostCrypt@@6B@ ; GostCrypt::SecurityTokenKeyfileAlreadyExists::`RTTI Complete Object Locator'
PUBLIC	??_R3SecurityTokenKeyfileAlreadyExists@GostCrypt@@8 ; GostCrypt::SecurityTokenKeyfileAlreadyExists::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SecurityTokenKeyfileAlreadyExists@GostCrypt@@8 ; GostCrypt::SecurityTokenKeyfileAlreadyExists::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SecurityTokenKeyfileAlreadyExists@GostCrypt@@8 ; GostCrypt::SecurityTokenKeyfileAlreadyExists::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4SecurityTokenKeyfileNotFound@GostCrypt@@6B@ ; GostCrypt::SecurityTokenKeyfileNotFound::`RTTI Complete Object Locator'
PUBLIC	??_R3SecurityTokenKeyfileNotFound@GostCrypt@@8	; GostCrypt::SecurityTokenKeyfileNotFound::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SecurityTokenKeyfileNotFound@GostCrypt@@8	; GostCrypt::SecurityTokenKeyfileNotFound::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SecurityTokenKeyfileNotFound@GostCrypt@@8 ; GostCrypt::SecurityTokenKeyfileNotFound::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@ ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > > `RTTI Type Descriptor'
PUBLIC	??_R3?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$numpunct@_W@std@@6B@			; std::numpunct<wchar_t>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$numpunct@_W@std@@@8			; std::numpunct<wchar_t> `RTTI Type Descriptor'
PUBLIC	??_R3?$numpunct@_W@std@@8			; std::numpunct<wchar_t>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@_W@std@@8			; std::numpunct<wchar_t>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@_W@std@@8		; std::numpunct<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$numpunct@D@std@@6B@			; std::numpunct<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$numpunct@D@std@@@8			; std::numpunct<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@D@std@@8		; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@4202a05f20000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	_frexp:PROC
EXTRN	_memchr:PROC
EXTRN	_memmove:PROC
EXTRN	___stdio_common_vswscanf:PROC
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	___stdio_common_vsprintf_s:PROC
EXTRN	_strcspn:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	_localeconv:PROC
EXTRN	__Getctype:PROC
EXTRN	__Getcvt:PROC
EXTRN	__Mbrtowc:PROC
EXTRN	__Tolower:PROC
EXTRN	__Toupper:PROC
EXTRN	__Wcrtomb:PROC
EXTRN	__Getwctype:PROC
EXTRN	__Getwctypes:PROC
EXTRN	__Towlower:PROC
EXTRN	__Towupper:PROC
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_E_Facet_base@std@@UAEPAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	??_Efacet@locale@std@@MAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	?_Init@locale@std@@CAPAV_Locimp@12@_N@Z:PROC	; std::locale::_Init
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	??_E?$ctype@_W@std@@MAEPAXI@Z:PROC		; std::ctype<wchar_t>::`vector deleting destructor'
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	??_E_System_error@std@@UAEPAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	?_Addstd@ios_base@std@@SAXPAV12@@Z:PROC		; std::ios_base::_Addstd
EXTRN	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z:PROC	; std::ios_base::_Ios_base_dtor
EXTRN	??_Eios_base@std@@UAEPAXI@Z:PROC		; std::ios_base::`vector deleting destructor'
EXTRN	??_EContainer@ForEach@GostCrypt@@UAEPAXI@Z:PROC	; GostCrypt::ForEach::Container::`vector deleting destructor'
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__wsprintfW:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_GetDictionaryValue:PROC
EXTRN	_GetString:PROC
EXTRN	_handleWin32Error:PROC
EXTRN	_Error:PROC
EXTRN	_ErrorDirect:PROC
EXTRN	?Utf8StringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:PROC ; Utf8StringToWide
EXTRN	??_E?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UAEPAXI@Z:PROC ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::`vector deleting destructor'
EXTRN	??_E?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z:PROC ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::`vector deleting destructor'
EXTRN	??_E?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z:PROC ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::`vector deleting destructor'
EXTRN	??_E?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z:PROC ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::`vector deleting destructor'
EXTRN	??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ios<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_iostream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_E?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`vector deleting destructor'
EXTRN	??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	??_E?$numpunct@D@std@@MAEPAXI@Z:PROC		; std::numpunct<char>::`vector deleting destructor'
EXTRN	??_E?$numpunct@_W@std@@MAEPAXI@Z:PROC		; std::numpunct<wchar_t>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	?_BADOFF@std@@3_JB:QWORD			; std::_BADOFF
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	?id@?$ctype@_W@std@@2V0locale@2@A:DWORD		; std::ctype<wchar_t>::id
EXTRN	_SecurityTokenLibraryPath:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?PinCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@A DD 01H DUP (?) ; GostCrypt::SecurityToken::PinCallback
?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A DQ 01H DUP (?) ; GostCrypt::SecurityToken::Sessions
?WarningCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@A DD 01H DUP (?) ; GostCrypt::SecurityToken::WarningCallback
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A
_BSS	SEGMENT
?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A DQ 01H DUP (?) ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Static
_BSS	ENDS
;	COMDAT ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA
_BSS	SEGMENT
?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<wchar_t> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
_BSS	ENDS
CRT$XCU	SEGMENT
??PinCallback$initializer$@SecurityToken@GostCrypt@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?PinCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@A@@YAXXZ ; GostCrypt::SecurityToken::inCallback$initializer$::operator>=
CRT$XCU	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+10
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@D@std@@8 DD FLAT:??_R0?AV?$numpunct@D@std@@@8 ; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@D@std@@8 ; std::numpunct<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@D@std@@8 DD 00H				; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
data$r	SEGMENT
??_R0?AV?$numpunct@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::numpunct<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@D@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@D@std@@6B@ DD 00H			; std::numpunct<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@D@std@@@8
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@_W@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@_W@std@@8 DD FLAT:??_R0?AV?$numpunct@_W@std@@@8 ; std::numpunct<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@_W@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@_W@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@_W@std@@8 ; std::numpunct<wchar_t>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@_W@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@_W@std@@8 DD 00H			; std::numpunct<wchar_t>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$numpunct@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@_W@std@@@8
data$r	SEGMENT
??_R0?AV?$numpunct@_W@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::numpunct<wchar_t> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@_W@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$numpunct@_W@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@_W@std@@6B@ DD 00H			; std::numpunct<wchar_t>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@_W@std@@@8
	DD	FLAT:??_R3?$numpunct@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8 DD FLAT:??_R0?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R2?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R3?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8 DD 00H ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@@8
data$r	SEGMENT
??_R0?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@s'
	DB	'td@@@ForEach@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@ DD 00H ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@@8
	DD	FLAT:??_R3?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8 DD FLAT:??_R0?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R2?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R3?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8 DD 00H ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@@8
data$r	SEGMENT
??_R0?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std'
	DB	'@@@ForEach@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@ DD 00H ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@@8
	DD	FLAT:??_R3?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 DD FLAT:??_R0?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R2?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R3?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 DD 00H ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8
data$r	SEGMENT
??_R0?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@G'
	DB	'ostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@'
	DB	'@@std@@@ForEach@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ DD 00H ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8
	DD	FLAT:??_R3?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@8 DD FLAT:??_R0?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R2?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R3?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@8 DD 00H ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@@8
data$r	SEGMENT
??_R0?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@'
	DB	'@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@Gost'
	DB	'Crypt@@@std@@@4@@std@@@ForEach@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@6B@ DD 00H ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@@8
	DD	FLAT:??_R3?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8 DD 00H ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@'
	DB	'_W@std@@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@ DD 00H ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SecurityTokenKeyfileNotFound@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SecurityTokenKeyfileNotFound@GostCrypt@@8 DD FLAT:??_R0?AUSecurityTokenKeyfileNotFound@GostCrypt@@@8 ; GostCrypt::SecurityTokenKeyfileNotFound::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SecurityTokenKeyfileNotFound@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2SecurityTokenKeyfileNotFound@GostCrypt@@8
rdata$r	SEGMENT
??_R2SecurityTokenKeyfileNotFound@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@SecurityTokenKeyfileNotFound@GostCrypt@@8 ; GostCrypt::SecurityTokenKeyfileNotFound::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3SecurityTokenKeyfileNotFound@GostCrypt@@8
rdata$r	SEGMENT
??_R3SecurityTokenKeyfileNotFound@GostCrypt@@8 DD 00H	; GostCrypt::SecurityTokenKeyfileNotFound::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2SecurityTokenKeyfileNotFound@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R4SecurityTokenKeyfileNotFound@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4SecurityTokenKeyfileNotFound@GostCrypt@@6B@ DD 00H	; GostCrypt::SecurityTokenKeyfileNotFound::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUSecurityTokenKeyfileNotFound@GostCrypt@@@8
	DD	FLAT:??_R3SecurityTokenKeyfileNotFound@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SecurityTokenKeyfileAlreadyExists@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SecurityTokenKeyfileAlreadyExists@GostCrypt@@8 DD FLAT:??_R0?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@@8 ; GostCrypt::SecurityTokenKeyfileAlreadyExists::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SecurityTokenKeyfileAlreadyExists@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2SecurityTokenKeyfileAlreadyExists@GostCrypt@@8
rdata$r	SEGMENT
??_R2SecurityTokenKeyfileAlreadyExists@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@SecurityTokenKeyfileAlreadyExists@GostCrypt@@8 ; GostCrypt::SecurityTokenKeyfileAlreadyExists::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3SecurityTokenKeyfileAlreadyExists@GostCrypt@@8
rdata$r	SEGMENT
??_R3SecurityTokenKeyfileAlreadyExists@GostCrypt@@8 DD 00H ; GostCrypt::SecurityTokenKeyfileAlreadyExists::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2SecurityTokenKeyfileAlreadyExists@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R4SecurityTokenKeyfileAlreadyExists@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4SecurityTokenKeyfileAlreadyExists@GostCrypt@@6B@ DD 00H ; GostCrypt::SecurityTokenKeyfileAlreadyExists::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@@8
	DD	FLAT:??_R3SecurityTokenKeyfileAlreadyExists@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@InvalidSecurityTokenKeyfilePath@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@InvalidSecurityTokenKeyfilePath@GostCrypt@@8 DD FLAT:??_R0?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@@8 ; GostCrypt::InvalidSecurityTokenKeyfilePath::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3InvalidSecurityTokenKeyfilePath@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2InvalidSecurityTokenKeyfilePath@GostCrypt@@8
rdata$r	SEGMENT
??_R2InvalidSecurityTokenKeyfilePath@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@InvalidSecurityTokenKeyfilePath@GostCrypt@@8 ; GostCrypt::InvalidSecurityTokenKeyfilePath::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3InvalidSecurityTokenKeyfilePath@GostCrypt@@8
rdata$r	SEGMENT
??_R3InvalidSecurityTokenKeyfilePath@GostCrypt@@8 DD 00H ; GostCrypt::InvalidSecurityTokenKeyfilePath::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2InvalidSecurityTokenKeyfilePath@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R4InvalidSecurityTokenKeyfilePath@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4InvalidSecurityTokenKeyfilePath@GostCrypt@@6B@ DD 00H ; GostCrypt::InvalidSecurityTokenKeyfilePath::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@@8
	DD	FLAT:??_R3InvalidSecurityTokenKeyfilePath@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SecurityTokenLibraryNotInitialized@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SecurityTokenLibraryNotInitialized@GostCrypt@@8 DD FLAT:??_R0?AUSecurityTokenLibraryNotInitialized@GostCrypt@@@8 ; GostCrypt::SecurityTokenLibraryNotInitialized::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SecurityTokenLibraryNotInitialized@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2SecurityTokenLibraryNotInitialized@GostCrypt@@8
rdata$r	SEGMENT
??_R2SecurityTokenLibraryNotInitialized@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@SecurityTokenLibraryNotInitialized@GostCrypt@@8 ; GostCrypt::SecurityTokenLibraryNotInitialized::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3SecurityTokenLibraryNotInitialized@GostCrypt@@8
rdata$r	SEGMENT
??_R3SecurityTokenLibraryNotInitialized@GostCrypt@@8 DD 00H ; GostCrypt::SecurityTokenLibraryNotInitialized::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2SecurityTokenLibraryNotInitialized@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R4SecurityTokenLibraryNotInitialized@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4SecurityTokenLibraryNotInitialized@GostCrypt@@6B@ DD 00H ; GostCrypt::SecurityTokenLibraryNotInitialized::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUSecurityTokenLibraryNotInitialized@GostCrypt@@@8
	DD	FLAT:??_R3SecurityTokenLibraryNotInitialized@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Pkcs11Exception@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Pkcs11Exception@GostCrypt@@8 DD FLAT:??_R0?AUPkcs11Exception@GostCrypt@@@8 ; GostCrypt::Pkcs11Exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Pkcs11Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2Pkcs11Exception@GostCrypt@@8
rdata$r	SEGMENT
??_R2Pkcs11Exception@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@Pkcs11Exception@GostCrypt@@8 ; GostCrypt::Pkcs11Exception::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3Pkcs11Exception@GostCrypt@@8
rdata$r	SEGMENT
??_R3Pkcs11Exception@GostCrypt@@8 DD 00H		; GostCrypt::Pkcs11Exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Pkcs11Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R4Pkcs11Exception@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4Pkcs11Exception@GostCrypt@@6B@ DD 00H		; GostCrypt::Pkcs11Exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUPkcs11Exception@GostCrypt@@@8
	DD	FLAT:??_R3Pkcs11Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ParameterIncorrect@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ParameterIncorrect@GostCrypt@@8 DD FLAT:??_R0?AUParameterIncorrect@GostCrypt@@@8 ; GostCrypt::ParameterIncorrect::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ParameterIncorrect@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2ParameterIncorrect@GostCrypt@@8
rdata$r	SEGMENT
??_R2ParameterIncorrect@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@ParameterIncorrect@GostCrypt@@8 ; GostCrypt::ParameterIncorrect::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3ParameterIncorrect@GostCrypt@@8
rdata$r	SEGMENT
??_R3ParameterIncorrect@GostCrypt@@8 DD 00H		; GostCrypt::ParameterIncorrect::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ParameterIncorrect@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R4ParameterIncorrect@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4ParameterIncorrect@GostCrypt@@6B@ DD 00H		; GostCrypt::ParameterIncorrect::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUParameterIncorrect@GostCrypt@@@8
	DD	FLAT:??_R3ParameterIncorrect@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SystemException@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SystemException@GostCrypt@@8 DD FLAT:??_R0?AUSystemException@GostCrypt@@@8 ; GostCrypt::SystemException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SystemException@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2SystemException@GostCrypt@@8
rdata$r	SEGMENT
??_R2SystemException@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@SystemException@GostCrypt@@8 ; GostCrypt::SystemException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3SystemException@GostCrypt@@8
rdata$r	SEGMENT
??_R3SystemException@GostCrypt@@8 DD 00H		; GostCrypt::SystemException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2SystemException@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R4SystemException@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4SystemException@GostCrypt@@6B@ DD 00H		; GostCrypt::SystemException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUSystemException@GostCrypt@@@8
	DD	FLAT:??_R3SystemException@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Exception@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Exception@GostCrypt@@8 DD FLAT:??_R0?AUException@GostCrypt@@@8 ; GostCrypt::Exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2Exception@GostCrypt@@8
rdata$r	SEGMENT
??_R2Exception@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@Exception@GostCrypt@@8 ; GostCrypt::Exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Exception@GostCrypt@@8
rdata$r	SEGMENT
??_R3Exception@GostCrypt@@8 DD 00H			; GostCrypt::Exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R4Exception@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4Exception@GostCrypt@@6B@ DD 00H			; GostCrypt::Exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	FLAT:??_R3Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8 DD FLAT:??_R0?AUContainer@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::Container::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2Container@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R2Container@ForEach@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::Container::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Container@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R3Container@ForEach@GostCrypt@@8 DD 00H		; GostCrypt::ForEach::Container::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUContainer@ForEach@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUContainer@ForEach@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::ForEach::Container `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUContainer@ForEach@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_R4Container@ForEach@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4Container@ForEach@GostCrypt@@6B@ DD 00H		; GostCrypt::ForEach::Container::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUContainer@ForEach@GostCrypt@@@8
	DD	FLAT:??_R3Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD FLAT:??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 00H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@_W@std@@8 DD FLAT:??_R0?AV?$ctype@_W@std@@@8 ; std::ctype<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R2?$ctype@_W@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@_W@std@@8 ; std::ctype<wchar_t>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R3?$ctype@_W@std@@8 DD 00H				; std::ctype<wchar_t>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
data$r	SEGMENT
??_R0?AV?$ctype@_W@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<wchar_t> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@_W@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@_W@std@@6B@ DD 00H				; std::ctype<wchar_t>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@_W@std@@@8
	DD	FLAT:??_R3?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
data$r	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$r	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD FLAT:??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$r	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$r	ENDS
;	COMDAT ??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R13?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$r	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$r	SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Facet_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 00H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Facet_base@std@@@8
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	FLAT:??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$all'
	DB	'ocator@_W@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
	DD	068H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD 00H ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$alloca'
	DB	'tor@_W@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DD 00H ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	FLAT:??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	020H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	08H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	018H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	FLAT:??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$alloc'
	DB	'ator@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	068H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocato'
	DB	'r@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	FLAT:??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	020H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	08H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	018H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ios<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4ios_base@std@@6B@
rdata$r	SEGMENT
??_R4ios_base@std@@6B@ DD 00H				; std::ios_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVios_base@std@@@8
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OOPEBDOJ@pP?$AA@
CONST	SEGMENT
??_C@_02OOPEBDOJ@pP?$AA@ DB 'pP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDKMJEGG@eE?$AA@
CONST	SEGMENT
??_C@_02MDKMJEGG@eE?$AA@ DB 'eE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$numpunct@_W@std@@6B@
CONST	SEGMENT
??_7?$numpunct@_W@std@@6B@ DD FLAT:??_R4?$numpunct@_W@std@@6B@ ; std::numpunct<wchar_t>::`vftable'
	DD	FLAT:??_E?$numpunct@_W@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_decimal_point@?$numpunct@_W@std@@MBE_WXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@_W@std@@MBE_WXZ
	DD	FLAT:?do_grouping@?$numpunct@_W@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
CONST	ENDS
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT
??_7?$numpunct@D@std@@6B@ DD FLAT:??_R4?$numpunct@D@std@@6B@ ; std::numpunct<char>::`vftable'
	DD	FLAT:??_E?$numpunct@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_decimal_point@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
CONST	SEGMENT
??_C@_02EAOCLKAK@ld?$AA@ DB 'ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
CONST	SEGMENT
??_C@_02BDDLJJBK@lu?$AA@ DB 'lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld?$AA@ DB 'Ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu?$AA@ DB 'Lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp?$AA@ DB '%p', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
CONST	ENDS
;	COMDAT ??_7?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@ ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`vftable'
	DD	FLAT:??_E?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBX@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WJ@Z
	DD	FLAT:?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z
CONST	ENDS
;	COMDAT ??_C@_1BK@FLCMNAGD@?$AA?6?$AA?6?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAc?$AAo?$AAd?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@FLCMNAGD@?$AA?6?$AA?6?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAc?$AAo?$AAd?$AAe?$AA?$AA@ DB 0aH
	DB	00H, 0aH, 00H, 'E', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@PNNJJJBG@?$AA?$CF?$AAs?$AA?3?$AA?6?$AA?6?$AA?$CF?$AAh?$AAs?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@PNNJJJBG@?$AA?$CF?$AAs?$AA?3?$AA?6?$AA?6?$AA?$CF?$AAh?$AAs?$AA?$CF?$AAs?$AA?$AA@ DB '%'
	DB	00H, 's', 00H, ':', 00H, 0aH, 00H, 0aH, 00H, '%', 00H, 'h', 00H
	DB	's', 00H, '%', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NKGFDJIN@SECURITY_TOKEN_ERROR?$AA@
CONST	SEGMENT
??_C@_0BF@NKGFDJIN@SECURITY_TOKEN_ERROR?$AA@ DB 'SECURITY_TOKEN_ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DIIAEOAC@CKR_?$AA@
CONST	SEGMENT
??_C@_04DIIAEOAC@CKR_?$AA@ DB 'CKR_', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_15ELOONFKJ@?$AA?3?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_15ELOONFKJ@?$AA?3?$AA?5?$AA?$AA@ DB ':', 00H, ' ', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDDDDAID@0x?$AA@
CONST	SEGMENT
??_C@_02MDDDDAID@0x?$AA@ DB '0x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GCNMIEKF@CKR_FUNCTION_REJECTED?$AA@
CONST	SEGMENT
??_C@_0BG@GCNMIEKF@CKR_FUNCTION_REJECTED?$AA@ DB 'CKR_FUNCTION_REJECTED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IBMCNMKC@CKR_NEXT_OTP?$AA@
CONST	SEGMENT
??_C@_0N@IBMCNMKC@CKR_NEXT_OTP?$AA@ DB 'CKR_NEXT_OTP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NJDNOJFN@CKR_NEW_PIN_MODE?$AA@
CONST	SEGMENT
??_C@_0BB@NJDNOJFN@CKR_NEW_PIN_MODE?$AA@ DB 'CKR_NEW_PIN_MODE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NLNAHNBM@CKR_MUTEX_NOT_LOCKED?$AA@
CONST	SEGMENT
??_C@_0BF@NLNAHNBM@CKR_MUTEX_NOT_LOCKED?$AA@ DB 'CKR_MUTEX_NOT_LOCKED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GIMOJHGA@CKR_MUTEX_BAD?$AA@
CONST	SEGMENT
??_C@_0O@GIMOJHGA@CKR_MUTEX_BAD?$AA@ DB 'CKR_MUTEX_BAD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JBBGANIO@CKR_CRYPTOKI_ALREADY_INITIALIZED@
CONST	SEGMENT
??_C@_0CB@JBBGANIO@CKR_CRYPTOKI_ALREADY_INITIALIZED@ DB 'CKR_CRYPTOKI_ALR'
	DB	'EADY_INITIALIZED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ODFNBLKM@CKR_CRYPTOKI_NOT_INITIALIZED?$AA@
CONST	SEGMENT
??_C@_0BN@ODFNBLKM@CKR_CRYPTOKI_NOT_INITIALIZED?$AA@ DB 'CKR_CRYPTOKI_NOT'
	DB	'_INITIALIZED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EAMMCHLP@CKR_STATE_UNSAVEABLE?$AA@
CONST	SEGMENT
??_C@_0BF@EAMMCHLP@CKR_STATE_UNSAVEABLE?$AA@ DB 'CKR_STATE_UNSAVEABLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NJDKONLD@CKR_INFORMATION_SENSITIVE?$AA@
CONST	SEGMENT
??_C@_0BK@NJDKONLD@CKR_INFORMATION_SENSITIVE?$AA@ DB 'CKR_INFORMATION_SEN'
	DB	'SITIVE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JPLEOJGD@CKR_SAVED_STATE_INVALID?$AA@
CONST	SEGMENT
??_C@_0BI@JPLEOJGD@CKR_SAVED_STATE_INVALID?$AA@ DB 'CKR_SAVED_STATE_INVAL'
	DB	'ID', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DHOMKFCE@CKR_BUFFER_TOO_SMALL?$AA@
CONST	SEGMENT
??_C@_0BF@DHOMKFCE@CKR_BUFFER_TOO_SMALL?$AA@ DB 'CKR_BUFFER_TOO_SMALL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MMHDGADE@CKR_DOMAIN_PARAMS_INVALID?$AA@
CONST	SEGMENT
??_C@_0BK@MMHDGADE@CKR_DOMAIN_PARAMS_INVALID?$AA@ DB 'CKR_DOMAIN_PARAMS_I'
	DB	'NVALID', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JEFNGGNK@CKR_RANDOM_NO_RNG?$AA@
CONST	SEGMENT
??_C@_0BC@JEFNGGNK@CKR_RANDOM_NO_RNG?$AA@ DB 'CKR_RANDOM_NO_RNG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GILEANPO@CKR_RANDOM_SEED_NOT_SUPPORTED?$AA@
CONST	SEGMENT
??_C@_0BO@GILEANPO@CKR_RANDOM_SEED_NOT_SUPPORTED?$AA@ DB 'CKR_RANDOM_SEED'
	DB	'_NOT_SUPPORTED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FOJGMFK@CKR_WRAPPING_KEY_TYPE_INCONSISTE@
CONST	SEGMENT
??_C@_0CD@FOJGMFK@CKR_WRAPPING_KEY_TYPE_INCONSISTE@ DB 'CKR_WRAPPING_KEY_'
	DB	'TYPE_INCONSISTENT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OCCHBGKK@CKR_WRAPPING_KEY_SIZE_RANGE?$AA@
CONST	SEGMENT
??_C@_0BM@OCCHBGKK@CKR_WRAPPING_KEY_SIZE_RANGE?$AA@ DB 'CKR_WRAPPING_KEY_'
	DB	'SIZE_RANGE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DLBMIHED@CKR_WRAPPING_KEY_HANDLE_INVALID?$AA@
CONST	SEGMENT
??_C@_0CA@DLBMIHED@CKR_WRAPPING_KEY_HANDLE_INVALID?$AA@ DB 'CKR_WRAPPING_'
	DB	'KEY_HANDLE_INVALID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MCPGJNEM@CKR_WRAPPED_KEY_LEN_RANGE?$AA@
CONST	SEGMENT
??_C@_0BK@MCPGJNEM@CKR_WRAPPED_KEY_LEN_RANGE?$AA@ DB 'CKR_WRAPPED_KEY_LEN'
	DB	'_RANGE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CPLHFH@CKR_WRAPPED_KEY_INVALID?$AA@
CONST	SEGMENT
??_C@_0BI@CPLHFH@CKR_WRAPPED_KEY_INVALID?$AA@ DB 'CKR_WRAPPED_KEY_INVALID'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MGNIFGMM@CKR_USER_TOO_MANY_TYPES?$AA@
CONST	SEGMENT
??_C@_0BI@MGNIFGMM@CKR_USER_TOO_MANY_TYPES?$AA@ DB 'CKR_USER_TOO_MANY_TYP'
	DB	'ES', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GJCCPLNL@CKR_USER_ANOTHER_ALREADY_LOGGED_@
CONST	SEGMENT
??_C@_0CD@GJCCPLNL@CKR_USER_ANOTHER_ALREADY_LOGGED_@ DB 'CKR_USER_ANOTHER'
	DB	'_ALREADY_LOGGED_IN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ECPOFDO@CKR_USER_TYPE_INVALID?$AA@
CONST	SEGMENT
??_C@_0BG@ECPOFDO@CKR_USER_TYPE_INVALID?$AA@ DB 'CKR_USER_TYPE_INVALID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CJFMMEDO@CKR_USER_PIN_NOT_INITIALIZED?$AA@
CONST	SEGMENT
??_C@_0BN@CJFMMEDO@CKR_USER_PIN_NOT_INITIALIZED?$AA@ DB 'CKR_USER_PIN_NOT'
	DB	'_INITIALIZED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PHIJDFPC@CKR_USER_NOT_LOGGED_IN?$AA@
CONST	SEGMENT
??_C@_0BH@PHIJDFPC@CKR_USER_NOT_LOGGED_IN?$AA@ DB 'CKR_USER_NOT_LOGGED_IN'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HHCLDMIB@CKR_USER_ALREADY_LOGGED_IN?$AA@
CONST	SEGMENT
??_C@_0BL@HHCLDMIB@CKR_USER_ALREADY_LOGGED_IN?$AA@ DB 'CKR_USER_ALREADY_L'
	DB	'OGGED_IN', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FNADNHJM@CKR_UNWRAPPING_KEY_TYPE_INCONSIS@
CONST	SEGMENT
??_C@_0CF@FNADNHJM@CKR_UNWRAPPING_KEY_TYPE_INCONSIS@ DB 'CKR_UNWRAPPING_K'
	DB	'EY_TYPE_INCONSISTENT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EDNGDMCF@CKR_UNWRAPPING_KEY_SIZE_RANGE?$AA@
CONST	SEGMENT
??_C@_0BO@EDNGDMCF@CKR_UNWRAPPING_KEY_SIZE_RANGE?$AA@ DB 'CKR_UNWRAPPING_'
	DB	'KEY_SIZE_RANGE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BHIKKBJK@CKR_UNWRAPPING_KEY_HANDLE_INVALI@
CONST	SEGMENT
??_C@_0CC@BHIKKBJK@CKR_UNWRAPPING_KEY_HANDLE_INVALI@ DB 'CKR_UNWRAPPING_K'
	DB	'EY_HANDLE_INVALID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LICPHIEK@CKR_TOKEN_WRITE_PROTECTED?$AA@
CONST	SEGMENT
??_C@_0BK@LICPHIEK@CKR_TOKEN_WRITE_PROTECTED?$AA@ DB 'CKR_TOKEN_WRITE_PRO'
	DB	'TECTED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DKIDJOKM@CKR_TOKEN_NOT_RECOGNIZED?$AA@
CONST	SEGMENT
??_C@_0BJ@DKIDJOKM@CKR_TOKEN_NOT_RECOGNIZED?$AA@ DB 'CKR_TOKEN_NOT_RECOGN'
	DB	'IZED', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GJCOFLCP@CKR_TOKEN_NOT_PRESENT?$AA@
CONST	SEGMENT
??_C@_0BG@GJCOFLCP@CKR_TOKEN_NOT_PRESENT?$AA@ DB 'CKR_TOKEN_NOT_PRESENT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NFOMODKD@CKR_TEMPLATE_INCONSISTENT?$AA@
CONST	SEGMENT
??_C@_0BK@NFOMODKD@CKR_TEMPLATE_INCONSISTENT?$AA@ DB 'CKR_TEMPLATE_INCONS'
	DB	'ISTENT', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OKLBFCJN@CKR_TEMPLATE_INCOMPLETE?$AA@
CONST	SEGMENT
??_C@_0BI@OKLBFCJN@CKR_TEMPLATE_INCOMPLETE?$AA@ DB 'CKR_TEMPLATE_INCOMPLE'
	DB	'TE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BCEJLCCN@CKR_SIGNATURE_LEN_RANGE?$AA@
CONST	SEGMENT
??_C@_0BI@BCEJLCCN@CKR_SIGNATURE_LEN_RANGE?$AA@ DB 'CKR_SIGNATURE_LEN_RAN'
	DB	'GE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FJFGJBPL@CKR_SIGNATURE_INVALID?$AA@
CONST	SEGMENT
??_C@_0BG@FJFGJBPL@CKR_SIGNATURE_INVALID?$AA@ DB 'CKR_SIGNATURE_INVALID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MOHOJDLI@CKR_SESSION_READ_WRITE_SO_EXISTS@
CONST	SEGMENT
??_C@_0CB@MOHOJDLI@CKR_SESSION_READ_WRITE_SO_EXISTS@ DB 'CKR_SESSION_READ'
	DB	'_WRITE_SO_EXISTS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FEECMDLD@CKR_SESSION_READ_ONLY_EXISTS?$AA@
CONST	SEGMENT
??_C@_0BN@FEECMDLD@CKR_SESSION_READ_ONLY_EXISTS?$AA@ DB 'CKR_SESSION_READ'
	DB	'_ONLY_EXISTS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CJEENIOI@CKR_SESSION_EXISTS?$AA@
CONST	SEGMENT
??_C@_0BD@CJEENIOI@CKR_SESSION_EXISTS?$AA@ DB 'CKR_SESSION_EXISTS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NACFPKBK@CKR_SESSION_READ_ONLY?$AA@
CONST	SEGMENT
??_C@_0BG@NACFPKBK@CKR_SESSION_READ_ONLY?$AA@ DB 'CKR_SESSION_READ_ONLY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CNJKDODF@CKR_SESSION_PARALLEL_NOT_SUPPORT@
CONST	SEGMENT
??_C@_0CD@CNJKDODF@CKR_SESSION_PARALLEL_NOT_SUPPORT@ DB 'CKR_SESSION_PARA'
	DB	'LLEL_NOT_SUPPORTED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JFEIAJEO@CKR_SESSION_HANDLE_INVALID?$AA@
CONST	SEGMENT
??_C@_0BL@JFEIAJEO@CKR_SESSION_HANDLE_INVALID?$AA@ DB 'CKR_SESSION_HANDLE'
	DB	'_INVALID', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GFNLAALM@CKR_SESSION_COUNT?$AA@
CONST	SEGMENT
??_C@_0BC@GFNLAALM@CKR_SESSION_COUNT?$AA@ DB 'CKR_SESSION_COUNT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EFPEBFCO@CKR_SESSION_CLOSED?$AA@
CONST	SEGMENT
??_C@_0BD@EFPEBFCO@CKR_SESSION_CLOSED?$AA@ DB 'CKR_SESSION_CLOSED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JGPCDBMN@CKR_PIN_LOCKED?$AA@
CONST	SEGMENT
??_C@_0P@JGPCDBMN@CKR_PIN_LOCKED?$AA@ DB 'CKR_PIN_LOCKED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PPOOFJBC@CKR_PIN_EXPIRED?$AA@
CONST	SEGMENT
??_C@_0BA@PPOOFJBC@CKR_PIN_EXPIRED?$AA@ DB 'CKR_PIN_EXPIRED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MEAAAEMN@CKR_PIN_LEN_RANGE?$AA@
CONST	SEGMENT
??_C@_0BC@MEAAAEMN@CKR_PIN_LEN_RANGE?$AA@ DB 'CKR_PIN_LEN_RANGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PDLKJELN@CKR_PIN_INVALID?$AA@
CONST	SEGMENT
??_C@_0BA@PDLKJELN@CKR_PIN_INVALID?$AA@ DB 'CKR_PIN_INVALID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PIDGDJNE@CKR_PIN_INCORRECT?$AA@
CONST	SEGMENT
??_C@_0BC@PIDGDJNE@CKR_PIN_INCORRECT?$AA@ DB 'CKR_PIN_INCORRECT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NIGNIKB@CKR_OPERATION_NOT_INITIALIZED?$AA@
CONST	SEGMENT
??_C@_0BO@NIGNIKB@CKR_OPERATION_NOT_INITIALIZED?$AA@ DB 'CKR_OPERATION_NO'
	DB	'T_INITIALIZED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LACBDJFM@CKR_OPERATION_ACTIVE?$AA@
CONST	SEGMENT
??_C@_0BF@LACBDJFM@CKR_OPERATION_ACTIVE?$AA@ DB 'CKR_OPERATION_ACTIVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NIGFIGL@CKR_OBJECT_HANDLE_INVALID?$AA@
CONST	SEGMENT
??_C@_0BK@NIGFIGL@CKR_OBJECT_HANDLE_INVALID?$AA@ DB 'CKR_OBJECT_HANDLE_IN'
	DB	'VALID', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NHMBLBHF@CKR_MECHANISM_PARAM_INVALID?$AA@
CONST	SEGMENT
??_C@_0BM@NHMBLBHF@CKR_MECHANISM_PARAM_INVALID?$AA@ DB 'CKR_MECHANISM_PAR'
	DB	'AM_INVALID', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FIBINAPL@CKR_MECHANISM_INVALID?$AA@
CONST	SEGMENT
??_C@_0BG@FIBINAPL@CKR_MECHANISM_INVALID?$AA@ DB 'CKR_MECHANISM_INVALID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OIKHBDLJ@CKR_KEY_UNEXTRACTABLE?$AA@
CONST	SEGMENT
??_C@_0BG@OIKHBDLJ@CKR_KEY_UNEXTRACTABLE?$AA@ DB 'CKR_KEY_UNEXTRACTABLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IEKNAGOL@CKR_KEY_NOT_WRAPPABLE?$AA@
CONST	SEGMENT
??_C@_0BG@IEKNAGOL@CKR_KEY_NOT_WRAPPABLE?$AA@ DB 'CKR_KEY_NOT_WRAPPABLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PCNBFOEJ@CKR_KEY_FUNCTION_NOT_PERMITTED?$AA@
CONST	SEGMENT
??_C@_0BP@PCNBFOEJ@CKR_KEY_FUNCTION_NOT_PERMITTED?$AA@ DB 'CKR_KEY_FUNCTI'
	DB	'ON_NOT_PERMITTED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GCBGIGLD@CKR_KEY_INDIGESTIBLE?$AA@
CONST	SEGMENT
??_C@_0BF@GCBGIGLD@CKR_KEY_INDIGESTIBLE?$AA@ DB 'CKR_KEY_INDIGESTIBLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CIJPGKMN@CKR_KEY_NEEDED?$AA@
CONST	SEGMENT
??_C@_0P@CIJPGKMN@CKR_KEY_NEEDED?$AA@ DB 'CKR_KEY_NEEDED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PBNACHHM@CKR_KEY_CHANGED?$AA@
CONST	SEGMENT
??_C@_0BA@PBNACHHM@CKR_KEY_CHANGED?$AA@ DB 'CKR_KEY_CHANGED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CADJPHKC@CKR_KEY_NOT_NEEDED?$AA@
CONST	SEGMENT
??_C@_0BD@CADJPHKC@CKR_KEY_NOT_NEEDED?$AA@ DB 'CKR_KEY_NOT_NEEDED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FBLHAPGA@CKR_KEY_TYPE_INCONSISTENT?$AA@
CONST	SEGMENT
??_C@_0BK@FBLHAPGA@CKR_KEY_TYPE_INCONSISTENT?$AA@ DB 'CKR_KEY_TYPE_INCONS'
	DB	'ISTENT', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DCCEPOIK@CKR_KEY_SIZE_RANGE?$AA@
CONST	SEGMENT
??_C@_0BD@DCCEPOIK@CKR_KEY_SIZE_RANGE?$AA@ DB 'CKR_KEY_SIZE_RANGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JBCBCIHC@CKR_KEY_HANDLE_INVALID?$AA@
CONST	SEGMENT
??_C@_0BH@JBCBCIHC@CKR_KEY_HANDLE_INVALID?$AA@ DB 'CKR_KEY_HANDLE_INVALID'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FLCFPGMF@CKR_FUNCTION_NOT_SUPPORTED?$AA@
CONST	SEGMENT
??_C@_0BL@FLCFPGMF@CKR_FUNCTION_NOT_SUPPORTED?$AA@ DB 'CKR_FUNCTION_NOT_S'
	DB	'UPPORTED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CPMALGEH@CKR_FUNCTION_NOT_PARALLEL?$AA@
CONST	SEGMENT
??_C@_0BK@CPMALGEH@CKR_FUNCTION_NOT_PARALLEL?$AA@ DB 'CKR_FUNCTION_NOT_PA'
	DB	'RALLEL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GFNGJBLD@CKR_FUNCTION_CANCELED?$AA@
CONST	SEGMENT
??_C@_0BG@GFNGJBLD@CKR_FUNCTION_CANCELED?$AA@ DB 'CKR_FUNCTION_CANCELED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CHFIOLM@CKR_ENCRYPTED_DATA_LEN_RANGE?$AA@
CONST	SEGMENT
??_C@_0BN@CHFIOLM@CKR_ENCRYPTED_DATA_LEN_RANGE?$AA@ DB 'CKR_ENCRYPTED_DAT'
	DB	'A_LEN_RANGE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HMMBAKLE@CKR_ENCRYPTED_DATA_INVALID?$AA@
CONST	SEGMENT
??_C@_0BL@HMMBAKLE@CKR_ENCRYPTED_DATA_INVALID?$AA@ DB 'CKR_ENCRYPTED_DATA'
	DB	'_INVALID', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CLPGKOPG@CKR_DEVICE_REMOVED?$AA@
CONST	SEGMENT
??_C@_0BD@CLPGKOPG@CKR_DEVICE_REMOVED?$AA@ DB 'CKR_DEVICE_REMOVED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EDKNPIJF@CKR_DEVICE_MEMORY?$AA@
CONST	SEGMENT
??_C@_0BC@EDKNPIJF@CKR_DEVICE_MEMORY?$AA@ DB 'CKR_DEVICE_MEMORY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OAEPJIAO@CKR_DEVICE_ERROR?$AA@
CONST	SEGMENT
??_C@_0BB@OAEPJIAO@CKR_DEVICE_ERROR?$AA@ DB 'CKR_DEVICE_ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BPCFCEOF@CKR_DATA_LEN_RANGE?$AA@
CONST	SEGMENT
??_C@_0BD@BPCFCEOF@CKR_DATA_LEN_RANGE?$AA@ DB 'CKR_DATA_LEN_RANGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HONBBNLK@CKR_DATA_INVALID?$AA@
CONST	SEGMENT
??_C@_0BB@HONBBNLK@CKR_DATA_INVALID?$AA@ DB 'CKR_DATA_INVALID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LMONJDMA@CKR_ATTRIBUTE_VALUE_INVALID?$AA@
CONST	SEGMENT
??_C@_0BM@LMONJDMA@CKR_ATTRIBUTE_VALUE_INVALID?$AA@ DB 'CKR_ATTRIBUTE_VAL'
	DB	'UE_INVALID', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CJHMMHEH@CKR_ATTRIBUTE_TYPE_INVALID?$AA@
CONST	SEGMENT
??_C@_0BL@CJHMMHEH@CKR_ATTRIBUTE_TYPE_INVALID?$AA@ DB 'CKR_ATTRIBUTE_TYPE'
	DB	'_INVALID', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LPANBEIN@CKR_ATTRIBUTE_SENSITIVE?$AA@
CONST	SEGMENT
??_C@_0BI@LPANBEIN@CKR_ATTRIBUTE_SENSITIVE?$AA@ DB 'CKR_ATTRIBUTE_SENSITI'
	DB	'VE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IDDIMLAI@CKR_ATTRIBUTE_READ_ONLY?$AA@
CONST	SEGMENT
??_C@_0BI@IDDIMLAI@CKR_ATTRIBUTE_READ_ONLY?$AA@ DB 'CKR_ATTRIBUTE_READ_ON'
	DB	'LY', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OHMKMDKB@CKR_CANT_LOCK?$AA@
CONST	SEGMENT
??_C@_0O@OHMKMDKB@CKR_CANT_LOCK?$AA@ DB 'CKR_CANT_LOCK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NDINCBKJ@CKR_NEED_TO_CREATE_THREADS?$AA@
CONST	SEGMENT
??_C@_0BL@NDINCBKJ@CKR_NEED_TO_CREATE_THREADS?$AA@ DB 'CKR_NEED_TO_CREATE'
	DB	'_THREADS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KFPEOGN@CKR_NO_EVENT?$AA@
CONST	SEGMENT
??_C@_0N@KFPEOGN@CKR_NO_EVENT?$AA@ DB 'CKR_NO_EVENT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LNHMJFHC@CKR_ARGUMENTS_BAD?$AA@
CONST	SEGMENT
??_C@_0BC@LNHMJFHC@CKR_ARGUMENTS_BAD?$AA@ DB 'CKR_ARGUMENTS_BAD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DIFKEOGI@CKR_FUNCTION_FAILED?$AA@
CONST	SEGMENT
??_C@_0BE@DIFKEOGI@CKR_FUNCTION_FAILED?$AA@ DB 'CKR_FUNCTION_FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BPPOLCIH@CKR_GENERAL_ERROR?$AA@
CONST	SEGMENT
??_C@_0BC@BPPOLCIH@CKR_GENERAL_ERROR?$AA@ DB 'CKR_GENERAL_ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FOAEJLLC@CKR_SLOT_ID_INVALID?$AA@
CONST	SEGMENT
??_C@_0BE@FOAEJLLC@CKR_SLOT_ID_INVALID?$AA@ DB 'CKR_SLOT_ID_INVALID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HHDKGBBP@CKR_HOST_MEMORY?$AA@
CONST	SEGMENT
??_C@_0BA@HHDKGBBP@CKR_HOST_MEMORY?$AA@ DB 'CKR_HOST_MEMORY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JIDCKNME@CKR_CANCEL?$AA@
CONST	SEGMENT
??_C@_0L@JIDCKNME@CKR_CANCEL?$AA@ DB 'CKR_CANCEL', 00H	; `string'
CONST	ENDS
;	COMDAT ?ErrorStrings@?1???BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4QBU<unnamed-type-ErrorStrings>@?1???B12@QBE?AV34@XZ@B
CONST	SEGMENT
?ErrorStrings@?1???BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4QBU<unnamed-type-ErrorStrings>@?1???B12@QBE?AV34@XZ@B DD 01H ;  ?? ::B::XZ::`GostCrypt::Pkcs11Exception::operator std::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::QBU<unnamed-type-ErrorStrings>::std::XZ::`GostCrypt::Pkcs11Exception::operator std::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::ErrorStrings
	DD	FLAT:??_C@_0L@JIDCKNME@CKR_CANCEL?$AA@
	DD	02H
	DD	FLAT:??_C@_0BA@HHDKGBBP@CKR_HOST_MEMORY?$AA@
	DD	03H
	DD	FLAT:??_C@_0BE@FOAEJLLC@CKR_SLOT_ID_INVALID?$AA@
	DD	05H
	DD	FLAT:??_C@_0BC@BPPOLCIH@CKR_GENERAL_ERROR?$AA@
	DD	06H
	DD	FLAT:??_C@_0BE@DIFKEOGI@CKR_FUNCTION_FAILED?$AA@
	DD	07H
	DD	FLAT:??_C@_0BC@LNHMJFHC@CKR_ARGUMENTS_BAD?$AA@
	DD	08H
	DD	FLAT:??_C@_0N@KFPEOGN@CKR_NO_EVENT?$AA@
	DD	09H
	DD	FLAT:??_C@_0BL@NDINCBKJ@CKR_NEED_TO_CREATE_THREADS?$AA@
	DD	0aH
	DD	FLAT:??_C@_0O@OHMKMDKB@CKR_CANT_LOCK?$AA@
	DD	010H
	DD	FLAT:??_C@_0BI@IDDIMLAI@CKR_ATTRIBUTE_READ_ONLY?$AA@
	DD	011H
	DD	FLAT:??_C@_0BI@LPANBEIN@CKR_ATTRIBUTE_SENSITIVE?$AA@
	DD	012H
	DD	FLAT:??_C@_0BL@CJHMMHEH@CKR_ATTRIBUTE_TYPE_INVALID?$AA@
	DD	013H
	DD	FLAT:??_C@_0BM@LMONJDMA@CKR_ATTRIBUTE_VALUE_INVALID?$AA@
	DD	020H
	DD	FLAT:??_C@_0BB@HONBBNLK@CKR_DATA_INVALID?$AA@
	DD	021H
	DD	FLAT:??_C@_0BD@BPCFCEOF@CKR_DATA_LEN_RANGE?$AA@
	DD	030H
	DD	FLAT:??_C@_0BB@OAEPJIAO@CKR_DEVICE_ERROR?$AA@
	DD	031H
	DD	FLAT:??_C@_0BC@EDKNPIJF@CKR_DEVICE_MEMORY?$AA@
	DD	032H
	DD	FLAT:??_C@_0BD@CLPGKOPG@CKR_DEVICE_REMOVED?$AA@
	DD	040H
	DD	FLAT:??_C@_0BL@HMMBAKLE@CKR_ENCRYPTED_DATA_INVALID?$AA@
	DD	041H
	DD	FLAT:??_C@_0BN@CHFIOLM@CKR_ENCRYPTED_DATA_LEN_RANGE?$AA@
	DD	050H
	DD	FLAT:??_C@_0BG@GFNGJBLD@CKR_FUNCTION_CANCELED?$AA@
	DD	051H
	DD	FLAT:??_C@_0BK@CPMALGEH@CKR_FUNCTION_NOT_PARALLEL?$AA@
	DD	054H
	DD	FLAT:??_C@_0BL@FLCFPGMF@CKR_FUNCTION_NOT_SUPPORTED?$AA@
	DD	060H
	DD	FLAT:??_C@_0BH@JBCBCIHC@CKR_KEY_HANDLE_INVALID?$AA@
	DD	062H
	DD	FLAT:??_C@_0BD@DCCEPOIK@CKR_KEY_SIZE_RANGE?$AA@
	DD	063H
	DD	FLAT:??_C@_0BK@FBLHAPGA@CKR_KEY_TYPE_INCONSISTENT?$AA@
	DD	064H
	DD	FLAT:??_C@_0BD@CADJPHKC@CKR_KEY_NOT_NEEDED?$AA@
	DD	065H
	DD	FLAT:??_C@_0BA@PBNACHHM@CKR_KEY_CHANGED?$AA@
	DD	066H
	DD	FLAT:??_C@_0P@CIJPGKMN@CKR_KEY_NEEDED?$AA@
	DD	067H
	DD	FLAT:??_C@_0BF@GCBGIGLD@CKR_KEY_INDIGESTIBLE?$AA@
	DD	068H
	DD	FLAT:??_C@_0BP@PCNBFOEJ@CKR_KEY_FUNCTION_NOT_PERMITTED?$AA@
	DD	069H
	DD	FLAT:??_C@_0BG@IEKNAGOL@CKR_KEY_NOT_WRAPPABLE?$AA@
	DD	06aH
	DD	FLAT:??_C@_0BG@OIKHBDLJ@CKR_KEY_UNEXTRACTABLE?$AA@
	DD	070H
	DD	FLAT:??_C@_0BG@FIBINAPL@CKR_MECHANISM_INVALID?$AA@
	DD	071H
	DD	FLAT:??_C@_0BM@NHMBLBHF@CKR_MECHANISM_PARAM_INVALID?$AA@
	DD	082H
	DD	FLAT:??_C@_0BK@NIGFIGL@CKR_OBJECT_HANDLE_INVALID?$AA@
	DD	090H
	DD	FLAT:??_C@_0BF@LACBDJFM@CKR_OPERATION_ACTIVE?$AA@
	DD	091H
	DD	FLAT:??_C@_0BO@NIGNIKB@CKR_OPERATION_NOT_INITIALIZED?$AA@
	DD	0a0H
	DD	FLAT:??_C@_0BC@PIDGDJNE@CKR_PIN_INCORRECT?$AA@
	DD	0a1H
	DD	FLAT:??_C@_0BA@PDLKJELN@CKR_PIN_INVALID?$AA@
	DD	0a2H
	DD	FLAT:??_C@_0BC@MEAAAEMN@CKR_PIN_LEN_RANGE?$AA@
	DD	0a3H
	DD	FLAT:??_C@_0BA@PPOOFJBC@CKR_PIN_EXPIRED?$AA@
	DD	0a4H
	DD	FLAT:??_C@_0P@JGPCDBMN@CKR_PIN_LOCKED?$AA@
	DD	0b0H
	DD	FLAT:??_C@_0BD@EFPEBFCO@CKR_SESSION_CLOSED?$AA@
	DD	0b1H
	DD	FLAT:??_C@_0BC@GFNLAALM@CKR_SESSION_COUNT?$AA@
	DD	0b3H
	DD	FLAT:??_C@_0BL@JFEIAJEO@CKR_SESSION_HANDLE_INVALID?$AA@
	DD	0b4H
	DD	FLAT:??_C@_0CD@CNJKDODF@CKR_SESSION_PARALLEL_NOT_SUPPORT@
	DD	0b5H
	DD	FLAT:??_C@_0BG@NACFPKBK@CKR_SESSION_READ_ONLY?$AA@
	DD	0b6H
	DD	FLAT:??_C@_0BD@CJEENIOI@CKR_SESSION_EXISTS?$AA@
	DD	0b7H
	DD	FLAT:??_C@_0BN@FEECMDLD@CKR_SESSION_READ_ONLY_EXISTS?$AA@
	DD	0b8H
	DD	FLAT:??_C@_0CB@MOHOJDLI@CKR_SESSION_READ_WRITE_SO_EXISTS@
	DD	0c0H
	DD	FLAT:??_C@_0BG@FJFGJBPL@CKR_SIGNATURE_INVALID?$AA@
	DD	0c1H
	DD	FLAT:??_C@_0BI@BCEJLCCN@CKR_SIGNATURE_LEN_RANGE?$AA@
	DD	0d0H
	DD	FLAT:??_C@_0BI@OKLBFCJN@CKR_TEMPLATE_INCOMPLETE?$AA@
	DD	0d1H
	DD	FLAT:??_C@_0BK@NFOMODKD@CKR_TEMPLATE_INCONSISTENT?$AA@
	DD	0e0H
	DD	FLAT:??_C@_0BG@GJCOFLCP@CKR_TOKEN_NOT_PRESENT?$AA@
	DD	0e1H
	DD	FLAT:??_C@_0BJ@DKIDJOKM@CKR_TOKEN_NOT_RECOGNIZED?$AA@
	DD	0e2H
	DD	FLAT:??_C@_0BK@LICPHIEK@CKR_TOKEN_WRITE_PROTECTED?$AA@
	DD	0f0H
	DD	FLAT:??_C@_0CC@BHIKKBJK@CKR_UNWRAPPING_KEY_HANDLE_INVALI@
	DD	0f1H
	DD	FLAT:??_C@_0BO@EDNGDMCF@CKR_UNWRAPPING_KEY_SIZE_RANGE?$AA@
	DD	0f2H
	DD	FLAT:??_C@_0CF@FNADNHJM@CKR_UNWRAPPING_KEY_TYPE_INCONSIS@
	DD	0100H
	DD	FLAT:??_C@_0BL@HHCLDMIB@CKR_USER_ALREADY_LOGGED_IN?$AA@
	DD	0101H
	DD	FLAT:??_C@_0BH@PHIJDFPC@CKR_USER_NOT_LOGGED_IN?$AA@
	DD	0102H
	DD	FLAT:??_C@_0BN@CJFMMEDO@CKR_USER_PIN_NOT_INITIALIZED?$AA@
	DD	0103H
	DD	FLAT:??_C@_0BG@ECPOFDO@CKR_USER_TYPE_INVALID?$AA@
	DD	0104H
	DD	FLAT:??_C@_0CD@GJCCPLNL@CKR_USER_ANOTHER_ALREADY_LOGGED_@
	DD	0105H
	DD	FLAT:??_C@_0BI@MGNIFGMM@CKR_USER_TOO_MANY_TYPES?$AA@
	DD	0110H
	DD	FLAT:??_C@_0BI@CPLHFH@CKR_WRAPPED_KEY_INVALID?$AA@
	DD	0112H
	DD	FLAT:??_C@_0BK@MCPGJNEM@CKR_WRAPPED_KEY_LEN_RANGE?$AA@
	DD	0113H
	DD	FLAT:??_C@_0CA@DLBMIHED@CKR_WRAPPING_KEY_HANDLE_INVALID?$AA@
	DD	0114H
	DD	FLAT:??_C@_0BM@OCCHBGKK@CKR_WRAPPING_KEY_SIZE_RANGE?$AA@
	DD	0115H
	DD	FLAT:??_C@_0CD@FOJGMFK@CKR_WRAPPING_KEY_TYPE_INCONSISTE@
	DD	0120H
	DD	FLAT:??_C@_0BO@GILEANPO@CKR_RANDOM_SEED_NOT_SUPPORTED?$AA@
	DD	0121H
	DD	FLAT:??_C@_0BC@JEFNGGNK@CKR_RANDOM_NO_RNG?$AA@
	DD	0130H
	DD	FLAT:??_C@_0BK@MMHDGADE@CKR_DOMAIN_PARAMS_INVALID?$AA@
	DD	0150H
	DD	FLAT:??_C@_0BF@DHOMKFCE@CKR_BUFFER_TOO_SMALL?$AA@
	DD	0160H
	DD	FLAT:??_C@_0BI@JPLEOJGD@CKR_SAVED_STATE_INVALID?$AA@
	DD	0170H
	DD	FLAT:??_C@_0BK@NJDKONLD@CKR_INFORMATION_SENSITIVE?$AA@
	DD	0180H
	DD	FLAT:??_C@_0BF@EAMMCHLP@CKR_STATE_UNSAVEABLE?$AA@
	DD	0190H
	DD	FLAT:??_C@_0BN@ODFNBLKM@CKR_CRYPTOKI_NOT_INITIALIZED?$AA@
	DD	0191H
	DD	FLAT:??_C@_0CB@JBBGANIO@CKR_CRYPTOKI_ALREADY_INITIALIZED@
	DD	01a0H
	DD	FLAT:??_C@_0O@GIMOJHGA@CKR_MUTEX_BAD?$AA@
	DD	01a1H
	DD	FLAT:??_C@_0BF@NLNAHNBM@CKR_MUTEX_NOT_LOCKED?$AA@
	DD	01b0H
	DD	FLAT:??_C@_0BB@NJDNOJFN@CKR_NEW_PIN_MODE?$AA@
	DD	01b1H
	DD	FLAT:??_C@_0N@IBMCNMKC@CKR_NEXT_OTP?$AA@
	DD	0200H
	DD	FLAT:??_C@_0BG@GCNMIEKF@CKR_FUNCTION_REJECTED?$AA@
CONST	ENDS
;	COMDAT ??_C@_0BC@GHFGDNNP@C_GetFunctionList?$AA@
CONST	SEGMENT
??_C@_0BC@GHFGDNNP@C_GetFunctionList?$AA@ DB 'C_GetFunctionList', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AUSystemException@GostCrypt@@@8??0SystemException@GostCrypt@@QAE@ABU01@@Z8
xdata$x	SEGMENT
__CT??_R0?AUSystemException@GostCrypt@@@8??0SystemException@GostCrypt@@QAE@ABU01@@Z8 DD 00H
	DD	FLAT:??_R0?AUSystemException@GostCrypt@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	08H
	DD	FLAT:??0SystemException@GostCrypt@@QAE@ABU01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUSystemException@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUSystemException@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::SystemException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUSystemException@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AUSystemException@GostCrypt@@
xdata$x	SEGMENT
__CTA2?AUSystemException@GostCrypt@@ DD 02H
	DD	FLAT:__CT??_R0?AUSystemException@GostCrypt@@@8??0SystemException@GostCrypt@@QAE@ABU01@@Z8
	DD	FLAT:__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
xdata$x	ENDS
;	COMDAT __TI2?AUSystemException@GostCrypt@@
xdata$x	SEGMENT
__TI2?AUSystemException@GostCrypt@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2?AUSystemException@GostCrypt@@
xdata$x	ENDS
;	COMDAT ??_C@_01IPJKGB@?$CD?$AA@
CONST	SEGMENT
??_C@_01IPJKGB@?$CD?$AA@ DB '#', 00H			; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	058H
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	068H
CONST	ENDS
;	COMDAT ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
	DD	010H
CONST	ENDS
;	COMDAT ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
	DD	020H
CONST	ENDS
;	COMDAT ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_iostream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`vbtable'
	DD	08H
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_istream<char,std::char_traits<char> >::`vbtable'
	DD	018H
CONST	ENDS
;	COMDAT ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_1BC@ELBDEFGA@?$AAt?$AAo?$AAk?$AAe?$AAn?$AA?3?$AA?1?$AA?1?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@ELBDEFGA@?$AAt?$AAo?$AAk?$AAe?$AAn?$AA?3?$AA?1?$AA?1?$AA?$AA@ DB 't'
	DB	00H, 'o', 00H, 'k', 00H, 'e', 00H, 'n', 00H, ':', 00H, '/', 00H
	DB	'/', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KHBANPMA@GostCrypt?3?3SecurityToken?3?3GetObj@
CONST	SEGMENT
??_C@_0DB@KHBANPMA@GostCrypt?3?3SecurityToken?3?3GetObj@ DB 'GostCrypt::S'
	DB	'ecurityToken::GetObjectAttribute:468', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KMNLDKPC@GostCrypt?3?3SecurityToken?3?3GetObj@
CONST	SEGMENT
??_C@_0CJ@KMNLDKPC@GostCrypt?3?3SecurityToken?3?3GetObj@ DB 'GostCrypt::S'
	DB	'ecurityToken::GetObjects:420', 00H		; `string'
CONST	ENDS
;	COMDAT ??_R0?AUUserAbort@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUUserAbort@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::UserAbort `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUUserAbort@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_7?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@
CONST	SEGMENT
??_7?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@ DD FLAT:??_R4?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::`vftable'
	DD	FLAT:??_E?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z
	DD	FLAT:?IsNotEnd@?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ
	DD	FLAT:?Next@?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBEXXZ
CONST	ENDS
;	COMDAT ??_7?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@
CONST	SEGMENT
??_7?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@ DD FLAT:??_R4?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::`vftable'
	DD	FLAT:??_E?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z
	DD	FLAT:?IsNotEnd@?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ
	DD	FLAT:?Next@?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBEXXZ
CONST	ENDS
;	COMDAT __CT??_R0?AUPkcs11Exception@GostCrypt@@@8??0Pkcs11Exception@GostCrypt@@QAE@ABU01@@Z24
xdata$x	SEGMENT
__CT??_R0?AUPkcs11Exception@GostCrypt@@@8??0Pkcs11Exception@GostCrypt@@QAE@ABU01@@Z24 DD 00H
	DD	FLAT:??_R0?AUPkcs11Exception@GostCrypt@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	FLAT:??0Pkcs11Exception@GostCrypt@@QAE@ABU01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUPkcs11Exception@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUPkcs11Exception@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::Pkcs11Exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUPkcs11Exception@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AUPkcs11Exception@GostCrypt@@
xdata$x	SEGMENT
__CTA2?AUPkcs11Exception@GostCrypt@@ DD 02H
	DD	FLAT:__CT??_R0?AUPkcs11Exception@GostCrypt@@@8??0Pkcs11Exception@GostCrypt@@QAE@ABU01@@Z24
	DD	FLAT:__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
xdata$x	ENDS
;	COMDAT __TI2?AUPkcs11Exception@GostCrypt@@
xdata$x	SEGMENT
__TI2?AUPkcs11Exception@GostCrypt@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2?AUPkcs11Exception@GostCrypt@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@@8??0SecurityTokenKeyfileAlreadyExists@GostCrypt@@QAE@ABU01@@Z4
xdata$x	SEGMENT
__CT??_R0?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@@8??0SecurityTokenKeyfileAlreadyExists@GostCrypt@@QAE@ABU01@@Z4 DD 00H
	DD	FLAT:??_R0?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	FLAT:??0SecurityTokenKeyfileAlreadyExists@GostCrypt@@QAE@ABU01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::SecurityTokenKeyfileAlreadyExists `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@
xdata$x	SEGMENT
__CTA2?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@ DD 02H
	DD	FLAT:__CT??_R0?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@@8??0SecurityTokenKeyfileAlreadyExists@GostCrypt@@QAE@ABU01@@Z4
	DD	FLAT:__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
xdata$x	ENDS
;	COMDAT __TI2?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@
xdata$x	SEGMENT
__TI2?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@
xdata$x	ENDS
;	COMDAT ??_C@_0CM@EILIPAOO@GostCrypt?3?3SecurityToken?3?3Create@
CONST	SEGMENT
??_C@_0CM@EILIPAOO@GostCrypt?3?3SecurityToken?3?3Create@ DB 'GostCrypt::S'
	DB	'ecurityToken::CreateKeyfile:167', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@
CONST	SEGMENT
??_7?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ DD FLAT:??_R4?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::`vftable'
	DD	FLAT:??_E?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z
	DD	FLAT:?IsNotEnd@?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ
	DD	FLAT:?Next@?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ
CONST	ENDS
;	COMDAT ??_C@_0CL@GPMOMIPC@GostCrypt?3?3SecurityToken?3?3CloseS@
CONST	SEGMENT
??_C@_0CL@GPMOMIPC@GostCrypt?3?3SecurityToken?3?3CloseS@ DB 'GostCrypt::S'
	DB	'ecurityToken::CloseSession:148', 00H	; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AUParameterIncorrect@GostCrypt@@@8??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z8
xdata$x	SEGMENT
__CT??_R0?AUParameterIncorrect@GostCrypt@@@8??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z8 DD 00H
	DD	FLAT:??_R0?AUParameterIncorrect@GostCrypt@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	08H
	DD	FLAT:??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUParameterIncorrect@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUParameterIncorrect@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::ParameterIncorrect `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUParameterIncorrect@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AUParameterIncorrect@GostCrypt@@
xdata$x	SEGMENT
__CTA2?AUParameterIncorrect@GostCrypt@@ DD 02H
	DD	FLAT:__CT??_R0?AUParameterIncorrect@GostCrypt@@@8??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z8
	DD	FLAT:__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
xdata$x	ENDS
;	COMDAT __TI2?AUParameterIncorrect@GostCrypt@@
xdata$x	SEGMENT
__TI2?AUParameterIncorrect@GostCrypt@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2?AUParameterIncorrect@GostCrypt@@
xdata$x	ENDS
;	COMDAT ??_7?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@6B@
CONST	SEGMENT
??_7?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@6B@ DD FLAT:??_R4?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::`vftable'
	DD	FLAT:??_E?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UAEPAXI@Z
	DD	FLAT:?IsNotEnd@?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UBE_NXZ
	DD	FLAT:?Next@?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UBEXXZ
CONST	ENDS
;	COMDAT __CT??_R0?AUSecurityTokenLibraryNotInitialized@GostCrypt@@@8??0SecurityTokenLibraryNotInitialized@GostCrypt@@QAE@ABU01@@Z4
xdata$x	SEGMENT
__CT??_R0?AUSecurityTokenLibraryNotInitialized@GostCrypt@@@8??0SecurityTokenLibraryNotInitialized@GostCrypt@@QAE@ABU01@@Z4 DD 00H
	DD	FLAT:??_R0?AUSecurityTokenLibraryNotInitialized@GostCrypt@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	FLAT:??0SecurityTokenLibraryNotInitialized@GostCrypt@@QAE@ABU01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUSecurityTokenLibraryNotInitialized@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUSecurityTokenLibraryNotInitialized@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::SecurityTokenLibraryNotInitialized `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUSecurityTokenLibraryNotInitialized@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AUSecurityTokenLibraryNotInitialized@GostCrypt@@
xdata$x	SEGMENT
__CTA2?AUSecurityTokenLibraryNotInitialized@GostCrypt@@ DD 02H
	DD	FLAT:__CT??_R0?AUSecurityTokenLibraryNotInitialized@GostCrypt@@@8??0SecurityTokenLibraryNotInitialized@GostCrypt@@QAE@ABU01@@Z4
	DD	FLAT:__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
xdata$x	ENDS
;	COMDAT __TI2?AUSecurityTokenLibraryNotInitialized@GostCrypt@@
xdata$x	SEGMENT
__TI2?AUSecurityTokenLibraryNotInitialized@GostCrypt@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2?AUSecurityTokenLibraryNotInitialized@GostCrypt@@
xdata$x	ENDS
;	COMDAT ??_C@_1BM@IPMKACB@?$AAt?$AAo?$AAk?$AAe?$AAn?$AA?3?$AA?1?$AA?1?$AAs?$AAl?$AAo?$AAt?$AA?1?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@IPMKACB@?$AAt?$AAo?$AAk?$AAe?$AAn?$AA?3?$AA?1?$AA?1?$AAs?$AAl?$AAo?$AAt?$AA?1?$AA?$AA@ DB 't'
	DB	00H, 'o', 00H, 'k', 00H, 'e', 00H, 'n', 00H, ':', 00H, '/', 00H
	DB	'/', 00H, 's', 00H, 'l', 00H, 'o', 00H, 't', 00H, '/', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@ DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
	DD	058H
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@ DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
	DD	068H
CONST	ENDS
;	COMDAT ??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DD FLAT:??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DD FLAT:??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z
	DD	FLAT:?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGXZ
	DD	FLAT:?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z
	DD	FLAT:?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z
	DD	FLAT:?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
	DD	FLAT:?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	FLAT:?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z
	DD	FLAT:?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z
	DD	FLAT:?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
CONST	SEGMENT
??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@ DD 00H ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
	DD	010H
CONST	ENDS
;	COMDAT ??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
CONST	SEGMENT
??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@ DD 00H ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
	DD	020H
CONST	ENDS
;	COMDAT ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_8?$basic_ostream@_WU?$char_traits@_W@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ostream@_WU?$char_traits@_W@std@@@std@@7B@ DD 00H ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
	DD	08H
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_8?$basic_istream@_WU?$char_traits@_W@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_istream@_WU?$char_traits@_W@std@@@std@@7B@ DD 00H ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
	DD	018H
CONST	ENDS
;	COMDAT ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT __CT??_R0?AUSecurityTokenKeyfileNotFound@GostCrypt@@@8??0SecurityTokenKeyfileNotFound@GostCrypt@@QAE@ABU01@@Z4
xdata$x	SEGMENT
__CT??_R0?AUSecurityTokenKeyfileNotFound@GostCrypt@@@8??0SecurityTokenKeyfileNotFound@GostCrypt@@QAE@ABU01@@Z4 DD 00H
	DD	FLAT:??_R0?AUSecurityTokenKeyfileNotFound@GostCrypt@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	FLAT:??0SecurityTokenKeyfileNotFound@GostCrypt@@QAE@ABU01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUSecurityTokenKeyfileNotFound@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUSecurityTokenKeyfileNotFound@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::SecurityTokenKeyfileNotFound `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUSecurityTokenKeyfileNotFound@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AUSecurityTokenKeyfileNotFound@GostCrypt@@
xdata$x	SEGMENT
__CTA2?AUSecurityTokenKeyfileNotFound@GostCrypt@@ DD 02H
	DD	FLAT:__CT??_R0?AUSecurityTokenKeyfileNotFound@GostCrypt@@@8??0SecurityTokenKeyfileNotFound@GostCrypt@@QAE@ABU01@@Z4
	DD	FLAT:__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
xdata$x	ENDS
;	COMDAT __TI2?AUSecurityTokenKeyfileNotFound@GostCrypt@@
xdata$x	SEGMENT
__TI2?AUSecurityTokenKeyfileNotFound@GostCrypt@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2?AUSecurityTokenKeyfileNotFound@GostCrypt@@
xdata$x	ENDS
;	COMDAT ??_C@_1O@HIAFDIDB@?$AA?1?$AAf?$AAi?$AAl?$AAe?$AA?1?$AA?$AA@
CONST	SEGMENT
??_C@_1O@HIAFDIDB@?$AA?1?$AAf?$AAi?$AAl?$AAe?$AA?1?$AA?$AA@ DB '/', 00H, 'f'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, '/', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
xdata$x	SEGMENT
__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4 DD 00H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	FLAT:??0Exception@GostCrypt@@QAE@ABU01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUException@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUException@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::Exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUException@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@@8??0InvalidSecurityTokenKeyfilePath@GostCrypt@@QAE@ABU01@@Z4
xdata$x	SEGMENT
__CT??_R0?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@@8??0InvalidSecurityTokenKeyfilePath@GostCrypt@@QAE@ABU01@@Z4 DD 00H
	DD	FLAT:??_R0?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	FLAT:??0InvalidSecurityTokenKeyfilePath@GostCrypt@@QAE@ABU01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::InvalidSecurityTokenKeyfilePath `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@
xdata$x	SEGMENT
__CTA2?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@ DD 02H
	DD	FLAT:__CT??_R0?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@@8??0InvalidSecurityTokenKeyfilePath@GostCrypt@@QAE@ABU01@@Z4
	DD	FLAT:__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
xdata$x	ENDS
;	COMDAT __TI2?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@
xdata$x	SEGMENT
__TI2?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@
xdata$x	ENDS
;	COMDAT ??_C@_1CC@OMDFECBP@?$AAt?$AAo?$AAk?$AAe?$AAn?$AA?3?$AA?1?$AA?1?$AAs?$AAl?$AAo?$AAt?$AA?1?$AA?$CF?$AAl?$AAu?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@OMDFECBP@?$AAt?$AAo?$AAk?$AAe?$AAn?$AA?3?$AA?1?$AA?1?$AAs?$AAl?$AAo?$AAt?$AA?1?$AA?$CF?$AAl?$AAu?$AA?$AA@ DB 't'
	DB	00H, 'o', 00H, 'k', 00H, 'e', 00H, 'n', 00H, ':', 00H, '/', 00H
	DB	'/', 00H, 's', 00H, 'l', 00H, 'o', 00H, 't', 00H, '/', 00H, '%'
	DB	00H, 'l', 00H, 'u', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BBCBGCML@TOKEN_KEYFILE_NOT_FOUND?$AA@
CONST	SEGMENT
??_C@_0BI@BBCBGCML@TOKEN_KEYFILE_NOT_FOUND?$AA@ DB 'TOKEN_KEYFILE_NOT_FOU'
	DB	'ND', 00H					; `string'
CONST	ENDS
;	COMDAT ??_7SecurityTokenKeyfileNotFound@GostCrypt@@6B@
CONST	SEGMENT
??_7SecurityTokenKeyfileNotFound@GostCrypt@@6B@ DD FLAT:??_R4SecurityTokenKeyfileNotFound@GostCrypt@@6B@ ; GostCrypt::SecurityTokenKeyfileNotFound::`vftable'
	DD	FLAT:?Show@SecurityTokenKeyfileNotFound@GostCrypt@@UBEXPAUHWND__@@@Z
CONST	ENDS
;	COMDAT ??_C@_0BN@LMLDGKPH@TOKEN_KEYFILE_ALREADY_EXISTS?$AA@
CONST	SEGMENT
??_C@_0BN@LMLDGKPH@TOKEN_KEYFILE_ALREADY_EXISTS?$AA@ DB 'TOKEN_KEYFILE_AL'
	DB	'READY_EXISTS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_7SecurityTokenKeyfileAlreadyExists@GostCrypt@@6B@
CONST	SEGMENT
??_7SecurityTokenKeyfileAlreadyExists@GostCrypt@@6B@ DD FLAT:??_R4SecurityTokenKeyfileAlreadyExists@GostCrypt@@6B@ ; GostCrypt::SecurityTokenKeyfileAlreadyExists::`vftable'
	DD	FLAT:?Show@SecurityTokenKeyfileAlreadyExists@GostCrypt@@UBEXPAUHWND__@@@Z
CONST	ENDS
;	COMDAT ??_C@_0BL@JIBHLIDC@INVALID_TOKEN_KEYFILE_PATH?$AA@
CONST	SEGMENT
??_C@_0BL@JIBHLIDC@INVALID_TOKEN_KEYFILE_PATH?$AA@ DB 'INVALID_TOKEN_KEYF'
	DB	'ILE_PATH', 00H				; `string'
CONST	ENDS
;	COMDAT ??_7InvalidSecurityTokenKeyfilePath@GostCrypt@@6B@
CONST	SEGMENT
??_7InvalidSecurityTokenKeyfilePath@GostCrypt@@6B@ DD FLAT:??_R4InvalidSecurityTokenKeyfilePath@GostCrypt@@6B@ ; GostCrypt::InvalidSecurityTokenKeyfilePath::`vftable'
	DD	FLAT:?Show@InvalidSecurityTokenKeyfilePath@GostCrypt@@UBEXPAUHWND__@@@Z
CONST	ENDS
;	COMDAT ??_C@_0BK@OPPAPAFF@PKCS11_MODULE_INIT_FAILED?$AA@
CONST	SEGMENT
??_C@_0BK@OPPAPAFF@PKCS11_MODULE_INIT_FAILED?$AA@ DB 'PKCS11_MODULE_INIT_'
	DB	'FAILED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NECJIJNL@NO_PKCS11_MODULE_SPECIFIED?$AA@
CONST	SEGMENT
??_C@_0BL@NECJIJNL@NO_PKCS11_MODULE_SPECIFIED?$AA@ DB 'NO_PKCS11_MODULE_S'
	DB	'PECIFIED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_7SecurityTokenLibraryNotInitialized@GostCrypt@@6B@
CONST	SEGMENT
??_7SecurityTokenLibraryNotInitialized@GostCrypt@@6B@ DD FLAT:??_R4SecurityTokenLibraryNotInitialized@GostCrypt@@6B@ ; GostCrypt::SecurityTokenLibraryNotInitialized::`vftable'
	DD	FLAT:?Show@SecurityTokenLibraryNotInitialized@GostCrypt@@UBEXPAUHWND__@@@Z
CONST	ENDS
;	COMDAT ??_7Pkcs11Exception@GostCrypt@@6B@
CONST	SEGMENT
??_7Pkcs11Exception@GostCrypt@@6B@ DD FLAT:??_R4Pkcs11Exception@GostCrypt@@6B@ ; GostCrypt::Pkcs11Exception::`vftable'
	DD	FLAT:?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z
CONST	ENDS
;	COMDAT ??_C@_09NKHKFHLH@GostCrypt?$AA@
CONST	SEGMENT
??_C@_09NKHKFHLH@GostCrypt?$AA@ DB 'GostCrypt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0IM@CKBKFPJM@Parameter?5incorrect?4?6?6?6?$CIIf?5you?5r@
CONST	SEGMENT
??_C@_0IM@CKBKFPJM@Parameter?5incorrect?4?6?6?6?$CIIf?5you?5r@ DB 'Parame'
	DB	'ter incorrect.', 0aH, 0aH, 0aH, '(If you report a bug in conn'
	DB	'ection with this, please include the following technical info'
	DB	'rmation in the bug report:', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ?$AA@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ?$AA@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7ParameterIncorrect@GostCrypt@@6B@
CONST	SEGMENT
??_7ParameterIncorrect@GostCrypt@@6B@ DD FLAT:??_R4ParameterIncorrect@GostCrypt@@6B@ ; GostCrypt::ParameterIncorrect::`vftable'
	DD	FLAT:?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z
CONST	ENDS
;	COMDAT ??_7SystemException@GostCrypt@@6B@
CONST	SEGMENT
??_7SystemException@GostCrypt@@6B@ DD FLAT:??_R4SystemException@GostCrypt@@6B@ ; GostCrypt::SystemException::`vftable'
	DD	FLAT:?Show@SystemException@GostCrypt@@UBEXPAUHWND__@@@Z
CONST	ENDS
;	COMDAT ??_7Exception@GostCrypt@@6B@
CONST	SEGMENT
??_7Exception@GostCrypt@@6B@ DD FLAT:??_R4Exception@GostCrypt@@6B@ ; GostCrypt::Exception::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7Container@ForEach@GostCrypt@@6B@
CONST	SEGMENT
??_7Container@ForEach@GostCrypt@@6B@ DD FLAT:??_R4Container@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::Container::`vftable'
	DD	FLAT:??_EContainer@ForEach@GostCrypt@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ DB 'ios_base::failbit se'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0_System_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
data$r	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
data$r	ENDS
;	COMDAT __CTA5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA5?AVfailure@ios_base@std@@ DD 05H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI5?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA5?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_7ios_base@std@@6B@
CONST	SEGMENT
??_7ios_base@std@@6B@ DD FLAT:??_R4ios_base@std@@6B@	; std::ios_base::`vftable'
	DD	FLAT:??_Eios_base@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DD FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DD	FLAT:??_E_System_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7?$ctype@_W@std@@6B@
CONST	SEGMENT
??_7?$ctype@_W@std@@6B@ DD FLAT:??_R4?$ctype@_W@std@@6B@ ; std::ctype<wchar_t>::`vftable'
	DD	FLAT:??_E?$ctype@_W@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z
	DD	FLAT:?do_is@?$ctype@_W@std@@MBE_NF_W@Z
	DD	FLAT:?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
	DD	FLAT:?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
	DD	FLAT:?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
	DD	FLAT:?do_tolower@?$ctype@_W@std@@MBE_W_W@Z
	DD	FLAT:?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
	DD	FLAT:?do_toupper@?$ctype@_W@std@@MBE_W_W@Z
	DD	FLAT:?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z
	DD	FLAT:?do_widen@?$ctype@_W@std@@MBE_WD@Z
	DD	FLAT:?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@_W@std@@MBED_WD@Z
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DD FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DD	FLAT:??_E_Facet_base@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception?$AA@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0
__tryblocktable$??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$6
__unwindtable$??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$4
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z$56 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z$0
__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z$56
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$0
__unwindtable$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$6
__ehfuncinfo$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z$120 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z$0
__unwindtable$??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z$120
__ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$15 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$0
__unwindtable$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$15
__ehfuncinfo$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z$0
__ehfuncinfo$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z$0
__ehfuncinfo$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z$29 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z$0
__tryblocktable$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z$29
__unwindtable$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@ABU34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@ABU34@@Z$1
__ehfuncinfo$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@ABU34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@ABU34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@AAU34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@AAU34@@Z$1
__ehfuncinfo$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@AAU34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@AAU34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z$0
__unwindtable$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z$2
__ehfuncinfo$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z$0
__ehfuncinfo$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0
__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$2
__ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0
__ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$33
	DD	02H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$33
	DD	02H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z$0
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z$0
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$32
	DD	02H
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$134
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$33
	DD	02H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$33
	DD	02H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z$0
__ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z$0
__ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$32
	DD	02H
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$134
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z$2
__ehfuncinfo$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z$2
__ehfuncinfo$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$38 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$38
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$36
	DD	04H
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$37
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ$1
__ehfuncinfo$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z$2
__ehfuncinfo$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z$3
__ehfuncinfo$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ$2
__ehfuncinfo$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
__ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$2
__ehfuncinfo$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ$1
__ehfuncinfo$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ$0
__ehfuncinfo$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ$3
__ehfuncinfo$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$3
__ehfuncinfo$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ$4
__ehfuncinfo$??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$0
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$1
	DD	02H
	DD	00H
__ehfuncinfo$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
__ehfuncinfo$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$3
__ehfuncinfo$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$14
	DD	01H
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$15
__ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z$34 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z DD 04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z$34
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z$5
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z$32
	DD	06H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z$33
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$14 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$14
__ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z$0
__ehfuncinfo$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
__ehfuncinfo$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$3
__ehfuncinfo$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z$0
__ehfuncinfo$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$1
__ehfuncinfo$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z$1
__ehfuncinfo$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$1
__ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ$0
__ehfuncinfo$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ$0
__unwindtable$??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ$3
__ehfuncinfo$??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ
	DD	01H
	DD	FLAT:__tryblocktable$??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@KV?$allocator@K@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@KV?$allocator@K@std@@@std@@@Z$0
__ehfuncinfo$??0?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@KV?$allocator@K@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@KV?$allocator@K@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$GetContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@01@ABV?$vector@KV?$allocator@K@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@01@ABV?$vector@KV?$allocator@K@std@@@std@@@Z$1
__ehfuncinfo$??$GetContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@01@ABV?$vector@KV?$allocator@K@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$GetContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@01@ABV?$vector@KV?$allocator@K@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@KV?$allocator@K@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@KV?$allocator@K@std@@@std@@@Z$0
__ehfuncinfo$??0?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@KV?$allocator@K@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@KV?$allocator@K@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z$1
__ehfuncinfo$??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z$46 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z$46
__unwindtable$??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z$0
__ehfuncinfo$??0?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$GetContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z$1
__ehfuncinfo$??$GetContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$GetContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@QAE@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@QAE@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z$0
__ehfuncinfo$??0?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@QAE@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@QAE@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$GetContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z$1
__ehfuncinfo$??$GetContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$GetContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$45 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$0
__tryblocktable$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$45
__ehfuncinfo$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$43
	DD	04H
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$44
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$38 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$0
__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$38
__ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$36
	DD	04H
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$37
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ$1
__ehfuncinfo$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z$2
__ehfuncinfo$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z$3
__ehfuncinfo$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ$2
__ehfuncinfo$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$0
__ehfuncinfo$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$2
__ehfuncinfo$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ$1
__ehfuncinfo$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ$0
__ehfuncinfo$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ$3
__ehfuncinfo$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$3
__ehfuncinfo$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$4
__ehfuncinfo$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z$0
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z$1
	DD	02H
	DD	00H
__ehfuncinfo$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$2
__ehfuncinfo$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$3
__ehfuncinfo$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$14
	DD	01H
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$15
__ehfuncinfo$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z$34 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z$0
__tryblocktable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z DD 04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z$34
__ehfuncinfo$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z$5
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z$32
	DD	06H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z$33
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$34 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$0
__tryblocktable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z DD 04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$34
__ehfuncinfo$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$5
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$32
	DD	06H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$33
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$14 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$14
__ehfuncinfo$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z$0
__ehfuncinfo$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$2
__ehfuncinfo$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$3
__ehfuncinfo$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z$0
__ehfuncinfo$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$1
__ehfuncinfo$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z$1
__ehfuncinfo$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z$1
__ehfuncinfo$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ$0
__ehfuncinfo$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z$54 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z$54
__ehfuncinfo$?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?push_back@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXABUSecurityTokenKeyfile@GostCrypt@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXABUSecurityTokenKeyfile@GostCrypt@@@Z$33
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXABUSecurityTokenKeyfile@GostCrypt@@@Z$57
__ehfuncinfo$?push_back@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXABUSecurityTokenKeyfile@GostCrypt@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?push_back@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXABUSecurityTokenKeyfile@GostCrypt@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$67 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$67
__ehfuncinfo$??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$232 DD 08H
	DD	FLAT:??_R0?AUPkcs11Exception@GostCrypt@@@8
	DD	0ffffff5cH
	DD	FLAT:__catch$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$2
__catchsym$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$231 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$0
__ehfuncinfo$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z DD 019930522H
	DD	011H
	DD	FLAT:__unwindtable$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z
	DD	02H
	DD	FLAT:__tryblocktable$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$231
	DD	03H
	DD	0fH
	DD	010H
	DD	01H
	DD	FLAT:__catchsym$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$232
__unwindtable$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$4
	DD	02H
	DD	00H
	DD	03H
	DD	FLAT:__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$90
	DD	05H
	DD	00H
	DD	06H
	DD	00H
	DD	06H
	DD	FLAT:__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$94
	DD	08H
	DD	00H
	DD	05H
	DD	FLAT:__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$91
	DD	0aH
	DD	FLAT:__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$98
	DD	04H
	DD	FLAT:__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$6
	DD	0cH
	DD	FLAT:__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$100
	DD	04H
	DD	FLAT:__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$197
	DD	04H
	DD	FLAT:__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$8
	DD	02H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetTokenSlots@SecurityToken@GostCrypt@@KA?AV?$list@KV?$allocator@K@std@@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTokenSlots@SecurityToken@GostCrypt@@KA?AV?$list@KV?$allocator@K@std@@@std@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTokenSlots@SecurityToken@GostCrypt@@KA?AV?$list@KV?$allocator@K@std@@@std@@XZ$1
__ehfuncinfo$?GetTokenSlots@SecurityToken@GostCrypt@@KA?AV?$list@KV?$allocator@K@std@@@std@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetTokenSlots@SecurityToken@GostCrypt@@KA?AV?$list@KV?$allocator@K@std@@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z$0
__ehfuncinfo$?GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?InitLibrary@SecurityToken@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$auto_ptr@UGetPinFunctor@GostCrypt@@@4@V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@4@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitLibrary@SecurityToken@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$auto_ptr@UGetPinFunctor@GostCrypt@@@4@V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@4@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?InitLibrary@SecurityToken@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$auto_ptr@UGetPinFunctor@GostCrypt@@@4@V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@4@@Z$1
__ehfuncinfo$?InitLibrary@SecurityToken@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$auto_ptr@UGetPinFunctor@GostCrypt@@@4@V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@4@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?InitLibrary@SecurityToken@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$auto_ptr@UGetPinFunctor@GostCrypt@@@4@V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@4@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z$90
__ehfuncinfo$?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ$234 DD 08H
	DD	FLAT:??_R0?AUPkcs11Exception@GostCrypt@@@8
	DD	0ffffff74H
	DD	FLAT:__catch$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ$0
__tryblocktable$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ DD 04H
	DD	05H
	DD	06H
	DD	01H
	DD	FLAT:__catchsym$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ$234
__ehfuncinfo$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ$4
	DD	03H
	DD	00H
	DD	04H
	DD	FLAT:__unwindfunclet$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ$6
	DD	03H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z DD 06H
	DD	06H
	DD	07H
	DD	02H
	DD	FLAT:__catchsym$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$765
__catchsym$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$765 DD 08H
	DD	FLAT:??_R0?AUUserAbort@GostCrypt@@@8
	DD	00H
	DD	FLAT:__catch$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$0
	DD	08H
	DD	FLAT:??_R0?AUPkcs11Exception@GostCrypt@@@8
	DD	0fffffe68H
	DD	FLAT:__catch$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$1
__ehfuncinfo$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$5
	DD	02H
	DD	FLAT:__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$6
	DD	01H
	DD	FLAT:__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$8
	DD	05H
	DD	00H
	DD	05H
	DD	00H
	DD	05H
	DD	FLAT:__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$10
	DD	08H
	DD	FLAT:__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$11
	DD	05H
	DD	FLAT:__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$11
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$13
	DD	0bH
	DD	FLAT:__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$14
	DD	0cH
	DD	FLAT:__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$15
	DD	0dH
	DD	FLAT:__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$16
	DD	0eH
	DD	FLAT:__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$545
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ$43 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ$0
__tryblocktable$?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ$43
__unwindtable$?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$55
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$59
	DD	03H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$56
	DD	05H
	DD	FLAT:__unwindfunclet$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$63
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$67
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$137
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$141
	DD	04H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$138
	DD	06H
	DD	FLAT:__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$145
	DD	00H
	DD	FLAT:__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$2
	DD	08H
	DD	FLAT:__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$5
	DD	09H
	DD	FLAT:__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$6
	DD	0aH
	DD	FLAT:__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$226
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z$1
__ehfuncinfo$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ$3
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ$7
	DD	03H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ$4
	DD	05H
	DD	FLAT:__unwindfunclet$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ$0
	DD	07H
	DD	FLAT:__unwindfunclet$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ$74
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??4SecurityTokenInfo@GostCrypt@@QAEAAU01@$$QAU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4SecurityTokenInfo@GostCrypt@@QAEAAU01@$$QAU01@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??4SecurityTokenInfo@GostCrypt@@QAEAAU01@$$QAU01@@Z$68
__ehfuncinfo$??4SecurityTokenInfo@GostCrypt@@QAEAAU01@$$QAU01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??4SecurityTokenInfo@GostCrypt@@QAEAAU01@$$QAU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0SecurityTokenInfo@GostCrypt@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SecurityTokenInfo@GostCrypt@@QAE@ABU01@@Z$0
__ehfuncinfo$??0SecurityTokenInfo@GostCrypt@@QAE@ABU01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SecurityTokenInfo@GostCrypt@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z$1
__ehfuncinfo$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$111
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@$$QAV12@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gios_base@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gios_base@std@@UAEPAXI@Z$0
__ehfuncinfo$??_Gios_base@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Gios_base@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Init@ios_base@std@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Init@ios_base@std@@IAEXXZ$0
__ehfuncinfo$?_Init@ios_base@std@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Init@ios_base@std@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1ios_base@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getloc@ios_base@std@@QBE?AVlocale@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getloc@ios_base@std@@QBE?AVlocale@2@XZ$1
__ehfuncinfo$?getloc@ios_base@std@@QBE?AVlocale@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getloc@ios_base@std@@QBE?AVlocale@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0
__ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1
__ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Glocale@std@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Glocale@std@@QAEPAXI@Z$0
__ehfuncinfo$??_Glocale@std@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Glocale@std@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1locale@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0locale@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0locale@std@@QAE@ABV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
??WarningCallback$initializer$@SecurityToken@GostCrypt@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?WarningCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@A@@YAXXZ ; GostCrypt::SecurityToken::arningCallback$initializer$::operator||
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??Sessions$initializer$@SecurityToken@GostCrypt@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A@@YAXXZ ; GostCrypt::SecurityToken::essions$initializer$::operator~
CRT$XCU	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_iostream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_iostream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$get@$0A@ABK@std@@YAABK$$QAV?$tuple@ABK@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$0A@ABK@std@@YAABK$$QAV?$tuple@ABK@0@@Z PROC	; std::get<0,unsigned long const &>, COMDAT

; 903  : 	{	// get rvalue reference to _Index element of tuple

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 904  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 905  : 		_Ttype;
; 906  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::type&&
; 907  : 		_RRtype;
; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Tuple$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 909  : 	}

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$get@$0A@ABK@std@@YAABK$$QAV?$tuple@ABK@0@@Z ENDP	; std::get<0,unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$tuple@ABK@std@@@std@@YA$$QAV?$tuple@ABK@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$tuple@ABK@std@@@std@@YA$$QAV?$tuple@ABK@0@AAV10@@Z PROC ; std::move<std::tuple<unsigned long const &> &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$tuple@ABK@std@@@std@@YA$$QAV?$tuple@ABK@0@AAV10@@Z ENDP ; std::move<std::tuple<unsigned long const &> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@AAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@AAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::construct<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@construct:

; 738  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@AAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@AAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::construct<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$?0V?$tuple@ABK@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@QAE@AAV?$tuple@ABK@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$?0V?$tuple@ABK@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@QAE@AAV?$tuple@ABK@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z PROC ; std::pair<unsigned long const ,GostCrypt::Pkcs11Session>::pair<unsigned long const ,GostCrypt::Pkcs11Session><std::tuple<unsigned long const &>,std::tuple<>,0>, COMDAT
; _this$ = ecx

; 1180 : 		{	// construct from pair of tuples

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1178 : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	89 01		 mov	 DWORD PTR [ecx], eax

; 1181 : 		(void) _Val1;	// TRANSITION, VSO#181496
; 1182 : 		(void) _Val2;
; 1183 : 		}

  0000c	8b c1		 mov	 eax, ecx
  0000e	c6 41 08 00	 mov	 BYTE PTR [ecx+8], 0
  00012	5d		 pop	 ebp
  00013	c2 10 00	 ret	 16			; 00000010H
??$?0V?$tuple@ABK@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@QAE@AAV?$tuple@ABK@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z ENDP ; std::pair<unsigned long const ,GostCrypt::Pkcs11Session>::pair<unsigned long const ,GostCrypt::Pkcs11Session><std::tuple<unsigned long const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@AAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@AAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@AAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@AAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::construct<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN8@construct:

; 858  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@AAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@AAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::construct<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$?0ABK$$Z$$V@?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABK@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 1
??$?0ABK$$Z$$V@?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABK@1@V?$tuple@$$V@1@@Z PROC ; std::pair<unsigned long const ,GostCrypt::Pkcs11Session>::pair<unsigned long const ,GostCrypt::Pkcs11Session><unsigned long const &>, COMDAT
; _this$ = ecx

; 1196 : 		{	// construct from pair of tuples

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1193 : 		: pair(_Val1, _Val2,

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 1197 : 		}

  0000a	8b c1		 mov	 eax, ecx
  0000c	c6 41 08 00	 mov	 BYTE PTR [ecx+8], 0
  00010	5d		 pop	 ebp
  00011	c2 0c 00	 ret	 12			; 0000000cH
??$?0ABK$$Z$$V@?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABK@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<unsigned long const ,GostCrypt::Pkcs11Session>::pair<unsigned long const ,GostCrypt::Pkcs11Session><unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@AAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@AAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@AAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@AAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::construct<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 11		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00011	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@AAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@AAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::construct<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@USecurityTokenKeyfile@GostCrypt@@U12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@$$QAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USecurityTokenKeyfile@GostCrypt@@U12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@$$QAU23@@Z PROC ; std::allocator<GostCrypt::SecurityTokenKeyfile>::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 08		 je	 SHORT $LN3@construct
  0000a	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0SecurityTokenKeyfile@GostCrypt@@QAE@$$QAU01@@Z
$LN3@construct:

; 738  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??$construct@USecurityTokenKeyfile@GostCrypt@@U12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@$$QAU23@@Z ENDP ; std::allocator<GostCrypt::SecurityTokenKeyfile>::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$ = 20					; size = 4
??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::construct<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	89 01		 mov	 DWORD PTR [ecx], eax
  00013	c6 41 08 00	 mov	 BYTE PTR [ecx+8], 0
$LN3@construct:

; 738  : 		}

  00017	5d		 pop	 ebp
  00018	c2 10 00	 ret	 16			; 00000010H
??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::construct<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_memmove@PBKPAK@std@@YAPAKPBK0PAK@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PBKPAK@std@@YAPAKPBK0PAK@Z PROC	; std::_Copy_memmove<unsigned long const *,unsigned long *>, COMDAT

; 2301 : 	{	// implement copy-like function as memmove

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2303 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2304 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 2308 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PBKPAK@std@@YAPAKPBK0PAK@Z ENDP	; std::_Copy_memmove<unsigned long const *,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Buynode@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &>, COMDAT
; _this$ = ecx

; 880  : 		{	// allocate a node with defaults and set links and value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 881  : 		_Nodeptr _Pnode = _Buynode0();

  00003	e8 00 00 00 00	 call	 ?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode0
  00008	8b c8		 mov	 ecx, eax

; 882  : 
; 883  : 		this->_Color(_Pnode) = _Red;
; 884  : 		this->_Isnil(_Pnode) = false;
; 885  : 
; 886  : 		_TRY_BEGIN
; 887  : 		this->_Getal().construct(

  0000a	8d 51 10	 lea	 edx, DWORD PTR [ecx+16]
  0000d	66 c7 41 0c 00
	00		 mov	 WORD PTR [ecx+12], 0
  00013	85 d2		 test	 edx, edx
  00015	74 13		 je	 SHORT $LN47@Buynode
  00017	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001a	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  0001e	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00022	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00025	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 888  : 			_STD addressof(_Myval(_Pnode)),
; 889  : 				_STD forward<_Valty>(_Val)...);
; 890  : 		_CATCH_ALL
; 891  : 		_Freenode0(_Pnode);
; 892  : 		_RERAISE;
; 893  : 		_CATCH_END
; 894  : 
; 895  : 		return (_Pnode);

  00028	8b c1		 mov	 eax, ecx
$LN47@Buynode:

; 896  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??$_Buynode@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@USecurityTokenKeyfile@GostCrypt@@U12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@$$QAU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@USecurityTokenKeyfile@GostCrypt@@U12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@$$QAU34@@Z PROC ; std::allocator_traits<std::allocator<GostCrypt::SecurityTokenKeyfile> >::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 08		 je	 SHORT $LN8@construct
  0000a	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0SecurityTokenKeyfile@GostCrypt@@QAE@$$QAU01@@Z
$LN8@construct:

; 858  : 		}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$construct@USecurityTokenKeyfile@GostCrypt@@U12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@$$QAU34@@Z ENDP ; std::allocator_traits<std::allocator<GostCrypt::SecurityTokenKeyfile> >::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@USecurityTokenKeyfile@GostCrypt@@@std@@YA$$QAUSecurityTokenKeyfile@GostCrypt@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@USecurityTokenKeyfile@GostCrypt@@@std@@YA$$QAUSecurityTokenKeyfile@GostCrypt@@AAU12@@Z PROC ; std::forward<GostCrypt::SecurityTokenKeyfile>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@USecurityTokenKeyfile@GostCrypt@@@std@@YA$$QAUSecurityTokenKeyfile@GostCrypt@@AAU12@@Z ENDP ; std::forward<GostCrypt::SecurityTokenKeyfile>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z
_TEXT	SEGMENT
__Node$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Buynode_if_nil@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode_if_nil<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &>, COMDAT
; _this$ = ecx

; 1629 : 		{	// node exists, just return it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1630 : 		return (_Node);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Node$[ebp]

; 1631 : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
??$_Buynode_if_nil@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode_if_nil<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
_<_Args_2>$ = 24					; size = 4
??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::construct<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0d		 je	 SHORT $LN14@construct
  0000a	8b 45 14	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	89 01		 mov	 DWORD PTR [ecx], eax
  00013	c6 41 08 00	 mov	 BYTE PTR [ecx+8], 0
$LN14@construct:

; 858  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::construct<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
$T2 = 12						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::SecurityTokenKeyfile const *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >, COMDAT

; 220  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, no special optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 221  : 	_FwdIt _Next = _Dest;

  0002b	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]

; 222  : 
; 223  : 	_TRY_BEGIN

  0002e	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00031	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00034	89 75 ec	 mov	 DWORD PTR __Next$[ebp], esi
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003e	66 90		 npad	 2
$LL4@Uninitiali:

; 224  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00040	3b fb		 cmp	 edi, ebx
  00042	74 3c		 je	 SHORT $LN3@Uninitiali

; 225  : 		_Al.construct(_Unfancy(_Dest), *_First);

  00044	89 75 0c	 mov	 DWORD PTR $T2[ebp], esi
  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0004b	85 f6		 test	 esi, esi
  0004d	74 08		 je	 SHORT $LN25@Uninitiali
  0004f	57		 push	 edi
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z
$LN25@Uninitiali:
  00057	83 c6 70	 add	 esi, 112		; 00000070H
  0005a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0005e	89 75 10	 mov	 DWORD PTR __Dest$[ebp], esi
  00061	83 c7 70	 add	 edi, 112		; 00000070H
  00064	eb da		 jmp	 SHORT $LL4@Uninitiali
__catch$??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0:

; 226  : 	_CATCH_ALL
; 227  : 	_Destroy_range(_Next, _Dest, _Al);

  00066	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00069	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0006c	ff 75 ec	 push	 DWORD PTR __Next$[ebp]
  0006f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@PAUSecurityTokenKeyfile@GostCrypt@@@std@@YAXPAUSecurityTokenKeyfile@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<GostCrypt::SecurityTokenKeyfile>,GostCrypt::SecurityTokenKeyfile *>
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 228  : 	_RERAISE;

  00077	6a 00		 push	 0
  00079	6a 00		 push	 0
  0007b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN38@Uninitiali:
$LN3@Uninitiali:

; 229  : 	_CATCH_END
; 230  : 
; 231  : 	return (_Dest);

  00080	8b c6		 mov	 eax, esi

; 232  : 	}

  00082	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00085	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008c	59		 pop	 ecx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN37@Uninitiali:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$4:
  00000	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00003	50		 push	 eax
  00004	8b 45 0c	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::SecurityTokenKeyfile const *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_copy_cat@$$CBUSecurityTokenKeyfile@GostCrypt@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBUSecurityTokenKeyfile@GostCrypt@@ABQAU23@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_copy_cat@$$CBUSecurityTokenKeyfile@GostCrypt@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBUSecurityTokenKeyfile@GostCrypt@@ABQAU23@@Z PROC ; std::_Ptr_copy_cat<GostCrypt::SecurityTokenKeyfile const ,GostCrypt::SecurityTokenKeyfile>, COMDAT

; 793  : 	return {};

  00000	32 c0		 xor	 al, al

; 794  : 	}

  00002	c3		 ret	 0
??$_Ptr_copy_cat@$$CBUSecurityTokenKeyfile@GostCrypt@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBUSecurityTokenKeyfile@GostCrypt@@ABQAU23@@Z ENDP ; std::_Ptr_copy_cat<GostCrypt::SecurityTokenKeyfile const ,GostCrypt::SecurityTokenKeyfile>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked1@$$CBKKV?$allocator@K@std@@@std@@YAPAKPBK0PAKAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_copy_al_unchecked1@$$CBKKV?$allocator@K@std@@@std@@YAPAKPBK0PAKAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked1<unsigned long const ,unsigned long,std::allocator<unsigned long> >, COMDAT

; 239  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 240  : 	return (_Copy_memmove(_First, _Last, _Dest));

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 241  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Uninitialized_copy_al_unchecked1@$$CBKKV?$allocator@K@std@@@std@@YAPAKPBK0PAKAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked1<unsigned long const ,unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_copy_cat@$$CBKK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQBKABQAK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_copy_cat@$$CBKK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQBKABQAK@Z PROC ; std::_Ptr_copy_cat<unsigned long const ,unsigned long>, COMDAT

; 792  : 	{	// return pointer copy optimization category for pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 793  : 	return {};

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 794  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Ptr_copy_cat@$$CBKK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQBKABQAK@Z ENDP ; std::_Ptr_copy_cat<unsigned long const ,unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Copy_or_move@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Copy_or_move@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_or_move<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,std::integral_constant<bool,0> >, COMDAT
; _this$ = ecx

; 1938 : 		{	// copy to new node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1939 : 		return (this->_Buynode(_Val));

  00003	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Buynode@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &>

; 1940 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 0c 00	 ret	 12			; 0000000cH
??$_Copy_or_move@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@U?$integral_constant@_N$0A@@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@U_Copy_tag@01@U?$integral_constant@_N$0A@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_or_move<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,std::integral_constant<bool,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1><std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 290  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1><std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z PROC ; std::forward<std::_One_then_variadic_args_t>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z ENDP ; std::forward<std::_One_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z PROC		; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT

; 2301 : 	{	// implement copy-like function as memmove

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2303 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2304 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 2308 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ENDP		; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@USecurityTokenKeyfile@GostCrypt@@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@USecurityTokenKeyfile@GostCrypt@@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@@Z PROC ; std::allocator<GostCrypt::SecurityTokenKeyfile>::destroy<GostCrypt::SecurityTokenKeyfile>, COMDAT
; _this$ = ecx

; 743  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 744  : 		_Ptr->~_Uty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1SecurityTokenKeyfile@GostCrypt@@QAE@XZ

; 745  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??$destroy@USecurityTokenKeyfile@GostCrypt@@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@@Z ENDP ; std::allocator<GostCrypt::SecurityTokenKeyfile>::destroy<GostCrypt::SecurityTokenKeyfile>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@USecurityTokenKeyfile@GostCrypt@@U12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@$$QAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USecurityTokenKeyfile@GostCrypt@@U12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@$$QAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 08		 je	 SHORT $LN13@construct
  0000a	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0SecurityTokenKeyfile@GostCrypt@@QAE@$$QAU01@@Z
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??$construct@USecurityTokenKeyfile@GostCrypt@@U12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@$$QAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z PROC		; std::_Copy_memmove<unsigned long *,unsigned long *>, COMDAT

; 2301 : 	{	// implement copy-like function as memmove

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2303 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2304 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 2308 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z ENDP		; std::_Copy_memmove<unsigned long *,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@USecurityTokenInfo@GostCrypt@@U12@@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEXPAUSecurityTokenInfo@GostCrypt@@$$QAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USecurityTokenInfo@GostCrypt@@U12@@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEXPAUSecurityTokenInfo@GostCrypt@@$$QAU23@@Z PROC ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::construct<GostCrypt::SecurityTokenInfo,GostCrypt::SecurityTokenInfo>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 4b		 je	 SHORT $LN3@construct
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _<_Args_0>$[ebp]
  0000f	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00012	33 d2		 xor	 edx, edx
  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	89 07		 mov	 DWORD PTR [edi], eax
  00018	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001b	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0001e	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00021	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  00028	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0002f	50		 push	 eax
  00030	66 89 11	 mov	 WORD PTR [ecx], dx
  00033	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  00038	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  0003b	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  0003e	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00045	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0004c	50		 push	 eax
  0004d	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00050	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00055	5e		 pop	 esi
$LN3@construct:
  00056	5f		 pop	 edi

; 738  : 		}

  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
??$construct@USecurityTokenInfo@GostCrypt@@U12@@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEXPAUSecurityTokenInfo@GostCrypt@@$$QAU23@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::construct<GostCrypt::SecurityTokenInfo,GostCrypt::SecurityTokenInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@KABK@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEXPAKABK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@KABK@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEXPAKABK@Z PROC ; std::allocator<std::_List_node<unsigned long,void *> >::construct<unsigned long,unsigned long const &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@KABK@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEXPAKABK@Z ENDP ; std::allocator<std::_List_node<unsigned long,void *> >::construct<unsigned long,unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z
_TEXT	SEGMENT
tv702 = -28						; size = 4
_this$1$ = -24						; size = 4
__Addleft$2 = -20					; size = 1
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
$T3 = 12						; size = 4
__Where$4 = 12						; size = 4
__Leftish$ = 12						; size = 1
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_nohint<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>, COMDAT
; _this$ = ecx

; 1771 : 		{	// try to insert node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b c1		 mov	 eax, ecx
  0002d	89 45 e8	 mov	 DWORD PTR _this$1$[ebp], eax

; 1772 : 		_TRY_BEGIN
; 1773 : 		_Nodeptr _Trynode = _Root();

  00030	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1774 : 		_Nodeptr _Wherenode = this->_Myhead();
; 1775 : 		bool _Addleft = true;	// add to left of head if tree empty

  00032	b2 01		 mov	 dl, 1
  00034	8b 5d 10	 mov	 ebx, DWORD PTR __Val$[ebp]
  00037	8b f9		 mov	 edi, ecx
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00040	89 4d e4	 mov	 DWORD PTR tv702[ebp], ecx
  00043	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00046	88 55 ec	 mov	 BYTE PTR __Addleft$2[ebp], dl

; 1776 : 
; 1777 : 		while (!this->_Isnil(_Trynode))

  00049	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004d	75 30		 jne	 SHORT $LN3@Insert_noh
  0004f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00051	8a 75 0c	 mov	 dh, BYTE PTR __Leftish$[ebp]
$LL2@Insert_noh:

; 1778 : 			{	// look for leaf to insert before (_Addleft) or after
; 1779 : 			_Wherenode = _Trynode;

  00054	8b f8		 mov	 edi, eax

; 1780 : 			if (_Leftish)

  00056	84 f6		 test	 dh, dh
  00058	74 08		 je	 SHORT $LN5@Insert_noh

; 1781 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),

  0005a	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  0005d	0f 93 c2	 setae	 dl

; 1782 : 					this->_Key(_Trynode),
; 1783 : 					this->_Kfn(_Val));	// favor left end
; 1784 : 			else

  00060	eb 06		 jmp	 SHORT $LN330@Insert_noh
$LN5@Insert_noh:

; 1785 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),

  00062	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00065	0f 92 c2	 setb	 dl
$LN330@Insert_noh:
  00068	88 55 ec	 mov	 BYTE PTR __Addleft$2[ebp], dl

; 1786 : 					this->_Kfn(_Val),
; 1787 : 					this->_Key(_Trynode));	// favor right end
; 1788 : 			_Trynode = _Addleft ? this->_Left(_Trynode)

  0006b	84 d2		 test	 dl, dl
  0006d	74 04		 je	 SHORT $LN16@Insert_noh
  0006f	8b 00		 mov	 eax, DWORD PTR [eax]
  00071	eb 03		 jmp	 SHORT $LN17@Insert_noh
$LN16@Insert_noh:
  00073	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN17@Insert_noh:

; 1776 : 
; 1777 : 		while (!this->_Isnil(_Trynode))

  00076	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0007a	74 d8		 je	 SHORT $LL2@Insert_noh
  0007c	8b 4d e4	 mov	 ecx, DWORD PTR tv702[ebp]
$LN3@Insert_noh:

; 1789 : 				: this->_Right(_Trynode);
; 1790 : 			}
; 1791 : 
; 1792 : 		if (this->_Multi)
; 1793 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1794 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1795 : 		else
; 1796 : 			{	// insert only if unique
; 1797 : 			iterator _Where = iterator(_Wherenode, &this->_Get_data());

  0007f	8b f7		 mov	 esi, edi
  00081	89 75 0c	 mov	 DWORD PTR __Where$4[ebp], esi

; 1798 : 			if (!_Addleft)

  00084	84 d2		 test	 dl, dl
  00086	74 41		 je	 SHORT $LN12@Insert_noh

; 1799 : 				;	// need to test if insert after is okay
; 1800 : 			else if (_Where == begin())

  00088	3b 39		 cmp	 edi, DWORD PTR [ecx]
  0008a	75 32		 jne	 SHORT $LN11@Insert_noh

; 1801 : 				return (_Pairib(_Insert_at(true, _Wherenode,

  0008c	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0008f	53		 push	 ebx
  00090	57		 push	 edi
  00091	6a 01		 push	 1
$LN331@Insert_noh:
  00093	8b 4d e8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00096	8d 45 0c	 lea	 eax, DWORD PTR $T3[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_at<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
  0009f	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a4	89 08		 mov	 DWORD PTR [eax], ecx
  000a6	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1

; 1820 : 		_CATCH_END
; 1821 : 		}

  000aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b4	59		 pop	 ecx
  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 10 00	 ret	 16			; 00000010H
$LN11@Insert_noh:

; 1802 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 			else
; 1804 : 				--_Where;	// need to test if insert before is okay

  000be	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$4[ebp]
  000c1	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::operator--
  000c6	8b 75 0c	 mov	 esi, DWORD PTR __Where$4[ebp]
$LN12@Insert_noh:

; 1805 : 
; 1806 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

  000c9	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 1807 : 				this->_Key(_Where._Mynode()),
; 1808 : 				this->_Kfn(_Val)))
; 1809 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

  000cc	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000cf	3b 03		 cmp	 eax, DWORD PTR [ebx]
  000d1	73 1b		 jae	 SHORT $LN13@Insert_noh
  000d3	53		 push	 ebx
  000d4	57		 push	 edi
  000d5	ff 75 ec	 push	 DWORD PTR __Addleft$2[ebp]
  000d8	eb b9		 jmp	 SHORT $LN331@Insert_noh
__catch$??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z$0:

; 1815 : 				}
; 1816 : 			}
; 1817 : 		_CATCH_ALL
; 1818 : 		_Destroy_if_not_nil(_Newnode);

  000da	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000dd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e2	83 c4 04	 add	 esp, 4

; 1819 : 		_RERAISE;

  000e5	6a 00		 push	 0
  000e7	6a 00		 push	 0
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN332@Insert_noh:
$LN13@Insert_noh:

; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				{	// duplicate, don't insert
; 1813 : 				_Destroy_if_not_nil(_Newnode);

  000ee	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1814 : 				return (_Pairib(_Where, false));

  000f3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000f6	83 c4 04	 add	 esp, 4
  000f9	89 30		 mov	 DWORD PTR [eax], esi
  000fb	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 1820 : 		_CATCH_END
; 1821 : 		}

  000ff	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00102	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00109	59		 pop	 ecx
  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c2 10 00	 ret	 16			; 00000010H
$LN329@Insert_noh:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_nohint<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_at@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_at<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>, COMDAT
; _this$ = ecx

; 1827 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 1828 : 		if (max_size() - 1 <= this->_Mysize())

  00008	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000b	3d 48 92 24 09	 cmp	 eax, 153391688		; 09249248H
  00010	0f 83 6e 01 00
	00		 jae	 $LN727@Insert_at

; 1832 : 			}
; 1833 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1834 : 			_STD forward<_Valty>(_Val));
; 1835 : 
; 1836 : 		++this->_Mysize();
; 1837 : 		_Newnode->_Parent = _Wherenode;

  00016	8b 5d 18	 mov	 ebx, DWORD PTR __Node$[ebp]
  00019	40		 inc	 eax
  0001a	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0001d	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00020	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 1838 : 
; 1839 : 		if (_Wherenode == this->_Myhead())

  00023	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00025	3b c1		 cmp	 eax, ecx
  00027	75 0e		 jne	 SHORT $LN6@Insert_at

; 1840 : 			{	// first node in tree, just set head values
; 1841 : 			_Root() = _Newnode;

  00029	89 59 04	 mov	 DWORD PTR [ecx+4], ebx

; 1842 : 			_Lmost() = _Newnode;

  0002c	8b 07		 mov	 eax, DWORD PTR [edi]
  0002e	89 18		 mov	 DWORD PTR [eax], ebx

; 1843 : 			_Rmost() = _Newnode;

  00030	8b 07		 mov	 eax, DWORD PTR [edi]
  00032	89 58 08	 mov	 DWORD PTR [eax+8], ebx
  00035	eb 1f		 jmp	 SHORT $LN11@Insert_at
$LN6@Insert_at:

; 1844 : 			}
; 1845 : 		else if (_Addleft)

  00037	80 7d 0c 00	 cmp	 BYTE PTR __Addleft$[ebp], 0
  0003b	74 0c		 je	 SHORT $LN8@Insert_at

; 1846 : 			{	// add to left of _Wherenode
; 1847 : 			this->_Left(_Wherenode) = _Newnode;

  0003d	89 18		 mov	 DWORD PTR [eax], ebx

; 1848 : 			if (_Wherenode == _Lmost())

  0003f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00041	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00043	75 11		 jne	 SHORT $LN11@Insert_at

; 1849 : 				_Lmost() = _Newnode;

  00045	89 19		 mov	 DWORD PTR [ecx], ebx

; 1850 : 			}
; 1851 : 		else

  00047	eb 0d		 jmp	 SHORT $LN11@Insert_at
$LN8@Insert_at:

; 1852 : 			{	// add to right of _Wherenode
; 1853 : 			this->_Right(_Wherenode) = _Newnode;

  00049	89 58 08	 mov	 DWORD PTR [eax+8], ebx

; 1854 : 			if (_Wherenode == _Rmost())

  0004c	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0004e	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00051	75 03		 jne	 SHORT $LN11@Insert_at

; 1855 : 				_Rmost() = _Newnode;

  00053	89 59 08	 mov	 DWORD PTR [ecx+8], ebx
$LN11@Insert_at:

; 1856 : 			}
; 1857 : 
; 1858 : 		for (_Nodeptr _Pnode = _Newnode;
; 1859 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00056	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00059	8b f3		 mov	 esi, ebx
  0005b	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  0005f	0f 85 0a 01 00
	00		 jne	 $LN3@Insert_at
$LL2@Insert_at:

; 1860 : 			if (this->_Parent(_Pnode)
; 1861 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00065	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00068	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0006b	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0006d	3b c1		 cmp	 eax, ecx
  0006f	75 74		 jne	 SHORT $LN12@Insert_at

; 1862 : 				{	// fixup red-red in left subtree
; 1863 : 				_Wherenode =

  00071	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]

; 1864 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1865 : 				if (this->_Color(_Wherenode) == this->_Red)

  00074	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00078	74 71		 je	 SHORT $LN726@Insert_at

; 1866 : 					{	// parent has two red children, blacken both
; 1867 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1868 : 					this->_Color(_Wherenode) = this->_Black;
; 1869 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1870 : 						= this->_Red;
; 1871 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1872 : 					}
; 1873 : 				else
; 1874 : 					{	// parent has red and black children
; 1875 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  0007a	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0007d	75 0a		 jne	 SHORT $LN16@Insert_at

; 1876 : 						{	// rotate right child to left
; 1877 : 						_Pnode = this->_Parent(_Pnode);

  0007f	8b f0		 mov	 esi, eax

; 1878 : 						_Lrotate(_Pnode);

  00081	8b cf		 mov	 ecx, edi
  00083	56		 push	 esi
  00084	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Lrotate
$LN16@Insert_at:

; 1879 : 						}
; 1880 : 					this->_Color(this->_Parent(_Pnode)) =

  00089	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0008c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 1881 : 						this->_Black;	// propagate red up
; 1882 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

  00090	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00093	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00096	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1883 : 						this->_Red;
; 1884 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  0009a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a2	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax
  000a7	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000aa	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000ae	75 03		 jne	 SHORT $LN373@Insert_at
  000b0	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN373@Insert_at:
  000b3	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000b6	89 42 04	 mov	 DWORD PTR [edx+4], eax
  000b9	8b 07		 mov	 eax, DWORD PTR [edi]
  000bb	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000be	75 0b		 jne	 SHORT $LN374@Insert_at
  000c0	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000c3	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

  000c6	e9 94 00 00 00	 jmp	 $LN725@Insert_at

; 1883 : 						this->_Red;
; 1884 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN374@Insert_at:
  000cb	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000ce	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  000d1	75 0b		 jne	 SHORT $LN376@Insert_at
  000d3	89 50 08	 mov	 DWORD PTR [eax+8], edx
  000d6	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

  000d9	e9 81 00 00 00	 jmp	 $LN725@Insert_at

; 1883 : 						this->_Red;
; 1884 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN376@Insert_at:
  000de	89 10		 mov	 DWORD PTR [eax], edx
  000e0	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

  000e3	eb 7a		 jmp	 SHORT $LN725@Insert_at
$LN12@Insert_at:

; 1888 : 				{	// fixup red-red in right subtree
; 1889 : 				_Wherenode =
; 1890 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1891 : 				if (this->_Color(_Wherenode) == this->_Red)

  000e5	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  000e9	75 1a		 jne	 SHORT $LN17@Insert_at
$LN726@Insert_at:

; 1892 : 					{	// parent has two red children, blacken both
; 1893 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  000eb	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 1894 : 					this->_Color(_Wherenode) = this->_Black;

  000ef	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1895 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

  000f3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f9	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1896 : 						this->_Red;
; 1897 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  000fd	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00100	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 1898 : 					}
; 1899 : 				else

  00103	eb 5d		 jmp	 SHORT $LN18@Insert_at
$LN17@Insert_at:

; 1900 : 					{	// parent has red and black children
; 1901 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00105	3b 30		 cmp	 esi, DWORD PTR [eax]
  00107	75 0a		 jne	 SHORT $LN19@Insert_at

; 1902 : 						{	// rotate left child to right
; 1903 : 						_Pnode = this->_Parent(_Pnode);

  00109	8b f0		 mov	 esi, eax

; 1904 : 						_Rrotate(_Pnode);

  0010b	8b cf		 mov	 ecx, edi
  0010d	56		 push	 esi
  0010e	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Rrotate
$LN19@Insert_at:

; 1905 : 						}
; 1906 : 					this->_Color(this->_Parent(_Pnode)) =

  00113	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00116	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 1907 : 						this->_Black;	// propagate red up
; 1908 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

  0011a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0011d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00120	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 1909 : 						this->_Red;
; 1910 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  00124	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00127	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0012d	8b 02		 mov	 eax, DWORD PTR [edx]
  0012f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00132	8b 02		 mov	 eax, DWORD PTR [edx]
  00134	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00138	75 03		 jne	 SHORT $LN572@Insert_at
  0013a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN572@Insert_at:
  0013d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00140	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00143	8b 07		 mov	 eax, DWORD PTR [edi]
  00145	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00148	75 05		 jne	 SHORT $LN573@Insert_at
  0014a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0014d	eb 0e		 jmp	 SHORT $LN576@Insert_at
$LN573@Insert_at:
  0014f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00152	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00154	75 04		 jne	 SHORT $LN575@Insert_at
  00156	89 10		 mov	 DWORD PTR [eax], edx
  00158	eb 03		 jmp	 SHORT $LN576@Insert_at
$LN575@Insert_at:
  0015a	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN576@Insert_at:
  0015d	89 0a		 mov	 DWORD PTR [edx], ecx
$LN725@Insert_at:
  0015f	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN18@Insert_at:

; 1856 : 			}
; 1857 : 
; 1858 : 		for (_Nodeptr _Pnode = _Newnode;
; 1859 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00162	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00165	80 78 0c 00	 cmp	 BYTE PTR [eax+12], 0
  00169	0f 84 f6 fe ff
	ff		 je	 $LL2@Insert_at
$LN3@Insert_at:

; 1911 : 					}
; 1912 : 				}
; 1913 : 
; 1914 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  0016f	8b 07		 mov	 eax, DWORD PTR [edi]
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00176	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 1915 : 		return (iterator(_Newnode, &this->_Get_data()));

  0017a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0017d	89 18		 mov	 DWORD PTR [eax], ebx
  0017f	5b		 pop	 ebx

; 1916 : 		}

  00180	5d		 pop	 ebp
  00181	c2 14 00	 ret	 20			; 00000014H
$LN727@Insert_at:

; 1829 : 			{	// tree would get too big, fail
; 1830 : 			_Destroy_if_not_nil(_Node);

  00184	ff 75 18	 push	 DWORD PTR __Node$[ebp]
  00187	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0018c	83 c4 04	 add	 esp, 4

; 1831 : 			_Xlength_error("map/set<T> too long");

  0018f	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  00194	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN729@Insert_at:
$LN724@Insert_at:
  00199	cc		 int	 3
??$_Insert_at@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_at<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@YAAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@YAAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@YAAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$ = 20					; size = 4
??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::construct<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 0d		 je	 SHORT $LN25@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	89 01		 mov	 DWORD PTR [ecx], eax
  00013	c6 41 08 00	 mov	 BYTE PTR [ecx+8], 0
$LN25@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00017	5d		 pop	 ebp
  00018	c2 10 00	 ret	 16			; 00000010H
??$construct@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::construct<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$?0ABK@?$_Tuple_val@ABK@std@@QAE@ABK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$?0ABK@?$_Tuple_val@ABK@std@@QAE@ABK@Z PROC		; std::_Tuple_val<unsigned long const &>::_Tuple_val<unsigned long const &><unsigned long const &>, COMDAT
; _this$ = ecx

; 164  : 		{	// construct with argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 165  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??$?0ABK@?$_Tuple_val@ABK@std@@QAE@ABK@Z ENDP		; std::_Tuple_val<unsigned long const &>::_Tuple_val<unsigned long const &><unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z PROC ; std::tuple<>::tuple<><std::_Exact_args_t,0>, COMDAT
; _this$ = ecx

; 256  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ENDP ; std::tuple<>::tuple<><std::_Exact_args_t,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy_al_unchecked@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<GostCrypt::SecurityTokenKeyfile const *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >, COMDAT

; 248  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 249  : 	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00017	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::SecurityTokenKeyfile const *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 250  : 		_Ptr_copy_cat(_First, _Dest),
; 251  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), decltype(*_First)>()));
; 252  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_copy_al_unchecked@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<GostCrypt::SecurityTokenKeyfile const *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@YAPBUSecurityTokenKeyfile@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@YAPBUSecurityTokenKeyfile@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >, COMDAT

; 271  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 272  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 273  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@YAPBUSecurityTokenKeyfile@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PBKPAKV?$allocator@K@std@@@std@@YAPAKPBK0PAKAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy_al_unchecked@PBKPAKV?$allocator@K@std@@@std@@YAPAKPBK0PAKAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<unsigned long const *,unsigned long *,std::allocator<unsigned long> >, COMDAT

; 248  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 249  : 	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 250  : 		_Ptr_copy_cat(_First, _Dest),
; 251  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), decltype(*_First)>()));
; 252  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Uninitialized_copy_al_unchecked@PBKPAKV?$allocator@K@std@@@std@@YAPAKPBK0PAKAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<unsigned long const *,unsigned long *,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@YAPBKV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@YAPBKV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<unsigned long> > >, COMDAT

; 271  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 272  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 273  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@YAPBKV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Newroot$ = 12						; size = 4
__Wherenode$ = 12					; size = 4
__Movefl$ = 16						; size = 1
??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_tag>, COMDAT
; _this$ = ecx

; 1959 : 		{	// copy entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 1960 : 		_Nodeptr _Newroot = this->_Myhead();	// point at nil node
; 1961 : 
; 1962 : 		if (!this->_Isnil(_Rootnode))

  00030	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00033	8b 3e		 mov	 edi, DWORD PTR [esi]
  00035	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00039	75 4e		 jne	 SHORT $LN8@Copy_nodes

; 1963 : 			{	// copy or move a node, then any subtrees
; 1964 : 			typename is_same<key_type, value_type>::type _Is_set;
; 1965 : 			_Nodeptr _Pnode = _Copy_or_move(

  0003b	83 c0 10	 add	 eax, 16			; 00000010H
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??$_Buynode@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &>

; 1966 : 				this->_Myval(_Rootnode), _Movefl, _Is_set);
; 1967 : 			_Pnode->_Parent = _Wherenode;
; 1968 : 			_Pnode->_Color = this->_Color(_Rootnode);

  00044	8b 4d 08	 mov	 ecx, DWORD PTR __Rootnode$[ebp]
  00047	8b d8		 mov	 ebx, eax
  00049	8b 45 0c	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 1969 : 			if (this->_Isnil(_Newroot))
; 1970 : 				_Newroot = _Pnode;	// memorize new root
; 1971 : 
; 1972 : 			_TRY_BEGIN

  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00053	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00056	8a 41 0c	 mov	 al, BYTE PTR [ecx+12]
  00059	88 43 0c	 mov	 BYTE PTR [ebx+12], al

; 1973 : 			this->_Left(_Pnode) =

  0005c	ff 75 10	 push	 DWORD PTR __Movefl$[ebp]
  0005f	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00063	53		 push	 ebx
  00064	ff 31		 push	 DWORD PTR [ecx]
  00066	0f 45 fb	 cmovne	 edi, ebx
  00069	8b ce		 mov	 ecx, esi
  0006b	89 7d 0c	 mov	 DWORD PTR __Newroot$[ebp], edi
  0006e	e8 00 00 00 00	 call	 ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_tag>
  00073	89 03		 mov	 DWORD PTR [ebx], eax

; 1974 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1975 : 			this->_Right(_Pnode) =

  00075	8b ce		 mov	 ecx, esi
  00077	ff 75 10	 push	 DWORD PTR __Movefl$[ebp]
  0007a	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0007d	53		 push	 ebx
  0007e	ff 70 08	 push	 DWORD PTR [eax+8]
  00081	e8 00 00 00 00	 call	 ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_tag>
  00086	89 43 08	 mov	 DWORD PTR [ebx+8], eax
$LN8@Copy_nodes:

; 1980 : 			_CATCH_END
; 1981 : 			}
; 1982 : 
; 1983 : 		return (_Newroot);	// return newly constructed tree

  00089	8b c7		 mov	 eax, edi

; 1984 : 		}

  0008b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00095	59		 pop	 ecx
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
__catch$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z$0:

; 1976 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1977 : 			_CATCH_ALL
; 1978 : 			_Erase(_Newroot);	// subtree copy failed, bail out

  0009f	ff 75 0c	 push	 DWORD PTR __Newroot$[ebp]
  000a2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Erase

; 1979 : 			_RERAISE;

  000aa	6a 00		 push	 0
  000ac	6a 00		 push	 0
  000ae	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN58@Copy_nodes:
$LN57@Copy_nodes:
  000b3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_tag>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABU?$less@K@std@@U_One_then_variadic_args_t@1@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@K@1@$$QAU21@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
_<_Val2_1>$ = 20					; size = 4
??$?0ABU?$less@K@std@@U_One_then_variadic_args_t@1@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@K@1@$$QAU21@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::less<unsigned long>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>,1>::_Compressed_pair<std::less<unsigned long>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>,1><std::less<unsigned long> const &,std::_One_then_variadic_args_t,std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 290  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c2 10 00	 ret	 16			; 00000010H
??$?0ABU?$less@K@std@@U_One_then_variadic_args_t@1@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@K@1@$$QAU21@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::less<unsigned long>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>,1>::_Compressed_pair<std::less<unsigned long>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>,1><std::less<unsigned long> const &,std::_One_then_variadic_args_t,std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@EEV?$allocator@E@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked1@EEV?$allocator@E@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<unsigned char,unsigned char,std::allocator<unsigned char> >, COMDAT

; 292  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 293  : 	return (_Copy_memmove(_First, _Last, _Dest));

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 294  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Uninitialized_move_al_unchecked1@EEV?$allocator@E@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<unsigned char,unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@EE@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAE0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_move_cat@EE@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAE0@Z PROC ; std::_Ptr_move_cat<unsigned char,unsigned char>, COMDAT

; 809  : 	{	// return pointer move optimization category for pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 810  : 	return {};

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 811  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Ptr_move_cat@EE@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAE0@Z ENDP ; std::_Ptr_move_cat<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@USecurityTokenKeyfile@GostCrypt@@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@USecurityTokenKeyfile@GostCrypt@@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@@Z PROC ; std::allocator_traits<std::allocator<GostCrypt::SecurityTokenKeyfile> >::destroy<GostCrypt::SecurityTokenKeyfile>, COMDAT

; 863  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 864  : 		_Al.destroy(_Ptr);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 865  : 		}

  00006	5d		 pop	 ebp

; 864  : 		_Al.destroy(_Ptr);

  00007	e9 00 00 00 00	 jmp	 ??1SecurityTokenKeyfile@GostCrypt@@QAE@XZ
??$destroy@USecurityTokenKeyfile@GostCrypt@@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@@Z ENDP ; std::allocator_traits<std::allocator<GostCrypt::SecurityTokenKeyfile> >::destroy<GostCrypt::SecurityTokenKeyfile>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked1@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<GostCrypt::SecurityTokenKeyfile *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >, COMDAT

; 273  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 274  : 	_FwdIt _Next = _Dest;
; 275  : 
; 276  : 	_TRY_BEGIN
; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 21		 je	 SHORT $LN39@Uninitiali
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL4@Uninitiali:

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));

  00013	85 ff		 test	 edi, edi
  00015	74 08		 je	 SHORT $LN2@Uninitiali
  00017	56		 push	 esi
  00018	8b cf		 mov	 ecx, edi
  0001a	e8 00 00 00 00	 call	 ??0SecurityTokenKeyfile@GostCrypt@@QAE@$$QAU01@@Z
$LN2@Uninitiali:

; 274  : 	_FwdIt _Next = _Dest;
; 275  : 
; 276  : 	_TRY_BEGIN
; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  0001f	83 c6 70	 add	 esi, 112		; 00000070H
  00022	83 c7 70	 add	 edi, 112		; 00000070H
  00025	3b f3		 cmp	 esi, ebx
  00027	75 ea		 jne	 SHORT $LL4@Uninitiali

; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);
; 281  : 	_RERAISE;
; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);

  00029	8b c7		 mov	 eax, edi
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx

; 285  : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN39@Uninitiali:

; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);
; 281  : 	_RERAISE;
; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);

  00030	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx

; 285  : 	}

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_move_al_unchecked1@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<GostCrypt::SecurityTokenKeyfile *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@USecurityTokenKeyfile@GostCrypt@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUSecurityTokenKeyfile@GostCrypt@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_move_cat@USecurityTokenKeyfile@GostCrypt@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUSecurityTokenKeyfile@GostCrypt@@0@Z PROC ; std::_Ptr_move_cat<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile>, COMDAT

; 810  : 	return {};

  00000	32 c0		 xor	 al, al

; 811  : 	}

  00002	c3		 ret	 0
??$_Ptr_move_cat@USecurityTokenKeyfile@GostCrypt@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUSecurityTokenKeyfile@GostCrypt@@0@Z ENDP ; std::_Ptr_move_cat<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAUSecurityTokenKeyfile@GostCrypt@@@std@@YA$$QAUSecurityTokenKeyfile@GostCrypt@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUSecurityTokenKeyfile@GostCrypt@@@std@@YA$$QAUSecurityTokenKeyfile@GostCrypt@@AAU12@@Z PROC ; std::move<GostCrypt::SecurityTokenKeyfile &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUSecurityTokenKeyfile@GostCrypt@@@std@@YA$$QAUSecurityTokenKeyfile@GostCrypt@@AAU12@@Z ENDP ; std::move<GostCrypt::SecurityTokenKeyfile &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z PROC ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >, COMDAT
; _this$ = ecx

; 554  : 		constexpr _Any_tag(_Ty&&) _NOEXCEPT {}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ENDP ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@KKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked1@KKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<unsigned long,unsigned long,std::allocator<unsigned long> >, COMDAT

; 292  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 293  : 	return (_Copy_memmove(_First, _Last, _Dest));

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 294  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Uninitialized_move_al_unchecked1@KKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<unsigned long,unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@KK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAK0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_move_cat@KK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAK0@Z PROC ; std::_Ptr_move_cat<unsigned long,unsigned long>, COMDAT

; 809  : 	{	// return pointer move optimization category for pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 810  : 	return {};

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 811  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Ptr_move_cat@KK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAK0@Z ENDP ; std::_Ptr_move_cat<unsigned long,unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@USecurityTokenInfo@GostCrypt@@U12@@?$allocator_traits@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@1@PAUSecurityTokenInfo@GostCrypt@@$$QAU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@USecurityTokenInfo@GostCrypt@@U12@@?$allocator_traits@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@1@PAUSecurityTokenInfo@GostCrypt@@$$QAU34@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::construct<GostCrypt::SecurityTokenInfo,GostCrypt::SecurityTokenInfo>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00004	8b 7d 0c	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 4b		 je	 SHORT $LN8@construct
  0000b	56		 push	 esi
  0000c	8b 75 10	 mov	 esi, DWORD PTR _<_Args_0>$[ebp]
  0000f	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00012	33 d2		 xor	 edx, edx
  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	89 07		 mov	 DWORD PTR [edi], eax
  00018	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001b	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0001e	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00021	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  00028	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0002f	50		 push	 eax
  00030	66 89 11	 mov	 WORD PTR [ecx], dx
  00033	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  00038	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  0003b	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  0003e	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00045	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0004c	50		 push	 eax
  0004d	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00050	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00055	5e		 pop	 esi
$LN8@construct:
  00056	5f		 pop	 edi

; 858  : 		}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
??$construct@USecurityTokenInfo@GostCrypt@@U12@@?$allocator_traits@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@1@PAUSecurityTokenInfo@GostCrypt@@$$QAU34@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::construct<GostCrypt::SecurityTokenInfo,GostCrypt::SecurityTokenInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@KABK@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAKABK@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@KABK@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAKABK@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<unsigned long,void *> > >::construct<unsigned long,unsigned long const &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@KABK@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAKABK@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<unsigned long,void *> > >::construct<unsigned long,unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > > &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 8
_this$1$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_hint<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>, COMDAT
; _this$ = ecx

; 1655 : 		{	// try to insert node using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	89 4d ec	 mov	 DWORD PTR _this$1$[ebp], ecx

; 1656 : 		const_iterator _Next;
; 1657 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1658 : 
; 1659 : 		_TRY_BEGIN
; 1660 : 
; 1661 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1662 : 		if (_Where._Getcont() != &this->_Get_data())
; 1663 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1664 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1665 : 
; 1666 : 		if (size() == 0)

  0002e	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00039	75 29		 jne	 SHORT $LN3@Insert_hin

; 1667 : 			return (_Insert_at(true, this->_Myhead(),

  0003b	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0003e	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00041	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  00044	ff 31		 push	 DWORD PTR [ecx]
  00046	6a 01		 push	 1
  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_at<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
  0004e	8b c6		 mov	 eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 10 00	 ret	 16			; 00000010H
$LN3@Insert_hin:

; 1668 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1669 : 		else if (this->_Multi)
; 1670 : 			{	// insert even if duplicate
; 1671 : 			if (_Where == begin())
; 1672 : 				{	// insert at beginning if before first element
; 1673 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1674 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1675 : 					return (_Insert_at(true, _Where._Mynode(),
; 1676 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1677 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1678 : 				}
; 1679 : 			else if (_Where == end())
; 1680 : 				{	// insert at end if after last element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1683 : 					return (_Insert_at(false, _Rmost(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				}
; 1686 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1687 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1688 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1689 : 					this->_Kfn(_Val),
; 1690 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1691 : 				{	// insert before _Where
; 1692 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1693 : 					return (_Insert_at(false, _Next._Mynode(),
; 1694 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1695 : 				else
; 1696 : 					return (_Insert_at(true, _Where._Mynode(),
; 1697 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1698 : 				}
; 1699 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1700 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1701 : 				&& (++(_Next = _Where) == end()
; 1702 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1703 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1704 : 				{	// insert after _Where
; 1705 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1706 : 					return (_Insert_at(false, _Where._Mynode(),
; 1707 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1708 : 				else
; 1709 : 					return (_Insert_at(true, _Next._Mynode(),
; 1710 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1711 : 				}
; 1712 : 			else
; 1713 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1714 : 			}
; 1715 : 		else
; 1716 : 			{	// insert only if unique
; 1717 : 			if (_Where == begin())

  00064	8b 39		 mov	 edi, DWORD PTR [ecx]
  00066	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]

; 1718 : 				{	// insert at beginning if before first element
; 1719 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

  00069	8b 5d 10	 mov	 ebx, DWORD PTR __Val$[ebp]
  0006c	3b 37		 cmp	 esi, DWORD PTR [edi]
  0006e	75 31		 jne	 SHORT $LN22@Insert_hin
  00070	8b 03		 mov	 eax, DWORD PTR [ebx]
  00072	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
  00075	0f 83 40 01 00
	00		 jae	 $LN35@Insert_hin

; 1720 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1721 : 					return (_Insert_at(true, _Where._Mynode(),

  0007b	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  0007e	53		 push	 ebx
$LN30@Insert_hin:
  0007f	56		 push	 esi
  00080	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00083	6a 01		 push	 1
  00085	56		 push	 esi
  00086	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_at<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
  0008b	8b c6		 mov	 eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 10 00	 ret	 16			; 00000010H
$LN22@Insert_hin:

; 1722 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1723 : 				}
; 1724 : 			else if (_Where == end())

  000a1	3b f7		 cmp	 esi, edi
  000a3	75 34		 jne	 SHORT $LN25@Insert_hin

; 1725 : 				{	// insert at end if after last element
; 1726 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

  000a5	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  000a8	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000ab	3b 03		 cmp	 eax, DWORD PTR [ebx]
  000ad	0f 83 08 01 00
	00		 jae	 $LN35@Insert_hin

; 1727 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1728 : 					return (_Insert_at(false, _Rmost(),

  000b3	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000b6	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  000b9	53		 push	 ebx
  000ba	52		 push	 edx
  000bb	6a 00		 push	 0
  000bd	56		 push	 esi
  000be	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_at<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
  000c3	8b c6		 mov	 eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

  000c5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cf	59		 pop	 ecx
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c2 10 00	 ret	 16			; 00000010H
$LN25@Insert_hin:

; 1729 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1730 : 				}
; 1731 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1732 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  000d9	8b 03		 mov	 eax, DWORD PTR [ebx]
  000db	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000de	3b c8		 cmp	 ecx, eax
  000e0	76 52		 jbe	 SHORT $LN800@Insert_hin
  000e2	8d 4d 10	 lea	 ecx, DWORD PTR __Next$[ebp]
  000e5	89 75 10	 mov	 DWORD PTR __Next$[ebp], esi
  000e8	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::operator--
  000ed	8b 45 10	 mov	 eax, DWORD PTR __Next$[ebp]
  000f0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000f2	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  000f5	73 36		 jae	 SHORT $LN797@Insert_hin

; 1734 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1735 : 					this->_Kfn(_Val)))
; 1736 : 				{	// insert before _Where
; 1737 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  000f7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 1738 : 					return (_Insert_at(false, _Next._Mynode(),

  000fa	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  000fd	53		 push	 ebx
  000fe	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00102	8b 4d ec	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00105	0f 84 74 ff ff
	ff		 je	 $LN30@Insert_hin
  0010b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0010e	50		 push	 eax
  0010f	6a 00		 push	 0
  00111	56		 push	 esi
  00112	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_at<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
  00117	8b c6		 mov	 eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

  00119	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0011c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00123	59		 pop	 ecx
  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	5b		 pop	 ebx
  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c2 10 00	 ret	 16			; 00000010H
$LN797@Insert_hin:
  0012d	8b c1		 mov	 eax, ecx
  0012f	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]

; 1739 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1740 : 				else
; 1741 : 					return (_Insert_at(true, _Where._Mynode(),
; 1742 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1743 : 				}
; 1744 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1745 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1746 : 				&& (++(_Next = _Where) == end()

  00132	3b c8		 cmp	 ecx, eax
$LN800@Insert_hin:
  00134	0f 83 81 00 00
	00		 jae	 $LN35@Insert_hin
  0013a	8d 4d 10	 lea	 ecx, DWORD PTR __Next$[ebp]
  0013d	89 75 10	 mov	 DWORD PTR __Next$[ebp], esi
  00140	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::operator++
  00145	8b 45 10	 mov	 eax, DWORD PTR __Next$[ebp]
  00148	3b c7		 cmp	 eax, edi
  0014a	74 07		 je	 SHORT $LN33@Insert_hin
  0014c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0014e	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00151	73 68		 jae	 SHORT $LN35@Insert_hin
$LN33@Insert_hin:

; 1747 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1748 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1749 : 				{	// insert after _Where
; 1750 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  00153	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1751 : 					return (_Insert_at(false, _Where._Mynode(),

  00156	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  00159	53		 push	 ebx
  0015a	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0015e	8b 4d ec	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00161	74 22		 je	 SHORT $LN34@Insert_hin
  00163	56		 push	 esi
  00164	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00167	6a 00		 push	 0
  00169	56		 push	 esi
  0016a	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_at<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
  0016f	8b c6		 mov	 eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

  00171	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00174	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0017b	59		 pop	 ecx
  0017c	5f		 pop	 edi
  0017d	5e		 pop	 esi
  0017e	5b		 pop	 ebx
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c2 10 00	 ret	 16			; 00000010H
$LN34@Insert_hin:

; 1752 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1753 : 				else
; 1754 : 					return (_Insert_at(true, _Next._Mynode(),

  00185	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00188	50		 push	 eax
  00189	6a 01		 push	 1
  0018b	56		 push	 esi
  0018c	e8 00 00 00 00	 call	 ??$_Insert_at@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@1@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_at<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
  00191	8b c6		 mov	 eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

  00193	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00196	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0019d	59		 pop	 ecx
  0019e	5f		 pop	 edi
  0019f	5e		 pop	 esi
  001a0	5b		 pop	 ebx
  001a1	8b e5		 mov	 esp, ebp
  001a3	5d		 pop	 ebp
  001a4	c2 10 00	 ret	 16			; 00000010H
__catch$??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z$0:

; 1755 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1756 : 				}
; 1757 : 			}
; 1758 : 		_CATCH_ALL
; 1759 : 		_Destroy_if_not_nil(_Newnode);

  001a7	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  001aa	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001af	83 c4 04	 add	 esp, 4

; 1760 : 		_RERAISE;

  001b2	6a 00		 push	 0
  001b4	6a 00		 push	 0
  001b6	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN801@Insert_hin:
$LN35@Insert_hin:

; 1761 : 		_CATCH_END
; 1762 : 
; 1763 : 		return (_Insert_nohint(_Leftish,

  001bb	ff 75 14	 push	 DWORD PTR __Newnode$[ebp]
  001be	8b 4d ec	 mov	 ecx, DWORD PTR _this$1$[ebp]
  001c1	8d 45 e4	 lea	 eax, DWORD PTR $T2[ebp]
  001c4	53		 push	 ebx
  001c5	6a 00		 push	 0
  001c7	50		 push	 eax
  001c8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001cf	e8 00 00 00 00	 call	 ??$_Insert_nohint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_nohint<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
  001d4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d6	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001d9	89 08		 mov	 DWORD PTR [eax], ecx

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

  001db	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001de	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e5	59		 pop	 ecx
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi
  001e8	5b		 pop	 ebx
  001e9	8b e5		 mov	 esp, ebp
  001eb	5d		 pop	 ebp
  001ec	c2 10 00	 ret	 16			; 00000010H
$LN799@Insert_hin:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_hint<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
_<_Val_1>$ = 12						; size = 4
_<_Val_2>$ = 16						; size = 4
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 880  : 		{	// allocate a node with defaults and set links and value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 881  : 		_Nodeptr _Pnode = _Buynode0();

  00003	e8 00 00 00 00	 call	 ?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode0

; 882  : 
; 883  : 		this->_Color(_Pnode) = _Red;
; 884  : 		this->_Isnil(_Pnode) = false;
; 885  : 
; 886  : 		_TRY_BEGIN
; 887  : 		this->_Getal().construct(

  00008	8d 50 10	 lea	 edx, DWORD PTR [eax+16]
  0000b	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0
  00011	85 d2		 test	 edx, edx
  00013	74 0d		 je	 SHORT $LN65@Buynode
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_1>$[ebp]
  00018	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001c	89 0a		 mov	 DWORD PTR [edx], ecx
  0001e	c6 42 08 00	 mov	 BYTE PTR [edx+8], 0
$LN65@Buynode:

; 888  : 			_STD addressof(_Myval(_Pnode)),
; 889  : 				_STD forward<_Valty>(_Val)...);
; 890  : 		_CATCH_ALL
; 891  : 		_Freenode0(_Pnode);
; 892  : 		_RERAISE;
; 893  : 		_CATCH_END
; 894  : 
; 895  : 		return (_Pnode);
; 896  : 		}

  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z PROC ; std::forward<std::tuple<> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z ENDP ; std::forward<std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$tuple@ABK@std@@@std@@YA$$QAV?$tuple@ABK@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$tuple@ABK@std@@@std@@YA$$QAV?$tuple@ABK@0@AAV10@@Z PROC ; std::forward<std::tuple<unsigned long const &> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$tuple@ABK@std@@@std@@YA$$QAV?$tuple@ABK@0@AAV10@@Z ENDP ; std::forward<std::tuple<unsigned long const &> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z PROC ; std::forward<std::piecewise_construct_t const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z ENDP ; std::forward<std::piecewise_construct_t const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$?0ABK$0A@@?$tuple@ABK@std@@QAE@ABK@Z
_TEXT	SEGMENT
__This_arg$ = 8						; size = 4
??$?0ABK$0A@@?$tuple@ABK@std@@QAE@ABK@Z PROC		; std::tuple<unsigned long const &>::tuple<unsigned long const &><unsigned long const &,0>, COMDAT
; _this$ = ecx

; 428  : 		{	// construct from one or more copied elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 427  : 		: _Mybase(_Exact_args_t{}, _Rest_arg...), _Myfirst(_This_arg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __This_arg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 429  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??$?0ABK$0A@@?$tuple@ABK@std@@QAE@ABK@Z ENDP		; std::tuple<unsigned long const &>::tuple<unsigned long const &><unsigned long const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YA$$QAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YA$$QAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@0@AAV10@@Z PROC ; std::forward<std::allocator<GostCrypt::SecurityTokenKeyfile> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YA$$QAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<GostCrypt::SecurityTokenKeyfile> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@0@AAV10@@Z PROC ; std::forward<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@K@std@@@std@@YA$$QAV?$allocator@K@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@K@std@@@std@@YA$$QAV?$allocator@K@0@AAV10@@Z PROC ; std::forward<std::allocator<unsigned long> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@K@std@@@std@@YA$$QAV?$allocator@K@0@AAV10@@Z ENDP ; std::forward<std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_List_node@KPAX@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_List_node@KPAX@std@@@0@AAV10@@Z PROC ; std::forward<std::allocator<std::_List_node<unsigned long,void *> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_List_node@KPAX@std@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<std::_List_node<unsigned long,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@PAUSecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@2@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@0@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@PAUSecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@2@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@0@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >, COMDAT

; 259  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 260  : 		// note: only called internally from elsewhere in the STL, debug checks
; 261  : 		// and deprecation warnings omitted
; 262  : 	return (_Rechecked(_Dest,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00017	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::SecurityTokenKeyfile const *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 263  : 		_Uninitialized_copy_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 264  : 			_Unchecked(_Dest), _Al)));
; 265  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@PAUSecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@2@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@0@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@PAKV?$allocator@K@2@@std@@YAPAKV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@0PAKAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@PAKV?$allocator@K@2@@std@@YAPAKV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@0PAKAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >,unsigned long *,std::allocator<unsigned long> >, COMDAT

; 259  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 260  : 		// note: only called internally from elsewhere in the STL, debug checks
; 261  : 		// and deprecation warnings omitted
; 262  : 	return (_Rechecked(_Dest,

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 263  : 		_Uninitialized_copy_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 264  : 			_Unchecked(_Dest), _Al)));
; 265  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@PAKV?$allocator@K@2@@std@@YAPAKV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@0@0PAKAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >,unsigned long *,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z PROC ; std::list<unsigned long,std::allocator<unsigned long> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > > >, COMDAT
; _this$ = ecx

; 1426 : 		{	// insert [_First, _Last) at _Where, forward iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d e8	 mov	 DWORD PTR _this$[ebp], edi

; 1427 : 		_DEBUG_RANGE(_First, _Last);
; 1428 : 		_Iter _Next = _First;

  00030	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00033	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 1429 : 
; 1430 : 		_TRY_BEGIN

  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003d	0f 1f 00	 npad	 3
$LL4@Insert_ran:

; 1431 : 		for (; _First != _Last; ++_First)

  00040	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  00043	74 6b		 je	 SHORT $LN3@Insert_ran

; 1432 : 			_Insert(_Where, *_First);

  00045	8b 75 08	 mov	 esi, DWORD PTR __Where$[ebp]
  00048	83 c0 08	 add	 eax, 8
  0004b	50		 push	 eax
  0004c	8b cf		 mov	 ecx, edi
  0004e	ff 76 04	 push	 DWORD PTR [esi+4]
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ??$_Buynode@ABK@?$_List_buy@KV?$allocator@K@std@@@std@@QAEPAU?$_List_node@KPAX@1@PAU21@0ABK@Z ; std::_List_buy<unsigned long,std::allocator<unsigned long> >::_Buynode<unsigned long const &>
  00057	8b d0		 mov	 edx, eax
  00059	b9 54 55 55 15	 mov	 ecx, 357913940		; 15555554H
  0005e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00061	2b c8		 sub	 ecx, eax
  00063	83 f9 01	 cmp	 ecx, 1
  00066	73 0a		 jae	 SHORT $LN38@Insert_ran
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN111@Insert_ran:
$LN38@Insert_ran:
  00072	40		 inc	 eax
  00073	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00076	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00079	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007c	89 10		 mov	 DWORD PTR [eax], edx
  0007e	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00081	8b 00		 mov	 eax, DWORD PTR [eax]
  00083	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
  00086	eb b8		 jmp	 SHORT $LL4@Insert_ran
__catch$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$0:

; 1433 : 		_CATCH_ALL
; 1434 : 		for (; _Next != _First; ++_Next)

  00088	8b 75 ec	 mov	 esi, DWORD PTR __Next$[ebp]
  0008b	3b 75 0c	 cmp	 esi, DWORD PTR __First$[ebp]
  0008e	74 17		 je	 SHORT $LN6@Insert_ran
  00090	8b 7d e8	 mov	 edi, DWORD PTR _this$[ebp]
$LL7@Insert_ran:

; 1435 : 			{	// undo inserts
; 1436 : 			_Unchecked_const_iterator _Before = _Where;
; 1437 : 			_Unchecked_erase(--_Before);

  00093	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00096	8b cf		 mov	 ecx, edi
  00098	ff 70 04	 push	 DWORD PTR [eax+4]
  0009b	e8 00 00 00 00	 call	 ?_Unchecked_erase@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::list<unsigned long,std::allocator<unsigned long> >::_Unchecked_erase
  000a0	8b 36		 mov	 esi, DWORD PTR [esi]
  000a2	3b 75 0c	 cmp	 esi, DWORD PTR __First$[ebp]
  000a5	75 ec		 jne	 SHORT $LL7@Insert_ran
$LN6@Insert_ran:

; 1438 : 			}
; 1439 : 		_RERAISE;

  000a7	6a 00		 push	 0
  000a9	6a 00		 push	 0
  000ab	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN112@Insert_ran:
$LN3@Insert_ran:

; 1440 : 		_CATCH_END
; 1441 : 		}

  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 10 00	 ret	 16			; 00000010H
$LN110@Insert_ran:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Copy@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Movefl$ = 12						; size = 1
??$_Copy@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy<std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_tag>, COMDAT
; _this$ = ecx

; 1920 : 		{	// copy or move entire tree from _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1921 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead(), _Movefl);

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	ff 75 0c	 push	 DWORD PTR __Movefl$[ebp]
  0000e	8b 07		 mov	 eax, DWORD PTR [edi]
  00010	8b 33		 mov	 esi, DWORD PTR [ebx]
  00012	56		 push	 esi
  00013	ff 70 04	 push	 DWORD PTR [eax+4]
  00016	e8 00 00 00 00	 call	 ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_nodes<std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_tag>
  0001b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1922 : 		this->_Mysize() = _Right.size();

  0001e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00021	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 1923 : 		if (!this->_Isnil(_Root()))

  00024	8b 13		 mov	 edx, DWORD PTR [ebx]
  00026	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00029	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0002d	75 37		 jne	 SHORT $LN2@Copy

; 1924 : 			{	// nonempty tree, look for new smallest and largest
; 1925 : 			_Lmost() = this->_Min(_Root());

  0002f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00031	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00035	75 0a		 jne	 SHORT $LN124@Copy
$LL123@Copy:
  00037	8b c8		 mov	 ecx, eax
  00039	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003b	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0003f	74 f6		 je	 SHORT $LL123@Copy
$LN124@Copy:
  00041	89 0a		 mov	 DWORD PTR [edx], ecx

; 1926 : 			_Rmost() = this->_Max(_Root());

  00043	8b 13		 mov	 edx, DWORD PTR [ebx]
  00045	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00048	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0004b	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004f	75 0b		 jne	 SHORT $LN172@Copy
$LL171@Copy:
  00051	8b c8		 mov	 ecx, eax
  00053	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00056	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0005a	74 f5		 je	 SHORT $LL171@Copy
$LN172@Copy:
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00061	5b		 pop	 ebx

; 1932 : 			}
; 1933 : 		}

  00062	5d		 pop	 ebp
  00063	c2 08 00	 ret	 8
$LN2@Copy:

; 1927 : 			}
; 1928 : 		else
; 1929 : 			{	// empty tree, just tidy head pointers
; 1930 : 			_Lmost() = this->_Myhead();

  00066	89 12		 mov	 DWORD PTR [edx], edx

; 1931 : 			_Rmost() = this->_Myhead();

  00068	8b 03		 mov	 eax, DWORD PTR [ebx]
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1932 : 			}
; 1933 : 		}

  00070	5d		 pop	 ebp
  00071	c2 08 00	 ret	 8
??$_Copy@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy<std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@X@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@X@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,void>, COMDAT
; _this$ = ecx

; 714  : 		{	// construct from comparator, allocator

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 715  : 		_Construct();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 716  : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@X@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::construct<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::construct<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@KPAX@std@@AAPAU12@@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEXPAPAU?$_List_node@KPAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@KPAX@std@@AAPAU12@@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEXPAPAU?$_List_node@KPAX@1@AAPAU21@@Z PROC ; std::allocator<std::_List_node<unsigned long,void *> >::construct<std::_List_node<unsigned long,void *> *,std::_List_node<unsigned long,void *> * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_List_node@KPAX@std@@AAPAU12@@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEXPAPAU?$_List_node@KPAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_List_node<unsigned long,void *> >::construct<std::_List_node<unsigned long,void *> *,std::_List_node<unsigned long,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::construct<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *,std::_List_node<GostCrypt::SecurityTokenInfo,void *> * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::construct<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *,std::_List_node<GostCrypt::SecurityTokenInfo,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@K@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEXPAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@K@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEXPAK@Z PROC ; std::allocator<std::_List_node<unsigned long,void *> >::destroy<unsigned long>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@K@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEXPAK@Z ENDP ; std::allocator<std::_List_node<unsigned long,void *> >::destroy<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@USecurityTokenInfo@GostCrypt@@@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEXPAUSecurityTokenInfo@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@USecurityTokenInfo@GostCrypt@@@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEXPAUSecurityTokenInfo@GostCrypt@@@Z PROC ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::destroy<GostCrypt::SecurityTokenInfo>, COMDAT
; _this$ = ecx

; 743  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 744  : 		_Ptr->~_Uty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1SecurityTokenInfo@GostCrypt@@QAE@XZ

; 745  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??$destroy@USecurityTokenInfo@GostCrypt@@@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEXPAUSecurityTokenInfo@GostCrypt@@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::destroy<GostCrypt::SecurityTokenInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z PROC	; std::_Rechecked<unsigned char *,unsigned char *>, COMDAT

; 457  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 458  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 459  : 	return (_Dest);
; 460  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z ENDP	; std::_Rechecked<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move_al_unchecked@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<unsigned char *,unsigned char *,std::allocator<unsigned char> >, COMDAT

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 302  : 	typedef decltype(_STD move(*_First)) _Src_type; // TRANSITION MODULES VSO#222794
; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<unsigned char *,unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAE@std@@YAPAEPAE@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAE@std@@YAPAEPAE@Z PROC			; std::_Unchecked<unsigned char *>, COMDAT

; 427  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 429  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAE@std@@YAPAEPAE@Z ENDP			; std::_Unchecked<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@USecurityTokenKeyfile@GostCrypt@@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@USecurityTokenKeyfile@GostCrypt@@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::destroy<GostCrypt::SecurityTokenKeyfile>, COMDAT
; _this$ = ecx

; 1002 : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1003 : 		_Mytraits::destroy(*this, _Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1SecurityTokenKeyfile@GostCrypt@@QAE@XZ

; 1004 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??$destroy@USecurityTokenKeyfile@GostCrypt@@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::destroy<GostCrypt::SecurityTokenKeyfile>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@@std@@YAAAPAUSecurityTokenKeyfile@GostCrypt@@AAPAU12@PAU12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@@std@@YAAAPAUSecurityTokenKeyfile@GostCrypt@@AAPAU12@PAU12@@Z PROC ; std::_Rechecked<GostCrypt::SecurityTokenKeyfile *,GostCrypt::SecurityTokenKeyfile *>, COMDAT

; 457  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 458  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 459  : 	return (_Dest);
; 460  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@@std@@YAAAPAUSecurityTokenKeyfile@GostCrypt@@AAPAU12@PAU12@@Z ENDP ; std::_Rechecked<GostCrypt::SecurityTokenKeyfile *,GostCrypt::SecurityTokenKeyfile *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move_al_unchecked@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<GostCrypt::SecurityTokenKeyfile *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >, COMDAT

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 302  : 	typedef decltype(_STD move(*_First)) _Src_type; // TRANSITION MODULES VSO#222794
; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00017	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Uninitialized_move_al_unchecked1@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<GostCrypt::SecurityTokenKeyfile *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<GostCrypt::SecurityTokenKeyfile *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUSecurityTokenKeyfile@GostCrypt@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUSecurityTokenKeyfile@GostCrypt@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@@Z PROC ; std::_Unchecked<GostCrypt::SecurityTokenKeyfile *>, COMDAT

; 427  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 429  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUSecurityTokenKeyfile@GostCrypt@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@@Z ENDP ; std::_Unchecked<GostCrypt::SecurityTokenKeyfile *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAKPAK@std@@YAAAPAKAAPAKPAK@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAKPAK@std@@YAAAPAKAAPAKPAK@Z PROC	; std::_Rechecked<unsigned long *,unsigned long *>, COMDAT

; 457  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 458  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 459  : 	return (_Dest);
; 460  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAKPAK@std@@YAAAPAKAAPAKPAK@Z ENDP	; std::_Rechecked<unsigned long *,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move_al_unchecked@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<unsigned long *,unsigned long *,std::allocator<unsigned long> >, COMDAT

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 302  : 	typedef decltype(_STD move(*_First)) _Src_type; // TRANSITION MODULES VSO#222794
; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<unsigned long *,unsigned long *,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAK@std@@YAPAKPAK@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAK@std@@YAPAKPAK@Z PROC			; std::_Unchecked<unsigned long *>, COMDAT

; 427  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 429  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAK@std@@YAPAKPAK@Z ENDP			; std::_Unchecked<unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::destroy<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::destroy<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@KPAX@std@@@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEXPAPAU?$_List_node@KPAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@KPAX@std@@@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEXPAPAU?$_List_node@KPAX@1@@Z PROC ; std::allocator<std::_List_node<unsigned long,void *> >::destroy<std::_List_node<unsigned long,void *> *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@KPAX@std@@@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEXPAPAU?$_List_node@KPAX@1@@Z ENDP ; std::allocator<std::_List_node<unsigned long,void *> >::destroy<std::_List_node<unsigned long,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@@Z PROC ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::destroy<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::destroy<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABV?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> const &>, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0ABV?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z PROC	; std::allocator<wchar_t>::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ENDP	; std::allocator<wchar_t>::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@E@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@E@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<unsigned char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@E@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<unsigned char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z PROC	; std::allocator<unsigned char>::construct<unsigned char,unsigned char>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 01		 mov	 BYTE PTR [ecx], al
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z ENDP	; std::allocator<unsigned char>::construct<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z PROC ; std::allocator<GostCrypt::SecurityTokenKeyfile>::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile const &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN3@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z
$LN3@construct:

; 738  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z ENDP ; std::allocator<GostCrypt::SecurityTokenKeyfile>::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z PROC ; std::allocator<GostCrypt::SecurityTokenKeyfile>::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN3@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z
$LN3@construct:

; 738  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z ENDP ; std::allocator<GostCrypt::SecurityTokenKeyfile>::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,1><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 290  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,1><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@USecurityTokenInfo@GostCrypt@@U12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUSecurityTokenInfo@GostCrypt@@$$QAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USecurityTokenInfo@GostCrypt@@U12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUSecurityTokenInfo@GostCrypt@@$$QAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::construct<GostCrypt::SecurityTokenInfo,GostCrypt::SecurityTokenInfo>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00004	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 4b		 je	 SHORT $LN13@construct
  0000b	56		 push	 esi
  0000c	8b 75 0c	 mov	 esi, DWORD PTR _<_Args_0>$[ebp]
  0000f	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00012	33 d2		 xor	 edx, edx
  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	89 07		 mov	 DWORD PTR [edi], eax
  00018	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001b	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0001e	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00021	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  00028	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0002f	50		 push	 eax
  00030	66 89 11	 mov	 WORD PTR [ecx], dx
  00033	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  00038	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  0003b	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  0003e	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00045	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0004c	50		 push	 eax
  0004d	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00050	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00055	5e		 pop	 esi
$LN13@construct:
  00056	5f		 pop	 edi

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
??$construct@USecurityTokenInfo@GostCrypt@@U12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUSecurityTokenInfo@GostCrypt@@$$QAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::construct<GostCrypt::SecurityTokenInfo,GostCrypt::SecurityTokenInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@KABK@?$allocator@K@std@@QAEXPAKABK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@KABK@?$allocator@K@std@@QAEXPAKABK@Z PROC	; std::allocator<unsigned long>::construct<unsigned long,unsigned long const &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@KABK@?$allocator@K@std@@QAEXPAKABK@Z ENDP	; std::allocator<unsigned long>::construct<unsigned long,unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@KAAK@?$allocator@K@std@@QAEXPAKAAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@KAAK@?$allocator@K@std@@QAEXPAKAAK@Z PROC	; std::allocator<unsigned long>::construct<unsigned long,unsigned long &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@KAAK@?$allocator@K@std@@QAEXPAKAAK@Z ENDP	; std::allocator<unsigned long>::construct<unsigned long,unsigned long &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,std::_List_val<std::_List_simple_types<unsigned long> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,std::_List_val<std::_List_simple_types<unsigned long> >,1><std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 290  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,std::_List_val<std::_List_simple_types<unsigned long> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,std::_List_val<std::_List_simple_types<unsigned long> >,1><std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@KABK@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXPAKABK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@KABK@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXPAKABK@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::construct<unsigned long,unsigned long const &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@KABK@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXPAKABK@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::construct<unsigned long,unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > > &,bool,void,0>, COMDAT
; _this$ = ecx

; 172  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 173  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > > &,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >,bool,void,0>, COMDAT
; _this$ = ecx

; 172  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 173  : 		}

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
_<_Val_0>$ = 16						; size = 4
_<_Val_1>$ = 20						; size = 4
_<_Val_2>$ = 24						; size = 4
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 1083 : 		{	// insert value_type(_Val...) at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1084 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

  00004	ff 75 18	 push	 DWORD PTR _<_Val_2>$[ebp]
  00007	8b f9		 mov	 edi, ecx
  00009	ff 75 14	 push	 DWORD PTR _<_Val_1>$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR _<_Val_0>$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >

; 1085 : 		return (_Insert_hint(_Where,

  00014	50		 push	 eax
  00015	83 c0 10	 add	 eax, 16			; 00000010H
  00018	8b cf		 mov	 ecx, edi
  0001a	50		 push	 eax
  0001b	ff 75 0c	 push	 DWORD PTR __Where$[ebp]
  0001e	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_hint<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
  00026	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00029	5f		 pop	 edi

; 1086 : 			this->_Myval(_Newnode), _Newnode));
; 1087 : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 14 00	 ret	 20			; 00000014H
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ PROC	; std::forward_as_tuple<>, COMDAT

; 986  : 	{	// forward arguments in a tuple

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 988  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ENDP	; std::forward_as_tuple<>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ??0?$tuple@ABK@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$tuple@ABK@std@@QAE@$$QAV01@@Z PROC			; std::tuple<unsigned long const &>::tuple<unsigned long const &>, COMDAT
; _this$ = ecx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b c1		 mov	 eax, ecx
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$tuple@ABK@std@@QAE@$$QAV01@@Z ENDP			; std::tuple<unsigned long const &>::tuple<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$forward_as_tuple@ABK@std@@YA?AV?$tuple@ABK@0@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
??$forward_as_tuple@ABK@std@@YA?AV?$tuple@ABK@0@ABK@Z PROC ; std::forward_as_tuple<unsigned long const &>, COMDAT

; 986  : 	{	// forward arguments in a tuple

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 988  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$forward_as_tuple@ABK@std@@YA?AV?$tuple@ABK@0@ABK@Z ENDP ; std::forward_as_tuple<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::destroy<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::destroy<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@YA$$QAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@YA$$QAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@0@AAPAU10@@Z PROC ; std::move<std::_List_node<GostCrypt::SecurityTokenInfo,void *> * &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@YA$$QAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@0@AAPAU10@@Z ENDP ; std::move<std::_List_node<GostCrypt::SecurityTokenInfo,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAPAU?$_List_node@KPAX@std@@@std@@YA$$QAPAU?$_List_node@KPAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAU?$_List_node@KPAX@std@@@std@@YA$$QAPAU?$_List_node@KPAX@0@AAPAU10@@Z PROC ; std::move<std::_List_node<unsigned long,void *> * &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAPAU?$_List_node@KPAX@std@@@std@@YA$$QAPAU?$_List_node@KPAX@0@AAPAU10@@Z ENDP ; std::move<std::_List_node<unsigned long,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@$$QAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@$$QAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> ><std::allocator<GostCrypt::SecurityTokenKeyfile> >, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@$$QAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> ><std::allocator<GostCrypt::SecurityTokenKeyfile> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAE@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAE@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > ><std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAE@$$QAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > ><std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@K@std@@@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@$$QAV?$allocator@K@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@K@std@@@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@$$QAV?$allocator@K@1@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> ><std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@K@std@@@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@$$QAV?$allocator@K@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> ><std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@U?$_List_node@KPAX@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@$$QAV?$allocator@U?$_List_node@KPAX@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@U?$_List_node@KPAX@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@$$QAV?$allocator@U?$_List_node@KPAX@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > ><std::allocator<std::_List_node<unsigned long,void *> > >, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@U?$_List_node@KPAX@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@$$QAV?$allocator@U?$_List_node@KPAX@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > ><std::allocator<std::_List_node<unsigned long,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Ptr$ = 12						; size = 4
__Cvt$ = 16						; size = 44
??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z PROC ; std::numpunct<char>::_Getvals<char>, COMDAT
; _this$ = ecx

; 189  : 		{	// get values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 190  : 		_Dp = _MAKLOCCHR(_Elem2, _Ptr->decimal_point[0], _Cvt);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0000b	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 191  : 		_Kseparator = _MAKLOCCHR(_Elem2, _Ptr->thousands_sep[0], _Cvt);

  0000e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00011	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00014	88 41 0d	 mov	 BYTE PTR [ecx+13], al

; 192  : 		}

  00017	5d		 pop	 ebp
  00018	c2 34 00	 ret	 52			; 00000034H
??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z ENDP ; std::numpunct<char>::_Getvals<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z PROC		; std::_Maklocchr<char>, COMDAT

; 686  : 	{	// convert char to _Elem using _Cvtvec

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 687  : 	return ((_Elem)(unsigned char)_Byte);

  00003	8a 45 08	 mov	 al, BYTE PTR __Byte$[ebp]

; 688  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ENDP		; std::_Maklocchr<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 719  : 	{	// convert C string to _Elem sequence using _Cvtvec

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 720  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	57		 push	 edi
  00008	8b fe		 mov	 edi, esi
  0000a	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0000d	0f 1f 00	 npad	 3
$LL11@Maklocstr:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL11@Maklocstr
  00017	2b f9		 sub	 edi, ecx
  00019	47		 inc	 edi

; 721  : 
; 722  : 	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),

  0001a	6a 01		 push	 1
  0001c	57		 push	 edi
  0001d	e8 00 00 00 00	 call	 _calloc
  00022	8b d0		 mov	 edx, eax
  00024	83 c4 08	 add	 esp, 8

; 723  : 		_CRT_BLOCK, __FILE__, __LINE__);
; 724  : 
; 725  : 	if (!_Ptrdest)

  00027	85 d2		 test	 edx, edx
  00029	74 1c		 je	 SHORT $LN13@Maklocstr

; 727  : 
; 728  :  #pragma warning(push)
; 729  :  #pragma warning(disable: 6011)	/* quiet prefast noise */
; 730  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

  0002b	85 ff		 test	 edi, edi
  0002d	74 12		 je	 SHORT $LN3@Maklocstr
  0002f	8b ca		 mov	 ecx, edx
  00031	2b ce		 sub	 ecx, esi
$LL4@Maklocstr:

; 731  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

  00033	8a 06		 mov	 al, BYTE PTR [esi]
  00035	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00038	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  0003c	83 ef 01	 sub	 edi, 1
  0003f	75 f2		 jne	 SHORT $LL4@Maklocstr
$LN3@Maklocstr:
  00041	5f		 pop	 edi

; 732  :  #pragma warning(pop)
; 733  : 
; 734  : 	return (_Ptrdest);

  00042	8b c2		 mov	 eax, edx
  00044	5e		 pop	 esi

; 735  : 	}

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN13@Maklocstr:

; 726  : 		_Xbad_alloc();

  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN15@Maklocstr:
$LN12@Maklocstr:
  0004c	cc		 int	 3
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEPAUSecurityTokenKeyfile@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@1@0PAU23@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEPAUSecurityTokenKeyfile@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@1@0PAU23@@Z PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > > >, COMDAT
; _this$ = ecx

; 1651 : 		{	// copy initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1652 : 		return (_Uninitialized_copy(_First, _Last,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	51		 push	 ecx
  0000f	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00012	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00015	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00018	e8 00 00 00 00	 call	 ??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::SecurityTokenKeyfile const *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >
  0001d	83 c4 18	 add	 esp, 24			; 00000018H

; 1653 : 			_Ptr, this->_Getal()));
; 1654 : 		}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEPAUSecurityTokenKeyfile@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@1@0PAU23@@Z ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@@?$vector@KV?$allocator@K@std@@@std@@IAEPAKV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@1@0PAK@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@@?$vector@KV?$allocator@K@std@@@std@@IAEPAKV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@1@0PAK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > > >, COMDAT
; _this$ = ecx

; 1651 : 		{	// copy initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1652 : 		return (_Uninitialized_copy(_First, _Last,

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Ptr$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 1653 : 			_Ptr, this->_Getal()));
; 1654 : 		}

  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@@?$vector@KV?$allocator@K@std@@@std@@IAEPAKV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@1@0PAK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$insert@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
$T2 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
??$insert@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@00@Z PROC ; std::list<unsigned long,std::allocator<unsigned long> >::insert<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > > >, COMDAT
; _this$ = ecx

; 1382 : 		{	// insert [_First, _Last) at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1383 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1384 : 		if (_Where._Getcont() != &this->_Get_data())
; 1385 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1386 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1387 : 
; 1388 : 		iterator _Prev = _Make_iter(_Where);
; 1389 : 		if (_Prev == begin())

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 1390 : 			{	// insert sequence at beginning
; 1391 : 			_Insert_range(_Where._Unchecked(), _First, _Last,

  0000a	c6 45 fc 00	 mov	 BYTE PTR $T2[ebp], 0
  0000e	8b 17		 mov	 edx, DWORD PTR [edi]
  00010	3b 02		 cmp	 eax, DWORD PTR [edx]
  00012	75 1f		 jne	 SHORT $LN2@insert
  00014	ff 75 fc	 push	 DWORD PTR $T2[ebp]
  00017	ff 75 14	 push	 DWORD PTR __Last$[ebp]
  0001a	ff 75 10	 push	 DWORD PTR __First$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::list<unsigned long,std::allocator<unsigned long> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > > >

; 1392 : 				_Iter_cat_t<_Iter>());
; 1393 : 			return (begin());

  00023	8b 07		 mov	 eax, DWORD PTR [edi]
  00025	5f		 pop	 edi
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1399 : 				_Iter_cat_t<_Iter>());
; 1400 : 			return (++_Prev);

  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 1401 : 			}
; 1402 : 		}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 10 00	 ret	 16			; 00000010H
$LN2@insert:
  00033	56		 push	 esi

; 1394 : 			}
; 1395 : 		else
; 1396 : 			{	// insert sequence not at beginning
; 1397 : 			--_Prev;
; 1398 : 			_Insert_range(_Where._Unchecked(), _First, _Last,

  00034	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00037	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0003a	ff 75 14	 push	 DWORD PTR __Last$[ebp]
  0003d	ff 75 10	 push	 DWORD PTR __First$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::list<unsigned long,std::allocator<unsigned long> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > > >

; 1399 : 				_Iter_cat_t<_Iter>());
; 1400 : 			return (++_Prev);

  00046	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00049	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0004b	5e		 pop	 esi
  0004c	5f		 pop	 edi
  0004d	89 08		 mov	 DWORD PTR [eax], ecx

; 1401 : 			}
; 1402 : 		}

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 10 00	 ret	 16			; 00000010H
??$insert@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@00@Z ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::insert<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??F?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::operator--, COMDAT
; _this$ = ecx

; 389  : 		--(*(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00005	89 01		 mov	 DWORD PTR [ecx], eax

; 390  : 		return (*this);

  00007	8b c1		 mov	 eax, ecx

; 391  : 		}

  00009	c3		 ret	 0
??F?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::operator++, COMDAT
; _this$ = ecx

; 376  : 		++(*(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 377  : 		return (*this);

  00006	8b c1		 mov	 eax, ecx

; 378  : 		}

  00008	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAE@PAU?$_List_node@KPAX@1@PBV?$_List_val@U?$_List_simple_types@K@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAE@PAU?$_List_node@KPAX@1@PBV?$_List_val@U?$_List_simple_types@K@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::_List_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >, COMDAT
; _this$ = ecx

; 348  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 347  : 		: _Mybase(_Pnode, _Plist)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 349  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAE@PAU?$_List_node@KPAX@1@PBV?$_List_val@U?$_List_simple_types@K@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::_List_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 1
$T3 = 8							; size = 4
__Right$ = 8						; size = 4
__Al$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > > >, COMDAT
; _this$ = ecx

; 1016 : 		{	// construct tree by copying _Right, allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 1015 : 		: _Mybase(_Right.key_comp(), _STD forward<_Any_alloc>(_Al))

  00030	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00036	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0003d	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buyheadnode
  00042	89 06		 mov	 DWORD PTR [esi], eax

; 1017 : 		_TRY_BEGIN
; 1018 : 		_Copy(_Right, _Copy_tag());

  00044	ff 75 08	 push	 DWORD PTR $T2[ebp]
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0004e	8b ce		 mov	 ecx, esi
  00050	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00053	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00057	e8 00 00 00 00	 call	 ??$_Copy@U_Copy_tag@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy<std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Copy_tag>

; 1022 : 		_CATCH_END
; 1023 : 		}

  0005c	8b c6		 mov	 eax, esi
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00061	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00068	59		 pop	 ecx
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 08 00	 ret	 8
__catch$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z$0:

; 1019 : 		_CATCH_ALL
; 1020 : 		_Tidy();

  00072	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	8b 01		 mov	 eax, DWORD PTR [ecx]
  00077	50		 push	 eax
  00078	ff 30		 push	 DWORD PTR [eax]
  0007a	8d 45 08	 lea	 eax, DWORD PTR $T3[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::erase

; 1021 : 		_RERAISE;

  00083	6a 00		 push	 0
  00085	6a 00		 push	 0
  00087	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN125@Pkcs11Sess:
$LN124@Pkcs11Sess:
  0008c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z$2:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >
__ehhandler$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::construct<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::construct<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@KPAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAPAU?$_List_node@KPAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_List_node@KPAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAPAU?$_List_node@KPAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<unsigned long,void *> > >::construct<std::_List_node<unsigned long,void *> *,std::_List_node<unsigned long,void *> * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAU?$_List_node@KPAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAPAU?$_List_node@KPAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<unsigned long,void *> > >::construct<std::_List_node<unsigned long,void *> *,std::_List_node<unsigned long,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@KPAX@std@@@std@@YAAAPAU?$_List_node@KPAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_List_node@KPAX@std@@@std@@YAAAPAU?$_List_node@KPAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<unsigned long,void *> * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAU?$_List_node@KPAX@std@@@std@@YAAAPAU?$_List_node@KPAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<unsigned long,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::construct<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *,std::_List_node<GostCrypt::SecurityTokenInfo,void *> * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::construct<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *,std::_List_node<GostCrypt::SecurityTokenInfo,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@YAAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@YAAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<GostCrypt::SecurityTokenInfo,void *> * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@YAAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<GostCrypt::SecurityTokenInfo,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@K@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAK@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@K@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAK@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<unsigned long,void *> > >::destroy<unsigned long>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@K@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAK@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<unsigned long,void *> > >::destroy<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@USecurityTokenInfo@GostCrypt@@@?$allocator_traits@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@1@PAUSecurityTokenInfo@GostCrypt@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@USecurityTokenInfo@GostCrypt@@@?$allocator_traits@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@1@PAUSecurityTokenInfo@GostCrypt@@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::destroy<GostCrypt::SecurityTokenInfo>, COMDAT

; 863  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 864  : 		_Al.destroy(_Ptr);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 865  : 		}

  00006	5d		 pop	 ebp

; 864  : 		_Al.destroy(_Ptr);

  00007	e9 00 00 00 00	 jmp	 ??1SecurityTokenInfo@GostCrypt@@QAE@XZ
??$destroy@USecurityTokenInfo@GostCrypt@@@?$allocator_traits@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@1@PAUSecurityTokenInfo@GostCrypt@@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::destroy<GostCrypt::SecurityTokenInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z PROC ; std::_Uninitialized_move<unsigned char *,unsigned char *,std::allocator<unsigned char> >, COMDAT

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Uninitialized_move@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ENDP ; std::_Uninitialized_move<unsigned char *,unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@PAUSecurityTokenKeyfile@GostCrypt@@@std@@YAXPAUSecurityTokenKeyfile@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@PAUSecurityTokenKeyfile@GostCrypt@@@std@@YAXPAUSecurityTokenKeyfile@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<std::allocator<GostCrypt::SecurityTokenKeyfile>,GostCrypt::SecurityTokenKeyfile *>, COMDAT

; 1099 : 	{	// destroy [_First, _Last), no special optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1100 : 	for (; _First != _Last; ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 0f		 je	 SHORT $LN3@Destroy_ra
  0000f	90		 npad	 1
$LL4@Destroy_ra:

; 1101 : 		_Al.destroy(_Unfancy(_First));

  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1SecurityTokenKeyfile@GostCrypt@@QAE@XZ
  00017	83 c6 70	 add	 esi, 112		; 00000070H
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $LL4@Destroy_ra
$LN3@Destroy_ra:
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 1102 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Destroy_range1@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@PAUSecurityTokenKeyfile@GostCrypt@@@std@@YAXPAUSecurityTokenKeyfile@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<std::allocator<GostCrypt::SecurityTokenKeyfile>,GostCrypt::SecurityTokenKeyfile *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z PROC ; std::_Uninitialized_move<GostCrypt::SecurityTokenKeyfile *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >, COMDAT

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00017	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Uninitialized_move_al_unchecked1@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<GostCrypt::SecurityTokenKeyfile *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<GostCrypt::SecurityTokenKeyfile *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@K@std@@PAK@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@K@std@@PAK@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<unsigned long>,unsigned long *>, COMDAT

; 1108 : 		// nothing to do
; 1109 : 	}

  00000	c3		 ret	 0
??$_Destroy_range1@V?$allocator@K@std@@PAK@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<unsigned long>,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z PROC ; std::_Uninitialized_move<unsigned long *,unsigned long *,std::allocator<unsigned long> >, COMDAT

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Uninitialized_move@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z ENDP ; std::_Uninitialized_move<unsigned long *,unsigned long *,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 281  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z PROC ; std::forward<std::_Zero_then_variadic_args_t>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z ENDP ; std::forward<std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABU?$less@K@std@@@std@@YAABU?$less@K@0@ABU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABU?$less@K@std@@@std@@YAABU?$less@K@0@ABU10@@Z PROC ; std::forward<std::less<unsigned long> const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABU?$less@K@std@@@std@@YAABU?$less@K@0@ABU10@@Z ENDP ; std::forward<std::less<unsigned long> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@KPAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAPAU?$_List_node@KPAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_List_node@KPAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAPAU?$_List_node@KPAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<unsigned long,void *> > >::destroy<std::_List_node<unsigned long,void *> *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_List_node@KPAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAPAU?$_List_node@KPAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<unsigned long,void *> > >::destroy<std::_List_node<unsigned long,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::destroy<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::destroy<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z PROC ; std::forward<std::allocator<wchar_t> const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z ENDP ; std::forward<std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z PROC		; std::forward<wchar_t * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ENDP		; std::forward<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1039 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1052 : 	_Left = _STD move(_Right);
; 1053 : 	}

  00000	c3		 ret	 0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1039 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1052 : 	_Left = _STD move(_Right);
; 1053 : 	}

  00000	c3		 ret	 0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z PROC ; std::forward<std::allocator<wchar_t> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ENDP ; std::forward<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@E@std@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@E@std@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<unsigned char>,unsigned char *>, COMDAT

; 1108 : 		// nothing to do
; 1109 : 	}

  00000	c3		 ret	 0
??$_Destroy_range1@V?$allocator@E@std@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<unsigned char>,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAI@std@@YA$$QAIAAI@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAI@std@@YA$$QAIAAI@Z PROC			; std::move<unsigned int &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAI@std@@YA$$QAIAAI@Z ENDP			; std::move<unsigned int &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocma@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<unsigned char> > >, COMDAT

; 1052 : 	_Left = _STD move(_Right);
; 1053 : 	}

  00000	c3		 ret	 0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator==<char,char>, COMDAT

; 796  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 797  : 	}

  00002	c3		 ret	 0
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator==<char,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator==<std::allocator<char>,std::allocator<char> >, COMDAT

; 1017 : 	return (static_cast<const _Ty&>(_Left)

  00000	b0 01		 mov	 al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator==<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z PROC		; std::operator==<wchar_t,wchar_t>, COMDAT

; 796  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 797  : 	}

  00002	c3		 ret	 0
??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z ENDP		; std::operator==<wchar_t,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 1017 : 	return (static_cast<const _Ty&>(_Left)

  00000	b0 01		 mov	 al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAEIV?$allocator@E@std@@@std@@YAXPAEIAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Uninitialized_default_fill_n1@PAEIV?$allocator@E@std@@@std@@YAXPAEIAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_default_fill_n1<unsigned char *,unsigned int,std::allocator<unsigned char> >, COMDAT

; 470  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

  00003	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000b	e8 00 00 00 00	 call	 _memset
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 472  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Uninitialized_default_fill_n1@PAEIV?$allocator@E@std@@@std@@YAXPAEIAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<unsigned char *,unsigned int,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8EE@std@@YA_NABV?$allocator@E@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8EE@std@@YA_NABV?$allocator@E@0@0@Z PROC		; std::operator==<unsigned char,unsigned char>, COMDAT

; 796  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 797  : 	}

  00002	c3		 ret	 0
??$?8EE@std@@YA_NABV?$allocator@E@0@0@Z ENDP		; std::operator==<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@E@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@E@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z PROC ; std::operator==<std::allocator<unsigned char>,std::allocator<unsigned char> >, COMDAT

; 1017 : 	return (static_cast<const _Ty&>(_Left)

  00000	b0 01		 mov	 al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@E@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z ENDP ; std::operator==<std::allocator<unsigned char>,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@EE@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAE$$QAE@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@EE@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAE$$QAE@Z PROC ; std::allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 01		 mov	 BYTE PTR [ecx], al
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@EE@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAE$$QAE@Z ENDP ; std::allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >,1><std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 290  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >,1><std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@ABU34@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@ABU34@@Z PROC ; std::allocator_traits<std::allocator<GostCrypt::SecurityTokenKeyfile> >::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile const &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@ABU34@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN8@construct
  00034	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z
$LN8@construct:

; 858  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@ABU34@@Z$1:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@ABU34@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@ABU34@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@ABU34@@Z ENDP ; std::allocator_traits<std::allocator<GostCrypt::SecurityTokenKeyfile> >::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABUSecurityTokenKeyfile@GostCrypt@@@std@@YAABUSecurityTokenKeyfile@GostCrypt@@ABU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUSecurityTokenKeyfile@GostCrypt@@@std@@YAABUSecurityTokenKeyfile@GostCrypt@@ABU12@@Z PROC ; std::forward<GostCrypt::SecurityTokenKeyfile const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUSecurityTokenKeyfile@GostCrypt@@@std@@YAABUSecurityTokenKeyfile@GostCrypt@@ABU12@@Z ENDP ; std::forward<GostCrypt::SecurityTokenKeyfile const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@AAU34@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@AAU34@@Z PROC ; std::allocator_traits<std::allocator<GostCrypt::SecurityTokenKeyfile> >::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@AAU34@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN8@construct
  00034	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z
$LN8@construct:

; 858  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@AAU34@@Z$1:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@AAU34@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@AAU34@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAXAAV?$allocator@USecurityTokenKeyfile@GostCrypt@@@1@PAUSecurityTokenKeyfile@GostCrypt@@AAU34@@Z ENDP ; std::allocator_traits<std::allocator<GostCrypt::SecurityTokenKeyfile> >::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAUSecurityTokenKeyfile@GostCrypt@@@std@@YAAAUSecurityTokenKeyfile@GostCrypt@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUSecurityTokenKeyfile@GostCrypt@@@std@@YAAAUSecurityTokenKeyfile@GostCrypt@@AAU12@@Z PROC ; std::forward<GostCrypt::SecurityTokenKeyfile &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUSecurityTokenKeyfile@GostCrypt@@@std@@YAAAUSecurityTokenKeyfile@GostCrypt@@AAU12@@Z ENDP ; std::forward<GostCrypt::SecurityTokenKeyfile &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@1@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > ><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,void>, COMDAT
; _this$ = ecx

; 611  : 		{	// construct head node, allocator from _Al

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 612  : 		_Myhead() = _Buyheadnode();

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Buynode0
  00019	89 06		 mov	 DWORD PTR [esi], eax

; 613  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@1@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > ><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$_Buynode@USecurityTokenInfo@GostCrypt@@@?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@PAU21@0$$QAUSecurityTokenInfo@GostCrypt@@@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
_<_Val_0>$ = 16						; size = 4
??$_Buynode@USecurityTokenInfo@GostCrypt@@@?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@PAU21@0$$QAUSecurityTokenInfo@GostCrypt@@@Z PROC ; std::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Buynode<GostCrypt::SecurityTokenInfo>, COMDAT
; _this$ = ecx

; 831  : 		{	// allocate a node and set links and value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 832  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);

  00005	ff 75 0c	 push	 DWORD PTR __Prev$[ebp]
  00008	ff 75 08	 push	 DWORD PTR __Next$[ebp]
  0000b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Buynode0
  00010	8b f8		 mov	 edi, eax

; 833  : 
; 834  : 		_TRY_BEGIN
; 835  : 		this->_Getal().construct(

  00012	8d 5f 08	 lea	 ebx, DWORD PTR [edi+8]
  00015	85 db		 test	 ebx, ebx
  00017	74 4d		 je	 SHORT $LN36@Buynode
  00019	56		 push	 esi
  0001a	8b 75 10	 mov	 esi, DWORD PTR _<_Val_0>$[ebp]
  0001d	33 d2		 xor	 edx, edx
  0001f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00021	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00024	89 0b		 mov	 DWORD PTR [ebx], ecx
  00026	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00029	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  0002c	8d 4b 08	 lea	 ecx, DWORD PTR [ebx+8]
  0002f	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  00036	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0003d	50		 push	 eax
  0003e	66 89 11	 mov	 WORD PTR [ecx], dx
  00041	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  00046	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  00049	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  0004c	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00053	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0005a	50		 push	 eax
  0005b	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0005e	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 836  : 			_STD addressof(this->_Myval(_Pnode)),
; 837  : 				_STD forward<_Valty>(_Val)...);
; 838  : 		_CATCH_ALL
; 839  : 		this->_Getal().deallocate(_Pnode, 1);
; 840  : 		_RERAISE;
; 841  : 		_CATCH_END
; 842  : 
; 843  : 		return (_Pnode);

  00063	8b c7		 mov	 eax, edi
  00065	5e		 pop	 esi
$LN36@Buynode:
  00066	5f		 pop	 edi
  00067	5b		 pop	 ebx

; 844  : 		}

  00068	5d		 pop	 ebp
  00069	c2 0c 00	 ret	 12			; 0000000cH
??$_Buynode@USecurityTokenInfo@GostCrypt@@@?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@PAU21@0$$QAUSecurityTokenInfo@GostCrypt@@@Z ENDP ; std::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Buynode<GostCrypt::SecurityTokenInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAKIV?$allocator@K@std@@@std@@YAXPAKIAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Uninitialized_default_fill_n1@PAKIV?$allocator@K@std@@@std@@YAXPAKIAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_default_fill_n1<unsigned long *,unsigned int,std::allocator<unsigned long> >, COMDAT

; 470  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 472  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Uninitialized_default_fill_n1@PAKIV?$allocator@K@std@@@std@@YAXPAKIAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<unsigned long *,unsigned int,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@K@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@K@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@K@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@K@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1><std::_Wrap_alloc<std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 290  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@K@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@K@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1><std::_Wrap_alloc<std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@K@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@K@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<unsigned long> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@K@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@KABK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKABK@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@KABK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKABK@Z PROC ; std::allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@KABK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKABK@Z ENDP ; std::allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@KAAK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKAAK@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@KAAK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKAAK@Z PROC ; std::allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@KAAK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKAAK@Z ENDP ; std::allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAK@std@@YAAAKAAK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAK@std@@YAAAKAAK@Z PROC			; std::forward<unsigned long &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAK@std@@YAAAKAAK@Z ENDP			; std::forward<unsigned long &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@X@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@X@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@1@@Z PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > ><std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,void>, COMDAT
; _this$ = ecx

; 611  : 		{	// construct head node, allocator from _Al

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 612  : 		_Myhead() = _Buyheadnode();

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Buynode0
  00019	89 06		 mov	 DWORD PTR [esi], eax

; 613  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@X@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@1@@Z ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > ><std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$_Buynode@ABK@?$_List_buy@KV?$allocator@K@std@@@std@@QAEPAU?$_List_node@KPAX@1@PAU21@0ABK@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
_<_Val_0>$ = 16						; size = 4
??$_Buynode@ABK@?$_List_buy@KV?$allocator@K@std@@@std@@QAEPAU?$_List_node@KPAX@1@PAU21@0ABK@Z PROC ; std::_List_buy<unsigned long,std::allocator<unsigned long> >::_Buynode<unsigned long const &>, COMDAT
; _this$ = ecx

; 831  : 		{	// allocate a node and set links and value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 832  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);

  00003	ff 75 0c	 push	 DWORD PTR __Prev$[ebp]
  00006	ff 75 08	 push	 DWORD PTR __Next$[ebp]
  00009	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Buynode0

; 833  : 
; 834  : 		_TRY_BEGIN
; 835  : 		this->_Getal().construct(

  0000e	8d 50 08	 lea	 edx, DWORD PTR [eax+8]
  00011	85 d2		 test	 edx, edx
  00013	74 07		 je	 SHORT $LN36@Buynode
  00015	8b 4d 10	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
  00018	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001a	89 0a		 mov	 DWORD PTR [edx], ecx
$LN36@Buynode:

; 836  : 			_STD addressof(this->_Myval(_Pnode)),
; 837  : 				_STD forward<_Valty>(_Val)...);
; 838  : 		_CATCH_ALL
; 839  : 		this->_Getal().deallocate(_Pnode, 1);
; 840  : 		_RERAISE;
; 841  : 		_CATCH_END
; 842  : 
; 843  : 		return (_Pnode);
; 844  : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
??$_Buynode@ABK@?$_List_buy@KV?$allocator@K@std@@@std@@QAEPAU?$_List_node@KPAX@1@PAU21@0ABK@Z ENDP ; std::_List_buy<unsigned long,std::allocator<unsigned long> >::_Buynode<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABK@std@@YAABKABK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABK@std@@YAABKABK@Z PROC			; std::forward<unsigned long const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABK@std@@YAABKABK@Z ENDP			; std::forward<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
$T2 = 12						; size = 4
__Keyval$ = 12						; size = 4
$T3 = 15						; size = 1
??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z PROC ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>, COMDAT
; _this$ = ecx

; 208  : 		{	// fail if _Keyval present, else emplace

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx

; 209  : 		iterator _Where = _Mybase::lower_bound(_Keyval);

  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  0000a	56		 push	 esi
  0000b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0000d	8b f0		 mov	 esi, eax
  0000f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00012	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00016	75 1d		 jne	 SHORT $LN19@Try_emplac
  00018	57		 push	 edi
  00019	8b 39		 mov	 edi, DWORD PTR [ecx]
  0001b	0f 1f 44 00 00	 npad	 5
$LL18@Try_emplac:
  00020	39 7a 10	 cmp	 DWORD PTR [edx+16], edi
  00023	73 05		 jae	 SHORT $LN20@Try_emplac
  00025	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00028	eb 04		 jmp	 SHORT $LN21@Try_emplac
$LN20@Try_emplac:
  0002a	8b f2		 mov	 esi, edx
  0002c	8b 12		 mov	 edx, DWORD PTR [edx]
$LN21@Try_emplac:
  0002e	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00032	74 ec		 je	 SHORT $LL18@Try_emplac
  00034	5f		 pop	 edi
$LN19@Try_emplac:

; 210  : 		if (_Where == _Mybase::end()
; 211  : 			|| _DEBUG_LT_PRED(_Mybase::_Getcomp(),

  00035	3b f0		 cmp	 esi, eax
  00037	74 18		 je	 SHORT $LN4@Try_emplac
  00039	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003b	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
  0003e	72 11		 jb	 SHORT $LN4@Try_emplac

; 214  : 				_Mybase::emplace_hint(_Where,
; 215  : 					piecewise_construct,
; 216  : 					_STD forward_as_tuple(
; 217  : 						_STD forward<_Keyty>(_Keyval)),
; 218  : 					_STD forward_as_tuple(
; 219  : 						_STD forward<_Mappedty>(_Mapval)...)),
; 220  : 				true));
; 221  : 		else
; 222  : 			return (_Pairib(_Where, false));

  00040	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00043	89 30		 mov	 DWORD PTR [eax], esi
  00045	5e		 pop	 esi
  00046	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  0004a	5b		 pop	 ebx

; 223  : 		}

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 08 00	 ret	 8
$LN4@Try_emplac:

; 212  : 				_Keyval, _Mybase::_Key(_Where._Mynode())))
; 213  : 			return (_Pairib(

  00051	8d 45 0f	 lea	 eax, DWORD PTR $T3[ebp]
  00054	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
  00057	50		 push	 eax
  00058	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0005b	8b cb		 mov	 ecx, ebx
  0005d	50		 push	 eax
  0005e	68 00 00 00 00	 push	 OFFSET ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
  00063	e8 00 00 00 00	 call	 ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
  00068	50		 push	 eax
  00069	83 c0 10	 add	 eax, 16			; 00000010H
  0006c	8b cb		 mov	 ecx, ebx
  0006e	50		 push	 eax
  0006f	56		 push	 esi
  00070	8d 45 0c	 lea	 eax, DWORD PTR $T2[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ??$_Insert_hint@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@1@AAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Insert_hint<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> &,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
  00079	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0007c	8b 4d 0c	 mov	 ecx, DWORD PTR $T2[ebp]
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	89 08		 mov	 DWORD PTR [eax], ecx
  00083	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1

; 223  : 		}

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 08 00	 ret	 8
??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ENDP ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::destroy<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@1@PAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::destroy<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAD@std@@YA$$QADAAD@Z PROC			; std::move<char &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAD@std@@YA$$QADAAD@Z ENDP			; std::move<char &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z PROC ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2459 : 	{	// test for string equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2460 : 	return (_Left.compare(_Right) == 0);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  0000a	8d 50 10	 lea	 edx, DWORD PTR [eax+16]
  0000d	72 02		 jb	 SHORT $LN25@operator
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN25@operator:
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00014	56		 push	 esi
  00015	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00019	8d 71 10	 lea	 esi, DWORD PTR [ecx+16]
  0001c	72 02		 jb	 SHORT $LN48@operator
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN48@operator:
  00020	ff 32		 push	 DWORD PTR [edx]
  00022	50		 push	 eax
  00023	ff 36		 push	 DWORD PTR [esi]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ?_Traits_compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAHQB_WI0I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Traits_compare
  0002b	83 c4 10	 add	 esp, 16			; 00000010H
  0002e	85 c0		 test	 eax, eax
  00030	0f 94 c0	 sete	 al
  00033	5e		 pop	 esi

; 2461 : 	}

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ENDP ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ@YAXXZ
text$yd	SEGMENT
??__F_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ@YAXXZ PROC ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::`dynamic atexit destructor for '_Static'', COMDAT
  00000	c3		 ret	 0
??__F_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ@YAXXZ ENDP ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::`dynamic atexit destructor for '_Static''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??1?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ PROC ; std::_Immortalizer<std::_Iostream_error_category>::~_Immortalizer<std::_Iostream_error_category>, COMDAT
; _this$ = ecx

; 687  : 		}

  00000	c3		 ret	 0
??1?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ ENDP ; std::_Immortalizer<std::_Iostream_error_category>::~_Immortalizer<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ PROC ; std::_Immortalizer<std::_Iostream_error_category>::_Immortalizer<std::_Iostream_error_category>, COMDAT
; _this$ = ecx

; 683  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	85 c9		 test	 ecx, ecx
  00004	74 0d		 je	 SHORT $LN3@Immortaliz

; 681  : 		{	// construct _Ty inside _Storage
; 682  : 		::new (static_cast<void *>(&_Storage)) _Ty();

  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Iostream_error_category@std@@6B@
  0000c	c7 41 04 05 00
	00 00		 mov	 DWORD PTR [ecx+4], 5
$LN3@Immortaliz:

; 683  : 		}

  00013	c3		 ret	 0
??0?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ ENDP ; std::_Immortalizer<std::_Iostream_error_category>::_Immortalizer<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::construct<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::construct<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *,std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@KPAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@KPAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@KPAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@KPAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::construct<std::_List_node<unsigned long,void *> *,std::_List_node<unsigned long,void *> * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_List_node@KPAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@KPAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::construct<std::_List_node<unsigned long,void *> *,std::_List_node<unsigned long,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::construct<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *,std::_List_node<GostCrypt::SecurityTokenInfo,void *> * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::construct<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *,std::_List_node<GostCrypt::SecurityTokenInfo,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@K@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXPAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@K@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXPAK@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::destroy<unsigned long>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@K@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXPAK@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::destroy<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@K@std@@YAPAKAAK@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@K@std@@YAPAKAAK@Z PROC			; std::addressof<unsigned long>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@K@std@@YAPAKAAK@Z ENDP			; std::addressof<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@USecurityTokenInfo@GostCrypt@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUSecurityTokenInfo@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@USecurityTokenInfo@GostCrypt@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUSecurityTokenInfo@GostCrypt@@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::destroy<GostCrypt::SecurityTokenInfo>, COMDAT
; _this$ = ecx

; 1002 : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1003 : 		_Mytraits::destroy(*this, _Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1SecurityTokenInfo@GostCrypt@@QAE@XZ

; 1004 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??$destroy@USecurityTokenInfo@GostCrypt@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUSecurityTokenInfo@GostCrypt@@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::destroy<GostCrypt::SecurityTokenInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@USecurityTokenInfo@GostCrypt@@@std@@YAPAUSecurityTokenInfo@GostCrypt@@AAU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@USecurityTokenInfo@GostCrypt@@@std@@YAPAUSecurityTokenInfo@GostCrypt@@AAU12@@Z PROC ; std::addressof<GostCrypt::SecurityTokenInfo>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@USecurityTokenInfo@GostCrypt@@@std@@YAPAUSecurityTokenInfo@GostCrypt@@AAU12@@Z ENDP ; std::addressof<GostCrypt::SecurityTokenInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@_W@std@@YAPA_WAA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@_W@std@@YAPA_WAA_W@Z PROC			; std::addressof<wchar_t>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@_W@std@@YAPA_WAA_W@Z ENDP			; std::addressof<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z PROC	; std::pointer_traits<char *>::pointer_to, COMDAT

; 279  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ENDP	; std::pointer_traits<char *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PA_W@std@@SAPA_WAA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PA_W@std@@SAPA_WAA_W@Z PROC ; std::pointer_traits<wchar_t *>::pointer_to, COMDAT

; 279  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PA_W@std@@SAPA_WAA_W@Z ENDP ; std::pointer_traits<wchar_t *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove<unsigned char *>, COMDAT
; _this$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1659 : 		return (_Uninitialized_move(_First, _Last,

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Ptr$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 1660 : 			_Ptr, this->_Getal()));
; 1661 : 		}

  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@PAUSecurityTokenKeyfile@GostCrypt@@@std@@YAXPAUSecurityTokenKeyfile@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@PAUSecurityTokenKeyfile@GostCrypt@@@std@@YAXPAUSecurityTokenKeyfile@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<GostCrypt::SecurityTokenKeyfile>,GostCrypt::SecurityTokenKeyfile *>, COMDAT

; 1114 : 	{	// destroy [_First, _Last), choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 0f		 je	 SHORT $LN5@Destroy_ra
  0000f	90		 npad	 1
$LL6@Destroy_ra:
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1SecurityTokenKeyfile@GostCrypt@@QAE@XZ
  00017	83 c6 70	 add	 esi, 112		; 00000070H
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $LL6@Destroy_ra
$LN5@Destroy_ra:
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Destroy_range@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@PAUSecurityTokenKeyfile@GostCrypt@@@std@@YAXPAUSecurityTokenKeyfile@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<GostCrypt::SecurityTokenKeyfile>,GostCrypt::SecurityTokenKeyfile *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAUSecurityTokenKeyfile@GostCrypt@@@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEPAUSecurityTokenKeyfile@GostCrypt@@PAU23@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUSecurityTokenKeyfile@GostCrypt@@@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEPAUSecurityTokenKeyfile@GostCrypt@@PAU23@00@Z PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Umove<GostCrypt::SecurityTokenKeyfile *>, COMDAT
; _this$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1659 : 		return (_Uninitialized_move(_First, _Last,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	51		 push	 ecx
  0000f	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00012	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00015	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00018	e8 00 00 00 00	 call	 ??$_Uninitialized_move_al_unchecked1@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<GostCrypt::SecurityTokenKeyfile *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >
  0001d	83 c4 18	 add	 esp, 24			; 00000018H

; 1660 : 			_Ptr, this->_Getal()));
; 1661 : 		}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUSecurityTokenKeyfile@GostCrypt@@@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEPAUSecurityTokenKeyfile@GostCrypt@@PAU23@00@Z ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Umove<GostCrypt::SecurityTokenKeyfile *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@K@std@@PAK@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@K@std@@PAK@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned long>,unsigned long *>, COMDAT

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@K@std@@PAK@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned long>,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove<unsigned long *>, COMDAT
; _this$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1659 : 		return (_Uninitialized_move(_First, _Last,

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR __Ptr$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 1660 : 			_Ptr, this->_Getal()));
; 1661 : 		}

  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove<unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<wchar_t> >, COMDAT

; 553  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 554  :  #if _NO_LOCALES
; 555  : 	static _Wrap_facet<_Facet> _Wfac;
; 556  : 	return (*(_Facet *)&_Wfac);
; 557  : 
; 558  :  #else /* _NO_LOCALES */
; 559  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 560  : 		const locale::facet *_Psave =
; 561  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 562  : 
; 563  : 		size_t _Id = _Facet::id;

  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$ctype@_W@std@@2V0locale@2@A ; std::ctype<wchar_t>::id
  00038	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	89 5d f0	 mov	 DWORD PTR __Psave$5[ebp], ebx
  00048	85 ff		 test	 edi, edi
  0004a	75 2f		 jne	 SHORT $LN11@use_facet
  0004c	57		 push	 edi
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$ctype@_W@std@@2V0locale@2@A, edi ; std::ctype<wchar_t>::id
  0005b	75 10		 jne	 SHORT $LN12@use_facet
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00062	40		 inc	 eax
  00063	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$ctype@_W@std@@2V0locale@2@A, eax ; std::ctype<wchar_t>::id
$LN12@use_facet:
  0006d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00070	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00075	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$ctype@_W@std@@2V0locale@2@A ; std::ctype<wchar_t>::id
$LN11@use_facet:

; 564  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0007e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00081	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00084	73 0c		 jae	 SHORT $LN20@use_facet
  00086	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00089	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  0008c	85 f6		 test	 esi, esi
  0008e	75 77		 jne	 SHORT $LN7@use_facet
  00090	eb 02		 jmp	 SHORT $LN28@use_facet
$LN20@use_facet:
  00092	33 f6		 xor	 esi, esi
$LN28@use_facet:
  00094	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00098	74 10		 je	 SHORT $LN17@use_facet
  0009a	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009f	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000a2	73 0a		 jae	 SHORT $LN29@use_facet
  000a4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a7	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN17@use_facet:

; 565  : 
; 566  : 		if (_Pf != 0)

  000aa	85 f6		 test	 esi, esi
  000ac	75 59		 jne	 SHORT $LN7@use_facet
$LN29@use_facet:

; 567  : 			;	// got facet from locale
; 568  : 		else if (_Psave != 0)

  000ae	85 db		 test	 ebx, ebx
  000b0	74 04		 je	 SHORT $LN4@use_facet

; 569  : 			_Pf = _Psave;	// lazy facet already allocated

  000b2	8b f3		 mov	 esi, ebx
  000b4	eb 51		 jmp	 SHORT $LN7@use_facet
$LN4@use_facet:

; 570  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000b6	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  000b9	8d 45 f0	 lea	 eax, DWORD PTR __Psave$5[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<wchar_t>::_Getcat
  000c2	83 c4 08	 add	 esp, 8
  000c5	83 f8 ff	 cmp	 eax, -1
  000c8	75 24		 jne	 SHORT $LN6@use_facet

; 571  : 
; 572  :  #if _HAS_EXCEPTIONS
; 573  : 
; 574  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000ca	0f 57 c0	 xorps	 xmm0, xmm0
  000cd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7bad_cast@std@@6B@
  000d4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000d9	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  000dc	66 0f d6 45 e0	 movq	 QWORD PTR $T2[ebp+4], xmm0
  000e1	50		 push	 eax
  000e2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@use_facet:
$LN6@use_facet:

; 575  : 
; 576  :  #else /* _HAS_EXCEPTIONS */
; 577  : 			abort();	// lazy disallowed
; 578  :  #endif /* _HAS_EXCEPTIONS */
; 579  : 
; 580  : 		else
; 581  : 			{	// queue up lazy facet for destruction
; 582  : 			_Pf = _Psave;

  000ee	8b 75 f0	 mov	 esi, DWORD PTR __Psave$5[ebp]

; 583  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 584  : 
; 585  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 586  : 			_Pfmod->_Incref();

  000f1	8b ce		 mov	 ecx, esi
  000f3	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
  000f9	8b 16		 mov	 edx, DWORD PTR [esi]
  000fb	ff 52 04	 call	 DWORD PTR [edx+4]

; 587  : 
; 588  :  #if defined(_M_CEE)
; 589  : 			_Facet_Register_m(_Pfmod);
; 590  : 
; 591  :  #else /* defined(_M_CEE) */
; 592  : 			_Facet_Register(_Pfmod);

  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  00104	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 593  :  #endif /* defined(_M_CEE) */
; 594  : 			}
; 595  : 
; 596  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00107	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0010a	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0010f	8b c6		 mov	 eax, esi

; 597  : 	_END_LOCK()
; 598  :  #endif /* _NO_LOCALES */
; 599  : 	}	// end of use_facet body

  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN31@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBKUPkcs11Session@GostCrypt@@@?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBKUPkcs11Session@GostCrypt@@@?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z PROC ; std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0>::_Kfn<unsigned long const ,GostCrypt::Pkcs11Session>, COMDAT

; 61   : 		{	// extract key from element value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 62   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 63   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@$$CBKUPkcs11Session@GostCrypt@@@?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@SAABKABU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z ENDP ; std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0>::_Kfn<unsigned long const ,GostCrypt::Pkcs11Session>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABU?$less@K@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@K@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
??$?0ABU?$less@K@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@K@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<unsigned long>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>,1>::_Compressed_pair<std::less<unsigned long>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>,1><std::less<unsigned long> const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 290  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c2 0c 00	 ret	 12			; 0000000cH
??$?0ABU?$less@K@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@K@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<unsigned long>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>,1>::_Compressed_pair<std::less<unsigned long>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>,1><std::less<unsigned long> const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,std::_List_val<std::_List_simple_types<unsigned long> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,std::_List_val<std::_List_simple_types<unsigned long> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 281  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,std::_List_val<std::_List_simple_types<unsigned long> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,std::_List_val<std::_List_simple_types<unsigned long> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@KPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@KPAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@KPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@KPAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::destroy<std::_List_node<unsigned long,void *> *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@KPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@KPAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::destroy<std::_List_node<unsigned long,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@KPAX@std@@@std@@YAPAPAU?$_List_node@KPAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@KPAX@std@@@std@@YAPAPAU?$_List_node@KPAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<unsigned long,void *> *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAU?$_List_node@KPAX@std@@@std@@YAPAPAU?$_List_node@KPAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<unsigned long,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 281  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::destroy<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::destroy<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@YAPAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@YAPAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@YAPAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0ABV?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0ABV?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::allocator<wchar_t> const &,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0ABV?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::allocator<wchar_t> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@_W@std@@YAPA_WPA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@_W@std@@YAPA_WPA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z PROC		; std::addressof<wchar_t *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z ENDP		; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 281  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1044 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1045 : 	_Pocca(_Left, _Right, _Tag);
; 1046 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1063 : 	typename _Alty::propagate_on_container_move_assignment _Tag;
; 1064 : 	_Pocma(_Left, _Right, _Tag);
; 1065 : 	}

  00000	c3		 ret	 0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 281  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1044 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1045 : 	_Pocca(_Left, _Right, _Tag);
; 1046 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1063 : 	typename _Alty::propagate_on_container_move_assignment _Tag;
; 1064 : 	_Pocma(_Left, _Right, _Tag);
; 1065 : 	}

  00000	c3		 ret	 0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAV?$allocator@_W@1@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAV?$allocator@_W@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@E@std@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char>,unsigned char *>, COMDAT

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@E@std@@PAE@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char>,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$swap@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@X@std@@YAXAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@X@std@@YAXAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@0@0@Z PROC ; std::swap<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *,void>, COMDAT

; 48   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_Ty _Tmp = _STD move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 50   : 	_Left = _STD move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 51   : 	_Right = _STD move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 52   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@X@std@@YAXAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@0@0@Z ENDP ; std::swap<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$_Swap_adl@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@YAXAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@YAXAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@0@0@Z PROC ; std::_Swap_adl<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *>, COMDAT

; 58   : 	{	// exchange values stored at _Left and _Right, using ADL

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 59   : 	swap(_Left, _Right);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax
  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 60   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Swap_adl@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@YAXAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@0@0@Z ENDP ; std::_Swap_adl<std::_List_node<GostCrypt::SecurityTokenInfo,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$swap@IX@std@@YAXAAI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@IX@std@@YAXAAI0@Z PROC				; std::swap<unsigned int,void>, COMDAT

; 48   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_Ty _Tmp = _STD move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 50   : 	_Left = _STD move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 51   : 	_Right = _STD move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 52   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@IX@std@@YAXAAI0@Z ENDP				; std::swap<unsigned int,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$swap@PAU?$_List_node@KPAX@std@@X@std@@YAXAAPAU?$_List_node@KPAX@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAU?$_List_node@KPAX@std@@X@std@@YAXAAPAU?$_List_node@KPAX@0@0@Z PROC ; std::swap<std::_List_node<unsigned long,void *> *,void>, COMDAT

; 48   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_Ty _Tmp = _STD move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 50   : 	_Left = _STD move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 51   : 	_Right = _STD move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 52   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@PAU?$_List_node@KPAX@std@@X@std@@YAXAAPAU?$_List_node@KPAX@0@0@Z ENDP ; std::swap<std::_List_node<unsigned long,void *> *,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$_Swap_adl@PAU?$_List_node@KPAX@std@@@std@@YAXAAPAU?$_List_node@KPAX@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@PAU?$_List_node@KPAX@std@@@std@@YAXAAPAU?$_List_node@KPAX@0@0@Z PROC ; std::_Swap_adl<std::_List_node<unsigned long,void *> *>, COMDAT

; 58   : 	{	// exchange values stored at _Left and _Right, using ADL

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 59   : 	swap(_Left, _Right);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax
  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 60   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Swap_adl@PAU?$_List_node@KPAX@std@@@std@@YAXAAPAU?$_List_node@KPAX@0@0@Z ENDP ; std::_Swap_adl<std::_List_node<unsigned long,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 281  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$numpunct@_W@std@@MAEPAXI@Z PROC			; std::numpunct<wchar_t>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 76 08	 push	 DWORD PTR [esi+8]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@_W@std@@6B@
  0000f	e8 00 00 00 00	 call	 _free
  00014	ff 76 10	 push	 DWORD PTR [esi+16]
  00017	e8 00 00 00 00	 call	 _free
  0001c	ff 76 14	 push	 DWORD PTR [esi+20]
  0001f	e8 00 00 00 00	 call	 _free
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00031	74 0b		 je	 SHORT $LN15@scalar
  00033	6a 18		 push	 24			; 00000018H
  00035	56		 push	 esi
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	83 c4 08	 add	 esp, 8
$LN15@scalar:
  0003e	8b c6		 mov	 eax, esi
  00040	5e		 pop	 esi
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
??_G?$numpunct@_W@std@@MAEPAXI@Z ENDP			; std::numpunct<wchar_t>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Tidy@?$numpunct@_W@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$numpunct@_W@std@@AAEXXZ PROC			; std::numpunct<wchar_t>::_Tidy, COMDAT
; _this$ = ecx

; 257  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 258  : 		_CSTD free((void *)_Grouping);

  00003	ff 76 08	 push	 DWORD PTR [esi+8]
  00006	e8 00 00 00 00	 call	 _free

; 259  : 		_CSTD free((void *)_Falsename);

  0000b	ff 76 10	 push	 DWORD PTR [esi+16]
  0000e	e8 00 00 00 00	 call	 _free

; 260  : 		_CSTD free((void *)_Truename);

  00013	ff 76 14	 push	 DWORD PTR [esi+20]
  00016	e8 00 00 00 00	 call	 _free
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001e	5e		 pop	 esi

; 261  : 		}

  0001f	c3		 ret	 0
?_Tidy@?$numpunct@_W@std@@AAEXXZ ENDP			; std::numpunct<wchar_t>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::numpunct<wchar_t>::do_truename, COMDAT
; _this$ = ecx

; 251  : 		{	// return name for true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 252  : 		return (string_type(_Truename));

  00004	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00007	33 c0		 xor	 eax, eax
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00014	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0001b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00022	66 89 06	 mov	 WORD PTR [esi], ax
  00025	66 39 02	 cmp	 WORD PTR [edx], ax
  00028	75 14		 jne	 SHORT $LN117@do_truenam
  0002a	33 c9		 xor	 ecx, ecx
  0002c	51		 push	 ecx
  0002d	52		 push	 edx
  0002e	8b ce		 mov	 ecx, esi
  00030	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi

; 253  : 		}

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4

; 252  : 		return (string_type(_Truename));

$LN117@do_truenam:
  0003e	8b ca		 mov	 ecx, edx
  00040	57		 push	 edi
  00041	8d 79 02	 lea	 edi, DWORD PTR [ecx+2]
$LL119@do_truenam:
  00044	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00047	83 c1 02	 add	 ecx, 2
  0004a	66 85 c0	 test	 ax, ax
  0004d	75 f5		 jne	 SHORT $LL119@do_truenam
  0004f	2b cf		 sub	 ecx, edi
  00051	d1 f9		 sar	 ecx, 1
  00053	5f		 pop	 edi
  00054	51		 push	 ecx
  00055	52		 push	 edx
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0005d	8b c6		 mov	 eax, esi
  0005f	5e		 pop	 esi

; 253  : 		}

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
?do_truename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::numpunct<wchar_t>::do_truename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_falsename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::numpunct<wchar_t>::do_falsename, COMDAT
; _this$ = ecx

; 246  : 		{	// return name for false

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 247  : 		return (string_type(_Falsename));

  00004	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00007	33 c0		 xor	 eax, eax
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00014	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0001b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00022	66 89 06	 mov	 WORD PTR [esi], ax
  00025	66 39 02	 cmp	 WORD PTR [edx], ax
  00028	75 14		 jne	 SHORT $LN117@do_falsena
  0002a	33 c9		 xor	 ecx, ecx
  0002c	51		 push	 ecx
  0002d	52		 push	 edx
  0002e	8b ce		 mov	 ecx, esi
  00030	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi

; 248  : 		}

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4

; 247  : 		return (string_type(_Falsename));

$LN117@do_falsena:
  0003e	8b ca		 mov	 ecx, edx
  00040	57		 push	 edi
  00041	8d 79 02	 lea	 edi, DWORD PTR [ecx+2]
$LL119@do_falsena:
  00044	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00047	83 c1 02	 add	 ecx, 2
  0004a	66 85 c0	 test	 ax, ax
  0004d	75 f5		 jne	 SHORT $LL119@do_falsena
  0004f	2b cf		 sub	 ecx, edi
  00051	d1 f9		 sar	 ecx, 1
  00053	5f		 pop	 edi
  00054	51		 push	 ecx
  00055	52		 push	 edx
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0005d	8b c6		 mov	 eax, esi
  0005f	5e		 pop	 esi

; 248  : 		}

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
?do_falsename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::numpunct<wchar_t>::do_falsename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_grouping@?$numpunct@_W@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@_W@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<wchar_t>::do_grouping, COMDAT
; _this$ = ecx

; 241  : 		{	// return grouping string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 242  : 		return (string(_Grouping));

  00004	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00020	c6 06 00	 mov	 BYTE PTR [esi], 0
  00023	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00026	75 14		 jne	 SHORT $LN115@do_groupin
  00028	33 c9		 xor	 ecx, ecx
  0002a	51		 push	 ecx
  0002b	52		 push	 edx
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi

; 243  : 		}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4

; 242  : 		return (string(_Grouping));

$LN115@do_groupin:
  0003c	8b ca		 mov	 ecx, edx
  0003e	57		 push	 edi
  0003f	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL117@do_groupin:
  00042	8a 01		 mov	 al, BYTE PTR [ecx]
  00044	41		 inc	 ecx
  00045	84 c0		 test	 al, al
  00047	75 f9		 jne	 SHORT $LL117@do_groupin
  00049	2b cf		 sub	 ecx, edi
  0004b	5f		 pop	 edi
  0004c	51		 push	 ecx
  0004d	52		 push	 edx
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi

; 243  : 		}

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
?do_grouping@?$numpunct@_W@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<wchar_t>::do_grouping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_thousands_sep@?$numpunct@_W@std@@MBE_WXZ
_TEXT	SEGMENT
?do_thousands_sep@?$numpunct@_W@std@@MBE_WXZ PROC	; std::numpunct<wchar_t>::do_thousands_sep, COMDAT
; _this$ = ecx

; 237  : 		return (_Kseparator);

  00000	66 8b 41 0e	 mov	 ax, WORD PTR [ecx+14]

; 238  : 		}

  00004	c3		 ret	 0
?do_thousands_sep@?$numpunct@_W@std@@MBE_WXZ ENDP	; std::numpunct<wchar_t>::do_thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_decimal_point@?$numpunct@_W@std@@MBE_WXZ
_TEXT	SEGMENT
?do_decimal_point@?$numpunct@_W@std@@MBE_WXZ PROC	; std::numpunct<wchar_t>::do_decimal_point, COMDAT
; _this$ = ecx

; 232  : 		return (_Dp);

  00000	66 8b 41 0c	 mov	 ax, WORD PTR [ecx+12]

; 233  : 		}

  00004	c3		 ret	 0
?do_decimal_point@?$numpunct@_W@std@@MBE_WXZ ENDP	; std::numpunct<wchar_t>::do_decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z
_TEXT	SEGMENT
$T2 = -124						; size = 44
$T3 = -124						; size = 44
__Mbst1$4 = -80						; size = 8
__Mbst1$5 = -80						; size = 8
_this$GSCopy$ = -76					; size = 4
__Ptr$1$ = -72						; size = 4
__Wc$6 = -72						; size = 2
__Wc$7 = -72						; size = 2
__Byte$ = -68						; size = 1
__Byte$ = -68						; size = 1
__Cvt$ = -64						; size = 44
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Lobj$ = 8						; size = 4
__Isdef$ = 12						; size = 1
?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z PROC	; std::numpunct<wchar_t>::_Init, COMDAT
; _this$ = ecx

; 202  : 		{	// initialize from _Lobj

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 70	 sub	 esp, 112		; 00000070H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002e	8b d9		 mov	 ebx, ecx
  00030	89 5d b4	 mov	 DWORD PTR _this$GSCopy$[ebp], ebx

; 203  : 		const lconv *_Ptr = _Lobj._Getlconv();

  00033	e8 00 00 00 00	 call	 _localeconv
  00038	8b f0		 mov	 esi, eax

; 204  : 		_Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();	// conversion information

  0003a	8d 45 84	 lea	 eax, DWORD PTR $T3[ebp]
  0003d	50		 push	 eax
  0003e	89 75 b8	 mov	 DWORD PTR __Ptr$1$[ebp], esi
  00041	e8 00 00 00 00	 call	 __Getcvt
  00046	83 c4 04	 add	 esp, 4

; 205  : 
; 206  : 		_Grouping = 0;
; 207  : 		_Falsename = 0;
; 208  : 		_Truename = 0;
; 209  : 
; 210  : 		_TRY_BEGIN

  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 211  : 		_Grouping = _MAKLOCSTR(char, _Isdef ? "" : _Ptr->grouping,

  00050	80 7d 0c 00	 cmp	 BYTE PTR __Isdef$[ebp], 0
  00054	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00057	0f 11 45 c0	 movups	 XMMWORD PTR __Cvt$[ebp], xmm0
  0005b	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  0005f	0f 11 45 d0	 movups	 XMMWORD PTR __Cvt$[ebp+16], xmm0
  00063	f3 0f 7e 40 20	 movq	 xmm0, QWORD PTR [eax+32]
  00068	66 0f d6 45 e0	 movq	 QWORD PTR __Cvt$[ebp+32], xmm0
  0006d	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00070	89 45 e8	 mov	 DWORD PTR __Cvt$[ebp+40], eax
  00073	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  0007a	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
  00081	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0
  00088	74 07		 je	 SHORT $LN6@Init
  0008a	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0008f	eb 03		 jmp	 SHORT $LN7@Init
$LN6@Init:
  00091	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
$LN7@Init:
  00094	8d 45 84	 lea	 eax, DWORD PTR $T2[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 __Getcvt
  0009d	8b fe		 mov	 edi, esi
  0009f	83 c4 04	 add	 esp, 4
  000a2	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL39@Init:
  000a5	8a 07		 mov	 al, BYTE PTR [edi]
  000a7	47		 inc	 edi
  000a8	84 c0		 test	 al, al
  000aa	75 f9		 jne	 SHORT $LL39@Init
  000ac	2b f9		 sub	 edi, ecx
  000ae	47		 inc	 edi
  000af	6a 01		 push	 1
  000b1	57		 push	 edi
  000b2	e8 00 00 00 00	 call	 _calloc
  000b7	8b d0		 mov	 edx, eax
  000b9	83 c4 08	 add	 esp, 8
  000bc	85 d2		 test	 edx, edx
  000be	75 05		 jne	 SHORT $LN22@Init
  000c0	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN43@Init:
$LN22@Init:
  000c5	85 ff		 test	 edi, edi
  000c7	74 15		 je	 SHORT $LN20@Init
  000c9	8b ca		 mov	 ecx, edx
  000cb	2b ce		 sub	 ecx, esi
  000cd	0f 1f 00	 npad	 3
$LL21@Init:
  000d0	8a 06		 mov	 al, BYTE PTR [esi]
  000d2	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  000d5	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  000d9	83 ef 01	 sub	 edi, 1
  000dc	75 f2		 jne	 SHORT $LL21@Init
$LN20@Init:

; 212  : 			_Lobj._Getcvt());
; 213  : 		_Falsename = _MAKLOCSTR(_Elem, _Lobj._Getfalse(), _Cvt);

  000de	8d 45 c0	 lea	 eax, DWORD PTR __Cvt$[ebp]
  000e1	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  000e4	50		 push	 eax
  000e5	6a 00		 push	 0
  000e7	68 00 00 00 00	 push	 OFFSET ??_C@_05LAPONLG@false?$AA@
  000ec	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f4	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 214  : 		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Cvt);

  000f7	8d 45 c0	 lea	 eax, DWORD PTR __Cvt$[ebp]
  000fa	50		 push	 eax
  000fb	6a 00		 push	 0
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_04LOAJBDKD@true?$AA@
  00102	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010a	89 43 14	 mov	 DWORD PTR [ebx+20], eax

; 218  : 		_CATCH_END
; 219  : 
; 220  : 		if (_Isdef)

  0010d	80 7d 0c 00	 cmp	 BYTE PTR __Isdef$[ebp], 0
  00111	0f 84 85 00 00
	00		 je	 $LN3@Init

; 221  : 			{	// apply defaults for required facets
; 222  : //			_Grouping = _MAKLOCSTR(char, "", _Cvt);
; 223  : 			_Dp = _MAKLOCCHR(_Elem, '.', _Cvt);

  00117	8d 45 c0	 lea	 eax, DWORD PTR __Cvt$[ebp]
  0011a	c6 45 bc 2e	 mov	 BYTE PTR __Byte$[ebp], 46 ; 0000002eH
  0011e	50		 push	 eax
  0011f	8d 45 b0	 lea	 eax, DWORD PTR __Mbst1$5[ebp]
  00122	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __Wc$6[ebp], 0
  00129	50		 push	 eax
  0012a	6a 01		 push	 1
  0012c	8d 45 bc	 lea	 eax, DWORD PTR __Byte$[ebp]
  0012f	0f 57 c0	 xorps	 xmm0, xmm0
  00132	50		 push	 eax
  00133	8d 45 b8	 lea	 eax, DWORD PTR __Wc$6[ebp]
  00136	66 0f d6 45 b0	 movq	 QWORD PTR __Mbst1$5[ebp], xmm0
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 __Mbrtowc
  00141	0f b7 45 b8	 movzx	 eax, WORD PTR __Wc$6[ebp]
  00145	0f 57 c0	 xorps	 xmm0, xmm0
  00148	66 89 43 0c	 mov	 WORD PTR [ebx+12], ax

; 224  : 			_Kseparator = _MAKLOCCHR(_Elem, ',', _Cvt);

  0014c	8d 45 c0	 lea	 eax, DWORD PTR __Cvt$[ebp]
  0014f	50		 push	 eax
  00150	8d 45 b0	 lea	 eax, DWORD PTR __Mbst1$4[ebp]
  00153	c6 45 bc 2c	 mov	 BYTE PTR __Byte$[ebp], 44 ; 0000002cH
  00157	50		 push	 eax
  00158	6a 01		 push	 1
  0015a	8d 45 bc	 lea	 eax, DWORD PTR __Byte$[ebp]
  0015d	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __Wc$7[ebp], 0
  00164	50		 push	 eax
  00165	8d 45 b8	 lea	 eax, DWORD PTR __Wc$7[ebp]
  00168	66 0f d6 45 b0	 movq	 QWORD PTR __Mbst1$4[ebp], xmm0
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 __Mbrtowc
  00173	0f b7 45 b8	 movzx	 eax, WORD PTR __Wc$7[ebp]
  00177	83 c4 28	 add	 esp, 40			; 00000028H
$LN42@Init:

; 225  : 			}
; 226  : 		else
; 227  : 			_Getvals((_Elem)0, _Ptr, _Cvt);

  0017a	66 89 43 0e	 mov	 WORD PTR [ebx+14], ax

; 228  : 		}

  0017e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00181	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00188	59		 pop	 ecx
  00189	5f		 pop	 edi
  0018a	5e		 pop	 esi
  0018b	5b		 pop	 ebx
  0018c	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018f	33 cd		 xor	 ecx, ebp
  00191	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c2 08 00	 ret	 8
$LN3@Init:

; 225  : 			}
; 226  : 		else
; 227  : 			_Getvals((_Elem)0, _Ptr, _Cvt);

  0019c	8b 4d b8	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  0019f	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  001a2	0f b7 00	 movzx	 eax, WORD PTR [eax]
  001a5	66 89 43 0c	 mov	 WORD PTR [ebx+12], ax
  001a9	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  001ac	0f b7 00	 movzx	 eax, WORD PTR [eax]
  001af	eb c9		 jmp	 SHORT $LN42@Init
__catch$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z$0:

; 215  : 		_CATCH_ALL
; 216  : 		_Tidy();

  001b1	8b 4d b4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001b4	e8 00 00 00 00	 call	 ?_Tidy@?$numpunct@_W@std@@AAEXXZ ; std::numpunct<wchar_t>::_Tidy

; 217  : 		_RERAISE;

  001b9	6a 00		 push	 0
  001bb	6a 00		 push	 0
  001bd	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN44@Init:
$LN41@Init:
  001c2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a 80	 mov	 ecx, DWORD PTR [edx-128]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z ENDP	; std::numpunct<wchar_t>::_Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??$_Getvals@_W@?$numpunct@_W@std@@IAEX_WPBUlconv@@U_Cvtvec@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 2
__Ptr$ = 12						; size = 4
___formal$ = 16						; size = 44
??$_Getvals@_W@?$numpunct@_W@std@@IAEX_WPBUlconv@@U_Cvtvec@@@Z PROC ; std::numpunct<wchar_t>::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 196  : 		{	// get values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Dp = (_Elem)_Ptr->_W_decimal_point[0];

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00009	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0000c	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 198  : 		_Kseparator = (_Elem)_Ptr->_W_thousands_sep[0];

  00010	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00013	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00016	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 199  : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 34 00	 ret	 52			; 00000034H
??$_Getvals@_W@?$numpunct@_W@std@@IAEX_WPBUlconv@@U_Cvtvec@@@Z ENDP ; std::numpunct<wchar_t>::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??1?$numpunct@_W@std@@MAE@XZ
_TEXT	SEGMENT
??1?$numpunct@_W@std@@MAE@XZ PROC			; std::numpunct<wchar_t>::~numpunct<wchar_t>, COMDAT
; _this$ = ecx

; 175  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 176  : 		_Tidy();

  00003	ff 76 08	 push	 DWORD PTR [esi+8]
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@_W@std@@6B@
  0000c	e8 00 00 00 00	 call	 _free
  00011	ff 76 10	 push	 DWORD PTR [esi+16]
  00014	e8 00 00 00 00	 call	 _free
  00019	ff 76 14	 push	 DWORD PTR [esi+20]
  0001c	e8 00 00 00 00	 call	 _free
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 177  : 		}

  00024	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002a	5e		 pop	 esi
  0002b	c3		 ret	 0
??1?$numpunct@_W@std@@MAE@XZ ENDP			; std::numpunct<wchar_t>::~numpunct<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 52
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::numpunct<wchar_t>::_Getcat, COMDAT

; 166  : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	33 db		 xor	 ebx, ebx
  0002a	89 5d f0	 mov	 DWORD PTR $T3[ebp], ebx

; 167  : 		if (_Ppf != 0 && *_Ppf == 0)

  0002d	8b 7d 08	 mov	 edi, DWORD PTR __Ppf$[ebp]
  00030	85 ff		 test	 edi, edi
  00032	74 76		 je	 SHORT $LN29@Getcat
  00034	39 1f		 cmp	 DWORD PTR [edi], ebx
  00036	75 72		 jne	 SHORT $LN29@Getcat

; 168  : 			*_Ppf = new numpunct<_Elem>(

  00038	6a 18		 push	 24			; 00000018H
  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	8b f0		 mov	 esi, eax
  00041	83 c4 04	 add	 esp, 4
  00044	89 75 08	 mov	 DWORD PTR $T4[ebp], esi
  00047	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0004a	85 f6		 test	 esi, esi
  0004c	74 4b		 je	 SHORT $LN4@Getcat
  0004e	8b 45 0c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00051	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00054	85 c9		 test	 ecx, ecx
  00056	75 07		 jne	 SHORT $LN12@Getcat
  00058	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0005d	eb 0a		 jmp	 SHORT $LN17@Getcat
$LN12@Getcat:
  0005f	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00062	85 c0		 test	 eax, eax
  00064	75 03		 jne	 SHORT $LN17@Getcat
  00066	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
$LN17@Getcat:
  00069	50		 push	 eax
  0006a	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0006d	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00072	bb 01 00 00 00	 mov	 ebx, 1
  00077	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0007e	89 5d f0	 mov	 DWORD PTR $T3[ebp], ebx
  00081	53		 push	 ebx
  00082	50		 push	 eax
  00083	8b ce		 mov	 ecx, esi
  00085	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0008c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@_W@std@@6B@
  00092	e8 00 00 00 00	 call	 ?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<wchar_t>::_Init
  00097	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00099	33 f6		 xor	 esi, esi
$LN5@Getcat:
  0009b	89 37		 mov	 DWORD PTR [edi], esi
  0009d	f6 c3 01	 test	 bl, 1
  000a0	74 08		 je	 SHORT $LN29@Getcat
  000a2	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  000a5	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN29@Getcat:

; 169  : 				_Locinfo(_Ploc->c_str()), 0, true);
; 170  : 		return (_X_NUMERIC);

  000aa	b8 04 00 00 00	 mov	 eax, 4

; 171  : 		}

  000af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b9	59		 pop	 ecx
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 18		 push	 24			; 00000018H
  00002	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	0f 84 0c 00 00
	00		 je	 $LN8@Getcat
  0001b	83 65 f0 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  0001f	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  00022	e9 00 00 00 00	 jmp	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN8@Getcat:
  00027	c3		 ret	 0
__unwindfunclet$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2:
  00028	8b 4d 08	 mov	 ecx, DWORD PTR $T4[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__ehhandler$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  00030	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00034	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00037	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0003a	33 c8		 xor	 ecx, eax
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00046	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::numpunct<wchar_t>::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
__Isdef$ = 16						; size = 1
??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z PROC	; std::numpunct<wchar_t>::numpunct<wchar_t>, COMDAT
; _this$ = ecx

; 160  : 		{	// construct from specified locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 159  : 		: locale::facet(_Refs)

  00029	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  0002c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 161  : 		_Init(_Lobj, _Isdef);

  0002f	ff 75 10	 push	 DWORD PTR __Isdef$[ebp]
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00039	ff 75 08	 push	 DWORD PTR __Lobj$[ebp]
  0003c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@_W@std@@6B@
  00042	e8 00 00 00 00	 call	 ?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<wchar_t>::_Init

; 162  : 		}

  00047	8b c6		 mov	 eax, esi
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5e		 pop	 esi
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__ehhandler$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$numpunct@_W@std@@QAE@ABV_Locinfo@1@I_N@Z ENDP	; std::numpunct<wchar_t>::numpunct<wchar_t>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?truename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?truename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::numpunct<wchar_t>::truename, COMDAT
; _this$ = ecx

; 143  : 		{	// return name for true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 144  : 		return (do_truename());

  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00010	ff 52 1c	 call	 DWORD PTR [edx+28]
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 145  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?truename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::numpunct<wchar_t>::truename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?falsename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?falsename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::numpunct<wchar_t>::falsename, COMDAT
; _this$ = ecx

; 138  : 		{	// return name for false

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 139  : 		return (do_falsename());

  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00010	ff 52 18	 call	 DWORD PTR [edx+24]
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 140  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?falsename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::numpunct<wchar_t>::falsename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?grouping@?$numpunct@_W@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?grouping@?$numpunct@_W@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<wchar_t>::grouping, COMDAT
; _this$ = ecx

; 133  : 		{	// return grouping string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 134  : 		return (do_grouping());

  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00010	ff 52 14	 call	 DWORD PTR [edx+20]
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 135  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?grouping@?$numpunct@_W@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<wchar_t>::grouping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?thousands_sep@?$numpunct@_W@std@@QBE_WXZ
_TEXT	SEGMENT
?thousands_sep@?$numpunct@_W@std@@QBE_WXZ PROC		; std::numpunct<wchar_t>::thousands_sep, COMDAT
; _this$ = ecx

; 129  : 		return (do_thousands_sep());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 10	 jmp	 DWORD PTR [eax+16]
?thousands_sep@?$numpunct@_W@std@@QBE_WXZ ENDP		; std::numpunct<wchar_t>::thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?decimal_point@?$numpunct@_W@std@@QBE_WXZ
_TEXT	SEGMENT
?decimal_point@?$numpunct@_W@std@@QBE_WXZ PROC		; std::numpunct<wchar_t>::decimal_point, COMDAT
; _this$ = ecx

; 124  : 		return (do_decimal_point());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 0c	 jmp	 DWORD PTR [eax+12]
?decimal_point@?$numpunct@_W@std@@QBE_WXZ ENDP		; std::numpunct<wchar_t>::decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<wchar_t> >, COMDAT

; 553  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 554  :  #if _NO_LOCALES
; 555  : 	static _Wrap_facet<_Facet> _Wfac;
; 556  : 	return (*(_Facet *)&_Wfac);
; 557  : 
; 558  :  #else /* _NO_LOCALES */
; 559  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 560  : 		const locale::facet *_Psave =
; 561  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 562  : 
; 563  : 		size_t _Id = _Facet::id;

  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
  00038	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<wchar_t> >::_Psave
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	89 5d f0	 mov	 DWORD PTR __Psave$5[ebp], ebx
  00048	85 ff		 test	 edi, edi
  0004a	75 2f		 jne	 SHORT $LN11@use_facet
  0004c	57		 push	 edi
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$numpunct@_W@std@@2V0locale@2@A, edi ; std::numpunct<wchar_t>::id
  0005b	75 10		 jne	 SHORT $LN12@use_facet
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00062	40		 inc	 eax
  00063	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$numpunct@_W@std@@2V0locale@2@A, eax ; std::numpunct<wchar_t>::id
$LN12@use_facet:
  0006d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00070	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00075	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
$LN11@use_facet:

; 564  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0007e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00081	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00084	73 0c		 jae	 SHORT $LN20@use_facet
  00086	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00089	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  0008c	85 f6		 test	 esi, esi
  0008e	75 77		 jne	 SHORT $LN7@use_facet
  00090	eb 02		 jmp	 SHORT $LN28@use_facet
$LN20@use_facet:
  00092	33 f6		 xor	 esi, esi
$LN28@use_facet:
  00094	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00098	74 10		 je	 SHORT $LN17@use_facet
  0009a	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009f	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000a2	73 0a		 jae	 SHORT $LN29@use_facet
  000a4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a7	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN17@use_facet:

; 565  : 
; 566  : 		if (_Pf != 0)

  000aa	85 f6		 test	 esi, esi
  000ac	75 59		 jne	 SHORT $LN7@use_facet
$LN29@use_facet:

; 567  : 			;	// got facet from locale
; 568  : 		else if (_Psave != 0)

  000ae	85 db		 test	 ebx, ebx
  000b0	74 04		 je	 SHORT $LN4@use_facet

; 569  : 			_Pf = _Psave;	// lazy facet already allocated

  000b2	8b f3		 mov	 esi, ebx
  000b4	eb 51		 jmp	 SHORT $LN7@use_facet
$LN4@use_facet:

; 570  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000b6	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  000b9	8d 45 f0	 lea	 eax, DWORD PTR __Psave$5[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<wchar_t>::_Getcat
  000c2	83 c4 08	 add	 esp, 8
  000c5	83 f8 ff	 cmp	 eax, -1
  000c8	75 24		 jne	 SHORT $LN6@use_facet

; 571  : 
; 572  :  #if _HAS_EXCEPTIONS
; 573  : 
; 574  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000ca	0f 57 c0	 xorps	 xmm0, xmm0
  000cd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7bad_cast@std@@6B@
  000d4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000d9	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  000dc	66 0f d6 45 e0	 movq	 QWORD PTR $T2[ebp+4], xmm0
  000e1	50		 push	 eax
  000e2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@use_facet:
$LN6@use_facet:

; 575  : 
; 576  :  #else /* _HAS_EXCEPTIONS */
; 577  : 			abort();	// lazy disallowed
; 578  :  #endif /* _HAS_EXCEPTIONS */
; 579  : 
; 580  : 		else
; 581  : 			{	// queue up lazy facet for destruction
; 582  : 			_Pf = _Psave;

  000ee	8b 75 f0	 mov	 esi, DWORD PTR __Psave$5[ebp]

; 583  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 584  : 
; 585  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 586  : 			_Pfmod->_Incref();

  000f1	8b ce		 mov	 ecx, esi
  000f3	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::numpunct<wchar_t> >::_Psave
  000f9	8b 16		 mov	 edx, DWORD PTR [esi]
  000fb	ff 52 04	 call	 DWORD PTR [edx+4]

; 587  : 
; 588  :  #if defined(_M_CEE)
; 589  : 			_Facet_Register_m(_Pfmod);
; 590  : 
; 591  :  #else /* defined(_M_CEE) */
; 592  : 			_Facet_Register(_Pfmod);

  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  00104	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 593  :  #endif /* defined(_M_CEE) */
; 594  : 			}
; 595  : 
; 596  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00107	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0010a	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0010f	8b c6		 mov	 eax, esi

; 597  : 	_END_LOCK()
; 598  :  #endif /* _NO_LOCALES */
; 599  : 	}	// end of use_facet body

  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN31@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Lbound@K@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@ABK@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??$_Lbound@K@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Lbound<unsigned long>, COMDAT
; _this$ = ecx

; 2059 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2060 : 		_Nodeptr _Pnode = _Root();

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 2061 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2062 : 
; 2063 : 		while (!this->_Isnil(_Pnode))

  00008	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000c	75 19		 jne	 SHORT $LN72@Lbound

; 2064 : 			if (_Compare(this->_Key(_Pnode), _Keyval))

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL2@Lbound:
  00013	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  00016	73 05		 jae	 SHORT $LN4@Lbound

; 2065 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 2066 : 			else

  0001b	eb 04		 jmp	 SHORT $LN5@Lbound
$LN4@Lbound:

; 2067 : 				{	// _Pnode not less than _Keyval, remember it
; 2068 : 				_Wherenode = _Pnode;

  0001d	8b d0		 mov	 edx, eax

; 2069 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN5@Lbound:

; 2061 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2062 : 
; 2063 : 		while (!this->_Isnil(_Pnode))

  00021	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00025	74 ec		 je	 SHORT $LL2@Lbound
$LN72@Lbound:

; 2070 : 				}
; 2071 : 
; 2072 : 		return (_Wherenode);	// return best remembered candidate

  00027	8b c2		 mov	 eax, edx

; 2073 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??$_Lbound@K@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Lbound<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@SAPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@SAPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> *>::pointer_to, COMDAT

; 279  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@SAPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 281  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<unsigned char> > >, COMDAT

; 1063 : 	typename _Alty::propagate_on_container_move_assignment _Tag;
; 1064 : 	_Pocma(_Left, _Right, _Tag);
; 1065 : 	}

  00000	c3		 ret	 0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 281  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$numpunct@D@std@@MAEPAXI@Z PROC			; std::numpunct<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 76 08	 push	 DWORD PTR [esi+8]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
  0000f	e8 00 00 00 00	 call	 _free
  00014	ff 76 10	 push	 DWORD PTR [esi+16]
  00017	e8 00 00 00 00	 call	 _free
  0001c	ff 76 14	 push	 DWORD PTR [esi+20]
  0001f	e8 00 00 00 00	 call	 _free
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00031	74 0b		 je	 SHORT $LN15@scalar
  00033	6a 18		 push	 24			; 00000018H
  00035	56		 push	 esi
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	83 c4 08	 add	 esp, 8
$LN15@scalar:
  0003e	8b c6		 mov	 eax, esi
  00040	5e		 pop	 esi
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
??_G?$numpunct@D@std@@MAEPAXI@Z ENDP			; std::numpunct<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Tidy@?$numpunct@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$numpunct@D@std@@AAEXXZ PROC			; std::numpunct<char>::_Tidy, COMDAT
; _this$ = ecx

; 257  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 258  : 		_CSTD free((void *)_Grouping);

  00003	ff 76 08	 push	 DWORD PTR [esi+8]
  00006	e8 00 00 00 00	 call	 _free

; 259  : 		_CSTD free((void *)_Falsename);

  0000b	ff 76 10	 push	 DWORD PTR [esi+16]
  0000e	e8 00 00 00 00	 call	 _free

; 260  : 		_CSTD free((void *)_Truename);

  00013	ff 76 14	 push	 DWORD PTR [esi+20]
  00016	e8 00 00 00 00	 call	 _free
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001e	5e		 pop	 esi

; 261  : 		}

  0001f	c3		 ret	 0
?_Tidy@?$numpunct@D@std@@AAEXXZ ENDP			; std::numpunct<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_truename, COMDAT
; _this$ = ecx

; 251  : 		{	// return name for true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 252  : 		return (string_type(_Truename));

  00004	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00020	c6 06 00	 mov	 BYTE PTR [esi], 0
  00023	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00026	75 14		 jne	 SHORT $LN115@do_truenam
  00028	33 c9		 xor	 ecx, ecx
  0002a	51		 push	 ecx
  0002b	52		 push	 edx
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi

; 253  : 		}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4

; 252  : 		return (string_type(_Truename));

$LN115@do_truenam:
  0003c	8b ca		 mov	 ecx, edx
  0003e	57		 push	 edi
  0003f	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL117@do_truenam:
  00042	8a 01		 mov	 al, BYTE PTR [ecx]
  00044	41		 inc	 ecx
  00045	84 c0		 test	 al, al
  00047	75 f9		 jne	 SHORT $LL117@do_truenam
  00049	2b cf		 sub	 ecx, edi
  0004b	5f		 pop	 edi
  0004c	51		 push	 ecx
  0004d	52		 push	 edx
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi

; 253  : 		}

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_truename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_falsename, COMDAT
; _this$ = ecx

; 246  : 		{	// return name for false

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 247  : 		return (string_type(_Falsename));

  00004	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00020	c6 06 00	 mov	 BYTE PTR [esi], 0
  00023	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00026	75 14		 jne	 SHORT $LN115@do_falsena
  00028	33 c9		 xor	 ecx, ecx
  0002a	51		 push	 ecx
  0002b	52		 push	 edx
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi

; 248  : 		}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4

; 247  : 		return (string_type(_Falsename));

$LN115@do_falsena:
  0003c	8b ca		 mov	 ecx, edx
  0003e	57		 push	 edi
  0003f	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL117@do_falsena:
  00042	8a 01		 mov	 al, BYTE PTR [ecx]
  00044	41		 inc	 ecx
  00045	84 c0		 test	 al, al
  00047	75 f9		 jne	 SHORT $LL117@do_falsena
  00049	2b cf		 sub	 ecx, edi
  0004b	5f		 pop	 edi
  0004c	51		 push	 ecx
  0004d	52		 push	 edx
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi

; 248  : 		}

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_falsename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_grouping, COMDAT
; _this$ = ecx

; 241  : 		{	// return grouping string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 242  : 		return (string(_Grouping));

  00004	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00020	c6 06 00	 mov	 BYTE PTR [esi], 0
  00023	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00026	75 14		 jne	 SHORT $LN115@do_groupin
  00028	33 c9		 xor	 ecx, ecx
  0002a	51		 push	 ecx
  0002b	52		 push	 edx
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi

; 243  : 		}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4

; 242  : 		return (string(_Grouping));

$LN115@do_groupin:
  0003c	8b ca		 mov	 ecx, edx
  0003e	57		 push	 edi
  0003f	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL117@do_groupin:
  00042	8a 01		 mov	 al, BYTE PTR [ecx]
  00044	41		 inc	 ecx
  00045	84 c0		 test	 al, al
  00047	75 f9		 jne	 SHORT $LL117@do_groupin
  00049	2b cf		 sub	 ecx, edi
  0004b	5f		 pop	 edi
  0004c	51		 push	 ecx
  0004d	52		 push	 edx
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi

; 243  : 		}

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_grouping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_thousands_sep, COMDAT
; _this$ = ecx

; 237  : 		return (_Kseparator);

  00000	8a 41 0d	 mov	 al, BYTE PTR [ecx+13]

; 238  : 		}

  00003	c3		 ret	 0
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_decimal_point@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_decimal_point, COMDAT
; _this$ = ecx

; 232  : 		return (_Dp);

  00000	8a 41 0c	 mov	 al, BYTE PTR [ecx+12]

; 233  : 		}

  00003	c3		 ret	 0
?do_decimal_point@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
_TEXT	SEGMENT
$T2 = -68						; size = 44
$T3 = -68						; size = 44
__Ptr$1$ = -24						; size = 4
_this$GSCopy$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Lobj$ = 8						; size = 4
__Isdef$ = 12						; size = 1
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z PROC	; std::numpunct<char>::_Init, COMDAT
; _this$ = ecx

; 202  : 		{	// initialize from _Lobj

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d ec	 mov	 DWORD PTR _this$GSCopy$[ebp], ebx

; 203  : 		const lconv *_Ptr = _Lobj._Getlconv();

  00030	e8 00 00 00 00	 call	 _localeconv
  00035	8b f0		 mov	 esi, eax

; 204  : 		_Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();	// conversion information

  00037	8d 45 bc	 lea	 eax, DWORD PTR $T3[ebp]
  0003a	50		 push	 eax
  0003b	89 75 e8	 mov	 DWORD PTR __Ptr$1$[ebp], esi
  0003e	e8 00 00 00 00	 call	 __Getcvt
  00043	83 c4 04	 add	 esp, 4

; 205  : 
; 206  : 		_Grouping = 0;

  00046	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 207  : 		_Falsename = 0;
; 208  : 		_Truename = 0;
; 209  : 
; 210  : 		_TRY_BEGIN
; 211  : 		_Grouping = _MAKLOCSTR(char, _Isdef ? "" : _Ptr->grouping,

  0004d	80 7d 0c 00	 cmp	 BYTE PTR __Isdef$[ebp], 0
  00051	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
  00058	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0
  0005f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00066	74 07		 je	 SHORT $LN6@Init
  00068	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0006d	eb 03		 jmp	 SHORT $LN7@Init
$LN6@Init:
  0006f	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
$LN7@Init:
  00072	8d 45 bc	 lea	 eax, DWORD PTR $T2[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 __Getcvt
  0007b	8b fe		 mov	 edi, esi
  0007d	83 c4 04	 add	 esp, 4
  00080	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL63@Init:
  00083	8a 07		 mov	 al, BYTE PTR [edi]
  00085	47		 inc	 edi
  00086	84 c0		 test	 al, al
  00088	75 f9		 jne	 SHORT $LL63@Init
  0008a	2b f9		 sub	 edi, ecx
  0008c	47		 inc	 edi
  0008d	6a 01		 push	 1
  0008f	57		 push	 edi
  00090	e8 00 00 00 00	 call	 _calloc
  00095	8b d0		 mov	 edx, eax
  00097	83 c4 08	 add	 esp, 8
  0009a	85 d2		 test	 edx, edx
  0009c	75 05		 jne	 SHORT $LN22@Init
  0009e	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN66@Init:
$LN22@Init:
  000a3	85 ff		 test	 edi, edi
  000a5	74 17		 je	 SHORT $LN20@Init
  000a7	8b ca		 mov	 ecx, edx
  000a9	2b ce		 sub	 ecx, esi
  000ab	0f 1f 44 00 00	 npad	 5
$LL21@Init:
  000b0	8a 06		 mov	 al, BYTE PTR [esi]
  000b2	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  000b5	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  000b9	83 ef 01	 sub	 edi, 1
  000bc	75 f2		 jne	 SHORT $LL21@Init
$LN20@Init:

; 212  : 			_Lobj._Getcvt());
; 213  : 		_Falsename = _MAKLOCSTR(_Elem, _Lobj._Getfalse(), _Cvt);

  000be	bf 06 00 00 00	 mov	 edi, 6
  000c3	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  000c6	6a 01		 push	 1
  000c8	57		 push	 edi
  000c9	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_05LAPONLG@false?$AA@
  000ce	e8 00 00 00 00	 call	 _calloc
  000d3	8b d0		 mov	 edx, eax
  000d5	83 c4 08	 add	 esp, 8
  000d8	85 d2		 test	 edx, edx
  000da	75 05		 jne	 SHORT $LN31@Init
  000dc	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN67@Init:
$LN31@Init:
  000e1	8b ca		 mov	 ecx, edx
  000e3	81 e9 00 00 00
	00		 sub	 ecx, OFFSET ??_C@_05LAPONLG@false?$AA@
  000e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL30@Init:
  000f0	8a 06		 mov	 al, BYTE PTR [esi]
  000f2	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  000f5	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  000f9	83 ef 01	 sub	 edi, 1
  000fc	75 f2		 jne	 SHORT $LL30@Init

; 214  : 		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Cvt);

  000fe	bf 05 00 00 00	 mov	 edi, 5
  00103	89 53 10	 mov	 DWORD PTR [ebx+16], edx
  00106	6a 01		 push	 1
  00108	57		 push	 edi
  00109	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_04LOAJBDKD@true?$AA@
  0010e	e8 00 00 00 00	 call	 _calloc
  00113	8b d0		 mov	 edx, eax
  00115	83 c4 08	 add	 esp, 8
  00118	85 d2		 test	 edx, edx
  0011a	75 16		 jne	 SHORT $LN39@Init
  0011c	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN68@Init:
__catch$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0:

; 215  : 		_CATCH_ALL
; 216  : 		_Tidy();

  00121	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00124	e8 00 00 00 00	 call	 ?_Tidy@?$numpunct@D@std@@AAEXXZ ; std::numpunct<char>::_Tidy

; 217  : 		_RERAISE;

  00129	6a 00		 push	 0
  0012b	6a 00		 push	 0
  0012d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN69@Init:

; 214  : 		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Cvt);

$LN39@Init:
  00132	8b ca		 mov	 ecx, edx
  00134	81 e9 00 00 00
	00		 sub	 ecx, OFFSET ??_C@_04LOAJBDKD@true?$AA@
  0013a	66 0f 1f 44 00
	00		 npad	 6
$LL38@Init:
  00140	8a 06		 mov	 al, BYTE PTR [esi]
  00142	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00145	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  00149	83 ef 01	 sub	 edi, 1
  0014c	75 f2		 jne	 SHORT $LL38@Init

; 218  : 		_CATCH_END
; 219  : 
; 220  : 		if (_Isdef)

  0014e	80 7d 0c 00	 cmp	 BYTE PTR __Isdef$[ebp], 0
  00152	89 53 14	 mov	 DWORD PTR [ebx+20], edx
  00155	74 1a		 je	 SHORT $LN3@Init

; 221  : 			{	// apply defaults for required facets
; 222  : //			_Grouping = _MAKLOCSTR(char, "", _Cvt);
; 223  : 			_Dp = _MAKLOCCHR(_Elem, '.', _Cvt);

  00157	66 c7 43 0c 2e
	2c		 mov	 WORD PTR [ebx+12], 11310 ; 00002c2eH

; 228  : 		}

  0015d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00160	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00167	59		 pop	 ecx
  00168	5f		 pop	 edi
  00169	5e		 pop	 esi
  0016a	5b		 pop	 ebx
  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c2 08 00	 ret	 8
$LN3@Init:

; 224  : 			_Kseparator = _MAKLOCCHR(_Elem, ',', _Cvt);
; 225  : 			}
; 226  : 		else
; 227  : 			_Getvals((_Elem)0, _Ptr, _Cvt);

  00171	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  00174	8b 01		 mov	 eax, DWORD PTR [ecx]
  00176	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00179	88 43 0c	 mov	 BYTE PTR [ebx+12], al
  0017c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0017f	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00182	88 43 0d	 mov	 BYTE PTR [ebx+13], al

; 228  : 		}

  00185	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00188	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0018f	59		 pop	 ecx
  00190	5f		 pop	 edi
  00191	5e		 pop	 esi
  00192	5b		 pop	 ebx
  00193	8b e5		 mov	 esp, ebp
  00195	5d		 pop	 ebp
  00196	c2 08 00	 ret	 8
$LN65@Init:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ENDP	; std::numpunct<char>::_Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$numpunct@D@std@@MAE@XZ PROC			; std::numpunct<char>::~numpunct<char>, COMDAT
; _this$ = ecx

; 175  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 176  : 		_Tidy();

  00003	ff 76 08	 push	 DWORD PTR [esi+8]
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
  0000c	e8 00 00 00 00	 call	 _free
  00011	ff 76 10	 push	 DWORD PTR [esi+16]
  00014	e8 00 00 00 00	 call	 _free
  00019	ff 76 14	 push	 DWORD PTR [esi+20]
  0001c	e8 00 00 00 00	 call	 _free
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 177  : 		}

  00024	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002a	5e		 pop	 esi
  0002b	c3		 ret	 0
??1?$numpunct@D@std@@MAE@XZ ENDP			; std::numpunct<char>::~numpunct<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 52
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::numpunct<char>::_Getcat, COMDAT

; 166  : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	33 db		 xor	 ebx, ebx
  0002a	89 5d f0	 mov	 DWORD PTR $T3[ebp], ebx

; 167  : 		if (_Ppf != 0 && *_Ppf == 0)

  0002d	8b 7d 08	 mov	 edi, DWORD PTR __Ppf$[ebp]
  00030	85 ff		 test	 edi, edi
  00032	74 76		 je	 SHORT $LN29@Getcat
  00034	39 1f		 cmp	 DWORD PTR [edi], ebx
  00036	75 72		 jne	 SHORT $LN29@Getcat

; 168  : 			*_Ppf = new numpunct<_Elem>(

  00038	6a 18		 push	 24			; 00000018H
  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	8b f0		 mov	 esi, eax
  00041	83 c4 04	 add	 esp, 4
  00044	89 75 08	 mov	 DWORD PTR $T4[ebp], esi
  00047	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0004a	85 f6		 test	 esi, esi
  0004c	74 4b		 je	 SHORT $LN4@Getcat
  0004e	8b 45 0c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00051	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00054	85 c9		 test	 ecx, ecx
  00056	75 07		 jne	 SHORT $LN12@Getcat
  00058	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0005d	eb 0a		 jmp	 SHORT $LN17@Getcat
$LN12@Getcat:
  0005f	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00062	85 c0		 test	 eax, eax
  00064	75 03		 jne	 SHORT $LN17@Getcat
  00066	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
$LN17@Getcat:
  00069	50		 push	 eax
  0006a	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0006d	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00072	bb 01 00 00 00	 mov	 ebx, 1
  00077	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0007e	89 5d f0	 mov	 DWORD PTR $T3[ebp], ebx
  00081	53		 push	 ebx
  00082	50		 push	 eax
  00083	8b ce		 mov	 ecx, esi
  00085	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0008c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
  00092	e8 00 00 00 00	 call	 ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<char>::_Init
  00097	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00099	33 f6		 xor	 esi, esi
$LN5@Getcat:
  0009b	89 37		 mov	 DWORD PTR [edi], esi
  0009d	f6 c3 01	 test	 bl, 1
  000a0	74 08		 je	 SHORT $LN29@Getcat
  000a2	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  000a5	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN29@Getcat:

; 169  : 				_Locinfo(_Ploc->c_str()), 0, true);
; 170  : 		return (_X_NUMERIC);

  000aa	b8 04 00 00 00	 mov	 eax, 4

; 171  : 		}

  000af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b9	59		 pop	 ecx
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 18		 push	 24			; 00000018H
  00002	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	0f 84 0c 00 00
	00		 je	 $LN8@Getcat
  0001b	83 65 f0 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  0001f	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  00022	e9 00 00 00 00	 jmp	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN8@Getcat:
  00027	c3		 ret	 0
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2:
  00028	8b 4d 08	 mov	 ecx, DWORD PTR $T4[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  00030	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00034	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00037	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0003a	33 c8		 xor	 ecx, eax
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00046	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::numpunct<char>::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
__Isdef$ = 16						; size = 1
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z PROC	; std::numpunct<char>::numpunct<char>, COMDAT
; _this$ = ecx

; 160  : 		{	// construct from specified locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 159  : 		: locale::facet(_Refs)

  00029	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  0002c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 161  : 		_Init(_Lobj, _Isdef);

  0002f	ff 75 10	 push	 DWORD PTR __Isdef$[ebp]
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00039	ff 75 08	 push	 DWORD PTR __Lobj$[ebp]
  0003c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
  00042	e8 00 00 00 00	 call	 ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<char>::_Init

; 162  : 		}

  00047	8b c6		 mov	 eax, esi
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5e		 pop	 esi
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__ehhandler$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z ENDP	; std::numpunct<char>::numpunct<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::truename, COMDAT
; _this$ = ecx

; 143  : 		{	// return name for true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 144  : 		return (do_truename());

  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00010	ff 52 1c	 call	 DWORD PTR [edx+28]
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 145  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::truename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::falsename, COMDAT
; _this$ = ecx

; 138  : 		{	// return name for false

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 139  : 		return (do_falsename());

  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00010	ff 52 18	 call	 DWORD PTR [edx+24]
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 140  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::falsename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::grouping, COMDAT
; _this$ = ecx

; 133  : 		{	// return grouping string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 134  : 		return (do_grouping());

  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00010	ff 52 14	 call	 DWORD PTR [edx+20]
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 135  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::grouping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?thousands_sep@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?thousands_sep@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::thousands_sep, COMDAT
; _this$ = ecx

; 129  : 		return (do_thousands_sep());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00005	ff e0		 jmp	 eax
?thousands_sep@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?decimal_point@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?decimal_point@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::decimal_point, COMDAT
; _this$ = ecx

; 124  : 		return (do_decimal_point());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00005	ff e0		 jmp	 eax
?decimal_point@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<char> >, COMDAT

; 553  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 554  :  #if _NO_LOCALES
; 555  : 	static _Wrap_facet<_Facet> _Wfac;
; 556  : 	return (*(_Facet *)&_Wfac);
; 557  : 
; 558  :  #else /* _NO_LOCALES */
; 559  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 560  : 		const locale::facet *_Psave =
; 561  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 562  : 
; 563  : 		size_t _Id = _Facet::id;

  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
  00038	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	89 5d f0	 mov	 DWORD PTR __Psave$5[ebp], ebx
  00048	85 ff		 test	 edi, edi
  0004a	75 2f		 jne	 SHORT $LN11@use_facet
  0004c	57		 push	 edi
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, edi ; std::numpunct<char>::id
  0005b	75 10		 jne	 SHORT $LN12@use_facet
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00062	40		 inc	 eax
  00063	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, eax ; std::numpunct<char>::id
$LN12@use_facet:
  0006d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00070	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00075	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
$LN11@use_facet:

; 564  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0007e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00081	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00084	73 0c		 jae	 SHORT $LN20@use_facet
  00086	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00089	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  0008c	85 f6		 test	 esi, esi
  0008e	75 77		 jne	 SHORT $LN7@use_facet
  00090	eb 02		 jmp	 SHORT $LN28@use_facet
$LN20@use_facet:
  00092	33 f6		 xor	 esi, esi
$LN28@use_facet:
  00094	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00098	74 10		 je	 SHORT $LN17@use_facet
  0009a	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009f	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000a2	73 0a		 jae	 SHORT $LN29@use_facet
  000a4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a7	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN17@use_facet:

; 565  : 
; 566  : 		if (_Pf != 0)

  000aa	85 f6		 test	 esi, esi
  000ac	75 59		 jne	 SHORT $LN7@use_facet
$LN29@use_facet:

; 567  : 			;	// got facet from locale
; 568  : 		else if (_Psave != 0)

  000ae	85 db		 test	 ebx, ebx
  000b0	74 04		 je	 SHORT $LN4@use_facet

; 569  : 			_Pf = _Psave;	// lazy facet already allocated

  000b2	8b f3		 mov	 esi, ebx
  000b4	eb 51		 jmp	 SHORT $LN7@use_facet
$LN4@use_facet:

; 570  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000b6	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  000b9	8d 45 f0	 lea	 eax, DWORD PTR __Psave$5[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
  000c2	83 c4 08	 add	 esp, 8
  000c5	83 f8 ff	 cmp	 eax, -1
  000c8	75 24		 jne	 SHORT $LN6@use_facet

; 571  : 
; 572  :  #if _HAS_EXCEPTIONS
; 573  : 
; 574  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000ca	0f 57 c0	 xorps	 xmm0, xmm0
  000cd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7bad_cast@std@@6B@
  000d4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000d9	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  000dc	66 0f d6 45 e0	 movq	 QWORD PTR $T2[ebp+4], xmm0
  000e1	50		 push	 eax
  000e2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@use_facet:
$LN6@use_facet:

; 575  : 
; 576  :  #else /* _HAS_EXCEPTIONS */
; 577  : 			abort();	// lazy disallowed
; 578  :  #endif /* _HAS_EXCEPTIONS */
; 579  : 
; 580  : 		else
; 581  : 			{	// queue up lazy facet for destruction
; 582  : 			_Pf = _Psave;

  000ee	8b 75 f0	 mov	 esi, DWORD PTR __Psave$5[ebp]

; 583  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 584  : 
; 585  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 586  : 			_Pfmod->_Incref();

  000f1	8b ce		 mov	 ecx, esi
  000f3	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::numpunct<char> >::_Psave
  000f9	8b 16		 mov	 edx, DWORD PTR [esi]
  000fb	ff 52 04	 call	 DWORD PTR [edx+4]

; 587  : 
; 588  :  #if defined(_M_CEE)
; 589  : 			_Facet_Register_m(_Pfmod);
; 590  : 
; 591  :  #else /* defined(_M_CEE) */
; 592  : 			_Facet_Register(_Pfmod);

  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  00104	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 593  :  #endif /* defined(_M_CEE) */
; 594  : 			}
; 595  : 
; 596  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00107	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0010a	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0010f	8b c6		 mov	 eax, esi

; 597  : 	_END_LOCK()
; 598  :  #endif /* _NO_LOCALES */
; 599  : 	}	// end of use_facet body

  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN31@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed, COMDAT
; _this$ = ecx

; 662  : 		return (_Failed);

  00000	8a 01		 mov	 al, BYTE PTR [ecx]

; 663  : 		}

  00002	c3		 ret	 0
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 652  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 653  : 		}

  00002	c3		 ret	 0
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 647  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 648  : 		}

  00002	c3		 ret	 0
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 1
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=, COMDAT
; _this$ = ecx

; 637  : 		{	// store element and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 638  : 		if (_Strbuf == 0
; 639  : 			|| traits_type::eq_int_type(_Traits::eof(),

  00006	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00009	85 c9		 test	 ecx, ecx
  0000b	74 37		 je	 SHORT $LN3@operator
  0000d	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00010	83 38 00	 cmp	 DWORD PTR [eax], 0
  00013	74 20		 je	 SHORT $LN7@operator
  00015	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	85 c0		 test	 eax, eax
  0001c	7e 17		 jle	 SHORT $LN7@operator
  0001e	48		 dec	 eax
  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00024	8b 11		 mov	 edx, DWORD PTR [ecx]
  00026	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00029	89 01		 mov	 DWORD PTR [ecx], eax
  0002b	8a 45 08	 mov	 al, BYTE PTR __Right$[ebp]
  0002e	88 02		 mov	 BYTE PTR [edx], al
  00030	0f b6 c0	 movzx	 eax, al
  00033	eb 0a		 jmp	 SHORT $LN8@operator
$LN7@operator:
  00035	8b 11		 mov	 edx, DWORD PTR [ecx]
  00037	0f b6 45 08	 movzx	 eax, BYTE PTR __Right$[ebp]
  0003b	50		 push	 eax
  0003c	ff 52 0c	 call	 DWORD PTR [edx+12]
$LN8@operator:
  0003f	83 f8 ff	 cmp	 eax, -1
  00042	75 03		 jne	 SHORT $LN28@operator
$LN3@operator:

; 640  : 				_Strbuf->sputc(_Right)))
; 641  : 			_Failed = true;

  00044	c6 06 01	 mov	 BYTE PTR [esi], 1
$LN28@operator:

; 642  : 		return (*this);

  00047	8b c6		 mov	 eax, esi
  00049	5e		 pop	 esi

; 643  : 		}

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
__Sb$ = 8						; size = 4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 628  : 		{	// construct from stream buffer _Sb

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 		: _Failed(false), _Strbuf(_Sb)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Sb$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 629  : 		}

  00009	8b c1		 mov	 eax, ecx
  0000b	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN13@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN13@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ch$ = 24						; size = 1
__Count$ = 28						; size = 4
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep, COMDAT

; 1583 : 		{	// put _Count * _Ch to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1584 : 		for (; 0 < _Count; --_Count, (void)++_Dest)

  00004	8b 75 14	 mov	 esi, DWORD PTR __Dest$[ebp+4]
  00007	57		 push	 edi
  00008	8b 7d 1c	 mov	 edi, DWORD PTR __Count$[ebp]
  0000b	85 ff		 test	 edi, edi
  0000d	74 4a		 je	 SHORT $LN3@Rep
  0000f	53		 push	 ebx
  00010	8a 5d 18	 mov	 bl, BYTE PTR __Ch$[ebp]
$LL4@Rep:

; 1585 : 			*_Dest = _Ch;

  00013	85 f6		 test	 esi, esi
  00015	74 38		 je	 SHORT $LN12@Rep
  00017	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0001a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001d	74 1d		 je	 SHORT $LN16@Rep
  0001f	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	85 c0		 test	 eax, eax
  00026	7e 14		 jle	 SHORT $LN16@Rep
  00028	48		 dec	 eax
  00029	89 01		 mov	 DWORD PTR [ecx], eax
  0002b	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00030	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00033	89 01		 mov	 DWORD PTR [ecx], eax
  00035	88 1a		 mov	 BYTE PTR [edx], bl
  00037	0f b6 c3	 movzx	 eax, bl
  0003a	eb 0b		 jmp	 SHORT $LN17@Rep
$LN16@Rep:
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	8b ce		 mov	 ecx, esi
  00040	0f b6 c3	 movzx	 eax, bl
  00043	50		 push	 eax
  00044	ff 52 0c	 call	 DWORD PTR [edx+12]
$LN17@Rep:
  00047	8b 75 14	 mov	 esi, DWORD PTR __Dest$[ebp+4]
  0004a	83 f8 ff	 cmp	 eax, -1
  0004d	75 04		 jne	 SHORT $LN2@Rep
$LN12@Rep:
  0004f	c6 45 10 01	 mov	 BYTE PTR __Dest$[ebp], 1
$LN2@Rep:

; 1584 : 		for (; 0 < _Count; --_Count, (void)++_Dest)

  00053	83 ef 01	 sub	 edi, 1
  00056	75 bb		 jne	 SHORT $LL4@Rep
  00058	5b		 pop	 ebx
$LN3@Rep:

; 1586 : 		return (_Dest);

  00059	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005c	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005f	5f		 pop	 edi
  00060	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00063	89 08		 mov	 DWORD PTR [eax], ecx
  00065	5e		 pop	 esi

; 1587 : 		}

  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
__Ch$1$ = 31						; size = 1
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put, COMDAT

; 1575 : 		{	// put [_Ptr, _Ptr + _Count) to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1576 : 		for (; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)

  00004	8b 75 1c	 mov	 esi, DWORD PTR __Count$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 14	 mov	 edi, DWORD PTR __Dest$[ebp+4]
  0000b	85 f6		 test	 esi, esi
  0000d	74 53		 je	 SHORT $LN3@Put
  0000f	53		 push	 ebx
  00010	8b 5d 18	 mov	 ebx, DWORD PTR __Ptr$[ebp]
$LL4@Put:

; 1577 : 			*_Dest = *_Ptr;

  00013	85 ff		 test	 edi, edi
  00015	74 40		 je	 SHORT $LN12@Put
  00017	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0001a	8a 0b		 mov	 cl, BYTE PTR [ebx]
  0001c	88 4d 1f	 mov	 BYTE PTR __Ch$1$[ebp], cl
  0001f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00022	74 20		 je	 SHORT $LN16@Put
  00024	8b 57 30	 mov	 edx, DWORD PTR [edi+48]
  00027	8b 02		 mov	 eax, DWORD PTR [edx]
  00029	85 c0		 test	 eax, eax
  0002b	7e 17		 jle	 SHORT $LN16@Put
  0002d	48		 dec	 eax
  0002e	89 02		 mov	 DWORD PTR [edx], eax
  00030	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00038	89 01		 mov	 DWORD PTR [ecx], eax
  0003a	8a 45 1f	 mov	 al, BYTE PTR __Ch$1$[ebp]
  0003d	88 02		 mov	 BYTE PTR [edx], al
  0003f	0f b6 c0	 movzx	 eax, al
  00042	eb 0b		 jmp	 SHORT $LN17@Put
$LN16@Put:
  00044	8b 17		 mov	 edx, DWORD PTR [edi]
  00046	0f b6 c1	 movzx	 eax, cl
  00049	8b cf		 mov	 ecx, edi
  0004b	50		 push	 eax
  0004c	ff 52 0c	 call	 DWORD PTR [edx+12]
$LN17@Put:
  0004f	8b 7d 14	 mov	 edi, DWORD PTR __Dest$[ebp+4]
  00052	83 f8 ff	 cmp	 eax, -1
  00055	75 04		 jne	 SHORT $LN2@Put
$LN12@Put:
  00057	c6 45 10 01	 mov	 BYTE PTR __Dest$[ebp], 1
$LN2@Put:

; 1576 : 		for (; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)

  0005b	43		 inc	 ebx
  0005c	83 ee 01	 sub	 esi, 1
  0005f	75 b2		 jne	 SHORT $LL4@Put
  00061	5b		 pop	 ebx
$LN3@Put:

; 1578 : 		return (_Dest);

  00062	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00065	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00068	89 78 04	 mov	 DWORD PTR [eax+4], edi
  0006b	5f		 pop	 edi
  0006c	89 08		 mov	 DWORD PTR [eax], ecx
  0006e	5e		 pop	 esi

; 1579 : 		}

  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT
$T2 = -92						; size = 8
__Iosbase$GSCopy$1$ = -88				; size = 4
___$ReturnUdt$GSCopy$1$ = -84				; size = 4
$T3 = -80						; size = 8
$T4 = -80						; size = 8
$T5 = -80						; size = 8
$T6 = -80						; size = 8
$T7 = -80						; size = 8
$T8 = -80						; size = 8
$T9 = -80						; size = 8
__Dest$3$ = -72						; size = 4
__Ctype_fac$1$ = -72					; size = 4
__Count$GSCopy$2$ = -68					; size = 4
__Buf$GSCopy$1$ = -68					; size = 4
__Punct_fac$1$ = -68					; size = 4
__Kseparator$10 = -68					; size = 1
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput, COMDAT

; 1515 : 		{	// put formatted integer to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 7d 24	 mov	 edi, DWORD PTR __Count$[ebp]
  0002e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00031	8b 75 18	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00034	8b 4d 20	 mov	 ecx, DWORD PTR __Buf$[ebp]
  00037	89 45 ac	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003a	89 75 a8	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], esi
  0003d	89 4d bc	 mov	 DWORD PTR __Buf$GSCopy$1$[ebp], ecx

; 1516 : 		_DEBUG_POINTER(_Dest);
; 1517 : 		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')

  00040	85 ff		 test	 edi, edi
  00042	74 11		 je	 SHORT $LN14@Iput
  00044	8a 01		 mov	 al, BYTE PTR [ecx]
  00046	3c 2b		 cmp	 al, 43			; 0000002bH
  00048	74 04		 je	 SHORT $LN13@Iput
  0004a	3c 2d		 cmp	 al, 45			; 0000002dH
  0004c	75 07		 jne	 SHORT $LN14@Iput
$LN13@Iput:
  0004e	bb 01 00 00 00	 mov	 ebx, 1
  00053	eb 02		 jmp	 SHORT $LN15@Iput
$LN14@Iput:
  00055	33 db		 xor	 ebx, ebx
$LN15@Iput:

; 1518 : 			? 1 : 0;
; 1519 : 		if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
; 1520 : 			&& _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1521 : 			&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))

  00057	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0005a	25 00 0e 00 00	 and	 eax, 3584		; 00000e00H
  0005f	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00064	75 1d		 jne	 SHORT $LN4@Iput
  00066	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  00069	3b c7		 cmp	 eax, edi
  0006b	77 16		 ja	 SHORT $LN4@Iput
  0006d	80 3c 19 30	 cmp	 BYTE PTR [ecx+ebx], 48	; 00000030H
  00071	75 10		 jne	 SHORT $LN4@Iput
  00073	8a 4c 19 01	 mov	 cl, BYTE PTR [ecx+ebx+1]
  00077	80 f9 78	 cmp	 cl, 120			; 00000078H
  0007a	74 05		 je	 SHORT $LN5@Iput
  0007c	80 f9 58	 cmp	 cl, 88			; 00000058H
  0007f	75 02		 jne	 SHORT $LN4@Iput
$LN5@Iput:

; 1522 : 			_Prefix += 2;

  00081	8b d8		 mov	 ebx, eax
$LN4@Iput:

; 1523 : 
; 1524 : 		const ctype<_Elem>& _Ctype_fac =

  00083	8d 45 b0	 lea	 eax, DWORD PTR $T9[ebp]
  00086	8b ce		 mov	 ecx, esi
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  0008e	50		 push	 eax
  0008f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00096	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 b8	 mov	 DWORD PTR __Ctype_fac$1$[ebp], eax
  000a1	8b 4d b4	 mov	 ecx, DWORD PTR $T9[ebp+4]
  000a4	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000ab	85 c9		 test	 ecx, ecx
  000ad	74 11		 je	 SHORT $LN27@Iput
  000af	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b1	ff 50 08	 call	 DWORD PTR [eax+8]
  000b4	85 c0		 test	 eax, eax
  000b6	74 08		 je	 SHORT $LN27@Iput
  000b8	8b 10		 mov	 edx, DWORD PTR [eax]
  000ba	8b c8		 mov	 ecx, eax
  000bc	6a 01		 push	 1
  000be	ff 12		 call	 DWORD PTR [edx]
$LN27@Iput:

; 1525 : 			_USE(_Iosbase.getloc(), ctype<_Elem>);
; 1526 : 		_Mystr _Groupstring(_Count, _Elem(0));	// reserve space

  000c0	6a 00		 push	 0
  000c2	57		 push	 edi
  000c3	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  000c6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cd	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __Groupstring$[ebp+20], 15 ; 0000000fH
  000d4	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Groupstring$[ebp+16], 0
  000db	c6 45 d8 00	 mov	 BYTE PTR __Groupstring$[ebp], 0
  000df	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1527 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

  000e4	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  000e8	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  000eb	8b 4d bc	 mov	 ecx, DWORD PTR __Buf$GSCopy$1$[ebp]
  000ee	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  000f2	8b 55 b8	 mov	 edx, DWORD PTR __Ctype_fac$1$[ebp]
  000f5	50		 push	 eax
  000f6	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  000f9	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00100	50		 push	 eax
  00101	8b 12		 mov	 edx, DWORD PTR [edx]
  00103	51		 push	 ecx
  00104	8b 4d b8	 mov	 ecx, DWORD PTR __Ctype_fac$1$[ebp]
  00107	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1528 : 
; 1529 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

  0010a	8d 45 b0	 lea	 eax, DWORD PTR $T8[ebp]
  0010d	8b ce		 mov	 ecx, esi
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00115	50		 push	 eax
  00116	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0011a	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
  0011f	8b f0		 mov	 esi, eax
  00121	83 c4 04	 add	 esp, 4
  00124	89 75 bc	 mov	 DWORD PTR __Punct_fac$1$[ebp], esi
  00127	8b 4d b4	 mov	 ecx, DWORD PTR $T8[ebp+4]
  0012a	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0012e	85 c9		 test	 ecx, ecx
  00130	74 11		 je	 SHORT $LN157@Iput
  00132	8b 01		 mov	 eax, DWORD PTR [ecx]
  00134	ff 50 08	 call	 DWORD PTR [eax+8]
  00137	85 c0		 test	 eax, eax
  00139	74 08		 je	 SHORT $LN157@Iput
  0013b	8b 10		 mov	 edx, DWORD PTR [eax]
  0013d	8b c8		 mov	 ecx, eax
  0013f	6a 01		 push	 1
  00141	ff 12		 call	 DWORD PTR [edx]
$LN157@Iput:

; 1530 : 		const string _Grouping = _Punct_fac.grouping();

  00143	8d 45 c0	 lea	 eax, DWORD PTR __Grouping$[ebp]
  00146	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0014a	50		 push	 eax
  0014b	8b ce		 mov	 ecx, esi
  0014d	e8 00 00 00 00	 call	 ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping

; 1531 : 		const char *_Pg = &_Grouping[0];

  00152	83 7d d4 10	 cmp	 DWORD PTR __Grouping$[ebp+20], 16 ; 00000010H
  00156	8d 75 c0	 lea	 esi, DWORD PTR __Grouping$[ebp]
  00159	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0015d	0f 43 75 c0	 cmovae	 esi, DWORD PTR __Grouping$[ebp]

; 1532 : 		if (*_Pg != CHAR_MAX && '\0' < *_Pg)

  00161	8a 06		 mov	 al, BYTE PTR [esi]
  00163	3c 7f		 cmp	 al, 127			; 0000007fH
  00165	74 4b		 je	 SHORT $LN3@Iput
  00167	84 c0		 test	 al, al
  00169	7e 47		 jle	 SHORT $LN3@Iput

; 1533 : 			{	// grouping specified, add thousands separators
; 1534 : 			const _Elem _Kseparator = _Punct_fac.thousands_sep();

  0016b	8b 4d bc	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
  0016e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00170	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00173	ff d0		 call	 eax

; 1535 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1536 : 				&& (size_t)*_Pg < _Count - _Prefix)

  00175	80 3e 7f	 cmp	 BYTE PTR [esi], 127	; 0000007fH
  00178	88 45 bc	 mov	 BYTE PTR __Kseparator$10[ebp], al
  0017b	74 35		 je	 SHORT $LN3@Iput
  0017d	0f 1f 00	 npad	 3
$LL2@Iput:
  00180	8a 06		 mov	 al, BYTE PTR [esi]
  00182	84 c0		 test	 al, al
  00184	7e 2c		 jle	 SHORT $LN3@Iput
  00186	0f be c8	 movsx	 ecx, al
  00189	8b c7		 mov	 eax, edi
  0018b	2b c3		 sub	 eax, ebx
  0018d	3b c8		 cmp	 ecx, eax
  0018f	73 21		 jae	 SHORT $LN3@Iput

; 1537 : 				{	// insert thousands separator
; 1538 : 				_Count -= *_Pg;
; 1539 : 				_Groupstring.insert(_Count, 1, _Kseparator);

  00191	ff 75 bc	 push	 DWORD PTR __Kseparator$10[ebp]
  00194	2b f9		 sub	 edi, ecx
  00196	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00199	6a 01		 push	 1
  0019b	57		 push	 edi
  0019c	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  001a1	80 7e 01 00	 cmp	 BYTE PTR [esi+1], 0

; 1540 : 				if ('\0' < _Pg[1])

  001a5	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  001a8	0f 4e c6	 cmovle	 eax, esi
  001ab	8b f0		 mov	 esi, eax
  001ad	80 3e 7f	 cmp	 BYTE PTR [esi], 127	; 0000007fH
  001b0	75 ce		 jne	 SHORT $LL2@Iput
$LN3@Iput:

; 1541 : 					++_Pg;	// not last group, advance
; 1542 : 				}
; 1543 : 			}
; 1544 : 
; 1545 : 		_Count = _Groupstring.size();
; 1546 : 		size_t _Fillcount = _Iosbase.width() <= 0
; 1547 : 			|| (size_t)_Iosbase.width() <= _Count

  001b2	8b 75 a8	 mov	 esi, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  001b5	8b 45 e8	 mov	 eax, DWORD PTR __Groupstring$[ebp+16]
  001b8	89 45 bc	 mov	 DWORD PTR __Count$GSCopy$2$[ebp], eax
  001bb	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  001bf	7c 13		 jl	 SHORT $LN16@Iput
  001c1	7f 06		 jg	 SHORT $LN470@Iput
  001c3	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  001c7	76 0b		 jbe	 SHORT $LN16@Iput
$LN470@Iput:
  001c9	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  001cc	3b f8		 cmp	 edi, eax
  001ce	76 04		 jbe	 SHORT $LN16@Iput
  001d0	2b f8		 sub	 edi, eax
  001d2	eb 02		 jmp	 SHORT $LN17@Iput
$LN16@Iput:
  001d4	33 ff		 xor	 edi, edi
$LN17@Iput:

; 1548 : 				? 0 : (size_t)_Iosbase.width() - _Count;
; 1549 : 
; 1550 : 		ios_base::fmtflags _Adjustfield =
; 1551 : 			_Iosbase.flags() & ios_base::adjustfield;

  001d6	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001d9	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  001de	83 f8 40	 cmp	 eax, 64			; 00000040H

; 1552 : 		if (_Adjustfield != ios_base::left
; 1553 : 			&& _Adjustfield != ios_base::internal)

  001e1	0f 84 97 00 00
	00		 je	 $LN10@Iput
  001e7	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  001ec	74 48		 je	 SHORT $LN469@Iput

; 1554 : 			{	// put leading fill
; 1555 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

  001ee	57		 push	 edi
  001ef	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  001f2	8d 45 b0	 lea	 eax, DWORD PTR $T7[ebp]
  001f5	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  001f8	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  001fb	50		 push	 eax
  001fc	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001ff	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  00204	8b d0		 mov	 edx, eax

; 1556 : 			_Fillcount = 0;
; 1557 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00206	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00209	33 ff		 xor	 edi, edi
  0020b	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  0020f	53		 push	 ebx
  00210	0f 43 4d d8	 cmovae	 ecx, DWORD PTR __Groupstring$[ebp]
  00214	8b 02		 mov	 eax, DWORD PTR [edx]
  00216	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00219	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0021c	51		 push	 ecx
  0021d	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00220	8d 45 b0	 lea	 eax, DWORD PTR $T6[ebp]
  00223	ff 72 04	 push	 DWORD PTR [edx+4]
  00226	ff 32		 push	 DWORD PTR [edx]
  00228	50		 push	 eax
  00229	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0022c	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  00231	83 c4 30	 add	 esp, 48			; 00000030H
  00234	eb 6a		 jmp	 SHORT $LN474@Iput
$LN469@Iput:

; 1558 : 			}
; 1559 : 		else if (_Adjustfield == ios_base::internal)
; 1560 : 			{	// put internal fill
; 1561 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00236	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  0023a	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0023d	53		 push	 ebx
  0023e	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  00242	50		 push	 eax
  00243	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  00246	8d 45 b0	 lea	 eax, DWORD PTR $T5[ebp]
  00249	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0024c	50		 push	 eax
  0024d	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00250	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  00255	8b c8		 mov	 ecx, eax

; 1562 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

  00257	57		 push	 edi
  00258	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  0025b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0025d	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00260	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00263	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00266	8d 45 b0	 lea	 eax, DWORD PTR $T4[ebp]
  00269	ff 71 04	 push	 DWORD PTR [ecx+4]
  0026c	ff 31		 push	 DWORD PTR [ecx]
  0026e	50		 push	 eax
  0026f	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00272	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  00277	83 c4 30	 add	 esp, 48			; 00000030H

; 1563 : 			_Fillcount = 0;

  0027a	33 ff		 xor	 edi, edi

; 1564 : 			}
; 1565 : 		else

  0027c	eb 22		 jmp	 SHORT $LN474@Iput
$LN10@Iput:

; 1566 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  0027e	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  00282	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  00285	53		 push	 ebx
  00286	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  0028a	50		 push	 eax
  0028b	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  0028e	8d 45 b0	 lea	 eax, DWORD PTR $T3[ebp]
  00291	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00294	50		 push	 eax
  00295	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00298	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  0029d	83 c4 18	 add	 esp, 24			; 00000018H
$LN474@Iput:
  002a0	8b 10		 mov	 edx, DWORD PTR [eax]

; 1567 : 
; 1568 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  002a2	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  002a6	8b 4d bc	 mov	 ecx, DWORD PTR __Count$GSCopy$2$[ebp]
  002a9	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  002ac	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002af	89 45 b8	 mov	 DWORD PTR __Dest$3$[ebp], eax
  002b2	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  002b5	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  002b8	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  002bc	2b cb		 sub	 ecx, ebx
  002be	51		 push	 ecx
  002bf	03 c3		 add	 eax, ebx
  002c1	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  002c4	50		 push	 eax
  002c5	ff 75 b8	 push	 DWORD PTR __Dest$3$[ebp]
  002c8	8d 45 a4	 lea	 eax, DWORD PTR $T2[ebp]
  002cb	52		 push	 edx
  002cc	50		 push	 eax
  002cd	53		 push	 ebx
  002ce	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1569 : 		_Iosbase.width(0);
; 1570 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

  002d3	57		 push	 edi
  002d4	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  002d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d9	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  002dc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002df	50		 push	 eax
  002e0	51		 push	 ecx
  002e1	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  002e8	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  002ef	8b 75 ac	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  002f2	56		 push	 esi
  002f3	53		 push	 ebx
  002f4	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  002f7	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  002fc	8b 45 d4	 mov	 eax, DWORD PTR __Grouping$[ebp+20]
  002ff	83 c4 30	 add	 esp, 48			; 00000030H
  00302	83 f8 10	 cmp	 eax, 16			; 00000010H
  00305	72 0d		 jb	 SHORT $LN270@Iput
  00307	40		 inc	 eax
  00308	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  0030b	50		 push	 eax
  0030c	ff 75 c0	 push	 DWORD PTR __Grouping$[ebp]
  0030f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN270@Iput:
  00314	8b 4d ec	 mov	 ecx, DWORD PTR __Groupstring$[ebp+20]
  00317	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+20], 15 ; 0000000fH
  0031e	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+16], 0
  00325	c6 45 c0 00	 mov	 BYTE PTR __Grouping$[ebp], 0
  00329	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0032c	72 0d		 jb	 SHORT $LN471@Iput
  0032e	41		 inc	 ecx
  0032f	51		 push	 ecx
  00330	ff 75 d8	 push	 DWORD PTR __Groupstring$[ebp]
  00333	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00336	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN471@Iput:
  0033b	8b c6		 mov	 eax, esi

; 1571 : 		}

  0033d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00340	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00347	59		 pop	 ecx
  00348	5f		 pop	 edi
  00349	5e		 pop	 esi
  0034a	5b		 pop	 ebx
  0034b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0034e	33 cd		 xor	 ecx, ebp
  00350	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00355	8b e5		 mov	 esp, ebp
  00357	5d		 pop	 ebp
  00358	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T9[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$4:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1:
  0000e	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$2:
  00016	8d 4d b0	 lea	 ecx, DWORD PTR $T8[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$33:
  0001e	e8 00 00 00 00	 call	 ___std_terminate
  00023	c3		 ret	 0
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$3:
  00024	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00040	33 c8		 xor	 ecx, eax
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
  0004c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 4
__Flags$ = 20						; size = 4
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt, COMDAT

; 1487 : 		{	// generate sprintf format for integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1488 : 		char *_Ptr = _Fmt;
; 1489 : 		*_Ptr++ = '%';
; 1490 : 
; 1491 : 		if (_Flags & ios_base::showpos)

  00003	8b 4d 14	 mov	 ecx, DWORD PTR __Flags$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Fmt$[ebp]
  0000a	57		 push	 edi
  0000b	c6 06 25	 mov	 BYTE PTR [esi], 37	; 00000025H
  0000e	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00011	f6 c1 20	 test	 cl, 32			; 00000020H
  00014	74 04		 je	 SHORT $LN2@Ifmt

; 1492 : 			*_Ptr++ = '+';

  00016	c6 00 2b	 mov	 BYTE PTR [eax], 43	; 0000002bH
  00019	40		 inc	 eax
$LN2@Ifmt:

; 1493 : 		if (_Flags & ios_base::showbase)

  0001a	f6 c1 08	 test	 cl, 8
  0001d	74 04		 je	 SHORT $LN3@Ifmt

; 1494 : 			*_Ptr++ = '#';

  0001f	c6 00 23	 mov	 BYTE PTR [eax], 35	; 00000023H
  00022	40		 inc	 eax
$LN3@Ifmt:

; 1495 : 		if (_Spec[0] != 'L')

  00023	8b 7d 10	 mov	 edi, DWORD PTR __Spec$[ebp]
  00026	8a 17		 mov	 dl, BYTE PTR [edi]
  00028	80 fa 4c	 cmp	 dl, 76			; 0000004cH
  0002b	74 04		 je	 SHORT $LN4@Ifmt

; 1496 : 			*_Ptr++ = _Spec[0];	// qualifier

  0002d	88 10		 mov	 BYTE PTR [eax], dl

; 1497 : 		else

  0002f	eb 0b		 jmp	 SHORT $LN5@Ifmt
$LN4@Ifmt:

; 1498 : 
; 1499 : 			{	/* change L to I64 */
; 1500 : 			*_Ptr++ = 'I';

  00031	66 c7 00 49 36	 mov	 WORD PTR [eax], 13897	; 00003649H

; 1501 : 			*_Ptr++ = '6';

  00036	83 c0 02	 add	 eax, 2

; 1502 : 			*_Ptr++ = '4';

  00039	c6 00 34	 mov	 BYTE PTR [eax], 52	; 00000034H
$LN5@Ifmt:

; 1503 : 			}
; 1504 : 
; 1505 : 		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

  0003c	8b d1		 mov	 edx, ecx
  0003e	81 e2 00 0e 00
	00		 and	 edx, 3584		; 00000e00H
  00044	81 fa 00 04 00
	00		 cmp	 edx, 1024		; 00000400H

; 1506 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'

  0004a	75 0f		 jne	 SHORT $LN9@Ifmt
  0004c	b1 6f		 mov	 cl, 111			; 0000006fH
  0004e	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 1507 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1508 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';
; 1509 : 		*_Ptr = '\0';

  00051	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 1510 : 		return (_Fmt);

  00055	8b c6		 mov	 eax, esi
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi

; 1511 : 		}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN9@Ifmt:
  0005b	81 fa 00 08 00
	00		 cmp	 edx, 2048		; 00000800H

; 1506 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'

  00061	74 10		 je	 SHORT $LN7@Ifmt
  00063	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00066	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 1507 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1508 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';
; 1509 : 		*_Ptr = '\0';

  00069	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 1510 : 		return (_Fmt);

  0006d	8b c6		 mov	 eax, esi
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi

; 1511 : 		}

  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
$LN7@Ifmt:

; 1506 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'

  00073	c0 e1 03	 shl	 cl, 3
  00076	f6 d1		 not	 cl
  00078	80 e1 20	 and	 cl, 32			; 00000020H
  0007b	80 c9 58	 or	 cl, 88			; 00000058H
  0007e	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 1507 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1508 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';
; 1509 : 		*_Ptr = '\0';

  00081	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 1510 : 		return (_Fmt);

  00085	8b c6		 mov	 eax, esi
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 1511 : 		}

  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
_TEXT	SEGMENT
$T2 = -104						; size = 8
__Iosbase$GSCopy$1$ = -100				; size = 4
___$ReturnUdt$GSCopy$1$ = -96				; size = 4
__Count$GSCopy$2$ = -92					; size = 4
__Eoff$1$ = -92						; size = 4
__Buf$GSCopy$1$ = -88					; size = 4
__Punct_fac$1$ = -88					; size = 4
$T3 = -84						; size = 8
$T4 = -84						; size = 8
$T5 = -84						; size = 8
$T6 = -84						; size = 8
$T7 = -84						; size = 8
$T8 = -84						; size = 8
$T9 = -84						; size = 8
__Ctype_fac$1$ = -76					; size = 4
__Kseparator$ = -76					; size = 1
__Dp$ = -72						; size = 2
__Dest$3$ = -68						; size = 4
__Count$GSCopy$1$ = -68					; size = 4
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput, COMDAT

; 1413 : 		{	// put formatted floating-point to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 4d 24	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00031	8b 75 18	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00034	8b 7d 20	 mov	 edi, DWORD PTR __Buf$[ebp]
  00037	89 45 a0	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003a	89 75 9c	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], esi
  0003d	89 7d a8	 mov	 DWORD PTR __Buf$GSCopy$1$[ebp], edi
  00040	89 4d bc	 mov	 DWORD PTR __Count$GSCopy$1$[ebp], ecx

; 1414 : 		_DEBUG_POINTER(_Dest);
; 1415 : 		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')

  00043	85 c9		 test	 ecx, ecx
  00045	74 11		 je	 SHORT $LN16@Fput
  00047	8a 07		 mov	 al, BYTE PTR [edi]
  00049	3c 2b		 cmp	 al, 43			; 0000002bH
  0004b	74 04		 je	 SHORT $LN15@Fput
  0004d	3c 2d		 cmp	 al, 45			; 0000002dH
  0004f	75 07		 jne	 SHORT $LN16@Fput
$LN15@Fput:
  00051	bb 01 00 00 00	 mov	 ebx, 1
  00056	eb 02		 jmp	 SHORT $LN17@Fput
$LN16@Fput:
  00058	33 db		 xor	 ebx, ebx
$LN17@Fput:

; 1416 : 			? 1 : 0;
; 1417 : 
; 1418 : 		const char *_Exps;
; 1419 : 		if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)

  0005a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0005d	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  00062	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  00067	74 07		 je	 SHORT $LN4@Fput

; 1420 : 			_Exps = "eE";

  00069	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MDKMJEGG@eE?$AA@

; 1421 : 		else

  0006e	eb 22		 jmp	 SHORT $LN6@Fput
$LN4@Fput:

; 1422 : 			{	// correct for hexadecimal floating-point
; 1423 : 			_Exps = "pP";
; 1424 : 			if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1425 : 				&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))

  00070	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  00073	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02OOPEBDOJ@pP?$AA@
  00078	3b c1		 cmp	 eax, ecx
  0007a	77 16		 ja	 SHORT $LN6@Fput
  0007c	80 3c 1f 30	 cmp	 BYTE PTR [edi+ebx], 48	; 00000030H
  00080	75 10		 jne	 SHORT $LN6@Fput
  00082	8a 4c 1f 01	 mov	 cl, BYTE PTR [edi+ebx+1]
  00086	80 f9 78	 cmp	 cl, 120			; 00000078H
  00089	74 05		 je	 SHORT $LN7@Fput
  0008b	80 f9 58	 cmp	 cl, 88			; 00000058H
  0008e	75 02		 jne	 SHORT $LN6@Fput
$LN7@Fput:

; 1426 : 				_Prefix += 2;

  00090	8b d8		 mov	 ebx, eax
$LN6@Fput:

; 1427 : 			}
; 1428 : 		const size_t _Eoff =
; 1429 : 			_CSTD strcspn(&_Buf[0], _Exps);	// find exponent

  00092	52		 push	 edx
  00093	57		 push	 edi
  00094	e8 00 00 00 00	 call	 _strcspn
  00099	89 45 a4	 mov	 DWORD PTR __Eoff$1$[ebp], eax

; 1430 : 		char _Dp[2] = {"."};

  0009c	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  000a1	66 89 45 b8	 mov	 WORD PTR __Dp$[ebp], ax

; 1431 : 		_Dp[0] = _CSTD localeconv()->decimal_point[0];

  000a5	e8 00 00 00 00	 call	 _localeconv
  000aa	8b 00		 mov	 eax, DWORD PTR [eax]
  000ac	8a 00		 mov	 al, BYTE PTR [eax]
  000ae	88 45 b8	 mov	 BYTE PTR __Dp$[ebp], al

; 1432 : 		const size_t _Poff =
; 1433 : 			_CSTD strcspn(&_Buf[0], &_Dp[0]);	// find decimal point

  000b1	8d 45 b8	 lea	 eax, DWORD PTR __Dp$[ebp]
  000b4	50		 push	 eax
  000b5	57		 push	 edi
  000b6	e8 00 00 00 00	 call	 _strcspn
  000bb	83 c4 10	 add	 esp, 16			; 00000010H
  000be	8b f8		 mov	 edi, eax

; 1434 : 
; 1435 : 		const ctype<_Elem>& _Ctype_fac =

  000c0	8d 45 ac	 lea	 eax, DWORD PTR $T9[ebp]
  000c3	8b ce		 mov	 ecx, esi
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  000cb	50		 push	 eax
  000cc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000d3	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  000d8	83 c4 04	 add	 esp, 4
  000db	89 45 b4	 mov	 DWORD PTR __Ctype_fac$1$[ebp], eax
  000de	8b 4d b0	 mov	 ecx, DWORD PTR $T9[ebp+4]
  000e1	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000e8	85 c9		 test	 ecx, ecx
  000ea	74 11		 je	 SHORT $LN29@Fput
  000ec	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ee	ff 50 08	 call	 DWORD PTR [eax+8]
  000f1	8b c8		 mov	 ecx, eax
  000f3	85 c9		 test	 ecx, ecx
  000f5	74 06		 je	 SHORT $LN29@Fput
  000f7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f9	6a 01		 push	 1
  000fb	ff 10		 call	 DWORD PTR [eax]
$LN29@Fput:

; 1436 : 			_USE(_Iosbase.getloc(), ctype<_Elem>);
; 1437 : 		_Mystr _Groupstring(_Count, _Elem(0));	// reserve space

  000fd	6a 00		 push	 0
  000ff	ff 75 bc	 push	 DWORD PTR __Count$GSCopy$1$[ebp]
  00102	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00105	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0010c	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __Groupstring$[ebp+20], 15 ; 0000000fH
  00113	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Groupstring$[ebp+16], 0
  0011a	c6 45 d8 00	 mov	 BYTE PTR __Groupstring$[ebp], 0
  0011e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1438 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

  00123	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  00127	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0012a	8b 55 b4	 mov	 edx, DWORD PTR __Ctype_fac$1$[ebp]
  0012d	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  00131	8b 4d a8	 mov	 ecx, DWORD PTR __Buf$GSCopy$1$[ebp]
  00134	50		 push	 eax
  00135	8b 45 bc	 mov	 eax, DWORD PTR __Count$GSCopy$1$[ebp]
  00138	8b 12		 mov	 edx, DWORD PTR [edx]
  0013a	03 c1		 add	 eax, ecx
  0013c	50		 push	 eax
  0013d	51		 push	 ecx
  0013e	8b 4d b4	 mov	 ecx, DWORD PTR __Ctype_fac$1$[ebp]
  00141	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00148	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1439 : 
; 1440 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

  0014b	8d 45 ac	 lea	 eax, DWORD PTR $T8[ebp]
  0014e	8b ce		 mov	 ecx, esi
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00156	50		 push	 eax
  00157	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0015b	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
  00160	8b f0		 mov	 esi, eax
  00162	83 c4 04	 add	 esp, 4
  00165	89 75 a8	 mov	 DWORD PTR __Punct_fac$1$[ebp], esi
  00168	8b 4d b0	 mov	 ecx, DWORD PTR $T8[ebp+4]
  0016b	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0016f	85 c9		 test	 ecx, ecx
  00171	74 11		 je	 SHORT $LN159@Fput
  00173	8b 01		 mov	 eax, DWORD PTR [ecx]
  00175	ff 50 08	 call	 DWORD PTR [eax+8]
  00178	8b c8		 mov	 ecx, eax
  0017a	85 c9		 test	 ecx, ecx
  0017c	74 06		 je	 SHORT $LN159@Fput
  0017e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00180	6a 01		 push	 1
  00182	ff 10		 call	 DWORD PTR [eax]
$LN159@Fput:

; 1441 : 		const string _Grouping = _Punct_fac.grouping();

  00184	8d 45 c0	 lea	 eax, DWORD PTR __Grouping$[ebp]
  00187	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0018b	50		 push	 eax
  0018c	8b ce		 mov	 ecx, esi
  0018e	e8 00 00 00 00	 call	 ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping

; 1442 : 		const _Elem _Kseparator = _Punct_fac.thousands_sep();

  00193	8b 06		 mov	 eax, DWORD PTR [esi]
  00195	8b ce		 mov	 ecx, esi
  00197	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0019b	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0019e	ff d0		 call	 eax

; 1443 : 
; 1444 : 		if (_Poff != _Count)

  001a0	8b 75 bc	 mov	 esi, DWORD PTR __Count$GSCopy$1$[ebp]
  001a3	88 45 b4	 mov	 BYTE PTR __Kseparator$[ebp], al
  001a6	3b fe		 cmp	 edi, esi
  001a8	74 1c		 je	 SHORT $LN494@Fput

; 1445 : 			_Groupstring[_Poff] = _Punct_fac.decimal_point();

  001aa	8b 4d a8	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
  001ad	8b 01		 mov	 eax, DWORD PTR [ecx]
  001af	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001b2	ff d0		 call	 eax
  001b4	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  001b8	8a c8		 mov	 cl, al
  001ba	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  001bd	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]

; 1446 : 
; 1447 : 		size_t _Off = _Poff == _Count ? _Eoff : _Poff;

  001c1	3b fe		 cmp	 edi, esi
  001c3	88 0c 38	 mov	 BYTE PTR [eax+edi], cl
$LN494@Fput:
  001c6	0f 44 7d a4	 cmove	 edi, DWORD PTR __Eoff$1$[ebp]

; 1448 : 		const char *_Pg = &_Grouping[0];

  001ca	8d 75 c0	 lea	 esi, DWORD PTR __Grouping$[ebp]
  001cd	83 7d d4 10	 cmp	 DWORD PTR __Grouping$[ebp+20], 16 ; 00000010H
  001d1	0f 43 75 c0	 cmovae	 esi, DWORD PTR __Grouping$[ebp]

; 1449 : 		while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1450 : 			&& (size_t)*_Pg < _Off - _Prefix)

  001d5	80 3e 7f	 cmp	 BYTE PTR [esi], 127	; 0000007fH
  001d8	74 38		 je	 SHORT $LN3@Fput
  001da	66 0f 1f 44 00
	00		 npad	 6
$LL2@Fput:
  001e0	8a 06		 mov	 al, BYTE PTR [esi]
  001e2	84 c0		 test	 al, al
  001e4	7e 2c		 jle	 SHORT $LN3@Fput
  001e6	0f be c8	 movsx	 ecx, al
  001e9	8b c7		 mov	 eax, edi
  001eb	2b c3		 sub	 eax, ebx
  001ed	3b c8		 cmp	 ecx, eax
  001ef	73 21		 jae	 SHORT $LN3@Fput

; 1451 : 			{	// add thousands separator
; 1452 : 			_Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);

  001f1	ff 75 b4	 push	 DWORD PTR __Kseparator$[ebp]
  001f4	2b f9		 sub	 edi, ecx
  001f6	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  001f9	6a 01		 push	 1
  001fb	57		 push	 edi
  001fc	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00201	80 7e 01 00	 cmp	 BYTE PTR [esi+1], 0

; 1453 : 			if ('\0' < _Pg[1])

  00205	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00208	0f 4e c6	 cmovle	 eax, esi
  0020b	8b f0		 mov	 esi, eax
  0020d	80 3e 7f	 cmp	 BYTE PTR [esi], 127	; 0000007fH
  00210	75 ce		 jne	 SHORT $LL2@Fput
$LN3@Fput:

; 1454 : 				++_Pg;	// not last group, advance
; 1455 : 			}
; 1456 : 
; 1457 : 		_Count = _Groupstring.size();
; 1458 : 		size_t _Fillcount = _Iosbase.width() <= 0
; 1459 : 			|| (size_t)_Iosbase.width() <= _Count

  00212	8b 7d 9c	 mov	 edi, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00215	8b 45 e8	 mov	 eax, DWORD PTR __Groupstring$[ebp+16]
  00218	89 45 a4	 mov	 DWORD PTR __Count$GSCopy$2$[ebp], eax
  0021b	83 7f 24 00	 cmp	 DWORD PTR [edi+36], 0
  0021f	7c 13		 jl	 SHORT $LN18@Fput
  00221	7f 06		 jg	 SHORT $LN490@Fput
  00223	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00227	76 0b		 jbe	 SHORT $LN18@Fput
$LN490@Fput:
  00229	8b 77 20	 mov	 esi, DWORD PTR [edi+32]
  0022c	3b f0		 cmp	 esi, eax
  0022e	76 04		 jbe	 SHORT $LN18@Fput
  00230	2b f0		 sub	 esi, eax
  00232	eb 02		 jmp	 SHORT $LN19@Fput
$LN18@Fput:
  00234	33 f6		 xor	 esi, esi
$LN19@Fput:

; 1460 : 				? 0 : (size_t)_Iosbase.width() - _Count;
; 1461 : 
; 1462 : 		ios_base::fmtflags _Adjustfield =
; 1463 : 			_Iosbase.flags() & ios_base::adjustfield;

  00236	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00239	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  0023e	83 f8 40	 cmp	 eax, 64			; 00000040H

; 1464 : 		if (_Adjustfield != ios_base::left
; 1465 : 			&& _Adjustfield != ios_base::internal)

  00241	0f 84 97 00 00
	00		 je	 $LN12@Fput
  00247	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0024c	74 48		 je	 SHORT $LN489@Fput

; 1466 : 			{	// put leading fill
; 1467 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

  0024e	56		 push	 esi
  0024f	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  00252	8d 45 ac	 lea	 eax, DWORD PTR $T7[ebp]
  00255	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  00258	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0025b	50		 push	 eax
  0025c	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0025f	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  00264	8b c8		 mov	 ecx, eax

; 1468 : 			_Fillcount = 0;

  00266	33 f6		 xor	 esi, esi

; 1469 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00268	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  0026c	53		 push	 ebx
  0026d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0026f	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00272	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00275	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00278	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0027b	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  0027f	50		 push	 eax
  00280	ff 71 04	 push	 DWORD PTR [ecx+4]
  00283	8d 45 ac	 lea	 eax, DWORD PTR $T6[ebp]
  00286	ff 31		 push	 DWORD PTR [ecx]
  00288	50		 push	 eax
  00289	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0028c	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  00291	83 c4 30	 add	 esp, 48			; 00000030H
  00294	eb 6a		 jmp	 SHORT $LN495@Fput
$LN489@Fput:

; 1470 : 			}
; 1471 : 		else if (_Adjustfield == ios_base::internal)
; 1472 : 			{	// put internal fill
; 1473 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00296	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  0029a	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0029d	53		 push	 ebx
  0029e	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  002a2	50		 push	 eax
  002a3	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  002a6	8d 45 ac	 lea	 eax, DWORD PTR $T5[ebp]
  002a9	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  002ac	50		 push	 eax
  002ad	ff 75 08	 push	 DWORD PTR _this$[ebp]
  002b0	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  002b5	8b c8		 mov	 ecx, eax

; 1474 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

  002b7	56		 push	 esi
  002b8	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  002bb	8b 01		 mov	 eax, DWORD PTR [ecx]
  002bd	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  002c0	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  002c3	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  002c6	8d 45 ac	 lea	 eax, DWORD PTR $T4[ebp]
  002c9	ff 71 04	 push	 DWORD PTR [ecx+4]
  002cc	ff 31		 push	 DWORD PTR [ecx]
  002ce	50		 push	 eax
  002cf	ff 75 08	 push	 DWORD PTR _this$[ebp]
  002d2	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  002d7	83 c4 30	 add	 esp, 48			; 00000030H

; 1475 : 			_Fillcount = 0;

  002da	33 f6		 xor	 esi, esi

; 1476 : 			}
; 1477 : 		else

  002dc	eb 22		 jmp	 SHORT $LN495@Fput
$LN12@Fput:

; 1478 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  002de	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  002e2	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  002e5	53		 push	 ebx
  002e6	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  002ea	50		 push	 eax
  002eb	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  002ee	8d 45 ac	 lea	 eax, DWORD PTR $T3[ebp]
  002f1	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  002f4	50		 push	 eax
  002f5	ff 75 08	 push	 DWORD PTR _this$[ebp]
  002f8	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  002fd	83 c4 18	 add	 esp, 24			; 00000018H
$LN495@Fput:
  00300	8b 10		 mov	 edx, DWORD PTR [eax]

; 1479 : 
; 1480 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  00302	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  00306	8b 4d a4	 mov	 ecx, DWORD PTR __Count$GSCopy$2$[ebp]
  00309	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  0030c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0030f	89 45 bc	 mov	 DWORD PTR __Dest$3$[ebp], eax
  00312	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00315	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  00318	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  0031c	2b cb		 sub	 ecx, ebx
  0031e	51		 push	 ecx
  0031f	03 c3		 add	 eax, ebx
  00321	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00324	50		 push	 eax
  00325	ff 75 bc	 push	 DWORD PTR __Dest$3$[ebp]
  00328	8d 45 98	 lea	 eax, DWORD PTR $T2[ebp]
  0032b	52		 push	 edx
  0032c	50		 push	 eax
  0032d	53		 push	 ebx
  0032e	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1481 : 		_Iosbase.width(0);
; 1482 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

  00333	56		 push	 esi
  00334	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  00337	8b 75 a0	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  0033a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0033c	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  0033f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00342	50		 push	 eax
  00343	51		 push	 ecx
  00344	56		 push	 esi
  00345	53		 push	 ebx
  00346	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00349	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
  00350	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], 0
  00357	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  0035c	8b 45 d4	 mov	 eax, DWORD PTR __Grouping$[ebp+20]
  0035f	83 c4 30	 add	 esp, 48			; 00000030H
  00362	83 f8 10	 cmp	 eax, 16			; 00000010H
  00365	72 0d		 jb	 SHORT $LN290@Fput
  00367	40		 inc	 eax
  00368	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  0036b	50		 push	 eax
  0036c	ff 75 c0	 push	 DWORD PTR __Grouping$[ebp]
  0036f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN290@Fput:
  00374	8b 4d ec	 mov	 ecx, DWORD PTR __Groupstring$[ebp+20]
  00377	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+20], 15 ; 0000000fH
  0037e	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+16], 0
  00385	c6 45 c0 00	 mov	 BYTE PTR __Grouping$[ebp], 0
  00389	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0038c	72 0d		 jb	 SHORT $LN491@Fput
  0038e	41		 inc	 ecx
  0038f	51		 push	 ecx
  00390	ff 75 d8	 push	 DWORD PTR __Groupstring$[ebp]
  00393	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00396	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN491@Fput:
  0039b	8b c6		 mov	 eax, esi

; 1483 : 		}

  0039d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003a0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003a7	59		 pop	 ecx
  003a8	5f		 pop	 edi
  003a9	5e		 pop	 esi
  003aa	5b		 pop	 ebx
  003ab	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ae	33 cd		 xor	 ecx, ebp
  003b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b5	8b e5		 mov	 esp, ebp
  003b7	5d		 pop	 ebp
  003b8	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$0:
  00000	8d 4d ac	 lea	 ecx, DWORD PTR $T9[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$4:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$1:
  0000e	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$2:
  00016	8d 4d ac	 lea	 ecx, DWORD PTR $T8[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$33:
  0001e	e8 00 00 00 00	 call	 ___std_terminate
  00023	c3		 ret	 0
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$3:
  00024	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 4a 94	 mov	 ecx, DWORD PTR [edx-108]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00040	33 c8		 xor	 ecx, eax
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
  0004c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 1
__Flags$ = 20						; size = 4
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt, COMDAT

; 1383 : 		{	// generate sprintf format for floating-point

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1384 : 		char *_Ptr = _Fmt;
; 1385 : 		*_Ptr++ = '%';
; 1386 : 
; 1387 : 		if (_Flags & ios_base::showpos)

  00003	8b 55 14	 mov	 edx, DWORD PTR __Flags$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Fmt$[ebp]
  0000a	c6 06 25	 mov	 BYTE PTR [esi], 37	; 00000025H
  0000d	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00010	f6 c2 20	 test	 dl, 32			; 00000020H
  00013	74 04		 je	 SHORT $LN2@Ffmt

; 1388 : 			*_Ptr++ = '+';

  00015	c6 00 2b	 mov	 BYTE PTR [eax], 43	; 0000002bH
  00018	40		 inc	 eax
$LN2@Ffmt:

; 1389 : 		if (_Flags & ios_base::showpoint)

  00019	f6 c2 10	 test	 dl, 16			; 00000010H
  0001c	74 04		 je	 SHORT $LN3@Ffmt

; 1390 : 			*_Ptr++ = '#';

  0001e	c6 00 23	 mov	 BYTE PTR [eax], 35	; 00000023H
  00021	40		 inc	 eax
$LN3@Ffmt:

; 1391 : 		*_Ptr++ = '.';
; 1392 : 		*_Ptr++ = '*';	// for precision argument
; 1393 : 		if (_Spec != '\0')

  00022	8a 4d 10	 mov	 cl, BYTE PTR __Spec$[ebp]
  00025	66 c7 00 2e 2a	 mov	 WORD PTR [eax], 10798	; 00002a2eH
  0002a	83 c0 02	 add	 eax, 2
  0002d	84 c9		 test	 cl, cl
  0002f	74 03		 je	 SHORT $LN4@Ffmt

; 1394 : 			*_Ptr++ = _Spec;	// 'L' qualifier for long double only

  00031	88 08		 mov	 BYTE PTR [eax], cl
  00033	40		 inc	 eax
$LN4@Ffmt:

; 1395 : 
; 1396 : 		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

  00034	8b ca		 mov	 ecx, edx
  00036	81 e1 00 30 00
	00		 and	 ecx, 12288		; 00003000H

; 1397 : 		if (_Flags & ios_base::uppercase)

  0003c	f6 c2 04	 test	 dl, 4
  0003f	74 38		 je	 SHORT $LN5@Ffmt
  00041	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H

; 1398 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  00047	74 38		 je	 SHORT $LN16@Ffmt
  00049	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H
  0004f	75 0d		 jne	 SHORT $LN8@Ffmt
  00051	b1 41		 mov	 cl, 65			; 00000041H

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  00053	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  00055	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi

; 1408 : 		}

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN8@Ffmt:
  0005e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H

; 1398 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  00064	0f 95 c1	 setne	 cl
  00067	8d 0c 4d 45 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+69]

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  0006e	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  00070	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  00074	8b c6		 mov	 eax, esi
  00076	5e		 pop	 esi

; 1408 : 		}

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN5@Ffmt:
  00079	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  0007f	75 0d		 jne	 SHORT $LN14@Ffmt
$LN16@Ffmt:
  00081	b1 66		 mov	 cl, 102			; 00000066H
  00083	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  00085	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  00089	8b c6		 mov	 eax, esi
  0008b	5e		 pop	 esi

; 1408 : 		}

  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
$LN14@Ffmt:
  0008e	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  00094	75 0d		 jne	 SHORT $LN12@Ffmt
  00096	b1 61		 mov	 cl, 97			; 00000061H
  00098	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  0009a	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  0009e	8b c6		 mov	 eax, esi
  000a0	5e		 pop	 esi

; 1408 : 		}

  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
$LN12@Ffmt:
  000a3	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  000a9	0f 95 c1	 setne	 cl
  000ac	8d 0c 4d 65 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+101]
  000b3	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  000b5	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  000b9	8b c6		 mov	 eax, esi
  000bb	5e		 pop	 esi

; 1408 : 		}

  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
_TEXT	SEGMENT
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1373 : 		{	// put formatted void pointer to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 1c	 mov	 eax, DWORD PTR __Val$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi

; 1374 : 		char _Buf[2 * _MAX_INT_DIG];
; 1375 : 
; 1376 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  0001c	50		 push	 eax
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp?$AA@
  00022	8d 45 bc	 lea	 eax, DWORD PTR __Buf$[ebp]
  00025	8b f9		 mov	 edi, ecx
  00027	6a 40		 push	 64			; 00000040H
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _sprintf_s
  0002f	50		 push	 eax
  00030	8d 45 bc	 lea	 eax, DWORD PTR __Buf$[ebp]
  00033	50		 push	 eax
  00034	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00037	56		 push	 esi
  00038	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0003b	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0003e	53		 push	 ebx
  0003f	57		 push	 edi
  00040	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1377 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), "%p", _Val)));
; 1378 : 		}

  00045	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00048	83 c4 30	 add	 esp, 48			; 00000030H
  0004b	8b c3		 mov	 eax, ebx
  0004d	33 cd		 xor	 ecx, ebp
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
_TEXT	SEGMENT
__Precision$ = -72					; size = 8
__Ptwo$2 = -68						; size = 4
___$ReturnUdt$GSCopy$1$ = -64				; size = 4
_this$GSCopy$1$ = -60					; size = 4
__Iosbase$GSCopy$1$ = -56				; size = 4
__Precision$1$ = -52					; size = 4
__Buf$ = -48						; size = 24
__Fmt$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1349 : 		{	// put formatted long double to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d c4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1350 : 		string _Buf;

  00030	33 d2		 xor	 edx, edx
  00032	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00035	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
  0003a	89 45 c0	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003d	89 4d c8	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], ecx
  00040	89 7d e4	 mov	 DWORD PTR __Buf$[ebp+20], edi
  00043	89 55 e0	 mov	 DWORD PTR __Buf$[ebp+16], edx
  00046	88 55 d0	 mov	 BYTE PTR __Buf$[ebp], dl

; 1351 : 		char _Fmt[8];
; 1352 : 		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
; 1353 : 			== ios_base::fixed;

  00049	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1354 : 		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed

  0004c	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  0004f	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  00054	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00057	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx
  0005a	89 75 cc	 mov	 DWORD PTR __Precision$1$[ebp], esi
  0005d	85 c9		 test	 ecx, ecx
  0005f	7f 17		 jg	 SHORT $LN4@do_put
  00061	7c 04		 jl	 SHORT $LN314@do_put
  00063	85 f6		 test	 esi, esi
  00065	75 11		 jne	 SHORT $LN4@do_put
$LN314@do_put:
  00067	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  0006c	74 0a		 je	 SHORT $LN4@do_put
  0006e	be 06 00 00 00	 mov	 esi, 6
  00073	33 c9		 xor	 ecx, ecx
  00075	89 75 cc	 mov	 DWORD PTR __Precision$1$[ebp], esi
$LN4@do_put:
  00078	89 4d bc	 mov	 DWORD PTR __Precision$[ebp+4], ecx

; 1355 : 			? 6 : _Iosbase.precision();	// desired precision
; 1356 : 		size_t _Bufsize = (size_t)_Precision;

  0007b	8b ce		 mov	 ecx, esi
  0007d	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H

; 1357 : 		if (_Isfixed && 1e10 < _CSTD fabsl(_Val))

  00082	75 56		 jne	 SHORT $LN2@do_put
  00084	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR __Val$[ebp]
  00089	0f 28 c1	 movaps	 xmm0, xmm1
  0008c	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00093	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4202a05f20000000
  0009b	76 3d		 jbe	 SHORT $LN2@do_put

; 1358 : 			{	// f or F format
; 1359 : 			int _Ptwo;
; 1360 : 			(void)_CSTD frexpl(_Val, &_Ptwo);

  0009d	8d 45 bc	 lea	 eax, DWORD PTR __Ptwo$2[ebp]
  000a0	50		 push	 eax
  000a1	83 ec 08	 sub	 esp, 8
  000a4	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  000a9	e8 00 00 00 00	 call	 _frexp

; 1361 : 			_Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  000ae	8b 45 bc	 mov	 eax, DWORD PTR __Ptwo$2[ebp]
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	8b 7d e4	 mov	 edi, DWORD PTR __Buf$[ebp+20]
  000b7	dd d8		 fstp	 ST(0)
  000b9	99		 cdq
  000ba	33 c2		 xor	 eax, edx
  000bc	2b c2		 sub	 eax, edx
  000be	69 c8 97 75 00
	00		 imul	 ecx, eax, 30103
  000c4	b8 89 b5 f8 14	 mov	 eax, 351843721		; 14f8b589H
  000c9	f7 e9		 imul	 ecx
  000cb	c1 fa 0d	 sar	 edx, 13			; 0000000dH
  000ce	8b ca		 mov	 ecx, edx
  000d0	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000d3	03 ca		 add	 ecx, edx
  000d5	8b 55 e0	 mov	 edx, DWORD PTR __Buf$[ebp+16]
  000d8	03 ce		 add	 ecx, esi
$LN2@do_put:

; 1362 : 			}
; 1363 : 		_Buf.resize(_Bufsize + 50);	// add fudge factor

  000da	83 c1 32	 add	 ecx, 50			; 00000032H
  000dd	3b ca		 cmp	 ecx, edx
  000df	77 13		 ja	 SHORT $LN127@do_put
  000e1	83 ff 10	 cmp	 edi, 16			; 00000010H
  000e4	89 4d e0	 mov	 DWORD PTR __Buf$[ebp+16], ecx
  000e7	8d 45 d0	 lea	 eax, DWORD PTR __Buf$[ebp]
  000ea	0f 43 45 d0	 cmovae	 eax, DWORD PTR __Buf$[ebp]
  000ee	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  000f2	eb 0d		 jmp	 SHORT $LN128@do_put
$LN127@do_put:
  000f4	2b ca		 sub	 ecx, edx
  000f6	6a 00		 push	 0
  000f8	51		 push	 ecx
  000f9	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  000fc	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN128@do_put:

; 1364 : 
; 1365 : 		int _Ngen = _CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),

  00101	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H
  00105	8d 7d d0	 lea	 edi, DWORD PTR __Buf$[ebp]
  00108	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  0010d	0f 43 7d d0	 cmovae	 edi, DWORD PTR __Buf$[ebp]
  00111	83 ec 08	 sub	 esp, 8
  00114	8b 45 c8	 mov	 eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00117	8b 75 e0	 mov	 esi, DWORD PTR __Buf$[ebp+16]
  0011a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0011f	ff 75 cc	 push	 DWORD PTR __Precision$1$[ebp]
  00122	ff 70 14	 push	 DWORD PTR [eax+20]
  00125	8d 45 e8	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00128	6a 4c		 push	 76			; 0000004cH
  0012a	50		 push	 eax
  0012b	ff 75 c4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0012e	e8 00 00 00 00	 call	 ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
  00133	83 c4 10	 add	 esp, 16			; 00000010H
  00136	50		 push	 eax
  00137	56		 push	 esi
  00138	57		 push	 edi
  00139	e8 00 00 00 00	 call	 _sprintf_s

; 1366 : 			_Ffmt(_Fmt, 'L', _Iosbase.flags()), (int)_Precision, _Val);
; 1367 : 
; 1368 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

  0013e	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H
  00142	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00145	8b 75 c0	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  00148	0f 43 4d d0	 cmovae	 ecx, DWORD PTR __Buf$[ebp]
  0014c	50		 push	 eax
  0014d	51		 push	 ecx
  0014e	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00151	ff 75 c8	 push	 DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00154	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00157	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0015a	56		 push	 esi
  0015b	ff 75 c4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0015e	e8 00 00 00 00	 call	 ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
  00163	8b 4d e4	 mov	 ecx, DWORD PTR __Buf$[ebp+20]
  00166	83 c4 38	 add	 esp, 56			; 00000038H
  00169	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0016c	72 0d		 jb	 SHORT $LN315@do_put
  0016e	41		 inc	 ecx
  0016f	51		 push	 ecx
  00170	ff 75 d0	 push	 DWORD PTR __Buf$[ebp]
  00173	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00176	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN315@do_put:
  0017b	8b c6		 mov	 eax, esi

; 1369 : 		}

  0017d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00180	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00187	59		 pop	 ecx
  00188	5f		 pop	 edi
  00189	5e		 pop	 esi
  0018a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018d	33 cd		 xor	 ecx, ebp
  0018f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00194	8b e5		 mov	 esp, ebp
  00196	5d		 pop	 ebp
  00197	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
__Precision$ = -72					; size = 8
__Ptwo$2 = -68						; size = 4
___$ReturnUdt$GSCopy$1$ = -64				; size = 4
_this$GSCopy$1$ = -60					; size = 4
__Iosbase$GSCopy$1$ = -56				; size = 4
__Precision$1$ = -52					; size = 4
__Buf$ = -48						; size = 24
__Fmt$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1325 : 		{	// put formatted double to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d c4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1326 : 		string _Buf;

  00030	33 d2		 xor	 edx, edx
  00032	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00035	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
  0003a	89 45 c0	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003d	89 4d c8	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], ecx
  00040	89 7d e4	 mov	 DWORD PTR __Buf$[ebp+20], edi
  00043	89 55 e0	 mov	 DWORD PTR __Buf$[ebp+16], edx
  00046	88 55 d0	 mov	 BYTE PTR __Buf$[ebp], dl

; 1327 : 		char _Fmt[8];
; 1328 : 		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
; 1329 : 			== ios_base::fixed;

  00049	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1330 : 		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed

  0004c	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  0004f	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  00054	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00057	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx
  0005a	89 75 cc	 mov	 DWORD PTR __Precision$1$[ebp], esi
  0005d	85 c9		 test	 ecx, ecx
  0005f	7f 17		 jg	 SHORT $LN4@do_put
  00061	7c 04		 jl	 SHORT $LN310@do_put
  00063	85 f6		 test	 esi, esi
  00065	75 11		 jne	 SHORT $LN4@do_put
$LN310@do_put:
  00067	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  0006c	74 0a		 je	 SHORT $LN4@do_put
  0006e	be 06 00 00 00	 mov	 esi, 6
  00073	33 c9		 xor	 ecx, ecx
  00075	89 75 cc	 mov	 DWORD PTR __Precision$1$[ebp], esi
$LN4@do_put:
  00078	89 4d bc	 mov	 DWORD PTR __Precision$[ebp+4], ecx

; 1331 : 			? 6 : _Iosbase.precision();	// desired precision
; 1332 : 		size_t _Bufsize = (size_t)_Precision;

  0007b	8b ce		 mov	 ecx, esi
  0007d	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H

; 1333 : 		if (_Isfixed && 1e10 < _CSTD fabs(_Val))

  00082	75 56		 jne	 SHORT $LN2@do_put
  00084	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR __Val$[ebp]
  00089	0f 28 c1	 movaps	 xmm0, xmm1
  0008c	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00093	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4202a05f20000000
  0009b	76 3d		 jbe	 SHORT $LN2@do_put

; 1334 : 			{	// f or F format
; 1335 : 			int _Ptwo;
; 1336 : 			(void)_CSTD frexp(_Val, &_Ptwo);

  0009d	8d 45 bc	 lea	 eax, DWORD PTR __Ptwo$2[ebp]
  000a0	50		 push	 eax
  000a1	83 ec 08	 sub	 esp, 8
  000a4	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  000a9	e8 00 00 00 00	 call	 _frexp

; 1337 : 			_Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  000ae	8b 45 bc	 mov	 eax, DWORD PTR __Ptwo$2[ebp]
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	8b 7d e4	 mov	 edi, DWORD PTR __Buf$[ebp+20]
  000b7	dd d8		 fstp	 ST(0)
  000b9	99		 cdq
  000ba	33 c2		 xor	 eax, edx
  000bc	2b c2		 sub	 eax, edx
  000be	69 c8 97 75 00
	00		 imul	 ecx, eax, 30103
  000c4	b8 89 b5 f8 14	 mov	 eax, 351843721		; 14f8b589H
  000c9	f7 e9		 imul	 ecx
  000cb	c1 fa 0d	 sar	 edx, 13			; 0000000dH
  000ce	8b ca		 mov	 ecx, edx
  000d0	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000d3	03 ca		 add	 ecx, edx
  000d5	8b 55 e0	 mov	 edx, DWORD PTR __Buf$[ebp+16]
  000d8	03 ce		 add	 ecx, esi
$LN2@do_put:

; 1338 : 			}
; 1339 : 		_Buf.resize(_Bufsize + 50);	// add fudge factor

  000da	83 c1 32	 add	 ecx, 50			; 00000032H
  000dd	3b ca		 cmp	 ecx, edx
  000df	77 13		 ja	 SHORT $LN123@do_put
  000e1	83 ff 10	 cmp	 edi, 16			; 00000010H
  000e4	89 4d e0	 mov	 DWORD PTR __Buf$[ebp+16], ecx
  000e7	8d 45 d0	 lea	 eax, DWORD PTR __Buf$[ebp]
  000ea	0f 43 45 d0	 cmovae	 eax, DWORD PTR __Buf$[ebp]
  000ee	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  000f2	eb 0d		 jmp	 SHORT $LN124@do_put
$LN123@do_put:
  000f4	2b ca		 sub	 ecx, edx
  000f6	6a 00		 push	 0
  000f8	51		 push	 ecx
  000f9	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  000fc	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN124@do_put:

; 1340 : 
; 1341 : 		int _Ngen = _CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),

  00101	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H
  00105	8d 7d d0	 lea	 edi, DWORD PTR __Buf$[ebp]
  00108	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  0010d	0f 43 7d d0	 cmovae	 edi, DWORD PTR __Buf$[ebp]
  00111	83 ec 08	 sub	 esp, 8
  00114	8b 45 c8	 mov	 eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00117	8b 75 e0	 mov	 esi, DWORD PTR __Buf$[ebp+16]
  0011a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0011f	ff 75 cc	 push	 DWORD PTR __Precision$1$[ebp]
  00122	ff 70 14	 push	 DWORD PTR [eax+20]
  00125	8d 45 e8	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00128	6a 00		 push	 0
  0012a	50		 push	 eax
  0012b	ff 75 c4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0012e	e8 00 00 00 00	 call	 ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
  00133	83 c4 10	 add	 esp, 16			; 00000010H
  00136	50		 push	 eax
  00137	56		 push	 esi
  00138	57		 push	 edi
  00139	e8 00 00 00 00	 call	 _sprintf_s

; 1342 : 			_Ffmt(_Fmt, 0, _Iosbase.flags()), (int)_Precision, _Val);
; 1343 : 
; 1344 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

  0013e	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H
  00142	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00145	8b 75 c0	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  00148	0f 43 4d d0	 cmovae	 ecx, DWORD PTR __Buf$[ebp]
  0014c	50		 push	 eax
  0014d	51		 push	 ecx
  0014e	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00151	ff 75 c8	 push	 DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00154	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00157	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0015a	56		 push	 esi
  0015b	ff 75 c4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0015e	e8 00 00 00 00	 call	 ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
  00163	8b 4d e4	 mov	 ecx, DWORD PTR __Buf$[ebp+20]
  00166	83 c4 38	 add	 esp, 56			; 00000038H
  00169	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0016c	72 0d		 jb	 SHORT $LN311@do_put
  0016e	41		 inc	 ecx
  0016f	51		 push	 ecx
  00170	ff 75 d0	 push	 DWORD PTR __Buf$[ebp]
  00173	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00176	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN311@do_put:
  0017b	8b c6		 mov	 eax, esi

; 1345 : 		}

  0017d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00180	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00187	59		 pop	 ecx
  00188	5f		 pop	 edi
  00189	5e		 pop	 esi
  0018a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018d	33 cd		 xor	 ecx, ebp
  0018f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00194	8b e5		 mov	 esp, ebp
  00196	5d		 pop	 ebp
  00197	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1315 : 		{	// put formatted unsigned long long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1316 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1317 : 
; 1318 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  00014	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi
  0001c	ff 75 20	 push	 DWORD PTR __Val$[ebp+4]
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  00024	ff 76 14	 push	 DWORD PTR [esi+20]
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_02CLHGNPPK@Lu?$AA@
  0002c	50		 push	 eax
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	50		 push	 eax
  00037	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0003a	6a 40		 push	 64			; 00000040H
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _sprintf_s
  00042	50		 push	 eax
  00043	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00046	50		 push	 eax
  00047	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0004a	56		 push	 esi
  0004b	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0004e	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00051	53		 push	 ebx
  00052	57		 push	 edi
  00053	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1319 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
; 1320 : 				_Iosbase.flags()), _Val)));
; 1321 : 		}

  00058	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005b	83 c4 34	 add	 esp, 52			; 00000034H
  0005e	8b c3		 mov	 eax, ebx
  00060	33 cd		 xor	 ecx, ebp
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 1c 00	 ret	 28			; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1305 : 		{	// put formatted long long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1306 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1307 : 
; 1308 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  00014	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi
  0001c	ff 75 20	 push	 DWORD PTR __Val$[ebp+4]
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  00024	ff 76 14	 push	 DWORD PTR [esi+20]
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_02HIKPPMOK@Ld?$AA@
  0002c	50		 push	 eax
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	50		 push	 eax
  00037	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0003a	6a 40		 push	 64			; 00000040H
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _sprintf_s
  00042	50		 push	 eax
  00043	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00046	50		 push	 eax
  00047	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0004a	56		 push	 esi
  0004b	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0004e	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00051	53		 push	 ebx
  00052	57		 push	 edi
  00053	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1309 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
; 1310 : 				_Iosbase.flags()), _Val)));
; 1311 : 		}

  00058	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005b	83 c4 34	 add	 esp, 52			; 00000034H
  0005e	8b c3		 mov	 eax, ebx
  00060	33 cd		 xor	 ecx, ebp
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 1c 00	 ret	 28			; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1295 : 		{	// put formatted unsigned long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1296 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1297 : 
; 1298 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  00014	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi
  0001c	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 76 14	 push	 DWORD PTR [esi+20]
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_02BDDLJJBK@lu?$AA@
  00029	50		 push	 eax
  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	50		 push	 eax
  00034	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00037	6a 40		 push	 64			; 00000040H
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _sprintf_s
  0003f	50		 push	 eax
  00040	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00043	50		 push	 eax
  00044	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00047	56		 push	 esi
  00048	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0004b	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0004e	53		 push	 ebx
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1299 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
; 1300 : 				_Iosbase.flags()), _Val)));
; 1301 : 		}

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	83 c4 30	 add	 esp, 48			; 00000030H
  0005b	8b c3		 mov	 eax, ebx
  0005d	33 cd		 xor	 ecx, ebp
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1285 : 		{	// put formatted long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1286 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1287 : 
; 1288 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  00014	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi
  0001c	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 76 14	 push	 DWORD PTR [esi+20]
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_02EAOCLKAK@ld?$AA@
  00029	50		 push	 eax
  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	50		 push	 eax
  00034	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00037	6a 40		 push	 64			; 00000040H
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _sprintf_s
  0003f	50		 push	 eax
  00040	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00043	50		 push	 eax
  00044	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00047	56		 push	 esi
  00048	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0004b	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0004e	53		 push	 ebx
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1289 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
; 1290 : 				_Iosbase.flags()), _Val)));
; 1291 : 		}

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	83 c4 30	 add	 esp, 48			; 00000030H
  0005b	8b c3		 mov	 eax, ebx
  0005d	33 cd		 xor	 ecx, ebp
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT
$T2 = -88						; size = 8
$T3 = -80						; size = 8
$T4 = -80						; size = 8
__Dest$3$ = -76						; size = 4
_this$GSCopy$1$ = -72					; size = 4
__Fill$GSCopy$ = -68					; size = 1
$T5 = -64						; size = 24
$T6 = -64						; size = 24
__Str$7 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 1
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1255 : 		{	// put formatted bool to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 4d b8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002e	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00031	8a 45 18	 mov	 al, BYTE PTR __Fill$[ebp]
  00034	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00037	88 45 bc	 mov	 BYTE PTR __Fill$GSCopy$[ebp], al

; 1256 : 		_DEBUG_POINTER(_Dest);
; 1257 : 		if (!(_Iosbase.flags() & ios_base::boolalpha))

  0003a	f7 46 14 00 40
	00 00		 test	 DWORD PTR [esi+20], 16384 ; 00004000H
  00041	75 1a		 jne	 SHORT $LN2@do_put

; 1258 : 			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));

  00043	0f b6 45 1c	 movzx	 eax, BYTE PTR __Val$[ebp]
  00047	8b 11		 mov	 edx, DWORD PTR [ecx]
  00049	50		 push	 eax
  0004a	ff 75 bc	 push	 DWORD PTR __Fill$GSCopy$[ebp]
  0004d	56		 push	 esi
  0004e	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00051	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00054	53		 push	 ebx
  00055	ff 52 24	 call	 DWORD PTR [edx+36]
  00058	e9 7d 01 00 00	 jmp	 $LN950@do_put
$LN2@do_put:

; 1259 : 		else
; 1260 : 			{	// put "false" or "true"
; 1261 : 			const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

  0005d	8d 45 b0	 lea	 eax, DWORD PTR $T4[ebp]
  00060	8b ce		 mov	 ecx, esi
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00068	50		 push	 eax
  00069	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00070	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
  00075	83 c4 04	 add	 esp, 4
  00078	8b f8		 mov	 edi, eax
  0007a	8b 4d b4	 mov	 ecx, DWORD PTR $T4[ebp+4]
  0007d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00084	85 c9		 test	 ecx, ecx
  00086	74 11		 je	 SHORT $LN19@do_put
  00088	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008a	ff 52 08	 call	 DWORD PTR [edx+8]
  0008d	85 c0		 test	 eax, eax
  0008f	74 08		 je	 SHORT $LN19@do_put
  00091	8b 10		 mov	 edx, DWORD PTR [eax]
  00093	8b c8		 mov	 ecx, eax
  00095	6a 01		 push	 1
  00097	ff 12		 call	 DWORD PTR [edx]
$LN19@do_put:

; 1262 : 			_Mystr _Str;

  00099	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __Str$7[ebp+20], 15 ; 0000000fH
  000a0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Str$7[ebp+16], 0
  000a7	c6 45 d8 00	 mov	 BYTE PTR __Str$7[ebp], 0

; 1263 : 			if (_Val)

  000ab	80 7d 1c 00	 cmp	 BYTE PTR __Val$[ebp], 0

; 1264 : 				_Str.assign(_Punct_fac.truename());

  000af	8d 45 c0	 lea	 eax, DWORD PTR $T6[ebp]
  000b2	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  000b9	8b cf		 mov	 ecx, edi
  000bb	50		 push	 eax
  000bc	74 09		 je	 SHORT $LN4@do_put
  000be	e8 00 00 00 00	 call	 ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
  000c3	8b f8		 mov	 edi, eax

; 1265 : 			else

  000c5	eb 07		 jmp	 SHORT $LN1052@do_put
$LN4@do_put:

; 1266 : 				_Str.assign(_Punct_fac.falsename());

  000c7	e8 00 00 00 00	 call	 ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
  000cc	8b f8		 mov	 edi, eax
$LN1052@do_put:
  000ce	8d 45 d8	 lea	 eax, DWORD PTR __Str$7[ebp]
  000d1	3b c7		 cmp	 eax, edi
  000d3	74 30		 je	 SHORT $LN509@do_put
  000d5	8b 45 ec	 mov	 eax, DWORD PTR __Str$7[ebp+20]
  000d8	83 f8 10	 cmp	 eax, 16			; 00000010H
  000db	72 0d		 jb	 SHORT $LN682@do_put
  000dd	40		 inc	 eax
  000de	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  000e1	50		 push	 eax
  000e2	ff 75 d8	 push	 DWORD PTR __Str$7[ebp]
  000e5	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN682@do_put:
  000ea	57		 push	 edi
  000eb	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  000ee	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __Str$7[ebp+20], 15 ; 0000000fH
  000f5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Str$7[ebp+16], 0
  000fc	c6 45 d8 00	 mov	 BYTE PTR __Str$7[ebp], 0
  00100	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN509@do_put:
  00105	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp+20]
  00108	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0010c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0010f	72 0d		 jb	 SHORT $LN786@do_put
  00111	40		 inc	 eax
  00112	8d 4d c0	 lea	 ecx, DWORD PTR $T5[ebp]
  00115	50		 push	 eax
  00116	ff 75 c0	 push	 DWORD PTR $T5[ebp]
  00119	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN786@do_put:

; 1267 : 
; 1268 : 			size_t _Fillcount = _Iosbase.width() <= 0
; 1269 : 				|| (size_t)_Iosbase.width() <= _Str.size()

  0011e	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00122	8b 4d e8	 mov	 ecx, DWORD PTR __Str$7[ebp+16]
  00125	7c 13		 jl	 SHORT $LN8@do_put
  00127	7f 06		 jg	 SHORT $LN1045@do_put
  00129	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0012d	76 0b		 jbe	 SHORT $LN8@do_put
$LN1045@do_put:
  0012f	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  00132	3b f9		 cmp	 edi, ecx
  00134	76 04		 jbe	 SHORT $LN8@do_put
  00136	2b f9		 sub	 edi, ecx
  00138	eb 02		 jmp	 SHORT $LN9@do_put
$LN8@do_put:
  0013a	33 ff		 xor	 edi, edi
$LN9@do_put:

; 1270 : 					? 0 : (size_t)_Iosbase.width() - _Str.size();
; 1271 : 
; 1272 : 			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)

  0013c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0013f	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00144	83 f8 40	 cmp	 eax, 64			; 00000040H
  00147	74 2b		 je	 SHORT $LN1046@do_put

; 1273 : 				{	// put leading fill
; 1274 : 				_Dest = _Rep(_Dest, _Fill, _Fillcount);

  00149	57		 push	 edi
  0014a	ff 75 bc	 push	 DWORD PTR __Fill$GSCopy$[ebp]
  0014d	8d 45 b0	 lea	 eax, DWORD PTR $T3[ebp]
  00150	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00153	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00156	50		 push	 eax
  00157	ff 75 b8	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0015a	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep

; 1275 : 				_Fillcount = 0;

  0015f	8b 4d e8	 mov	 ecx, DWORD PTR __Str$7[ebp+16]
  00162	83 c4 18	 add	 esp, 24			; 00000018H
  00165	33 ff		 xor	 edi, edi
  00167	8b 10		 mov	 edx, DWORD PTR [eax]
  00169	89 55 0c	 mov	 DWORD PTR __Dest$[ebp], edx
  0016c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0016f	89 45 10	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00172	eb 06		 jmp	 SHORT $LN1053@do_put
$LN1046@do_put:
  00174	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp+4]
  00177	8b 55 0c	 mov	 edx, DWORD PTR __Dest$[ebp]
$LN1053@do_put:

; 1276 : 				}
; 1277 : 			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field

  0017a	83 7d ec 10	 cmp	 DWORD PTR __Str$7[ebp+20], 16 ; 00000010H
  0017e	89 45 b4	 mov	 DWORD PTR __Dest$3$[ebp], eax
  00181	8d 45 d8	 lea	 eax, DWORD PTR __Str$7[ebp]
  00184	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Str$7[ebp]
  00188	51		 push	 ecx
  00189	50		 push	 eax
  0018a	ff 75 b4	 push	 DWORD PTR __Dest$3$[ebp]
  0018d	8d 45 a8	 lea	 eax, DWORD PTR $T2[ebp]
  00190	52		 push	 edx
  00191	50		 push	 eax
  00192	ff 75 b8	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  00195	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1278 : 			_Iosbase.width(0);
; 1279 : 			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

  0019a	57		 push	 edi
  0019b	ff 75 bc	 push	 DWORD PTR __Fill$GSCopy$[ebp]
  0019e	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a0	89 4d 0c	 mov	 DWORD PTR __Dest$[ebp], ecx
  001a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a6	50		 push	 eax
  001a7	51		 push	 ecx
  001a8	53		 push	 ebx
  001a9	ff 75 b8	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  001ac	89 45 10	 mov	 DWORD PTR __Dest$[ebp+4], eax
  001af	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  001b6	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  001bd	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  001c2	8b 45 ec	 mov	 eax, DWORD PTR __Str$7[ebp+20]
  001c5	83 c4 30	 add	 esp, 48			; 00000030H
  001c8	83 f8 10	 cmp	 eax, 16			; 00000010H
  001cb	72 0d		 jb	 SHORT $LN950@do_put
  001cd	40		 inc	 eax
  001ce	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  001d1	50		 push	 eax
  001d2	ff 75 d8	 push	 DWORD PTR __Str$7[ebp]
  001d5	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN950@do_put:
  001da	8b c3		 mov	 eax, ebx

; 1280 : 			}
; 1281 : 		}

  001dc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001df	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e6	59		 pop	 ecx
  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi
  001e9	5b		 pop	 ebx
  001ea	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ed	33 cd		 xor	 ecx, ebp
  001ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f4	8b e5		 mov	 esp, ebp
  001f6	5d		 pop	 ebp
  001f7	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$4:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1:
  0000e	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$32:
  00016	e8 00 00 00 00	 call	 ___std_terminate
  0001b	c3		 ret	 0
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$134:
  0001c	e8 00 00 00 00	 call	 ___std_terminate
  00021	c3		 ret	 0
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z:
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
  00042	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx

; 1218 : 		{	// put formatted unsigned long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1219 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

  00003	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0000b	ff 75 14	 push	 DWORD PTR __Iosbase$[ebp]
  0000e	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00011	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00017	ff 50 20	 call	 DWORD PTR [eax+32]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1220 : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 18 00	 ret	 24			; 00000018H
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 1197 : 		{	// construct from specified locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1196 : 		: locale::facet(_Refs)

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  00007	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1198 : 		_Init(_Lobj);
; 1199 : 		}

  0000a	8b c1		 mov	 eax, ecx
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = ecx

; 1184 : 		}

  00000	c2 04 00	 ret	 4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 1180 : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 52
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 1168 : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1169 : 		if (_Ppf != 0 && *_Ppf == 0)

  00028	8b 7d 08	 mov	 edi, DWORD PTR __Ppf$[ebp]
  0002b	33 db		 xor	 ebx, ebx
  0002d	89 5d f0	 mov	 DWORD PTR $T3[ebp], ebx
  00030	85 ff		 test	 edi, edi
  00032	74 63		 je	 SHORT $LN30@Getcat
  00034	39 1f		 cmp	 DWORD PTR [edi], ebx
  00036	75 5f		 jne	 SHORT $LN30@Getcat

; 1170 : 			*_Ppf = new num_put<_Elem, _OutIt>(

  00038	6a 08		 push	 8
  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	8b f0		 mov	 esi, eax
  00041	83 c4 04	 add	 esp, 4
  00044	89 75 08	 mov	 DWORD PTR $T4[ebp], esi
  00047	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0004a	85 f6		 test	 esi, esi
  0004c	74 38		 je	 SHORT $LN4@Getcat
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR __Ploc$[ebp]
  00051	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00054	85 c9		 test	 ecx, ecx
  00056	75 07		 jne	 SHORT $LN12@Getcat
  00058	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0005d	eb 0a		 jmp	 SHORT $LN17@Getcat
$LN12@Getcat:
  0005f	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00062	85 c0		 test	 eax, eax
  00064	75 03		 jne	 SHORT $LN17@Getcat
  00066	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
$LN17@Getcat:
  00069	50		 push	 eax
  0006a	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0006d	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00072	bb 01 00 00 00	 mov	 ebx, 1
  00077	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0007e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
  00084	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00086	33 f6		 xor	 esi, esi
$LN5@Getcat:
  00088	89 37		 mov	 DWORD PTR [edi], esi
  0008a	f6 c3 01	 test	 bl, 1
  0008d	74 08		 je	 SHORT $LN30@Getcat
  0008f	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  00092	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN30@Getcat:

; 1171 : 				_Locinfo(_Ploc->c_str()));
; 1172 : 		return (_X_NUMERIC);

  00097	b8 04 00 00 00	 mov	 eax, 4

; 1173 : 		}

  0009c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a6	59		 pop	 ecx
  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 08		 push	 8
  00002	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 553  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 554  :  #if _NO_LOCALES
; 555  : 	static _Wrap_facet<_Facet> _Wfac;
; 556  : 	return (*(_Facet *)&_Wfac);
; 557  : 
; 558  :  #else /* _NO_LOCALES */
; 559  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 560  : 		const locale::facet *_Psave =
; 561  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 562  : 
; 563  : 		size_t _Id = _Facet::id;

  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
  00038	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	89 5d f0	 mov	 DWORD PTR __Psave$5[ebp], ebx
  00048	85 ff		 test	 edi, edi
  0004a	75 2f		 jne	 SHORT $LN11@use_facet
  0004c	57		 push	 edi
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, edi ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
  0005b	75 10		 jne	 SHORT $LN12@use_facet
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00062	40		 inc	 eax
  00063	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN12@use_facet:
  0006d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00070	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00075	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN11@use_facet:

; 564  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0007e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00081	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00084	73 0c		 jae	 SHORT $LN20@use_facet
  00086	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00089	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  0008c	85 f6		 test	 esi, esi
  0008e	75 77		 jne	 SHORT $LN7@use_facet
  00090	eb 02		 jmp	 SHORT $LN28@use_facet
$LN20@use_facet:
  00092	33 f6		 xor	 esi, esi
$LN28@use_facet:
  00094	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00098	74 10		 je	 SHORT $LN17@use_facet
  0009a	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009f	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000a2	73 0a		 jae	 SHORT $LN29@use_facet
  000a4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a7	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN17@use_facet:

; 565  : 
; 566  : 		if (_Pf != 0)

  000aa	85 f6		 test	 esi, esi
  000ac	75 59		 jne	 SHORT $LN7@use_facet
$LN29@use_facet:

; 567  : 			;	// got facet from locale
; 568  : 		else if (_Psave != 0)

  000ae	85 db		 test	 ebx, ebx
  000b0	74 04		 je	 SHORT $LN4@use_facet

; 569  : 			_Pf = _Psave;	// lazy facet already allocated

  000b2	8b f3		 mov	 esi, ebx
  000b4	eb 51		 jmp	 SHORT $LN7@use_facet
$LN4@use_facet:

; 570  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000b6	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  000b9	8d 45 f0	 lea	 eax, DWORD PTR __Psave$5[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
  000c2	83 c4 08	 add	 esp, 8
  000c5	83 f8 ff	 cmp	 eax, -1
  000c8	75 24		 jne	 SHORT $LN6@use_facet

; 571  : 
; 572  :  #if _HAS_EXCEPTIONS
; 573  : 
; 574  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000ca	0f 57 c0	 xorps	 xmm0, xmm0
  000cd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7bad_cast@std@@6B@
  000d4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000d9	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  000dc	66 0f d6 45 e0	 movq	 QWORD PTR $T2[ebp+4], xmm0
  000e1	50		 push	 eax
  000e2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@use_facet:
$LN6@use_facet:

; 575  : 
; 576  :  #else /* _HAS_EXCEPTIONS */
; 577  : 			abort();	// lazy disallowed
; 578  :  #endif /* _HAS_EXCEPTIONS */
; 579  : 
; 580  : 		else
; 581  : 			{	// queue up lazy facet for destruction
; 582  : 			_Pf = _Psave;

  000ee	8b 75 f0	 mov	 esi, DWORD PTR __Psave$5[ebp]

; 583  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 584  : 
; 585  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 586  : 			_Pfmod->_Incref();

  000f1	8b ce		 mov	 ecx, esi
  000f3	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
  000f9	8b 16		 mov	 edx, DWORD PTR [esi]
  000fb	ff 52 04	 call	 DWORD PTR [edx+4]

; 587  : 
; 588  :  #if defined(_M_CEE)
; 589  : 			_Facet_Register_m(_Pfmod);
; 590  : 
; 591  :  #else /* defined(_M_CEE) */
; 592  : 			_Facet_Register(_Pfmod);

  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  00104	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 593  :  #endif /* defined(_M_CEE) */
; 594  : 			}
; 595  : 
; 596  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00107	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0010a	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0010f	8b c6		 mov	 eax, esi

; 597  : 	_END_LOCK()
; 598  :  #endif /* _NO_LOCALES */
; 599  : 	}	// end of use_facet body

  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN31@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 142  : 			return (_Ok);

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 143  : 			}

  00003	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 130  : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

  00025	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  0002a	84 c0		 test	 al, al
  0002c	75 07		 jne	 SHORT $LN2@sentry

; 133  : 				this->_Myostr._Osfx();

  0002e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00030	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN2@sentry:

; 134  : 
; 135  :  #else /* _HAS_EXCEPTIONS */
; 136  : 			this->_Myostr._Osfx();
; 137  :  #endif /* _HAS_EXCEPTIONS */
; 138  : 			}

  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00040	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00043	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  00047	85 c9		 test	 ecx, ecx
  00049	74 05		 je	 SHORT $LN5@sentry
  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@sentry:
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 123  : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi

; 122  : 			: _Sentry_base(_Ostr)

  0002a	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  0002d	89 37		 mov	 DWORD PTR [edi], esi
  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00038	85 c9		 test	 ecx, ecx
  0003a	74 05		 je	 SHORT $LN6@sentry
  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	ff 50 04	 call	 DWORD PTR [eax+4]
$LN6@sentry:

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00041	8b 06		 mov	 eax, DWORD PTR [esi]
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004d	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  00052	75 11		 jne	 SHORT $LN2@sentry
  00054	8b 4c 30 3c	 mov	 ecx, DWORD PTR [eax+esi+60]
  00058	85 c9		 test	 ecx, ecx
  0005a	74 09		 je	 SHORT $LN2@sentry
  0005c	3b ce		 cmp	 ecx, esi
  0005e	74 05		 je	 SHORT $LN2@sentry

; 125  : 				_Ostr.tie()->flush();

  00060	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN2@sentry:

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006a	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  0006f	0f 94 c0	 sete	 al
  00072	88 47 04	 mov	 BYTE PTR [edi+4], al

; 127  : 			}

  00075	8b c7		 mov	 eax, edi
  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 106  : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 107  : 			if (_Myostr.rdbuf() != 0)

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 05		 je	 SHORT $LN2@Sentry_bas

; 108  : 				_Myostr.rdbuf()->_Unlock();

  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 109  : 			}

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 100  : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   : 			: _Myostr(_Ostr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00006	56		 push	 esi

; 100  : 			{	// lock the stream buffer, if there

  00007	8b f1		 mov	 esi, ecx
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 101  : 			if (_Myostr.rdbuf() != 0)

  0000b	8b 02		 mov	 eax, DWORD PTR [edx]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  00014	85 c9		 test	 ecx, ecx
  00016	74 05		 je	 SHORT $LN8@Sentry_bas

; 102  : 				_Myostr.rdbuf()->_Lock();

  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	ff 50 04	 call	 DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 103  : 			}

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?failed@?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?failed@?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::failed, COMDAT
; _this$ = ecx

; 662  : 		return (_Failed);

  00000	8a 01		 mov	 al, BYTE PTR [ecx]

; 663  : 		}

  00002	c3		 ret	 0
?failed@?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::failed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??E?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::operator++, COMDAT
; _this$ = ecx

; 652  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 653  : 		}

  00002	c3		 ret	 0
??E?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??D?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::operator*, COMDAT
; _this$ = ecx

; 647  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 648  : 		}

  00002	c3		 ret	 0
??D?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??4?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_W@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 2
??4?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_W@Z PROC ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 637  : 		{	// store element and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 638  : 		if (_Strbuf == 0
; 639  : 			|| traits_type::eq_int_type(_Traits::eof(),

  00006	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00009	85 c9		 test	 ecx, ecx
  0000b	74 3b		 je	 SHORT $LN3@operator
  0000d	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00010	83 38 00	 cmp	 DWORD PTR [eax], 0
  00013	74 1e		 je	 SHORT $LN7@operator
  00015	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	85 c0		 test	 eax, eax
  0001c	7e 15		 jle	 SHORT $LN7@operator
  0001e	48		 dec	 eax
  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00024	8b 11		 mov	 edx, DWORD PTR [ecx]
  00026	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00029	89 01		 mov	 DWORD PTR [ecx], eax
  0002b	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0002e	66 89 02	 mov	 WORD PTR [edx], ax
  00031	eb 08		 jmp	 SHORT $LN28@operator
$LN7@operator:
  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00038	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN28@operator:
  0003b	0f b7 c0	 movzx	 eax, ax
  0003e	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00043	66 3b c8	 cmp	 cx, ax
  00046	75 03		 jne	 SHORT $LN29@operator
$LN3@operator:

; 640  : 				_Strbuf->sputc(_Right)))
; 641  : 			_Failed = true;

  00048	c6 06 01	 mov	 BYTE PTR [esi], 1
$LN29@operator:

; 642  : 		return (*this);

  0004b	8b c6		 mov	 eax, esi
  0004d	5e		 pop	 esi

; 643  : 		}

  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
??4?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_W@Z ENDP ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??0?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
_TEXT	SEGMENT
__Sb$ = 8						; size = 4
??0?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z PROC ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 628  : 		{	// construct from stream buffer _Sb

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 		: _Failed(false), _Strbuf(_Sb)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Sb$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 629  : 		}

  00009	8b c1		 mov	 eax, ecx
  0000b	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??0?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z ENDP ; std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN13@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN13@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ch$ = 24						; size = 2
__Count$ = 28						; size = 4
?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep, COMDAT

; 1583 : 		{	// put _Count * _Ch to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1584 : 		for (; 0 < _Count; --_Count, (void)++_Dest)

  00003	8b 55 14	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  00006	56		 push	 esi
  00007	8b 75 1c	 mov	 esi, DWORD PTR __Count$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	74 52		 je	 SHORT $LN3@Rep
  0000e	53		 push	 ebx
  0000f	57		 push	 edi
  00010	8b 7d 18	 mov	 edi, DWORD PTR __Ch$[ebp]
  00013	bb ff ff 00 00	 mov	 ebx, 65535		; 0000ffffH
$LL4@Rep:

; 1585 : 			*_Dest = _Ch;

  00018	85 d2		 test	 edx, edx
  0001a	74 39		 je	 SHORT $LN12@Rep
  0001c	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0001f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00022	74 1e		 je	 SHORT $LN16@Rep
  00024	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]
  00027	8b 01		 mov	 eax, DWORD PTR [ecx]
  00029	85 c0		 test	 eax, eax
  0002b	7e 15		 jle	 SHORT $LN16@Rep
  0002d	48		 dec	 eax
  0002e	89 01		 mov	 DWORD PTR [ecx], eax
  00030	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00038	89 01		 mov	 DWORD PTR [ecx], eax
  0003a	66 89 3a	 mov	 WORD PTR [edx], di
  0003d	0f b7 c7	 movzx	 eax, di
  00040	eb 0b		 jmp	 SHORT $LN17@Rep
$LN16@Rep:
  00042	8b 02		 mov	 eax, DWORD PTR [edx]
  00044	8b ca		 mov	 ecx, edx
  00046	57		 push	 edi
  00047	ff 50 0c	 call	 DWORD PTR [eax+12]
  0004a	0f b7 c0	 movzx	 eax, ax
$LN17@Rep:
  0004d	8b 55 14	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  00050	66 3b d8	 cmp	 bx, ax
  00053	75 04		 jne	 SHORT $LN2@Rep
$LN12@Rep:
  00055	c6 45 10 01	 mov	 BYTE PTR __Dest$[ebp], 1
$LN2@Rep:

; 1584 : 		for (; 0 < _Count; --_Count, (void)++_Dest)

  00059	83 ee 01	 sub	 esi, 1
  0005c	75 ba		 jne	 SHORT $LL4@Rep
  0005e	5f		 pop	 edi
  0005f	5b		 pop	 ebx
$LN3@Rep:

; 1586 : 		return (_Dest);

  00060	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00063	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00066	5e		 pop	 esi
  00067	89 08		 mov	 DWORD PTR [eax], ecx
  00069	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1587 : 		}

  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put, COMDAT

; 1575 : 		{	// put [_Ptr, _Ptr + _Count) to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1576 : 		for (; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)

  00003	8b 55 14	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  00006	56		 push	 esi
  00007	8b 75 1c	 mov	 esi, DWORD PTR __Count$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	74 57		 je	 SHORT $LN3@Put
  0000e	53		 push	 ebx
  0000f	57		 push	 edi
  00010	8b 7d 18	 mov	 edi, DWORD PTR __Ptr$[ebp]
$LL4@Put:

; 1577 : 			*_Dest = *_Ptr;

  00013	85 d2		 test	 edx, edx
  00015	74 40		 je	 SHORT $LN12@Put
  00017	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0001a	0f b7 1f	 movzx	 ebx, WORD PTR [edi]
  0001d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00020	74 1d		 je	 SHORT $LN16@Put
  00022	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]
  00025	8b 01		 mov	 eax, DWORD PTR [ecx]
  00027	85 c0		 test	 eax, eax
  00029	7e 14		 jle	 SHORT $LN16@Put
  0002b	48		 dec	 eax
  0002c	89 01		 mov	 DWORD PTR [ecx], eax
  0002e	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  00031	8b 11		 mov	 edx, DWORD PTR [ecx]
  00033	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00036	89 01		 mov	 DWORD PTR [ecx], eax
  00038	8b c3		 mov	 eax, ebx
  0003a	66 89 1a	 mov	 WORD PTR [edx], bx
  0003d	eb 0b		 jmp	 SHORT $LN17@Put
$LN16@Put:
  0003f	8b 02		 mov	 eax, DWORD PTR [edx]
  00041	8b ca		 mov	 ecx, edx
  00043	53		 push	 ebx
  00044	ff 50 0c	 call	 DWORD PTR [eax+12]
  00047	0f b7 c0	 movzx	 eax, ax
$LN17@Put:
  0004a	8b 55 14	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  0004d	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00052	66 3b c8	 cmp	 cx, ax
  00055	75 04		 jne	 SHORT $LN2@Put
$LN12@Put:
  00057	c6 45 10 01	 mov	 BYTE PTR __Dest$[ebp], 1
$LN2@Put:

; 1576 : 		for (; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)

  0005b	83 c7 02	 add	 edi, 2
  0005e	83 ee 01	 sub	 esi, 1
  00061	75 b0		 jne	 SHORT $LL4@Put
  00063	5f		 pop	 edi
  00064	5b		 pop	 ebx
$LN3@Put:

; 1578 : 		return (_Dest);

  00065	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00068	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0006b	5e		 pop	 esi
  0006c	89 08		 mov	 DWORD PTR [eax], ecx
  0006e	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1579 : 		}

  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z
_TEXT	SEGMENT
$T2 = -92						; size = 8
__Iosbase$GSCopy$1$ = -88				; size = 4
___$ReturnUdt$GSCopy$1$ = -84				; size = 4
$T3 = -80						; size = 8
$T4 = -80						; size = 8
$T5 = -80						; size = 8
$T6 = -80						; size = 8
$T7 = -80						; size = 8
$T8 = -80						; size = 8
$T9 = -80						; size = 8
__Dest$3$ = -72						; size = 4
__Ctype_fac$1$ = -72					; size = 4
__Kseparator$1$ = -68					; size = 4
__Count$GSCopy$2$ = -68					; size = 4
__Buf$GSCopy$1$ = -68					; size = 4
__Punct_fac$1$ = -68					; size = 4
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 2
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput, COMDAT

; 1515 : 		{	// put formatted integer to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 7d 24	 mov	 edi, DWORD PTR __Count$[ebp]
  0002e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00031	8b 75 18	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00034	8b 4d 20	 mov	 ecx, DWORD PTR __Buf$[ebp]
  00037	89 45 ac	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003a	89 75 a8	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], esi
  0003d	89 4d bc	 mov	 DWORD PTR __Buf$GSCopy$1$[ebp], ecx

; 1516 : 		_DEBUG_POINTER(_Dest);
; 1517 : 		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')

  00040	85 ff		 test	 edi, edi
  00042	74 11		 je	 SHORT $LN14@Iput
  00044	8a 01		 mov	 al, BYTE PTR [ecx]
  00046	3c 2b		 cmp	 al, 43			; 0000002bH
  00048	74 04		 je	 SHORT $LN13@Iput
  0004a	3c 2d		 cmp	 al, 45			; 0000002dH
  0004c	75 07		 jne	 SHORT $LN14@Iput
$LN13@Iput:
  0004e	bb 01 00 00 00	 mov	 ebx, 1
  00053	eb 02		 jmp	 SHORT $LN15@Iput
$LN14@Iput:
  00055	33 db		 xor	 ebx, ebx
$LN15@Iput:

; 1518 : 			? 1 : 0;
; 1519 : 		if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
; 1520 : 			&& _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1521 : 			&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))

  00057	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0005a	25 00 0e 00 00	 and	 eax, 3584		; 00000e00H
  0005f	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00064	75 1d		 jne	 SHORT $LN4@Iput
  00066	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  00069	3b c7		 cmp	 eax, edi
  0006b	77 16		 ja	 SHORT $LN4@Iput
  0006d	80 3c 19 30	 cmp	 BYTE PTR [ecx+ebx], 48	; 00000030H
  00071	75 10		 jne	 SHORT $LN4@Iput
  00073	8a 4c 19 01	 mov	 cl, BYTE PTR [ecx+ebx+1]
  00077	80 f9 78	 cmp	 cl, 120			; 00000078H
  0007a	74 05		 je	 SHORT $LN5@Iput
  0007c	80 f9 58	 cmp	 cl, 88			; 00000058H
  0007f	75 02		 jne	 SHORT $LN4@Iput
$LN5@Iput:

; 1522 : 			_Prefix += 2;

  00081	8b d8		 mov	 ebx, eax
$LN4@Iput:

; 1523 : 
; 1524 : 		const ctype<_Elem>& _Ctype_fac =

  00083	8d 45 b0	 lea	 eax, DWORD PTR $T9[ebp]
  00086	8b ce		 mov	 ecx, esi
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  0008e	50		 push	 eax
  0008f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00096	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 b8	 mov	 DWORD PTR __Ctype_fac$1$[ebp], eax
  000a1	8b 4d b4	 mov	 ecx, DWORD PTR $T9[ebp+4]
  000a4	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000ab	85 c9		 test	 ecx, ecx
  000ad	74 11		 je	 SHORT $LN27@Iput
  000af	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b1	ff 50 08	 call	 DWORD PTR [eax+8]
  000b4	85 c0		 test	 eax, eax
  000b6	74 08		 je	 SHORT $LN27@Iput
  000b8	8b 10		 mov	 edx, DWORD PTR [eax]
  000ba	8b c8		 mov	 ecx, eax
  000bc	6a 01		 push	 1
  000be	ff 12		 call	 DWORD PTR [edx]
$LN27@Iput:

; 1525 : 			_USE(_Iosbase.getloc(), ctype<_Elem>);
; 1526 : 		_Mystr _Groupstring(_Count, _Elem(0));	// reserve space

  000c0	33 c0		 xor	 eax, eax
  000c2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000c9	50		 push	 eax
  000ca	57		 push	 edi
  000cb	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  000ce	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR __Groupstring$[ebp+20], 7
  000d5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Groupstring$[ebp+16], 0
  000dc	66 89 45 d8	 mov	 WORD PTR __Groupstring$[ebp], ax
  000e0	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 1527 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

  000e5	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  000e9	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  000ec	8b 4d bc	 mov	 ecx, DWORD PTR __Buf$GSCopy$1$[ebp]
  000ef	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  000f3	8b 55 b8	 mov	 edx, DWORD PTR __Ctype_fac$1$[ebp]
  000f6	50		 push	 eax
  000f7	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  000fa	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00101	50		 push	 eax
  00102	8b 12		 mov	 edx, DWORD PTR [edx]
  00104	51		 push	 ecx
  00105	8b 4d b8	 mov	 ecx, DWORD PTR __Ctype_fac$1$[ebp]
  00108	ff 52 2c	 call	 DWORD PTR [edx+44]

; 1528 : 
; 1529 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

  0010b	8d 45 b0	 lea	 eax, DWORD PTR $T8[ebp]
  0010e	8b ce		 mov	 ecx, esi
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00116	50		 push	 eax
  00117	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0011b	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<wchar_t> >
  00120	8b f0		 mov	 esi, eax
  00122	83 c4 04	 add	 esp, 4
  00125	89 75 bc	 mov	 DWORD PTR __Punct_fac$1$[ebp], esi
  00128	8b 4d b4	 mov	 ecx, DWORD PTR $T8[ebp+4]
  0012b	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0012f	85 c9		 test	 ecx, ecx
  00131	74 11		 je	 SHORT $LN159@Iput
  00133	8b 01		 mov	 eax, DWORD PTR [ecx]
  00135	ff 50 08	 call	 DWORD PTR [eax+8]
  00138	85 c0		 test	 eax, eax
  0013a	74 08		 je	 SHORT $LN159@Iput
  0013c	8b 10		 mov	 edx, DWORD PTR [eax]
  0013e	8b c8		 mov	 ecx, eax
  00140	6a 01		 push	 1
  00142	ff 12		 call	 DWORD PTR [edx]
$LN159@Iput:

; 1530 : 		const string _Grouping = _Punct_fac.grouping();

  00144	8d 45 c0	 lea	 eax, DWORD PTR __Grouping$[ebp]
  00147	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0014b	50		 push	 eax
  0014c	8b ce		 mov	 ecx, esi
  0014e	e8 00 00 00 00	 call	 ?grouping@?$numpunct@_W@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<wchar_t>::grouping

; 1531 : 		const char *_Pg = &_Grouping[0];

  00153	83 7d d4 10	 cmp	 DWORD PTR __Grouping$[ebp+20], 16 ; 00000010H
  00157	8d 75 c0	 lea	 esi, DWORD PTR __Grouping$[ebp]
  0015a	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0015e	0f 43 75 c0	 cmovae	 esi, DWORD PTR __Grouping$[ebp]

; 1532 : 		if (*_Pg != CHAR_MAX && '\0' < *_Pg)

  00162	8a 06		 mov	 al, BYTE PTR [esi]
  00164	3c 7f		 cmp	 al, 127			; 0000007fH
  00166	74 4b		 je	 SHORT $LN3@Iput
  00168	84 c0		 test	 al, al
  0016a	7e 47		 jle	 SHORT $LN3@Iput

; 1533 : 			{	// grouping specified, add thousands separators
; 1534 : 			const _Elem _Kseparator = _Punct_fac.thousands_sep();

  0016c	8b 4d bc	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
  0016f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00171	ff 50 10	 call	 DWORD PTR [eax+16]

; 1535 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1536 : 				&& (size_t)*_Pg < _Count - _Prefix)

  00174	80 3e 7f	 cmp	 BYTE PTR [esi], 127	; 0000007fH
  00177	0f b7 d0	 movzx	 edx, ax
  0017a	89 55 bc	 mov	 DWORD PTR __Kseparator$1$[ebp], edx
  0017d	74 34		 je	 SHORT $LN3@Iput
  0017f	90		 npad	 1
$LL2@Iput:
  00180	8a 06		 mov	 al, BYTE PTR [esi]
  00182	84 c0		 test	 al, al
  00184	7e 2d		 jle	 SHORT $LN3@Iput
  00186	0f be c8	 movsx	 ecx, al
  00189	8b c7		 mov	 eax, edi
  0018b	2b c3		 sub	 eax, ebx
  0018d	3b c8		 cmp	 ecx, eax
  0018f	73 22		 jae	 SHORT $LN3@Iput

; 1537 : 				{	// insert thousands separator
; 1538 : 				_Count -= *_Pg;
; 1539 : 				_Groupstring.insert(_Count, 1, _Kseparator);

  00191	52		 push	 edx
  00192	2b f9		 sub	 edi, ecx
  00194	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00197	6a 01		 push	 1
  00199	57		 push	 edi
  0019a	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
  0019f	80 7e 01 00	 cmp	 BYTE PTR [esi+1], 0

; 1540 : 				if ('\0' < _Pg[1])

  001a3	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  001a6	8b 55 bc	 mov	 edx, DWORD PTR __Kseparator$1$[ebp]
  001a9	0f 4e c6	 cmovle	 eax, esi
  001ac	8b f0		 mov	 esi, eax
  001ae	80 3e 7f	 cmp	 BYTE PTR [esi], 127	; 0000007fH
  001b1	75 cd		 jne	 SHORT $LL2@Iput
$LN3@Iput:

; 1541 : 					++_Pg;	// not last group, advance
; 1542 : 				}
; 1543 : 			}
; 1544 : 
; 1545 : 		_Count = _Groupstring.size();
; 1546 : 		size_t _Fillcount = _Iosbase.width() <= 0
; 1547 : 			|| (size_t)_Iosbase.width() <= _Count

  001b3	8b 75 a8	 mov	 esi, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  001b6	8b 45 e8	 mov	 eax, DWORD PTR __Groupstring$[ebp+16]
  001b9	89 45 bc	 mov	 DWORD PTR __Count$GSCopy$2$[ebp], eax
  001bc	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  001c0	7c 13		 jl	 SHORT $LN16@Iput
  001c2	7f 06		 jg	 SHORT $LN474@Iput
  001c4	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  001c8	76 0b		 jbe	 SHORT $LN16@Iput
$LN474@Iput:
  001ca	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  001cd	3b f8		 cmp	 edi, eax
  001cf	76 04		 jbe	 SHORT $LN16@Iput
  001d1	2b f8		 sub	 edi, eax
  001d3	eb 02		 jmp	 SHORT $LN17@Iput
$LN16@Iput:
  001d5	33 ff		 xor	 edi, edi
$LN17@Iput:

; 1548 : 				? 0 : (size_t)_Iosbase.width() - _Count;
; 1549 : 
; 1550 : 		ios_base::fmtflags _Adjustfield =
; 1551 : 			_Iosbase.flags() & ios_base::adjustfield;

  001d7	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001da	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  001df	83 f8 40	 cmp	 eax, 64			; 00000040H

; 1552 : 		if (_Adjustfield != ios_base::left
; 1553 : 			&& _Adjustfield != ios_base::internal)

  001e2	0f 84 97 00 00
	00		 je	 $LN10@Iput
  001e8	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  001ed	74 48		 je	 SHORT $LN473@Iput

; 1554 : 			{	// put leading fill
; 1555 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

  001ef	57		 push	 edi
  001f0	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  001f3	8d 45 b0	 lea	 eax, DWORD PTR $T7[ebp]
  001f6	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  001f9	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  001fc	50		 push	 eax
  001fd	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00200	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  00205	8b d0		 mov	 edx, eax

; 1556 : 			_Fillcount = 0;
; 1557 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00207	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  0020a	33 ff		 xor	 edi, edi
  0020c	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  00210	53		 push	 ebx
  00211	0f 43 4d d8	 cmovae	 ecx, DWORD PTR __Groupstring$[ebp]
  00215	8b 02		 mov	 eax, DWORD PTR [edx]
  00217	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  0021a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0021d	51		 push	 ecx
  0021e	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00221	8d 45 b0	 lea	 eax, DWORD PTR $T6[ebp]
  00224	ff 72 04	 push	 DWORD PTR [edx+4]
  00227	ff 32		 push	 DWORD PTR [edx]
  00229	50		 push	 eax
  0022a	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0022d	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
  00232	83 c4 30	 add	 esp, 48			; 00000030H
  00235	eb 6a		 jmp	 SHORT $LN478@Iput
$LN473@Iput:

; 1558 : 			}
; 1559 : 		else if (_Adjustfield == ios_base::internal)
; 1560 : 			{	// put internal fill
; 1561 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00237	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  0023b	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0023e	53		 push	 ebx
  0023f	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  00243	50		 push	 eax
  00244	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  00247	8d 45 b0	 lea	 eax, DWORD PTR $T5[ebp]
  0024a	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0024d	50		 push	 eax
  0024e	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00251	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
  00256	8b c8		 mov	 ecx, eax

; 1562 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

  00258	57		 push	 edi
  00259	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  0025c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0025e	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00261	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00264	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00267	8d 45 b0	 lea	 eax, DWORD PTR $T4[ebp]
  0026a	ff 71 04	 push	 DWORD PTR [ecx+4]
  0026d	ff 31		 push	 DWORD PTR [ecx]
  0026f	50		 push	 eax
  00270	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00273	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  00278	83 c4 30	 add	 esp, 48			; 00000030H

; 1563 : 			_Fillcount = 0;

  0027b	33 ff		 xor	 edi, edi

; 1564 : 			}
; 1565 : 		else

  0027d	eb 22		 jmp	 SHORT $LN478@Iput
$LN10@Iput:

; 1566 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  0027f	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  00283	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  00286	53		 push	 ebx
  00287	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  0028b	50		 push	 eax
  0028c	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  0028f	8d 45 b0	 lea	 eax, DWORD PTR $T3[ebp]
  00292	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00295	50		 push	 eax
  00296	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00299	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
  0029e	83 c4 18	 add	 esp, 24			; 00000018H
$LN478@Iput:
  002a1	8b 10		 mov	 edx, DWORD PTR [eax]

; 1567 : 
; 1568 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  002a3	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  002a7	8b 4d bc	 mov	 ecx, DWORD PTR __Count$GSCopy$2$[ebp]
  002aa	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  002ad	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002b0	89 45 b8	 mov	 DWORD PTR __Dest$3$[ebp], eax
  002b3	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  002b6	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  002b9	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  002bd	2b cb		 sub	 ecx, ebx
  002bf	51		 push	 ecx
  002c0	8d 04 58	 lea	 eax, DWORD PTR [eax+ebx*2]
  002c3	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  002c6	50		 push	 eax
  002c7	ff 75 b8	 push	 DWORD PTR __Dest$3$[ebp]
  002ca	8d 45 a4	 lea	 eax, DWORD PTR $T2[ebp]
  002cd	52		 push	 edx
  002ce	50		 push	 eax
  002cf	53		 push	 ebx
  002d0	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put

; 1569 : 		_Iosbase.width(0);
; 1570 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

  002d5	57		 push	 edi
  002d6	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  002d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  002db	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  002de	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002e1	50		 push	 eax
  002e2	51		 push	 ecx
  002e3	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  002ea	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  002f1	8b 75 ac	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  002f4	56		 push	 esi
  002f5	53		 push	 ebx
  002f6	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  002f9	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  002fe	8b 45 d4	 mov	 eax, DWORD PTR __Grouping$[ebp+20]
  00301	83 c4 30	 add	 esp, 48			; 00000030H
  00304	83 f8 10	 cmp	 eax, 16			; 00000010H
  00307	72 0d		 jb	 SHORT $LN272@Iput
  00309	40		 inc	 eax
  0030a	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  0030d	50		 push	 eax
  0030e	ff 75 c0	 push	 DWORD PTR __Grouping$[ebp]
  00311	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN272@Iput:
  00316	8b 4d ec	 mov	 ecx, DWORD PTR __Groupstring$[ebp+20]
  00319	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+20], 15 ; 0000000fH
  00320	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+16], 0
  00327	c6 45 c0 00	 mov	 BYTE PTR __Grouping$[ebp], 0
  0032b	83 f9 08	 cmp	 ecx, 8
  0032e	72 0d		 jb	 SHORT $LN475@Iput
  00330	41		 inc	 ecx
  00331	51		 push	 ecx
  00332	ff 75 d8	 push	 DWORD PTR __Groupstring$[ebp]
  00335	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00338	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN475@Iput:
  0033d	8b c6		 mov	 eax, esi

; 1571 : 		}

  0033f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00342	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00349	59		 pop	 ecx
  0034a	5f		 pop	 edi
  0034b	5e		 pop	 esi
  0034c	5b		 pop	 ebx
  0034d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00350	33 cd		 xor	 ecx, ebp
  00352	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00357	8b e5		 mov	 esp, ebp
  00359	5d		 pop	 ebp
  0035a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T9[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$4:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$1:
  0000e	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$2:
  00016	8d 4d b0	 lea	 ecx, DWORD PTR $T8[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$33:
  0001e	e8 00 00 00 00	 call	 ___std_terminate
  00023	c3		 ret	 0
__unwindfunclet$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z$3:
  00024	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00040	33 c8		 xor	 ecx, eax
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z
  0004c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 4
__Flags$ = 20						; size = 4
?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ifmt, COMDAT

; 1487 : 		{	// generate sprintf format for integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1488 : 		char *_Ptr = _Fmt;
; 1489 : 		*_Ptr++ = '%';
; 1490 : 
; 1491 : 		if (_Flags & ios_base::showpos)

  00003	8b 4d 14	 mov	 ecx, DWORD PTR __Flags$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Fmt$[ebp]
  0000a	57		 push	 edi
  0000b	c6 06 25	 mov	 BYTE PTR [esi], 37	; 00000025H
  0000e	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00011	f6 c1 20	 test	 cl, 32			; 00000020H
  00014	74 04		 je	 SHORT $LN2@Ifmt

; 1492 : 			*_Ptr++ = '+';

  00016	c6 00 2b	 mov	 BYTE PTR [eax], 43	; 0000002bH
  00019	40		 inc	 eax
$LN2@Ifmt:

; 1493 : 		if (_Flags & ios_base::showbase)

  0001a	f6 c1 08	 test	 cl, 8
  0001d	74 04		 je	 SHORT $LN3@Ifmt

; 1494 : 			*_Ptr++ = '#';

  0001f	c6 00 23	 mov	 BYTE PTR [eax], 35	; 00000023H
  00022	40		 inc	 eax
$LN3@Ifmt:

; 1495 : 		if (_Spec[0] != 'L')

  00023	8b 7d 10	 mov	 edi, DWORD PTR __Spec$[ebp]
  00026	8a 17		 mov	 dl, BYTE PTR [edi]
  00028	80 fa 4c	 cmp	 dl, 76			; 0000004cH
  0002b	74 04		 je	 SHORT $LN4@Ifmt

; 1496 : 			*_Ptr++ = _Spec[0];	// qualifier

  0002d	88 10		 mov	 BYTE PTR [eax], dl

; 1497 : 		else

  0002f	eb 0b		 jmp	 SHORT $LN5@Ifmt
$LN4@Ifmt:

; 1498 : 
; 1499 : 			{	/* change L to I64 */
; 1500 : 			*_Ptr++ = 'I';

  00031	66 c7 00 49 36	 mov	 WORD PTR [eax], 13897	; 00003649H

; 1501 : 			*_Ptr++ = '6';

  00036	83 c0 02	 add	 eax, 2

; 1502 : 			*_Ptr++ = '4';

  00039	c6 00 34	 mov	 BYTE PTR [eax], 52	; 00000034H
$LN5@Ifmt:

; 1503 : 			}
; 1504 : 
; 1505 : 		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

  0003c	8b d1		 mov	 edx, ecx
  0003e	81 e2 00 0e 00
	00		 and	 edx, 3584		; 00000e00H
  00044	81 fa 00 04 00
	00		 cmp	 edx, 1024		; 00000400H

; 1506 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'

  0004a	75 0f		 jne	 SHORT $LN9@Ifmt
  0004c	b1 6f		 mov	 cl, 111			; 0000006fH
  0004e	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 1507 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1508 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';
; 1509 : 		*_Ptr = '\0';

  00051	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 1510 : 		return (_Fmt);

  00055	8b c6		 mov	 eax, esi
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi

; 1511 : 		}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN9@Ifmt:
  0005b	81 fa 00 08 00
	00		 cmp	 edx, 2048		; 00000800H

; 1506 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'

  00061	74 10		 je	 SHORT $LN7@Ifmt
  00063	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00066	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 1507 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1508 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';
; 1509 : 		*_Ptr = '\0';

  00069	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 1510 : 		return (_Fmt);

  0006d	8b c6		 mov	 eax, esi
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi

; 1511 : 		}

  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
$LN7@Ifmt:

; 1506 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'

  00073	c0 e1 03	 shl	 cl, 3
  00076	f6 d1		 not	 cl
  00078	80 e1 20	 and	 cl, 32			; 00000020H
  0007b	80 c9 58	 or	 cl, 88			; 00000058H
  0007e	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 1507 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1508 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';
; 1509 : 		*_Ptr = '\0';

  00081	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 1510 : 		return (_Fmt);

  00085	8b c6		 mov	 eax, esi
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 1511 : 		}

  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ifmt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z
_TEXT	SEGMENT
$T2 = -104						; size = 8
__Iosbase$GSCopy$1$ = -100				; size = 4
___$ReturnUdt$GSCopy$1$ = -96				; size = 4
__Count$GSCopy$2$ = -92					; size = 4
__Eoff$1$ = -92						; size = 4
__Buf$GSCopy$1$ = -88					; size = 4
__Punct_fac$1$ = -88					; size = 4
$T3 = -84						; size = 8
$T4 = -84						; size = 8
$T5 = -84						; size = 8
$T6 = -84						; size = 8
$T7 = -84						; size = 8
$T8 = -84						; size = 8
$T9 = -84						; size = 8
__Kseparator$1$ = -76					; size = 4
__Ctype_fac$1$ = -76					; size = 4
__Dp$ = -72						; size = 2
__Dest$3$ = -68						; size = 4
__Count$GSCopy$1$ = -68					; size = 4
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 2
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Fput, COMDAT

; 1413 : 		{	// put formatted floating-point to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 4d 24	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00031	8b 75 18	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00034	8b 7d 20	 mov	 edi, DWORD PTR __Buf$[ebp]
  00037	89 45 a0	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003a	89 75 9c	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], esi
  0003d	89 7d a8	 mov	 DWORD PTR __Buf$GSCopy$1$[ebp], edi
  00040	89 4d bc	 mov	 DWORD PTR __Count$GSCopy$1$[ebp], ecx

; 1414 : 		_DEBUG_POINTER(_Dest);
; 1415 : 		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')

  00043	85 c9		 test	 ecx, ecx
  00045	74 11		 je	 SHORT $LN16@Fput
  00047	8a 07		 mov	 al, BYTE PTR [edi]
  00049	3c 2b		 cmp	 al, 43			; 0000002bH
  0004b	74 04		 je	 SHORT $LN15@Fput
  0004d	3c 2d		 cmp	 al, 45			; 0000002dH
  0004f	75 07		 jne	 SHORT $LN16@Fput
$LN15@Fput:
  00051	bb 01 00 00 00	 mov	 ebx, 1
  00056	eb 02		 jmp	 SHORT $LN17@Fput
$LN16@Fput:
  00058	33 db		 xor	 ebx, ebx
$LN17@Fput:

; 1416 : 			? 1 : 0;
; 1417 : 
; 1418 : 		const char *_Exps;
; 1419 : 		if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)

  0005a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0005d	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  00062	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  00067	74 07		 je	 SHORT $LN4@Fput

; 1420 : 			_Exps = "eE";

  00069	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MDKMJEGG@eE?$AA@

; 1421 : 		else

  0006e	eb 22		 jmp	 SHORT $LN6@Fput
$LN4@Fput:

; 1422 : 			{	// correct for hexadecimal floating-point
; 1423 : 			_Exps = "pP";
; 1424 : 			if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1425 : 				&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))

  00070	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  00073	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02OOPEBDOJ@pP?$AA@
  00078	3b c1		 cmp	 eax, ecx
  0007a	77 16		 ja	 SHORT $LN6@Fput
  0007c	80 3c 1f 30	 cmp	 BYTE PTR [edi+ebx], 48	; 00000030H
  00080	75 10		 jne	 SHORT $LN6@Fput
  00082	8a 4c 1f 01	 mov	 cl, BYTE PTR [edi+ebx+1]
  00086	80 f9 78	 cmp	 cl, 120			; 00000078H
  00089	74 05		 je	 SHORT $LN7@Fput
  0008b	80 f9 58	 cmp	 cl, 88			; 00000058H
  0008e	75 02		 jne	 SHORT $LN6@Fput
$LN7@Fput:

; 1426 : 				_Prefix += 2;

  00090	8b d8		 mov	 ebx, eax
$LN6@Fput:

; 1427 : 			}
; 1428 : 		const size_t _Eoff =
; 1429 : 			_CSTD strcspn(&_Buf[0], _Exps);	// find exponent

  00092	52		 push	 edx
  00093	57		 push	 edi
  00094	e8 00 00 00 00	 call	 _strcspn
  00099	89 45 a4	 mov	 DWORD PTR __Eoff$1$[ebp], eax

; 1430 : 		char _Dp[2] = {"."};

  0009c	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  000a1	66 89 45 b8	 mov	 WORD PTR __Dp$[ebp], ax

; 1431 : 		_Dp[0] = _CSTD localeconv()->decimal_point[0];

  000a5	e8 00 00 00 00	 call	 _localeconv
  000aa	8b 00		 mov	 eax, DWORD PTR [eax]
  000ac	8a 00		 mov	 al, BYTE PTR [eax]
  000ae	88 45 b8	 mov	 BYTE PTR __Dp$[ebp], al

; 1432 : 		const size_t _Poff =
; 1433 : 			_CSTD strcspn(&_Buf[0], &_Dp[0]);	// find decimal point

  000b1	8d 45 b8	 lea	 eax, DWORD PTR __Dp$[ebp]
  000b4	50		 push	 eax
  000b5	57		 push	 edi
  000b6	e8 00 00 00 00	 call	 _strcspn
  000bb	83 c4 10	 add	 esp, 16			; 00000010H
  000be	8b f8		 mov	 edi, eax

; 1434 : 
; 1435 : 		const ctype<_Elem>& _Ctype_fac =

  000c0	8d 45 ac	 lea	 eax, DWORD PTR $T9[ebp]
  000c3	8b ce		 mov	 ecx, esi
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  000cb	50		 push	 eax
  000cc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000d3	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  000d8	83 c4 04	 add	 esp, 4
  000db	89 45 b4	 mov	 DWORD PTR __Ctype_fac$1$[ebp], eax
  000de	8b 4d b0	 mov	 ecx, DWORD PTR $T9[ebp+4]
  000e1	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000e8	85 c9		 test	 ecx, ecx
  000ea	74 11		 je	 SHORT $LN29@Fput
  000ec	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ee	ff 50 08	 call	 DWORD PTR [eax+8]
  000f1	8b c8		 mov	 ecx, eax
  000f3	85 c9		 test	 ecx, ecx
  000f5	74 06		 je	 SHORT $LN29@Fput
  000f7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f9	6a 01		 push	 1
  000fb	ff 10		 call	 DWORD PTR [eax]
$LN29@Fput:

; 1436 : 			_USE(_Iosbase.getloc(), ctype<_Elem>);
; 1437 : 		_Mystr _Groupstring(_Count, _Elem(0));	// reserve space

  000fd	33 c0		 xor	 eax, eax
  000ff	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00106	50		 push	 eax
  00107	ff 75 bc	 push	 DWORD PTR __Count$GSCopy$1$[ebp]
  0010a	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  0010d	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR __Groupstring$[ebp+20], 7
  00114	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Groupstring$[ebp+16], 0
  0011b	66 89 45 d8	 mov	 WORD PTR __Groupstring$[ebp], ax
  0011f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 1438 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

  00124	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  00128	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0012b	8b 55 b4	 mov	 edx, DWORD PTR __Ctype_fac$1$[ebp]
  0012e	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  00132	8b 4d a8	 mov	 ecx, DWORD PTR __Buf$GSCopy$1$[ebp]
  00135	50		 push	 eax
  00136	8b 45 bc	 mov	 eax, DWORD PTR __Count$GSCopy$1$[ebp]
  00139	8b 12		 mov	 edx, DWORD PTR [edx]
  0013b	03 c1		 add	 eax, ecx
  0013d	50		 push	 eax
  0013e	51		 push	 ecx
  0013f	8b 4d b4	 mov	 ecx, DWORD PTR __Ctype_fac$1$[ebp]
  00142	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00149	ff 52 2c	 call	 DWORD PTR [edx+44]

; 1439 : 
; 1440 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

  0014c	8d 45 ac	 lea	 eax, DWORD PTR $T8[ebp]
  0014f	8b ce		 mov	 ecx, esi
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00157	50		 push	 eax
  00158	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0015c	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<wchar_t> >
  00161	8b f0		 mov	 esi, eax
  00163	83 c4 04	 add	 esp, 4
  00166	89 75 a8	 mov	 DWORD PTR __Punct_fac$1$[ebp], esi
  00169	8b 4d b0	 mov	 ecx, DWORD PTR $T8[ebp+4]
  0016c	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00170	85 c9		 test	 ecx, ecx
  00172	74 11		 je	 SHORT $LN161@Fput
  00174	8b 01		 mov	 eax, DWORD PTR [ecx]
  00176	ff 50 08	 call	 DWORD PTR [eax+8]
  00179	8b c8		 mov	 ecx, eax
  0017b	85 c9		 test	 ecx, ecx
  0017d	74 06		 je	 SHORT $LN161@Fput
  0017f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00181	6a 01		 push	 1
  00183	ff 10		 call	 DWORD PTR [eax]
$LN161@Fput:

; 1441 : 		const string _Grouping = _Punct_fac.grouping();

  00185	8d 45 c0	 lea	 eax, DWORD PTR __Grouping$[ebp]
  00188	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0018c	50		 push	 eax
  0018d	8b ce		 mov	 ecx, esi
  0018f	e8 00 00 00 00	 call	 ?grouping@?$numpunct@_W@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<wchar_t>::grouping

; 1442 : 		const _Elem _Kseparator = _Punct_fac.thousands_sep();

  00194	8b 06		 mov	 eax, DWORD PTR [esi]
  00196	8b ce		 mov	 ecx, esi
  00198	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0019c	ff 50 10	 call	 DWORD PTR [eax+16]

; 1443 : 
; 1444 : 		if (_Poff != _Count)

  0019f	8b 75 bc	 mov	 esi, DWORD PTR __Count$GSCopy$1$[ebp]
  001a2	0f b7 d0	 movzx	 edx, ax
  001a5	89 55 b4	 mov	 DWORD PTR __Kseparator$1$[ebp], edx
  001a8	3b fe		 cmp	 edi, esi
  001aa	74 1f		 je	 SHORT $LN498@Fput

; 1445 : 			_Groupstring[_Poff] = _Punct_fac.decimal_point();

  001ac	8b 4d a8	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
  001af	8b 01		 mov	 eax, DWORD PTR [ecx]
  001b1	ff 50 0c	 call	 DWORD PTR [eax+12]
  001b4	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  001b8	8b 55 b4	 mov	 edx, DWORD PTR __Kseparator$1$[ebp]
  001bb	0f b7 c8	 movzx	 ecx, ax
  001be	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  001c1	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]

; 1446 : 
; 1447 : 		size_t _Off = _Poff == _Count ? _Eoff : _Poff;

  001c5	3b fe		 cmp	 edi, esi
  001c7	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN498@Fput:
  001cb	0f 44 7d a4	 cmove	 edi, DWORD PTR __Eoff$1$[ebp]

; 1448 : 		const char *_Pg = &_Grouping[0];

  001cf	8d 75 c0	 lea	 esi, DWORD PTR __Grouping$[ebp]
  001d2	83 7d d4 10	 cmp	 DWORD PTR __Grouping$[ebp+20], 16 ; 00000010H
  001d6	0f 43 75 c0	 cmovae	 esi, DWORD PTR __Grouping$[ebp]

; 1449 : 		while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1450 : 			&& (size_t)*_Pg < _Off - _Prefix)

  001da	80 3e 7f	 cmp	 BYTE PTR [esi], 127	; 0000007fH
  001dd	74 34		 je	 SHORT $LN3@Fput
  001df	90		 npad	 1
$LL2@Fput:
  001e0	8a 06		 mov	 al, BYTE PTR [esi]
  001e2	84 c0		 test	 al, al
  001e4	7e 2d		 jle	 SHORT $LN3@Fput
  001e6	0f be c8	 movsx	 ecx, al
  001e9	8b c7		 mov	 eax, edi
  001eb	2b c3		 sub	 eax, ebx
  001ed	3b c8		 cmp	 ecx, eax
  001ef	73 22		 jae	 SHORT $LN3@Fput

; 1451 : 			{	// add thousands separator
; 1452 : 			_Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);

  001f1	52		 push	 edx
  001f2	2b f9		 sub	 edi, ecx
  001f4	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  001f7	6a 01		 push	 1
  001f9	57		 push	 edi
  001fa	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
  001ff	80 7e 01 00	 cmp	 BYTE PTR [esi+1], 0

; 1453 : 			if ('\0' < _Pg[1])

  00203	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00206	8b 55 b4	 mov	 edx, DWORD PTR __Kseparator$1$[ebp]
  00209	0f 4e c6	 cmovle	 eax, esi
  0020c	8b f0		 mov	 esi, eax
  0020e	80 3e 7f	 cmp	 BYTE PTR [esi], 127	; 0000007fH
  00211	75 cd		 jne	 SHORT $LL2@Fput
$LN3@Fput:

; 1454 : 				++_Pg;	// not last group, advance
; 1455 : 			}
; 1456 : 
; 1457 : 		_Count = _Groupstring.size();
; 1458 : 		size_t _Fillcount = _Iosbase.width() <= 0
; 1459 : 			|| (size_t)_Iosbase.width() <= _Count

  00213	8b 7d 9c	 mov	 edi, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00216	8b 45 e8	 mov	 eax, DWORD PTR __Groupstring$[ebp+16]
  00219	89 45 a4	 mov	 DWORD PTR __Count$GSCopy$2$[ebp], eax
  0021c	83 7f 24 00	 cmp	 DWORD PTR [edi+36], 0
  00220	7c 13		 jl	 SHORT $LN18@Fput
  00222	7f 06		 jg	 SHORT $LN494@Fput
  00224	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00228	76 0b		 jbe	 SHORT $LN18@Fput
$LN494@Fput:
  0022a	8b 77 20	 mov	 esi, DWORD PTR [edi+32]
  0022d	3b f0		 cmp	 esi, eax
  0022f	76 04		 jbe	 SHORT $LN18@Fput
  00231	2b f0		 sub	 esi, eax
  00233	eb 02		 jmp	 SHORT $LN19@Fput
$LN18@Fput:
  00235	33 f6		 xor	 esi, esi
$LN19@Fput:

; 1460 : 				? 0 : (size_t)_Iosbase.width() - _Count;
; 1461 : 
; 1462 : 		ios_base::fmtflags _Adjustfield =
; 1463 : 			_Iosbase.flags() & ios_base::adjustfield;

  00237	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0023a	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  0023f	83 f8 40	 cmp	 eax, 64			; 00000040H

; 1464 : 		if (_Adjustfield != ios_base::left
; 1465 : 			&& _Adjustfield != ios_base::internal)

  00242	0f 84 97 00 00
	00		 je	 $LN12@Fput
  00248	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0024d	74 48		 je	 SHORT $LN493@Fput

; 1466 : 			{	// put leading fill
; 1467 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

  0024f	56		 push	 esi
  00250	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  00253	8d 45 ac	 lea	 eax, DWORD PTR $T7[ebp]
  00256	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  00259	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0025c	50		 push	 eax
  0025d	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00260	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  00265	8b c8		 mov	 ecx, eax

; 1468 : 			_Fillcount = 0;

  00267	33 f6		 xor	 esi, esi

; 1469 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00269	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  0026d	53		 push	 ebx
  0026e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00270	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00273	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00276	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00279	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0027c	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  00280	50		 push	 eax
  00281	ff 71 04	 push	 DWORD PTR [ecx+4]
  00284	8d 45 ac	 lea	 eax, DWORD PTR $T6[ebp]
  00287	ff 31		 push	 DWORD PTR [ecx]
  00289	50		 push	 eax
  0028a	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0028d	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
  00292	83 c4 30	 add	 esp, 48			; 00000030H
  00295	eb 6a		 jmp	 SHORT $LN499@Fput
$LN493@Fput:

; 1470 : 			}
; 1471 : 		else if (_Adjustfield == ios_base::internal)
; 1472 : 			{	// put internal fill
; 1473 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00297	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  0029b	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0029e	53		 push	 ebx
  0029f	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  002a3	50		 push	 eax
  002a4	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  002a7	8d 45 ac	 lea	 eax, DWORD PTR $T5[ebp]
  002aa	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  002ad	50		 push	 eax
  002ae	ff 75 08	 push	 DWORD PTR _this$[ebp]
  002b1	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
  002b6	8b c8		 mov	 ecx, eax

; 1474 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

  002b8	56		 push	 esi
  002b9	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  002bc	8b 01		 mov	 eax, DWORD PTR [ecx]
  002be	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  002c1	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  002c4	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  002c7	8d 45 ac	 lea	 eax, DWORD PTR $T4[ebp]
  002ca	ff 71 04	 push	 DWORD PTR [ecx+4]
  002cd	ff 31		 push	 DWORD PTR [ecx]
  002cf	50		 push	 eax
  002d0	ff 75 08	 push	 DWORD PTR _this$[ebp]
  002d3	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  002d8	83 c4 30	 add	 esp, 48			; 00000030H

; 1475 : 			_Fillcount = 0;

  002db	33 f6		 xor	 esi, esi

; 1476 : 			}
; 1477 : 		else

  002dd	eb 22		 jmp	 SHORT $LN499@Fput
$LN12@Fput:

; 1478 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  002df	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  002e3	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  002e6	53		 push	 ebx
  002e7	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  002eb	50		 push	 eax
  002ec	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  002ef	8d 45 ac	 lea	 eax, DWORD PTR $T3[ebp]
  002f2	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  002f5	50		 push	 eax
  002f6	ff 75 08	 push	 DWORD PTR _this$[ebp]
  002f9	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put
  002fe	83 c4 18	 add	 esp, 24			; 00000018H
$LN499@Fput:
  00301	8b 10		 mov	 edx, DWORD PTR [eax]

; 1479 : 
; 1480 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  00303	83 7d ec 08	 cmp	 DWORD PTR __Groupstring$[ebp+20], 8
  00307	8b 4d a4	 mov	 ecx, DWORD PTR __Count$GSCopy$2$[ebp]
  0030a	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  0030d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00310	89 45 bc	 mov	 DWORD PTR __Dest$3$[ebp], eax
  00313	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00316	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  00319	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  0031d	2b cb		 sub	 ecx, ebx
  0031f	51		 push	 ecx
  00320	8d 04 58	 lea	 eax, DWORD PTR [eax+ebx*2]
  00323	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00326	50		 push	 eax
  00327	ff 75 bc	 push	 DWORD PTR __Dest$3$[ebp]
  0032a	8d 45 98	 lea	 eax, DWORD PTR $T2[ebp]
  0032d	52		 push	 edx
  0032e	50		 push	 eax
  0032f	53		 push	 ebx
  00330	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put

; 1481 : 		_Iosbase.width(0);
; 1482 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

  00335	56		 push	 esi
  00336	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  00339	8b 75 a0	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  0033c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0033e	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00341	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00344	50		 push	 eax
  00345	51		 push	 ecx
  00346	56		 push	 esi
  00347	53		 push	 ebx
  00348	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  0034b	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
  00352	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], 0
  00359	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  0035e	8b 45 d4	 mov	 eax, DWORD PTR __Grouping$[ebp+20]
  00361	83 c4 30	 add	 esp, 48			; 00000030H
  00364	83 f8 10	 cmp	 eax, 16			; 00000010H
  00367	72 0d		 jb	 SHORT $LN292@Fput
  00369	40		 inc	 eax
  0036a	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  0036d	50		 push	 eax
  0036e	ff 75 c0	 push	 DWORD PTR __Grouping$[ebp]
  00371	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN292@Fput:
  00376	8b 4d ec	 mov	 ecx, DWORD PTR __Groupstring$[ebp+20]
  00379	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+20], 15 ; 0000000fH
  00380	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+16], 0
  00387	c6 45 c0 00	 mov	 BYTE PTR __Grouping$[ebp], 0
  0038b	83 f9 08	 cmp	 ecx, 8
  0038e	72 0d		 jb	 SHORT $LN495@Fput
  00390	41		 inc	 ecx
  00391	51		 push	 ecx
  00392	ff 75 d8	 push	 DWORD PTR __Groupstring$[ebp]
  00395	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00398	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN495@Fput:
  0039d	8b c6		 mov	 eax, esi

; 1483 : 		}

  0039f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003a2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003a9	59		 pop	 ecx
  003aa	5f		 pop	 edi
  003ab	5e		 pop	 esi
  003ac	5b		 pop	 ebx
  003ad	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b0	33 cd		 xor	 ecx, ebp
  003b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b7	8b e5		 mov	 esp, ebp
  003b9	5d		 pop	 ebp
  003ba	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$0:
  00000	8d 4d ac	 lea	 ecx, DWORD PTR $T9[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$4:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$1:
  0000e	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$2:
  00016	8d 4d ac	 lea	 ecx, DWORD PTR $T8[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$33:
  0001e	e8 00 00 00 00	 call	 ___std_terminate
  00023	c3		 ret	 0
__unwindfunclet$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z$3:
  00024	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 4a 94	 mov	 ecx, DWORD PTR [edx-108]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00040	33 c8		 xor	 ecx, eax
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z
  0004c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Fput
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 1
__Flags$ = 20						; size = 4
?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ffmt, COMDAT

; 1383 : 		{	// generate sprintf format for floating-point

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1384 : 		char *_Ptr = _Fmt;
; 1385 : 		*_Ptr++ = '%';
; 1386 : 
; 1387 : 		if (_Flags & ios_base::showpos)

  00003	8b 55 14	 mov	 edx, DWORD PTR __Flags$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Fmt$[ebp]
  0000a	c6 06 25	 mov	 BYTE PTR [esi], 37	; 00000025H
  0000d	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00010	f6 c2 20	 test	 dl, 32			; 00000020H
  00013	74 04		 je	 SHORT $LN2@Ffmt

; 1388 : 			*_Ptr++ = '+';

  00015	c6 00 2b	 mov	 BYTE PTR [eax], 43	; 0000002bH
  00018	40		 inc	 eax
$LN2@Ffmt:

; 1389 : 		if (_Flags & ios_base::showpoint)

  00019	f6 c2 10	 test	 dl, 16			; 00000010H
  0001c	74 04		 je	 SHORT $LN3@Ffmt

; 1390 : 			*_Ptr++ = '#';

  0001e	c6 00 23	 mov	 BYTE PTR [eax], 35	; 00000023H
  00021	40		 inc	 eax
$LN3@Ffmt:

; 1391 : 		*_Ptr++ = '.';
; 1392 : 		*_Ptr++ = '*';	// for precision argument
; 1393 : 		if (_Spec != '\0')

  00022	8a 4d 10	 mov	 cl, BYTE PTR __Spec$[ebp]
  00025	66 c7 00 2e 2a	 mov	 WORD PTR [eax], 10798	; 00002a2eH
  0002a	83 c0 02	 add	 eax, 2
  0002d	84 c9		 test	 cl, cl
  0002f	74 03		 je	 SHORT $LN4@Ffmt

; 1394 : 			*_Ptr++ = _Spec;	// 'L' qualifier for long double only

  00031	88 08		 mov	 BYTE PTR [eax], cl
  00033	40		 inc	 eax
$LN4@Ffmt:

; 1395 : 
; 1396 : 		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

  00034	8b ca		 mov	 ecx, edx
  00036	81 e1 00 30 00
	00		 and	 ecx, 12288		; 00003000H

; 1397 : 		if (_Flags & ios_base::uppercase)

  0003c	f6 c2 04	 test	 dl, 4
  0003f	74 38		 je	 SHORT $LN5@Ffmt
  00041	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H

; 1398 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  00047	74 38		 je	 SHORT $LN16@Ffmt
  00049	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H
  0004f	75 0d		 jne	 SHORT $LN8@Ffmt
  00051	b1 41		 mov	 cl, 65			; 00000041H

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  00053	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  00055	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi

; 1408 : 		}

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN8@Ffmt:
  0005e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H

; 1398 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  00064	0f 95 c1	 setne	 cl
  00067	8d 0c 4d 45 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+69]

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  0006e	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  00070	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  00074	8b c6		 mov	 eax, esi
  00076	5e		 pop	 esi

; 1408 : 		}

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN5@Ffmt:
  00079	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  0007f	75 0d		 jne	 SHORT $LN14@Ffmt
$LN16@Ffmt:
  00081	b1 66		 mov	 cl, 102			; 00000066H
  00083	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  00085	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  00089	8b c6		 mov	 eax, esi
  0008b	5e		 pop	 esi

; 1408 : 		}

  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
$LN14@Ffmt:
  0008e	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  00094	75 0d		 jne	 SHORT $LN12@Ffmt
  00096	b1 61		 mov	 cl, 97			; 00000061H
  00098	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  0009a	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  0009e	8b c6		 mov	 eax, esi
  000a0	5e		 pop	 esi

; 1408 : 		}

  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
$LN12@Ffmt:
  000a3	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  000a9	0f 95 c1	 setne	 cl
  000ac	8d 0c 4d 65 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+101]
  000b3	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  000b5	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  000b9	8b c6		 mov	 eax, esi
  000bb	5e		 pop	 esi

; 1408 : 		}

  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ffmt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBX@Z
_TEXT	SEGMENT
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 4
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBX@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1373 : 		{	// put formatted void pointer to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 1c	 mov	 eax, DWORD PTR __Val$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi

; 1374 : 		char _Buf[2 * _MAX_INT_DIG];
; 1375 : 
; 1376 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  0001c	50		 push	 eax
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp?$AA@
  00022	8d 45 bc	 lea	 eax, DWORD PTR __Buf$[ebp]
  00025	8b f9		 mov	 edi, ecx
  00027	6a 40		 push	 64			; 00000040H
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _sprintf_s
  0002f	50		 push	 eax
  00030	8d 45 bc	 lea	 eax, DWORD PTR __Buf$[ebp]
  00033	50		 push	 eax
  00034	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00037	56		 push	 esi
  00038	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0003b	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0003e	53		 push	 ebx
  0003f	57		 push	 edi
  00040	e8 00 00 00 00	 call	 ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput

; 1377 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), "%p", _Val)));
; 1378 : 		}

  00045	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00048	83 c4 30	 add	 esp, 48			; 00000030H
  0004b	8b c3		 mov	 eax, ebx
  0004d	33 cd		 xor	 ecx, ebp
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBX@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z
_TEXT	SEGMENT
__Precision$ = -72					; size = 8
__Ptwo$2 = -68						; size = 4
___$ReturnUdt$GSCopy$1$ = -64				; size = 4
_this$GSCopy$1$ = -60					; size = 4
__Iosbase$GSCopy$1$ = -56				; size = 4
__Precision$1$ = -52					; size = 4
__Buf$ = -48						; size = 24
__Fmt$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 8
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1349 : 		{	// put formatted long double to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d c4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1350 : 		string _Buf;

  00030	33 d2		 xor	 edx, edx
  00032	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00035	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
  0003a	89 45 c0	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003d	89 4d c8	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], ecx
  00040	89 7d e4	 mov	 DWORD PTR __Buf$[ebp+20], edi
  00043	89 55 e0	 mov	 DWORD PTR __Buf$[ebp+16], edx
  00046	88 55 d0	 mov	 BYTE PTR __Buf$[ebp], dl

; 1351 : 		char _Fmt[8];
; 1352 : 		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
; 1353 : 			== ios_base::fixed;

  00049	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1354 : 		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed

  0004c	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  0004f	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  00054	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00057	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx
  0005a	89 75 cc	 mov	 DWORD PTR __Precision$1$[ebp], esi
  0005d	85 c9		 test	 ecx, ecx
  0005f	7f 17		 jg	 SHORT $LN4@do_put
  00061	7c 04		 jl	 SHORT $LN314@do_put
  00063	85 f6		 test	 esi, esi
  00065	75 11		 jne	 SHORT $LN4@do_put
$LN314@do_put:
  00067	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  0006c	74 0a		 je	 SHORT $LN4@do_put
  0006e	be 06 00 00 00	 mov	 esi, 6
  00073	33 c9		 xor	 ecx, ecx
  00075	89 75 cc	 mov	 DWORD PTR __Precision$1$[ebp], esi
$LN4@do_put:
  00078	89 4d bc	 mov	 DWORD PTR __Precision$[ebp+4], ecx

; 1355 : 			? 6 : _Iosbase.precision();	// desired precision
; 1356 : 		size_t _Bufsize = (size_t)_Precision;

  0007b	8b ce		 mov	 ecx, esi
  0007d	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H

; 1357 : 		if (_Isfixed && 1e10 < _CSTD fabsl(_Val))

  00082	75 56		 jne	 SHORT $LN2@do_put
  00084	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR __Val$[ebp]
  00089	0f 28 c1	 movaps	 xmm0, xmm1
  0008c	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00093	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4202a05f20000000
  0009b	76 3d		 jbe	 SHORT $LN2@do_put

; 1358 : 			{	// f or F format
; 1359 : 			int _Ptwo;
; 1360 : 			(void)_CSTD frexpl(_Val, &_Ptwo);

  0009d	8d 45 bc	 lea	 eax, DWORD PTR __Ptwo$2[ebp]
  000a0	50		 push	 eax
  000a1	83 ec 08	 sub	 esp, 8
  000a4	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  000a9	e8 00 00 00 00	 call	 _frexp

; 1361 : 			_Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  000ae	8b 45 bc	 mov	 eax, DWORD PTR __Ptwo$2[ebp]
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	8b 7d e4	 mov	 edi, DWORD PTR __Buf$[ebp+20]
  000b7	dd d8		 fstp	 ST(0)
  000b9	99		 cdq
  000ba	33 c2		 xor	 eax, edx
  000bc	2b c2		 sub	 eax, edx
  000be	69 c8 97 75 00
	00		 imul	 ecx, eax, 30103
  000c4	b8 89 b5 f8 14	 mov	 eax, 351843721		; 14f8b589H
  000c9	f7 e9		 imul	 ecx
  000cb	c1 fa 0d	 sar	 edx, 13			; 0000000dH
  000ce	8b ca		 mov	 ecx, edx
  000d0	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000d3	03 ca		 add	 ecx, edx
  000d5	8b 55 e0	 mov	 edx, DWORD PTR __Buf$[ebp+16]
  000d8	03 ce		 add	 ecx, esi
$LN2@do_put:

; 1362 : 			}
; 1363 : 		_Buf.resize(_Bufsize + 50);	// add fudge factor

  000da	83 c1 32	 add	 ecx, 50			; 00000032H
  000dd	3b ca		 cmp	 ecx, edx
  000df	77 13		 ja	 SHORT $LN127@do_put
  000e1	83 ff 10	 cmp	 edi, 16			; 00000010H
  000e4	89 4d e0	 mov	 DWORD PTR __Buf$[ebp+16], ecx
  000e7	8d 45 d0	 lea	 eax, DWORD PTR __Buf$[ebp]
  000ea	0f 43 45 d0	 cmovae	 eax, DWORD PTR __Buf$[ebp]
  000ee	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  000f2	eb 0d		 jmp	 SHORT $LN128@do_put
$LN127@do_put:
  000f4	2b ca		 sub	 ecx, edx
  000f6	6a 00		 push	 0
  000f8	51		 push	 ecx
  000f9	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  000fc	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN128@do_put:

; 1364 : 
; 1365 : 		int _Ngen = _CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),

  00101	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H
  00105	8d 7d d0	 lea	 edi, DWORD PTR __Buf$[ebp]
  00108	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  0010d	0f 43 7d d0	 cmovae	 edi, DWORD PTR __Buf$[ebp]
  00111	83 ec 08	 sub	 esp, 8
  00114	8b 45 c8	 mov	 eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00117	8b 75 e0	 mov	 esi, DWORD PTR __Buf$[ebp+16]
  0011a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0011f	ff 75 cc	 push	 DWORD PTR __Precision$1$[ebp]
  00122	ff 70 14	 push	 DWORD PTR [eax+20]
  00125	8d 45 e8	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00128	6a 4c		 push	 76			; 0000004cH
  0012a	50		 push	 eax
  0012b	ff 75 c4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0012e	e8 00 00 00 00	 call	 ?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ffmt
  00133	83 c4 10	 add	 esp, 16			; 00000010H
  00136	50		 push	 eax
  00137	56		 push	 esi
  00138	57		 push	 edi
  00139	e8 00 00 00 00	 call	 _sprintf_s

; 1366 : 			_Ffmt(_Fmt, 'L', _Iosbase.flags()), (int)_Precision, _Val);
; 1367 : 
; 1368 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

  0013e	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H
  00142	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00145	8b 75 c0	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  00148	0f 43 4d d0	 cmovae	 ecx, DWORD PTR __Buf$[ebp]
  0014c	50		 push	 eax
  0014d	51		 push	 ecx
  0014e	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00151	ff 75 c8	 push	 DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00154	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00157	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0015a	56		 push	 esi
  0015b	ff 75 c4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0015e	e8 00 00 00 00	 call	 ?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Fput
  00163	8b 4d e4	 mov	 ecx, DWORD PTR __Buf$[ebp+20]
  00166	83 c4 38	 add	 esp, 56			; 00000038H
  00169	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0016c	72 0d		 jb	 SHORT $LN315@do_put
  0016e	41		 inc	 ecx
  0016f	51		 push	 ecx
  00170	ff 75 d0	 push	 DWORD PTR __Buf$[ebp]
  00173	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00176	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN315@do_put:
  0017b	8b c6		 mov	 eax, esi

; 1369 : 		}

  0017d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00180	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00187	59		 pop	 ecx
  00188	5f		 pop	 edi
  00189	5e		 pop	 esi
  0018a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018d	33 cd		 xor	 ecx, ebp
  0018f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00194	8b e5		 mov	 esp, ebp
  00196	5d		 pop	 ebp
  00197	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WO@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z
_TEXT	SEGMENT
__Precision$ = -72					; size = 8
__Ptwo$2 = -68						; size = 4
___$ReturnUdt$GSCopy$1$ = -64				; size = 4
_this$GSCopy$1$ = -60					; size = 4
__Iosbase$GSCopy$1$ = -56				; size = 4
__Precision$1$ = -52					; size = 4
__Buf$ = -48						; size = 24
__Fmt$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 8
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1325 : 		{	// put formatted double to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d c4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1326 : 		string _Buf;

  00030	33 d2		 xor	 edx, edx
  00032	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00035	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
  0003a	89 45 c0	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003d	89 4d c8	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], ecx
  00040	89 7d e4	 mov	 DWORD PTR __Buf$[ebp+20], edi
  00043	89 55 e0	 mov	 DWORD PTR __Buf$[ebp+16], edx
  00046	88 55 d0	 mov	 BYTE PTR __Buf$[ebp], dl

; 1327 : 		char _Fmt[8];
; 1328 : 		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
; 1329 : 			== ios_base::fixed;

  00049	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1330 : 		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed

  0004c	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  0004f	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  00054	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00057	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx
  0005a	89 75 cc	 mov	 DWORD PTR __Precision$1$[ebp], esi
  0005d	85 c9		 test	 ecx, ecx
  0005f	7f 17		 jg	 SHORT $LN4@do_put
  00061	7c 04		 jl	 SHORT $LN310@do_put
  00063	85 f6		 test	 esi, esi
  00065	75 11		 jne	 SHORT $LN4@do_put
$LN310@do_put:
  00067	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  0006c	74 0a		 je	 SHORT $LN4@do_put
  0006e	be 06 00 00 00	 mov	 esi, 6
  00073	33 c9		 xor	 ecx, ecx
  00075	89 75 cc	 mov	 DWORD PTR __Precision$1$[ebp], esi
$LN4@do_put:
  00078	89 4d bc	 mov	 DWORD PTR __Precision$[ebp+4], ecx

; 1331 : 			? 6 : _Iosbase.precision();	// desired precision
; 1332 : 		size_t _Bufsize = (size_t)_Precision;

  0007b	8b ce		 mov	 ecx, esi
  0007d	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H

; 1333 : 		if (_Isfixed && 1e10 < _CSTD fabs(_Val))

  00082	75 56		 jne	 SHORT $LN2@do_put
  00084	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR __Val$[ebp]
  00089	0f 28 c1	 movaps	 xmm0, xmm1
  0008c	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00093	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4202a05f20000000
  0009b	76 3d		 jbe	 SHORT $LN2@do_put

; 1334 : 			{	// f or F format
; 1335 : 			int _Ptwo;
; 1336 : 			(void)_CSTD frexp(_Val, &_Ptwo);

  0009d	8d 45 bc	 lea	 eax, DWORD PTR __Ptwo$2[ebp]
  000a0	50		 push	 eax
  000a1	83 ec 08	 sub	 esp, 8
  000a4	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  000a9	e8 00 00 00 00	 call	 _frexp

; 1337 : 			_Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  000ae	8b 45 bc	 mov	 eax, DWORD PTR __Ptwo$2[ebp]
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	8b 7d e4	 mov	 edi, DWORD PTR __Buf$[ebp+20]
  000b7	dd d8		 fstp	 ST(0)
  000b9	99		 cdq
  000ba	33 c2		 xor	 eax, edx
  000bc	2b c2		 sub	 eax, edx
  000be	69 c8 97 75 00
	00		 imul	 ecx, eax, 30103
  000c4	b8 89 b5 f8 14	 mov	 eax, 351843721		; 14f8b589H
  000c9	f7 e9		 imul	 ecx
  000cb	c1 fa 0d	 sar	 edx, 13			; 0000000dH
  000ce	8b ca		 mov	 ecx, edx
  000d0	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000d3	03 ca		 add	 ecx, edx
  000d5	8b 55 e0	 mov	 edx, DWORD PTR __Buf$[ebp+16]
  000d8	03 ce		 add	 ecx, esi
$LN2@do_put:

; 1338 : 			}
; 1339 : 		_Buf.resize(_Bufsize + 50);	// add fudge factor

  000da	83 c1 32	 add	 ecx, 50			; 00000032H
  000dd	3b ca		 cmp	 ecx, edx
  000df	77 13		 ja	 SHORT $LN123@do_put
  000e1	83 ff 10	 cmp	 edi, 16			; 00000010H
  000e4	89 4d e0	 mov	 DWORD PTR __Buf$[ebp+16], ecx
  000e7	8d 45 d0	 lea	 eax, DWORD PTR __Buf$[ebp]
  000ea	0f 43 45 d0	 cmovae	 eax, DWORD PTR __Buf$[ebp]
  000ee	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  000f2	eb 0d		 jmp	 SHORT $LN124@do_put
$LN123@do_put:
  000f4	2b ca		 sub	 ecx, edx
  000f6	6a 00		 push	 0
  000f8	51		 push	 ecx
  000f9	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  000fc	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN124@do_put:

; 1340 : 
; 1341 : 		int _Ngen = _CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),

  00101	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H
  00105	8d 7d d0	 lea	 edi, DWORD PTR __Buf$[ebp]
  00108	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  0010d	0f 43 7d d0	 cmovae	 edi, DWORD PTR __Buf$[ebp]
  00111	83 ec 08	 sub	 esp, 8
  00114	8b 45 c8	 mov	 eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00117	8b 75 e0	 mov	 esi, DWORD PTR __Buf$[ebp+16]
  0011a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0011f	ff 75 cc	 push	 DWORD PTR __Precision$1$[ebp]
  00122	ff 70 14	 push	 DWORD PTR [eax+20]
  00125	8d 45 e8	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00128	6a 00		 push	 0
  0012a	50		 push	 eax
  0012b	ff 75 c4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0012e	e8 00 00 00 00	 call	 ?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ffmt
  00133	83 c4 10	 add	 esp, 16			; 00000010H
  00136	50		 push	 eax
  00137	56		 push	 esi
  00138	57		 push	 edi
  00139	e8 00 00 00 00	 call	 _sprintf_s

; 1342 : 			_Ffmt(_Fmt, 0, _Iosbase.flags()), (int)_Precision, _Val);
; 1343 : 
; 1344 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

  0013e	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H
  00142	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00145	8b 75 c0	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  00148	0f 43 4d d0	 cmovae	 ecx, DWORD PTR __Buf$[ebp]
  0014c	50		 push	 eax
  0014d	51		 push	 ecx
  0014e	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00151	ff 75 c8	 push	 DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00154	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00157	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0015a	56		 push	 esi
  0015b	ff 75 c4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0015e	e8 00 00 00 00	 call	 ?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Fput
  00163	8b 4d e4	 mov	 ecx, DWORD PTR __Buf$[ebp+20]
  00166	83 c4 38	 add	 esp, 56			; 00000038H
  00169	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0016c	72 0d		 jb	 SHORT $LN311@do_put
  0016e	41		 inc	 ecx
  0016f	51		 push	 ecx
  00170	ff 75 d0	 push	 DWORD PTR __Buf$[ebp]
  00173	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00176	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN311@do_put:
  0017b	8b c6		 mov	 eax, esi

; 1345 : 		}

  0017d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00180	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00187	59		 pop	 ecx
  00188	5f		 pop	 edi
  00189	5e		 pop	 esi
  0018a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018d	33 cd		 xor	 ecx, ebp
  0018f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00194	8b e5		 mov	 esp, ebp
  00196	5d		 pop	 ebp
  00197	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WN@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 8
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1315 : 		{	// put formatted unsigned long long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1316 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1317 : 
; 1318 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  00014	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi
  0001c	ff 75 20	 push	 DWORD PTR __Val$[ebp+4]
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  00024	ff 76 14	 push	 DWORD PTR [esi+20]
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_02CLHGNPPK@Lu?$AA@
  0002c	50		 push	 eax
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ifmt
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	50		 push	 eax
  00037	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0003a	6a 40		 push	 64			; 00000040H
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _sprintf_s
  00042	50		 push	 eax
  00043	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00046	50		 push	 eax
  00047	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0004a	56		 push	 esi
  0004b	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0004e	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00051	53		 push	 ebx
  00052	57		 push	 edi
  00053	e8 00 00 00 00	 call	 ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput

; 1319 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
; 1320 : 				_Iosbase.flags()), _Val)));
; 1321 : 		}

  00058	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005b	83 c4 34	 add	 esp, 52			; 00000034H
  0005e	8b c3		 mov	 eax, ebx
  00060	33 cd		 xor	 ecx, ebp
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 1c 00	 ret	 28			; 0000001cH
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 8
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1305 : 		{	// put formatted long long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1306 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1307 : 
; 1308 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  00014	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi
  0001c	ff 75 20	 push	 DWORD PTR __Val$[ebp+4]
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  00024	ff 76 14	 push	 DWORD PTR [esi+20]
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_02HIKPPMOK@Ld?$AA@
  0002c	50		 push	 eax
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ifmt
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	50		 push	 eax
  00037	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0003a	6a 40		 push	 64			; 00000040H
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _sprintf_s
  00042	50		 push	 eax
  00043	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00046	50		 push	 eax
  00047	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0004a	56		 push	 esi
  0004b	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0004e	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00051	53		 push	 ebx
  00052	57		 push	 edi
  00053	e8 00 00 00 00	 call	 ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput

; 1309 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
; 1310 : 				_Iosbase.flags()), _Val)));
; 1311 : 		}

  00058	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005b	83 c4 34	 add	 esp, 52			; 00000034H
  0005e	8b c3		 mov	 eax, ebx
  00060	33 cd		 xor	 ecx, ebp
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 1c 00	 ret	 28			; 0000001cH
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_J@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 4
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1295 : 		{	// put formatted unsigned long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1296 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1297 : 
; 1298 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  00014	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi
  0001c	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 76 14	 push	 DWORD PTR [esi+20]
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_02BDDLJJBK@lu?$AA@
  00029	50		 push	 eax
  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ifmt
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	50		 push	 eax
  00034	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00037	6a 40		 push	 64			; 00000040H
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _sprintf_s
  0003f	50		 push	 eax
  00040	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00043	50		 push	 eax
  00044	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00047	56		 push	 esi
  00048	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0004b	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0004e	53		 push	 ebx
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput

; 1299 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
; 1300 : 				_Iosbase.flags()), _Val)));
; 1301 : 		}

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	83 c4 30	 add	 esp, 48			; 00000030H
  0005b	8b c3		 mov	 eax, ebx
  0005d	33 cd		 xor	 ecx, ebp
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WJ@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 4
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WJ@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1285 : 		{	// put formatted long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1286 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1287 : 
; 1288 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  00014	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi
  0001c	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 76 14	 push	 DWORD PTR [esi+20]
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_02EAOCLKAK@ld?$AA@
  00029	50		 push	 eax
  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Ifmt
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	50		 push	 eax
  00034	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00037	6a 40		 push	 64			; 00000040H
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _sprintf_s
  0003f	50		 push	 eax
  00040	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00043	50		 push	 eax
  00044	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00047	56		 push	 esi
  00048	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0004b	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0004e	53		 push	 ebx
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Iput

; 1289 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
; 1290 : 				_Iosbase.flags()), _Val)));
; 1291 : 		}

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	83 c4 30	 add	 esp, 48			; 00000030H
  0005b	8b c3		 mov	 eax, ebx
  0005d	33 cd		 xor	 ecx, ebp
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WJ@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z
_TEXT	SEGMENT
$T2 = -88						; size = 8
__Fill$GSCopy$1$ = -80					; size = 4
$T3 = -76						; size = 8
$T4 = -76						; size = 8
__Dest$3$ = -72						; size = 4
_this$GSCopy$1$ = -68					; size = 4
$T5 = -64						; size = 24
$T6 = -64						; size = 24
__Str$7 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 1
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put, COMDAT
; _this$ = ecx

; 1255 : 		{	// put formatted bool to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 4d bc	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002e	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00031	0f b7 7d 18	 movzx	 edi, WORD PTR __Fill$[ebp]
  00035	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00038	89 7d b0	 mov	 DWORD PTR __Fill$GSCopy$1$[ebp], edi

; 1256 : 		_DEBUG_POINTER(_Dest);
; 1257 : 		if (!(_Iosbase.flags() & ios_base::boolalpha))

  0003b	f7 46 14 00 40
	00 00		 test	 DWORD PTR [esi+20], 16384 ; 00004000H
  00042	75 18		 jne	 SHORT $LN2@do_put

; 1258 : 			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));

  00044	0f b6 45 1c	 movzx	 eax, BYTE PTR __Val$[ebp]
  00048	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004a	50		 push	 eax
  0004b	57		 push	 edi
  0004c	56		 push	 esi
  0004d	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00050	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00053	53		 push	 ebx
  00054	ff 52 24	 call	 DWORD PTR [edx+36]
  00057	e9 7d 01 00 00	 jmp	 $LN964@do_put
$LN2@do_put:

; 1259 : 		else
; 1260 : 			{	// put "false" or "true"
; 1261 : 			const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

  0005c	8d 45 b4	 lea	 eax, DWORD PTR $T4[ebp]
  0005f	8b ce		 mov	 ecx, esi
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00067	50		 push	 eax
  00068	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006f	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<wchar_t> >
  00074	83 c4 04	 add	 esp, 4
  00077	8b f8		 mov	 edi, eax
  00079	8b 4d b8	 mov	 ecx, DWORD PTR $T4[ebp+4]
  0007c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00083	85 c9		 test	 ecx, ecx
  00085	74 11		 je	 SHORT $LN19@do_put
  00087	8b 11		 mov	 edx, DWORD PTR [ecx]
  00089	ff 52 08	 call	 DWORD PTR [edx+8]
  0008c	85 c0		 test	 eax, eax
  0008e	74 08		 je	 SHORT $LN19@do_put
  00090	8b 10		 mov	 edx, DWORD PTR [eax]
  00092	8b c8		 mov	 ecx, eax
  00094	6a 01		 push	 1
  00096	ff 12		 call	 DWORD PTR [edx]
$LN19@do_put:

; 1262 : 			_Mystr _Str;

  00098	33 c0		 xor	 eax, eax
  0009a	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR __Str$7[ebp+20], 7
  000a1	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Str$7[ebp+16], 0
  000a8	66 89 45 d8	 mov	 WORD PTR __Str$7[ebp], ax

; 1263 : 			if (_Val)

  000ac	80 7d 1c 00	 cmp	 BYTE PTR __Val$[ebp], 0

; 1264 : 				_Str.assign(_Punct_fac.truename());

  000b0	8d 45 c0	 lea	 eax, DWORD PTR $T6[ebp]
  000b3	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  000ba	8b cf		 mov	 ecx, edi
  000bc	50		 push	 eax
  000bd	74 09		 je	 SHORT $LN4@do_put
  000bf	e8 00 00 00 00	 call	 ?truename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::numpunct<wchar_t>::truename
  000c4	8b f8		 mov	 edi, eax

; 1265 : 			else

  000c6	eb 07		 jmp	 SHORT $LN1068@do_put
$LN4@do_put:

; 1266 : 				_Str.assign(_Punct_fac.falsename());

  000c8	e8 00 00 00 00	 call	 ?falsename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::numpunct<wchar_t>::falsename
  000cd	8b f8		 mov	 edi, eax
$LN1068@do_put:
  000cf	8d 45 d8	 lea	 eax, DWORD PTR __Str$7[ebp]
  000d2	3b c7		 cmp	 eax, edi
  000d4	74 2e		 je	 SHORT $LN517@do_put
  000d6	8b 45 ec	 mov	 eax, DWORD PTR __Str$7[ebp+20]
  000d9	83 f8 08	 cmp	 eax, 8
  000dc	72 0d		 jb	 SHORT $LN692@do_put
  000de	40		 inc	 eax
  000df	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  000e2	50		 push	 eax
  000e3	ff 75 d8	 push	 DWORD PTR __Str$7[ebp]
  000e6	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN692@do_put:
  000eb	33 c0		 xor	 eax, eax
  000ed	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR __Str$7[ebp+20], 7
  000f4	57		 push	 edi
  000f5	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  000f8	89 45 e8	 mov	 DWORD PTR __Str$7[ebp+16], eax
  000fb	66 89 45 d8	 mov	 WORD PTR __Str$7[ebp], ax
  000ff	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN517@do_put:
  00104	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp+20]
  00107	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0010b	83 f8 08	 cmp	 eax, 8
  0010e	72 0d		 jb	 SHORT $LN798@do_put
  00110	40		 inc	 eax
  00111	8d 4d c0	 lea	 ecx, DWORD PTR $T5[ebp]
  00114	50		 push	 eax
  00115	ff 75 c0	 push	 DWORD PTR $T5[ebp]
  00118	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN798@do_put:

; 1267 : 
; 1268 : 			size_t _Fillcount = _Iosbase.width() <= 0
; 1269 : 				|| (size_t)_Iosbase.width() <= _Str.size()

  0011d	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00121	8b 4d e8	 mov	 ecx, DWORD PTR __Str$7[ebp+16]
  00124	7c 13		 jl	 SHORT $LN8@do_put
  00126	7f 06		 jg	 SHORT $LN1061@do_put
  00128	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0012c	76 0b		 jbe	 SHORT $LN8@do_put
$LN1061@do_put:
  0012e	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  00131	3b f9		 cmp	 edi, ecx
  00133	76 04		 jbe	 SHORT $LN8@do_put
  00135	2b f9		 sub	 edi, ecx
  00137	eb 02		 jmp	 SHORT $LN9@do_put
$LN8@do_put:
  00139	33 ff		 xor	 edi, edi
$LN9@do_put:

; 1270 : 					? 0 : (size_t)_Iosbase.width() - _Str.size();
; 1271 : 
; 1272 : 			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)

  0013b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0013e	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00143	83 f8 40	 cmp	 eax, 64			; 00000040H
  00146	74 2b		 je	 SHORT $LN1062@do_put

; 1273 : 				{	// put leading fill
; 1274 : 				_Dest = _Rep(_Dest, _Fill, _Fillcount);

  00148	57		 push	 edi
  00149	ff 75 b0	 push	 DWORD PTR __Fill$GSCopy$1$[ebp]
  0014c	8d 45 b4	 lea	 eax, DWORD PTR $T3[ebp]
  0014f	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00152	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00155	50		 push	 eax
  00156	ff 75 bc	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  00159	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep

; 1275 : 				_Fillcount = 0;

  0015e	8b 4d e8	 mov	 ecx, DWORD PTR __Str$7[ebp+16]
  00161	83 c4 18	 add	 esp, 24			; 00000018H
  00164	33 ff		 xor	 edi, edi
  00166	8b 10		 mov	 edx, DWORD PTR [eax]
  00168	89 55 0c	 mov	 DWORD PTR __Dest$[ebp], edx
  0016b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0016e	89 45 10	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00171	eb 06		 jmp	 SHORT $LN1069@do_put
$LN1062@do_put:
  00173	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp+4]
  00176	8b 55 0c	 mov	 edx, DWORD PTR __Dest$[ebp]
$LN1069@do_put:

; 1276 : 				}
; 1277 : 			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field

  00179	83 7d ec 08	 cmp	 DWORD PTR __Str$7[ebp+20], 8
  0017d	89 45 b8	 mov	 DWORD PTR __Dest$3$[ebp], eax
  00180	8d 45 d8	 lea	 eax, DWORD PTR __Str$7[ebp]
  00183	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Str$7[ebp]
  00187	51		 push	 ecx
  00188	50		 push	 eax
  00189	ff 75 b8	 push	 DWORD PTR __Dest$3$[ebp]
  0018c	8d 45 a8	 lea	 eax, DWORD PTR $T2[ebp]
  0018f	52		 push	 edx
  00190	50		 push	 eax
  00191	ff 75 bc	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  00194	e8 00 00 00 00	 call	 ?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Put

; 1278 : 			_Iosbase.width(0);
; 1279 : 			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

  00199	57		 push	 edi
  0019a	ff 75 b0	 push	 DWORD PTR __Fill$GSCopy$1$[ebp]
  0019d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019f	89 4d 0c	 mov	 DWORD PTR __Dest$[ebp], ecx
  001a2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a5	50		 push	 eax
  001a6	51		 push	 ecx
  001a7	53		 push	 ebx
  001a8	ff 75 bc	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  001ab	89 45 10	 mov	 DWORD PTR __Dest$[ebp+4], eax
  001ae	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  001b5	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  001bc	e8 00 00 00 00	 call	 ?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Rep
  001c1	8b 45 ec	 mov	 eax, DWORD PTR __Str$7[ebp+20]
  001c4	83 c4 30	 add	 esp, 48			; 00000030H
  001c7	83 f8 08	 cmp	 eax, 8
  001ca	72 0d		 jb	 SHORT $LN964@do_put
  001cc	40		 inc	 eax
  001cd	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  001d0	50		 push	 eax
  001d1	ff 75 d8	 push	 DWORD PTR __Str$7[ebp]
  001d4	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN964@do_put:
  001d9	8b c3		 mov	 eax, ebx

; 1280 : 			}
; 1281 : 		}

  001db	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001de	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e5	59		 pop	 ecx
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi
  001e8	5b		 pop	 ebx
  001e9	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ec	33 cd		 xor	 ecx, ebp
  001ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f3	8b e5		 mov	 esp, ebp
  001f5	5d		 pop	 ebp
  001f6	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$0:
  00000	8d 4d b4	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$4:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$1:
  0000e	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$32:
  00016	e8 00 00 00 00	 call	 ___std_terminate
  0001b	c3		 ret	 0
__unwindfunclet$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z$134:
  0001c	e8 00 00 00 00	 call	 ___std_terminate
  00021	c3		 ret	 0
__ehhandler$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z:
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z
  00042	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_N@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::do_put
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 8
?put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::put, COMDAT
; _this$ = ecx

; 1230 : 		{	// put formatted unsigned long long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1231 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

  00003	ff 75 20	 push	 DWORD PTR __Val$[ebp+4]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  0000b	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Iosbase$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00014	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00017	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0001a	ff 50 18	 call	 DWORD PTR [eax+24]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1232 : 		}

  00020	5d		 pop	 ebp
  00021	c2 1c 00	 ret	 28			; 0000001cH
?put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_W_K@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 2
__Val$ = 28						; size = 4
?put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::put, COMDAT
; _this$ = ecx

; 1218 : 		{	// put formatted unsigned long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1219 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

  00003	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0000b	ff 75 14	 push	 DWORD PTR __Iosbase$[ebp]
  0000e	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00011	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00017	ff 50 20	 call	 DWORD PTR [eax+32]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1220 : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 18 00	 ret	 24			; 00000018H
?put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WK@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??0?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >, COMDAT
; _this$ = ecx

; 1197 : 		{	// construct from specified locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1196 : 		: locale::facet(_Refs)

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  00007	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1198 : 		_Init(_Lobj);
; 1199 : 		}

  0000a	8b c1		 mov	 eax, ecx
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??0?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Init@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Init@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Init, COMDAT
; _this$ = ecx

; 1184 : 		}

  00000	c2 04 00	 ret	 4
?_Init@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??1?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAE@XZ PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::~num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >, COMDAT
; _this$ = ecx

; 1180 : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::~num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 52
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getcat, COMDAT

; 1168 : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1169 : 		if (_Ppf != 0 && *_Ppf == 0)

  00028	8b 7d 08	 mov	 edi, DWORD PTR __Ppf$[ebp]
  0002b	33 db		 xor	 ebx, ebx
  0002d	89 5d f0	 mov	 DWORD PTR $T3[ebp], ebx
  00030	85 ff		 test	 edi, edi
  00032	74 63		 je	 SHORT $LN30@Getcat
  00034	39 1f		 cmp	 DWORD PTR [edi], ebx
  00036	75 5f		 jne	 SHORT $LN30@Getcat

; 1170 : 			*_Ppf = new num_put<_Elem, _OutIt>(

  00038	6a 08		 push	 8
  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	8b f0		 mov	 esi, eax
  00041	83 c4 04	 add	 esp, 4
  00044	89 75 08	 mov	 DWORD PTR $T4[ebp], esi
  00047	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0004a	85 f6		 test	 esi, esi
  0004c	74 38		 je	 SHORT $LN4@Getcat
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR __Ploc$[ebp]
  00051	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00054	85 c9		 test	 ecx, ecx
  00056	75 07		 jne	 SHORT $LN12@Getcat
  00058	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0005d	eb 0a		 jmp	 SHORT $LN17@Getcat
$LN12@Getcat:
  0005f	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00062	85 c0		 test	 eax, eax
  00064	75 03		 jne	 SHORT $LN17@Getcat
  00066	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
$LN17@Getcat:
  00069	50		 push	 eax
  0006a	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0006d	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00072	bb 01 00 00 00	 mov	 ebx, 1
  00077	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0007e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@6B@
  00084	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00086	33 f6		 xor	 esi, esi
$LN5@Getcat:
  00088	89 37		 mov	 DWORD PTR [edi], esi
  0008a	f6 c3 01	 test	 bl, 1
  0008d	74 08		 je	 SHORT $LN30@Getcat
  0008f	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  00092	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN30@Getcat:

; 1171 : 				_Locinfo(_Ploc->c_str()));
; 1172 : 		return (_X_NUMERIC);

  00097	b8 04 00 00 00	 mov	 eax, 4

; 1173 : 		}

  0009c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a6	59		 pop	 ecx
  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 08		 push	 8
  00002	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >, COMDAT

; 553  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 554  :  #if _NO_LOCALES
; 555  : 	static _Wrap_facet<_Facet> _Wfac;
; 556  : 	return (*(_Facet *)&_Wfac);
; 557  : 
; 558  :  #else /* _NO_LOCALES */
; 559  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 560  : 		const locale::facet *_Psave =
; 561  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 562  : 
; 563  : 		size_t _Id = _Facet::id;

  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
  00038	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >::_Psave
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	89 5d f0	 mov	 DWORD PTR __Psave$5[ebp], ebx
  00048	85 ff		 test	 edi, edi
  0004a	75 2f		 jne	 SHORT $LN11@use_facet
  0004c	57		 push	 edi
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A, edi ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
  0005b	75 10		 jne	 SHORT $LN12@use_facet
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00062	40		 inc	 eax
  00063	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
$LN12@use_facet:
  0006d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00070	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00075	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::id
$LN11@use_facet:

; 564  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0007e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00081	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00084	73 0c		 jae	 SHORT $LN20@use_facet
  00086	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00089	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  0008c	85 f6		 test	 esi, esi
  0008e	75 77		 jne	 SHORT $LN7@use_facet
  00090	eb 02		 jmp	 SHORT $LN28@use_facet
$LN20@use_facet:
  00092	33 f6		 xor	 esi, esi
$LN28@use_facet:
  00094	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00098	74 10		 je	 SHORT $LN17@use_facet
  0009a	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009f	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000a2	73 0a		 jae	 SHORT $LN29@use_facet
  000a4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a7	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN17@use_facet:

; 565  : 
; 566  : 		if (_Pf != 0)

  000aa	85 f6		 test	 esi, esi
  000ac	75 59		 jne	 SHORT $LN7@use_facet
$LN29@use_facet:

; 567  : 			;	// got facet from locale
; 568  : 		else if (_Psave != 0)

  000ae	85 db		 test	 ebx, ebx
  000b0	74 04		 je	 SHORT $LN4@use_facet

; 569  : 			_Pf = _Psave;	// lazy facet already allocated

  000b2	8b f3		 mov	 esi, ebx
  000b4	eb 51		 jmp	 SHORT $LN7@use_facet
$LN4@use_facet:

; 570  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000b6	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  000b9	8d 45 f0	 lea	 eax, DWORD PTR __Psave$5[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?_Getcat@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getcat
  000c2	83 c4 08	 add	 esp, 8
  000c5	83 f8 ff	 cmp	 eax, -1
  000c8	75 24		 jne	 SHORT $LN6@use_facet

; 571  : 
; 572  :  #if _HAS_EXCEPTIONS
; 573  : 
; 574  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000ca	0f 57 c0	 xorps	 xmm0, xmm0
  000cd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7bad_cast@std@@6B@
  000d4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000d9	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  000dc	66 0f d6 45 e0	 movq	 QWORD PTR $T2[ebp+4], xmm0
  000e1	50		 push	 eax
  000e2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@use_facet:
$LN6@use_facet:

; 575  : 
; 576  :  #else /* _HAS_EXCEPTIONS */
; 577  : 			abort();	// lazy disallowed
; 578  :  #endif /* _HAS_EXCEPTIONS */
; 579  : 
; 580  : 		else
; 581  : 			{	// queue up lazy facet for destruction
; 582  : 			_Pf = _Psave;

  000ee	8b 75 f0	 mov	 esi, DWORD PTR __Psave$5[ebp]

; 583  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 584  : 
; 585  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 586  : 			_Pfmod->_Incref();

  000f1	8b ce		 mov	 ecx, esi
  000f3	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >::_Psave
  000f9	8b 16		 mov	 edx, DWORD PTR [esi]
  000fb	ff 52 04	 call	 DWORD PTR [edx+4]

; 587  : 
; 588  :  #if defined(_M_CEE)
; 589  : 			_Facet_Register_m(_Pfmod);
; 590  : 
; 591  :  #else /* defined(_M_CEE) */
; 592  : 			_Facet_Register(_Pfmod);

  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  00104	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 593  :  #endif /* defined(_M_CEE) */
; 594  : 			}
; 595  : 
; 596  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00107	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0010a	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0010f	8b c6		 mov	 eax, esi

; 597  : 	_END_LOCK()
; 598  :  #endif /* _NO_LOCALES */
; 599  : 	}	// end of use_facet body

  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN31@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 142  : 			return (_Ok);

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 143  : 			}

  00003	c3		 ret	 0
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 130  : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

  00025	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  0002a	84 c0		 test	 al, al
  0002c	75 07		 jne	 SHORT $LN2@sentry

; 133  : 				this->_Myostr._Osfx();

  0002e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00030	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN2@sentry:

; 134  : 
; 135  :  #else /* _HAS_EXCEPTIONS */
; 136  : 			this->_Myostr._Osfx();
; 137  :  #endif /* _HAS_EXCEPTIONS */
; 138  : 			}

  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00040	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00043	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  00047	85 c9		 test	 ecx, ecx
  00049	74 05		 je	 SHORT $LN5@sentry
  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@sentry:
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 123  : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi

; 122  : 			: _Sentry_base(_Ostr)

  0002a	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  0002d	89 37		 mov	 DWORD PTR [edi], esi
  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00038	85 c9		 test	 ecx, ecx
  0003a	74 05		 je	 SHORT $LN6@sentry
  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	ff 50 04	 call	 DWORD PTR [eax+4]
$LN6@sentry:

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00041	8b 06		 mov	 eax, DWORD PTR [esi]
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004d	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  00052	75 11		 jne	 SHORT $LN2@sentry
  00054	8b 4c 30 3c	 mov	 ecx, DWORD PTR [eax+esi+60]
  00058	85 c9		 test	 ecx, ecx
  0005a	74 09		 je	 SHORT $LN2@sentry
  0005c	3b ce		 cmp	 ecx, esi
  0005e	74 05		 je	 SHORT $LN2@sentry

; 125  : 				_Ostr.tie()->flush();

  00060	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
$LN2@sentry:

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006a	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  0006f	0f 94 c0	 sete	 al
  00072	88 47 04	 mov	 BYTE PTR [edi+4], al

; 127  : 			}

  00075	8b c7		 mov	 eax, edi
  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 106  : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 107  : 			if (_Myostr.rdbuf() != 0)

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 05		 je	 SHORT $LN2@Sentry_bas

; 108  : 				_Myostr.rdbuf()->_Unlock();

  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 109  : 			}

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 100  : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   : 			: _Myostr(_Ostr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00006	56		 push	 esi

; 100  : 			{	// lock the stream buffer, if there

  00007	8b f1		 mov	 esi, ecx
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 101  : 			if (_Myostr.rdbuf() != 0)

  0000b	8b 02		 mov	 eax, DWORD PTR [edx]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  00014	85 c9		 test	 ecx, ecx
  00016	74 05		 je	 SHORT $LN8@Sentry_bas

; 102  : 				_Myostr.rdbuf()->_Lock();

  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	ff 50 04	 call	 DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 103  : 			}

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ
_TEXT	SEGMENT
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT
; _this$ = ecx

; 68   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	03 01		 add	 eax, DWORD PTR [ecx]
  00005	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00008	13 51 04	 adc	 edx, DWORD PTR [ecx+4]

; 69   : 		}

  0000b	c3		 ret	 0
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with stream offset

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	89 01		 mov	 DWORD PTR [ecx], eax
  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp+4]
  0000e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 44   : 		}

  00011	8b c1		 mov	 eax, ecx
  00013	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001a	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00021	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >, COMDAT
; _this$ = ecx

; 1202 : 		{	// assign [_First, _Last), input iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1203 : 		return (replace(begin(), end(), _First, _Last));

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	72 04		 jb	 SHORT $LN14@assign
  00009	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000b	eb 02		 jmp	 SHORT $LN15@assign
$LN14@assign:
  0000d	8b d1		 mov	 edx, ecx
$LN15@assign:
  0000f	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00012	03 c2		 add	 eax, edx
  00014	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00018	72 13		 jb	 SHORT $LN48@assign
  0001a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00022	50		 push	 eax
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace

; 1204 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8

; 1203 : 		return (replace(begin(), end(), _First, _Last));

$LN48@assign:
  0002d	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00030	8b d1		 mov	 edx, ecx
  00032	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace

; 1204 : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 398  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 399  : 		return (*(_Mybase *)this - _Right);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]

; 400  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ
_TEXT	SEGMENT
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 340  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 341  : 		}

  00002	c3		 ret	 0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 322  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 321  : 		: _Mybase(_Parg, _Pstring)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 323  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator!=<char,char>, COMDAT

; 804  : 	return (false);

  00000	32 c0		 xor	 al, al

; 805  : 	}

  00002	c3		 ret	 0
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator!=<char,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator!=<std::allocator<char>,std::allocator<char> >, COMDAT

; 1026 : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 1027 : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat, COMDAT
; _this$ = ecx

; 270  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==, COMDAT
; _this$ = ecx

; 220  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 221  : 		_Compat(_Right);
; 222  : 		return (_Ptr == _Right._Ptr);
; 223  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 209  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 210  : 		_Compat(_Right);
; 211  : 		return (_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]

; 212  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 68   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 69   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 70   : 		const auto _Contptr = _Mycont ? _Mycont->_Myptr() : 0;
; 71   : 		if (_Mycont == 0
; 72   : 			|| _Ptr == nullptr_t{}
; 73   : 			|| _Unfancy(_Ptr) < _Contptr
; 74   : 			|| _Contptr + _Mycont->_Mysize <= _Unfancy(_Ptr))
; 75   : 			{	// report error
; 76   : 			_DEBUG_ERROR("string iterator not dereferencable");
; 77   : 			_SCL_SECURE_OUT_OF_RANGE;
; 78   : 			}
; 79   : 
; 80   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 81   : 		_SCL_SECURE_VALIDATE(_Ptr != nullptr_t{});
; 82   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 83   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 84   : 		const auto _Contptr = _Mycont->_Myptr();
; 85   : 		_SCL_SECURE_VALIDATE_RANGE(_Contptr <= _Unfancy(_Ptr) && _Unfancy(_Ptr) < _Contptr + _Mycont->_Mysize);
; 86   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 87   : 
; 88   : 		_Analysis_assume_(_Ptr != nullptr_t{});
; 89   : 
; 90   : 		return (*_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 91   : 		}

  00002	c3		 ret	 0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 49   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 48   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 50   : 		this->_Adopt(_Pstring);
; 51   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >, COMDAT
; _this$ = ecx

; 1202 : 		{	// assign [_First, _Last), input iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1203 : 		return (replace(begin(), end(), _First, _Last));

  00003	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00007	72 04		 jb	 SHORT $LN14@assign
  00009	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000b	eb 02		 jmp	 SHORT $LN15@assign
$LN14@assign:
  0000d	8b d1		 mov	 edx, ecx
$LN15@assign:
  0000f	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00013	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00016	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00019	72 13		 jb	 SHORT $LN48@assign
  0001b	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00023	50		 push	 eax
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace

; 1204 : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8

; 1203 : 		return (replace(begin(), end(), _First, _Last));

$LN48@assign:
  0002e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00031	8b d1		 mov	 edx, ecx
  00033	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00036	50		 push	 eax
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace

; 1204 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator-, COMDAT
; _this$ = ecx

; 398  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 399  : 		return (*(_Mybase *)this - _Right);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	d1 f8		 sar	 eax, 1

; 400  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ
_TEXT	SEGMENT
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator*, COMDAT
; _this$ = ecx

; 340  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 341  : 		}

  00002	c3		 ret	 0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT
; _this$ = ecx

; 322  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 321  : 		: _Mybase(_Parg, _Pstring)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 323  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Compat, COMDAT
; _this$ = ecx

; 270  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator==, COMDAT
; _this$ = ecx

; 220  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 221  : 		_Compat(_Right);
; 222  : 		return (_Ptr == _Right._Ptr);
; 223  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator-, COMDAT
; _this$ = ecx

; 209  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 210  : 		_Compat(_Right);
; 211  : 		return (_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	d1 f8		 sar	 eax, 1

; 212  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator*, COMDAT
; _this$ = ecx

; 68   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 69   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 70   : 		const auto _Contptr = _Mycont ? _Mycont->_Myptr() : 0;
; 71   : 		if (_Mycont == 0
; 72   : 			|| _Ptr == nullptr_t{}
; 73   : 			|| _Unfancy(_Ptr) < _Contptr
; 74   : 			|| _Contptr + _Mycont->_Mysize <= _Unfancy(_Ptr))
; 75   : 			{	// report error
; 76   : 			_DEBUG_ERROR("string iterator not dereferencable");
; 77   : 			_SCL_SECURE_OUT_OF_RANGE;
; 78   : 			}
; 79   : 
; 80   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 81   : 		_SCL_SECURE_VALIDATE(_Ptr != nullptr_t{});
; 82   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 83   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 84   : 		const auto _Contptr = _Mycont->_Myptr();
; 85   : 		_SCL_SECURE_VALIDATE_RANGE(_Contptr <= _Unfancy(_Ptr) && _Unfancy(_Ptr) < _Contptr + _Mycont->_Mysize);
; 86   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 87   : 
; 88   : 		_Analysis_assume_(_Ptr != nullptr_t{});
; 89   : 
; 90   : 		return (*_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 91   : 		}

  00002	c3		 ret	 0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT
; _this$ = ecx

; 49   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 48   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 50   : 		this->_Adopt(_Pstring);
; 51   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9_W_W@std@@YA_NABV?$allocator@_W@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9_W_W@std@@YA_NABV?$allocator@_W@0@0@Z PROC		; std::operator!=<wchar_t,wchar_t>, COMDAT

; 804  : 	return (false);

  00000	32 c0		 xor	 al, al

; 805  : 	}

  00002	c3		 ret	 0
??$?9_W_W@std@@YA_NABV?$allocator@_W@0@0@Z ENDP		; std::operator!=<wchar_t,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 1026 : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 1027 : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAEIV?$allocator@E@std@@@std@@YAXPAEIAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAEIV?$allocator@E@std@@@std@@YAXPAEIAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<unsigned char *,unsigned int,std::allocator<unsigned char> >, COMDAT

; 479  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

  00003	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000b	e8 00 00 00 00	 call	 _memset
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 482  : 		typename conjunction<
; 483  : 			is_pointer<_FwdIt>,
; 484  : 			is_scalar<_Ty>,
; 485  : 			negation<is_volatile<_Ty>>,
; 486  : 			negation<is_member_pointer<_Ty>>,
; 487  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
; 488  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Uninitialized_default_fill_n@PAEIV?$allocator@E@std@@@std@@YAXPAEIAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<unsigned char *,unsigned int,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z PROC ; std::forward<std::vector<unsigned char,std::allocator<unsigned char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z ENDP ; std::forward<std::vector<unsigned char,std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@E@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@E@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z PROC ; std::operator!=<std::allocator<unsigned char>,std::allocator<unsigned char> >, COMDAT

; 1026 : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 1027 : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@E@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<unsigned char>,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@EE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAE$$QAE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@EE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAE$$QAE@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 01		 mov	 BYTE PTR [ecx], al
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@EE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAE$$QAE@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@E@std@@YA$$QAEAAE@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@E@std@@YA$$QAEAAE@Z PROC			; std::forward<unsigned char>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@E@std@@YA$$QAEAAE@Z ENDP			; std::forward<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@E@std@@YAPAEPAE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@E@std@@YAPAEPAE@Z PROC			; std::_Unfancy<unsigned char>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@E@std@@YAPAEPAE@Z ENDP			; std::_Unfancy<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@E@std@@YAPAEAAE@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@E@std@@YAPAEAAE@Z PROC			; std::addressof<unsigned char>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@E@std@@YAPAEAAE@Z ENDP			; std::addressof<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEAAEXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEAAEXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator*, COMDAT
; _this$ = ecx

; 331  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 332  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEAAEXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT
; _this$ = ecx

; 313  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 312  : 		: _Mybase(_Parg, _Pvector)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 314  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEABEXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEABEXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 68   : 		if (_Mycont == 0
; 69   : 			|| _Ptr == _Tptr()
; 70   : 			|| _Ptr < _Mycont->_Myfirst
; 71   : 			|| _Mycont->_Mylast <= _Ptr)
; 72   : 			{	// report error
; 73   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 74   : 			_SCL_SECURE_OUT_OF_RANGE;
; 75   : 			}
; 76   : 
; 77   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 78   : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 79   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 80   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 81   : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEABEXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@YA$$QAV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@YA$$QAV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@AAV10@@Z PROC ; std::forward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@YA$$QAV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > ><std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,void>, COMDAT
; _this$ = ecx

; 526  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 529  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > ><std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEAAUSecurityTokenKeyfile@GostCrypt@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEAAUSecurityTokenKeyfile@GostCrypt@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::operator*, COMDAT
; _this$ = ecx

; 331  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 332  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEAAUSecurityTokenKeyfile@GostCrypt@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAE@PAUSecurityTokenKeyfile@GostCrypt@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAE@PAUSecurityTokenKeyfile@GostCrypt@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >, COMDAT
; _this$ = ecx

; 313  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 312  : 		: _Mybase(_Parg, _Pvector)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 314  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAE@PAUSecurityTokenKeyfile@GostCrypt@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile const &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN13@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z$2:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@USecurityTokenKeyfile@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@ABU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN13@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z$2:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@USecurityTokenKeyfile@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@AAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::construct<GostCrypt::SecurityTokenKeyfile,GostCrypt::SecurityTokenKeyfile &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@USecurityTokenKeyfile@GostCrypt@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@USecurityTokenKeyfile@GostCrypt@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@@Z PROC ; std::_Unfancy<GostCrypt::SecurityTokenKeyfile>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@USecurityTokenKeyfile@GostCrypt@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@@Z ENDP ; std::_Unfancy<GostCrypt::SecurityTokenKeyfile>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUSecurityTokenKeyfile@GostCrypt@@@std@@YAPBUSecurityTokenKeyfile@GostCrypt@@ABU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUSecurityTokenKeyfile@GostCrypt@@@std@@YAPBUSecurityTokenKeyfile@GostCrypt@@ABU12@@Z PROC ; std::addressof<GostCrypt::SecurityTokenKeyfile const >, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUSecurityTokenKeyfile@GostCrypt@@@std@@YAPBUSecurityTokenKeyfile@GostCrypt@@ABU12@@Z ENDP ; std::addressof<GostCrypt::SecurityTokenKeyfile const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@YA$$QAV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@YA$$QAV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@0@AAV10@@Z PROC ; std::forward<std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@YA$$QAV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@1@@Z PROC ; std::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> ><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,void>, COMDAT
; _this$ = ecx

; 825  : 		{	// construct from allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Buynode0
  00020	89 06		 mov	 DWORD PTR [esi], eax

; 826  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@1@@Z ENDP ; std::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> ><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$_Insert@USecurityTokenInfo@GostCrypt@@@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@$$QAUSecurityTokenInfo@GostCrypt@@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Insert@USecurityTokenInfo@GostCrypt@@@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@$$QAUSecurityTokenInfo@GostCrypt@@@Z PROC ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Insert<GostCrypt::SecurityTokenInfo>, COMDAT
; _this$ = ecx

; 1061 : 		{	// insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1062 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1063 : 		_Nodeptr _Newnode =
; 1064 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

  00004	8b 75 08	 mov	 esi, DWORD PTR __Where$[ebp]
  00007	57		 push	 edi
  00008	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
  0000b	8b f9		 mov	 edi, ecx
  0000d	ff 76 04	 push	 DWORD PTR [esi+4]
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??$_Buynode@USecurityTokenInfo@GostCrypt@@@?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@PAU21@0$$QAUSecurityTokenInfo@GostCrypt@@@Z ; std::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Buynode<GostCrypt::SecurityTokenInfo>
  00016	8b d0		 mov	 edx, eax

; 1065 : 				_STD forward<_Valty>(_Val)...);
; 1066 : 		_Incsize(1);

  00018	b9 fe ff ff 03	 mov	 ecx, 67108862		; 03fffffeH
  0001d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00020	2b c8		 sub	 ecx, eax
  00022	83 f9 01	 cmp	 ecx, 1
  00025	72 12		 jb	 SHORT $LN65@Insert
  00027	40		 inc	 eax
  00028	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1067 : 		this->_Prevnode(_Pnode) = _Newnode;

  0002b	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1068 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  0002e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	89 10		 mov	 DWORD PTR [eax], edx

; 1069 : 		}

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
$LN65@Insert:

; 1065 : 				_STD forward<_Valty>(_Val)...);
; 1066 : 		_Incsize(1);

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0003e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN67@Insert:
$LN64@Insert:
  00043	cc		 int	 3
??$_Insert@USecurityTokenInfo@GostCrypt@@@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@$$QAUSecurityTokenInfo@GostCrypt@@@Z ENDP ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Insert<GostCrypt::SecurityTokenInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@USecurityTokenInfo@GostCrypt@@@std@@YA$$QAUSecurityTokenInfo@GostCrypt@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@USecurityTokenInfo@GostCrypt@@@std@@YA$$QAUSecurityTokenInfo@GostCrypt@@AAU12@@Z PROC ; std::forward<GostCrypt::SecurityTokenInfo>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@USecurityTokenInfo@GostCrypt@@@std@@YA$$QAUSecurityTokenInfo@GostCrypt@@AAU12@@Z ENDP ; std::forward<GostCrypt::SecurityTokenInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> > >, COMDAT
; _this$ = ecx

; 124  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 123  : 		: _Mybase(_Pnode, _Plist)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 125  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 96   : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 97   : 		}

  00002	c3		 ret	 0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		: _Ptr(_Pnode)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAKIV?$allocator@K@std@@@std@@YAXPAKIAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAKIV?$allocator@K@std@@@std@@YAXPAKIAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<unsigned long *,unsigned int,std::allocator<unsigned long> >, COMDAT

; 479  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	c1 e0 02	 shl	 eax, 2
  00009	89 45 10	 mov	 DWORD PTR __Al$[ebp], eax
  0000c	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR __Count$[ebp], 0

; 482  : 		typename conjunction<
; 483  : 			is_pointer<_FwdIt>,
; 484  : 			is_scalar<_Ty>,
; 485  : 			negation<is_volatile<_Ty>>,
; 486  : 			negation<is_member_pointer<_Ty>>,
; 487  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
; 488  : 	}

  00013	5d		 pop	 ebp

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

  00014	e9 00 00 00 00	 jmp	 _memset
??$_Uninitialized_default_fill_n@PAKIV?$allocator@K@std@@@std@@YAXPAKIAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<unsigned long *,unsigned int,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$vector@KV?$allocator@K@std@@@std@@@std@@YA$$QAV?$vector@KV?$allocator@K@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$vector@KV?$allocator@K@std@@@std@@@std@@YA$$QAV?$vector@KV?$allocator@K@std@@@0@AAV10@@Z PROC ; std::forward<std::vector<unsigned long,std::allocator<unsigned long> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$vector@KV?$allocator@K@std@@@std@@@std@@YA$$QAV?$vector@KV?$allocator@K@std@@@0@AAV10@@Z ENDP ; std::forward<std::vector<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@K@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@K@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@K@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@K@std@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > ><std::_Wrap_alloc<std::allocator<unsigned long> >,void>, COMDAT
; _this$ = ecx

; 526  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 529  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@K@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@K@std@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > ><std::_Wrap_alloc<std::allocator<unsigned long> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@K@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@K@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<unsigned long> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@K@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<unsigned long> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEAAKXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEAAKXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator*, COMDAT
; _this$ = ecx

; 331  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 332  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEAAKXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >, COMDAT
; _this$ = ecx

; 313  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 312  : 		: _Mybase(_Parg, _Pvector)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 314  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@KABK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKABK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@KABK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKABK@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@KABK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKABK@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@KAAK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKAAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@KAAK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKAAK@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::construct<unsigned long,unsigned long &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@KAAK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKAAK@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::construct<unsigned long,unsigned long &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@K@std@@YAPAKPAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@K@std@@YAPAKPAK@Z PROC			; std::_Unfancy<unsigned long>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@K@std@@YAPAKPAK@Z ENDP			; std::_Unfancy<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBK@std@@YAPBKABK@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBK@std@@YAPBKABK@Z PROC			; std::addressof<unsigned long const >, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBK@std@@YAPBKABK@Z ENDP			; std::addressof<unsigned long const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$list@KV?$allocator@K@std@@@std@@@std@@YA$$QAV?$list@KV?$allocator@K@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$list@KV?$allocator@K@std@@@std@@@std@@YA$$QAV?$list@KV?$allocator@K@std@@@0@AAV10@@Z PROC ; std::forward<std::list<unsigned long,std::allocator<unsigned long> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$list@KV?$allocator@K@std@@@std@@@std@@YA$$QAV?$list@KV?$allocator@K@std@@@0@AAV10@@Z ENDP ; std::forward<std::list<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@X@?$_List_buy@KV?$allocator@K@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@X@?$_List_buy@KV?$allocator@K@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@1@@Z PROC ; std::_List_buy<unsigned long,std::allocator<unsigned long> >::_List_buy<unsigned long,std::allocator<unsigned long> ><std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,void>, COMDAT
; _this$ = ecx

; 825  : 		{	// construct from allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Buynode0
  00020	89 06		 mov	 DWORD PTR [esi], eax

; 826  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@X@?$_List_buy@KV?$allocator@K@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@1@@Z ENDP ; std::_List_buy<unsigned long,std::allocator<unsigned long> >::_List_buy<unsigned long,std::allocator<unsigned long> ><std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$_Insert@ABK@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@ABK@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Insert@ABK@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@ABK@Z PROC ; std::list<unsigned long,std::allocator<unsigned long> >::_Insert<unsigned long const &>, COMDAT
; _this$ = ecx

; 1061 : 		{	// insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1062 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1063 : 		_Nodeptr _Newnode =
; 1064 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

  00004	8b 75 08	 mov	 esi, DWORD PTR __Where$[ebp]
  00007	57		 push	 edi
  00008	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
  0000b	8b f9		 mov	 edi, ecx
  0000d	ff 76 04	 push	 DWORD PTR [esi+4]
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??$_Buynode@ABK@?$_List_buy@KV?$allocator@K@std@@@std@@QAEPAU?$_List_node@KPAX@1@PAU21@0ABK@Z ; std::_List_buy<unsigned long,std::allocator<unsigned long> >::_Buynode<unsigned long const &>
  00016	8b d0		 mov	 edx, eax

; 1065 : 				_STD forward<_Valty>(_Val)...);
; 1066 : 		_Incsize(1);

  00018	b9 54 55 55 15	 mov	 ecx, 357913940		; 15555554H
  0001d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00020	2b c8		 sub	 ecx, eax
  00022	83 f9 01	 cmp	 ecx, 1
  00025	72 12		 jb	 SHORT $LN65@Insert
  00027	40		 inc	 eax
  00028	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1067 : 		this->_Prevnode(_Pnode) = _Newnode;

  0002b	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1068 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  0002e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	89 10		 mov	 DWORD PTR [eax], edx

; 1069 : 		}

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
$LN65@Insert:

; 1065 : 				_STD forward<_Valty>(_Val)...);
; 1066 : 		_Incsize(1);

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0003e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN67@Insert:
$LN64@Insert:
  00043	cc		 int	 3
??$_Insert@ABK@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@ABK@Z ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::_Insert<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAE@PAU?$_List_node@KPAX@1@PBV?$_List_val@U?$_List_simple_types@K@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAE@PAU?$_List_node@KPAX@1@PBV?$_List_val@U?$_List_simple_types@K@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >, COMDAT
; _this$ = ecx

; 124  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 123  : 		: _Mybase(_Pnode, _Plist)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 125  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAE@PAU?$_List_node@KPAX@1@PBV?$_List_val@U?$_List_simple_types@K@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$try_emplace@$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$try_emplace@$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z PROC ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::try_emplace<>, COMDAT
; _this$ = ecx

; 228  : 		{	// fail if _Keyval present, else emplace

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 229  : 		return (_Try_emplace(_Keyval, _STD forward<_Mappedty>(_Mapval)...));

  00003	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  00006	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 230  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$try_emplace@$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ENDP ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::try_emplace<>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::destroy<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::destroy<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@YAPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@YAPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@0@AAU10@@Z PROC ; std::addressof<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@YAPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$swap@DX@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@DX@std@@YAXAAD0@Z PROC				; std::swap<char,void>, COMDAT

; 48   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_Ty _Tmp = _STD move(_Left);
; 50   : 	_Left = _STD move(_Right);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  00009	53		 push	 ebx
  0000a	8a 01		 mov	 al, BYTE PTR [ecx]
  0000c	8a 1a		 mov	 bl, BYTE PTR [edx]
  0000e	88 02		 mov	 BYTE PTR [edx], al

; 51   : 	_Right = _STD move(_Tmp);

  00010	88 19		 mov	 BYTE PTR [ecx], bl
  00012	5b		 pop	 ebx

; 52   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@DX@std@@YAXAAD0@Z ENDP				; std::swap<char,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A@@YAXXZ
text$yd	SEGMENT
$T1 = -4						; size = 4
??__F?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'GostCrypt::SecurityToken::Sessions'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  0000e	56		 push	 esi
  0000f	50		 push	 eax
  00010	ff 30		 push	 DWORD PTR [eax]
  00012	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::erase
  0001b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A
  00021	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  00026	56		 push	 esi
  00027	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
  0002c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0002f	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
  0003a	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> *>
  00048	56		 push	 esi
  00049	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004e	83 c4 04	 add	 esp, 4
  00051	5e		 pop	 esi
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??__F?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'GostCrypt::SecurityToken::Sessions''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ??__E?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A@@YAXXZ
text$di	SEGMENT
??__E?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'GostCrypt::SecurityToken::Sessions'', COMDAT

; 894  : 	map <CK_SLOT_ID, Pkcs11Session> SecurityToken::Sessions;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  00005	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >
  0000a	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  0000f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A, 0
  00019	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A+4, 0
  00023	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buyheadnode
  00028	68 00 00 00 00	 push	 OFFSET ??__F?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'GostCrypt::SecurityToken::Sessions''
  0002d	a3 00 00 00 00	 mov	 DWORD PTR ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A, eax
  00032	e8 00 00 00 00	 call	 _atexit
  00037	59		 pop	 ecx
  00038	c3		 ret	 0
??__E?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'GostCrypt::SecurityToken::Sessions''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?WarningCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?WarningCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'GostCrypt::SecurityToken::WarningCallback'', COMDAT
  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WarningCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@A ; GostCrypt::SecurityToken::WarningCallback
  00006	85 c9		 test	 ecx, ecx
  00008	74 06		 je	 SHORT $LN5@WarningCal
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	6a 01		 push	 1
  0000e	ff 10		 call	 DWORD PTR [eax]
$LN5@WarningCal:
  00010	c3		 ret	 0
??__F?WarningCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'GostCrypt::SecurityToken::WarningCallback''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ??__E?WarningCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@A@@YAXXZ
text$di	SEGMENT
??__E?WarningCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'GostCrypt::SecurityToken::WarningCallback'', COMDAT

; 890  : 	auto_ptr <SendExceptionFunctor> SecurityToken::WarningCallback;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?WarningCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'GostCrypt::SecurityToken::WarningCallback''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?WarningCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'GostCrypt::SecurityToken::WarningCallback''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?PinCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?PinCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'GostCrypt::SecurityToken::PinCallback'', COMDAT
  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?PinCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@A ; GostCrypt::SecurityToken::PinCallback
  00006	85 c9		 test	 ecx, ecx
  00008	74 06		 je	 SHORT $LN5@PinCallbac
  0000a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000c	6a 01		 push	 1
  0000e	ff 10		 call	 DWORD PTR [eax]
$LN5@PinCallbac:
  00010	c3		 ret	 0
??__F?PinCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'GostCrypt::SecurityToken::PinCallback''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ??__E?PinCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@A@@YAXXZ
text$di	SEGMENT
??__E?PinCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'GostCrypt::SecurityToken::PinCallback'', COMDAT

; 889  : 	auto_ptr <GetPinFunctor> SecurityToken::PinCallback;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?PinCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'GostCrypt::SecurityToken::PinCallback''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?PinCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'GostCrypt::SecurityToken::PinCallback''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W$$QAV10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W$$QAV10@@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2417 : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2418 : 	return (_STD move(_Right.insert(0, _Left)));

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Left$[ebp]
  00007	56		 push	 esi
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000f	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  00013	75 04		 jne	 SHORT $LN9@operator
  00015	33 c0		 xor	 eax, eax
  00017	eb 16		 jmp	 SHORT $LN10@operator
$LN9@operator:
  00019	8b c2		 mov	 eax, edx
  0001b	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  0001e	66 90		 npad	 2
$LL141@operator:
  00020	66 8b 08	 mov	 cx, WORD PTR [eax]
  00023	83 c0 02	 add	 eax, 2
  00026	66 85 c9	 test	 cx, cx
  00029	75 f5		 jne	 SHORT $LL141@operator
  0002b	2b c6		 sub	 eax, esi
  0002d	d1 f8		 sar	 eax, 1
$LN10@operator:
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  00032	50		 push	 eax
  00033	52		 push	 edx
  00034	6a 00		 push	 0
  00036	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
  0003b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0003e	33 c9		 xor	 ecx, ecx
  00040	50		 push	 eax
  00041	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00048	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004f	66 89 0e	 mov	 WORD PTR [esi], cx
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi

; 2419 : 	}

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W$$QAV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ?reset@?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAEXPAUSendExceptionFunctor@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?reset@?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAEXPAUSendExceptionFunctor@GostCrypt@@@Z PROC ; std::auto_ptr<GostCrypt::SendExceptionFunctor>::reset, COMDAT
; _this$ = ecx

; 793  : 		{	// destroy designated object and store new pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 794  : 		if (_Ptr != _Myptr)

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  0000a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000c	3b f9		 cmp	 edi, ecx
  0000e	74 0a		 je	 SHORT $LN7@reset

; 795  : 			delete _Myptr;

  00010	85 c9		 test	 ecx, ecx
  00012	74 06		 je	 SHORT $LN7@reset
  00014	8b 01		 mov	 eax, DWORD PTR [ecx]
  00016	6a 01		 push	 1
  00018	ff 10		 call	 DWORD PTR [eax]
$LN7@reset:

; 796  : 		_Myptr = _Ptr;

  0001a	89 3e		 mov	 DWORD PTR [esi], edi
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi

; 797  : 		}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?reset@?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAEXPAUSendExceptionFunctor@GostCrypt@@@Z ENDP ; std::auto_ptr<GostCrypt::SendExceptionFunctor>::reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ?release@?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAEPAUSendExceptionFunctor@GostCrypt@@XZ
_TEXT	SEGMENT
?release@?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAEPAUSendExceptionFunctor@GostCrypt@@XZ PROC ; std::auto_ptr<GostCrypt::SendExceptionFunctor>::release, COMDAT
; _this$ = ecx

; 787  : 		_Ty *_Tmp = _Myptr;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 788  : 		_Myptr = 0;

  00002	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 789  : 		return (_Tmp);
; 790  : 		}

  00008	c3		 ret	 0
?release@?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAEPAUSendExceptionFunctor@GostCrypt@@XZ ENDP ; std::auto_ptr<GostCrypt::SendExceptionFunctor>::release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ?get@?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QBEPAUSendExceptionFunctor@GostCrypt@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QBEPAUSendExceptionFunctor@GostCrypt@@XZ PROC ; std::auto_ptr<GostCrypt::SendExceptionFunctor>::get, COMDAT
; _this$ = ecx

; 782  : 		return (_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 783  : 		}

  00002	c3		 ret	 0
?get@?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QBEPAUSendExceptionFunctor@GostCrypt@@XZ ENDP ; std::auto_ptr<GostCrypt::SendExceptionFunctor>::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??D?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QBEAAUSendExceptionFunctor@GostCrypt@@XZ
_TEXT	SEGMENT
??D?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QBEAAUSendExceptionFunctor@GostCrypt@@XZ PROC ; std::auto_ptr<GostCrypt::SendExceptionFunctor>::operator*, COMDAT
; _this$ = ecx

; 762  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 763  : 		if (_Myptr == 0)
; 764  : 			_DEBUG_ERROR("auto_ptr not dereferencable");
; 765  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 766  : 
; 767  : 		return (*get());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 768  : 		}

  00002	c3		 ret	 0
??D?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QBEAAUSendExceptionFunctor@GostCrypt@@XZ ENDP ; std::auto_ptr<GostCrypt::SendExceptionFunctor>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??1?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAE@XZ PROC ; std::auto_ptr<GostCrypt::SendExceptionFunctor>::~auto_ptr<GostCrypt::SendExceptionFunctor>, COMDAT
; _this$ = ecx

; 757  : 		delete _Myptr;

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	85 c9		 test	 ecx, ecx
  00004	74 06		 je	 SHORT $LN3@auto_ptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	6a 01		 push	 1
  0000a	ff 10		 call	 DWORD PTR [eax]
$LN3@auto_ptr:

; 758  : 		}

  0000c	c3		 ret	 0
??1?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAE@XZ ENDP ; std::auto_ptr<GostCrypt::SendExceptionFunctor>::~auto_ptr<GostCrypt::SendExceptionFunctor>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??4?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAEAAV01@AAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAEAAV01@AAV01@@Z PROC ; std::auto_ptr<GostCrypt::SendExceptionFunctor>::operator=, COMDAT
; _this$ = ecx

; 742  : 		{	// assign compatible _Right (assume pointer)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 743  : 		reset(_Right.release());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi
  0000a	8b 38		 mov	 edi, DWORD PTR [eax]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00012	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00014	3b f9		 cmp	 edi, ecx
  00016	74 0a		 je	 SHORT $LN12@operator
  00018	85 c9		 test	 ecx, ecx
  0001a	74 06		 je	 SHORT $LN12@operator
  0001c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001e	6a 01		 push	 1
  00020	ff 10		 call	 DWORD PTR [eax]
$LN12@operator:
  00022	89 3e		 mov	 DWORD PTR [esi], edi

; 744  : 		return (*this);

  00024	8b c6		 mov	 eax, esi
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 745  : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??4?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAEAAV01@AAV01@@Z ENDP ; std::auto_ptr<GostCrypt::SendExceptionFunctor>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??0?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAE@PAUSendExceptionFunctor@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAE@PAUSendExceptionFunctor@GostCrypt@@@Z PROC ; std::auto_ptr<GostCrypt::SendExceptionFunctor>::auto_ptr<GostCrypt::SendExceptionFunctor>, COMDAT
; _this$ = ecx

; 698  : 		{	// construct from object pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 		: _Myptr(_Ptr)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 699  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAE@PAUSendExceptionFunctor@GostCrypt@@@Z ENDP ; std::auto_ptr<GostCrypt::SendExceptionFunctor>::auto_ptr<GostCrypt::SendExceptionFunctor>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ?reset@?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAEXPAUGetPinFunctor@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?reset@?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAEXPAUGetPinFunctor@GostCrypt@@@Z PROC ; std::auto_ptr<GostCrypt::GetPinFunctor>::reset, COMDAT
; _this$ = ecx

; 793  : 		{	// destroy designated object and store new pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 794  : 		if (_Ptr != _Myptr)

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  0000a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000c	3b f9		 cmp	 edi, ecx
  0000e	74 0a		 je	 SHORT $LN7@reset

; 795  : 			delete _Myptr;

  00010	85 c9		 test	 ecx, ecx
  00012	74 06		 je	 SHORT $LN7@reset
  00014	8b 01		 mov	 eax, DWORD PTR [ecx]
  00016	6a 01		 push	 1
  00018	ff 10		 call	 DWORD PTR [eax]
$LN7@reset:

; 796  : 		_Myptr = _Ptr;

  0001a	89 3e		 mov	 DWORD PTR [esi], edi
  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi

; 797  : 		}

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?reset@?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAEXPAUGetPinFunctor@GostCrypt@@@Z ENDP ; std::auto_ptr<GostCrypt::GetPinFunctor>::reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ?release@?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAEPAUGetPinFunctor@GostCrypt@@XZ
_TEXT	SEGMENT
?release@?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAEPAUGetPinFunctor@GostCrypt@@XZ PROC ; std::auto_ptr<GostCrypt::GetPinFunctor>::release, COMDAT
; _this$ = ecx

; 787  : 		_Ty *_Tmp = _Myptr;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 788  : 		_Myptr = 0;

  00002	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 789  : 		return (_Tmp);
; 790  : 		}

  00008	c3		 ret	 0
?release@?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAEPAUGetPinFunctor@GostCrypt@@XZ ENDP ; std::auto_ptr<GostCrypt::GetPinFunctor>::release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ?get@?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QBEPAUGetPinFunctor@GostCrypt@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QBEPAUGetPinFunctor@GostCrypt@@XZ PROC ; std::auto_ptr<GostCrypt::GetPinFunctor>::get, COMDAT
; _this$ = ecx

; 782  : 		return (_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 783  : 		}

  00002	c3		 ret	 0
?get@?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QBEPAUGetPinFunctor@GostCrypt@@XZ ENDP ; std::auto_ptr<GostCrypt::GetPinFunctor>::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??D?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QBEAAUGetPinFunctor@GostCrypt@@XZ
_TEXT	SEGMENT
??D?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QBEAAUGetPinFunctor@GostCrypt@@XZ PROC ; std::auto_ptr<GostCrypt::GetPinFunctor>::operator*, COMDAT
; _this$ = ecx

; 762  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 763  : 		if (_Myptr == 0)
; 764  : 			_DEBUG_ERROR("auto_ptr not dereferencable");
; 765  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 766  : 
; 767  : 		return (*get());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 768  : 		}

  00002	c3		 ret	 0
??D?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QBEAAUGetPinFunctor@GostCrypt@@XZ ENDP ; std::auto_ptr<GostCrypt::GetPinFunctor>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??1?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAE@XZ PROC ; std::auto_ptr<GostCrypt::GetPinFunctor>::~auto_ptr<GostCrypt::GetPinFunctor>, COMDAT
; _this$ = ecx

; 757  : 		delete _Myptr;

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	85 c9		 test	 ecx, ecx
  00004	74 06		 je	 SHORT $LN3@auto_ptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	6a 01		 push	 1
  0000a	ff 10		 call	 DWORD PTR [eax]
$LN3@auto_ptr:

; 758  : 		}

  0000c	c3		 ret	 0
??1?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAE@XZ ENDP ; std::auto_ptr<GostCrypt::GetPinFunctor>::~auto_ptr<GostCrypt::GetPinFunctor>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??4?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAEAAV01@AAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAEAAV01@AAV01@@Z PROC ; std::auto_ptr<GostCrypt::GetPinFunctor>::operator=, COMDAT
; _this$ = ecx

; 742  : 		{	// assign compatible _Right (assume pointer)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 743  : 		reset(_Right.release());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi
  0000a	8b 38		 mov	 edi, DWORD PTR [eax]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00012	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00014	3b f9		 cmp	 edi, ecx
  00016	74 0a		 je	 SHORT $LN12@operator
  00018	85 c9		 test	 ecx, ecx
  0001a	74 06		 je	 SHORT $LN12@operator
  0001c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001e	6a 01		 push	 1
  00020	ff 10		 call	 DWORD PTR [eax]
$LN12@operator:
  00022	89 3e		 mov	 DWORD PTR [esi], edi

; 744  : 		return (*this);

  00024	8b c6		 mov	 eax, esi
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 745  : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??4?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAEAAV01@AAV01@@Z ENDP ; std::auto_ptr<GostCrypt::GetPinFunctor>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??0?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAE@PAUGetPinFunctor@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAE@PAUGetPinFunctor@GostCrypt@@@Z PROC ; std::auto_ptr<GostCrypt::GetPinFunctor>::auto_ptr<GostCrypt::GetPinFunctor>, COMDAT
; _this$ = ecx

; 698  : 		{	// construct from object pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 		: _Myptr(_Ptr)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 699  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAE@PAUGetPinFunctor@GostCrypt@@@Z ENDP ; std::auto_ptr<GostCrypt::GetPinFunctor>::auto_ptr<GostCrypt::GetPinFunctor>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ??1Finally625@?BI@??LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z@QAE@XZ
_TEXT	SEGMENT
??1Finally625@?BI@??LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z@QAE@XZ PROC ; `GostCrypt::SecurityToken::LoginUserIfRequired'::`24'::Finally625::~Finally625, COMDAT
; _this$ = ecx

; 625  : 					finally_do_arg (string*, &pin, { burn ((void *) finally_arg->c_str(), finally_arg->size()); });

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00006	72 04		 jb	 SHORT $LN26@Finally625
  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	eb 02		 jmp	 SHORT $LN27@Finally625
$LN26@Finally625:
  0000c	8b d0		 mov	 edx, eax
$LN27@Finally625:
  0000e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00012	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00015	72 02		 jb	 SHORT $LN67@Finally625
  00017	8b 00		 mov	 eax, DWORD PTR [eax]
$LN67@Finally625:
  00019	56		 push	 esi
  0001a	8b f1		 mov	 esi, ecx
  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN76@Finally625
$LL72@Finally625:
  00020	c6 00 00	 mov	 BYTE PTR [eax], 0
  00023	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00026	83 ee 01	 sub	 esi, 1
  00029	75 f5		 jne	 SHORT $LL72@Finally625
$LN76@Finally625:
  0002b	5e		 pop	 esi
  0002c	85 c9		 test	 ecx, ecx
  0002e	74 0b		 je	 SHORT $LN78@Finally625
$LL5@Finally625:
  00030	c6 02 00	 mov	 BYTE PTR [edx], 0
  00033	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00036	83 e9 01	 sub	 ecx, 1
  00039	75 f5		 jne	 SHORT $LL5@Finally625
$LN78@Finally625:
  0003b	c3		 ret	 0
??1Finally625@?BI@??LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z@QAE@XZ ENDP ; `GostCrypt::SecurityToken::LoginUserIfRequired'::`24'::Finally625::~Finally625
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ??0Finally625@?BI@??LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
??0Finally625@?BI@??LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; `GostCrypt::SecurityToken::LoginUserIfRequired'::`24'::Finally625::Finally625, COMDAT
; _this$ = ecx

; 625  : 					finally_do_arg (string*, &pin, { burn ((void *) finally_arg->c_str(), finally_arg->size()); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0Finally625@?BI@??LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; `GostCrypt::SecurityToken::LoginUserIfRequired'::`24'::Finally625::Finally625
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
$T2 = -96						; size = 20
$T3 = -76						; size = 20
$T4 = -56						; size = 20
__Ok$ = -36						; size = 8
__Pad$ = -36						; size = 8
__State$ = -28						; size = 4
__Count$1$ = -24					; size = 4
tv1281 = -24						; size = 4
$T5 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
$T6 = 15						; size = 1
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 780  : 	{	// insert NTBS into char stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 781  : 	typedef char _Elem;
; 782  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 783  : 	ios_base::iostate _State = ios_base::goodbit;
; 784  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0002e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0
  00035	80 38 00	 cmp	 BYTE PTR [eax], 0
  00038	75 04		 jne	 SHORT $LN26@operator
  0003a	33 c9		 xor	 ecx, ecx
  0003c	eb 0e		 jmp	 SHORT $LN270@operator
$LN26@operator:
  0003e	8b c8		 mov	 ecx, eax
  00040	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL257@operator:
  00043	8a 01		 mov	 al, BYTE PTR [ecx]
  00045	41		 inc	 ecx
  00046	84 c0		 test	 al, al
  00048	75 f9		 jne	 SHORT $LL257@operator
  0004a	2b ca		 sub	 ecx, edx
$LN270@operator:

; 785  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  0004c	8b 5d 08	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  0004f	89 4d e8	 mov	 DWORD PTR __Count$1$[ebp], ecx
  00052	8b 03		 mov	 eax, DWORD PTR [ebx]
  00054	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00057	8b 7c 18 24	 mov	 edi, DWORD PTR [eax+ebx+36]
  0005b	8b 74 18 20	 mov	 esi, DWORD PTR [eax+ebx+32]
  0005f	85 ff		 test	 edi, edi
  00061	7c 17		 jl	 SHORT $LN17@operator
  00063	7f 0e		 jg	 SHORT $LN259@operator
  00065	85 f6		 test	 esi, esi
  00067	74 11		 je	 SHORT $LN17@operator
  00069	85 ff		 test	 edi, edi
  0006b	7c 0d		 jl	 SHORT $LN17@operator
  0006d	7f 04		 jg	 SHORT $LN259@operator
  0006f	3b f1		 cmp	 esi, ecx
  00071	76 07		 jbe	 SHORT $LN17@operator
$LN259@operator:
  00073	2b f1		 sub	 esi, ecx
  00075	83 df 00	 sbb	 edi, 0
  00078	eb 0e		 jmp	 SHORT $LN18@operator
$LN17@operator:
  0007a	0f 57 c0	 xorps	 xmm0, xmm0
  0007d	66 0f 13 45 dc	 movlpd	 QWORD PTR __Pad$[ebp], xmm0
  00082	8b 7d e0	 mov	 edi, DWORD PTR __Pad$[ebp+4]
  00085	8b 75 dc	 mov	 esi, DWORD PTR __Pad$[ebp]
$LN18@operator:

; 786  : 		? 0 : _Ostr.width() - _Count;
; 787  : 	const typename _Myos::sentry _Ok(_Ostr);

  00088	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  0008c	89 5d dc	 mov	 DWORD PTR __Ok$[ebp], ebx
  0008f	85 c9		 test	 ecx, ecx
  00091	74 05		 je	 SHORT $LN39@operator
  00093	8b 01		 mov	 eax, DWORD PTR [ecx]
  00095	ff 50 04	 call	 DWORD PTR [eax+4]
$LN39@operator:
  00098	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000a1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a4	83 7c 18 0c 00	 cmp	 DWORD PTR [eax+ebx+12], 0
  000a9	75 11		 jne	 SHORT $LN35@operator
  000ab	8b 4c 18 3c	 mov	 ecx, DWORD PTR [eax+ebx+60]
  000af	85 c9		 test	 ecx, ecx
  000b1	74 09		 je	 SHORT $LN35@operator
  000b3	3b cb		 cmp	 ecx, ebx
  000b5	74 05		 je	 SHORT $LN35@operator
  000b7	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN35@operator:
  000bc	8b 03		 mov	 eax, DWORD PTR [ebx]
  000be	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c1	83 7c 19 0c 00	 cmp	 DWORD PTR [ecx+ebx+12], 0
  000c6	0f 94 c0	 sete	 al
  000c9	88 45 e0	 mov	 BYTE PTR __Ok$[ebp+4], al
  000cc	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 788  : 
; 789  : 	if (!_Ok)

  000d3	84 c0		 test	 al, al
  000d5	75 0a		 jne	 SHORT $LN8@operator

; 790  : 		_State |= ios_base::badbit;

  000d7	b9 04 00 00 00	 mov	 ecx, 4

; 791  : 	else

  000dc	e9 56 01 00 00	 jmp	 $LN22@operator
$LN8@operator:

; 792  : 		{	// state okay, insert
; 793  : 		_TRY_IO_BEGIN
; 794  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000e1	8b 44 19 14	 mov	 eax, DWORD PTR [ecx+ebx+20]
  000e5	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000ea	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000ee	83 f8 40	 cmp	 eax, 64			; 00000040H
  000f1	74 6b		 je	 SHORT $LN254@operator
$LL4@operator:

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000f3	85 ff		 test	 edi, edi
  000f5	7c 5f		 jl	 SHORT $LN3@operator
  000f7	7f 04		 jg	 SHORT $LN260@operator
  000f9	85 f6		 test	 esi, esi
  000fb	74 59		 je	 SHORT $LN3@operator
$LN260@operator:

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

  000fd	8b 03		 mov	 eax, DWORD PTR [ebx]
  000ff	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00102	8a 4c 18 40	 mov	 cl, BYTE PTR [eax+ebx+64]
  00106	88 4d ef	 mov	 BYTE PTR $T5[ebp], cl
  00109	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  0010d	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00110	83 38 00	 cmp	 DWORD PTR [eax], 0
  00113	74 20		 je	 SHORT $LN69@operator
  00115	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00118	8b 02		 mov	 eax, DWORD PTR [edx]
  0011a	85 c0		 test	 eax, eax
  0011c	7e 17		 jle	 SHORT $LN69@operator
  0011e	48		 dec	 eax
  0011f	89 02		 mov	 DWORD PTR [edx], eax
  00121	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00124	8b 11		 mov	 edx, DWORD PTR [ecx]
  00126	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00129	89 01		 mov	 DWORD PTR [ecx], eax
  0012b	8a 45 ef	 mov	 al, BYTE PTR $T5[ebp]
  0012e	88 02		 mov	 BYTE PTR [edx], al
  00130	0f b6 c0	 movzx	 eax, al
  00133	eb 0a		 jmp	 SHORT $LN70@operator
$LN69@operator:
  00135	0f b6 45 ef	 movzx	 eax, BYTE PTR $T5[ebp]
  00139	8b 11		 mov	 edx, DWORD PTR [ecx]
  0013b	50		 push	 eax
  0013c	ff 52 0c	 call	 DWORD PTR [edx+12]
$LN70@operator:
  0013f	83 f8 ff	 cmp	 eax, -1
  00142	75 0a		 jne	 SHORT $LN2@operator
$LN261@operator:

; 797  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 798  : 					{	// insertion failed, quit
; 799  : 					_State |= ios_base::badbit;

  00144	b9 04 00 00 00	 mov	 ecx, 4

; 800  : 					break;

  00149	e9 96 00 00 00	 jmp	 $LN6@operator
$LN2@operator:

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  0014e	83 c6 ff	 add	 esi, -1
  00151	83 d7 ff	 adc	 edi, -1
  00154	eb 9d		 jmp	 SHORT $LL4@operator
$LN3@operator:
  00156	33 c9		 xor	 ecx, ecx

; 801  : 					}
; 802  : 
; 803  : 		if (_State == ios_base::goodbit
; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

  00158	0f 85 86 00 00
	00		 jne	 $LN6@operator
$LN254@operator:
  0015e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00160	6a 00		 push	 0
  00162	ff 75 e8	 push	 DWORD PTR __Count$1$[ebp]
  00165	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00168	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0016b	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  0016f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00171	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00174	ff d0		 call	 eax
  00176	3b 45 e8	 cmp	 eax, DWORD PTR __Count$1$[ebp]
  00179	75 c9		 jne	 SHORT $LN261@operator
  0017b	85 d2		 test	 edx, edx
  0017d	75 c5		 jne	 SHORT $LN261@operator
  0017f	90		 npad	 1
$LL263@operator:

; 805  : 			_State |= ios_base::badbit;
; 806  : 
; 807  : 		if (_State == ios_base::goodbit)
; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00180	85 ff		 test	 edi, edi
  00182	7c 5e		 jl	 SHORT $LN266@operator
  00184	7f 04		 jg	 SHORT $LN262@operator
  00186	85 f6		 test	 esi, esi
  00188	74 58		 je	 SHORT $LN266@operator
$LN262@operator:

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

  0018a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0018c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018f	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  00193	8a 54 18 40	 mov	 dl, BYTE PTR [eax+ebx+64]
  00197	88 55 0f	 mov	 BYTE PTR $T6[ebp], dl
  0019a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0019d	83 38 00	 cmp	 DWORD PTR [eax], 0
  001a0	74 23		 je	 SHORT $LN99@operator
  001a2	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  001a5	8b 00		 mov	 eax, DWORD PTR [eax]
  001a7	85 c0		 test	 eax, eax
  001a9	7e 1a		 jle	 SHORT $LN99@operator
  001ab	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  001ae	48		 dec	 eax
  001af	89 02		 mov	 DWORD PTR [edx], eax
  001b1	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  001b4	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b6	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  001b9	89 01		 mov	 DWORD PTR [ecx], eax
  001bb	8a 45 0f	 mov	 al, BYTE PTR $T6[ebp]
  001be	88 02		 mov	 BYTE PTR [edx], al
  001c0	0f b6 c0	 movzx	 eax, al
  001c3	eb 09		 jmp	 SHORT $LN100@operator
$LN99@operator:
  001c5	0f b6 c2	 movzx	 eax, dl
  001c8	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ca	50		 push	 eax
  001cb	ff 52 0c	 call	 DWORD PTR [edx+12]
$LN100@operator:
  001ce	83 f8 ff	 cmp	 eax, -1
  001d1	75 07		 jne	 SHORT $LN5@operator

; 810  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 811  : 					{	// insertion failed, quit
; 812  : 					_State |= ios_base::badbit;

  001d3	33 c9		 xor	 ecx, ecx
  001d5	83 c9 04	 or	 ecx, 4

; 813  : 					break;

  001d8	eb 0a		 jmp	 SHORT $LN6@operator
$LN5@operator:

; 805  : 			_State |= ios_base::badbit;
; 806  : 
; 807  : 		if (_State == ios_base::goodbit)
; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  001da	83 c6 ff	 add	 esi, -1
  001dd	83 d7 ff	 adc	 edi, -1
  001e0	eb 9e		 jmp	 SHORT $LL263@operator
$LN266@operator:
  001e2	33 c9		 xor	 ecx, ecx
$LN6@operator:

; 814  : 					}
; 815  : 		_Ostr.width(0);

  001e4	8b 03		 mov	 eax, DWORD PTR [ebx]
  001e6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e9	c7 44 18 20 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+32], 0
  001f1	c7 44 18 24 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+36], 0
  001f9	eb 35		 jmp	 SHORT $LN273@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 816  : 		_CATCH_IO_(_Ostr)

  001fb	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001fe	8b 01		 mov	 eax, DWORD PTR [ecx]
  00200	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00203	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  00207	03 d1		 add	 edx, ecx
  00209	83 c8 04	 or	 eax, 4
  0020c	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00210	75 03		 jne	 SHORT $LN128@operator
  00212	83 c8 04	 or	 eax, 4
$LN128@operator:
  00215	83 e0 17	 and	 eax, 23			; 00000017H
  00218	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0021b	85 42 10	 test	 DWORD PTR [edx+16], eax
  0021e	0f 85 0e 01 00
	00		 jne	 $LN131@operator
  00224	b8 00 00 00 00	 mov	 eax, $LN23@operator
  00229	c3		 ret	 0
$LN23@operator:
  0022a	8b 5d 08	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  0022d	8b 4d e4	 mov	 ecx, DWORD PTR __State$[ebp]
$LN273@operator:
  00230	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:

; 817  : 		}
; 818  : 
; 819  : 	_Ostr.setstate(_State);

  00237	8b 03		 mov	 eax, DWORD PTR [ebx]
  00239	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0023c	03 d3		 add	 edx, ebx
  0023e	85 c9		 test	 ecx, ecx
  00240	0f 84 a8 00 00
	00		 je	 $LN196@operator
  00246	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00249	0b c1		 or	 eax, ecx
  0024b	8b c8		 mov	 ecx, eax
  0024d	83 c9 04	 or	 ecx, 4
  00250	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00254	0f 45 c8	 cmovne	 ecx, eax
  00257	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0025a	83 e1 17	 and	 ecx, 23			; 00000017H
  0025d	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00260	23 c1		 and	 eax, ecx
  00262	0f 84 86 00 00
	00		 je	 $LN196@operator
  00268	a8 04		 test	 al, 4
  0026a	74 2a		 je	 SHORT $LN193@operator
  0026c	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00271	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  00276	50		 push	 eax
  00277	6a 01		 push	 1
  00279	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  0027c	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00281	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00286	8d 45 c8	 lea	 eax, DWORD PTR $T4[ebp]
  00289	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00290	50		 push	 eax
  00291	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN274@operator:
$LN193@operator:
  00296	a8 02		 test	 al, 2
  00298	74 2a		 je	 SHORT $LN195@operator
  0029a	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  0029f	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  002a4	50		 push	 eax
  002a5	6a 01		 push	 1
  002a7	8d 4d b4	 lea	 ecx, DWORD PTR $T3[ebp]
  002aa	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  002af	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  002b4	8d 45 b4	 lea	 eax, DWORD PTR $T3[ebp]
  002b7	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  002be	50		 push	 eax
  002bf	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN275@operator:
$LN195@operator:
  002c4	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  002c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  002ce	50		 push	 eax
  002cf	6a 01		 push	 1
  002d1	8d 4d a0	 lea	 ecx, DWORD PTR $T2[ebp]
  002d4	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  002d9	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  002de	8d 45 a0	 lea	 eax, DWORD PTR $T2[ebp]
  002e1	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN276@operator:
$LN196@operator:

; 820  : 	return (_Ostr);

  002ee	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  002f5	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  002fa	8b 75 dc	 mov	 esi, DWORD PTR __Ok$[ebp]
  002fd	84 c0		 test	 al, al
  002ff	75 07		 jne	 SHORT $LN237@operator
  00301	8b ce		 mov	 ecx, esi
  00303	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN237@operator:
  00308	8b 06		 mov	 eax, DWORD PTR [esi]
  0030a	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  0030e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00311	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00315	85 c9		 test	 ecx, ecx
  00317	74 05		 je	 SHORT $LN241@operator
  00319	8b 11		 mov	 edx, DWORD PTR [ecx]
  0031b	ff 52 08	 call	 DWORD PTR [edx+8]
$LN241@operator:
  0031e	8b c3		 mov	 eax, ebx

; 821  : 	}

  00320	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00323	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0032a	59		 pop	 ecx
  0032b	5f		 pop	 edi
  0032c	5e		 pop	 esi
  0032d	5b		 pop	 ebx
  0032e	8b e5		 mov	 esp, ebp
  00330	5d		 pop	 ebp
  00331	c3		 ret	 0

; 816  : 		_CATCH_IO_(_Ostr)

$LN131@operator:
  00332	6a 00		 push	 0
  00334	6a 00		 push	 0
  00336	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN277@operator:
$LN269@operator:
  0033b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00008	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$36:
  00010	e8 00 00 00 00	 call	 ___std_terminate
  00015	c3		 ret	 0
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$37:
  00016	e8 00 00 00 00	 call	 ___std_terminate
  0001b	c3		 ret	 0
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8d 71 68	 lea	 esi, DWORD PTR [ecx+104]
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  0002d	56		 push	 esi
  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  0003b	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00040	83 c4 04	 add	 esp, 4
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	5e		 pop	 esi
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8d 71 98	 lea	 esi, DWORD PTR [ecx-104]
  00026	e8 00 00 00 00	 call	 ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  0002b	8d 46 68	 lea	 eax, DWORD PTR [esi+104]
  0002e	50		 push	 eax
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00036	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  0003c	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00041	83 c4 04	 add	 esp, 4
  00044	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00048	74 0e		 je	 SHORT $LN13@scalar
  0004a	68 b0 00 00 00	 push	 176			; 000000b0H
  0004f	56		 push	 esi
  00050	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00055	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00058	8b c6		 mov	 eax, esi
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5e		 pop	 esi
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0002c	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00031	8b 7e 34	 mov	 edi, DWORD PTR [esi+52]
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  0003a	85 ff		 test	 edi, edi
  0003c	74 2a		 je	 SHORT $LN13@scalar
  0003e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00048	85 c9		 test	 ecx, ecx
  0004a	74 11		 je	 SHORT $LN19@scalar
  0004c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004e	ff 50 08	 call	 DWORD PTR [eax+8]
  00051	85 c0		 test	 eax, eax
  00053	74 08		 je	 SHORT $LN19@scalar
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b c8		 mov	 ecx, eax
  00059	6a 01		 push	 1
  0005b	ff 12		 call	 DWORD PTR [edx]
$LN19@scalar:
  0005d	6a 08		 push	 8
  0005f	57		 push	 edi
  00060	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00065	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00068	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0006c	74 0b		 je	 SHORT $LN22@scalar
  0006e	6a 44		 push	 68			; 00000044H
  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00076	83 c4 08	 add	 esp, 8
$LN22@scalar:
  00079	8b c6		 mov	 eax, esi
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z
_TEXT	SEGMENT
__Mode$ = 8						; size = 4
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate, COMDAT
; _this$ = ecx

; 354  : 		{	// convert open mode to stream state bits

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Mode$[ebp]

; 355  : 		_Strstate _State = (_Strstate)0;
; 356  : 		if (!(_Mode & ios_base::in))
; 357  : 			_State |= _Noread;
; 358  : 		if (!(_Mode & ios_base::out))

  00007	8b c3		 mov	 eax, ebx
  00009	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  00010	f7 d1		 not	 ecx
  00012	83 e1 04	 and	 ecx, 4
  00015	8b d1		 mov	 edx, ecx
  00017	83 ca 02	 or	 edx, 2
  0001a	24 02		 and	 al, 2

; 359  : 			_State |= _Constant;
; 360  : 		if (_Mode & ios_base::app)

  0001c	8b c3		 mov	 eax, ebx
  0001e	0f 45 d1	 cmovne	 edx, ecx
  00021	8b ca		 mov	 ecx, edx
  00023	83 c9 08	 or	 ecx, 8
  00026	24 08		 and	 al, 8
  00028	0f 44 ca	 cmove	 ecx, edx
  0002b	8b c1		 mov	 eax, ecx
  0002d	83 c8 10	 or	 eax, 16			; 00000010H

; 361  : 			_State |= _Append;
; 362  : 		if (_Mode & ios_base::ate)

  00030	80 e3 04	 and	 bl, 4
  00033	5b		 pop	 ebx
  00034	0f 44 c1	 cmove	 eax, ecx

; 363  : 			_State |= _Atend;
; 364  : 		return (_State);
; 365  : 		}

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 337  : 		{	// discard any allocated buffer and clear pointers

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 338  : 		if (_Mystate & _Allocated)

  00003	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  00007	74 4d		 je	 SHORT $LN25@Tidy

; 339  : 			_Al.deallocate(_Mysb::eback(),

  00009	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	85 c9		 test	 ecx, ecx
  00010	74 09		 je	 SHORT $LN4@Tidy
  00012	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00015	8b 10		 mov	 edx, DWORD PTR [eax]
  00017	03 d1		 add	 edx, ecx
  00019	eb 0a		 jmp	 SHORT $LN5@Tidy
$LN4@Tidy:
  0001b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0001e	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00021	8b 10		 mov	 edx, DWORD PTR [eax]
  00023	03 11		 add	 edx, DWORD PTR [ecx]
$LN5@Tidy:
  00025	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	2b d0		 sub	 edx, eax
  0002c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00032	72 19		 jb	 SHORT $LN20@Tidy
  00034	a8 1f		 test	 al, 31			; 0000001fH
  00036	75 61		 jne	 SHORT $LN33@Tidy
  00038	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0003b	3b c8		 cmp	 ecx, eax
  0003d	73 5f		 jae	 SHORT $LN35@Tidy
  0003f	2b c1		 sub	 eax, ecx
  00041	83 f8 04	 cmp	 eax, 4
  00044	72 5d		 jb	 SHORT $LN36@Tidy
  00046	83 f8 23	 cmp	 eax, 35			; 00000023H
  00049	77 5d		 ja	 SHORT $LN37@Tidy
  0004b	8b c1		 mov	 eax, ecx
$LN20@Tidy:
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00053	83 c4 04	 add	 esp, 4
$LN25@Tidy:

; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);

  00056	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00059	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0005f	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00062	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00068	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0006b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 343  : 		_Mysb::setp(0, 0);

  00071	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00074	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0007a	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0007d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00083	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00086	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;

  0008c	83 66 3c fe	 and	 DWORD PTR [esi+60], -2	; fffffffeH
  00090	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00097	5e		 pop	 esi

; 346  : 		}

  00098	c3		 ret	 0
$LN33@Tidy:

; 339  : 			_Al.deallocate(_Mysb::eback(),

  00099	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN38@Tidy:
$LN35@Tidy:
  0009e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN39@Tidy:
$LN36@Tidy:
  000a3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN40@Tidy:
$LN37@Tidy:
  000a8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN41@Tidy:
$LN32@Tidy:
  000ad	cc		 int	 3
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__State$ = 16						; size = 4
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init, COMDAT
; _this$ = ecx

; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 311  : 		_Seekhigh = 0;
; 312  : 		_Mystate = _State;

  00003	8b 45 10	 mov	 eax, DWORD PTR __State$[ebp]
  00006	53		 push	 ebx

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00014	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00017	85 db		 test	 ebx, ebx
  00019	74 7e		 je	 SHORT $LN2@Init
  0001b	83 e0 06	 and	 eax, 6
  0001e	3c 06		 cmp	 al, 6
  00020	74 77		 je	 SHORT $LN2@Init

; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Al.allocate(_Count);

  00022	57		 push	 edi
  00023	53		 push	 ebx
  00024	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  00027	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);

  0002c	53		 push	 ebx
  0002d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00030	8b f8		 mov	 edi, eax
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 _memcpy
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 319  : 			_Seekhigh = _Pnew + _Count;

  0003b	8d 0c 1f	 lea	 ecx, DWORD PTR [edi+ebx]

; 320  : 
; 321  : 			if (!(_Mystate & _Noread))

  0003e	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  00042	89 4e 38	 mov	 DWORD PTR [esi+56], ecx
  00045	75 0f		 jne	 SHORT $LN3@Init

; 322  : 				_Mysb::setg(_Pnew, _Pnew,

  00047	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0004a	89 38		 mov	 DWORD PTR [eax], edi
  0004c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0004f	89 38		 mov	 DWORD PTR [eax], edi
  00051	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00054	89 18		 mov	 DWORD PTR [eax], ebx
$LN3@Init:

; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))

  00056	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00059	a8 02		 test	 al, 2
  0005b	75 37		 jne	 SHORT $LN5@Init

; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,

  0005d	a8 18		 test	 al, 24			; 00000018H
  0005f	8b d7		 mov	 edx, edi
  00061	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00064	0f 45 d1	 cmovne	 edx, ecx
  00067	8b cf		 mov	 ecx, edi
  00069	2b ca		 sub	 ecx, edx
  0006b	03 cb		 add	 ecx, ebx
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00072	89 10		 mov	 DWORD PTR [eax], edx
  00074	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00077	89 08		 mov	 DWORD PTR [eax], ecx

; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)

  00079	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0007c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0007f	75 13		 jne	 SHORT $LN5@Init

; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);

  00081	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00084	89 38		 mov	 DWORD PTR [eax], edi
  00086	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00089	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0008f	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00092	89 38		 mov	 DWORD PTR [eax], edi
$LN5@Init:

; 331  : 				}
; 332  : 			_Mystate |= _Allocated;

  00094	83 4e 3c 01	 or	 DWORD PTR [esi+60], 1
  00098	5f		 pop	 edi
$LN2@Init:
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx

; 333  : 			}
; 334  : 		}

  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
tv282 = -4						; size = 4
tv235 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Ptr$ = 12						; size = 24
tv278 = 36						; size = 4
__Mode$ = 36						; size = 4
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos, COMDAT
; _this$ = ecx

; 276  : 		{	// change position to _Pos, according to _Mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 277  : 		streamoff _Off = (streamoff)_Ptr;

  00005	8b 5d 18	 mov	 ebx, DWORD PTR __Ptr$[ebp+12]
  00008	56		 push	 esi
  00009	8b 75 14	 mov	 esi, DWORD PTR __Ptr$[ebp+8]
  0000c	03 75 0c	 add	 esi, DWORD PTR __Ptr$[ebp]
  0000f	57		 push	 edi
  00010	13 5d 10	 adc	 ebx, DWORD PTR __Ptr$[ebp+4]
  00013	8b f9		 mov	 edi, ecx

; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  00015	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	85 c0		 test	 eax, eax
  0001c	74 08		 je	 SHORT $LN2@seekpos
  0001e	39 47 38	 cmp	 DWORD PTR [edi+56], eax
  00021	73 03		 jae	 SHORT $LN2@seekpos

; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  00023	89 47 38	 mov	 DWORD PTR [edi+56], eax
$LN2@seekpos:

; 280  : 
; 281  : 		if (_Off == _BADOFF)

  00026	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB+4
  0002b	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  00031	75 08		 jne	 SHORT $LN55@seekpos
  00033	3b d8		 cmp	 ebx, eax
  00035	0f 84 c0 00 00
	00		 je	 $LN11@seekpos
$LN55@seekpos:

; 282  : 			;
; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

  0003b	8b 4d 24	 mov	 ecx, DWORD PTR __Mode$[ebp]
  0003e	f6 c1 01	 test	 cl, 1
  00041	74 74		 je	 SHORT $LN5@seekpos
  00043	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 45 fc	 mov	 DWORD PTR tv235[ebp], eax
  0004b	85 c0		 test	 eax, eax
  0004d	74 63		 je	 SHORT $LN60@seekpos

; 284  : 			{	// position within read buffer
; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0004f	85 db		 test	 ebx, ebx
  00051	7c 57		 jl	 SHORT $LN7@seekpos
  00053	7f 04		 jg	 SHORT $LN56@seekpos
  00055	85 f6		 test	 esi, esi
  00057	72 51		 jb	 SHORT $LN7@seekpos
$LN56@seekpos:
  00059	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00061	2b c1		 sub	 eax, ecx
  00063	99		 cdq
  00064	3b da		 cmp	 ebx, edx
  00066	7f 42		 jg	 SHORT $LN7@seekpos
  00068	7c 04		 jl	 SHORT $LN57@seekpos
  0006a	3b f0		 cmp	 esi, eax
  0006c	77 3c		 ja	 SHORT $LN7@seekpos
$LN57@seekpos:

; 286  : 				{	// change read position
; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  0006e	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00071	2b 4d fc	 sub	 ecx, DWORD PTR tv235[ebp]
  00074	03 ce		 add	 ecx, esi
  00076	29 08		 sub	 DWORD PTR [eax], ecx
  00078	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0007b	01 08		 add	 DWORD PTR [eax], ecx

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  0007d	f6 45 24 02	 test	 BYTE PTR __Mode$[ebp], 2
  00081	74 78		 je	 SHORT $LN11@seekpos
  00083	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00086	8b 00		 mov	 eax, DWORD PTR [eax]
  00088	89 45 24	 mov	 DWORD PTR tv278[ebp], eax
  0008b	85 c0		 test	 eax, eax
  0008d	74 6c		 je	 SHORT $LN11@seekpos

; 289  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),

  0008f	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00092	8b 10		 mov	 edx, DWORD PTR [eax]
  00094	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  00097	8b 08		 mov	 ecx, DWORD PTR [eax]
  00099	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0009c	03 4d 24	 add	 ecx, DWORD PTR tv278[ebp]
  0009f	2b ca		 sub	 ecx, edx
  000a1	89 10		 mov	 DWORD PTR [eax], edx
  000a3	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000a6	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 						_Mysb::epptr());	// change write position to match
; 291  : 				}
; 292  : 			else

  000a8	eb 51		 jmp	 SHORT $LN11@seekpos
$LN7@seekpos:

; 293  : 				_Off = _BADOFF;

  000aa	8b 1d 04 00 00
	00		 mov	 ebx, DWORD PTR ?_BADOFF@std@@3_JB+4
  000b0	eb 43		 jmp	 SHORT $LN61@seekpos
$LN60@seekpos:
  000b2	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB+4
$LN5@seekpos:

; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  000b7	f6 c1 02	 test	 cl, 2
  000ba	74 37		 je	 SHORT $LN10@seekpos
  000bc	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000bf	74 32		 je	 SHORT $LN10@seekpos

; 296  : 			{	// position within write buffer
; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  000c1	85 db		 test	 ebx, ebx
  000c3	7c e5		 jl	 SHORT $LN7@seekpos
  000c5	7f 04		 jg	 SHORT $LN58@seekpos
  000c7	85 f6		 test	 esi, esi
  000c9	72 df		 jb	 SHORT $LN7@seekpos
$LN58@seekpos:
  000cb	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d0	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  000d3	2b c1		 sub	 eax, ecx
  000d5	99		 cdq
  000d6	3b da		 cmp	 ebx, edx
  000d8	7f d0		 jg	 SHORT $LN7@seekpos
  000da	7c 04		 jl	 SHORT $LN59@seekpos
  000dc	3b f0		 cmp	 esi, eax
  000de	77 ca		 ja	 SHORT $LN7@seekpos
$LN59@seekpos:

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

  000e0	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  000e3	2b 08		 sub	 ecx, DWORD PTR [eax]
  000e5	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000e8	03 ce		 add	 ecx, esi
  000ea	29 08		 sub	 DWORD PTR [eax], ecx
  000ec	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  000ef	01 08		 add	 DWORD PTR [eax], ecx

; 299  : 					- _Mysb::pptr() + _Off));	// change write position
; 300  : 			else

  000f1	eb 08		 jmp	 SHORT $LN11@seekpos
$LN10@seekpos:

; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  000f3	8b d8		 mov	 ebx, eax
$LN61@seekpos:
  000f5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
$LN11@seekpos:

; 305  : 		return (streampos(_Off));

  000fb	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000fe	0f 57 c0	 xorps	 xmm0, xmm0
  00101	5f		 pop	 edi
  00102	89 30		 mov	 DWORD PTR [eax], esi
  00104	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00107	5e		 pop	 esi
  00108	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0010f	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00116	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  0011b	5b		 pop	 ebx

; 306  : 		}

  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
tv265 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
tv276 = 20						; size = 4
__Way$ = 20						; size = 4
tv271 = 24						; size = 4
tv270 = 24						; size = 4
__Which$ = 24						; size = 4
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff, COMDAT
; _this$ = ecx

; 227  : 		{	// change position by _Off, according to _Way, _Mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  00009	8b 53 20	 mov	 edx, DWORD PTR [ebx+32]
  0000c	8b 02		 mov	 eax, DWORD PTR [edx]
  0000e	85 c0		 test	 eax, eax
  00010	74 08		 je	 SHORT $LN2@seekoff
  00012	39 43 38	 cmp	 DWORD PTR [ebx+56], eax
  00015	73 03		 jae	 SHORT $LN2@seekoff

; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  00017	89 43 38	 mov	 DWORD PTR [ebx+56], eax
$LN2@seekoff:

; 230  : 
; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

  0001a	8b 4d 18	 mov	 ecx, DWORD PTR __Which$[ebp]
  0001d	f6 c1 01	 test	 cl, 1
  00020	0f 84 d9 00 00
	00		 je	 $LN3@seekoff
  00026	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00029	8b 30		 mov	 esi, DWORD PTR [eax]
  0002b	89 75 fc	 mov	 DWORD PTR tv265[ebp], esi
  0002e	85 f6		 test	 esi, esi
  00030	0f 84 c9 00 00
	00		 je	 $LN3@seekoff

; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)

  00036	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  00039	83 f8 02	 cmp	 eax, 2
  0003c	75 15		 jne	 SHORT $LN5@seekoff

; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  0003e	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00041	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00044	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00047	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0004a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0004c	99		 cdq
  0004d	03 f0		 add	 esi, eax
  0004f	13 fa		 adc	 edi, edx

; 235  : 			else if (_Way == ios_base::cur

  00051	eb 36		 jmp	 SHORT $LN9@seekoff
$LN5@seekoff:

; 236  : 				&& (_Which & ios_base::out) == 0)

  00053	83 f8 01	 cmp	 eax, 1
  00056	75 19		 jne	 SHORT $LN7@seekoff
  00058	f6 c1 02	 test	 cl, 2
  0005b	75 18		 jne	 SHORT $LN74@seekoff

; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());

  0005d	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00060	8b c6		 mov	 eax, esi
  00062	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00065	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00068	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006a	99		 cdq
  0006b	03 f0		 add	 esi, eax
  0006d	13 fa		 adc	 edi, edx
  0006f	eb 18		 jmp	 SHORT $LN9@seekoff
$LN7@seekoff:

; 238  : 			else if (_Way != ios_base::beg)

  00071	85 c0		 test	 eax, eax
  00073	74 0e		 je	 SHORT $LN79@seekoff
$LN74@seekoff:

; 239  : 				_Off = _BADOFF;

  00075	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  0007b	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_BADOFF@std@@3_JB+4
  00081	eb 06		 jmp	 SHORT $LN9@seekoff
$LN79@seekoff:
  00083	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00086	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
$LN9@seekoff:

; 240  : 
; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00089	85 ff		 test	 edi, edi
  0008b	0f 8c 0a 01 00
	00		 jl	 $LN10@seekoff
  00091	7f 08		 jg	 SHORT $LN75@seekoff
  00093	85 f6		 test	 esi, esi
  00095	0f 82 00 01 00
	00		 jb	 $LN10@seekoff
$LN75@seekoff:
  0009b	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  000a3	2b c1		 sub	 eax, ecx
  000a5	99		 cdq
  000a6	3b fa		 cmp	 edi, edx
  000a8	0f 8f ed 00 00
	00		 jg	 $LN10@seekoff
  000ae	7c 08		 jl	 SHORT $LN76@seekoff
  000b0	3b f0		 cmp	 esi, eax
  000b2	0f 87 e3 00 00
	00		 ja	 $LN10@seekoff
$LN76@seekoff:

; 242  : 				{	// change read position
; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  000b8	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  000bb	2b 4d fc	 sub	 ecx, DWORD PTR tv265[ebp]
  000be	03 ce		 add	 ecx, esi
  000c0	29 08		 sub	 DWORD PTR [eax], ecx
  000c2	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  000c5	01 08		 add	 DWORD PTR [eax], ecx

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000c7	f6 45 18 02	 test	 BYTE PTR __Which$[ebp], 2
  000cb	0f 84 d6 00 00
	00		 je	 $LN22@seekoff
  000d1	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  000d4	8b 00		 mov	 eax, DWORD PTR [eax]
  000d6	89 45 18	 mov	 DWORD PTR tv271[ebp], eax
  000d9	85 c0		 test	 eax, eax
  000db	0f 84 c6 00 00
	00		 je	 $LN22@seekoff

; 245  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),

  000e1	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  000e4	8b 10		 mov	 edx, DWORD PTR [eax]
  000e6	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  000e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000eb	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  000ee	03 4d 18	 add	 ecx, DWORD PTR tv271[ebp]
  000f1	2b ca		 sub	 ecx, edx
  000f3	89 10		 mov	 DWORD PTR [eax], edx
  000f5	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  000f8	89 08		 mov	 DWORD PTR [eax], ecx

; 246  : 						_Mysb::epptr());	// change write position to match
; 247  : 				}
; 248  : 			else

  000fa	e9 a8 00 00 00	 jmp	 $LN22@seekoff
$LN3@seekoff:

; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000ff	f6 c1 02	 test	 cl, 2
  00102	0f 84 87 00 00
	00		 je	 $LN13@seekoff
  00108	8b 12		 mov	 edx, DWORD PTR [edx]
  0010a	89 55 18	 mov	 DWORD PTR tv270[ebp], edx
  0010d	85 d2		 test	 edx, edx
  0010f	74 7e		 je	 SHORT $LN13@seekoff

; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)

  00111	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  00114	83 f8 02	 cmp	 eax, 2
  00117	75 15		 jne	 SHORT $LN15@seekoff

; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  00119	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0011c	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  0011f	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00122	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00125	2b 01		 sub	 eax, DWORD PTR [ecx]
  00127	99		 cdq
  00128	03 f0		 add	 esi, eax
  0012a	13 fa		 adc	 edi, edx
  0012c	eb 31		 jmp	 SHORT $LN19@seekoff
$LN15@seekoff:

; 255  : 			else if (_Way == ios_base::cur)

  0012e	83 f8 01	 cmp	 eax, 1
  00131	75 14		 jne	 SHORT $LN17@seekoff

; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());

  00133	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00136	8b c2		 mov	 eax, edx
  00138	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  0013b	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0013e	2b 01		 sub	 eax, DWORD PTR [ecx]
  00140	99		 cdq
  00141	03 f0		 add	 esi, eax
  00143	13 fa		 adc	 edi, edx
  00145	eb 18		 jmp	 SHORT $LN19@seekoff
$LN17@seekoff:

; 257  : 			else if (_Way != ios_base::beg)

  00147	85 c0		 test	 eax, eax
  00149	74 0e		 je	 SHORT $LN80@seekoff

; 258  : 				_Off = _BADOFF;

  0014b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  00151	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_BADOFF@std@@3_JB+4
  00157	eb 06		 jmp	 SHORT $LN19@seekoff
$LN80@seekoff:
  00159	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0015c	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
$LN19@seekoff:

; 259  : 
; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0015f	85 ff		 test	 edi, edi
  00161	7c 38		 jl	 SHORT $LN10@seekoff
  00163	7f 04		 jg	 SHORT $LN77@seekoff
  00165	85 f6		 test	 esi, esi
  00167	72 32		 jb	 SHORT $LN10@seekoff
$LN77@seekoff:
  00169	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0016c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016e	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00171	2b c1		 sub	 eax, ecx
  00173	99		 cdq
  00174	3b fa		 cmp	 edi, edx
  00176	7f 23		 jg	 SHORT $LN10@seekoff
  00178	7c 04		 jl	 SHORT $LN78@seekoff
  0017a	3b f0		 cmp	 esi, eax
  0017c	77 1d		 ja	 SHORT $LN10@seekoff
$LN78@seekoff:

; 261  : 				_Mysb::pbump((int)(_Mysb::eback()

  0017e	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  00181	2b 4d 18	 sub	 ecx, DWORD PTR tv270[ebp]
  00184	03 ce		 add	 ecx, esi
  00186	29 08		 sub	 DWORD PTR [eax], ecx
  00188	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  0018b	01 08		 add	 DWORD PTR [eax], ecx

; 262  : 					- _Mysb::pptr() + _Off));	// change write position
; 263  : 			else

  0018d	eb 18		 jmp	 SHORT $LN22@seekoff
$LN13@seekoff:

; 264  : 				_Off = _BADOFF;
; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)

  0018f	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00192	8b c6		 mov	 eax, esi
  00194	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00197	0b c7		 or	 eax, edi
  00199	74 0c		 je	 SHORT $LN22@seekoff
$LN10@seekoff:

; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  0019b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  001a1	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_BADOFF@std@@3_JB+4
$LN22@seekoff:

; 271  : 		return (pos_type(_Off));

  001a7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001aa	0f 57 c0	 xorps	 xmm0, xmm0
  001ad	89 78 04	 mov	 DWORD PTR [eax+4], edi
  001b0	5f		 pop	 edi
  001b1	89 30		 mov	 DWORD PTR [eax], esi
  001b3	5e		 pop	 esi
  001b4	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  001bb	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  001c2	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  001c7	5b		 pop	 ebx

; 272  : 		}

  001c8	8b e5		 mov	 esp, ebp
  001ca	5d		 pop	 ebp
  001cb	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow, COMDAT
; _this$ = ecx

; 207  : 		{	// get an element from stream, but don't point past it

  00000	56		 push	 esi

; 208  : 		if (_Mysb::gptr() == 0)

  00001	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]
  00004	8b 16		 mov	 edx, DWORD PTR [esi]
  00006	85 d2		 test	 edx, edx
  00008	75 05		 jne	 SHORT $LN2@underflow

; 209  : 			return (_Traits::eof());	// no character buffer, fail

  0000a	83 c8 ff	 or	 eax, -1
  0000d	5e		 pop	 esi

; 221  : 			}
; 222  : 		}

  0000e	c3		 ret	 0
$LN2@underflow:
  0000f	57		 push	 edi

; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())

  00010	8b 79 2c	 mov	 edi, DWORD PTR [ecx+44]
  00013	8b 07		 mov	 eax, DWORD PTR [edi]
  00015	03 c2		 add	 eax, edx
  00017	3b d0		 cmp	 edx, eax
  00019	73 06		 jae	 SHORT $LN4@underflow

; 211  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered

  0001b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 221  : 			}
; 222  : 		}

  00020	c3		 ret	 0
$LN4@underflow:

; 212  : 		else if (_Mystate & _Noread || _Mysb::pptr() == 0
; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

  00021	f6 41 3c 04	 test	 BYTE PTR [ecx+60], 4
  00025	75 2c		 jne	 SHORT $LN8@underflow
  00027	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0002a	8b 00		 mov	 eax, DWORD PTR [eax]
  0002c	85 c0		 test	 eax, eax
  0002e	74 23		 je	 SHORT $LN8@underflow
  00030	3b c2		 cmp	 eax, edx
  00032	77 05		 ja	 SHORT $LN6@underflow
  00034	39 51 38	 cmp	 DWORD PTR [ecx+56], edx
  00037	76 1a		 jbe	 SHORT $LN8@underflow
$LN6@underflow:

; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())

  00039	39 41 38	 cmp	 DWORD PTR [ecx+56], eax
  0003c	73 03		 jae	 SHORT $LN9@underflow

; 218  : 				_Seekhigh = _Mysb::pptr();

  0003e	89 41 38	 mov	 DWORD PTR [ecx+56], eax
$LN9@underflow:

; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);

  00041	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00044	2b 06		 sub	 eax, DWORD PTR [esi]
  00046	89 07		 mov	 DWORD PTR [edi], eax

; 220  : 			return (_Traits::to_int_type(*_Mysb::gptr()));

  00048	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	8b 00		 mov	 eax, DWORD PTR [eax]
  0004f	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 221  : 			}
; 222  : 		}

  00052	c3		 ret	 0
$LN8@underflow:
  00053	5f		 pop	 edi

; 214  : 			return (_Traits::eof());	// can't read, fail

  00054	83 c8 ff	 or	 eax, -1
  00057	5e		 pop	 esi

; 221  : 			}
; 222  : 		}

  00058	c3		 ret	 0
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail, COMDAT
; _this$ = ecx

; 190  : 		{	// put an element back to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx
  00005	56		 push	 esi

; 191  : 		if (_Mysb::gptr() == 0
; 192  : 			|| _Mysb::gptr() <= _Mysb::eback()
; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  00006	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00009	8b 30		 mov	 esi, DWORD PTR [eax]
  0000b	85 f6		 test	 esi, esi
  0000d	74 40		 je	 SHORT $LN4@pbackfail
  0000f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00012	3b 30		 cmp	 esi, DWORD PTR [eax]
  00014	76 39		 jbe	 SHORT $LN4@pbackfail
  00016	8b 4d 08	 mov	 ecx, DWORD PTR __Meta$[ebp]
  00019	83 f9 ff	 cmp	 ecx, -1
  0001c	74 0b		 je	 SHORT $LN2@pbackfail
  0001e	3a 4e ff	 cmp	 cl, BYTE PTR [esi-1]
  00021	74 06		 je	 SHORT $LN2@pbackfail
  00023	f6 42 3c 02	 test	 BYTE PTR [edx+60], 2
  00027	75 26		 jne	 SHORT $LN4@pbackfail
$LN2@pbackfail:

; 197  : 		else
; 198  : 			{	// back up one position and store put-back character
; 199  : 			_Mysb::gbump(-1);

  00029	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0002c	ff 00		 inc	 DWORD PTR [eax]
  0002e	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00031	ff 08		 dec	 DWORD PTR [eax]

; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))

  00033	83 f9 ff	 cmp	 ecx, -1
  00036	74 0e		 je	 SHORT $LN45@pbackfail

; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);

  00038	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0003b	5e		 pop	 esi
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	88 08		 mov	 BYTE PTR [eax], cl

; 202  : 			return (_Traits::not_eof(_Meta));

  00040	8b c1		 mov	 eax, ecx

; 203  : 			}
; 204  : 		}

  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4

; 202  : 			return (_Traits::not_eof(_Meta));

$LN45@pbackfail:
  00046	33 c9		 xor	 ecx, ecx
  00048	8b c1		 mov	 eax, ecx
  0004a	5e		 pop	 esi

; 203  : 			}
; 204  : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
$LN4@pbackfail:

; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail

  0004f	83 c8 ff	 or	 eax, -1
  00052	5e		 pop	 esi

; 203  : 			}
; 204  : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
tv598 = -8						; size = 4
__Newsize$1$ = -8					; size = 4
__Oldptr$1$ = -4					; size = 4
__Meta$ = 8						; size = 4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow, COMDAT
; _this$ = ecx

; 120  : 		{	// put an element to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 121  : 		if (_Mystate & _Constant)

  00009	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0000c	a8 02		 test	 al, 2
  0000e	74 0a		 je	 SHORT $LN4@overflow

; 122  : 			return (_Traits::eof());	// array nonmutable, fail

  00010	83 c8 ff	 or	 eax, -1
  00013	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN4@overflow:
  0001a	53		 push	 ebx

; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  0001b	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]
  0001e	83 fb ff	 cmp	 ebx, -1
  00021	75 0a		 jne	 SHORT $LN6@overflow

; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  00023	5b		 pop	 ebx
  00024	33 c0		 xor	 eax, eax
  00026	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
$LN6@overflow:
  0002d	57		 push	 edi

; 125  : 
; 126  : 		if (_Mystate & _Append
; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

  0002e	a8 08		 test	 al, 8
  00030	74 23		 je	 SHORT $LN7@overflow
  00032	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00035	8b 10		 mov	 edx, DWORD PTR [eax]
  00037	85 d2		 test	 edx, edx
  00039	74 1a		 je	 SHORT $LN7@overflow
  0003b	8b 7e 38	 mov	 edi, DWORD PTR [esi+56]
  0003e	3b d7		 cmp	 edx, edi
  00040	73 13		 jae	 SHORT $LN7@overflow

; 128  : 			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());

  00042	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00045	8b 08		 mov	 ecx, DWORD PTR [eax]
  00047	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0004a	03 ca		 add	 ecx, edx
  0004c	2b cf		 sub	 ecx, edi
  0004e	89 38		 mov	 DWORD PTR [eax], edi
  00050	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@overflow:

; 129  : 
; 130  : 		if (_Mysb::pptr() != 0
; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

  00055	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	85 d2		 test	 edx, edx
  0005c	74 2a		 je	 SHORT $LN119@overflow
  0005e	8b 7e 30	 mov	 edi, DWORD PTR [esi+48]
  00061	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00063	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00066	3b d0		 cmp	 edx, eax
  00068	73 1a		 jae	 SHORT $LN8@overflow

; 132  : 			{	// room in buffer, store it
; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  0006a	49		 dec	 ecx

; 134  : 			return (_Meta);

  0006b	8b c3		 mov	 eax, ebx
  0006d	89 0f		 mov	 DWORD PTR [edi], ecx
  0006f	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00072	5f		 pop	 edi
  00073	8b 32		 mov	 esi, DWORD PTR [edx]
  00075	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00078	89 0a		 mov	 DWORD PTR [edx], ecx
  0007a	88 1e		 mov	 BYTE PTR [esi], bl
  0007c	5b		 pop	 ebx
  0007d	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
$LN8@overflow:

; 135  : 			}
; 136  : 		else
; 137  : 			{	// grow buffer and store element
; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

  00084	85 d2		 test	 edx, edx
  00086	75 04		 jne	 SHORT $LN20@overflow
$LN119@overflow:
  00088	33 ff		 xor	 edi, edi
  0008a	eb 0c		 jmp	 SHORT $LN21@overflow
$LN20@overflow:
  0008c	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0008f	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00092	8b 38		 mov	 edi, DWORD PTR [eax]
  00094	2b 39		 sub	 edi, DWORD PTR [ecx]
  00096	03 fa		 add	 edi, edx
$LN21@overflow:

; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE

  00098	8b cf		 mov	 ecx, edi
  0009a	d1 e9		 shr	 ecx, 1
  0009c	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0009f	73 07		 jae	 SHORT $LN22@overflow
  000a1	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000a6	eb 08		 jmp	 SHORT $LL2@overflow
$LN22@overflow:

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  000a8	85 c9		 test	 ecx, ecx
  000aa	74 17		 je	 SHORT $LN121@overflow
  000ac	0f 1f 40 00	 npad	 4
$LL2@overflow:
  000b0	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000b5	2b c1		 sub	 eax, ecx
  000b7	3b c7		 cmp	 eax, edi
  000b9	73 04		 jae	 SHORT $LN114@overflow

; 145  : 				_Inc /= 2;	// increment causes overflow, halve it

  000bb	d1 e9		 shr	 ecx, 1

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  000bd	75 f1		 jne	 SHORT $LL2@overflow
$LN114@overflow:

; 146  : 			if (_Inc == 0)

  000bf	85 c9		 test	 ecx, ecx
  000c1	75 0c		 jne	 SHORT $LN10@overflow
$LN121@overflow:
  000c3	5f		 pop	 edi
  000c4	5b		 pop	 ebx

; 147  : 				return (_Traits::eof());	// buffer can't grow, fail

  000c5	83 c8 ff	 or	 eax, -1
  000c8	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 04 00	 ret	 4
$LN10@overflow:

; 148  : 
; 149  : 			_Newsize += _Inc;

  000cf	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]

; 150  : 
; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);

  000d2	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  000d5	89 45 f8	 mov	 DWORD PTR __Newsize$1$[ebp], eax
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 152  : 			_Elem *_Oldptr = _Mysb::eback();

  000de	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  000e1	8b d8		 mov	 ebx, eax
  000e3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000e5	89 4d fc	 mov	 DWORD PTR __Oldptr$1$[ebp], ecx

; 153  : 
; 154  : 			if (0 < _Oldsize)

  000e8	85 ff		 test	 edi, edi
  000ea	74 12		 je	 SHORT $LN123@overflow

; 155  : 				_Traits::copy(_Newptr, _Oldptr, _Oldsize);

  000ec	57		 push	 edi
  000ed	51		 push	 ecx
  000ee	53		 push	 ebx
  000ef	e8 00 00 00 00	 call	 _memcpy
  000f4	8b 4d fc	 mov	 ecx, DWORD PTR __Oldptr$1$[ebp]
  000f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 156  : 
; 157  : 			if (_Oldsize == 0)

  000fa	85 ff		 test	 edi, edi
  000fc	75 3d		 jne	 SHORT $LN12@overflow
$LN123@overflow:

; 158  : 				{	// first growth, set up pointers
; 159  : 				_Seekhigh = _Newptr;
; 160  : 				_Mysb::setp(_Newptr, _Newptr + _Newsize);

  000fe	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00101	8b 55 f8	 mov	 edx, DWORD PTR __Newsize$1$[ebp]
  00104	89 5e 38	 mov	 DWORD PTR [esi+56], ebx
  00107	89 18		 mov	 DWORD PTR [eax], ebx
  00109	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0010c	89 18		 mov	 DWORD PTR [eax], ebx
  0010e	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00111	89 10		 mov	 DWORD PTR [eax], edx

; 161  : 				if (_Mystate & _Noread)
; 162  : 					_Mysb::setg(_Newptr, 0, _Newptr);

  00113	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00116	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  0011a	89 18		 mov	 DWORD PTR [eax], ebx
  0011c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0011f	74 0d		 je	 SHORT $LN14@overflow
  00121	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00127	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0012a	89 18		 mov	 DWORD PTR [eax], ebx

; 163  : 				else

  0012c	eb 74		 jmp	 SHORT $LN17@overflow
$LN14@overflow:

; 164  : 					_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);

  0012e	89 18		 mov	 DWORD PTR [eax], ebx
  00130	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00133	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 165  : 				}
; 166  : 			else

  00139	eb 67		 jmp	 SHORT $LN17@overflow
$LN12@overflow:

; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);

  0013b	8b c3		 mov	 eax, ebx
  0013d	2b c1		 sub	 eax, ecx
  0013f	01 46 38	 add	 DWORD PTR [esi+56], eax

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

  00142	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00145	8b 10		 mov	 edx, DWORD PTR [eax]
  00147	8b c3		 mov	 eax, ebx
  00149	2b 45 fc	 sub	 eax, DWORD PTR __Oldptr$1$[ebp]
  0014c	2b d1		 sub	 edx, ecx
  0014e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00151	03 d3		 add	 edx, ebx
  00153	01 01		 add	 DWORD PTR [ecx], eax
  00155	8b cb		 mov	 ecx, ebx
  00157	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0015a	2b ca		 sub	 ecx, edx
  0015c	03 4d f8	 add	 ecx, DWORD PTR __Newsize$1$[ebp]
  0015f	89 10		 mov	 DWORD PTR [eax], edx
  00161	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00164	89 08		 mov	 DWORD PTR [eax], ecx

; 170  : 					_Newptr + (_Mysb::pptr() - _Oldptr),
; 171  : 					_Newptr + _Newsize);
; 172  : 				if (_Mystate & _Noread)

  00166	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  0016a	74 15		 je	 SHORT $LN16@overflow

; 173  : 					_Mysb::setg(_Newptr, 0, _Newptr);

  0016c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0016f	89 18		 mov	 DWORD PTR [eax], ebx
  00171	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00174	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0017a	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0017d	89 18		 mov	 DWORD PTR [eax], ebx

; 174  : 				else

  0017f	eb 21		 jmp	 SHORT $LN17@overflow
$LN16@overflow:

; 175  : 					_Mysb::setg(_Newptr,

  00181	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00184	8b 10		 mov	 edx, DWORD PTR [eax]
  00186	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00189	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0018e	2b 4d fc	 sub	 ecx, DWORD PTR __Oldptr$1$[ebp]
  00191	03 cb		 add	 ecx, ebx
  00193	2b d1		 sub	 edx, ecx
  00195	89 18		 mov	 DWORD PTR [eax], ebx
  00197	42		 inc	 edx
  00198	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0019b	89 08		 mov	 DWORD PTR [eax], ecx
  0019d	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  001a0	89 10		 mov	 DWORD PTR [eax], edx
$LN17@overflow:

; 176  : 						_Newptr + (_Mysb::gptr() - _Oldptr),
; 177  : 						_Mysb::pptr() + 1);
; 178  : 				}
; 179  : 
; 180  : 			if (_Mystate & _Allocated)

  001a2	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  001a6	74 0c		 je	 SHORT $LN18@overflow

; 181  : 				_Al.deallocate(_Oldptr, _Oldsize);

  001a8	57		 push	 edi
  001a9	ff 75 fc	 push	 DWORD PTR __Oldptr$1$[ebp]
  001ac	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  001af	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate
$LN18@overflow:

; 182  : 			_Mystate |= _Allocated;
; 183  : 
; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  001b4	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  001b7	83 4e 3c 01	 or	 DWORD PTR [esi+60], 1
  001bb	5f		 pop	 edi
  001bc	5b		 pop	 ebx
  001bd	ff 08		 dec	 DWORD PTR [eax]
  001bf	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  001c2	5e		 pop	 esi
  001c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c5	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  001c8	89 01		 mov	 DWORD PTR [ecx], eax
  001ca	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  001cd	88 02		 mov	 BYTE PTR [edx], al

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  001cf	8b e5		 mov	 esp, ebp
  001d1	5d		 pop	 ebp
  001d2	c2 04 00	 ret	 4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -32						; size = 4
__Nul$2 = -28						; size = 24
__Str$3 = -28						; size = 24
__Str$4 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT
; _this$ = ecx

; 93   : 		{	// return string copy of character array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b d1		 mov	 edx, ecx
  00012	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00019	56		 push	 esi
  0001a	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  0001d	8b 4a 3c	 mov	 ecx, DWORD PTR [edx+60]
  00020	f6 c1 02	 test	 cl, 2
  00023	75 7c		 jne	 SHORT $LN2@str
  00025	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	85 c0		 test	 eax, eax
  0002c	74 73		 je	 SHORT $LN2@str

; 95   : 			{	// writable, make string from write buffer
; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  0002e	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  00031	3b c8		 cmp	 ecx, eax
  00033	0f 42 c8	 cmovb	 ecx, eax
  00036	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	2b c8		 sub	 ecx, eax
  0003d	51		 push	 ecx
  0003e	50		 push	 eax
  0003f	8d 4d e4	 lea	 ecx, DWORD PTR __Str$4[ebp]
  00042	c7 45 f8 0f 00
	00 00		 mov	 DWORD PTR __Str$4[ebp+20], 15 ; 0000000fH
  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Str$4[ebp+16], 0
  00050	c6 45 e4 00	 mov	 BYTE PTR __Str$4[ebp], 0
  00054	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
; 98   : 			return (_Str);

  00059	8d 45 e4	 lea	 eax, DWORD PTR __Str$4[ebp]
  0005c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00063	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0006a	8b ce		 mov	 ecx, esi
  0006c	50		 push	 eax
  0006d	c6 06 00	 mov	 BYTE PTR [esi], 0
  00070	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00075	8b 4d f8	 mov	 ecx, DWORD PTR __Str$4[ebp+20]
  00078	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0007b	0f 82 9f 00 00
	00		 jb	 $LN261@str
  00081	41		 inc	 ecx
  00082	51		 push	 ecx
  00083	ff 75 e4	 push	 DWORD PTR __Str$4[ebp]
  00086	8d 4d e4	 lea	 ecx, DWORD PTR __Str$4[ebp]
  00089	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate

; 108  : 			return (_Nul);

  0008e	8b c6		 mov	 eax, esi
  00090	5e		 pop	 esi

; 109  : 			}
; 110  : 		}

  00091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00094	33 cd		 xor	 ecx, ebp
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 04 00	 ret	 4
$LN2@str:
  000a1	57		 push	 edi

; 99   : 			}
; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  000a2	f6 c1 04	 test	 cl, 4
  000a5	75 35		 jne	 SHORT $LN4@str
  000a7	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000aa	8b 38		 mov	 edi, DWORD PTR [eax]
  000ac	85 ff		 test	 edi, edi
  000ae	74 2c		 je	 SHORT $LN4@str

; 101  : 			{	// readable, make string from read buffer
; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());

  000b0	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000b8	03 cf		 add	 ecx, edi
  000ba	8b 00		 mov	 eax, DWORD PTR [eax]
  000bc	2b c8		 sub	 ecx, eax
  000be	51		 push	 ecx
  000bf	50		 push	 eax
  000c0	8d 4d e4	 lea	 ecx, DWORD PTR __Str$3[ebp]
  000c3	c7 45 f8 0f 00
	00 00		 mov	 DWORD PTR __Str$3[ebp+20], 15 ; 0000000fH
  000ca	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Str$3[ebp+16], 0
  000d1	c6 45 e4 00	 mov	 BYTE PTR __Str$3[ebp], 0
  000d5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 103  : 			return (_Str);

  000da	eb 12		 jmp	 SHORT $LN1032@str
$LN4@str:

; 104  : 			}
; 105  : 		else
; 106  : 			{	// inaccessible, return empty string
; 107  : 			_Mystr _Nul;

  000dc	c7 45 f8 0f 00
	00 00		 mov	 DWORD PTR __Nul$2[ebp+20], 15 ; 0000000fH
  000e3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Nul$2[ebp+16], 0
  000ea	c6 45 e4 00	 mov	 BYTE PTR __Nul$2[ebp], 0
$LN1032@str:

; 108  : 			return (_Nul);

  000ee	8d 45 e4	 lea	 eax, DWORD PTR __Nul$2[ebp]
  000f1	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  000f8	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000ff	8b ce		 mov	 ecx, esi
  00101	50		 push	 eax
  00102	c6 06 00	 mov	 BYTE PTR [esi], 0
  00105	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0010a	8b 45 f8	 mov	 eax, DWORD PTR __Nul$2[ebp+20]
  0010d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00110	72 0d		 jb	 SHORT $LN934@str
  00112	40		 inc	 eax
  00113	8d 4d e4	 lea	 ecx, DWORD PTR __Nul$2[ebp]
  00116	50		 push	 eax
  00117	ff 75 e4	 push	 DWORD PTR __Nul$2[ebp]
  0011a	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN934@str:
  0011f	5f		 pop	 edi

; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
; 98   : 			return (_Str);

$LN261@str:

; 109  : 			}
; 110  : 		}

  00120	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00123	8b c6		 mov	 eax, esi
  00125	33 cd		 xor	 ecx, ebp
  00127	5e		 pop	 esi
  00128	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c2 04 00	 ret	 4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 75   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 76   : 		_Tidy();

  0002b	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 77   : 		}

  00030	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  00036	8b 76 34	 mov	 esi, DWORD PTR [esi+52]
  00039	85 f6		 test	 esi, esi
  0003b	74 2a		 je	 SHORT $LN9@basic_stri
  0003d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	85 c9		 test	 ecx, ecx
  00049	74 11		 je	 SHORT $LN15@basic_stri
  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	ff 50 08	 call	 DWORD PTR [eax+8]
  00050	85 c0		 test	 eax, eax
  00052	74 08		 je	 SHORT $LN15@basic_stri
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	8b c8		 mov	 ecx, eax
  00058	6a 01		 push	 1
  0005a	ff 12		 call	 DWORD PTR [edx]
$LN15@basic_stri:
  0005c	6a 08		 push	 8
  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00064	83 c4 08	 add	 esp, 8
$LN9@basic_stri:
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00071	59		 pop	 ecx
  00072	5e		 pop	 esi
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$ = 8						; size = 4
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 28   : 	explicit basic_stringbuf(ios_base::openmode _Mode =

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode

  0002a	e8 00 00 00 00	 call	 ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
  0002f	8b 5d 08	 mov	 ebx, DWORD PTR __Mode$[ebp]

; 31   : 		_Init(0, 0, _Getstate(_Mode));

  00032	8b c3		 mov	 eax, ebx
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0003a	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00041	8d 14 9d 00 00
	00 00		 lea	 edx, DWORD PTR [ebx*4]
  00048	f7 d2		 not	 edx
  0004a	83 e2 04	 and	 edx, 4
  0004d	8b ca		 mov	 ecx, edx
  0004f	83 c9 02	 or	 ecx, 2
  00052	24 02		 and	 al, 2
  00054	8b c3		 mov	 eax, ebx
  00056	0f 45 ca	 cmovne	 ecx, edx
  00059	8b d1		 mov	 edx, ecx
  0005b	83 ca 08	 or	 edx, 8
  0005e	24 08		 and	 al, 8
  00060	0f 44 d1	 cmove	 edx, ecx
  00063	8b c2		 mov	 eax, edx
  00065	83 c8 10	 or	 eax, 16			; 00000010H
  00068	80 e3 04	 and	 bl, 4
  0006b	0f 44 c2	 cmove	 eax, edx
  0006e	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 32   : 		}

  00071	8b c6		 mov	 eax, esi
  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	8b 7e 34	 mov	 edi, DWORD PTR [esi+52]
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  0002f	85 ff		 test	 edi, edi
  00031	74 2a		 je	 SHORT $LN10@scalar
  00033	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	85 c9		 test	 ecx, ecx
  0003f	74 11		 je	 SHORT $LN16@scalar
  00041	8b 01		 mov	 eax, DWORD PTR [ecx]
  00043	ff 50 08	 call	 DWORD PTR [eax+8]
  00046	85 c0		 test	 eax, eax
  00048	74 08		 je	 SHORT $LN16@scalar
  0004a	8b 10		 mov	 edx, DWORD PTR [eax]
  0004c	8b c8		 mov	 ecx, eax
  0004e	6a 01		 push	 1
  00050	ff 12		 call	 DWORD PTR [edx]
$LN16@scalar:
  00052	6a 08		 push	 8
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0005a	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0005d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00061	74 0b		 je	 SHORT $LN19@scalar
  00063	6a 38		 push	 56			; 00000038H
  00065	56		 push	 esi
  00066	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006b	83 c4 08	 add	 esp, 8
$LN19@scalar:
  0006e	8b c6		 mov	 eax, esi
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 449  : 		}

  00000	c2 04 00	 ret	 4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 444  : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 445  : 		}

  00002	c3		 ret	 0
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 439  : 		return (this);

  00000	8b c1		 mov	 eax, ecx

; 440  : 		}

  00002	c2 0c 00	 ret	 12			; 0000000cH
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 433  : 		{	// change to specified position, according to mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 434  : 		return (streampos(_BADOFF));

  00003	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB
  0000e	89 02		 mov	 DWORD PTR [edx], eax
  00010	8b c2		 mov	 eax, edx
  00012	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3_JB+4
  00018	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0001b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00022	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  00029	66 0f d6 42 10	 movq	 QWORD PTR [edx+16], xmm0

; 435  : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 8
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 427  : 		{	// change position by offset, according to way and mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  : 		return (streampos(_BADOFF));

  00003	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB
  0000e	89 02		 mov	 DWORD PTR [edx], eax
  00010	8b c2		 mov	 eax, edx
  00012	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3_JB+4
  00018	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0001b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00022	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  00029	66 0f d6 42 10	 movq	 QWORD PTR [edx+16], xmm0

; 429  : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
_TEXT	SEGMENT
__Copied$ = -16						; size = 8
__Size$2$ = -12						; size = 4
_this$1$ = -8						; size = 4
__Copied$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
__Copied$2$ = 16					; size = 4
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn, COMDAT
; _this$ = ecx

; 397  : 		{	// put _Count characters to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 398  : 		streamsize _Size, _Copied;
; 399  : 
; 400  : 		for (_Copied = 0; 0 < _Count; )

  00007	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp+4]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  00010	66 0f 13 45 f0	 movlpd	 QWORD PTR __Copied$[ebp], xmm0
  00015	57		 push	 edi
  00016	85 db		 test	 ebx, ebx
  00018	0f 8c c0 00 00
	00		 jl	 $LN38@xsputn
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00021	7f 08		 jg	 SHORT $LN37@xsputn
  00023	85 ff		 test	 edi, edi
  00025	0f 84 b3 00 00
	00		 je	 $LN38@xsputn
$LN37@xsputn:
  0002b	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  00031	89 55 10	 mov	 DWORD PTR __Copied$2$[ebp], edx
  00034	89 45 fc	 mov	 DWORD PTR __Copied$1$[ebp], eax
  00037	56		 push	 esi
$LL2@xsputn:

; 401  : 			if (0 < (_Size = _Pnavail()))

  00038	e8 00 00 00 00	 call	 ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
  0003d	8b f0		 mov	 esi, eax
  0003f	8b c2		 mov	 eax, edx
  00041	89 45 f4	 mov	 DWORD PTR __Size$2$[ebp], eax
  00044	85 c0		 test	 eax, eax
  00046	7c 4c		 jl	 SHORT $LN5@xsputn
  00048	7f 04		 jg	 SHORT $LN33@xsputn
  0004a	85 f6		 test	 esi, esi
  0004c	74 46		 je	 SHORT $LN5@xsputn
$LN33@xsputn:

; 402  : 				{	// copy to write buffer
; 403  : 				if (_Count < _Size)

  0004e	3b d8		 cmp	 ebx, eax
  00050	7f 0b		 jg	 SHORT $LN7@xsputn
  00052	7c 04		 jl	 SHORT $LN34@xsputn
  00054	3b fe		 cmp	 edi, esi
  00056	73 05		 jae	 SHORT $LN7@xsputn
$LN34@xsputn:

; 404  : 					_Size = _Count;

  00058	8b f7		 mov	 esi, edi
  0005a	89 5d f4	 mov	 DWORD PTR __Size$2$[ebp], ebx
$LN7@xsputn:

; 405  : 				_Traits::copy(pptr(), _Ptr, (size_t)_Size);

  0005d	85 f6		 test	 esi, esi
  0005f	74 14		 je	 SHORT $LN16@xsputn
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00064	56		 push	 esi
  00065	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00068	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0006b	ff 30		 push	 DWORD PTR [eax]
  0006d	e8 00 00 00 00	 call	 _memcpy
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@xsputn:

; 406  : 				_Ptr += _Size;

  00075	01 75 08	 add	 DWORD PTR __Ptr$[ebp], esi

; 407  : 				_Copied += _Size;

  00078	01 75 fc	 add	 DWORD PTR __Copied$1$[ebp], esi
  0007b	8b 45 f4	 mov	 eax, DWORD PTR __Size$2$[ebp]
  0007e	11 45 10	 adc	 DWORD PTR __Copied$2$[ebp], eax

; 408  : 				_Count -= _Size;

  00081	2b fe		 sub	 edi, esi

; 409  : 				pbump((int)_Size);

  00083	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00086	1b d8		 sbb	 ebx, eax
  00088	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0008b	29 30		 sub	 DWORD PTR [eax], esi
  0008d	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00090	01 30		 add	 DWORD PTR [eax], esi
  00092	eb 29		 jmp	 SHORT $LN9@xsputn
$LN5@xsputn:

; 410  : 				}
; 411  : 			else if (_Traits::eq_int_type(_Traits::eof(),

  00094	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00097	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  0009a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009c	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0009f	50		 push	 eax
  000a0	ff 52 0c	 call	 DWORD PTR [edx+12]
  000a3	83 f8 ff	 cmp	 eax, -1
  000a6	74 27		 je	 SHORT $LN40@xsputn

; 412  : 				overflow(_Traits::to_int_type(*_Ptr))))
; 413  : 				break;	// single character put failed, quit
; 414  : 			else
; 415  : 				{	// count character successfully put
; 416  : 				++_Ptr;

  000a8	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000ab	46		 inc	 esi

; 417  : 				++_Copied;

  000ac	83 45 fc 01	 add	 DWORD PTR __Copied$1$[ebp], 1
  000b0	89 75 08	 mov	 DWORD PTR __Ptr$[ebp], esi
  000b3	83 55 10 00	 adc	 DWORD PTR __Copied$2$[ebp], 0

; 418  : 				--_Count;

  000b7	83 c7 ff	 add	 edi, -1
  000ba	83 d3 ff	 adc	 ebx, -1
$LN9@xsputn:

; 398  : 		streamsize _Size, _Copied;
; 399  : 
; 400  : 		for (_Copied = 0; 0 < _Count; )

  000bd	85 db		 test	 ebx, ebx
  000bf	0f 8f 73 ff ff
	ff		 jg	 $LL2@xsputn
  000c5	7c 08		 jl	 SHORT $LN40@xsputn
  000c7	85 ff		 test	 edi, edi
  000c9	0f 85 69 ff ff
	ff		 jne	 $LL2@xsputn
$LN40@xsputn:
  000cf	8b 55 10	 mov	 edx, DWORD PTR __Copied$2$[ebp]
  000d2	8b 45 fc	 mov	 eax, DWORD PTR __Copied$1$[ebp]
  000d5	5e		 pop	 esi
  000d6	5f		 pop	 edi
  000d7	5b		 pop	 ebx

; 419  : 				}
; 420  : 
; 421  : 		return (_Copied);
; 422  : 		}

  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c2 0c 00	 ret	 12			; 0000000cH
$LN38@xsputn:

; 398  : 		streamsize _Size, _Copied;
; 399  : 
; 400  : 		for (_Copied = 0; 0 < _Count; )

  000de	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  000e1	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  000e4	5f		 pop	 edi
  000e5	5b		 pop	 ebx

; 419  : 				}
; 420  : 
; 421  : 		return (_Copied);
; 422  : 		}

  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 0c 00	 ret	 12			; 0000000cH
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
_TEXT	SEGMENT
__Copied$ = -16						; size = 8
__Size$2$ = -12						; size = 4
_this$1$ = -8						; size = 4
__Copied$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
__Copied$2$ = 16					; size = 4
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn, COMDAT
; _this$ = ecx

; 368  : 		{	// get _Count characters from stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 369  : 		int_type _Meta;
; 370  : 		streamsize _Size, _Copied;
; 371  : 
; 372  : 		for (_Copied = 0; 0 < _Count; )

  00007	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp+4]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  00010	66 0f 13 45 f0	 movlpd	 QWORD PTR __Copied$[ebp], xmm0
  00015	57		 push	 edi
  00016	85 db		 test	 ebx, ebx
  00018	0f 8c be 00 00
	00		 jl	 $LN38@xsgetn
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00021	7f 08		 jg	 SHORT $LN37@xsgetn
  00023	85 ff		 test	 edi, edi
  00025	0f 84 b1 00 00
	00		 je	 $LN38@xsgetn
$LN37@xsgetn:
  0002b	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  00031	89 55 10	 mov	 DWORD PTR __Copied$2$[ebp], edx
  00034	89 45 fc	 mov	 DWORD PTR __Copied$1$[ebp], eax
  00037	56		 push	 esi
$LL2@xsgetn:

; 373  : 			if (0 < (_Size = _Gnavail()))

  00038	e8 00 00 00 00	 call	 ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
  0003d	8b f0		 mov	 esi, eax
  0003f	8b c2		 mov	 eax, edx
  00041	89 45 f4	 mov	 DWORD PTR __Size$2$[ebp], eax
  00044	85 c0		 test	 eax, eax
  00046	7c 4c		 jl	 SHORT $LN5@xsgetn
  00048	7f 04		 jg	 SHORT $LN33@xsgetn
  0004a	85 f6		 test	 esi, esi
  0004c	74 46		 je	 SHORT $LN5@xsgetn
$LN33@xsgetn:

; 374  : 				{	// copy from read buffer
; 375  : 				if (_Count < _Size)

  0004e	3b d8		 cmp	 ebx, eax
  00050	7f 0b		 jg	 SHORT $LN7@xsgetn
  00052	7c 04		 jl	 SHORT $LN34@xsgetn
  00054	3b fe		 cmp	 edi, esi
  00056	73 05		 jae	 SHORT $LN7@xsgetn
$LN34@xsgetn:

; 376  : 					_Size = _Count;

  00058	8b f7		 mov	 esi, edi
  0005a	89 5d f4	 mov	 DWORD PTR __Size$2$[ebp], ebx
$LN7@xsgetn:

; 377  : 				_Traits::copy(_Ptr, gptr(), (size_t)_Size);

  0005d	85 f6		 test	 esi, esi
  0005f	74 14		 je	 SHORT $LN16@xsgetn
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00064	56		 push	 esi
  00065	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00068	ff 30		 push	 DWORD PTR [eax]
  0006a	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0006d	e8 00 00 00 00	 call	 _memcpy
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@xsgetn:

; 378  : 				_Ptr += _Size;

  00075	01 75 08	 add	 DWORD PTR __Ptr$[ebp], esi

; 379  : 				_Copied += _Size;

  00078	01 75 fc	 add	 DWORD PTR __Copied$1$[ebp], esi
  0007b	8b 45 f4	 mov	 eax, DWORD PTR __Size$2$[ebp]
  0007e	11 45 10	 adc	 DWORD PTR __Copied$2$[ebp], eax

; 380  : 				_Count -= _Size;

  00081	2b fe		 sub	 edi, esi

; 381  : 				gbump((int)_Size);

  00083	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00086	1b d8		 sbb	 ebx, eax
  00088	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0008b	29 30		 sub	 DWORD PTR [eax], esi
  0008d	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00090	01 30		 add	 DWORD PTR [eax], esi
  00092	eb 27		 jmp	 SHORT $LN9@xsgetn
$LN5@xsgetn:

; 382  : 				}
; 383  : 			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  00094	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00097	8b 01		 mov	 eax, DWORD PTR [ecx]
  00099	ff 50 1c	 call	 DWORD PTR [eax+28]
  0009c	83 f8 ff	 cmp	 eax, -1
  0009f	74 2c		 je	 SHORT $LN40@xsgetn

; 384  : 				break;	// end of file, quit
; 385  : 			else
; 386  : 				{	// get a single character
; 387  : 				*_Ptr++ = _Traits::to_char_type(_Meta);

  000a1	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000a4	88 01		 mov	 BYTE PTR [ecx], al
  000a6	41		 inc	 ecx

; 388  : 				++_Copied;

  000a7	83 45 fc 01	 add	 DWORD PTR __Copied$1$[ebp], 1
  000ab	89 4d 08	 mov	 DWORD PTR __Ptr$[ebp], ecx
  000ae	83 55 10 00	 adc	 DWORD PTR __Copied$2$[ebp], 0

; 389  : 				--_Count;

  000b2	83 c7 ff	 add	 edi, -1
  000b5	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000b8	83 d3 ff	 adc	 ebx, -1
$LN9@xsgetn:

; 369  : 		int_type _Meta;
; 370  : 		streamsize _Size, _Copied;
; 371  : 
; 372  : 		for (_Copied = 0; 0 < _Count; )

  000bb	85 db		 test	 ebx, ebx
  000bd	0f 8f 75 ff ff
	ff		 jg	 $LL2@xsgetn
  000c3	7c 08		 jl	 SHORT $LN40@xsgetn
  000c5	85 ff		 test	 edi, edi
  000c7	0f 85 6b ff ff
	ff		 jne	 $LL2@xsgetn
$LN40@xsgetn:
  000cd	8b 55 10	 mov	 edx, DWORD PTR __Copied$2$[ebp]
  000d0	8b 45 fc	 mov	 eax, DWORD PTR __Copied$1$[ebp]
  000d3	5e		 pop	 esi
  000d4	5f		 pop	 edi
  000d5	5b		 pop	 ebx

; 390  : 				}
; 391  : 
; 392  : 		return (_Copied);
; 393  : 		}

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 0c 00	 ret	 12			; 0000000cH
$LN38@xsgetn:

; 369  : 		int_type _Meta;
; 370  : 		streamsize _Size, _Copied;
; 371  : 
; 372  : 		for (_Copied = 0; 0 < _Count; )

  000dc	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  000df	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  000e2	5f		 pop	 edi
  000e3	5b		 pop	 ebx

; 390  : 				}
; 391  : 
; 392  : 		return (_Copied);
; 393  : 		}

  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 0c 00	 ret	 12			; 0000000cH
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 361  : 		{	// get a character from stream, point past it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 362  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 50 18	 call	 DWORD PTR [eax+24]
  00008	83 f8 ff	 cmp	 eax, -1
  0000b	75 04		 jne	 SHORT $LN3@uflow
  0000d	0b c0		 or	 eax, eax
  0000f	5e		 pop	 esi

; 363  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
; 364  : 		}

  00010	c3		 ret	 0
$LN3@uflow:

; 362  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())

  00011	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00014	ff 08		 dec	 DWORD PTR [eax]
  00016	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00019	5e		 pop	 esi
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0001f	89 01		 mov	 DWORD PTR [ecx], eax
  00021	0f b6 02	 movzx	 eax, BYTE PTR [edx]

; 363  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
; 364  : 		}

  00024	c3		 ret	 0
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::uflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 357  : 		return (_Traits::eof());

  00000	83 c8 ff	 or	 eax, -1

; 358  : 		}

  00003	c3		 ret	 0
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
_TEXT	SEGMENT
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc, COMDAT
; _this$ = ecx

; 352  : 		return (0);

  00000	33 c0		 xor	 eax, eax
  00002	33 d2		 xor	 edx, edx

; 353  : 		}

  00004	c3		 ret	 0
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 347  : 		return (_Traits::eof());

  00000	83 c8 ff	 or	 eax, -1

; 348  : 		}

  00003	c2 04 00	 ret	 4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 342  : 		return (_Traits::eof());

  00000	83 c8 ff	 or	 eax, -1

; 343  : 		}

  00003	c2 04 00	 ret	 4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 319  : 		_IGfirst = &_Gfirst;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 320  : 		_IPfirst = &_Pfirst;

  00006	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]

; 321  : 		_IGnext = &_Gnext;

  00009	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]
  0000c	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000f	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 322  : 		_IPnext = &_Pnext;

  00012	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00015	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 323  : 		_IGcount = &_Gcount;

  00018	8d 41 24	 lea	 eax, DWORD PTR [ecx+36]
  0001b	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 324  : 		_IPcount = &_Pcount;

  0001e	8d 41 28	 lea	 eax, DWORD PTR [ecx+40]
  00021	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 325  : 		setp(0, 0);

  00024	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0002a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00033	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00036	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 326  : 		setg(0, 0, 0);

  0003c	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00045	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00048	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0004e	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 327  : 		}

  00057	c3		 ret	 0
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT
; _this$ = ecx

; 314  : 		return (*_IPnext != 0 ? *_IPcount : 0);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 07		 je	 SHORT $LN3@Pnavail
  00008	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	99		 cdq

; 315  : 		}

  0000e	c3		 ret	 0
$LN3@Pnavail:

; 314  : 		return (*_IPnext != 0 ? *_IPcount : 0);

  0000f	33 c0		 xor	 eax, eax
  00011	99		 cdq

; 315  : 		}

  00012	c3		 ret	 0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 308  : 		--*_IPcount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 309  : 		return ((*_IPnext)++);

  00005	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00008	8b 02		 mov	 eax, DWORD PTR [edx]
  0000a	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0000d	89 0a		 mov	 DWORD PTR [edx], ecx

; 310  : 		}

  0000f	c3		 ret	 0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Next$ = 12						; size = 4
__Last$ = 16						; size = 4
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setp, COMDAT
; _this$ = ecx

; 300  : 		{	// set pointers for write buffer, extended version

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 301  : 		*_IPfirst = _First;

  00003	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi

; 302  : 		*_IPnext = _Next;
; 303  : 		*_IPcount = (int)(_Last - _Next);

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	89 02		 mov	 DWORD PTR [edx], eax
  0000f	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00012	8b 55 0c	 mov	 edx, DWORD PTR __Next$[ebp]
  00015	2b f2		 sub	 esi, edx
  00017	89 10		 mov	 DWORD PTR [eax], edx
  00019	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0001c	89 30		 mov	 DWORD PTR [eax], esi
  0001e	5e		 pop	 esi

; 304  : 		}

  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setp, COMDAT
; _this$ = ecx

; 293  : 		{	// set pointers for write buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 294  : 		*_IPfirst = _First;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 295  : 		*_IPnext = _First;
; 296  : 		*_IPcount = (int)(_Last - _First);

  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b d6		 sub	 edx, esi
  0000f	89 30		 mov	 DWORD PTR [eax], esi
  00011	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00014	89 30		 mov	 DWORD PTR [eax], esi
  00016	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00019	5e		 pop	 esi
  0001a	89 10		 mov	 DWORD PTR [eax], edx

; 297  : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbump, COMDAT
; _this$ = ecx

; 287  : 		{	// alter current position in write buffer by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 288  : 		*_IPcount -= _Off;

  00003	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00009	29 10		 sub	 DWORD PTR [eax], edx

; 289  : 		*_IPnext += _Off;

  0000b	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0000e	01 10		 add	 DWORD PTR [eax], edx

; 290  : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail, COMDAT
; _this$ = ecx

; 283  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 07		 je	 SHORT $LN3@Gnavail
  00008	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	99		 cdq

; 284  : 		}

  0000e	c3		 ret	 0
$LN3@Gnavail:

; 283  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  0000f	33 c0		 xor	 eax, eax
  00011	99		 cdq

; 284  : 		}

  00012	c3		 ret	 0
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT
; _this$ = ecx

; 271  : 		--*_IGcount;

  00000	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 272  : 		return ((*_IGnext)++);

  00005	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00008	8b 02		 mov	 eax, DWORD PTR [edx]
  0000a	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0000d	89 0a		 mov	 DWORD PTR [edx], ecx

; 273  : 		}

  0000f	c3		 ret	 0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::epptr, COMDAT
; _this$ = ecx

; 260  : 		return (*_IPnext + *_IPcount);

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	03 01		 add	 eax, DWORD PTR [ecx]

; 261  : 		}

  0000a	c3		 ret	 0
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::epptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Next$ = 12						; size = 4
__Last$ = 16						; size = 4
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setg, COMDAT
; _this$ = ecx

; 252  : 		{	// set pointers for read buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 253  : 		*_IGfirst = _First;

  00003	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi

; 254  : 		*_IGnext = _Next;
; 255  : 		*_IGcount = (int)(_Last - _Next);

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	89 02		 mov	 DWORD PTR [edx], eax
  0000f	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00012	8b 55 0c	 mov	 edx, DWORD PTR __Next$[ebp]
  00015	2b f2		 sub	 esi, edx
  00017	89 10		 mov	 DWORD PTR [eax], edx
  00019	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0001c	89 30		 mov	 DWORD PTR [eax], esi
  0001e	5e		 pop	 esi

; 256  : 		}

  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::gbump, COMDAT
; _this$ = ecx

; 246  : 		{	// alter current position in read buffer by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 247  : 		*_IGcount -= _Off;

  00003	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00009	29 10		 sub	 DWORD PTR [eax], edx

; 248  : 		*_IGnext += _Off;

  0000b	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0000e	01 10		 add	 DWORD PTR [eax], edx

; 249  : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gbump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::egptr, COMDAT
; _this$ = ecx

; 242  : 		return (*_IGnext + *_IGcount);

  00000	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00003	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	03 01		 add	 eax, DWORD PTR [ecx]

; 243  : 		}

  0000a	c3		 ret	 0
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::egptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pptr, COMDAT
; _this$ = ecx

; 237  : 		return (*_IPnext);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 238  : 		}

  00005	c3		 ret	 0
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbase, COMDAT
; _this$ = ecx

; 232  : 		return (*_IPfirst);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 233  : 		}

  00005	c3		 ret	 0
?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT
; _this$ = ecx

; 227  : 		return (*_IGnext);

  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 228  : 		}

  00005	c3		 ret	 0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::eback, COMDAT
; _this$ = ecx

; 222  : 		return (*_IGfirst);

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 223  : 		}

  00005	c3		 ret	 0
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::eback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 217  : 		}

  00000	c3		 ret	 0
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 213  : 		}

  00000	c3		 ret	 0
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputn, COMDAT
; _this$ = ecx

; 207  : 		{	// put _Count characters from array beginning at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (xsputn(_Ptr, _Count));

  00003	ff 75 10	 push	 DWORD PTR __Count$[ebp+4]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000e	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00011	ff d0		 call	 eax

; 209  : 		}

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT
; _this$ = ecx

; 199  : 		{	// put a character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 200  : 		return (0 < _Pnavail()

  00003	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00006	83 38 00	 cmp	 DWORD PTR [eax], 0
  00009	74 22		 je	 SHORT $LN3@sputc
  0000b	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0000e	8b 02		 mov	 eax, DWORD PTR [edx]
  00010	85 c0		 test	 eax, eax
  00012	7e 19		 jle	 SHORT $LN3@sputc
  00014	48		 dec	 eax
  00015	89 02		 mov	 DWORD PTR [edx], eax
  00017	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0001f	89 01		 mov	 DWORD PTR [ecx], eax
  00021	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]
  00024	88 02		 mov	 BYTE PTR [edx], al
  00026	0f b6 c0	 movzx	 eax, al

; 201  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 202  : 			: overflow(_Traits::to_int_type(_Ch)));
; 203  : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
$LN3@sputc:

; 200  : 		return (0 < _Pnavail()

  0002d	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00031	8b 11		 mov	 edx, DWORD PTR [ecx]
  00033	89 45 08	 mov	 DWORD PTR __Ch$[ebp], eax

; 201  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 202  : 			: overflow(_Traits::to_int_type(_Ch)));
; 203  : 		}

  00036	5d		 pop	 ebp

; 200  : 		return (0 < _Pnavail()

  00037	ff 62 0c	 jmp	 DWORD PTR [edx+12]
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 145  : 		return (sync());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 34	 jmp	 DWORD PTR [eax+52]
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 79   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 80   : 		delete _Plocale;

  00023	8b 71 34	 mov	 esi, DWORD PTR [ecx+52]
  00026	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  0002c	85 f6		 test	 esi, esi
  0002e	74 2a		 je	 SHORT $LN6@basic_stre
  00030	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	85 c9		 test	 ecx, ecx
  0003c	74 11		 je	 SHORT $LN12@basic_stre
  0003e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00040	ff 50 08	 call	 DWORD PTR [eax+8]
  00043	85 c0		 test	 eax, eax
  00045	74 08		 je	 SHORT $LN12@basic_stre
  00047	8b 10		 mov	 edx, DWORD PTR [eax]
  00049	8b c8		 mov	 ecx, eax
  0004b	6a 01		 push	 1
  0004d	ff 12		 call	 DWORD PTR [edx]
$LN12@basic_stre:
  0004f	6a 08		 push	 8
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00057	83 c4 08	 add	 esp, 8
$LN6@basic_stre:

; 81   : 		}

  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5e		 pop	 esi
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 26   : 		{	// construct with no buffers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 25   : 		: _Plocale(new locale)

  00026	6a 08		 push	 8

; 26   : 		{	// construct with no buffers

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	8b f8		 mov	 edi, eax
  00035	83 c4 04	 add	 esp, 4
  00038	85 ff		 test	 edi, edi
  0003a	74 16		 je	 SHORT $LN3@basic_stre

; 25   : 		: _Plocale(new locale)

  0003c	6a 01		 push	 1
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00050	eb 02		 jmp	 SHORT $LN4@basic_stre
$LN3@basic_stre:
  00052	33 ff		 xor	 edi, edi
$LN4@basic_stre:

; 27   : 		_Init();

  00054	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00057	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  0005a	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0005d	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00060	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00063	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00066	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00069	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  0006c	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0006f	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  00072	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  00075	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  00078	89 46 30	 mov	 DWORD PTR [esi+48], eax
  0007b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00081	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00084	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0008a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0008d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00093	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00096	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0009c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0009f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000a5	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000a8	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 28   : 		}

  000ae	8b c6		 mov	 eax, esi
  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT
; _this$ = ecx

; 644  : 		{	// return string copy of character array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 645  : 		return (_Stringbuffer.str());

  00004	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00007	83 c1 18	 add	 ecx, 24			; 00000018H
  0000a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00011	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 646  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 635  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx
  00026	8b 47 98	 mov	 eax, DWORD PTR [edi-104]

; 636  : 		}

  00029	8d 4f b0	 lea	 ecx, DWORD PTR [edi-80]
  0002c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002f	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00037	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  0003a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003d	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  00040	89 44 3a 94	 mov	 DWORD PTR [edx+edi-108], eax
  00044	c7 47 b0 00 00
	00 00		 mov	 DWORD PTR [edi-80], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0004b	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00050	8b 77 e4	 mov	 esi, DWORD PTR [edi-28]
  00053	c7 47 b0 00 00
	00 00		 mov	 DWORD PTR [edi-80], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  0005a	85 f6		 test	 esi, esi
  0005c	74 2a		 je	 SHORT $LN12@basic_stri
  0005e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00061	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	85 c9		 test	 ecx, ecx
  0006a	74 11		 je	 SHORT $LN18@basic_stri
  0006c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006e	ff 50 08	 call	 DWORD PTR [eax+8]
  00071	85 c0		 test	 eax, eax
  00073	74 08		 je	 SHORT $LN18@basic_stri
  00075	8b 10		 mov	 edx, DWORD PTR [eax]
  00077	8b c8		 mov	 ecx, eax
  00079	6a 01		 push	 1
  0007b	ff 12		 call	 DWORD PTR [edx]
$LN18@basic_stri:
  0007d	6a 08		 push	 8
  0007f	56		 push	 esi
  00080	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00085	83 c4 08	 add	 esp, 8
$LN12@basic_stri:
  00088	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  0008b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008e	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  00096	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  00099	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009c	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  0009f	89 44 39 94	 mov	 DWORD PTR [ecx+edi-108], eax
  000a3	8b 47 a8	 mov	 eax, DWORD PTR [edi-88]
  000a6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a9	c7 44 38 a8 00
	00 00 00	 mov	 DWORD PTR [eax+edi-88], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  000b1	8b 47 a8	 mov	 eax, DWORD PTR [edi-88]
  000b4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b7	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  000ba	89 44 39 a4	 mov	 DWORD PTR [ecx+edi-92], eax
  000be	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  000c1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c4	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  000cc	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  000cf	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d2	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  000d5	89 44 39 94	 mov	 DWORD PTR [ecx+edi-108], eax
  000d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e3	59		 pop	 ecx
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$ = 8						; size = 4
_this$ = 12						; size = 4
_$initVBases$ = 12					; size = 4
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 591  : 		{	// construct empty character buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00034	83 7d 0c 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  00038	74 22		 je	 SHORT $LN2@basic_stri
  0003a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  00040	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00047	c7 47 68 00 00
	00 00		 mov	 DWORD PTR [edi+104], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00055	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_stri:

; 589  : 		: _Mybase(&_Stringbuffer),

  0005c	6a 00		 push	 0
  0005e	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  00061	8b cf		 mov	 ecx, edi
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 ??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >

; 591  : 		{	// construct empty character buffer

  00069	8b 07		 mov	 eax, DWORD PTR [edi]
  0006b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00072	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00075	c7 04 07 00 00
	00 00		 mov	 DWORD PTR [edi+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0007c	8b 07		 mov	 eax, DWORD PTR [edi]
  0007e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00081	89 75 0c	 mov	 DWORD PTR _this$[ebp], esi
  00084	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00087	89 44 39 fc	 mov	 DWORD PTR [ecx+edi-4], eax
  0008b	8b ce		 mov	 ecx, esi
  0008d	e8 00 00 00 00	 call	 ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
  00092	8b 5d 08	 mov	 ebx, DWORD PTR __Mode$[ebp]
  00095	8b c3		 mov	 eax, ebx
  00097	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0009d	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  000a4	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  000ab	f7 d1		 not	 ecx
  000ad	83 e1 04	 and	 ecx, 4
  000b0	8b d1		 mov	 edx, ecx
  000b2	83 ca 02	 or	 edx, 2
  000b5	24 02		 and	 al, 2
  000b7	8b c3		 mov	 eax, ebx
  000b9	0f 45 d1	 cmovne	 edx, ecx
  000bc	8b ca		 mov	 ecx, edx
  000be	83 c9 08	 or	 ecx, 8
  000c1	24 08		 and	 al, 8
  000c3	0f 44 ca	 cmove	 ecx, edx
  000c6	8b c1		 mov	 eax, ecx
  000c8	83 c8 10	 or	 eax, 16			; 00000010H
  000cb	80 e3 04	 and	 bl, 4
  000ce	0f 44 c1	 cmove	 eax, ecx
  000d1	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 592  : 		}

  000d4	8b c7		 mov	 eax, edi
  000d6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e0	59		 pop	 ecx
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_stri
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 68	 add	 ecx, 104		; 00000068H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN5@basic_stri:
  0001b	c3		 ret	 0
__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1:
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 20	 add	 ecx, 32			; 00000020H
  00022	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$3:
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__ehhandler$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:
  0002f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00033	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00036	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  00045	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_iostream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8d 51 20	 lea	 edx, DWORD PTR [ecx+32]
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	c7 44 10 e0 00
	00 00 00	 mov	 DWORD PTR [eax+edx-32], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  00032	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  0003b	89 44 11 dc	 mov	 DWORD PTR [ecx+edx-36], eax
  0003f	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  00042	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00045	c7 44 10 f0 00
	00 00 00	 mov	 DWORD PTR [eax+edx-16], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  0004d	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  00050	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00053	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  00056	89 44 11 ec	 mov	 DWORD PTR [ecx+edx-20], eax
  0005a	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	c7 44 10 e0 00
	00 00 00	 mov	 DWORD PTR [eax+edx-32], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00068	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  0006b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006e	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00071	89 44 11 dc	 mov	 DWORD PTR [ecx+edx-36], eax
  00075	52		 push	 edx
  00076	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007d	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00083	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00088	83 c4 04	 add	 esp, 4
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00095	59		 pop	 ecx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ$4:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_iostream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_iostream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 71 e0	 lea	 esi, DWORD PTR [ecx-32]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00012	74 0b		 je	 SHORT $LN4@scalar
  00014	6a 68		 push	 104			; 00000068H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_iostream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 983  : 		{	// destroy the object

  00000	8b 41 e0	 mov	 eax, DWORD PTR [ecx-32]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 e0 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-32], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  0000e	8b 41 e0	 mov	 eax, DWORD PTR [ecx-32]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 e0	 lea	 eax, DWORD PTR [edx-32]
  00017	89 44 0a dc	 mov	 DWORD PTR [edx+ecx-36], eax

; 984  : 		}

  0001b	8d 51 f8	 lea	 edx, DWORD PTR [ecx-8]
  0001e	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	c7 44 10 f8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  0002c	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  0002f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00032	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  00035	89 44 11 f4	 mov	 DWORD PTR [ecx+edx-12], eax
  00039	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  0003c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003f	c7 44 10 e8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00047	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  0004a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004d	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00050	89 44 11 e4	 mov	 DWORD PTR [ecx+edx-28], eax
  00054	c3		 ret	 0
??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
_this$ = 12						; size = 4
_$initVBases$ = 12					; size = 4
??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 954  : 		{	// construct from stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00032	83 7d 0c 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  00036	74 22		 je	 SHORT $LN2@basic_iost
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0003e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], OFFSET ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00045	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00053	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_iost:

; 952  : 		: _Myis(_Strbuf, false),

  0005a	8b 06		 mov	 eax, DWORD PTR [esi]
  0005c	6a 00		 push	 0
  0005e	ff 75 08	 push	 DWORD PTR __Strbuf$[ebp]
  00061	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00064	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  0006b	8b 06		 mov	 eax, DWORD PTR [esi]
  0006d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00070	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00073	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax
  00077	8b 06		 mov	 eax, DWORD PTR [esi]
  00079	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00080	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00087	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008a	03 ce		 add	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init

; 953  : 			_Myos(_Noinit, false)

  00091	8d 56 10	 lea	 edx, DWORD PTR [esi+16]
  00094	89 55 0c	 mov	 DWORD PTR _this$[ebp], edx
  00097	8b 02		 mov	 eax, DWORD PTR [edx]
  00099	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0009c	c7 04 02 00 00
	00 00		 mov	 DWORD PTR [edx+eax], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  000a3	8b 02		 mov	 eax, DWORD PTR [edx]
  000a5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a8	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  000ab	89 44 11 fc	 mov	 DWORD PTR [ecx+edx-4], eax

; 954  : 		{	// construct from stream buffer pointer

  000af	8b 06		 mov	 eax, DWORD PTR [esi]
  000b1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b4	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  000bb	8b 06		 mov	 eax, DWORD PTR [esi]
  000bd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c0	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  000c3	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax

; 955  : 		}

  000c7	8b c6		 mov	 eax, esi
  000c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5e		 pop	 esi
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_iost
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 20	 add	 ecx, 32			; 00000020H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN5@basic_iost:
  0001b	c3		 ret	 0
__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$1:
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 18	 add	 ecx, 24			; 00000018H
  00022	e9 00 00 00 00	 jmp	 ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
__ehhandler$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	c7 44 10 f8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  00032	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0003b	89 44 11 f4	 mov	 DWORD PTR [ecx+edx-12], eax
  0003f	52		 push	 edx
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  0004d	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00052	83 c4 04	 add	 esp, 4
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b d1		 mov	 edx, ecx
  00025	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00028	8d 72 f8	 lea	 esi, DWORD PTR [edx-8]
  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002e	c7 44 10 f8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0003e	89 44 11 f4	 mov	 DWORD PTR [ecx+edx-12], eax
  00042	52		 push	 edx
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00050	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00055	83 c4 04	 add	 esp, 4
  00058	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005c	74 0b		 je	 SHORT $LN16@scalar
  0005e	6a 50		 push	 80			; 00000050H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00066	83 c4 08	 add	 esp, 8
$LN16@scalar:
  00069	8b c6		 mov	 eax, esi
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
$T2 = -40						; size = 20
__Ok$3 = -20						; size = 8
__$EHRec$ = -12						; size = 12
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 574  : 		{	// flush output stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx

; 575  : 		if (_Myios::rdbuf() != 0)

  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	83 7c 30 38 00	 cmp	 DWORD PTR [eax+esi+56], 0
  00032	0f 84 ce 00 00
	00		 je	 $LN102@flush

; 576  : 			{	// buffer exists, flush it
; 577  : 			const sentry _Ok(*this);

  00038	56		 push	 esi
  00039	8d 4d ec	 lea	 ecx, DWORD PTR __Ok$3[ebp]
  0003c	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 578  : 
; 579  : 			if (_Ok && _Myios::rdbuf()->pubsync() == -1)

  00041	80 7d f0 00	 cmp	 BYTE PTR __Ok$3[ebp+4], 0
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	0f 84 83 00 00
	00		 je	 $LN56@flush
  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00057	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  0005b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005d	ff 50 34	 call	 DWORD PTR [eax+52]
  00060	83 f8 ff	 cmp	 eax, -1
  00063	75 70		 jne	 SHORT $LN56@flush

; 580  : 				_Myios::setstate(ios_base::badbit);	// sync failed

  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0006a	8b 44 32 10	 mov	 eax, DWORD PTR [edx+esi+16]
  0006e	03 d6		 add	 edx, esi
  00070	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00073	83 c9 04	 or	 ecx, 4
  00076	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0007a	0f 45 4a 0c	 cmovne	 ecx, DWORD PTR [edx+12]
  0007e	83 e1 13	 and	 ecx, 19			; 00000013H
  00081	83 c9 04	 or	 ecx, 4
  00084	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00087	23 c1		 and	 eax, ecx
  00089	74 4a		 je	 SHORT $LN56@flush
  0008b	a8 04		 test	 al, 4
  0008d	74 2a		 je	 SHORT $LN53@flush
  0008f	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN111@flush:
  00099	50		 push	 eax
  0009a	6a 01		 push	 1
  0009c	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0009f	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000a4	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000a9	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  000ac	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN112@flush:
$LN53@flush:
  000b9	a8 02		 test	 al, 2
  000bb	74 0c		 je	 SHORT $LN55@flush
  000bd	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  000c7	eb d0		 jmp	 SHORT $LN111@flush
$LN55@flush:
  000c9	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000d3	eb c4		 jmp	 SHORT $LN111@flush
$LN56@flush:

; 581  : 			}

  000d5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000dc	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  000e1	84 c0		 test	 al, al
  000e3	75 08		 jne	 SHORT $LN98@flush
  000e5	8b 4d ec	 mov	 ecx, DWORD PTR __Ok$3[ebp]
  000e8	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN98@flush:
  000ed	8b 4d ec	 mov	 ecx, DWORD PTR __Ok$3[ebp]
  000f0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000f4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f9	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  000fd	85 c9		 test	 ecx, ecx
  000ff	74 05		 je	 SHORT $LN102@flush
  00101	8b 01		 mov	 eax, DWORD PTR [ecx]
  00103	ff 50 08	 call	 DWORD PTR [eax+8]
$LN102@flush:

; 582  : 		return (*this);

  00106	8b c6		 mov	 eax, esi

; 583  : 		}

  00108	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0010b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00112	59		 pop	 ecx
  00113	5e		 pop	 esi
  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c3		 ret	 0
$LN110@flush:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Ok$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$14:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$15:
  0000e	e8 00 00 00 00	 call	 ___std_terminate
  00013	c3		 ret	 0
__ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z
_TEXT	SEGMENT
$T2 = -112						; size = 20
$T3 = -92						; size = 20
$T4 = -72						; size = 20
$T5 = -52						; size = 8
$T6 = -52						; size = 8
$T7 = -44						; size = 8
__Ok$ = -36						; size = 8
__State$ = -28						; size = 4
$T8 = -24						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 356  : 		{	// insert an unsigned long

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 64	 sub	 esp, 100		; 00000064H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 357  : 		ios_base::iostate _State = ios_base::goodbit;
; 358  : 		const sentry _Ok(*this);

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	33 ff		 xor	 edi, edi
  00034	89 7d e4	 mov	 DWORD PTR __State$[ebp], edi
  00037	89 75 dc	 mov	 DWORD PTR __Ok$[ebp], esi
  0003a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003d	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00041	85 c9		 test	 ecx, ecx
  00043	74 05		 je	 SHORT $LN19@operator
  00045	8b 01		 mov	 eax, DWORD PTR [ecx]
  00047	ff 50 04	 call	 DWORD PTR [eax+4]
$LN19@operator:
  0004a	8b 06		 mov	 eax, DWORD PTR [esi]
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00053	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00056	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  0005b	75 11		 jne	 SHORT $LN15@operator
  0005d	8b 4c 30 3c	 mov	 ecx, DWORD PTR [eax+esi+60]
  00061	85 c9		 test	 ecx, ecx
  00063	74 09		 je	 SHORT $LN15@operator
  00065	3b ce		 cmp	 ecx, esi
  00067	74 05		 je	 SHORT $LN15@operator
  00069	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN15@operator:
  0006e	8b 06		 mov	 eax, DWORD PTR [esi]
  00070	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00073	03 ce		 add	 ecx, esi
  00075	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00079	0f 94 c0	 sete	 al
  0007c	88 45 e0	 mov	 BYTE PTR __Ok$[ebp+4], al
  0007f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 359  : 
; 360  : 		if (_Ok)

  00086	84 c0		 test	 al, al
  00088	74 75		 je	 SHORT $LN12@operator

; 361  : 			{	// state okay, use facet to insert
; 362  : 			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

  0008a	8d 45 d4	 lea	 eax, DWORD PTR $T7[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00093	50		 push	 eax
  00094	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00098	e8 00 00 00 00	 call	 ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
  0009d	83 c4 04	 add	 esp, 4
  000a0	8b d8		 mov	 ebx, eax
  000a2	8b 4d d8	 mov	 ecx, DWORD PTR $T7[ebp+4]
  000a5	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  000a9	85 c9		 test	 ecx, ecx
  000ab	74 11		 je	 SHORT $LN44@operator
  000ad	8b 11		 mov	 edx, DWORD PTR [ecx]
  000af	ff 52 08	 call	 DWORD PTR [edx+8]
  000b2	85 c0		 test	 eax, eax
  000b4	74 08		 je	 SHORT $LN44@operator
  000b6	8b 10		 mov	 edx, DWORD PTR [eax]
  000b8	8b c8		 mov	 ecx, eax
  000ba	6a 01		 push	 1
  000bc	ff 12		 call	 DWORD PTR [edx]
$LN44@operator:

; 363  : 
; 364  : 			_TRY_IO_BEGIN
; 365  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 366  : 				_Myios::fill(), _Val).failed())

  000be	8b 06		 mov	 eax, DWORD PTR [esi]
  000c0	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  000c3	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  000c7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ca	8a 44 31 40	 mov	 al, BYTE PTR [ecx+esi+64]
  000ce	03 ce		 add	 ecx, esi
  000d0	88 45 e8	 mov	 BYTE PTR $T8[ebp], al
  000d3	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  000d6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000d8	51		 push	 ecx
  000d9	c6 45 cc 00	 mov	 BYTE PTR $T6[ebp], 0
  000dd	ff 71 38	 push	 DWORD PTR [ecx+56]
  000e0	8d 4d cc	 lea	 ecx, DWORD PTR $T5[ebp]
  000e3	ff 75 cc	 push	 DWORD PTR $T6[ebp]
  000e6	51		 push	 ecx
  000e7	8b cb		 mov	 ecx, ebx
  000e9	ff 50 20	 call	 DWORD PTR [eax+32]
  000ec	80 7d cc 00	 cmp	 BYTE PTR $T5[ebp], 0
  000f0	b8 04 00 00 00	 mov	 eax, 4
  000f5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  000fc	0f 45 f8	 cmovne	 edi, eax
$LN12@operator:

; 369  : 			}
; 370  : 
; 371  : 		_Myios::setstate(_State);

  000ff	8b 06		 mov	 eax, DWORD PTR [esi]
  00101	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00104	03 d6		 add	 edx, esi
  00106	85 ff		 test	 edi, edi
  00108	0f 84 ee 00 00
	00		 je	 $LN134@operator
  0010e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00111	0b c7		 or	 eax, edi
  00113	8b c8		 mov	 ecx, eax
  00115	83 c9 04	 or	 ecx, 4
  00118	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0011c	0f 45 c8	 cmovne	 ecx, eax
  0011f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00122	83 e1 17	 and	 ecx, 23			; 00000017H
  00125	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00128	23 c1		 and	 eax, ecx
  0012a	0f 84 cc 00 00
	00		 je	 $LN134@operator
  00130	a8 04		 test	 al, 4
  00132	74 70		 je	 SHORT $LN131@operator
  00134	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00139	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  0013e	50		 push	 eax
  0013f	6a 01		 push	 1
  00141	8d 4d b8	 lea	 ecx, DWORD PTR $T4[ebp]
  00144	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00149	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  0014e	8d 45 b8	 lea	 eax, DWORD PTR $T4[ebp]
  00151	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN188@operator:
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z$0:

; 367  : 				_State |= ios_base::badbit;
; 368  : 			_CATCH_IO_END

  0015e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	8b 01		 mov	 eax, DWORD PTR [ecx]
  00163	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00166	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  0016a	03 d1		 add	 edx, ecx
  0016c	83 c8 04	 or	 eax, 4
  0016f	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00173	75 03		 jne	 SHORT $LN66@operator
  00175	83 c8 04	 or	 eax, 4
$LN66@operator:
  00178	83 e0 17	 and	 eax, 23			; 00000017H
  0017b	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0017e	85 42 10	 test	 DWORD PTR [edx+16], eax
  00181	75 18		 jne	 SHORT $LN69@operator
  00183	b8 00 00 00 00	 mov	 eax, $LN13@operator
  00188	c3		 ret	 0
$LN13@operator:
  00189	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0018c	8b 7d e4	 mov	 edi, DWORD PTR __State$[ebp]
  0018f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00196	e9 64 ff ff ff	 jmp	 $LN12@operator
$LN69@operator:
  0019b	6a 00		 push	 0
  0019d	6a 00		 push	 0
  0019f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN189@operator:

; 369  : 			}
; 370  : 
; 371  : 		_Myios::setstate(_State);

$LN131@operator:
  001a4	a8 02		 test	 al, 2
  001a6	74 2a		 je	 SHORT $LN133@operator
  001a8	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  001b2	50		 push	 eax
  001b3	6a 01		 push	 1
  001b5	8d 4d a4	 lea	 ecx, DWORD PTR $T3[ebp]
  001b8	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  001bd	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  001c2	8d 45 a4	 lea	 eax, DWORD PTR $T3[ebp]
  001c5	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN190@operator:
$LN133@operator:
  001d2	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  001d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  001dc	50		 push	 eax
  001dd	6a 01		 push	 1
  001df	8d 4d 90	 lea	 ecx, DWORD PTR $T2[ebp]
  001e2	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  001e7	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  001ec	8d 45 90	 lea	 eax, DWORD PTR $T2[ebp]
  001ef	c7 45 90 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  001f6	50		 push	 eax
  001f7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN191@operator:
$LN134@operator:

; 372  : 		return (*this);

  001fc	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 6
  00203	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  00208	84 c0		 test	 al, al
  0020a	75 07		 jne	 SHORT $LN175@operator
  0020c	8b ce		 mov	 ecx, esi
  0020e	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN175@operator:
  00213	8b 06		 mov	 eax, DWORD PTR [esi]
  00215	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+12], 7
  00219	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0021c	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00220	85 c9		 test	 ecx, ecx
  00222	74 05		 je	 SHORT $LN179@operator
  00224	8b 01		 mov	 eax, DWORD PTR [ecx]
  00226	ff 50 08	 call	 DWORD PTR [eax+8]
$LN179@operator:
  00229	8b c6		 mov	 eax, esi

; 373  : 		}

  0022b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0022e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00235	59		 pop	 ecx
  00236	5f		 pop	 edi
  00237	5e		 pop	 esi
  00238	5b		 pop	 ebx
  00239	8b e5		 mov	 esp, ebp
  0023b	5d		 pop	 ebp
  0023c	c2 04 00	 ret	 4
$LN187@operator:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z$4:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z$2:
  00008	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z$3:
  00010	8d 4d d4	 lea	 ecx, DWORD PTR $T7[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z$5:
  00018	e8 00 00 00 00	 call	 ___std_terminate
  0001d	c3		 ret	 0
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z$32:
  0001e	e8 00 00 00 00	 call	 ___std_terminate
  00023	c3		 ret	 0
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z$33:
  00024	e8 00 00 00 00	 call	 ___std_terminate
  00029	c3		 ret	 0
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z:
  0002a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00031	8b 4a 8c	 mov	 ecx, DWORD PTR [edx-116]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z
  00040	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z
_TEXT	SEGMENT
__Pfn$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 210  : 		{	// call ios_base manipulator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 211  : 		_DEBUG_POINTER(_Pfn);
; 212  : 		(*_Pfn)(*(ios_base *)this);

  00006	85 f6		 test	 esi, esi
  00008	75 10		 jne	 SHORT $LN3@operator
  0000a	33 c0		 xor	 eax, eax
  0000c	50		 push	 eax
  0000d	ff 55 08	 call	 DWORD PTR __Pfn$[ebp]
  00010	83 c4 04	 add	 esp, 4

; 213  : 		return (*this);

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi

; 214  : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN3@operator:

; 211  : 		_DEBUG_POINTER(_Pfn);
; 212  : 		(*_Pfn)(*(ios_base *)this);

  0001a	8b 06		 mov	 eax, DWORD PTR [esi]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	03 c6		 add	 eax, esi
  00021	50		 push	 eax
  00022	ff 55 08	 call	 DWORD PTR __Pfn$[ebp]
  00025	83 c4 04	 add	 esp, 4

; 213  : 		return (*this);

  00028	8b c6		 mov	 eax, esi
  0002a	5e		 pop	 esi

; 214  : 		}

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T2 = -76						; size = 20
$T3 = -56						; size = 20
$T4 = -36						; size = 20
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 165  : 		{	// perform any wrapup

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 166  : 		_TRY_BEGIN
; 167  : 		if (this->good() && this->flags() & ios_base::unitbuf)

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00036	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00039	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  0003e	0f 85 d3 00 00
	00		 jne	 $LN9@Osfx
  00044	f6 44 30 14 02	 test	 BYTE PTR [eax+esi+20], 2
  00049	0f 84 c8 00 00
	00		 je	 $LN9@Osfx

; 168  : 			if (_Myios::rdbuf()->pubsync() == -1)	// flush stream as needed

  0004f	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00053	8b 01		 mov	 eax, DWORD PTR [ecx]
  00055	ff 50 34	 call	 DWORD PTR [eax+52]
  00058	83 f8 ff	 cmp	 eax, -1
  0005b	0f 85 b6 00 00
	00		 jne	 $LN9@Osfx

; 169  : 				_Myios::setstate(ios_base::badbit);

  00061	8b 06		 mov	 eax, DWORD PTR [esi]
  00063	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00066	8b 44 32 10	 mov	 eax, DWORD PTR [edx+esi+16]
  0006a	03 d6		 add	 edx, esi
  0006c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0006f	83 c9 04	 or	 ecx, 4
  00072	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00076	0f 45 4a 0c	 cmovne	 ecx, DWORD PTR [edx+12]
  0007a	83 e1 13	 and	 ecx, 19			; 00000013H
  0007d	83 c9 04	 or	 ecx, 4
  00080	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00083	23 c1		 and	 eax, ecx
  00085	0f 84 8c 00 00
	00		 je	 $LN9@Osfx
  0008b	a8 04		 test	 al, 4
  0008d	74 2a		 je	 SHORT $LN34@Osfx
  0008f	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  00099	50		 push	 eax
  0009a	6a 01		 push	 1
  0009c	8d 4d dc	 lea	 ecx, DWORD PTR $T4[ebp]
  0009f	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000a4	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000a9	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  000ac	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN80@Osfx:
$LN34@Osfx:
  000b9	a8 02		 test	 al, 2
  000bb	74 2a		 je	 SHORT $LN36@Osfx
  000bd	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  000c7	50		 push	 eax
  000c8	6a 01		 push	 1
  000ca	8d 4d c8	 lea	 ecx, DWORD PTR $T3[ebp]
  000cd	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000d2	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000d7	8d 45 c8	 lea	 eax, DWORD PTR $T3[ebp]
  000da	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN81@Osfx:
$LN36@Osfx:
  000e7	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000f1	50		 push	 eax
  000f2	6a 01		 push	 1
  000f4	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp]
  000f7	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000fc	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00101	8d 45 b4	 lea	 eax, DWORD PTR $T2[ebp]
  00104	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN82@Osfx:
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0:

; 170  : 		_CATCH_ALL
; 171  : 		_CATCH_END

  00111	b8 00 00 00 00	 mov	 eax, $LN9@Osfx
  00116	c3		 ret	 0
$LN9@Osfx:

; 172  : 		}

  00117	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0011a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00121	59		 pop	 ecx
  00122	5f		 pop	 edi
  00123	5e		 pop	 esi
  00124	5b		 pop	 ebx
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
$LN79@Osfx:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 88   : 		{	// destroy the object

  00000	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 f8 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  0000e	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00017	89 44 0a f4	 mov	 DWORD PTR [edx+ecx-12], eax

; 89   : 		}

  0001b	c3		 ret	 0
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
__Addit$ = 12						; size = 1
_$initVBases$ = 16					; size = 4
??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 58   : 	__CLR_OR_THIS_CALL basic_ostream(_Uninitialized, bool _Addit = true)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 59   : 		{	// construct uninitialized

  0002b	83 7d 10 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00036	74 1b		 je	 SHORT $LN2@basic_ostr
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@
  0003e	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_ostr:

; 60   : 		if (_Addit)

  00053	80 7d 0c 00	 cmp	 BYTE PTR __Addit$[ebp], 0
  00057	8b 06		 mov	 eax, DWORD PTR [esi]
  00059	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005c	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  00063	8b 06		 mov	 eax, DWORD PTR [esi]
  00065	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00068	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0006b	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax
  0006f	74 10		 je	 SHORT $LN13@basic_ostr

; 61   : 			this->_Addstd(this);	// suppress for basic_iostream

  00071	8b 06		 mov	 eax, DWORD PTR [esi]
  00073	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00076	03 c6		 add	 eax, esi
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  0007e	83 c4 04	 add	 esp, 4
$LN13@basic_ostr:

; 62   : 		}

  00081	8b c6		 mov	 eax, esi
  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	5e		 pop	 esi
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN8@basic_ostr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 08	 add	 ecx, 8
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN8@basic_ostr:
  0001b	c3		 ret	 0
__ehhandler$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8d 51 18	 lea	 edx, DWORD PTR [ecx+24]
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	c7 44 10 e8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00032	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0003b	89 44 11 e4	 mov	 DWORD PTR [ecx+edx-28], eax
  0003f	52		 push	 edx
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  0004d	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00052	83 c4 04	 add	 esp, 4
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b d1		 mov	 edx, ecx
  00025	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  00028	8d 72 e8	 lea	 esi, DWORD PTR [edx-24]
  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002e	c7 44 10 e8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0003e	89 44 11 e4	 mov	 DWORD PTR [ecx+edx-28], eax
  00042	52		 push	 edx
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00050	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00055	83 c4 04	 add	 esp, 4
  00058	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005c	74 0b		 je	 SHORT $LN16@scalar
  0005e	6a 60		 push	 96			; 00000060H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00066	83 c4 08	 add	 esp, 8
$LN16@scalar:
  00069	8b c6		 mov	 eax, esi
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 81   : 		{	// destroy the object

  00000	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 e8 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  0000e	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 e8	 lea	 eax, DWORD PTR [edx-24]
  00017	89 44 0a e4	 mov	 DWORD PTR [edx+ecx-28], eax

; 82   : 		}

  0001b	c3		 ret	 0
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
_$initVBases$ = 16					; size = 4
??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 46   : 		{	// construct from stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002b	83 7d 10 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00036	74 1b		 je	 SHORT $LN2@basic_istr
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@
  0003e	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_istr:
  00053	8b 06		 mov	 eax, DWORD PTR [esi]

; 47   : 		_Myios::init(_Strbuf, _Isstd);

  00055	ff 75 0c	 push	 DWORD PTR __Isstd$[ebp]
  00058	ff 75 08	 push	 DWORD PTR __Strbuf$[ebp]
  0005b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005e	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006a	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0006d	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax
  00071	8b 06		 mov	 eax, DWORD PTR [esi]
  00073	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0007a	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00081	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00084	03 ce		 add	 ecx, esi
  00086	e8 00 00 00 00	 call	 ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init

; 48   : 		}

  0008b	8b c6		 mov	 eax, esi
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	5e		 pop	 esi
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_istr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 18	 add	 ecx, 24			; 00000018H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN5@basic_istr:
  0001b	c3		 ret	 0
__ehhandler$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	56		 push	 esi
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00033	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00038	83 c4 04	 add	 esp, 4
  0003b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003f	74 0b		 je	 SHORT $LN10@scalar
  00041	6a 48		 push	 72			; 00000048H
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00049	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0004c	8b c6		 mov	 eax, esi
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00058	59		 pop	 ecx
  00059	5e		 pop	 esi
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ PROC	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 183  : 	__CLR_OR_THIS_CALL basic_ios()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  : 		{	// default constructor, do nothing
; 185  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
_TEXT	SEGMENT
$T2 = -60						; size = 20
$T3 = -40						; size = 20
$T4 = -20						; size = 8
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::init, COMDAT
; _this$ = ecx

; 170  : 		{	// initialize with stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx

; 171  : 		_Init();	// initialize ios_base

  00029	e8 00 00 00 00	 call	 ?_Init@ios_base@std@@IAEXXZ ; std::ios_base::_Init

; 172  : 		_Mystrbuf = _Strbuf;

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Strbuf$[ebp]

; 173  : 		_Tiestr = 0;
; 174  : 		_Fillch = widen(' ');

  00031	8b ce		 mov	 ecx, esi
  00033	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00036	8d 45 ec	 lea	 eax, DWORD PTR $T4[ebp]
  00039	50		 push	 eax
  0003a	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
  00041	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00046	50		 push	 eax
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004e	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00053	83 c4 04	 add	 esp, 4
  00056	8b f8		 mov	 edi, eax
  00058	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp+4]
  0005b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00062	85 c9		 test	 ecx, ecx
  00064	74 11		 je	 SHORT $LN11@init
  00066	8b 11		 mov	 edx, DWORD PTR [ecx]
  00068	ff 52 08	 call	 DWORD PTR [edx+8]
  0006b	85 c0		 test	 eax, eax
  0006d	74 08		 je	 SHORT $LN11@init
  0006f	8b 10		 mov	 edx, DWORD PTR [eax]
  00071	8b c8		 mov	 ecx, eax
  00073	6a 01		 push	 1
  00075	ff 12		 call	 DWORD PTR [edx]
$LN11@init:
  00077	8b 07		 mov	 eax, DWORD PTR [edi]
  00079	8b cf		 mov	 ecx, edi
  0007b	6a 20		 push	 32			; 00000020H
  0007d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00084	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00087	ff d0		 call	 eax

; 175  : 
; 176  : 		if (_Mystrbuf == 0)

  00089	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  0008d	88 46 40	 mov	 BYTE PTR [esi+64], al
  00090	75 79		 jne	 SHORT $LN33@init

; 177  : 			setstate(badbit);

  00092	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00095	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00098	83 e0 13	 and	 eax, 19			; 00000013H
  0009b	83 c8 04	 or	 eax, 4
  0009e	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  000a1	23 c8		 and	 ecx, eax
  000a3	74 66		 je	 SHORT $LN33@init
  000a5	f6 c1 04	 test	 cl, 4
  000a8	74 2a		 je	 SHORT $LN30@init
  000aa	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN76@init:
  000b4	50		 push	 eax
  000b5	6a 01		 push	 1
  000b7	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  000ba	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000bf	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000c6	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  000c9	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
$LN77@init:
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN78@init:
$LN30@init:
  000d4	f6 c1 02	 test	 cl, 2
  000d7	74 0c		 je	 SHORT $LN32@init
  000d9	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  000e3	eb cf		 jmp	 SHORT $LN76@init
$LN32@init:
  000e5	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000ef	50		 push	 eax
  000f0	6a 01		 push	 1
  000f2	8d 4d c4	 lea	 ecx, DWORD PTR $T2[ebp]
  000f5	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000fa	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00101	8d 45 c4	 lea	 eax, DWORD PTR $T2[ebp]
  00104	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00109	eb c3		 jmp	 SHORT $LN77@init
$LN33@init:

; 178  : 
; 179  : 		if (_Isstd)

  0010b	80 7d 0c 00	 cmp	 BYTE PTR __Isstd$[ebp], 0
  0010f	74 09		 je	 SHORT $LN3@init

; 180  : 			_Addstd(this);	// special handling for standard streams

  00111	56		 push	 esi
  00112	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  00117	83 c4 04	 add	 esp, 4
$LN3@init:

; 181  : 		}

  0011a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00124	59		 pop	 ecx
  00125	5f		 pop	 edi
  00126	5e		 pop	 esi
  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c2 08 00	 ret	 8
$LN75@init:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z$1:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__ehhandler$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
_TEXT	SEGMENT
$T2 = -20						; size = 8
__$EHRec$ = -12						; size = 12
__Byte$ = 8						; size = 1
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z PROC ; std::basic_ios<char,std::char_traits<char> >::widen, COMDAT
; _this$ = ecx

; 130  : 		{	// convert _Byte to character using imbued locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 131  : 		const _Ctype& _Ctype_fac = _USE(getloc(), _Ctype);

  00026	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  0002f	50		 push	 eax
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00037	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  0003c	83 c4 04	 add	 esp, 4
  0003f	8b f0		 mov	 esi, eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp+4]
  00044	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0004b	85 c9		 test	 ecx, ecx
  0004d	74 11		 je	 SHORT $LN7@widen
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	ff 52 08	 call	 DWORD PTR [edx+8]
  00054	85 c0		 test	 eax, eax
  00056	74 08		 je	 SHORT $LN7@widen
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b c8		 mov	 ecx, eax
  0005c	6a 01		 push	 1
  0005e	ff 12		 call	 DWORD PTR [edx]
$LN7@widen:

; 132  : 		return (_Ctype_fac.widen(_Byte));

  00060	8b 06		 mov	 eax, DWORD PTR [esi]
  00062	8b ce		 mov	 ecx, esi
  00064	ff 75 08	 push	 DWORD PTR __Byte$[ebp]
  00067	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006e	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00071	ff d0		 call	 eax

; 133  : 		}

  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5e		 pop	 esi
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$1:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::widen
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT
; _this$ = ecx

; 113  : 		return (_Fillch);

  00000	8a 41 40	 mov	 al, BYTE PTR [ecx+64]

; 114  : 		}

  00003	c3		 ret	 0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 92   : 		return (_Mystrbuf);

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]

; 93   : 		}

  00003	c3		 ret	 0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 80   : 		return (_Tiestr);

  00000	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]

; 81   : 		}

  00003	c3		 ret	 0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 58   : 		{	// merge _State into state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 59   : 		if (_State != goodbit)

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 1a		 je	 SHORT $LN2@setstate

; 60   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

  0000a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0000d	ff 75 0c	 push	 DWORD PTR __Reraise$[ebp]
  00010	0b d0		 or	 edx, eax
  00012	8b c2		 mov	 eax, edx
  00014	83 c8 04	 or	 eax, 4
  00017	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0001b	0f 45 c2	 cmovne	 eax, edx
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN2@setstate:

; 61   : 		}

  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 44   : 		{	// set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __State$[ebp]

; 45   : 		ios_base::clear((iostate)(_Mystrbuf == 0

  00006	ff 75 0c	 push	 DWORD PTR __Reraise$[ebp]
  00009	83 ca 04	 or	 edx, 4
  0000c	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00010	0f 45 55 08	 cmovne	 edx, DWORD PTR __State$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);
; 47   : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ PROC	; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 39   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 40   : 		}

  00022	51		 push	 ecx
  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
  00030	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00035	83 c4 04	 add	 esp, 4
  00038	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00042	59		 pop	 ecx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ
_TEXT	SEGMENT
$T2 = -24						; size = 8
__$EHRec$ = -16						; size = 16
??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ PROC ; `GostCrypt::SecurityToken::GetObjects'::`2'::Finally431::~Finally431, COMDAT
; _this$ = ecx

; 431  : 		finally_do_arg (CK_SLOT_ID, slotId, { Pkcs11Functions->C_FindObjectsFinal (Sessions[finally_arg].Handle); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	51		 push	 ecx
  0002c	8d 45 e8	 lea	 eax, DWORD PTR $T2[ebp]
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00036	50		 push	 eax
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  0003c	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  00041	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  00044	ff 70 14	 push	 DWORD PTR [eax+20]
  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  0004c	8b 40 72	 mov	 eax, DWORD PTR [eax+114]
  0004f	ff d0		 call	 eax
  00051	83 c4 04	 add	 esp, 4
$LN7@Finally431:
  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
__catch$??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ$0:
  00066	b8 00 00 00 00	 mov	 eax, $LN7@Finally431
  0006b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ ENDP ; `GostCrypt::SecurityToken::GetObjects'::`2'::Finally431::~Finally431
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ??0Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@K@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
??0Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@K@Z PROC ; `GostCrypt::SecurityToken::GetObjects'::`2'::Finally431::Finally431, COMDAT
; _this$ = ecx

; 431  : 		finally_do_arg (CK_SLOT_ID, slotId, { Pkcs11Functions->C_FindObjectsFinal (Sessions[finally_arg].Handle); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@K@Z ENDP ; `GostCrypt::SecurityToken::GetObjects'::`2'::Finally431::Finally431
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Incsize@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Incsize@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXI@Z PROC ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Incsize, COMDAT
; _this$ = ecx

; 1906 : 		{	// alter element count, with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1907 : 		if (max_size() - this->_Mysize() - 1 < _Count)

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	b8 fe ff ff 03	 mov	 eax, 67108862		; 03fffffeH
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  0000f	2b c2		 sub	 eax, edx
  00011	3b c6		 cmp	 eax, esi
  00013	72 0b		 jb	 SHORT $LN41@Incsize

; 1909 : 		this->_Mysize() += _Count;

  00015	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  00018	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0001b	5e		 pop	 esi

; 1910 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
$LN41@Incsize:

; 1908 : 			_Xlength_error("list<T> too long");

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00025	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN43@Incsize:
$LN40@Incsize:
  0002a	cc		 int	 3
?_Incsize@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXI@Z ENDP ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Incsize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Tidy@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXXZ PROC ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1884 : 		clear();

  00000	e9 00 00 00 00	 jmp	 ?clear@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::clear
?_Tidy@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXXZ ENDP ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?clear@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?clear@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXXZ PROC ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::clear, COMDAT
; _this$ = ecx

; 1500 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1501 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1502 : 
; 1503 : 		this->_Orphan_ptr(nullptr);
; 1504 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1505 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	57		 push	 edi
  00007	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000a	8b 38		 mov	 edi, DWORD PTR [eax]

; 1506 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

  0000c	89 00		 mov	 DWORD PTR [eax], eax

; 1507 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

  0000e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00010	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1508 : 		this->_Mysize() = 0;

  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 1509 : 
; 1510 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

  0001a	3b 39		 cmp	 edi, DWORD PTR [ecx]
  0001c	0f 84 d9 00 00
	00		 je	 $LN421@clear
  00022	53		 push	 ebx
  00023	56		 push	 esi
$LL4@clear:

; 1511 : 			{	// delete an element
; 1512 : 			_Pnext = this->_Nextnode(_Pnode);
; 1513 : 			this->_Freenode(_Pnode);

  00024	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00027	8d 77 28	 lea	 esi, DWORD PTR [edi+40]
  0002a	8b 1f		 mov	 ebx, DWORD PTR [edi]
  0002c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0002f	72 3d		 jb	 SHORT $LN225@clear
  00031	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00033	40		 inc	 eax
  00034	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00039	72 2a		 jb	 SHORT $LN220@clear
  0003b	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0003e	0f 85 bc 00 00
	00		 jne	 $LN425@clear
  00044	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00047	3b c1		 cmp	 eax, ecx
  00049	0f 83 b1 00 00
	00		 jae	 $LN425@clear
  0004f	2b c8		 sub	 ecx, eax
  00051	83 f9 04	 cmp	 ecx, 4
  00054	0f 82 a6 00 00
	00		 jb	 $LN425@clear
  0005a	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0005d	0f 87 9d 00 00
	00		 ja	 $LN425@clear
  00063	8b c8		 mov	 ecx, eax
$LN220@clear:
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0006b	83 c4 04	 add	 esp, 4
$LN225@clear:
  0006e	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00075	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00079	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00080	72 02		 jb	 SHORT $LN248@clear
  00082	8b 36		 mov	 esi, DWORD PTR [esi]
$LN248@clear:
  00084	c6 06 00	 mov	 BYTE PTR [esi], 0
  00087	8d 77 10	 lea	 esi, DWORD PTR [edi+16]
  0008a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0008d	83 f8 08	 cmp	 eax, 8
  00090	72 36		 jb	 SHORT $LN345@clear
  00092	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00094	40		 inc	 eax
  00095	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0009a	77 64		 ja	 SHORT $LN425@clear
  0009c	03 c0		 add	 eax, eax
  0009e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000a3	72 1a		 jb	 SHORT $LN340@clear
  000a5	f6 c1 1f	 test	 cl, 31			; 0000001fH
  000a8	75 56		 jne	 SHORT $LN425@clear
  000aa	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  000ad	3b c1		 cmp	 eax, ecx
  000af	73 4f		 jae	 SHORT $LN425@clear
  000b1	2b c8		 sub	 ecx, eax
  000b3	83 f9 04	 cmp	 ecx, 4
  000b6	72 48		 jb	 SHORT $LN425@clear
  000b8	83 f9 23	 cmp	 ecx, 35			; 00000023H
  000bb	77 43		 ja	 SHORT $LN425@clear
  000bd	8b c8		 mov	 ecx, eax
$LN340@clear:
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000c5	83 c4 04	 add	 esp, 4
$LN345@clear:
  000c8	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  000cf	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000d3	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000da	72 02		 jb	 SHORT $LN368@clear
  000dc	8b 36		 mov	 esi, DWORD PTR [esi]
$LN368@clear:
  000de	33 c0		 xor	 eax, eax
  000e0	57		 push	 edi
  000e1	66 89 06	 mov	 WORD PTR [esi], ax
  000e4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e9	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000ec	83 c4 04	 add	 esp, 4
  000ef	8b fb		 mov	 edi, ebx
  000f1	3b 18		 cmp	 ebx, DWORD PTR [eax]
  000f3	0f 85 2b ff ff
	ff		 jne	 $LL4@clear
  000f9	5e		 pop	 esi
  000fa	5b		 pop	 ebx
$LN421@clear:
  000fb	5f		 pop	 edi

; 1514 : 			}
; 1515 : 		}

  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c3		 ret	 0
$LN425@clear:

; 1511 : 			{	// delete an element
; 1512 : 			_Pnext = this->_Nextnode(_Pnode);
; 1513 : 			this->_Freenode(_Pnode);

  00100	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN426@clear:
$LN424@clear:
  00105	cc		 int	 3
?clear@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXXZ ENDP ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?empty@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QBE_NXZ PROC ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::empty, COMDAT
; _this$ = ecx

; 1251 : 		{	// test if sequence is empty

  00000	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00004	0f 94 c0	 sete	 al

; 1252 : 		return (this->_Mysize() == 0);
; 1253 : 		}

  00007	c3		 ret	 0
?empty@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QBE_NXZ ENDP ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?max_size@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QBEIXZ PROC ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::max_size, COMDAT
; _this$ = ecx

; 1247 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 03	 mov	 eax, 67108863		; 03ffffffH

; 1248 : 		}

  00005	c3		 ret	 0
?max_size@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QBEIXZ ENDP ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Unchecked_end@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1152 : 		{	// return unchecked iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1153 : 		return (_Unchecked_iterator(this->_Myhead(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1154 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Unchecked_end@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??1?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::~list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >, COMDAT
; _this$ = ecx

; 1097 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1098 : 		_Tidy();

  00003	e8 00 00 00 00	 call	 ?clear@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::clear

; 1099 : 		}

  00008	ff 36		 push	 DWORD PTR [esi]
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
  00012	5e		 pop	 esi
  00013	c3		 ret	 0
??1?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::~list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?push_back@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEX$$QAUSecurityTokenInfo@GostCrypt@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEX$$QAUSecurityTokenInfo@GostCrypt@@@Z PROC ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::push_back, COMDAT
; _this$ = ecx

; 1025 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1026 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));

  00007	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0000a	8b 3e		 mov	 edi, DWORD PTR [esi]
  0000c	ff 77 04	 push	 DWORD PTR [edi+4]
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 ??$_Buynode@USecurityTokenInfo@GostCrypt@@@?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@PAU21@0$$QAUSecurityTokenInfo@GostCrypt@@@Z ; std::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Buynode<GostCrypt::SecurityTokenInfo>
  00015	8b d0		 mov	 edx, eax
  00017	b9 fe ff ff 03	 mov	 ecx, 67108862		; 03fffffeH
  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	2b c8		 sub	 ecx, eax
  00021	83 f9 01	 cmp	 ecx, 1
  00024	72 12		 jb	 SHORT $LN94@push_back
  00026	40		 inc	 eax
  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0002a	89 57 04	 mov	 DWORD PTR [edi+4], edx
  0002d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	89 10		 mov	 DWORD PTR [eax], edx

; 1027 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN94@push_back:

; 1026 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0003d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN96@push_back:
$LN93@push_back:
  00042	cc		 int	 3
?push_back@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEX$$QAUSecurityTokenInfo@GostCrypt@@@Z ENDP ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Assign_rv@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEX$$QAV12@@Z PROC ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Assign_rv, COMDAT
; _this$ = ecx

; 1013 : 		{	// swap with empty *this, same allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1014 : 		this->_Swap_all(_Right);
; 1015 : 		_Swap_adl(this->_Myhead(), _Right._Myhead());

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	89 01		 mov	 DWORD PTR [ecx], eax
  0000d	89 16		 mov	 DWORD PTR [esi], edx

; 1016 : 		_STD swap(this->_Mysize(), _Right._Mysize());

  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00015	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00018	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0001b	5e		 pop	 esi

; 1017 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?_Assign_rv@?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEX$$QAV12@@Z ENDP ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >, COMDAT
; _this$ = ecx

; 986  : 		{	// construct list by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Buynode0

; 987  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00020	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00023	89 06		 mov	 DWORD PTR [esi], eax
  00025	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00027	89 0e		 mov	 DWORD PTR [esi], ecx
  00029	89 02		 mov	 DWORD PTR [edx], eax
  0002b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00031	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 988  : 		}

  00034	8b c6		 mov	 eax, esi
  00036	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00039	5e		 pop	 esi
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
??0?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >, COMDAT
; _this$ = ecx

; 893  : 		{	// construct empty list

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Buynode0
  00020	89 06		 mov	 DWORD PTR [esi], eax

; 894  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::~_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >, COMDAT
; _this$ = ecx
  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::~_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Freenode@?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode@?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@@Z PROC ; std::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Freenode, COMDAT
; _this$ = ecx

; 848  : 		{	// give node back

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 849  : 		this->_Getal().destroy(
; 850  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 851  : 		this->_Getal().destroy(
; 852  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 853  : 		this->_Getal().destroy(

  00004	8b 75 08	 mov	 esi, DWORD PTR __Pnode$[ebp]
  00007	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0000a	e8 00 00 00 00	 call	 ??1SecurityTokenInfo@GostCrypt@@QAE@XZ

; 854  : 			_STD addressof(this->_Myval(_Pnode)));
; 855  : 		this->_Getal().deallocate(_Pnode, 1);

  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
  00018	5e		 pop	 esi

; 856  : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?_Freenode@?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEXPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@@Z ENDP ; std::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Freenode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >, COMDAT
; _this$ = ecx

; 818  : 		{	// default construct

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Buynode0
  00020	89 06		 mov	 DWORD PTR [esi], eax

; 819  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myval@?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@SAAAUSecurityTokenInfo@GostCrypt@@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@SAAAUSecurityTokenInfo@GostCrypt@@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >::_Myval, COMDAT

; 545  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 546  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 547  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@SAAAUSecurityTokenInfo@GostCrypt@@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Prevnode@?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >::_Prevnode, COMDAT

; 540  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 541  : 		return ((_Nodepref)_Pnode->_Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 542  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >::_Nextnode, COMDAT

; 535  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 536  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 537  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >, COMDAT
; _this$ = ecx

; 529  : 		: _Myhead(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 532  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >::_List_val<std::_List_simple_types<GostCrypt::SecurityTokenInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Mysize@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QBEABIXZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Mysize, COMDAT
; _this$ = ecx

; 797  : 		return (_Get_data()._Mysize);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 798  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QBEABIXZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Mysize@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Mysize, COMDAT
; _this$ = ecx

; 792  : 		return (_Get_data()._Mysize);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 793  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myhead@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Myhead, COMDAT
; _this$ = ecx

; 782  : 		return (_Get_data()._Myhead);

  00000	8b c1		 mov	 eax, ecx

; 783  : 		}

  00002	c3		 ret	 0
?_Myhead@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Get_data@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 777  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 778  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Get_data@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 772  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 773  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@USecurityTokenInfo@GostCrypt@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Getal@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 767  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 768  : 		}

  00002	c3		 ret	 0
?_Getal@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Getal@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 762  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 763  : 		}

  00002	c3		 ret	 0
?_Getal@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Swap_all@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_all@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Swap_all, COMDAT
; _this$ = ecx

; 757  : 		_Get_data()._Swap_all(_Right._Get_data());
; 758  : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Buynode0@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@0@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
?_Buynode0@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@0@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Buynode0, COMDAT
; _this$ = ecx

; 729  : 		{	// allocate a node and set links

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 730  : 		_Nodeptr _Pnode = _Getal().allocate(1);

  00003	6a 40		 push	 64			; 00000040H
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4
  0000d	85 c0		 test	 eax, eax
  0000f	74 1f		 je	 SHORT $LN117@Buynode0

; 731  : 
; 732  : 		if (_Next == _Nodeptr())

  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Next$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	75 06		 jne	 SHORT $LN115@Buynode0

; 733  : 			{	// point at self
; 734  : 			_Next = _Pnode;

  00018	8b c8		 mov	 ecx, eax

; 735  : 			_Prev = _Pnode;

  0001a	8b d0		 mov	 edx, eax
  0001c	eb 03		 jmp	 SHORT $LN2@Buynode0
$LN115@Buynode0:
  0001e	8b 55 0c	 mov	 edx, DWORD PTR __Prev$[ebp]
$LN2@Buynode0:

; 736  : 			}
; 737  : 		_TRY_BEGIN
; 738  : 		_Getal().construct(

  00021	89 08		 mov	 DWORD PTR [eax], ecx

; 739  : 			_STD addressof(_Nextnode(_Pnode)), _Next);
; 740  : 		_Getal().construct(

  00023	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00026	85 c9		 test	 ecx, ecx
  00028	74 02		 je	 SHORT $LN4@Buynode0
  0002a	89 11		 mov	 DWORD PTR [ecx], edx
$LN4@Buynode0:

; 741  : 			_STD addressof(_Prevnode(_Pnode)), _Prev);
; 742  : 		_CATCH_ALL
; 743  : 		_Getal().deallocate(_Pnode, 1);
; 744  : 		_RERAISE;
; 745  : 		_CATCH_END
; 746  : 
; 747  : 		return (_Pnode);
; 748  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
$LN117@Buynode0:

; 730  : 		_Nodeptr _Pnode = _Getal().allocate(1);

  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN119@Buynode0:
$LN116@Buynode0:
  00035	cc		 int	 3
?_Buynode0@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@0@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Freeheadnode@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEXPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEXPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Freeheadnode, COMDAT
; _this$ = ecx

; 719  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Getal().destroy(
; 721  : 			_STD addressof(_Nextnode(_Pnode)));
; 722  : 		_Getal().destroy(
; 723  : 			_STD addressof(_Prevnode(_Pnode)));
; 724  : 		_Getal().deallocate(_Pnode, 1);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 725  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freeheadnode@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEXPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Buyheadnode@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Buyheadnode, COMDAT
; _this$ = ecx

; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Buynode0

; 716  : 		}

  00009	c3		 ret	 0
?_Buyheadnode@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??1?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::~_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >, COMDAT
; _this$ = ecx

; 617  : 		_Freeheadnode(_Myhead());

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx

; 618  : 		}

  00008	c3		 ret	 0
??1?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::~_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >, COMDAT
; _this$ = ecx

; 602  : 		{	// default construct head node

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 603  : 		_Myhead() = _Buyheadnode();

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Buynode0
  00019	89 06		 mov	 DWORD PTR [esi], eax

; 604  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c3		 ret	 0
??0?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myval@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@SAAAUSecurityTokenInfo@GostCrypt@@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@SAAAUSecurityTokenInfo@GostCrypt@@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Myval, COMDAT

; 595  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 596  : 		return (_List_val<_Val_types>::_Myval(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 597  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@SAAAUSecurityTokenInfo@GostCrypt@@PAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Prevnode@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Prevnode, COMDAT

; 590  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 591  : 		return (_List_val<_Val_types>::_Prevnode(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 592  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Nextnode, COMDAT

; 585  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 586  : 		return (_List_val<_Val_types>::_Nextnode(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 587  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 03	 mov	 eax, 67108863		; 03ffffffH

; 1009 : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 988  : 		}

  00003	5d		 pop	 ebp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00004	e9 00 00 00 00	 jmp	 ?deallocate@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@I@Z ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 977  : 		}

  00003	5d		 pop	 ebp

; 976  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@I@Z ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	b8 ff ff ff 03	 mov	 eax, 67108863		; 03ffffffH

; 870  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 03	 mov	 eax, 67108863		; 03ffffffH

; 750  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d ff ff ff 03	 cmp	 eax, 67108863		; 03ffffffH
  00013	77 3c		 ja	 SHORT $LN14@allocate
  00015	c1 e0 06	 shl	 eax, 6
  00018	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001d	72 23		 jb	 SHORT $LN6@allocate
  0001f	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00022	3b c8		 cmp	 ecx, eax
  00024	76 30		 jbe	 SHORT $LN16@allocate
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002c	8b c8		 mov	 ecx, eax
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c9		 test	 ecx, ecx
  00033	74 26		 je	 SHORT $LN17@allocate
  00035	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00038	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0003b	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00048	83 c4 04	 add	 esp, 4
  0004b	85 c0		 test	 eax, eax
  0004d	75 bb		 jne	 SHORT $LN12@allocate
  0004f	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:
  00051	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:
  00056	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:
  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:
  00060	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00065	cc		 int	 3
?allocate@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	81 f9 ff ff ff
	03		 cmp	 ecx, 67108863		; 03ffffffH
  0000f	77 31		 ja	 SHORT $LN13@deallocate
  00011	c1 e1 06	 shl	 ecx, 6
  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 19		 jb	 SHORT $LN5@deallocate
  0001c	a8 1f		 test	 al, 31			; 0000001fH
  0001e	75 27		 jne	 SHORT $LN15@deallocate
  00020	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00023	3b c8		 cmp	 ecx, eax
  00025	73 25		 jae	 SHORT $LN16@deallocate
  00027	2b c1		 sub	 eax, ecx
  00029	83 f8 04	 cmp	 eax, 4
  0002c	72 23		 jb	 SHORT $LN17@deallocate
  0002e	83 f8 23	 cmp	 eax, 35			; 00000023H
  00031	77 23		 ja	 SHORT $LN18@deallocate
  00033	8b c1		 mov	 eax, ecx
$LN5@deallocate:
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4

; 721  : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00042	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:
  00047	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00056	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005b	cc		 int	 3
?deallocate@?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >::allocator<std::_List_node<GostCrypt::SecurityTokenInfo,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z PROC ; std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2489 : 	{	// test for string inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2490 : 	return (!(_Left == _Right));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  0000a	8d 50 10	 lea	 edx, DWORD PTR [eax+16]
  0000d	72 02		 jb	 SHORT $LN28@operator
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN28@operator:
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00014	56		 push	 esi
  00015	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00019	8d 71 10	 lea	 esi, DWORD PTR [ecx+16]
  0001c	72 02		 jb	 SHORT $LN51@operator
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN51@operator:
  00020	ff 32		 push	 DWORD PTR [edx]
  00022	50		 push	 eax
  00023	ff 36		 push	 DWORD PTR [esi]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ?_Traits_compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAHQB_WI0I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Traits_compare
  0002b	83 c4 10	 add	 esp, 16			; 00000010H
  0002e	85 c0		 test	 eax, eax
  00030	0f 95 c0	 setne	 al
  00033	5e		 pop	 esi

; 2491 : 	}

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ENDP ; std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$GetContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$vector@KV?$allocator@K@std@@@std@@@01@@Z
_TEXT	SEGMENT
_forEachContainer$ = 8					; size = 4
___formal$ = 12						; size = 4
??$GetContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$vector@KV?$allocator@K@std@@@std@@@01@@Z PROC ; GostCrypt::ForEach::GetContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >, COMDAT

; 95   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 96   : 			return static_cast <const ContainerForward <T> &> (forEachContainer);

  00003	8b 45 08	 mov	 eax, DWORD PTR _forEachContainer$[ebp]

; 97   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$GetContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$vector@KV?$allocator@K@std@@@std@@@01@@Z ENDP ; GostCrypt::ForEach::GetContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$?BV?$vector@KV?$allocator@K@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$vector@KV?$allocator@K@std@@@std@@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BV?$vector@KV?$allocator@K@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$vector@KV?$allocator@K@std@@@std@@@12@XZ PROC ; GostCrypt::ForEach::TypeWrapperDummy::operator<std::vector<unsigned long,std::allocator<unsigned long> > > GostCrypt::ForEach::TypeWrapper<std::vector<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx

; 90   : 			operator TypeWrapper <T> () const { return TypeWrapper <T> (); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
??$?BV?$vector@KV?$allocator@K@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$vector@KV?$allocator@K@std@@@std@@@12@XZ ENDP ; GostCrypt::ForEach::TypeWrapperDummy::operator<std::vector<unsigned long,std::allocator<unsigned long> > > GostCrypt::ForEach::TypeWrapper<std::vector<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$ToTypeWrapper@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$vector@KV?$allocator@K@std@@@std@@@01@ABV?$vector@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
_x$ = 8							; size = 4
??$ToTypeWrapper@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$vector@KV?$allocator@K@std@@@std@@@01@ABV?$vector@KV?$allocator@K@std@@@std@@@Z PROC ; GostCrypt::ForEach::ToTypeWrapper<std::vector<unsigned long,std::allocator<unsigned long> > >, COMDAT

; 85   : 		static TypeWrapper <T> ToTypeWrapper (const T &x) { return TypeWrapper <T> (); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8a 45 ff	 mov	 al, BYTE PTR $T1[ebp]
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$ToTypeWrapper@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$vector@KV?$allocator@K@std@@@std@@@01@ABV?$vector@KV?$allocator@K@std@@@std@@@Z ENDP ; GostCrypt::ForEach::ToTypeWrapper<std::vector<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z PROC ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi
  00007	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000a	85 c9		 test	 ecx, ecx
  0000c	74 27		 je	 SHORT $LN11@scalar
  0000e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00011	2b c1		 sub	 eax, ecx
  00013	c1 f8 02	 sar	 eax, 2
  00016	50		 push	 eax
  00017	51		 push	 ecx
  00018	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0001b	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
  00020	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00027	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0002e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
$LN11@scalar:
  00035	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00039	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  0003f	74 0b		 je	 SHORT $LN103@scalar
  00041	6a 1c		 push	 28			; 0000001cH
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00049	83 c4 08	 add	 esp, 8
$LN103@scalar:
  0004c	5f		 pop	 edi
  0004d	8b c6		 mov	 eax, esi
  0004f	5e		 pop	 esi
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
??_G?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
_TEXT	SEGMENT
??1?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAE@XZ PROC ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::~ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
  00004	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00007	85 c9		 test	 ecx, ecx
  00009	74 27		 je	 SHORT $LN99@ContainerF
  0000b	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0000e	2b c1		 sub	 eax, ecx
  00010	c1 f8 02	 sar	 eax, 2
  00013	50		 push	 eax
  00014	51		 push	 ecx
  00015	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00018	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
  0001d	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00024	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  0002b	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
$LN99@ContainerF:
  00032	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	c3		 ret	 0
??1?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAE@XZ ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::~ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Compat, COMDAT
; _this$ = ecx

; 262  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator!=, COMDAT
; _this$ = ecx

; 218  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 95 c0	 setne	 al

; 219  : 		return (!(*this == _Right));
; 220  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator==, COMDAT
; _this$ = ecx

; 212  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 213  : 		_Compat(_Right);
; 214  : 		return (_Ptr == _Right._Ptr);
; 215  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 98   : 		if (_Mycont == 0
; 99   : 			|| _Ptr == nullptr_t{}
; 100  : 			|| _Mycont->_Mylast <= _Ptr)
; 101  : 			{	// report error
; 102  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 103  : 			_SCL_SECURE_OUT_OF_RANGE;
; 104  : 			}
; 105  : 
; 106  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 107  : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 108  : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 109  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 110  : 		_SCL_SECURE_VALIDATE_RANGE(_Ptr < _Mycont->_Mylast);
; 111  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 112  : 
; 113  : 		++_Ptr;

  00000	83 01 04	 add	 DWORD PTR [ecx], 4

; 114  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 115  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEABKXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEABKXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 68   : 		if (_Mycont == 0
; 69   : 			|| _Ptr == _Tptr()
; 70   : 			|| _Ptr < _Mycont->_Myfirst
; 71   : 			|| _Mycont->_Mylast <= _Ptr)
; 72   : 			{	// report error
; 73   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 74   : 			_SCL_SECURE_OUT_OF_RANGE;
; 75   : 			}
; 76   : 
; 77   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 78   : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 79   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 80   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 81   : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEABKXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEPBKXZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEPBKXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Unchecked, COMDAT
; _this$ = ecx

; 61   : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 62   : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEPBKXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?Next@?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBEXXZ
_TEXT	SEGMENT
?Next@?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBEXXZ PROC ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::Next, COMDAT
; _this$ = ecx

; 39   : 			virtual void Next () const { ++Iterator; }

  00000	83 41 18 04	 add	 DWORD PTR [ecx+24], 4
  00004	c3		 ret	 0
?Next@?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBEXXZ ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::Next
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?IsNotEnd@?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ
_TEXT	SEGMENT
?IsNotEnd@?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ PROC ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::IsNotEnd, COMDAT
; _this$ = ecx

; 38   : 			virtual bool IsNotEnd () const { bool r = InnerContinue && Iterator != EndIterator; InnerContinue = false; return r; }

  00000	80 79 04 00	 cmp	 BYTE PTR [ecx+4], 0
  00004	74 0f		 je	 SHORT $LN3@IsNotEnd
  00006	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00009	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  0000c	74 07		 je	 SHORT $LN3@IsNotEnd
  0000e	b0 01		 mov	 al, 1
  00010	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00014	c3		 ret	 0
$LN3@IsNotEnd:
  00015	32 c0		 xor	 al, al
  00017	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0001a	c3		 ret	 0
?IsNotEnd@?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::IsNotEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??0?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_container$ = 8						; size = 4
??0?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@KV?$allocator@K@std@@@std@@@Z PROC ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx

; 36   : 				: ContainerCopy (container), EndIterator (ContainerCopy.end()), Iterator (ContainerCopy.begin()) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@KV?$allocator@K@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002a	66 c7 47 04 01
	00		 mov	 WORD PTR [edi+4], 1
  00030	ff 75 08	 push	 DWORD PTR _container$[ebp]
  00033	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@
  00043	e8 00 00 00 00	 call	 ??0?$vector@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
  00048	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0004b	89 47 14	 mov	 DWORD PTR [edi+20], eax
  0004e	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00051	89 47 18	 mov	 DWORD PTR [edi+24], eax
  00054	8b c7		 mov	 eax, edi
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00060	59		 pop	 ecx
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@KV?$allocator@K@std@@@std@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Container@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::Container::~Container
__ehhandler$??0?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@KV?$allocator@K@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@KV?$allocator@K@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@KV?$allocator@K@std@@@std@@@Z ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >::ContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$GetContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@01@ABV?$vector@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_container$ = 12					; size = 4
??$GetContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@01@ABV?$vector@KV?$allocator@K@std@@@std@@@Z PROC ; GostCrypt::ForEach::GetContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >, COMDAT

; 69   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$GetContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@01@ABV?$vector@KV?$allocator@K@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 70   : 			return ContainerForward <T> (container);

  00025	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00028	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0002f	66 c7 47 04 01
	00		 mov	 WORD PTR [edi+4], 1
  00035	ff 75 0c	 push	 DWORD PTR _container$[ebp]
  00038	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@
  00048	e8 00 00 00 00	 call	 ??0?$vector@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
  0004d	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00050	8b c7		 mov	 eax, edi
  00052	89 4f 14	 mov	 DWORD PTR [edi+20], ecx
  00055	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00058	89 4f 18	 mov	 DWORD PTR [edi+24], ecx

; 71   : 		}

  0005b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00065	59		 pop	 ecx
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@01@ABV?$vector@KV?$allocator@K@std@@@std@@@Z$1:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Container@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::Container::~Container
__ehhandler$??$GetContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@01@ABV?$vector@KV?$allocator@K@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$GetContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@01@ABV?$vector@KV?$allocator@K@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$GetContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@01@ABV?$vector@KV?$allocator@K@std@@@std@@@Z ENDP ; GostCrypt::ForEach::GetContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@IBEXPAK0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@IBEXPAK0@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1794 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@IBEXPAK0@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen, COMDAT
; _this$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 25		 je	 SHORT $LN2@Tidy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c1		 sub	 eax, ecx
  0000e	c1 f8 02	 sar	 eax, 2
  00011	50		 push	 eax
  00012	51		 push	 ecx
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate

; 1642 : 				this->_Myend() - this->_Myfirst());
; 1643 : 			this->_Myfirst() = pointer();

  0001a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1644 : 			this->_Mylast() = pointer();

  00020	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

  00027	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:
  0002e	5e		 pop	 esi

; 1646 : 			}
; 1647 : 		}

  0002f	c3		 ret	 0
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1627 : 		if (_Unused_capacity() < _Count)

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	57		 push	 edi
  0000a	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0000d	8b c7		 mov	 eax, edi
  0000f	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00012	2b c2		 sub	 eax, edx
  00014	c1 f8 02	 sar	 eax, 2
  00017	3b c1		 cmp	 eax, ecx
  00019	73 37		 jae	 SHORT $LN2@Reserve

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

  0001b	2b 16		 sub	 edx, DWORD PTR [esi]
  0001d	53		 push	 ebx
  0001e	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  00023	c1 fa 02	 sar	 edx, 2
  00026	8b c3		 mov	 eax, ebx
  00028	2b c2		 sub	 eax, edx
  0002a	3b c1		 cmp	 eax, ecx
  0002c	72 2a		 jb	 SHORT $LN134@Reserve

; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

  0002e	2b 3e		 sub	 edi, DWORD PTR [esi]
  00030	03 d1		 add	 edx, ecx
  00032	c1 ff 02	 sar	 edi, 2
  00035	33 c9		 xor	 ecx, ecx
  00037	8b c7		 mov	 eax, edi
  00039	d1 e8		 shr	 eax, 1
  0003b	2b d8		 sub	 ebx, eax
  0003d	03 c7		 add	 eax, edi
  0003f	3b df		 cmp	 ebx, edi
  00041	0f 43 c8	 cmovae	 ecx, eax
  00044	3b ca		 cmp	 ecx, edx
  00046	0f 43 d1	 cmovae	 edx, ecx
  00049	8b ce		 mov	 ecx, esi
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reallocate
  00051	5b		 pop	 ebx
$LN2@Reserve:
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi

; 1632 : 			}
; 1633 : 		}

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN134@Reserve:

; 1630 : 				_Xlen();

  00058	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0005d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN136@Reserve:
$LN133@Reserve:
  00062	cc		 int	 3
?_Reserve@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  00006	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?allocate@?$allocator@K@std@@QAEPAKI@Z ; std::allocator<unsigned long>::allocate

; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);

  00010	8b 37		 mov	 esi, DWORD PTR [edi]
  00012	8b d8		 mov	 ebx, eax
  00014	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00017	2b d6		 sub	 edx, esi
  00019	52		 push	 edx
  0001a	56		 push	 esi
  0001b	53		 push	 ebx
  0001c	e8 00 00 00 00	 call	 _memmove

; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();

  00021	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00029	2b f1		 sub	 esi, ecx
  0002b	c1 fe 02	 sar	 esi, 2

; 1612 : 		if (this->_Myfirst() != pointer())

  0002e	85 c9		 test	 ecx, ecx
  00030	74 11		 je	 SHORT $LN3@Reallocate

; 1613 : 			{	// destroy and deallocate old array
; 1614 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

  00032	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00035	2b c1		 sub	 eax, ecx
  00037	c1 f8 02	 sar	 eax, 2
  0003a	50		 push	 eax
  0003b	51		 push	 ecx
  0003c	8b cf		 mov	 ecx, edi
  0003e	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
$LN3@Reallocate:

; 1616 : 				this->_Myend() - this->_Myfirst());
; 1617 : 			}
; 1618 : 
; 1619 : 		this->_Orphan_all();
; 1620 : 		this->_Myend() = _Ptr + _Count;

  00043	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00046	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  00049	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1621 : 		this->_Mylast() = _Ptr + _Size;

  0004c	8d 04 b3	 lea	 eax, DWORD PTR [ebx+esi*4]
  0004f	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1622 : 		this->_Myfirst() = _Ptr;

  00052	89 1f		 mov	 DWORD PTR [edi], ebx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx

; 1623 : 		}

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@KV?$allocator@K@std@@@std@@IBE_NPBK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@KV?$allocator@K@std@@@std@@IBE_NPBK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Inside, COMDAT
; _this$ = ecx

; 1596 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1598 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1598 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@KV?$allocator@K@std@@@std@@IBE_NPBK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@KV?$allocator@K@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@KV?$allocator@K@std@@@std@@IBEII@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1586 : 		size_type _Capacity = capacity();

  00004	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]

; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00007	ba ff ff ff 3f	 mov	 edx, 1073741823		; 3fffffffH
  0000c	2b 31		 sub	 esi, DWORD PTR [ecx]
  0000e	c1 fe 02	 sar	 esi, 2
  00011	8b c6		 mov	 eax, esi
  00013	d1 e8		 shr	 eax, 1
  00015	2b d0		 sub	 edx, eax
  00017	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0001a	33 c0		 xor	 eax, eax
  0001c	3b d6		 cmp	 edx, esi
  0001e	5e		 pop	 esi
  0001f	0f 43 c1	 cmovae	 eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

  00022	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00025	0f 42 45 08	 cmovb	 eax, DWORD PTR __Count$[ebp]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?_Grow_to@?$vector@KV?$allocator@K@std@@@std@@IBEII@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy, COMDAT
; _this$ = ecx

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy, COMDAT
; _this$ = ecx

; 1561 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1562 : 		this->_Myfirst() = pointer();
; 1563 : 		this->_Mylast() = pointer();
; 1564 : 		this->_Myend() = pointer();
; 1565 : 
; 1566 : 		if (_Capacity == 0)

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Capacity$[ebp]
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00010	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00017	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001e	85 ff		 test	 edi, edi
  00020	75 08		 jne	 SHORT $LN2@Buy

; 1567 : 			return (false);

  00022	5f		 pop	 edi
  00023	32 c0		 xor	 al, al
  00025	5e		 pop	 esi

; 1577 : 		}

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN2@Buy:

; 1568 : 		else if (max_size() < _Capacity)

  0002a	81 ff ff ff ff
	3f		 cmp	 edi, 1073741823		; 3fffffffH
  00030	77 1b		 ja	 SHORT $LN109@Buy

; 1570 : 		else
; 1571 : 			{	// nonempty array, allocate storage
; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@K@std@@QAEPAKI@Z ; std::allocator<unsigned long>::allocate
  00038	89 06		 mov	 DWORD PTR [esi], eax

; 1573 : 			this->_Mylast() = this->_Myfirst();

  0003a	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

  0003d	8b 06		 mov	 eax, DWORD PTR [esi]
  0003f	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  00042	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1575 : 			}
; 1576 : 		return (true);

  00045	b0 01		 mov	 al, 1
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi

; 1577 : 		}

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
$LN109@Buy:

; 1569 : 			_Xlen();	// result too long

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00052	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN111@Buy:
$LN108@Buy:
  00057	cc		 int	 3
?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::push_back, COMDAT
; _this$ = ecx

; 1276 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1277 : 		if (_Inside(_STD addressof(_Val)))

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 31		 jae	 SHORT $LN2@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 2b		 ja	 SHORT $LN2@push_back

; 1278 : 			{	// push back an element
; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

  00017	2b f9		 sub	 edi, ecx
  00019	c1 ff 02	 sar	 edi, 2

; 1280 : 			if (this->_Mylast() == this->_Myend())

  0001c	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001f	75 09		 jne	 SHORT $LN4@push_back

; 1281 : 				_Reserve(1);

  00021	6a 01		 push	 1
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?_Reserve@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reserve
$LN4@push_back:

; 1282 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

  0002a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 2a		 je	 SHORT $LN209@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]

; 1291 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1292 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

  00036	89 01		 mov	 DWORD PTR [ecx], eax

; 1293 : 				_Val);
; 1294 : 			++this->_Mylast();

  00038	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 1295 : 			}
; 1296 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN2@push_back:

; 1284 : 				this->_Myfirst()[_Idx]);
; 1285 : 			++this->_Mylast();
; 1286 : 			}
; 1287 : 		else
; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

  00042	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00045	75 09		 jne	 SHORT $LN5@push_back

; 1290 : 				_Reserve(1);

  00047	6a 01		 push	 1
  00049	8b ce		 mov	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reserve
$LN5@push_back:

; 1291 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1292 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

  00050	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00053	85 c9		 test	 ecx, ecx
  00055	74 04		 je	 SHORT $LN209@push_back
  00057	8b 07		 mov	 eax, DWORD PTR [edi]
  00059	89 01		 mov	 DWORD PTR [ecx], eax
$LN209@push_back:

; 1293 : 				_Val);
; 1294 : 			++this->_Mylast();

  0005b	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 1295 : 			}
; 1296 : 		}

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?front@?$vector@KV?$allocator@K@std@@@std@@QAEAAKXZ
_TEXT	SEGMENT
?front@?$vector@KV?$allocator@K@std@@@std@@QAEAAKXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::front, COMDAT
; _this$ = ecx

; 1257 : 		return (*begin());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1258 : 		}

  00002	c3		 ret	 0
?front@?$vector@KV?$allocator@K@std@@@std@@QAEAAKXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::operator[], COMDAT
; _this$ = ecx

; 1230 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00008	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1243 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size, COMDAT
; _this$ = ecx

; 1185 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1186 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1181 : 		}

  00008	c3		 ret	 0
?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@KV?$allocator@K@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@KV?$allocator@K@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::end, COMDAT
; _this$ = ecx

; 1072 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1073 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1074 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@KV?$allocator@K@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@KV?$allocator@K@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@KV?$allocator@K@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::begin, COMDAT
; _this$ = ecx

; 1062 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1063 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1064 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@KV?$allocator@K@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::begin, COMDAT
; _this$ = ecx

; 1057 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1058 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1059 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  00006	c1 f8 02	 sar	 eax, 2

; 1049 : 		}

  00009	c3		 ret	 0
?_Unused_capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1044 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 976  : 		_Tidy();

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 25		 je	 SHORT $LN4@vector
  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c1		 sub	 eax, ecx
  0000e	c1 f8 02	 sar	 eax, 2
  00011	50		 push	 eax
  00012	51		 push	 ecx
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
  0001a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00020	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00027	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  0002e	5e		 pop	 esi

; 977  : 		}

  0002f	c3		 ret	 0
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Assign_rv@?$vector@KV?$allocator@K@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv@?$vector@KV?$allocator@K@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Assign_rv, COMDAT
; _this$ = ecx

; 868  : 		{	// move from _Right, stealing its contents

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 869  : 		this->_Swap_all((_Myt&)_Right);
; 870  : 		this->_Myfirst() = _Right._Myfirst();

  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 871  : 		this->_Mylast() = _Right._Mylast();

  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 872  : 		this->_Myend() = _Right._Myend();

  00010	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00013	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 873  : 
; 874  : 		_Right._Myfirst() = pointer();

  00016	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 875  : 		_Right._Mylast() = pointer();

  0001c	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 876  : 		_Right._Myend() = pointer();

  00023	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 877  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?_Assign_rv@?$vector@KV?$allocator@K@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@KV?$allocator@K@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$vector@KV?$allocator@K@std@@@std@@QAE@$$QAV01@@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 841  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 842  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());

  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0000c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00013	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	89 01		 mov	 DWORD PTR [ecx], eax
  0001e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00021	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00024	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00027	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 843  : 		}

  0002a	8b c1		 mov	 eax, ecx
  0002c	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00032	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  00039	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$vector@KV?$allocator@K@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$vector@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 748  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b d9		 mov	 ebx, ecx
  00007	57		 push	 edi

; 749  : 		if (_Buy(_Right.size()))

  00008	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  0000b	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00011	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00018	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  0001f	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00022	2b 37		 sub	 esi, DWORD PTR [edi]
  00024	c1 fe 02	 sar	 esi, 2
  00027	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  0002d	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00034	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  0003b	85 f6		 test	 esi, esi
  0003d	74 38		 je	 SHORT $LN5@vector
  0003f	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  00045	77 39		 ja	 SHORT $LN257@vector
  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 ?allocate@?$allocator@K@std@@QAEPAKI@Z ; std::allocator<unsigned long>::allocate
  0004d	89 03		 mov	 DWORD PTR [ebx], eax
  0004f	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00052	8b 03		 mov	 eax, DWORD PTR [ebx]
  00054	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]
  00057	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 750  : 			_TRY_BEGIN
; 751  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0005d	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  00060	8b 33		 mov	 esi, DWORD PTR [ebx]
  00062	8b 00		 mov	 eax, DWORD PTR [eax]
  00064	2b f8		 sub	 edi, eax
  00066	57		 push	 edi
  00067	50		 push	 eax
  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 _memmove
  0006e	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
  00074	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN5@vector:

; 752  : 				this->_Myfirst());
; 753  : 			_CATCH_ALL
; 754  : 			_Tidy();
; 755  : 			_RERAISE;
; 756  : 			_CATCH_END
; 757  : 		}

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	8b c3		 mov	 eax, ebx
  0007b	5b		 pop	 ebx
  0007c	5d		 pop	 ebp
  0007d	c2 04 00	 ret	 4
$LN257@vector:

; 749  : 		if (_Buy(_Right.size()))

  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00085	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN259@vector:
$LN256@vector:
  0008a	cc		 int	 3
??0?$vector@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@KV?$allocator@K@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$vector@KV?$allocator@K@std@@@std@@QAE@I@Z PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 717  : 		{	// construct from _Count * value_type()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 718  : 		if (_Buy(_Count))

  00004	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00010	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00017	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  0001e	85 f6		 test	 esi, esi
  00020	74 2d		 je	 SHORT $LN5@vector
  00022	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  00028	77 2d		 ja	 SHORT $LN153@vector
  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 ?allocate@?$allocator@K@std@@QAEPAKI@Z ; std::allocator<unsigned long>::allocate
  00030	89 07		 mov	 DWORD PTR [edi], eax
  00032	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00035	8b 07		 mov	 eax, DWORD PTR [edi]
  00037	c1 e6 02	 shl	 esi, 2

; 719  : 			{	// nonzero, fill it
; 720  : 			_TRY_BEGIN
; 721  : 			_Uninitialized_default_fill_n(this->_Myfirst(), _Count,

  0003a	56		 push	 esi
  0003b	03 c6		 add	 eax, esi
  0003d	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00040	6a 00		 push	 0
  00042	ff 37		 push	 DWORD PTR [edi]
  00044	e8 00 00 00 00	 call	 _memset
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH

; 722  : 				this->_Getal());
; 723  : 			this->_Mylast() += _Count;

  0004c	01 77 04	 add	 DWORD PTR [edi+4], esi
$LN5@vector:

; 724  : 			_CATCH_ALL
; 725  : 			_Tidy();
; 726  : 			_RERAISE;
; 727  : 			_CATCH_END
; 728  : 			}
; 729  : 		}

  0004f	8b c7		 mov	 eax, edi
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
$LN153@vector:

; 718  : 		if (_Buy(_Count))

  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0005c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN155@vector:
$LN152@vector:
  00061	cc		 int	 3
??0?$vector@KV?$allocator@K@std@@@std@@QAE@I@Z ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 706  : 		: _Mybase()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 708  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@K@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned long> >::_Vector_val<std::_Simple_types<unsigned long> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 489  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@K@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned long> >::_Vector_val<std::_Simple_types<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 669  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 664  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 659  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 654  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 649  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 644  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 639  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 634  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 629  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 624  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Swap_all, COMDAT
; _this$ = ecx

; 618  : 		_Get_data()._Swap_all(_Right._Get_data());
; 619  : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx

; 519  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 521  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$list@KV?$allocator@K@std@@@std@@@01@@Z
_TEXT	SEGMENT
_forEachContainer$ = 8					; size = 4
___formal$ = 12						; size = 4
??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$list@KV?$allocator@K@std@@@std@@@01@@Z PROC ; GostCrypt::ForEach::GetContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >, COMDAT

; 95   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 96   : 			return static_cast <const ContainerForward <T> &> (forEachContainer);

  00003	8b 45 08	 mov	 eax, DWORD PTR _forEachContainer$[ebp]

; 97   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$list@KV?$allocator@K@std@@@std@@@01@@Z ENDP ; GostCrypt::ForEach::GetContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$?BV?$list@KV?$allocator@K@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$list@KV?$allocator@K@std@@@std@@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BV?$list@KV?$allocator@K@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$list@KV?$allocator@K@std@@@std@@@12@XZ PROC ; GostCrypt::ForEach::TypeWrapperDummy::operator<std::list<unsigned long,std::allocator<unsigned long> > > GostCrypt::ForEach::TypeWrapper<std::list<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx

; 90   : 			operator TypeWrapper <T> () const { return TypeWrapper <T> (); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
??$?BV?$list@KV?$allocator@K@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$list@KV?$allocator@K@std@@@std@@@12@XZ ENDP ; GostCrypt::ForEach::TypeWrapperDummy::operator<std::list<unsigned long,std::allocator<unsigned long> > > GostCrypt::ForEach::TypeWrapper<std::list<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$ToTypeWrapper@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
_x$ = 8							; size = 4
??$ToTypeWrapper@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z PROC ; GostCrypt::ForEach::ToTypeWrapper<std::list<unsigned long,std::allocator<unsigned long> > >, COMDAT

; 85   : 		static TypeWrapper <T> ToTypeWrapper (const T &x) { return TypeWrapper <T> (); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8a 45 ff	 mov	 al, BYTE PTR $T1[ebp]
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$ToTypeWrapper@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z ENDP ; GostCrypt::ForEach::ToTypeWrapper<std::list<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z PROC ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 18		 push	 24			; 00000018H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z ENDP ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
_TEXT	SEGMENT
??1?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAE@XZ PROC ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::~ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx
  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx
  00003	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 12		 mov	 DWORD PTR [edx], edx
  0000a	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  0000d	89 52 04	 mov	 DWORD PTR [edx+4], edx
  00010	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  00017	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  0001a	74 17		 je	 SHORT $LN10@ContainerF
  0001c	56		 push	 esi
  0001d	0f 1f 00	 npad	 3
$LL11@ContainerF:
  00020	8b 30		 mov	 esi, DWORD PTR [eax]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 04	 add	 esp, 4
  0002b	8b c6		 mov	 eax, esi
  0002d	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  00030	75 ee		 jne	 SHORT $LL11@ContainerF
  00032	5e		 pop	 esi
$LN10@ContainerF:
  00033	ff 77 08	 push	 DWORD PTR [edi+8]
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4
  0003e	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00044	5f		 pop	 edi
  00045	c3		 ret	 0
??1?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAE@XZ ENDP ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::~ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::operator!=, COMDAT
; _this$ = ecx

; 305  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 95 c0	 setne	 al

; 306  : 		return (!(*this == _Right));
; 307  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::operator==, COMDAT
; _this$ = ecx

; 289  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 290  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 291  : 		if (this->_Getcont() != _Right._Getcont())
; 292  : 			{	// report error
; 293  : 			_DEBUG_ERROR("list iterators incompatible");
; 294  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 295  : 			}
; 296  : 
; 297  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 298  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 299  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 300  : 
; 301  : 		return (this->_Ptr == _Right._Ptr);
; 302  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??F?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::operator--, COMDAT
; _this$ = ecx

; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 259  : 		if (_Mycont == 0
; 260  : 			|| this->_Ptr == nullptr_t{}
; 261  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr)) == _Mycont->_Myhead)
; 262  : 			{	// report error
; 263  : 			_DEBUG_ERROR("list iterator not decrementable");
; 264  : 			_SCL_SECURE_OUT_OF_RANGE;
; 265  : 			}
; 266  : 
; 267  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 268  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 269  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 270  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 271  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 272  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 273  : 
; 274  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 275  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00005	89 01		 mov	 DWORD PTR [ecx], eax

; 276  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 277  : 
; 278  : 		return (*this);

  00007	8b c1		 mov	 eax, ecx

; 279  : 		}

  00009	c3		 ret	 0
??F?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::operator++, COMDAT
; _this$ = ecx

; 227  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 228  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 229  : 		if (_Mycont == 0
; 230  : 			|| this->_Ptr == nullptr_t{}
; 231  : 			|| this->_Ptr == _Mycont->_Myhead)
; 232  : 			{	// report error
; 233  : 			_DEBUG_ERROR("list iterator not incrementable");
; 234  : 			_SCL_SECURE_OUT_OF_RANGE;
; 235  : 			}
; 236  : 
; 237  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 238  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 239  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 240  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 241  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 242  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 243  : 
; 244  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 245  : 		return (*this);

  00006	8b c1		 mov	 eax, ecx

; 246  : 		}

  00008	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QBEABKXZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QBEABKXZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::operator*, COMDAT
; _this$ = ecx

; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 207  : 		if (_Mycont == 0
; 208  : 			|| this->_Ptr == nullptr_t{}
; 209  : 			|| this->_Ptr == _Mycont->_Myhead)
; 210  : 			{	// report error
; 211  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 212  : 			_SCL_SECURE_OUT_OF_RANGE;
; 213  : 			}
; 214  : 
; 215  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 216  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 217  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 218  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 219  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 220  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 221  : 
; 222  : 		return (_Mylist::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 223  : 		}

  00005	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QBEABKXZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Unchecked@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::_Unchecked, COMDAT
; _this$ = ecx

; 199  : 		{	// make an unchecked iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 200  : 		return (_Unchecked_type(this->_Ptr, static_cast<const _Mylist *>(this->_Getcont())));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Unchecked@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAE@PAU?$_List_node@KPAX@1@PBV?$_List_val@U?$_List_simple_types@K@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAE@PAU?$_List_node@KPAX@1@PBV?$_List_val@U?$_List_simple_types@K@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >, COMDAT
; _this$ = ecx

; 187  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 186  : 		: _Mybase(_Pnode, _Plist)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 188  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@QAE@PAU?$_List_node@KPAX@1@PBV?$_List_val@U?$_List_simple_types@K@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@KPAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@KPAX@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 96   : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 97   : 		}

  00002	c3		 ret	 0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@KPAX@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00005	89 01		 mov	 DWORD PTR [ecx], eax

; 74   : 		return (*this);

  00007	8b c1		 mov	 eax, ecx

; 75   : 		}

  00009	c3		 ret	 0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@KPAX@1@PBV?$_List_val@U?$_List_simple_types@K@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@KPAX@1@PBV?$_List_val@U?$_List_simple_types@K@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		: _Ptr(_Pnode)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@KPAX@1@PBV?$_List_val@U?$_List_simple_types@K@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?Next@?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBEXXZ
_TEXT	SEGMENT
?Next@?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBEXXZ PROC ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::Next, COMDAT
; _this$ = ecx

; 39   : 			virtual void Next () const { ++Iterator; }

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]
  00005	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00008	c3		 ret	 0
?Next@?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBEXXZ ENDP ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::Next
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?IsNotEnd@?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ
_TEXT	SEGMENT
?IsNotEnd@?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ PROC ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::IsNotEnd, COMDAT
; _this$ = ecx

; 38   : 			virtual bool IsNotEnd () const { bool r = InnerContinue && Iterator != EndIterator; InnerContinue = false; return r; }

  00000	80 79 04 00	 cmp	 BYTE PTR [ecx+4], 0
  00004	74 0f		 je	 SHORT $LN3@IsNotEnd
  00006	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00009	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  0000c	74 07		 je	 SHORT $LN3@IsNotEnd
  0000e	b0 01		 mov	 al, 1
  00010	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00014	c3		 ret	 0
$LN3@IsNotEnd:
  00015	32 c0		 xor	 al, al
  00017	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0001a	c3		 ret	 0
?IsNotEnd@?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ ENDP ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::IsNotEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??0?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_container$ = 8						; size = 4
??0?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@KV?$allocator@K@std@@@std@@@Z PROC ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx

; 36   : 				: ContainerCopy (container), EndIterator (ContainerCopy.end()), Iterator (ContainerCopy.begin()) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@KV?$allocator@K@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002a	66 c7 47 04 01
	00		 mov	 WORD PTR [edi+4], 1
  00030	ff 75 08	 push	 DWORD PTR _container$[ebp]
  00033	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@
  00043	e8 00 00 00 00	 call	 ??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z ; std::list<unsigned long,std::allocator<unsigned long> >::list<unsigned long,std::allocator<unsigned long> >
  00048	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0004b	89 47 10	 mov	 DWORD PTR [edi+16], eax
  0004e	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 47 14	 mov	 DWORD PTR [edi+20], eax
  00056	8b c7		 mov	 eax, edi
  00058	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00062	59		 pop	 ecx
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@KV?$allocator@K@std@@@std@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Container@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::Container::~Container
__ehhandler$??0?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@KV?$allocator@K@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@KV?$allocator@K@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@KV?$allocator@K@std@@@std@@@Z ENDP ; GostCrypt::ForEach::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >::ContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_container$ = 12					; size = 4
??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z PROC ; GostCrypt::ForEach::GetContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >, COMDAT

; 69   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 70   : 			return ContainerForward <T> (container);

  00025	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00028	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0002f	66 c7 47 04 01
	00		 mov	 WORD PTR [edi+4], 1
  00035	ff 75 0c	 push	 DWORD PTR _container$[ebp]
  00038	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@6B@
  00048	e8 00 00 00 00	 call	 ??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z ; std::list<unsigned long,std::allocator<unsigned long> >::list<unsigned long,std::allocator<unsigned long> >
  0004d	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00050	8b c7		 mov	 eax, edi
  00052	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  00055	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00058	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0005a	89 4f 14	 mov	 DWORD PTR [edi+20], ecx

; 71   : 		}

  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00060	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00067	59		 pop	 ecx
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z$1:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Container@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::Container::~Container
__ehhandler$??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z ENDP ; GostCrypt::ForEach::GetContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Incsize@?$list@KV?$allocator@K@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Incsize@?$list@KV?$allocator@K@std@@@std@@QAEXI@Z PROC ; std::list<unsigned long,std::allocator<unsigned long> >::_Incsize, COMDAT
; _this$ = ecx

; 1906 : 		{	// alter element count, with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1907 : 		if (max_size() - this->_Mysize() - 1 < _Count)

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	b8 54 55 55 15	 mov	 eax, 357913940		; 15555554H
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  0000f	2b c2		 sub	 eax, edx
  00011	3b c6		 cmp	 eax, esi
  00013	72 0b		 jb	 SHORT $LN41@Incsize

; 1909 : 		this->_Mysize() += _Count;

  00015	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  00018	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0001b	5e		 pop	 esi

; 1910 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
$LN41@Incsize:

; 1908 : 			_Xlength_error("list<T> too long");

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00025	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN43@Incsize:
$LN40@Incsize:
  0002a	cc		 int	 3
?_Incsize@?$list@KV?$allocator@K@std@@@std@@QAEXI@Z ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::_Incsize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Tidy@?$list@KV?$allocator@K@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@KV?$allocator@K@std@@@std@@QAEXXZ PROC	; std::list<unsigned long,std::allocator<unsigned long> >::_Tidy, COMDAT
; _this$ = ecx

; 1883 : 		{	// free all storage

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 1884 : 		clear();

  00003	8b 17		 mov	 edx, DWORD PTR [edi]
  00005	8b 02		 mov	 eax, DWORD PTR [edx]
  00007	89 12		 mov	 DWORD PTR [edx], edx
  00009	8b 17		 mov	 edx, DWORD PTR [edi]
  0000b	89 52 04	 mov	 DWORD PTR [edx+4], edx
  0000e	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00015	3b 07		 cmp	 eax, DWORD PTR [edi]
  00017	74 19		 je	 SHORT $LN5@Tidy
  00019	56		 push	 esi
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL6@Tidy:
  00020	8b 30		 mov	 esi, DWORD PTR [eax]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 04	 add	 esp, 4
  0002b	8b c6		 mov	 eax, esi
  0002d	3b 37		 cmp	 esi, DWORD PTR [edi]
  0002f	75 ef		 jne	 SHORT $LL6@Tidy
  00031	5e		 pop	 esi
$LN5@Tidy:
  00032	5f		 pop	 edi

; 1885 : 		}

  00033	c3		 ret	 0
?_Tidy@?$list@KV?$allocator@K@std@@@std@@QAEXXZ ENDP	; std::list<unsigned long,std::allocator<unsigned long> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?clear@?$list@KV?$allocator@K@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@KV?$allocator@K@std@@@std@@QAEXXZ PROC	; std::list<unsigned long,std::allocator<unsigned long> >::clear, COMDAT
; _this$ = ecx

; 1500 : 		{	// erase all

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 1501 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1502 : 
; 1503 : 		this->_Orphan_ptr(nullptr);
; 1504 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1505 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

  00003	8b 17		 mov	 edx, DWORD PTR [edi]
  00005	8b 02		 mov	 eax, DWORD PTR [edx]

; 1506 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

  00007	89 12		 mov	 DWORD PTR [edx], edx

; 1507 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

  00009	8b 17		 mov	 edx, DWORD PTR [edi]
  0000b	89 52 04	 mov	 DWORD PTR [edx+4], edx

; 1508 : 		this->_Mysize() = 0;

  0000e	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1509 : 
; 1510 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

  00015	3b 07		 cmp	 eax, DWORD PTR [edi]
  00017	74 19		 je	 SHORT $LN3@clear
  00019	56		 push	 esi
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@clear:

; 1511 : 			{	// delete an element
; 1512 : 			_Pnext = this->_Nextnode(_Pnode);

  00020	8b 30		 mov	 esi, DWORD PTR [eax]

; 1513 : 			this->_Freenode(_Pnode);

  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 04	 add	 esp, 4
  0002b	8b c6		 mov	 eax, esi
  0002d	3b 37		 cmp	 esi, DWORD PTR [edi]
  0002f	75 ef		 jne	 SHORT $LL4@clear
  00031	5e		 pop	 esi
$LN3@clear:
  00032	5f		 pop	 edi

; 1514 : 			}
; 1515 : 		}

  00033	c3		 ret	 0
?clear@?$list@KV?$allocator@K@std@@@std@@QAEXXZ ENDP	; std::list<unsigned long,std::allocator<unsigned long> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Unchecked_erase@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Unchecked_erase@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::list<unsigned long,std::allocator<unsigned long> >::_Unchecked_erase, COMDAT
; _this$ = ecx

; 1473 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1474 : 		_Nodeptr _Pnode = _Where._Mynode();

  00004	8b 75 08	 mov	 esi, DWORD PTR __Where$[ebp]
  00007	57		 push	 edi

; 1475 : 
; 1476 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1477 : 			this->_Nextnode(_Pnode);
; 1478 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1479 : 			this->_Prevnode(_Pnode);
; 1480 : 		this->_Freenode(_Pnode);

  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000e	8b 06		 mov	 eax, DWORD PTR [esi]
  00010	89 02		 mov	 DWORD PTR [edx], eax
  00012	8b 16		 mov	 edx, DWORD PTR [esi]
  00014	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00017	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001f	83 c4 04	 add	 esp, 4

; 1481 : 		--this->_Mysize();

  00022	ff 4f 04	 dec	 DWORD PTR [edi+4]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi

; 1482 : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?_Unchecked_erase@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?push_back@?$list@KV?$allocator@K@std@@@std@@QAEXABK@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@KV?$allocator@K@std@@@std@@QAEXABK@Z PROC ; std::list<unsigned long,std::allocator<unsigned long> >::push_back, COMDAT
; _this$ = ecx

; 1292 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1293 : 		_Insert(_Unchecked_end(), _Val);

  00007	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0000a	8b 3e		 mov	 edi, DWORD PTR [esi]
  0000c	ff 77 04	 push	 DWORD PTR [edi+4]
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 ??$_Buynode@ABK@?$_List_buy@KV?$allocator@K@std@@@std@@QAEPAU?$_List_node@KPAX@1@PAU21@0ABK@Z ; std::_List_buy<unsigned long,std::allocator<unsigned long> >::_Buynode<unsigned long const &>
  00015	8b d0		 mov	 edx, eax
  00017	b9 54 55 55 15	 mov	 ecx, 357913940		; 15555554H
  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	2b c8		 sub	 ecx, eax
  00021	83 f9 01	 cmp	 ecx, 1
  00024	72 12		 jb	 SHORT $LN91@push_back
  00026	40		 inc	 eax
  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0002a	89 57 04	 mov	 DWORD PTR [edi+4], edx
  0002d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	89 10		 mov	 DWORD PTR [eax], edx

; 1294 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN91@push_back:

; 1293 : 		_Insert(_Unchecked_end(), _Val);

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0003d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN93@push_back:
$LN90@push_back:
  00042	cc		 int	 3
?push_back@?$list@KV?$allocator@K@std@@@std@@QAEXABK@Z ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?max_size@?$list@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@KV?$allocator@K@std@@@std@@QBEIXZ PROC	; std::list<unsigned long,std::allocator<unsigned long> >::max_size, COMDAT
; _this$ = ecx

; 1247 : 		return (this->_Getal().max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1248 : 		}

  00005	c3		 ret	 0
?max_size@?$list@KV?$allocator@K@std@@@std@@QBEIXZ ENDP	; std::list<unsigned long,std::allocator<unsigned long> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Make_iter@?$list@KV?$allocator@K@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$list@KV?$allocator@K@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@@Z PROC ; std::list<unsigned long,std::allocator<unsigned long> >::_Make_iter, COMDAT
; _this$ = ecx

; 1163 : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1164 : 		return (iterator(_Where._Ptr, &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1165 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$list@KV?$allocator@K@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@@Z ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Unchecked_end@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ PROC ; std::list<unsigned long,std::allocator<unsigned long> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1152 : 		{	// return unchecked iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1153 : 		return (_Unchecked_iterator(this->_Myhead(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1154 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Unchecked_end@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?end@?$list@KV?$allocator@K@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@KV?$allocator@K@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ PROC ; std::list<unsigned long,std::allocator<unsigned long> >::end, COMDAT
; _this$ = ecx

; 1135 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1136 : 		return (const_iterator(this->_Myhead(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1137 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$list@KV?$allocator@K@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?begin@?$list@KV?$allocator@K@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@KV?$allocator@K@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ PROC ; std::list<unsigned long,std::allocator<unsigned long> >::begin, COMDAT
; _this$ = ecx

; 1124 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1125 : 		return (const_iterator(this->_Nextnode(this->_Myhead()),

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1126 : 			&this->_Get_data()));
; 1127 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$list@KV?$allocator@K@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?begin@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ PROC ; std::list<unsigned long,std::allocator<unsigned long> >::begin, COMDAT
; _this$ = ecx

; 1118 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1119 : 		return (iterator(this->_Nextnode(this->_Myhead()),

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1120 : 			&this->_Get_data()));
; 1121 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??1?$list@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::list<unsigned long,std::allocator<unsigned long> >::~list<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 1097 : 		{	// destroy the object

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 1098 : 		_Tidy();

  00003	8b 07		 mov	 eax, DWORD PTR [edi]
  00005	8b 10		 mov	 edx, DWORD PTR [eax]
  00007	89 00		 mov	 DWORD PTR [eax], eax
  00009	8b 07		 mov	 eax, DWORD PTR [edi]
  0000b	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0000e	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00015	3b 17		 cmp	 edx, DWORD PTR [edi]
  00017	74 19		 je	 SHORT $LN7@list
  00019	56		 push	 esi
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL8@list:
  00020	8b 32		 mov	 esi, DWORD PTR [edx]
  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 04	 add	 esp, 4
  0002b	8b d6		 mov	 edx, esi
  0002d	3b 37		 cmp	 esi, DWORD PTR [edi]
  0002f	75 ef		 jne	 SHORT $LL8@list
  00031	5e		 pop	 esi
$LN7@list:

; 1099 : 		}

  00032	ff 37		 push	 DWORD PTR [edi]
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
  0003c	5f		 pop	 edi
  0003d	c3		 ret	 0
??1?$list@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::list<unsigned long,std::allocator<unsigned long> >::~list<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Assign_rv@?$list@KV?$allocator@K@std@@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$list@KV?$allocator@K@std@@@std@@QAEX$$QAV12@@Z PROC ; std::list<unsigned long,std::allocator<unsigned long> >::_Assign_rv, COMDAT
; _this$ = ecx

; 1013 : 		{	// swap with empty *this, same allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1014 : 		this->_Swap_all(_Right);
; 1015 : 		_Swap_adl(this->_Myhead(), _Right._Myhead());

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	89 01		 mov	 DWORD PTR [ecx], eax
  0000d	89 16		 mov	 DWORD PTR [esi], edx

; 1016 : 		_STD swap(this->_Mysize(), _Right._Mysize());

  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00015	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00018	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0001b	5e		 pop	 esi

; 1017 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?_Assign_rv@?$list@KV?$allocator@K@std@@@std@@QAEX$$QAV12@@Z ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$list@KV?$allocator@K@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$list@KV?$allocator@K@std@@@std@@QAE@$$QAV01@@Z PROC ; std::list<unsigned long,std::allocator<unsigned long> >::list<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 986  : 		{	// construct list by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Buynode0

; 987  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00020	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00023	89 06		 mov	 DWORD PTR [esi], eax
  00025	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00027	89 0e		 mov	 DWORD PTR [esi], ecx
  00029	89 02		 mov	 DWORD PTR [edx], eax
  0002b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00031	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 988  : 		}

  00034	8b c6		 mov	 eax, esi
  00036	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00039	5e		 pop	 esi
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
??0?$list@KV?$allocator@K@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::list<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 1
__Right$ = 8						; size = 4
??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z PROC	; std::list<unsigned long,std::allocator<unsigned long> >::list<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 924  : 		{	// construct list by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 921  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0003a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00041	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Buynode0
  00046	89 06		 mov	 DWORD PTR [esi], eax

; 925  : 		_TRY_BEGIN
; 926  : 		insert(begin(), _Right.begin(), _Right.end());

  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	c6 45 08 00	 mov	 BYTE PTR $T2[ebp], 0
  00051	ff 75 08	 push	 DWORD PTR $T2[ebp]
  00054	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00056	51		 push	 ecx
  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0005e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00062	8b 11		 mov	 edx, DWORD PTR [ecx]
  00064	8b ce		 mov	 ecx, esi
  00066	52		 push	 edx
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@std@@@?$list@KV?$allocator@K@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::list<unsigned long,std::allocator<unsigned long> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned long> > > >

; 930  : 		_CATCH_END
; 931  : 		}

  0006d	8b c6		 mov	 eax, esi
  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00079	59		 pop	 ecx
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
__catch$??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z$0:

; 927  : 		_CATCH_ALL
; 928  : 		_Tidy();

  00083	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Tidy@?$list@KV?$allocator@K@std@@@std@@QAEXXZ ; std::list<unsigned long,std::allocator<unsigned long> >::_Tidy

; 929  : 		_RERAISE;

  0008b	6a 00		 push	 0
  0008d	6a 00		 push	 0
  0008f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN246@list:
$LN245@list:
  00094	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z$2:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_List_buy@KV?$allocator@K@std@@@std@@QAE@XZ
__ehhandler$??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$list@KV?$allocator@K@std@@@std@@QAE@ABV01@@Z ENDP	; std::list<unsigned long,std::allocator<unsigned long> >::list<unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$list@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$list@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::list<unsigned long,std::allocator<unsigned long> >::list<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 893  : 		{	// construct empty list

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Buynode0
  00020	89 06		 mov	 DWORD PTR [esi], eax

; 894  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$list@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::list<unsigned long,std::allocator<unsigned long> >::list<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_List_buy@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_buy@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::_List_buy<unsigned long,std::allocator<unsigned long> >::~_List_buy<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx
  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_List_buy@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::_List_buy<unsigned long,std::allocator<unsigned long> >::~_List_buy<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Freenode@?$_List_buy@KV?$allocator@K@std@@@std@@QAEXPAU?$_List_node@KPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode@?$_List_buy@KV?$allocator@K@std@@@std@@QAEXPAU?$_List_node@KPAX@2@@Z PROC ; std::_List_buy<unsigned long,std::allocator<unsigned long> >::_Freenode, COMDAT
; _this$ = ecx

; 848  : 		{	// give node back

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 849  : 		this->_Getal().destroy(
; 850  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 851  : 		this->_Getal().destroy(
; 852  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 853  : 		this->_Getal().destroy(
; 854  : 			_STD addressof(this->_Myval(_Pnode)));
; 855  : 		this->_Getal().deallocate(_Pnode, 1);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 856  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freenode@?$_List_buy@KV?$allocator@K@std@@@std@@QAEXPAU?$_List_node@KPAX@2@@Z ENDP ; std::_List_buy<unsigned long,std::allocator<unsigned long> >::_Freenode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_buy@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_List_buy@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::_List_buy<unsigned long,std::allocator<unsigned long> >::_List_buy<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 818  : 		{	// default construct

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Buynode0
  00020	89 06		 mov	 DWORD PTR [esi], eax

; 819  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$_List_buy@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::_List_buy<unsigned long,std::allocator<unsigned long> >::_List_buy<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@K@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,std::_List_val<std::_List_simple_types<unsigned long> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,std::_List_val<std::_List_simple_types<unsigned long> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@K@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,std::_List_val<std::_List_simple_types<unsigned long> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,std::_List_val<std::_List_simple_types<unsigned long> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,std::_List_val<std::_List_simple_types<unsigned long> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,std::_List_val<std::_List_simple_types<unsigned long> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,std::_List_val<std::_List_simple_types<unsigned long> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@K@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >,std::_List_val<std::_List_simple_types<unsigned long> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myval@?$_List_val@U?$_List_simple_types@K@std@@@std@@SAAAKPAU?$_List_node@KPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@U?$_List_simple_types@K@std@@@std@@SAAAKPAU?$_List_node@KPAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<unsigned long> >::_Myval, COMDAT

; 545  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 546  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 547  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_val@U?$_List_simple_types@K@std@@@std@@SAAAKPAU?$_List_node@KPAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<unsigned long> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Prevnode@?$_List_val@U?$_List_simple_types@K@std@@@std@@SAAAPAU?$_List_node@KPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_val@U?$_List_simple_types@K@std@@@std@@SAAAPAU?$_List_node@KPAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<unsigned long> >::_Prevnode, COMDAT

; 540  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 541  : 		return ((_Nodepref)_Pnode->_Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 542  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_val@U?$_List_simple_types@K@std@@@std@@SAAAPAU?$_List_node@KPAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<unsigned long> >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_val@U?$_List_simple_types@K@std@@@std@@SAAAPAU?$_List_node@KPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@U?$_List_simple_types@K@std@@@std@@SAAAPAU?$_List_node@KPAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<unsigned long> >::_Nextnode, COMDAT

; 535  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 536  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 537  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_val@U?$_List_simple_types@K@std@@@std@@SAAAPAU?$_List_node@KPAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<unsigned long> >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_val@U?$_List_simple_types@K@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<unsigned long> >::_List_val<std::_List_simple_types<unsigned long> >, COMDAT
; _this$ = ecx

; 529  : 		: _Myhead(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 532  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_List_val@U?$_List_simple_types@K@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<unsigned long> >::_List_val<std::_List_simple_types<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Mysize@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAIXZ PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Mysize, COMDAT
; _this$ = ecx

; 792  : 		return (_Get_data()._Mysize);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 793  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myhead@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAU?$_List_node@KPAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAU?$_List_node@KPAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Myhead, COMDAT
; _this$ = ecx

; 787  : 		return (_Get_data()._Myhead);

  00000	8b c1		 mov	 eax, ecx

; 788  : 		}

  00002	c3		 ret	 0
?_Myhead@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAU?$_List_node@KPAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myhead@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAU?$_List_node@KPAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAU?$_List_node@KPAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Myhead, COMDAT
; _this$ = ecx

; 782  : 		return (_Get_data()._Myhead);

  00000	8b c1		 mov	 eax, ecx

; 783  : 		}

  00002	c3		 ret	 0
?_Myhead@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAU?$_List_node@KPAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Get_data@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@K@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data, COMDAT
; _this$ = ecx

; 777  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 778  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@K@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Get_data@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@K@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data, COMDAT
; _this$ = ecx

; 772  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 773  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@K@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Getal@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal, COMDAT
; _this$ = ecx

; 767  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 768  : 		}

  00002	c3		 ret	 0
?_Getal@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Getal@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal, COMDAT
; _this$ = ecx

; 762  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 763  : 		}

  00002	c3		 ret	 0
?_Getal@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Swap_all@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_all@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Swap_all, COMDAT
; _this$ = ecx

; 757  : 		_Get_data()._Swap_all(_Right._Get_data());
; 758  : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Buynode0@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@PAU32@0@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
?_Buynode0@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@PAU32@0@Z PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Buynode0, COMDAT
; _this$ = ecx

; 729  : 		{	// allocate a node and set links

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 730  : 		_Nodeptr _Pnode = _Getal().allocate(1);

  00003	6a 0c		 push	 12			; 0000000cH
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4
  0000d	85 c0		 test	 eax, eax
  0000f	74 1f		 je	 SHORT $LN117@Buynode0

; 731  : 
; 732  : 		if (_Next == _Nodeptr())

  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Next$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	75 06		 jne	 SHORT $LN115@Buynode0

; 733  : 			{	// point at self
; 734  : 			_Next = _Pnode;

  00018	8b c8		 mov	 ecx, eax

; 735  : 			_Prev = _Pnode;

  0001a	8b d0		 mov	 edx, eax
  0001c	eb 03		 jmp	 SHORT $LN2@Buynode0
$LN115@Buynode0:
  0001e	8b 55 0c	 mov	 edx, DWORD PTR __Prev$[ebp]
$LN2@Buynode0:

; 736  : 			}
; 737  : 		_TRY_BEGIN
; 738  : 		_Getal().construct(

  00021	89 08		 mov	 DWORD PTR [eax], ecx

; 739  : 			_STD addressof(_Nextnode(_Pnode)), _Next);
; 740  : 		_Getal().construct(

  00023	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00026	85 c9		 test	 ecx, ecx
  00028	74 02		 je	 SHORT $LN4@Buynode0
  0002a	89 11		 mov	 DWORD PTR [ecx], edx
$LN4@Buynode0:

; 741  : 			_STD addressof(_Prevnode(_Pnode)), _Prev);
; 742  : 		_CATCH_ALL
; 743  : 		_Getal().deallocate(_Pnode, 1);
; 744  : 		_RERAISE;
; 745  : 		_CATCH_END
; 746  : 
; 747  : 		return (_Pnode);
; 748  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
$LN117@Buynode0:

; 730  : 		_Nodeptr _Pnode = _Getal().allocate(1);

  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN119@Buynode0:
$LN116@Buynode0:
  00035	cc		 int	 3
?_Buynode0@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@PAU32@0@Z ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Freeheadnode@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXPAU?$_List_node@KPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXPAU?$_List_node@KPAX@2@@Z PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Freeheadnode, COMDAT
; _this$ = ecx

; 719  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Getal().destroy(
; 721  : 			_STD addressof(_Nextnode(_Pnode)));
; 722  : 		_Getal().destroy(
; 723  : 			_STD addressof(_Prevnode(_Pnode)));
; 724  : 		_Getal().deallocate(_Pnode, 1);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 725  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freeheadnode@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXPAU?$_List_node@KPAX@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Buyheadnode@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Buyheadnode, COMDAT
; _this$ = ecx

; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Buynode0

; 716  : 		}

  00009	c3		 ret	 0
?_Buyheadnode@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??1?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::~_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx

; 617  : 		_Freeheadnode(_Myhead());

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx

; 618  : 		}

  00008	c3		 ret	 0
??1?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::~_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx

; 602  : 		{	// default construct head node

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 603  : 		_Myhead() = _Buyheadnode();

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Buynode0
  00019	89 06		 mov	 DWORD PTR [esi], eax

; 604  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c3		 ret	 0
??0?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myval@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@SAAAKPAU?$_List_node@KPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@SAAAKPAU?$_List_node@KPAX@2@@Z PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Myval, COMDAT

; 595  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 596  : 		return (_List_val<_Val_types>::_Myval(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 597  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@SAAAKPAU?$_List_node@KPAX@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Prevnode@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@SAAAPAU?$_List_node@KPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@SAAAPAU?$_List_node@KPAX@2@PAU32@@Z PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Prevnode, COMDAT

; 590  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 591  : 		return (_List_val<_Val_types>::_Prevnode(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 592  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@SAAAPAU?$_List_node@KPAX@2@PAU32@@Z ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@SAAAPAU?$_List_node@KPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@SAAAPAU?$_List_node@KPAX@2@PAU32@@Z PROC ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Nextnode, COMDAT

; 585  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 586  : 		return (_List_val<_Val_types>::_Nextnode(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 587  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@SAAAPAU?$_List_node@KPAX@2@PAU32@@Z ENDP ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1009 : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXPAU?$_List_node@KPAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXPAU?$_List_node@KPAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 988  : 		}

  00003	5d		 pop	 ebp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00004	e9 00 00 00 00	 jmp	 ?deallocate@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEXPAU?$_List_node@KPAX@2@I@Z ; std::allocator<std::_List_node<unsigned long,void *> >::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXPAU?$_List_node@KPAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 977  : 		}

  00003	5d		 pop	 ebp

; 976  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEPAU?$_List_node@KPAX@2@I@Z ; std::allocator<std::_List_node<unsigned long,void *> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned long,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@KPAX@std@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@KPAX@std@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<unsigned long,void *> > >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@KPAX@std@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<unsigned long,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@KPAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@KPAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<unsigned long,void *> > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 870  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@KPAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<unsigned long,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_List_node@KPAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_List_node@KPAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_List_node<unsigned long,void *> >::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 750  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$_List_node@KPAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_List_node<unsigned long,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEPAU?$_List_node@KPAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEPAU?$_List_node@KPAX@2@I@Z PROC ; std::allocator<std::_List_node<unsigned long,void *> >::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00013	77 3f		 ja	 SHORT $LN14@allocate
  00015	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00018	c1 e0 02	 shl	 eax, 2
  0001b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00020	72 23		 jb	 SHORT $LN6@allocate
  00022	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00025	3b c8		 cmp	 ecx, eax
  00027	76 30		 jbe	 SHORT $LN16@allocate
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	8b c8		 mov	 ecx, eax
  00031	83 c4 04	 add	 esp, 4
  00034	85 c9		 test	 ecx, ecx
  00036	74 26		 je	 SHORT $LN17@allocate
  00038	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0003b	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0003e	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004b	83 c4 04	 add	 esp, 4
  0004e	85 c0		 test	 eax, eax
  00050	75 b8		 jne	 SHORT $LN12@allocate
  00052	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:
  00054	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:
  00059	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:
  0005e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:
  00063	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00068	cc		 int	 3
?allocate@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEPAU?$_List_node@KPAX@2@I@Z ENDP ; std::allocator<std::_List_node<unsigned long,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEXPAU?$_List_node@KPAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEXPAU?$_List_node@KPAX@2@I@Z PROC ; std::allocator<std::_List_node<unsigned long,void *> >::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  0000e	77 34		 ja	 SHORT $LN13@deallocate
  00010	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00013	c1 e0 02	 shl	 eax, 2
  00016	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001b	72 1a		 jb	 SHORT $LN5@deallocate
  0001d	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00020	75 27		 jne	 SHORT $LN15@deallocate
  00022	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00025	3b c1		 cmp	 eax, ecx
  00027	73 25		 jae	 SHORT $LN16@deallocate
  00029	2b c8		 sub	 ecx, eax
  0002b	83 f9 04	 cmp	 ecx, 4
  0002e	72 23		 jb	 SHORT $LN17@deallocate
  00030	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00033	77 23		 ja	 SHORT $LN18@deallocate
  00035	8b c8		 mov	 ecx, eax
$LN5@deallocate:
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003d	83 c4 04	 add	 esp, 4

; 721  : 		}

  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:
  00049	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:
  0004e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:
  00053	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00058	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005d	cc		 int	 3
?deallocate@?$allocator@U?$_List_node@KPAX@std@@@std@@QAEXPAU?$_List_node@KPAX@2@I@Z ENDP ; std::allocator<std::_List_node<unsigned long,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_List_node@KPAX@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$_List_node@KPAX@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_List_node<unsigned long,void *> >::allocator<std::_List_node<unsigned long,void *> >, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@U?$_List_node@KPAX@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_List_node<unsigned long,void *> >::allocator<std::_List_node<unsigned long,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_List_node@KPAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_List_node@KPAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_List_node<unsigned long,void *> >::allocator<std::_List_node<unsigned long,void *> >, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_List_node@KPAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_List_node<unsigned long,void *> >::allocator<std::_List_node<unsigned long,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1009 : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0000e	77 31		 ja	 SHORT $LN16@deallocate
  00010	c1 e0 02	 shl	 eax, 2
  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN7@deallocate
  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN18@deallocate
  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN19@deallocate
  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN20@deallocate
  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN21@deallocate
  00032	8b c8		 mov	 ecx, eax
$LN7@deallocate:
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 988  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:
  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:
  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:
  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  0005a	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEPAKI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEPAKI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 977  : 		}

  00003	5d		 pop	 ebp

; 976  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@K@std@@QAEPAKI@Z ; std::allocator<unsigned long>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEPAKI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@K@std@@@std@@SA?AV?$allocator@K@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@K@std@@@std@@SA?AV?$allocator@K@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<unsigned long> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@K@std@@@std@@SA?AV?$allocator@K@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<unsigned long> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@K@std@@@std@@SAIABV?$allocator@K@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@K@std@@@std@@SAIABV?$allocator@K@2@@Z PROC ; std::allocator_traits<std::allocator<unsigned long> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 870  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@K@std@@@std@@SAIABV?$allocator@K@2@@Z ENDP ; std::allocator_traits<std::allocator<unsigned long> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@K@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@K@std@@QBEIXZ PROC		; std::allocator<unsigned long>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 750  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@K@std@@QBEIXZ ENDP		; std::allocator<unsigned long>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@K@std@@QAEPAKI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@K@std@@QAEPAKI@Z PROC		; std::allocator<unsigned long>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00013	77 3c		 ja	 SHORT $LN14@allocate
  00015	c1 e0 02	 shl	 eax, 2
  00018	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001d	72 23		 jb	 SHORT $LN6@allocate
  0001f	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00022	3b c8		 cmp	 ecx, eax
  00024	76 30		 jbe	 SHORT $LN16@allocate
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002c	8b c8		 mov	 ecx, eax
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c9		 test	 ecx, ecx
  00033	74 26		 je	 SHORT $LN17@allocate
  00035	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00038	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0003b	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00048	83 c4 04	 add	 esp, 4
  0004b	85 c0		 test	 eax, eax
  0004d	75 bb		 jne	 SHORT $LN12@allocate
  0004f	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:
  00051	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:
  00056	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:
  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:
  00060	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00065	cc		 int	 3
?allocate@?$allocator@K@std@@QAEPAKI@Z ENDP		; std::allocator<unsigned long>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@K@std@@QAEXPAKI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@K@std@@QAEXPAKI@Z PROC		; std::allocator<unsigned long>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0000e	77 31		 ja	 SHORT $LN13@deallocate
  00010	c1 e0 02	 shl	 eax, 2
  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN5@deallocate
  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN15@deallocate
  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN16@deallocate
  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN17@deallocate
  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN18@deallocate
  00032	8b c8		 mov	 ecx, eax
$LN5@deallocate:
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 721  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:
  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:
  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:
  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005a	cc		 int	 3
?deallocate@?$allocator@K@std@@QAEXPAKI@Z ENDP		; std::allocator<unsigned long>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@K@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@K@std@@QAE@ABV01@@Z PROC			; std::allocator<unsigned long>::allocator<unsigned long>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@K@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned long>::allocator<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@K@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@K@std@@QAE@XZ PROC			; std::allocator<unsigned long>::allocator<unsigned long>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@K@std@@QAE@XZ ENDP			; std::allocator<unsigned long>::allocator<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ??1Finally211@?1??CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@QAE@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
$T2 = -4						; size = 4
??1Finally211@?1??CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@QAE@XZ PROC ; `GostCrypt::SecurityToken::CreateKeyfile'::`2'::Finally211::~Finally211, COMDAT
; _this$ = ecx

; 211  : 		finally_do_arg (vector <byte> *, &objectData, { if (!finally_arg->empty()) burn (&finally_arg->front(), finally_arg->size()); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	83 ec 08	 sub	 esp, 8
  00008	8b 02		 mov	 eax, DWORD PTR [edx]
  0000a	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  0000d	74 30		 je	 SHORT $LN3@Finally211
  0000f	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00012	56		 push	 esi
  00013	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00016	2b c8		 sub	 ecx, eax
  00018	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  0001b	8b d0		 mov	 edx, eax
  0001d	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00020	2b f0		 sub	 esi, eax
  00022	74 0b		 je	 SHORT $LN142@Finally211
$LL138@Finally211:
  00024	c6 02 00	 mov	 BYTE PTR [edx], 0
  00027	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0002a	83 ee 01	 sub	 esi, 1
  0002d	75 f5		 jne	 SHORT $LL138@Finally211
$LN142@Finally211:
  0002f	5e		 pop	 esi
  00030	85 c9		 test	 ecx, ecx
  00032	74 0b		 je	 SHORT $LN3@Finally211
$LL5@Finally211:
  00034	c6 00 00	 mov	 BYTE PTR [eax], 0
  00037	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  0003a	83 e9 01	 sub	 ecx, 1
  0003d	75 f5		 jne	 SHORT $LL5@Finally211
$LN3@Finally211:
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
??1Finally211@?1??CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@QAE@XZ ENDP ; `GostCrypt::SecurityToken::CreateKeyfile'::`2'::Finally211::~Finally211
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ??0Finally211@?1??CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@QAE@PAV45@@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
??0Finally211@?1??CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@QAE@PAV45@@Z PROC ; `GostCrypt::SecurityToken::CreateKeyfile'::`2'::Finally211::Finally211, COMDAT
; _this$ = ecx

; 211  : 		finally_do_arg (vector <byte> *, &objectData, { if (!finally_arg->empty()) burn (&finally_arg->front(), finally_arg->size()); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0Finally211@?1??CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@QAE@PAV45@@Z ENDP ; `GostCrypt::SecurityToken::CreateKeyfile'::`2'::Finally211::Finally211
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1794 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen, COMDAT
; _this$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

  00003	8b 16		 mov	 edx, DWORD PTR [esi]
  00005	85 d2		 test	 edx, edx
  00007	74 43		 je	 SHORT $LN2@Tidy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c2		 sub	 eax, edx
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 1a		 jb	 SHORT $LN70@Tidy
  00015	f6 c2 1f	 test	 dl, 31			; 0000001fH
  00018	75 34		 jne	 SHORT $LN107@Tidy
  0001a	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0001d	3b c2		 cmp	 eax, edx
  0001f	73 32		 jae	 SHORT $LN109@Tidy
  00021	2b d0		 sub	 edx, eax
  00023	83 fa 04	 cmp	 edx, 4
  00026	72 30		 jb	 SHORT $LN110@Tidy
  00028	83 fa 23	 cmp	 edx, 35			; 00000023H
  0002b	77 30		 ja	 SHORT $LN111@Tidy
  0002d	8b d0		 mov	 edx, eax
$LN70@Tidy:
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1642 : 				this->_Myend() - this->_Myfirst());
; 1643 : 			this->_Myfirst() = pointer();

  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0003b	83 c4 04	 add	 esp, 4

; 1644 : 			this->_Mylast() = pointer();

  0003e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

  00045	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1646 : 			}
; 1647 : 		}

  0004c	5e		 pop	 esi
  0004d	c3		 ret	 0
$LN107@Tidy:

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

  0004e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN112@Tidy:
$LN109@Tidy:
  00053	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN113@Tidy:
$LN110@Tidy:
  00058	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN114@Tidy:
$LN111@Tidy:
  0005d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN115@Tidy:
$LN106@Tidy:
  00062	cc		 int	 3
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 1627 : 		if (_Unused_capacity() < _Count)

  00008	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b c3		 mov	 eax, ebx
  00010	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00013	2b c6		 sub	 eax, esi
  00015	3b c1		 cmp	 eax, ecx
  00017	73 2f		 jae	 SHORT $LN2@Reserve

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

  00019	8b 17		 mov	 edx, DWORD PTR [edi]
  0001b	8b c2		 mov	 eax, edx
  0001d	2b c6		 sub	 eax, esi
  0001f	48		 dec	 eax
  00020	3b c1		 cmp	 eax, ecx
  00022	72 2b		 jb	 SHORT $LN134@Reserve

; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

  00024	2b da		 sub	 ebx, edx
  00026	2b f2		 sub	 esi, edx
  00028	03 f1		 add	 esi, ecx
  0002a	8b c3		 mov	 eax, ebx
  0002c	d1 e8		 shr	 eax, 1
  0002e	33 d2		 xor	 edx, edx
  00030	8b c8		 mov	 ecx, eax
  00032	03 c3		 add	 eax, ebx
  00034	f7 d1		 not	 ecx
  00036	3b cb		 cmp	 ecx, ebx
  00038	8b cf		 mov	 ecx, edi
  0003a	0f 43 d0	 cmovae	 edx, eax
  0003d	3b d6		 cmp	 edx, esi
  0003f	0f 43 f2	 cmovae	 esi, edx
  00042	56		 push	 esi
  00043	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate
$LN2@Reserve:
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 1632 : 			}
; 1633 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
$LN134@Reserve:

; 1630 : 				_Xlen();

  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00054	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN136@Reserve:
$LN133@Reserve:
  00059	cc		 int	 3
?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	85 ff		 test	 edi, edi
  0000d	75 35		 jne	 SHORT $LN20@Reallocate
  0000f	33 f6		 xor	 esi, esi
$LN26@Reallocate:

; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);

  00011	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00013	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00016	2b c1		 sub	 eax, ecx
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memmove

; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();

  00020	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH
  00025	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00028	2b c1		 sub	 eax, ecx
  0002a	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1612 : 		if (this->_Myfirst() != pointer())

  0002d	85 c9		 test	 ecx, ecx
  0002f	74 69		 je	 SHORT $LN173@Reallocate

; 1613 : 			{	// destroy and deallocate old array
; 1614 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

  00031	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00034	2b c1		 sub	 eax, ecx
  00036	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0003b	72 54		 jb	 SHORT $LN168@Reallocate
  0003d	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00040	74 3a		 je	 SHORT $LN169@Reallocate
  00042	eb 6d		 jmp	 SHORT $LN204@Reallocate

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

$LN20@Reallocate:
  00044	81 ff 00 10 00
	00		 cmp	 edi, 4096		; 00001000H
  0004a	72 1f		 jb	 SHORT $LN22@Reallocate
  0004c	8d 47 23	 lea	 eax, DWORD PTR [edi+35]
  0004f	3b c7		 cmp	 eax, edi
  00051	76 63		 jbe	 SHORT $LN206@Reallocate
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00059	83 c4 04	 add	 esp, 4
  0005c	85 c0		 test	 eax, eax
  0005e	74 5b		 je	 SHORT $LN207@Reallocate
  00060	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  00063	83 e6 e0	 and	 esi, -32		; ffffffe0H
  00066	89 46 fc	 mov	 DWORD PTR [esi-4], eax
  00069	eb a6		 jmp	 SHORT $LN26@Reallocate
$LN22@Reallocate:
  0006b	57		 push	 edi
  0006c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00071	8b f0		 mov	 esi, eax
  00073	83 c4 04	 add	 esp, 4
  00076	85 f6		 test	 esi, esi
  00078	75 97		 jne	 SHORT $LN26@Reallocate
  0007a	eb 44		 jmp	 SHORT $LN208@Reallocate

; 1613 : 			{	// destroy and deallocate old array
; 1614 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

$LN169@Reallocate:
  0007c	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0007f	3b c1		 cmp	 eax, ecx
  00081	73 42		 jae	 SHORT $LN209@Reallocate
  00083	2b c8		 sub	 ecx, eax
  00085	83 f9 04	 cmp	 ecx, 4
  00088	72 40		 jb	 SHORT $LN210@Reallocate
  0008a	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0008d	77 40		 ja	 SHORT $LN211@Reallocate
  0008f	8b c8		 mov	 ecx, eax
$LN168@Reallocate:
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00097	83 c4 04	 add	 esp, 4
$LN173@Reallocate:

; 1616 : 				this->_Myend() - this->_Myfirst());
; 1617 : 			}
; 1618 : 
; 1619 : 		this->_Orphan_all();
; 1620 : 		this->_Myend() = _Ptr + _Count;

  0009a	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0009d	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 1621 : 		this->_Mylast() = _Ptr + _Size;

  000a0	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  000a3	03 c6		 add	 eax, esi
  000a5	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  000a8	5f		 pop	 edi

; 1622 : 		this->_Myfirst() = _Ptr;

  000a9	89 33		 mov	 DWORD PTR [ebx], esi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx

; 1623 : 		}

  000ad	5d		 pop	 ebp
  000ae	c2 04 00	 ret	 4
$LN204@Reallocate:

; 1613 : 			{	// destroy and deallocate old array
; 1614 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

  000b1	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN212@Reallocate:
$LN206@Reallocate:

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  000b6	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN213@Reallocate:
$LN207@Reallocate:
  000bb	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN214@Reallocate:
$LN208@Reallocate:
  000c0	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN215@Reallocate:
$LN209@Reallocate:

; 1613 : 			{	// destroy and deallocate old array
; 1614 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

  000c5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN216@Reallocate:
$LN210@Reallocate:
  000ca	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN217@Reallocate:
$LN211@Reallocate:
  000cf	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN218@Reallocate:
$LN203@Reallocate:
  000d4	cc		 int	 3
?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@EV?$allocator@E@std@@@std@@IBE_NPBE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@EV?$allocator@E@std@@@std@@IBE_NPBE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Inside, COMDAT
; _this$ = ecx

; 1596 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1598 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1598 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@EV?$allocator@E@std@@@std@@IBE_NPBE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@EV?$allocator@E@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@EV?$allocator@E@std@@@std@@IBEII@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1586 : 		size_type _Capacity = capacity();

  00004	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00007	2b 31		 sub	 esi, DWORD PTR [ecx]

; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  00009	8b c6		 mov	 eax, esi
  0000b	d1 e8		 shr	 eax, 1
  0000d	8b d0		 mov	 edx, eax
  0000f	f7 d2		 not	 edx
  00011	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  00014	33 c0		 xor	 eax, eax
  00016	3b d6		 cmp	 edx, esi
  00018	5e		 pop	 esi
  00019	0f 43 c1	 cmovae	 eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  0001f	0f 42 45 08	 cmovb	 eax, DWORD PTR __Count$[ebp]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?_Grow_to@?$vector@EV?$allocator@E@std@@@std@@IBEII@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy, COMDAT
; _this$ = ecx

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy, COMDAT
; _this$ = ecx

; 1561 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1562 : 		this->_Myfirst() = pointer();
; 1563 : 		this->_Mylast() = pointer();
; 1564 : 		this->_Myend() = pointer();
; 1565 : 
; 1566 : 		if (_Capacity == 0)

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Capacity$[ebp]
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00010	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00017	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001e	85 ff		 test	 edi, edi
  00020	75 08		 jne	 SHORT $LN2@Buy

; 1567 : 			return (false);

  00022	5f		 pop	 edi
  00023	32 c0		 xor	 al, al
  00025	5e		 pop	 esi

; 1577 : 		}

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN2@Buy:

; 1568 : 		else if (max_size() < _Capacity)
; 1569 : 			_Xlen();	// result too long
; 1570 : 		else
; 1571 : 			{	// nonempty array, allocate storage
; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEPAEI@Z ; std::_Wrap_alloc<std::allocator<unsigned char> >::allocate
  00030	89 06		 mov	 DWORD PTR [esi], eax

; 1573 : 			this->_Mylast() = this->_Myfirst();

  00032	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

  00035	8b 06		 mov	 eax, DWORD PTR [esi]
  00037	03 c7		 add	 eax, edi
  00039	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1575 : 			}
; 1576 : 		return (true);

  0003c	b0 01		 mov	 al, 1
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi

; 1577 : 		}

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::clear, COMDAT
; _this$ = ecx

; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1543 : 		}

  00005	c3		 ret	 0
?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?front@?$vector@EV?$allocator@E@std@@@std@@QAEAAEXZ
_TEXT	SEGMENT
?front@?$vector@EV?$allocator@E@std@@@std@@QAEAAEXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::front, COMDAT
; _this$ = ecx

; 1257 : 		return (*begin());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1258 : 		}

  00002	c3		 ret	 0
?front@?$vector@EV?$allocator@E@std@@@std@@QAEAAEXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?empty@?$vector@EV?$allocator@E@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@EV?$allocator@E@std@@@std@@QBE_NXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::empty, COMDAT
; _this$ = ecx

; 1189 : 		{	// test if sequence is empty

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00005	0f 94 c0	 sete	 al

; 1190 : 		return (this->_Myfirst() == this->_Mylast());
; 1191 : 		}

  00008	c3		 ret	 0
?empty@?$vector@EV?$allocator@E@std@@@std@@QBE_NXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size, COMDAT
; _this$ = ecx

; 1185 : 		return (this->_Getal().max_size());

  00000	83 c8 ff	 or	 eax, -1

; 1186 : 		}

  00003	c3		 ret	 0
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1181 : 		}

  00005	c3		 ret	 0
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::begin, COMDAT
; _this$ = ecx

; 1057 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1058 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1059 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]

; 1049 : 		}

  00006	c3		 ret	 0
?_Unused_capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1044 : 		}

  00005	c3		 ret	 0
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 976  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back, COMDAT
; _this$ = ecx

; 896  : 		{	// insert by moving into element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 897  : 		if (_Inside(_STD addressof(_Val)))

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	3b f8		 cmp	 edi, eax
  0000f	73 2d		 jae	 SHORT $LN2@push_back
  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00013	3b cf		 cmp	 ecx, edi
  00015	77 27		 ja	 SHORT $LN2@push_back

; 898  : 			{	// push back an element
; 899  : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

  00017	2b f9		 sub	 edi, ecx

; 900  : 			if (this->_Mylast() == this->_Myend())

  00019	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0001c	75 09		 jne	 SHORT $LN4@push_back

; 901  : 				_Reserve(1);

  0001e	6a 01		 push	 1
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reserve
$LN4@push_back:

; 902  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 903  : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

  00027	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002a	85 c9		 test	 ecx, ecx
  0002c	74 29		 je	 SHORT $LN215@push_back
  0002e	8b 06		 mov	 eax, DWORD PTR [esi]
  00030	8a 04 07	 mov	 al, BYTE PTR [edi+eax]

; 911  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 912  : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

  00033	88 01		 mov	 BYTE PTR [ecx], al

; 913  : 				_STD forward<value_type>(_Val));
; 914  : 			++this->_Mylast();

  00035	ff 46 04	 inc	 DWORD PTR [esi+4]
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 915  : 			}
; 916  : 		}

  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
$LN2@push_back:

; 904  : 				_STD forward<value_type>(this->_Myfirst()[_Idx]));
; 905  : 			++this->_Mylast();
; 906  : 			}
; 907  : 		else
; 908  : 			{	// push back a non-element
; 909  : 			if (this->_Mylast() == this->_Myend())

  0003e	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00041	75 09		 jne	 SHORT $LN5@push_back

; 910  : 				_Reserve(1);

  00043	6a 01		 push	 1
  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Reserve
$LN5@push_back:

; 911  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 912  : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

  0004c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004f	85 c9		 test	 ecx, ecx
  00051	74 04		 je	 SHORT $LN215@push_back
  00053	8a 07		 mov	 al, BYTE PTR [edi]
  00055	88 01		 mov	 BYTE PTR [ecx], al
$LN215@push_back:

; 913  : 				_STD forward<value_type>(_Val));
; 914  : 			++this->_Mylast();

  00057	ff 46 04	 inc	 DWORD PTR [esi+4]
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi

; 915  : 			}
; 916  : 		}

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 889  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 890  : 		_Assign_rv(_STD forward<_Myt>(_Right),

  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00010	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00013	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00016	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0001c	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  00023	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 891  : 			typename _Alty::propagate_on_container_move_assignment());
; 892  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 868  : 		{	// move from _Right, stealing its contents

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 869  : 		this->_Swap_all((_Myt&)_Right);
; 870  : 		this->_Myfirst() = _Right._Myfirst();

  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 871  : 		this->_Mylast() = _Right._Mylast();

  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 872  : 		this->_Myend() = _Right._Myend();

  00010	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00013	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 873  : 
; 874  : 		_Right._Myfirst() = pointer();

  00016	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 875  : 		_Right._Mylast() = pointer();

  0001c	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 876  : 		_Right._Myend() = pointer();

  00023	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 877  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=, COMDAT
; _this$ = ecx

; 854  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 855  : 		if (this != &_Right)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 29		 je	 SHORT $LN123@operator

; 856  : 			{	// different, assign it
; 857  : 			_Tidy();

  0000e	e8 00 00 00 00	 call	 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy

; 858  : 			if (_Alty::propagate_on_container_move_assignment::value
; 859  : 				&& this->_Getal() != _Right._Getal())
; 860  : 				this->_Move_alloc(_Right._Getal());
; 861  : 
; 862  : 			_Assign_rv(_STD forward<_Myt>(_Right));

  00013	8b 07		 mov	 eax, DWORD PTR [edi]
  00015	89 06		 mov	 DWORD PTR [esi], eax
  00017	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0001a	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0001d	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00020	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00023	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00029	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00030	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN123@operator:

; 863  : 			}
; 864  : 		return (*this);

  00037	5f		 pop	 edi
  00038	8b c6		 mov	 eax, esi
  0003a	5e		 pop	 esi

; 865  : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$vector@EV?$allocator@E@std@@@std@@QAE@I@Z PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 717  : 		{	// construct from _Count * value_type()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 718  : 		if (_Buy(_Count))

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00010	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00017	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001e	85 ff		 test	 edi, edi
  00020	74 22		 je	 SHORT $LN150@vector
  00022	57		 push	 edi
  00023	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEPAEI@Z ; std::_Wrap_alloc<std::allocator<unsigned char> >::allocate
  00028	89 06		 mov	 DWORD PTR [esi], eax
  0002a	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0002d	8b 06		 mov	 eax, DWORD PTR [esi]

; 719  : 			{	// nonzero, fill it
; 720  : 			_TRY_BEGIN
; 721  : 			_Uninitialized_default_fill_n(this->_Myfirst(), _Count,

  0002f	57		 push	 edi
  00030	03 c7		 add	 eax, edi
  00032	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00035	6a 00		 push	 0
  00037	ff 36		 push	 DWORD PTR [esi]
  00039	e8 00 00 00 00	 call	 _memset
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 722  : 				this->_Getal());
; 723  : 			this->_Mylast() += _Count;

  00041	01 7e 04	 add	 DWORD PTR [esi+4], edi
$LN150@vector:

; 724  : 			_CATCH_ALL
; 725  : 			_Tidy();
; 726  : 			_RERAISE;
; 727  : 			_CATCH_END
; 728  : 			}
; 729  : 		}

  00044	5f		 pop	 edi
  00045	8b c6		 mov	 eax, esi
  00047	5e		 pop	 esi
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
??0?$vector@EV?$allocator@E@std@@@std@@QAE@I@Z ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 706  : 		: _Mybase()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 708  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned char> >,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 489  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 669  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 664  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 659  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 654  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 649  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 644  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 639  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 634  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 629  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 624  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Swap_all, COMDAT
; _this$ = ecx

; 618  : 		_Get_data()._Swap_all(_Right._Get_data());
; 619  : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Move_alloc@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Move_alloc@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Move_alloc, COMDAT
; _this$ = ecx

; 538  : 		_Pocma(_Getal(), _Al);
; 539  : 		}

  00000	c2 04 00	 ret	 4
?_Move_alloc@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@E@std@@@2@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >, COMDAT
; _this$ = ecx

; 519  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 521  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned char> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	83 c8 ff	 or	 eax, -1

; 1009 : 		}

  00003	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned char> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000d	72 19		 jb	 SHORT $LN7@deallocate
  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $LN16@deallocate
  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00016	3b c8		 cmp	 ecx, eax
  00018	73 20		 jae	 SHORT $LN18@deallocate
  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 1e		 jb	 SHORT $LN19@deallocate
  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 1e		 ja	 SHORT $LN20@deallocate
  00026	8b c1		 mov	 eax, ecx
$LN7@deallocate:
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 988  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00035	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN18@deallocate:
  0003a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN19@deallocate:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN20@deallocate:
  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN15@deallocate:
  00049	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEPAEI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEPAEI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned char> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 976  : 		return (_Mybase::allocate(_Count));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN6@allocate
$LN15@allocate:

; 977  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 976  : 		return (_Mybase::allocate(_Count));

$LN6@allocate:
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 23		 jb	 SHORT $LN8@allocate
  00015	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00018	3b c8		 cmp	 ecx, eax
  0001a	76 2b		 jbe	 SHORT $LN17@allocate
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	8b c8		 mov	 ecx, eax
  00024	83 c4 04	 add	 esp, 4
  00027	85 c9		 test	 ecx, ecx
  00029	74 21		 je	 SHORT $LN19@allocate
  0002b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002e	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00031	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 977  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4

; 976  : 		return (_Mybase::allocate(_Count));

$LN8@allocate:
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 c5		 jne	 SHORT $LN15@allocate
  00045	eb 0a		 jmp	 SHORT $LN20@allocate
$LN17@allocate:
  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN21@allocate:
$LN19@allocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN20@allocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@allocate:
$LN16@allocate:
  00056	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEPAEI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??4?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEAAU01@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned char> >::operator=, COMDAT
; _this$ = ecx

; 963  : 		_Mybase::operator=(_STD move(_Right));
; 964  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 965  : 		}

  00002	c2 04 00	 ret	 4
??4?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<unsigned char> >::_Wrap_alloc<std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<unsigned char> >::_Wrap_alloc<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z PROC ; std::allocator_traits<std::allocator<unsigned char> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	83 c8 ff	 or	 eax, -1

; 870  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z ENDP ; std::allocator_traits<std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@E@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@E@std@@QBEIXZ PROC		; std::allocator<unsigned char>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	83 c8 ff	 or	 eax, -1

; 750  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@E@std@@QBEIXZ ENDP		; std::allocator<unsigned char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@E@std@@QAEPAEI@Z PROC		; std::allocator<unsigned char>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 23		 jb	 SHORT $LN6@allocate
  00015	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00018	3b c8		 cmp	 ecx, eax
  0001a	76 2b		 jbe	 SHORT $LN14@allocate
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	8b c8		 mov	 ecx, eax
  00024	83 c4 04	 add	 esp, 4
  00027	85 c9		 test	 ecx, ecx
  00029	74 21		 je	 SHORT $LN16@allocate
  0002b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002e	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00031	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 c5		 jne	 SHORT $LN12@allocate
  00045	eb 0a		 jmp	 SHORT $LN17@allocate
$LN14@allocate:
  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN18@allocate:
$LN16@allocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@allocate:
$LN17@allocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@allocate:
$LN13@allocate:
  00056	cc		 int	 3
?allocate@?$allocator@E@std@@QAEPAEI@Z ENDP		; std::allocator<unsigned char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@E@std@@QAEXPAEI@Z PROC		; std::allocator<unsigned char>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000d	72 19		 jb	 SHORT $LN5@deallocate
  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $LN13@deallocate
  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00016	3b c8		 cmp	 ecx, eax
  00018	73 20		 jae	 SHORT $LN15@deallocate
  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 1e		 jb	 SHORT $LN16@deallocate
  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 1e		 ja	 SHORT $LN17@deallocate
  00026	8b c1		 mov	 eax, ecx
$LN5@deallocate:
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 721  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00035	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
$LN15@deallocate:
  0003a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN16@deallocate:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN17@deallocate:
  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN12@deallocate:
  00049	cc		 int	 3
?deallocate@?$allocator@E@std@@QAEXPAEI@Z ENDP		; std::allocator<unsigned char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@E@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@E@std@@QAE@XZ PROC			; std::allocator<unsigned char>::allocator<unsigned char>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@E@std@@QAE@XZ ENDP			; std::allocator<unsigned char>::allocator<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2459 : 	{	// test for string equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2460 : 	return (_Left.compare(_Right) == 0);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0000c	8d 71 10	 lea	 esi, DWORD PTR [ecx+16]
  0000f	72 02		 jb	 SHORT $LN25@operator
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN25@operator:
  00013	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  00016	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  0001a	8d 7a 10	 lea	 edi, DWORD PTR [edx+16]
  0001d	72 02		 jb	 SHORT $LN48@operator
  0001f	8b 12		 mov	 edx, DWORD PTR [edx]
$LN48@operator:
  00021	8b 36		 mov	 esi, DWORD PTR [esi]
  00023	8b c6		 mov	 eax, esi
  00025	8b 3f		 mov	 edi, DWORD PTR [edi]
  00027	3b fe		 cmp	 edi, esi
  00029	0f 42 c7	 cmovb	 eax, edi
  0002c	50		 push	 eax
  0002d	51		 push	 ecx
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	85 c0		 test	 eax, eax
  00039	75 16		 jne	 SHORT $LN57@operator
  0003b	3b f7		 cmp	 esi, edi
  0003d	76 0c		 jbe	 SHORT $LN58@operator
  0003f	83 c8 ff	 or	 eax, -1
  00042	85 c0		 test	 eax, eax
  00044	5f		 pop	 edi
  00045	0f 94 c0	 sete	 al
  00048	5e		 pop	 esi

; 2461 : 	}

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN58@operator:

; 2460 : 	return (_Left.compare(_Right) == 0);

  0004b	1b c0		 sbb	 eax, eax
  0004d	f7 d8		 neg	 eax
  0004f	85 c0		 test	 eax, eax
$LN57@operator:
  00051	5f		 pop	 edi
  00052	0f 94 c0	 sete	 al
  00055	5e		 pop	 esi

; 2461 : 	}

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$GetContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@@Z
_TEXT	SEGMENT
_forEachContainer$ = 8					; size = 4
___formal$ = 12						; size = 4
??$GetContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@@Z PROC ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >, COMDAT

; 95   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 96   : 			return static_cast <const ContainerForward <T> &> (forEachContainer);

  00003	8b 45 08	 mov	 eax, DWORD PTR _forEachContainer$[ebp]

; 97   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$GetContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@@Z ENDP ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$?BV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@12@XZ PROC ; GostCrypt::ForEach::TypeWrapperDummy::operator<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > > GostCrypt::ForEach::TypeWrapper<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >, COMDAT
; _this$ = ecx

; 90   : 			operator TypeWrapper <T> () const { return TypeWrapper <T> (); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
??$?BV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@12@XZ ENDP ; GostCrypt::ForEach::TypeWrapperDummy::operator<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > > GostCrypt::ForEach::TypeWrapper<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$ToTypeWrapper@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
_x$ = 8							; size = 4
??$ToTypeWrapper@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z PROC ; GostCrypt::ForEach::ToTypeWrapper<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >, COMDAT

; 85   : 		static TypeWrapper <T> ToTypeWrapper (const T &x) { return TypeWrapper <T> (); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8a 45 ff	 mov	 al, BYTE PTR $T1[ebp]
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$ToTypeWrapper@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z ENDP ; GostCrypt::ForEach::ToTypeWrapper<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z PROC ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00009	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Tidy
  0000e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00018	74 0b		 je	 SHORT $LN13@scalar
  0001a	6a 1c		 push	 28			; 0000001cH
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_G?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
_TEXT	SEGMENT
??1?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ PROC ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::~ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00006	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Tidy
  0000b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00011	5e		 pop	 esi
  00012	c3		 ret	 0
??1?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::~ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::_Compat, COMDAT
; _this$ = ecx

; 262  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::operator!=, COMDAT
; _this$ = ecx

; 218  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 95 c0	 setne	 al

; 219  : 		return (!(*this == _Right));
; 220  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::operator==, COMDAT
; _this$ = ecx

; 212  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 213  : 		_Compat(_Right);
; 214  : 		return (_Ptr == _Right._Ptr);
; 215  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 98   : 		if (_Mycont == 0
; 99   : 			|| _Ptr == nullptr_t{}
; 100  : 			|| _Mycont->_Mylast <= _Ptr)
; 101  : 			{	// report error
; 102  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 103  : 			_SCL_SECURE_OUT_OF_RANGE;
; 104  : 			}
; 105  : 
; 106  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 107  : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 108  : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 109  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 110  : 		_SCL_SECURE_VALIDATE_RANGE(_Ptr < _Mycont->_Mylast);
; 111  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 112  : 
; 113  : 		++_Ptr;

  00000	83 01 70	 add	 DWORD PTR [ecx], 112	; 00000070H

; 114  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 115  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABUSecurityTokenKeyfile@GostCrypt@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABUSecurityTokenKeyfile@GostCrypt@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 68   : 		if (_Mycont == 0
; 69   : 			|| _Ptr == _Tptr()
; 70   : 			|| _Ptr < _Mycont->_Myfirst
; 71   : 			|| _Mycont->_Mylast <= _Ptr)
; 72   : 			{	// report error
; 73   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 74   : 			_SCL_SECURE_OUT_OF_RANGE;
; 75   : 			}
; 76   : 
; 77   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 78   : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 79   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 80   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 81   : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABUSecurityTokenKeyfile@GostCrypt@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEPBUSecurityTokenKeyfile@GostCrypt@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEPBUSecurityTokenKeyfile@GostCrypt@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::_Unchecked, COMDAT
; _this$ = ecx

; 61   : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 62   : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEPBUSecurityTokenKeyfile@GostCrypt@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAE@PAUSecurityTokenKeyfile@GostCrypt@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAE@PAUSecurityTokenKeyfile@GostCrypt@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAE@PAUSecurityTokenKeyfile@GostCrypt@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?Next@?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ
_TEXT	SEGMENT
?Next@?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ PROC ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::Next, COMDAT
; _this$ = ecx

; 39   : 			virtual void Next () const { ++Iterator; }

  00000	83 41 18 70	 add	 DWORD PTR [ecx+24], 112	; 00000070H
  00004	c3		 ret	 0
?Next@?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::Next
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?IsNotEnd@?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ
_TEXT	SEGMENT
?IsNotEnd@?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ PROC ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::IsNotEnd, COMDAT
; _this$ = ecx

; 38   : 			virtual bool IsNotEnd () const { bool r = InnerContinue && Iterator != EndIterator; InnerContinue = false; return r; }

  00000	80 79 04 00	 cmp	 BYTE PTR [ecx+4], 0
  00004	74 0f		 je	 SHORT $LN3@IsNotEnd
  00006	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00009	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  0000c	74 07		 je	 SHORT $LN3@IsNotEnd
  0000e	b0 01		 mov	 al, 1
  00010	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00014	c3		 ret	 0
$LN3@IsNotEnd:
  00015	32 c0		 xor	 al, al
  00017	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0001a	c3		 ret	 0
?IsNotEnd@?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::IsNotEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??0?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_container$ = 8						; size = 4
??0?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z PROC ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >, COMDAT
; _this$ = ecx

; 36   : 				: ContainerCopy (container), EndIterator (ContainerCopy.end()), Iterator (ContainerCopy.begin()) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002a	66 c7 47 04 01
	00		 mov	 WORD PTR [edi+4], 1
  00030	ff 75 08	 push	 DWORD PTR _container$[ebp]
  00033	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@
  00043	e8 00 00 00 00	 call	 ??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >
  00048	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0004b	89 47 14	 mov	 DWORD PTR [edi+20], eax
  0004e	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00051	89 47 18	 mov	 DWORD PTR [edi+24], eax
  00054	8b c7		 mov	 eax, edi
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00060	59		 pop	 ecx
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Container@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::Container::~Container
__ehhandler$??0?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::ContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$GetContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_container$ = 12					; size = 4
??$GetContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z PROC ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >, COMDAT

; 69   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$GetContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 70   : 			return ContainerForward <T> (container);

  00025	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00028	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0002f	66 c7 47 04 01
	00		 mov	 WORD PTR [edi+4], 1
  00035	ff 75 0c	 push	 DWORD PTR _container$[ebp]
  00038	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@
  00048	e8 00 00 00 00	 call	 ??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >
  0004d	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00050	8b c7		 mov	 eax, edi
  00052	89 4f 14	 mov	 DWORD PTR [edi+20], ecx
  00055	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00058	89 4f 18	 mov	 DWORD PTR [edi+24], ecx

; 71   : 		}

  0005b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00065	59		 pop	 ecx
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z$1:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Container@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::Container::~Container
__ehhandler$??$GetContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$GetContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$GetContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z ENDP ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator--, COMDAT
; _this$ = ecx

; 424  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 425  : 		--static_cast<_Mybase&>(*this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::operator--

; 426  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 427  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator->, COMDAT
; _this$ = ecx

; 407  : 		return (pointer_traits<pointer>::pointer_to(**this));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 408  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator*, COMDAT
; _this$ = ecx

; 402  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 403  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >, COMDAT
; _this$ = ecx

; 384  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 383  : 		: _Mybase(_Pnode, _Plist)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 385  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0$$CBKUPkcs11Session@GostCrypt@@X$0A@@?$pair@KUPkcs11Session@GostCrypt@@@std@@QAE@ABU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0$$CBKUPkcs11Session@GostCrypt@@X$0A@@?$pair@KUPkcs11Session@GostCrypt@@@std@@QAE@ABU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z PROC ; std::pair<unsigned long,GostCrypt::Pkcs11Session>::pair<unsigned long,GostCrypt::Pkcs11Session><unsigned long const ,GostCrypt::Pkcs11Session,void,0>, COMDAT
; _this$ = ecx

; 123  : 		{	// construct from compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 122  : 		: first(_Right.first), second(_Right.second)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00010	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00013	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 124  : 		}

  00016	8b c1		 mov	 eax, ecx
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??$?0$$CBKUPkcs11Session@GostCrypt@@X$0A@@?$pair@KUPkcs11Session@GostCrypt@@@std@@QAE@ABU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@@Z ENDP ; std::pair<unsigned long,GostCrypt::Pkcs11Session>::pair<unsigned long,GostCrypt::Pkcs11Session><unsigned long const ,GostCrypt::Pkcs11Session,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$GetContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@@Z
_TEXT	SEGMENT
_forEachContainer$ = 8					; size = 4
___formal$ = 12						; size = 4
??$GetContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@@Z PROC ; GostCrypt::ForEach::GetContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >, COMDAT

; 95   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 96   : 			return static_cast <const ContainerForward <T> &> (forEachContainer);

  00003	8b 45 08	 mov	 eax, DWORD PTR _forEachContainer$[ebp]

; 97   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$GetContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@@Z ENDP ; GostCrypt::ForEach::GetContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$?BV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@12@XZ PROC ; GostCrypt::ForEach::TypeWrapperDummy::operator<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > > GostCrypt::ForEach::TypeWrapper<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >, COMDAT
; _this$ = ecx

; 90   : 			operator TypeWrapper <T> () const { return TypeWrapper <T> (); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
??$?BV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@12@XZ ENDP ; GostCrypt::ForEach::TypeWrapperDummy::operator<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > > GostCrypt::ForEach::TypeWrapper<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$ToTypeWrapper@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
_x$ = 8							; size = 4
??$ToTypeWrapper@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z PROC ; GostCrypt::ForEach::ToTypeWrapper<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >, COMDAT

; 85   : 		static TypeWrapper <T> ToTypeWrapper (const T &x) { return TypeWrapper <T> (); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8a 45 ff	 mov	 al, BYTE PTR $T1[ebp]
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$ToTypeWrapper@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z ENDP ; GostCrypt::ForEach::ToTypeWrapper<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UAEPAXI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UAEPAXI@Z PROC ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0000b	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0000e	50		 push	 eax
  0000f	ff 30		 push	 DWORD PTR [eax]
  00011	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::erase
  0001a	ff 77 08	 push	 DWORD PTR [edi+8]
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
  00025	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  0002b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0002f	74 0b		 je	 SHORT $LN182@scalar
  00031	6a 18		 push	 24			; 00000018H
  00033	57		 push	 edi
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00039	83 c4 08	 add	 esp, 8
$LN182@scalar:
  0003c	8b c7		 mov	 eax, edi
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
??_G?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UAEPAXI@Z ENDP ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UAE@XZ PROC ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::~ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0000b	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0000e	50		 push	 eax
  0000f	ff 30		 push	 DWORD PTR [eax]
  00011	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::erase
  0001a	ff 77 08	 push	 DWORD PTR [edi+8]
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00022	83 c4 04	 add	 esp, 4
  00025	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??1?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UAE@XZ ENDP ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::~ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 95 c0	 setne	 al

; 341  : 		return (!(*this == _Right));
; 342  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator==, COMDAT
; _this$ = ecx

; 324  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (this->_Getcont() != _Right._Getcont())
; 327  : 			{	// report error
; 328  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 329  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 330  : 			}
; 331  : 
; 332  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 333  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator--, COMDAT
; _this$ = ecx

; 285  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 286  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 287  : 		if (this->_Getcont() == 0
; 288  : 			|| this->_Ptr == nullptr_t{})
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 295  : 		--static_cast<_Mybase&>(*this);
; 296  : 		if (_Ptrsav == this->_Ptr)
; 297  : 			{	// report error
; 298  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 299  : 			_SCL_SECURE_OUT_OF_RANGE;
; 300  : 			}
; 301  : 
; 302  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 303  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 304  : 
; 305  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 306  : 		--static_cast<_Mybase&>(*this);
; 307  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 308  : 
; 309  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 310  : 		--static_cast<_Mybase&>(*this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::operator--

; 311  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 312  : 
; 313  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 314  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator++, COMDAT
; _this$ = ecx

; 278  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 279  : 		_Myiter _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 280  : 		++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::operator++

; 281  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 282  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator++, COMDAT
; _this$ = ecx

; 258  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 259  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 260  : 		if (this->_Getcont() == 0
; 261  : 			|| this->_Ptr == nullptr_t{}
; 262  : 			|| _Mytree::_Isnil(this->_Ptr))
; 263  : 			{	// report error
; 264  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 265  : 			_SCL_SECURE_OUT_OF_RANGE;
; 266  : 			}
; 267  : 
; 268  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 269  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 270  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		++static_cast<_Mybase&>(*this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::operator++

; 274  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 275  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator*, COMDAT
; _this$ = ecx

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 234  : 		if (_Mycont == 0
; 235  : 			|| this->_Ptr == nullptr_t{}
; 236  : 			|| this->_Ptr == _Mycont->_Myhead)
; 237  : 			{	// report error
; 238  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 239  : 			_SCL_SECURE_OUT_OF_RANGE;
; 240  : 			}
; 241  : 
; 242  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 243  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 244  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 245  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 246  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 247  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 248  : 
; 249  : 		return (_Mytree::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 10	 add	 eax, 16			; 00000010H

; 250  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBKUPkcs11Session@GostCrypt@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 213  : 		: _Mybase(_Pnode, _Plist)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 215  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >, COMDAT
; _this$ = ecx

; 208  : 		: _Mybase()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 210  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 124  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

  00000	8b d1		 mov	 edx, ecx

; 85   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 02		 mov	 eax, DWORD PTR [edx]
  00004	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00008	74 08		 je	 SHORT $LN4@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	89 02		 mov	 DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

  0000f	8b c2		 mov	 eax, edx

; 102  : 		}

  00011	c3		 ret	 0
$LN4@operator:

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00018	75 19		 jne	 SHORT $LN40@operator

; 88   : 			_Ptr = _Mytree::_Max(

  0001a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001d	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00021	75 36		 jne	 SHORT $LN23@operator
$LL22@operator:
  00023	8b c8		 mov	 ecx, eax
  00025	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00028	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0002c	74 f5		 je	 SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002e	89 0a		 mov	 DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

  00030	8b c2		 mov	 eax, edx

; 102  : 		}

  00032	c3		 ret	 0
$LN40@operator:

; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  00033	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00036	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0003a	75 15		 jne	 SHORT $LN3@operator
  0003c	0f 1f 40 00	 npad	 4
$LL2@operator:
  00040	8b 02		 mov	 eax, DWORD PTR [edx]
  00042	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00044	75 0b		 jne	 SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  00046	89 0a		 mov	 DWORD PTR [edx], ecx
  00048	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0004b	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0004f	74 ef		 je	 SHORT $LL2@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00057	75 02		 jne	 SHORT $LN47@operator

; 88   : 			_Ptr = _Mytree::_Max(

$LN23@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  00059	89 0a		 mov	 DWORD PTR [edx], ecx
$LN47@operator:

; 100  : 			}
; 101  : 		return (*this);

  0005b	8b c2		 mov	 eax, edx

; 102  : 		}

  0005d	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

  00000	8b d1		 mov	 edx, ecx

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 02		 mov	 eax, DWORD PTR [edx]
  00004	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00008	75 42		 jne	 SHORT $LN41@operator

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00011	75 1c		 jne	 SHORT $LN34@operator

; 63   : 			_Ptr = _Mytree::_Min(

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	75 0f		 jne	 SHORT $LN19@operator
  0001b	0f 1f 44 00 00	 npad	 5
$LL18@operator:
  00020	8b c8		 mov	 ecx, eax
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00028	74 f6		 je	 SHORT $LL18@operator
$LN19@operator:
  0002a	89 0a		 mov	 DWORD PTR [edx], ecx

; 72   : 			}
; 73   : 		return (*this);

  0002c	8b c2		 mov	 eax, edx

; 74   : 		}

  0002e	c3		 ret	 0
$LN34@operator:

; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00036	75 12		 jne	 SHORT $LN3@operator
$LL2@operator:
  00038	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0003a	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0003d	75 0b		 jne	 SHORT $LN3@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003f	89 02		 mov	 DWORD PTR [edx], eax
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00048	74 ee		 je	 SHORT $LL2@operator
$LN3@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  0004a	89 02		 mov	 DWORD PTR [edx], eax
$LN41@operator:

; 72   : 			}
; 73   : 		return (*this);

  0004c	8b c2		 mov	 eax, edx

; 74   : 		}

  0004e	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		: _Ptr(_Pnode)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 40   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE@XZ PROC ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::~map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	50		 push	 eax
  0000a	ff 30		 push	 DWORD PTR [eax]
  0000c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::erase
  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	5e		 pop	 esi
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::~map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??A?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAEAAUPkcs11Session@GostCrypt@@ABK@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Keyval$ = 8						; size = 4
??A?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAEAAUPkcs11Session@GostCrypt@@ABK@Z PROC ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::operator[], COMDAT
; _this$ = ecx

; 337  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 338  : 		return (try_emplace(_Keyval).first->second);

  00006	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  00009	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  00012	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00015	83 c0 14	 add	 eax, 20			; 00000014H

; 339  : 		}

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??A?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAEAAUPkcs11Session@GostCrypt@@ABK@Z ENDP ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??0?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE@ABV01@@Z PROC ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >, COMDAT
; _this$ = ecx

; 111  : 		{	// construct map by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 109  : 		: _Mybase(_Right,

  00007	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]

; 111  : 		{	// construct map by copying _Right

  0000a	8b f1		 mov	 esi, ecx
  0000c	50		 push	 eax
  0000d	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00010	89 75 f8	 mov	 DWORD PTR _this$[ebp], esi
  00013	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > > >

; 112  : 		}

  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??0?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE@ABV01@@Z ENDP ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??0?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE@XZ PROC ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >, COMDAT
; _this$ = ecx

; 100  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00010	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00017	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buyheadnode
  0001c	89 06		 mov	 DWORD PTR [esi], eax

; 101  : 		}

  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??0?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEABKPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEABKPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Key, COMDAT
; _this$ = ecx

; 2177 : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2178 : 		return ((const key_type&)this->_Kfn(this->_Myval(_Pnode)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H

; 2179 : 		}

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Key@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEABKPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEABKABU?$pair@$$CBKUPkcs11Session@GostCrypt@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEABKABU?$pair@$$CBKUPkcs11Session@GostCrypt@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Kfn, COMDAT
; _this$ = ecx

; 2172 : 		{	// get key from value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2173 : 		return (_Traits::_Kfn(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 2174 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?_Kfn@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEABKABU?$pair@$$CBKUPkcs11Session@GostCrypt@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2167 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2168 : 		erase(begin(), end());

  00004	8b 01		 mov	 eax, DWORD PTR [ecx]
  00006	50		 push	 eax
  00007	ff 30		 push	 DWORD PTR [eax]
  00009	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::erase

; 2169 : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2111 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2112 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]

; 2113 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	89 02		 mov	 DWORD PTR [edx], eax

; 2114 : 
; 2115 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0000e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN2@Rrotate

; 2116 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN2@Rrotate:

; 2117 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2118 : 
; 2119 : 		if (_Wherenode == _Root())

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]
  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0e		 jne	 SHORT $LN3@Rrotate

; 2120 : 			_Root() = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

  0002a	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

  0002d	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00030	5e		 pop	 esi

; 2128 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN3@Rrotate:

; 2121 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00035	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00038	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0003b	75 0e		 jne	 SHORT $LN5@Rrotate

; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003d	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

  00040	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

  00043	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00046	5e		 pop	 esi

; 2128 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN5@Rrotate:

; 2123 : 		else
; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 30		 mov	 DWORD PTR [eax], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00053	5e		 pop	 esi

; 2128 : 		}

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Root, COMDAT
; _this$ = ecx

; 2107 : 		return (this->_Parent(this->_Myhead()));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 04	 add	 eax, 4

; 2108 : 		}

  00005	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 2102 : 		return (this->_Right(this->_Myhead()));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 2103 : 		}

  00005	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 2081 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2082 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi
  00007	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 2083 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 06		 mov	 eax, DWORD PTR [esi]
  0000c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 2084 : 
; 2085 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0000f	8b 06		 mov	 eax, DWORD PTR [esi]
  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN2@Lrotate

; 2086 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN2@Lrotate:

; 2087 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2088 : 
; 2089 : 		if (_Wherenode == _Root())

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]
  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0d		 jne	 SHORT $LN3@Lrotate

; 2090 : 			_Root() = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

  0002a	89 16		 mov	 DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

  0002c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0002f	5e		 pop	 esi

; 2098 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN3@Lrotate:

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00034	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00037	3b 10		 cmp	 edx, DWORD PTR [eax]
  00039	75 0c		 jne	 SHORT $LN5@Lrotate

; 2092 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003b	89 30		 mov	 DWORD PTR [eax], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

  0003d	89 16		 mov	 DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

  0003f	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00042	5e		 pop	 esi

; 2098 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN5@Lrotate:

; 2093 : 		else
; 2094 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 16		 mov	 DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0004f	5e		 pop	 esi

; 2098 : 		}

  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2077 : 		return (this->_Left(this->_Myhead()));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2078 : 		}

  00002	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Compare@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBE_NABK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?_Compare@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBE_NABK0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Compare, COMDAT
; _this$ = ecx

; 2046 : 		{	// compare key_type to key_type, with debug checks

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000d	0f 92 c0	 setb	 al

; 2047 : 		return (_DEBUG_LT_PRED(this->_Getcomp(), _Left, _Right));
; 2048 : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?_Compare@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IBE_NABK0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2032 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 2033 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	8b f7		 mov	 esi, edi

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0000d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00011	75 1d		 jne	 SHORT $LN3@Erase
$LL4@Erase:

; 2035 : 			{	// free subtrees, then node
; 2036 : 			_Erase(this->_Right(_Pnode));

  00013	ff 76 08	 push	 DWORD PTR [esi+8]
  00016	8b cb		 mov	 ecx, ebx
  00018	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Erase

; 2037 : 			_Pnode = this->_Left(_Pnode);

  0001d	8b 36		 mov	 esi, DWORD PTR [esi]

; 2038 : 			this->_Getal().destroy(
; 2039 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2040 : 
; 2041 : 			this->_Getal().deallocate(_Rootnode, 1);

  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
  00028	8b fe		 mov	 edi, esi
  0002a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0002e	74 e3		 je	 SHORT $LL4@Erase
$LN3@Erase:
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx

; 2042 : 			}
; 2043 : 		}

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Newnode$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Destroy_if_not_nil, COMDAT
; _this$ = ecx

; 1640 : 		{	// node exists, destroy it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1641 : 		this->_Getal().destroy(
; 1642 : 			_STD addressof(this->_Myval(_Newnode)));
; 1643 : 
; 1644 : 		this->_Getal().deallocate(_Newnode, 1);

  00003	ff 75 08	 push	 DWORD PTR __Newnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 1645 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1537 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00008	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000c	75 19		 jne	 SHORT $LN91@lower_boun
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LL13@lower_boun:
  00013	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  00016	73 05		 jae	 SHORT $LN15@lower_boun
  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001b	eb 04		 jmp	 SHORT $LN16@lower_boun
$LN15@lower_boun:
  0001d	8b d0		 mov	 edx, eax
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN16@lower_boun:
  00021	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00025	74 ec		 je	 SHORT $LL13@lower_boun
$LN91@lower_boun:
  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002a	89 10		 mov	 DWORD PTR [eax], edx

; 1539 : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::find, COMDAT
; _this$ = ecx

; 1480 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1481 : 		iterator _Where = lower_bound(_Keyval);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b d0		 mov	 edx, eax
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  0000b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00012	75 18		 jne	 SHORT $LN18@find
  00014	56		 push	 esi
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$LL17@find:
  00017	39 71 10	 cmp	 DWORD PTR [ecx+16], esi
  0001a	73 05		 jae	 SHORT $LN19@find
  0001c	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0001f	eb 04		 jmp	 SHORT $LN20@find
$LN19@find:
  00021	8b d1		 mov	 edx, ecx
  00023	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN20@find:
  00025	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00029	74 ec		 je	 SHORT $LL17@find
  0002b	5e		 pop	 esi
$LN18@find:

; 1482 : 		return (_Where == end()

  0002c	3b d0		 cmp	 edx, eax
  0002e	74 11		 je	 SHORT $LN3@find
  00030	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00032	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  00035	72 0a		 jb	 SHORT $LN3@find
  00037	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	5f		 pop	 edi
  0003b	89 10		 mov	 DWORD PTR [eax], edx

; 1483 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1484 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1485 : 					? end() : _Where);
; 1486 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN3@find:

; 1482 : 		return (_Where == end()

  00041	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00044	5f		 pop	 edi
  00045	89 01		 mov	 DWORD PTR [ecx], eax
  00047	8b c1		 mov	 eax, ecx

; 1483 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1484 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1485 : 					? end() : _Where);
; 1486 : 		}

  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?clear@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::clear, COMDAT
; _this$ = ecx

; 1467 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?clear@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx

; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 		this->_Orphan_ptr(nullptr_t{});
; 1470 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 
; 1472 : 		_Erase(_Root());

  00027	8b 07		 mov	 eax, DWORD PTR [edi]
  00029	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0002c	8b f3		 mov	 esi, ebx
  0002e	80 7b 0d 00	 cmp	 BYTE PTR [ebx+13], 0
  00032	75 1d		 jne	 SHORT $LN23@clear
$LL24@clear:
  00034	ff 76 08	 push	 DWORD PTR [esi+8]
  00037	8b cf		 mov	 ecx, edi
  00039	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Erase
  0003e	8b 36		 mov	 esi, DWORD PTR [esi]
  00040	53		 push	 ebx
  00041	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00046	83 c4 04	 add	 esp, 4
  00049	8b de		 mov	 ebx, esi
  0004b	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0004f	74 e3		 je	 SHORT $LL24@clear
$LN23@clear:

; 1473 : 		_Root() = this->_Myhead();

  00051	8b 07		 mov	 eax, DWORD PTR [edi]
  00053	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1474 : 		_Lmost() = this->_Myhead();

  00056	8b 07		 mov	 eax, DWORD PTR [edi]
  00058	89 00		 mov	 DWORD PTR [eax], eax

; 1475 : 		_Rmost() = this->_Myhead();

  0005a	8b 07		 mov	 eax, DWORD PTR [edi]
  0005c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1476 : 		this->_Mysize() = 0;

  0005f	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1477 : 		}

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?clear@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::clear
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::erase, COMDAT
; _this$ = ecx

; 1444 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1445 : 		if (_First == begin() && _Last == end())

  00004	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00007	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8b 37		 mov	 esi, DWORD PTR [edi]
  00010	3b 06		 cmp	 eax, DWORD PTR [esi]
  00012	75 1a		 jne	 SHORT $LN176@erase
  00014	3b d6		 cmp	 edx, esi
  00016	75 16		 jne	 SHORT $LN176@erase

; 1446 : 			{	// erase all
; 1447 : 			clear();

  00018	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::clear

; 1448 : 			return (begin());

  0001d	8b 07		 mov	 eax, DWORD PTR [edi]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00026	89 08		 mov	 DWORD PTR [eax], ecx

; 1455 : 			}
; 1456 : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 0c 00	 ret	 12			; 0000000cH
$LN176@erase:

; 1449 : 			}
; 1450 : 		else
; 1451 : 			{	// partial erase, one at a time
; 1452 : 			while (_First != _Last)

  0002e	3b c2		 cmp	 eax, edx
  00030	74 5d		 je	 SHORT $LN3@erase
$LL2@erase:

; 1453 : 				erase(_First++);

  00032	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00036	8b c8		 mov	 ecx, eax
  00038	75 41		 jne	 SHORT $LN133@erase
  0003a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003d	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00041	75 19		 jne	 SHORT $LN178@erase
  00043	8b 02		 mov	 eax, DWORD PTR [edx]
  00045	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00049	75 2d		 jne	 SHORT $LN188@erase
  0004b	0f 1f 44 00 00	 npad	 5
$LL144@erase:
  00050	8b d0		 mov	 edx, eax
  00052	8b 02		 mov	 eax, DWORD PTR [edx]
  00054	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00058	74 f6		 je	 SHORT $LL144@erase
  0005a	eb 1c		 jmp	 SHORT $LN188@erase
$LN178@erase:
  0005c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005f	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00063	75 13		 jne	 SHORT $LN188@erase
$LL128@erase:
  00065	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00068	75 0e		 jne	 SHORT $LN188@erase
  0006a	8b c2		 mov	 eax, edx
  0006c	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
  0006f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00072	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00076	74 ed		 je	 SHORT $LL128@erase
$LN188@erase:
  00078	89 55 0c	 mov	 DWORD PTR __First$[ebp], edx
$LN133@erase:
  0007b	51		 push	 ecx
  0007c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0007f	8b cf		 mov	 ecx, edi
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::erase
  00087	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0008a	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  0008d	75 a3		 jne	 SHORT $LL2@erase
$LN3@erase:

; 1454 : 			return (iterator(_First._Ptr, &this->_Get_data()));

  0008f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	89 01		 mov	 DWORD PTR [ecx], eax
  00096	8b c1		 mov	 eax, ecx

; 1455 : 			}
; 1456 : 		}

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv1196 = -16						; size = 4
tv1197 = -12						; size = 4
tv1195 = -8						; size = 4
tv1191 = -8						; size = 4
tv1171 = -8						; size = 4
__Erasednode$1$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::erase, COMDAT
; _this$ = ecx

; 1259 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1260 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1261 : 		if (_Where._Getcont() != &this->_Get_data()
; 1262 : 			|| this->_Isnil(_Where._Mynode()))
; 1263 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1264 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1265 : 		++_Where;	// save successor iterator for return
; 1266 : 		_Orphan_ptr(_Erasednode);
; 1267 : 
; 1268 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1269 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b d9		 mov	 ebx, ecx
  0000d	89 45 fc	 mov	 DWORD PTR __Erasednode$1$[ebp], eax
  00010	57		 push	 edi

; 1270 : 		++_Where;	// save successor iterator for return

  00011	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00014	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::operator++

; 1271 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1272 : 
; 1273 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1274 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1275 : 		_Nodeptr _Pnode = _Erasednode;
; 1276 : 
; 1277 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00019	8b 4d fc	 mov	 ecx, DWORD PTR __Erasednode$1$[ebp]
  0001c	8b 31		 mov	 esi, DWORD PTR [ecx]
  0001e	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00022	74 05		 je	 SHORT $LN5@erase

; 1278 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00024	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]

; 1279 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00027	eb 1b		 jmp	 SHORT $LN691@erase
$LN5@erase:
  00029	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0002c	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00030	74 04		 je	 SHORT $LN7@erase

; 1280 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00032	8b fe		 mov	 edi, esi

; 1281 : 		else

  00034	eb 0e		 jmp	 SHORT $LN691@erase
$LN7@erase:

; 1282 : 			{	// two subtrees, must lift successor node to replace erased
; 1283 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  00036	8b 55 0c	 mov	 edx, DWORD PTR __Where$[ebp]

; 1284 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00039	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]

; 1285 : 			}
; 1286 : 
; 1287 : 		if (_Pnode == _Erasednode)

  0003c	3b d1		 cmp	 edx, ecx
  0003e	0f 85 83 00 00
	00		 jne	 $LN9@erase
$LN691@erase:

; 1288 : 			{	// at most one subtree, relink it
; 1289 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1290 : 			if (!this->_Isnil(_Fixnode))

  00044	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00048	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0004b	75 03		 jne	 SHORT $LN11@erase

; 1291 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  0004d	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN11@erase:

; 1292 : 
; 1293 : 			if (_Root() == _Erasednode)

  00050	8b 03		 mov	 eax, DWORD PTR [ebx]
  00052	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  00055	75 05		 jne	 SHORT $LN12@erase

; 1294 : 				_Root() = _Fixnode;	// link down from root

  00057	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1295 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  0005a	eb 0b		 jmp	 SHORT $LN15@erase
$LN12@erase:
  0005c	39 0e		 cmp	 DWORD PTR [esi], ecx
  0005e	75 04		 jne	 SHORT $LN14@erase

; 1296 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00060	89 3e		 mov	 DWORD PTR [esi], edi

; 1297 : 			else

  00062	eb 03		 jmp	 SHORT $LN15@erase
$LN14@erase:

; 1298 : 				this->_Right(_Fixnodeparent) =

  00064	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN15@erase:

; 1299 : 					_Fixnode;	// link down to right
; 1300 : 
; 1301 : 			if (_Lmost() == _Erasednode)

  00067	8b 03		 mov	 eax, DWORD PTR [ebx]
  00069	39 08		 cmp	 DWORD PTR [eax], ecx
  0006b	75 22		 jne	 SHORT $LN16@erase

; 1302 : 				_Lmost() = this->_Isnil(_Fixnode)

  0006d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00071	74 04		 je	 SHORT $LN42@erase
  00073	8b d6		 mov	 edx, esi
  00075	eb 16		 jmp	 SHORT $LN43@erase
$LN42@erase:
  00077	8b 07		 mov	 eax, DWORD PTR [edi]
  00079	8b d7		 mov	 edx, edi
  0007b	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0007f	75 0a		 jne	 SHORT $LN166@erase
$LL165@erase:
  00081	8b d0		 mov	 edx, eax
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
  00085	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00089	74 f6		 je	 SHORT $LL165@erase
$LN166@erase:
  0008b	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN43@erase:
  0008d	89 10		 mov	 DWORD PTR [eax], edx
$LN16@erase:

; 1303 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1304 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1305 : 
; 1306 : 			if (_Rmost() == _Erasednode)

  0008f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00091	39 48 08	 cmp	 DWORD PTR [eax+8], ecx
  00094	0f 85 8b 00 00
	00		 jne	 $LN373@erase

; 1307 : 				_Rmost() = this->_Isnil(_Fixnode)

  0009a	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0009e	74 0a		 je	 SHORT $LN44@erase
  000a0	8b d6		 mov	 edx, esi
  000a2	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1308 : 					? _Fixnodeparent	// largest is parent of erased node
; 1309 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1310 : 			}
; 1311 : 		else

  000a5	e9 7b 00 00 00	 jmp	 $LN373@erase
$LN44@erase:

; 1307 : 				_Rmost() = this->_Isnil(_Fixnode)

  000aa	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000ad	8b d7		 mov	 edx, edi
  000af	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000b3	75 0b		 jne	 SHORT $LN218@erase
$LL217@erase:
  000b5	8b d0		 mov	 edx, eax
  000b7	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ba	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000be	74 f5		 je	 SHORT $LL217@erase
$LN218@erase:
  000c0	8b 03		 mov	 eax, DWORD PTR [ebx]
  000c2	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1308 : 					? _Fixnodeparent	// largest is parent of erased node
; 1309 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1310 : 			}
; 1311 : 		else

  000c5	eb 5e		 jmp	 SHORT $LN373@erase
$LN9@erase:

; 1312 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1313 : 			this->_Parent(this->_Left(_Erasednode)) =

  000c7	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1314 : 				_Pnode;	// link left up
; 1315 : 			this->_Left(_Pnode) =

  000ca	8b 01		 mov	 eax, DWORD PTR [ecx]
  000cc	89 02		 mov	 DWORD PTR [edx], eax

; 1316 : 				this->_Left(_Erasednode);	// link successor down
; 1317 : 
; 1318 : 			if (_Pnode == this->_Right(_Erasednode))

  000ce	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  000d1	75 04		 jne	 SHORT $LN18@erase

; 1319 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000d3	8b f2		 mov	 esi, edx

; 1320 : 			else

  000d5	eb 1a		 jmp	 SHORT $LN19@erase
$LN18@erase:

; 1321 : 				{	// successor further down, link in place of erased
; 1322 : 				_Fixnodeparent =
; 1323 : 					this->_Parent(_Pnode);	// parent is successor's
; 1324 : 				if (!this->_Isnil(_Fixnode))

  000d7	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000db	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  000de	75 03		 jne	 SHORT $LN20@erase

; 1325 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000e0	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN20@erase:

; 1326 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000e3	89 3e		 mov	 DWORD PTR [esi], edi

; 1327 : 				this->_Right(_Pnode) =

  000e5	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000e8	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1328 : 					this->_Right(_Erasednode);	// link next down
; 1329 : 				this->_Parent(this->_Right(_Erasednode)) =

  000eb	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000ee	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN19@erase:

; 1330 : 					_Pnode;	// right up
; 1331 : 				}
; 1332 : 
; 1333 : 			if (_Root() == _Erasednode)

  000f1	8b 03		 mov	 eax, DWORD PTR [ebx]
  000f3	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  000f6	75 05		 jne	 SHORT $LN21@erase

; 1334 : 				_Root() = _Pnode;	// link down from root

  000f8	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1335 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000fb	eb 0e		 jmp	 SHORT $LN24@erase
$LN21@erase:
  000fd	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00100	39 08		 cmp	 DWORD PTR [eax], ecx
  00102	75 04		 jne	 SHORT $LN23@erase

; 1336 : 				this->_Left(this->_Parent(_Erasednode)) =

  00104	89 10		 mov	 DWORD PTR [eax], edx

; 1337 : 					_Pnode;	// link down to left
; 1338 : 			else

  00106	eb 03		 jmp	 SHORT $LN24@erase
$LN23@erase:

; 1339 : 				this->_Right(this->_Parent(_Erasednode)) =

  00108	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN24@erase:

; 1340 : 					_Pnode;	// link down to right
; 1341 : 
; 1342 : 			this->_Parent(_Pnode) =

  0010b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0010e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1343 : 				this->_Parent(_Erasednode);	// link successor up
; 1344 : 			_STD swap(this->_Color(_Pnode),

  00111	8b 45 fc	 mov	 eax, DWORD PTR __Erasednode$1$[ebp]
  00114	8a 4a 0c	 mov	 cl, BYTE PTR [edx+12]
  00117	8a 40 0c	 mov	 al, BYTE PTR [eax+12]
  0011a	88 42 0c	 mov	 BYTE PTR [edx+12], al
  0011d	8b 45 fc	 mov	 eax, DWORD PTR __Erasednode$1$[ebp]
  00120	88 48 0c	 mov	 BYTE PTR [eax+12], cl
  00123	8b c8		 mov	 ecx, eax
$LN373@erase:

; 1345 : 				this->_Color(_Erasednode));	// recolor it
; 1346 : 			}
; 1347 : 
; 1348 : 		if (this->_Color(_Erasednode) == this->_Black)

  00125	80 79 0c 01	 cmp	 BYTE PTR [ecx+12], 1
  00129	0f 85 ef 00 00
	00		 jne	 $LN25@erase

; 1349 : 			{	// erasing black link, must recolor/rebalance tree
; 1350 : 			for (; _Fixnode != _Root()
; 1351 : 				&& this->_Color(_Fixnode) == this->_Black;

  0012f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00131	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  00134	0f 84 e0 00 00
	00		 je	 $LN3@erase
  0013a	66 0f 1f 44 00
	00		 npad	 6
$LL4@erase:
  00140	80 7f 0c 01	 cmp	 BYTE PTR [edi+12], 1
  00144	8b d6		 mov	 edx, esi
  00146	89 55 f8	 mov	 DWORD PTR tv1195[ebp], edx
  00149	89 75 f4	 mov	 DWORD PTR tv1197[ebp], esi
  0014c	89 75 f0	 mov	 DWORD PTR tv1196[ebp], esi
  0014f	0f 85 c2 00 00
	00		 jne	 $LN694@erase

; 1353 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00155	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00157	3b f9		 cmp	 edi, ecx
  00159	75 72		 jne	 SHORT $LN26@erase

; 1354 : 					{	// fixup left subtree
; 1355 : 					_Pnode = this->_Right(_Fixnodeparent);

  0015b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1356 : 					if (this->_Color(_Pnode) == this->_Red)

  0015e	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00162	75 15		 jne	 SHORT $LN28@erase

; 1357 : 						{	// rotate red up from right subtree
; 1358 : 						this->_Color(_Pnode) = this->_Black;

  00164	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1359 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1360 : 						_Lrotate(_Fixnodeparent);

  00168	8b cb		 mov	 ecx, ebx
  0016a	56		 push	 esi
  0016b	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  0016f	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Lrotate

; 1361 : 						_Pnode = this->_Right(_Fixnodeparent);

  00174	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00177	8b d6		 mov	 edx, esi
$LN28@erase:

; 1362 : 						}
; 1363 : 
; 1364 : 					if (this->_Isnil(_Pnode))

  00179	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0017d	0f 85 80 00 00
	00		 jne	 $LN2@erase

; 1365 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1366 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1367 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00183	8b 01		 mov	 eax, DWORD PTR [ecx]
  00185	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00189	75 09		 jne	 SHORT $LN31@erase
  0018b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0018e	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00192	74 6b		 je	 SHORT $LN695@erase
$LN31@erase:

; 1368 : 						{	// redden right subtree with black children
; 1369 : 						this->_Color(_Pnode) = this->_Red;
; 1370 : 						_Fixnode = _Fixnodeparent;
; 1371 : 						}
; 1372 : 					else
; 1373 : 						{	// must rearrange right subtree
; 1374 : 						if (this->_Color(this->_Right(_Pnode))
; 1375 : 							== this->_Black)

  00194	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00197	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  0019b	75 15		 jne	 SHORT $LN33@erase

; 1376 : 							{	// rotate red up from left sub-subtree
; 1377 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  0019d	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1378 : 							this->_Color(_Pnode) = this->_Red;
; 1379 : 							_Rrotate(_Pnode);

  0019f	51		 push	 ecx
  001a0	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  001a4	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  001a8	8b cb		 mov	 ecx, ebx
  001aa	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Rrotate

; 1380 : 							_Pnode = this->_Right(_Fixnodeparent);

  001af	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$LN33@erase:

; 1381 : 							}
; 1382 : 
; 1383 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  001b2	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  001b5	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 1384 : 						this->_Color(_Fixnodeparent) = this->_Black;

  001b8	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 1385 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  001bc	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1386 : 						_Lrotate(_Fixnodeparent);

  001bf	8b cb		 mov	 ecx, ebx
  001c1	56		 push	 esi
  001c2	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  001c6	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Lrotate

; 1387 : 						break;	// tree now recolored/rebalanced

  001cb	eb 4a		 jmp	 SHORT $LN694@erase
$LN26@erase:

; 1388 : 						}
; 1389 : 					}
; 1390 : 				else
; 1391 : 					{	// fixup right subtree
; 1392 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1393 : 					if (this->_Color(_Pnode) == this->_Red)

  001cd	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  001d1	75 15		 jne	 SHORT $LN34@erase

; 1394 : 						{	// rotate red up from left subtree
; 1395 : 						this->_Color(_Pnode) = this->_Black;

  001d3	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 1396 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1397 : 						_Rrotate(_Fixnodeparent);

  001d7	8b cb		 mov	 ecx, ebx
  001d9	56		 push	 esi
  001da	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  001de	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Rrotate

; 1398 : 						_Pnode = this->_Left(_Fixnodeparent);

  001e3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001e5	8b 55 f8	 mov	 edx, DWORD PTR tv1195[ebp]
$LN34@erase:

; 1399 : 						}
; 1400 : 
; 1401 : 					if (this->_Isnil(_Pnode))

  001e8	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001ec	75 15		 jne	 SHORT $LN2@erase

; 1402 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1403 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1404 : 						this->_Black
; 1405 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001ee	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001f1	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001f5	75 4c		 jne	 SHORT $LN37@erase
  001f7	8b 01		 mov	 eax, DWORD PTR [ecx]
  001f9	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001fd	75 44		 jne	 SHORT $LN37@erase
$LN695@erase:

; 1406 : 						{	// redden left subtree with black children
; 1407 : 						this->_Color(_Pnode) = this->_Red;

  001ff	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
$LN2@erase:

; 1349 : 			{	// erasing black link, must recolor/rebalance tree
; 1350 : 			for (; _Fixnode != _Root()
; 1351 : 				&& this->_Color(_Fixnode) == this->_Black;

  00203	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1352 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00205	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00208	8b 7d f4	 mov	 edi, DWORD PTR tv1197[ebp]
  0020b	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  0020e	0f 85 2c ff ff
	ff		 jne	 $LL4@erase
  00214	8b 7d f0	 mov	 edi, DWORD PTR tv1196[ebp]
$LN694@erase:
  00217	8b 4d fc	 mov	 ecx, DWORD PTR __Erasednode$1$[ebp]
$LN3@erase:

; 1424 : 						break;	// tree now recolored/rebalanced
; 1425 : 						}
; 1426 : 					}
; 1427 : 
; 1428 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  0021a	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
$LN25@erase:

; 1429 : 			}
; 1430 : 
; 1431 : 		this->_Getal().destroy(
; 1432 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1433 : 
; 1434 : 		this->_Getal().deallocate(_Erasednode, 1);

  0021e	51		 push	 ecx
  0021f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1435 : 
; 1436 : 		if (0 < this->_Mysize())

  00224	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00227	83 c4 04	 add	 esp, 4

; 1438 : 
; 1439 : 		return (iterator(_Where._Ptr,

  0022a	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  0022d	85 c0		 test	 eax, eax
  0022f	74 04		 je	 SHORT $LN693@erase

; 1437 : 			--this->_Mysize();

  00231	48		 dec	 eax
  00232	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN693@erase:

; 1438 : 
; 1439 : 		return (iterator(_Where._Ptr,

  00235	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00238	5f		 pop	 edi
  00239	5e		 pop	 esi
  0023a	5b		 pop	 ebx
  0023b	89 08		 mov	 DWORD PTR [eax], ecx

; 1440 : 			&this->_Get_data()));	// return successor iterator
; 1441 : 		}

  0023d	8b e5		 mov	 esp, ebp
  0023f	5d		 pop	 ebp
  00240	c2 08 00	 ret	 8
$LN37@erase:

; 1408 : 						_Fixnode = _Fixnodeparent;
; 1409 : 						}
; 1410 : 					else
; 1411 : 						{	// must rearrange left subtree
; 1412 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  00243	8b 01		 mov	 eax, DWORD PTR [ecx]
  00245	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00249	75 15		 jne	 SHORT $LN39@erase

; 1413 : 							{	// rotate red up from right sub-subtree
; 1414 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  0024b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1415 : 							this->_Color(_Pnode) = this->_Red;
; 1416 : 							_Lrotate(_Pnode);

  0024e	51		 push	 ecx
  0024f	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00253	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  00257	8b cb		 mov	 ecx, ebx
  00259	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Lrotate

; 1417 : 							_Pnode = this->_Left(_Fixnodeparent);

  0025e	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN39@erase:

; 1418 : 							}
; 1419 : 
; 1420 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00260	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  00263	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 1421 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00266	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 1422 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  0026a	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1423 : 						_Rrotate(_Fixnodeparent);

  0026c	8b cb		 mov	 ecx, ebx
  0026e	56		 push	 esi
  0026f	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00273	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Rrotate
  00278	eb 9d		 jmp	 SHORT $LN694@erase
?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 1191 : 		{	// return object for comparing keys

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1192 : 		return (this->_Getcomp());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1193 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?key_comp@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@K@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::key_comp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::max_size, COMDAT
; _this$ = ecx

; 1176 : 		return (this->_Getal().max_size());

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 1177 : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::size, COMDAT
; _this$ = ecx

; 1171 : 		return (this->_Mysize());

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1172 : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::end, COMDAT
; _this$ = ecx

; 1125 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1126 : 		return (const_iterator(this->_Myhead(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1127 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::end, COMDAT
; _this$ = ecx

; 1120 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1121 : 		return (iterator(this->_Myhead(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1122 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::begin, COMDAT
; _this$ = ecx

; 1115 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1116 : 		return (const_iterator(_Lmost(), &this->_Get_data()));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1117 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::begin, COMDAT
; _this$ = ecx

; 1110 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1111 : 		return (iterator(_Lmost(), &this->_Get_data()));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1112 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >, COMDAT
; _this$ = ecx

; 1090 : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 1091 : 		_Tidy();

  00007	8b 06		 mov	 eax, DWORD PTR [esi]
  00009	50		 push	 eax
  0000a	ff 30		 push	 DWORD PTR [eax]
  0000c	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::erase

; 1092 : 		}

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4
  0001f	5e		 pop	 esi
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >, COMDAT
; _this$ = ecx

; 1004 : 		{	// construct empty tree from comparator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00010	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00017	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buyheadnode
  0001c	89 06		 mov	 DWORD PTR [esi], eax

; 1005 : 		}

  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<unsigned long>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<unsigned long>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<unsigned long>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<unsigned long>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@K@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@K@2@XZ PROC ; std::_Compressed_pair<std::less<unsigned long>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@K@2@XZ ENDP ; std::_Compressed_pair<std::less<unsigned long>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@K@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@K@2@XZ PROC ; std::_Compressed_pair<std::less<unsigned long>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$less@K@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@K@2@XZ ENDP ; std::_Compressed_pair<std::less<unsigned long>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Min, COMDAT

; 614  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 615  : 		while (!_Isnil(_Left(_Pnode)))

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000c	75 0c		 jne	 SHORT $LN15@Min
  0000e	66 90		 npad	 2
$LL2@Min:

; 616  : 			_Pnode = _Left(_Pnode);

  00010	8b c8		 mov	 ecx, eax
  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00018	74 f6		 je	 SHORT $LL2@Min
$LN15@Min:

; 617  : 		return (_Pnode);

  0001a	8b c1		 mov	 eax, ecx

; 618  : 		}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Max, COMDAT

; 607  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 608  : 		while (!_Isnil(_Right(_Pnode)))

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00006	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00009	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000d	75 0c		 jne	 SHORT $LN15@Max
  0000f	90		 npad	 1
$LL2@Max:

; 609  : 			_Pnode = _Right(_Pnode);

  00010	8b c8		 mov	 ecx, eax
  00012	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN15@Max:

; 610  : 		return (_Pnode);

  0001b	8b c1		 mov	 eax, ecx

; 611  : 		}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@2@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@2@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Myval, COMDAT

; 602  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 603  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H

; 604  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@2@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Right, COMDAT

; 597  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 598  : 		return ((_Nodepref)_Pnode->_Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 599  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Parent, COMDAT

; 592  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 594  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Left, COMDAT

; 587  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 588  : 		return ((_Nodepref)_Pnode->_Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 589  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Isnil, COMDAT

; 582  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 583  : 		return ((char&)_Pnode->_Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0d	 add	 eax, 13			; 0000000dH

; 584  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Color, COMDAT

; 577  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 578  : 		return ((char&)_Pnode->_Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 579  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >, COMDAT
; _this$ = ecx

; 567  : 		: _Myhead(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 570  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??R?$less@K@std@@QBE_NABK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@K@std@@QBE_NABK0@Z PROC			; std::less<unsigned long>::operator(), COMDAT
; _this$ = ecx

; 238  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000d	0f 92 c0	 setb	 al

; 239  : 		return (_Left < _Right);
; 240  : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??R?$less@K@std@@QBE_NABK0@Z ENDP			; std::less<unsigned long>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEABIXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Mysize, COMDAT
; _this$ = ecx

; 945  : 		return (_Get_data()._Mysize);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 946  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEABIXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEAAIXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Mysize, COMDAT
; _this$ = ecx

; 940  : 		return (_Get_data()._Mysize);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 941  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEAAIXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Myhead, COMDAT
; _this$ = ecx

; 935  : 		return (_Get_data()._Myhead);

  00000	8b c1		 mov	 eax, ecx

; 936  : 		}

  00002	c3		 ret	 0
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Myhead, COMDAT
; _this$ = ecx

; 930  : 		return (_Get_data()._Myhead);

  00000	8b c1		 mov	 eax, ecx

; 931  : 		}

  00002	c3		 ret	 0
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 925  : 		return (_Mypair._Get_second()._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 926  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 920  : 		return (_Mypair._Get_second()._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 921  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 915  : 		return (_Mypair._Get_second()._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 916  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 910  : 		return (_Mypair._Get_second()._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 911  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEABU?$less@K@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEABU?$less@K@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 905  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 906  : 		}

  00002	c3		 ret	 0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QBEABU?$less@K@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEAAU?$less@K@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEAAU?$less@K@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 900  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 901  : 		}

  00002	c3		 ret	 0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEAAU?$less@K@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Freenode0, COMDAT
; _this$ = ecx

; 868  : 		{	// free non-value node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 869  : 		_Getal().destroy(
; 870  : 			_STD addressof(_Left(_Pnode)));
; 871  : 		_Getal().destroy(
; 872  : 			_STD addressof(_Parent(_Pnode)));
; 873  : 		_Getal().destroy(
; 874  : 			_STD addressof(_Right(_Pnode)));
; 875  : 		_Getal().deallocate(_Pnode, 1);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 876  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode0, COMDAT
; _this$ = ecx

; 849  : 		{	// allocate a non-value node

  00000	56		 push	 esi

; 850  : 		_Nodeptr _Pnode = _Getal().allocate(1);

  00001	6a 1c		 push	 28			; 0000001cH
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	8b d0		 mov	 edx, eax
  0000c	83 c4 04	 add	 esp, 4
  0000f	85 d2		 test	 edx, edx
  00011	74 1e		 je	 SHORT $LN199@Buynode0

; 851  : 
; 852  : 		_TRY_BEGIN
; 853  : 		_Getal().construct(

  00013	8b 06		 mov	 eax, DWORD PTR [esi]

; 854  : 			_STD addressof(_Left(_Pnode)), _Myhead());
; 855  : 		_Getal().construct(

  00015	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
  00018	89 02		 mov	 DWORD PTR [edx], eax
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 04		 je	 SHORT $LN120@Buynode0
  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
  00020	89 01		 mov	 DWORD PTR [ecx], eax
$LN120@Buynode0:

; 856  : 			_STD addressof(_Parent(_Pnode)), _Myhead());
; 857  : 		_Getal().construct(

  00022	8d 4a 08	 lea	 ecx, DWORD PTR [edx+8]
  00025	85 c9		 test	 ecx, ecx
  00027	74 04		 je	 SHORT $LN167@Buynode0
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	89 01		 mov	 DWORD PTR [ecx], eax
$LN167@Buynode0:

; 858  : 			_STD addressof(_Right(_Pnode)), _Myhead());
; 859  : 		_CATCH_ALL
; 860  : 		_Getal().deallocate(_Pnode, 1);
; 861  : 		_RERAISE;
; 862  : 		_CATCH_END
; 863  : 
; 864  : 		return (_Pnode);

  0002d	8b c2		 mov	 eax, edx
  0002f	5e		 pop	 esi

; 865  : 		}

  00030	c3		 ret	 0
$LN199@Buynode0:

; 850  : 		_Nodeptr _Pnode = _Getal().allocate(1);

  00031	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN201@Buynode0:
$LN198@Buynode0:
  00036	cc		 int	 3
?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Freeheadnode, COMDAT
; _this$ = ecx

; 838  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 839  : 		_Getal().destroy(
; 840  : 			_STD addressof(_Left(_Pnode)));
; 841  : 		_Getal().destroy(
; 842  : 			_STD addressof(_Parent(_Pnode)));
; 843  : 		_Getal().destroy(
; 844  : 			_STD addressof(_Right(_Pnode)));
; 845  : 		_Getal().deallocate(_Pnode, 1);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 846  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buyheadnode, COMDAT
; _this$ = ecx

; 818  : 		_Nodeptr _Pnode = _Getal().allocate(1);

  00000	6a 1c		 push	 28			; 0000001cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 819  : 
; 820  : 		_TRY_BEGIN
; 821  : 		_Getal().construct(
; 822  : 			_STD addressof(_Left(_Pnode)), _Pnode);
; 823  : 		_Getal().construct(

  00012	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00015	89 00		 mov	 DWORD PTR [eax], eax
  00017	85 c9		 test	 ecx, ecx
  00019	74 02		 je	 SHORT $LN96@Buyheadnod
  0001b	89 01		 mov	 DWORD PTR [ecx], eax
$LN96@Buyheadnod:

; 824  : 			_STD addressof(_Parent(_Pnode)), _Pnode);
; 825  : 		_Getal().construct(

  0001d	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  00020	85 c9		 test	 ecx, ecx
  00022	74 02		 je	 SHORT $LN131@Buyheadnod
  00024	89 01		 mov	 DWORD PTR [ecx], eax
$LN131@Buyheadnod:

; 826  : 			_STD addressof(_Right(_Pnode)), _Pnode);
; 827  : 		_CATCH_ALL
; 828  : 		_Getal().deallocate(_Pnode, 1);
; 829  : 		_RERAISE;
; 830  : 		_CATCH_END
; 831  : 
; 832  : 		_Color(_Pnode) = _Black;

  00026	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 833  : 		_Isnil(_Pnode) = true;
; 834  : 		return (_Pnode);
; 835  : 		}

  0002c	c3		 ret	 0
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??1?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >, COMDAT
; _this$ = ecx

; 726  : 		_Freeheadnode(_Myhead());

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx

; 727  : 		}

  00008	c3		 ret	 0
??1?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Construct, COMDAT
; _this$ = ecx

; 720  : 		{	// construct head node

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 721  : 		_Myhead() = _Buyheadnode();

  00003	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buyheadnode
  00008	89 06		 mov	 DWORD PTR [esi], eax
  0000a	5e		 pop	 esi

; 722  : 		}

  0000b	c3		 ret	 0
?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
??0?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >, COMDAT
; _this$ = ecx

; 704  : 		{	// construct from comparator

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 705  : 		_Construct();

  00010	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Buyheadnode
  00015	89 06		 mov	 DWORD PTR [esi], eax

; 706  : 		}

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi
  0001a	c2 04 00	 ret	 4
??0?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Min, COMDAT

; 697  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000c	75 0c		 jne	 SHORT $LN17@Min
  0000e	66 90		 npad	 2
$LL4@Min:
  00010	8b c8		 mov	 ecx, eax
  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00018	74 f6		 je	 SHORT $LL4@Min
$LN17@Min:
  0001a	8b c1		 mov	 eax, ecx

; 699  : 		}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Max, COMDAT

; 692  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00006	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00009	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0000d	75 0c		 jne	 SHORT $LN17@Max
  0000f	90		 npad	 1
$LL4@Max:
  00010	8b c8		 mov	 ecx, eax
  00012	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	74 f5		 je	 SHORT $LL4@Max
$LN17@Max:
  0001b	8b c1		 mov	 eax, ecx

; 694  : 		}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@2@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@2@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Myval, COMDAT

; 687  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 688  : 		return (_Tree_val<_Val_types>::_Myval(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H

; 689  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAAU?$pair@$$CBKUPkcs11Session@GostCrypt@@@2@PAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Right, COMDAT

; 682  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 683  : 		return (_Tree_val<_Val_types>::_Right(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 684  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Parent, COMDAT

; 677  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 678  : 		return (_Tree_val<_Val_types>::_Parent(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 679  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Left, COMDAT

; 672  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 673  : 		return (_Tree_val<_Val_types>::_Left(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 674  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Isnil, COMDAT

; 667  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 668  : 		return (_Tree_val<_Val_types>::_Isnil(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0d	 add	 eax, 13			; 0000000dH

; 669  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Color, COMDAT

; 662  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 663  : 		return (_Tree_val<_Val_types>::_Color(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 664  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 1009 : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 988  : 		}

  00003	5d		 pop	 ebp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00004	e9 00 00 00 00	 jmp	 ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 977  : 		}

  00003	5d		 pop	 ebp

; 976  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 870  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 750  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 06		 jne	 SHORT $LN4@allocate
  0000a	33 c0		 xor	 eax, eax
$LN12@allocate:

; 726  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  00010	81 f9 49 92 24
	09		 cmp	 ecx, 153391689		; 09249249H
  00016	77 45		 ja	 SHORT $LN14@allocate
  00018	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001f	2b c1		 sub	 eax, ecx
  00021	c1 e0 02	 shl	 eax, 2
  00024	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00029	72 23		 jb	 SHORT $LN6@allocate
  0002b	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  0002e	3b c8		 cmp	 ecx, eax
  00030	76 30		 jbe	 SHORT $LN16@allocate
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00038	8b c8		 mov	 ecx, eax
  0003a	83 c4 04	 add	 esp, 4
  0003d	85 c9		 test	 ecx, ecx
  0003f	74 26		 je	 SHORT $LN17@allocate
  00041	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00044	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00047	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00054	83 c4 04	 add	 esp, 4
  00057	85 c0		 test	 eax, eax
  00059	75 b1		 jne	 SHORT $LN12@allocate
  0005b	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:
  0005d	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:
  00062	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:
  00067	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:
  0006c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00071	cc		 int	 3
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	81 fa 49 92 24
	09		 cmp	 edx, 153391689		; 09249249H
  0000f	77 3a		 ja	 SHORT $LN13@deallocate
  00011	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [edx*8]
  00018	2b c2		 sub	 eax, edx
  0001a	c1 e0 02	 shl	 eax, 2
  0001d	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00022	72 1a		 jb	 SHORT $LN5@deallocate
  00024	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00027	75 27		 jne	 SHORT $LN15@deallocate
  00029	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0002c	3b c1		 cmp	 eax, ecx
  0002e	73 25		 jae	 SHORT $LN16@deallocate
  00030	2b c8		 sub	 ecx, eax
  00032	83 f9 04	 cmp	 ecx, 4
  00035	72 23		 jb	 SHORT $LN17@deallocate
  00037	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0003a	77 23		 ja	 SHORT $LN18@deallocate
  0003c	8b c8		 mov	 ecx, eax
$LN5@deallocate:
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00044	83 c4 04	 add	 esp, 4

; 721  : 		}

  00047	5d		 pop	 ebp
  00048	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:
  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:
  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:
  0005a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  0005f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  00064	cc		 int	 3
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?Next@?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UBEXXZ
_TEXT	SEGMENT
?Next@?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UBEXXZ PROC ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::Next, COMDAT
; _this$ = ecx

; 39   : 			virtual void Next () const { ++Iterator; }

  00000	83 c1 14	 add	 ecx, 20			; 00000014H
  00003	e9 00 00 00 00	 jmp	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >,std::_Iterator_base0>::operator++
?Next@?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UBEXXZ ENDP ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::Next
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?IsNotEnd@?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UBE_NXZ
_TEXT	SEGMENT
?IsNotEnd@?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UBE_NXZ PROC ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::IsNotEnd, COMDAT
; _this$ = ecx

; 38   : 			virtual bool IsNotEnd () const { bool r = InnerContinue && Iterator != EndIterator; InnerContinue = false; return r; }

  00000	80 79 04 00	 cmp	 BYTE PTR [ecx+4], 0
  00004	74 0f		 je	 SHORT $LN3@IsNotEnd
  00006	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00009	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  0000c	74 07		 je	 SHORT $LN3@IsNotEnd
  0000e	b0 01		 mov	 al, 1
  00010	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00014	c3		 ret	 0
$LN3@IsNotEnd:
  00015	32 c0		 xor	 al, al
  00017	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0001a	c3		 ret	 0
?IsNotEnd@?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UBE_NXZ ENDP ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::IsNotEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??0?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@QAE@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_container$ = 8						; size = 4
??0?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@QAE@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z PROC ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >, COMDAT
; _this$ = ecx

; 36   : 				: ContainerCopy (container), EndIterator (ContainerCopy.end()), Iterator (ContainerCopy.begin()) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@QAE@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002c	66 c7 47 04 01
	00		 mov	 WORD PTR [edi+4], 1
  00032	8d 45 f3	 lea	 eax, DWORD PTR $T2[ebp]
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003c	50		 push	 eax
  0003d	ff 75 08	 push	 DWORD PTR _container$[ebp]
  00040	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  00043	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@6B@
  00049	8b ce		 mov	 ecx, esi
  0004b	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
  0004e	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > > >
  00053	8b 06		 mov	 eax, DWORD PTR [esi]
  00055	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00058	8b 06		 mov	 eax, DWORD PTR [esi]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	89 47 14	 mov	 DWORD PTR [edi+20], eax
  0005f	8b c7		 mov	 eax, edi
  00061	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00064	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006b	59		 pop	 ecx
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@QAE@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Container@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::Container::~Container
__ehhandler$??0?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@QAE@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@QAE@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@QAE@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z ENDP ; GostCrypt::ForEach::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >::ContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$GetContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_container$ = 12					; size = 4
??$GetContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z PROC ; GostCrypt::ForEach::GetContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >, COMDAT

; 69   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$GetContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 70   : 			return ContainerForward <T> (container);

  00027	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0002a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00031	66 c7 47 04 01
	00		 mov	 WORD PTR [edi+4], 1
  00037	8d 45 f3	 lea	 eax, DWORD PTR $T3[ebp]
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	50		 push	 eax
  00042	ff 75 0c	 push	 DWORD PTR _container$[ebp]
  00045	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  00048	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@6B@
  0004e	8b ce		 mov	 ecx, esi
  00050	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
  00053	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@PAX@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned long const ,GostCrypt::Pkcs11Session>,void *> > > >
  00058	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005a	8b c7		 mov	 eax, edi
  0005c	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  0005f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00061	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00063	89 4f 14	 mov	 DWORD PTR [edi+20], ecx

; 71   : 		}

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z$1:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Container@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::Container::~Container
__ehhandler$??$GetContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$GetContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$GetContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z ENDP ; GostCrypt::ForEach::GetContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
$T2 = -100						; size = 20
$T3 = -80						; size = 20
$T4 = -60						; size = 20
$T5 = -40						; size = 8
$T6 = -40						; size = 8
__Ok$ = -40						; size = 8
$T7 = -32						; size = 4
$T8 = -32						; size = 4
tv1331 = -28						; size = 4
__State$ = -24						; size = 4
__Size$1$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
tv1324 = 12						; size = 4
__Str$ = 12						; size = 4
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 170  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 171  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 172  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 173  : 	typedef typename _Mystr::size_type _Mysizt;
; 174  : 
; 175  : 	ios_base::iostate _State = ios_base::goodbit;
; 176  : 	_Mysizt _Size = _Str.size();

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  0002e	33 ff		 xor	 edi, edi

; 177  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size

  00030	8b 5d 08	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  00033	89 7d e8	 mov	 DWORD PTR __State$[ebp], edi
  00036	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00039	8b 03		 mov	 eax, DWORD PTR [ebx]
  0003b	89 55 ec	 mov	 DWORD PTR __Size$1$[ebp], edx
  0003e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00041	8b 44 19 24	 mov	 eax, DWORD PTR [ecx+ebx+36]
  00045	8b 74 19 20	 mov	 esi, DWORD PTR [ecx+ebx+32]
  00049	85 c0		 test	 eax, eax
  0004b	7c 14		 jl	 SHORT $LN17@operator
  0004d	7f 04		 jg	 SHORT $LN286@operator
  0004f	85 f6		 test	 esi, esi
  00051	74 0e		 je	 SHORT $LN17@operator
$LN286@operator:
  00053	89 45 dc	 mov	 DWORD PTR $T6[ebp+4], eax
  00056	3b f2		 cmp	 esi, edx
  00058	76 07		 jbe	 SHORT $LN17@operator
  0005a	89 45 dc	 mov	 DWORD PTR $T5[ebp+4], eax
  0005d	2b f2		 sub	 esi, edx
  0005f	eb 02		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00061	33 f6		 xor	 esi, esi
$LN18@operator:

; 178  : 		? 0 : (_Mysizt)_Ostr.width() - _Size;
; 179  : 	const typename _Myos::sentry _Ok(_Ostr);

  00063	8b 4c 19 38	 mov	 ecx, DWORD PTR [ecx+ebx+56]
  00067	89 5d d8	 mov	 DWORD PTR __Ok$[ebp], ebx
  0006a	85 c9		 test	 ecx, ecx
  0006c	74 05		 je	 SHORT $LN47@operator
  0006e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00070	ff 50 04	 call	 DWORD PTR [eax+4]
$LN47@operator:
  00073	8b 03		 mov	 eax, DWORD PTR [ebx]
  00075	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0007c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007f	83 7c 18 0c 00	 cmp	 DWORD PTR [eax+ebx+12], 0
  00084	75 11		 jne	 SHORT $LN43@operator
  00086	8b 4c 18 3c	 mov	 ecx, DWORD PTR [eax+ebx+60]
  0008a	85 c9		 test	 ecx, ecx
  0008c	74 09		 je	 SHORT $LN43@operator
  0008e	3b cb		 cmp	 ecx, ebx
  00090	74 05		 je	 SHORT $LN43@operator
  00092	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
$LN43@operator:
  00097	8b 03		 mov	 eax, DWORD PTR [ebx]
  00099	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009c	83 7c 19 0c 00	 cmp	 DWORD PTR [ecx+ebx+12], 0
  000a1	0f 94 c0	 sete	 al
  000a4	88 45 dc	 mov	 BYTE PTR __Ok$[ebp+4], al
  000a7	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 180  : 
; 181  : 	if (!_Ok)

  000ae	84 c0		 test	 al, al
  000b0	75 0a		 jne	 SHORT $LN8@operator

; 182  : 		_State |= ios_base::badbit;

  000b2	bf 04 00 00 00	 mov	 edi, 4

; 183  : 	else

  000b7	e9 55 01 00 00	 jmp	 $LN22@operator
$LN8@operator:

; 184  : 		{	// state okay, insert characters
; 185  : 	_TRY_IO_BEGIN
; 186  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000bc	8b 44 19 14	 mov	 eax, DWORD PTR [ecx+ebx+20]
  000c0	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000c5	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000c9	83 f8 40	 cmp	 eax, 64			; 00000040H
  000cc	74 64		 je	 SHORT $LN283@operator
  000ce	66 90		 npad	 2
$LL4@operator:

; 187  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000d0	85 f6		 test	 esi, esi
  000d2	74 5a		 je	 SHORT $LN3@operator

; 188  : 				if (_Traits::eq_int_type(_Traits::eof(),

  000d4	8b 03		 mov	 eax, DWORD PTR [ebx]
  000d6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d9	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  000dd	0f b7 54 18 40	 movzx	 edx, WORD PTR [eax+ebx+64]
  000e2	89 55 e0	 mov	 DWORD PTR $T8[ebp], edx
  000e5	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  000e8	83 38 00	 cmp	 DWORD PTR [eax], 0
  000eb	74 21		 je	 SHORT $LN77@operator
  000ed	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  000f0	8b 00		 mov	 eax, DWORD PTR [eax]
  000f2	85 c0		 test	 eax, eax
  000f4	7e 18		 jle	 SHORT $LN77@operator
  000f6	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000f9	48		 dec	 eax
  000fa	89 02		 mov	 DWORD PTR [edx], eax
  000fc	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  000ff	8b 11		 mov	 edx, DWORD PTR [ecx]
  00101	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00104	89 01		 mov	 DWORD PTR [ecx], eax
  00106	8b 45 e0	 mov	 eax, DWORD PTR $T8[ebp]
  00109	66 89 02	 mov	 WORD PTR [edx], ax
  0010c	eb 06		 jmp	 SHORT $LN294@operator
$LN77@operator:
  0010e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00110	52		 push	 edx
  00111	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN294@operator:
  00114	0f b7 c0	 movzx	 eax, ax
  00117	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0011c	66 3b c8	 cmp	 cx, ax
  0011f	75 0a		 jne	 SHORT $LN2@operator

; 189  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 190  : 					{	// insertion failed, quit
; 191  : 					_State |= ios_base::badbit;

  00121	bf 04 00 00 00	 mov	 edi, 4
  00126	89 7d e8	 mov	 DWORD PTR __State$[ebp], edi

; 192  : 					break;

  00129	eb 35		 jmp	 SHORT $LL288@operator
$LN2@operator:

; 187  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  0012b	4e		 dec	 esi
  0012c	eb a2		 jmp	 SHORT $LL4@operator
$LN3@operator:
  0012e	85 ff		 test	 edi, edi

; 193  : 					}
; 194  : 
; 195  : 		if (_State == ios_base::goodbit
; 196  : 			&& _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)

  00130	75 2e		 jne	 SHORT $LL288@operator
$LN283@operator:
  00132	8b 55 0c	 mov	 edx, DWORD PTR __Str$[ebp]
  00135	83 7a 14 08	 cmp	 DWORD PTR [edx+20], 8
  00139	72 02		 jb	 SHORT $LN111@operator
  0013b	8b 12		 mov	 edx, DWORD PTR [edx]
$LN111@operator:
  0013d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0013f	6a 00		 push	 0
  00141	ff 75 ec	 push	 DWORD PTR __Size$1$[ebp]
  00144	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00147	52		 push	 edx
  00148	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  0014c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0014e	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00151	ff d0		 call	 eax
  00153	3b 45 ec	 cmp	 eax, DWORD PTR __Size$1$[ebp]
  00156	75 61		 jne	 SHORT $LN287@operator
  00158	85 d2		 test	 edx, edx
  0015a	75 5d		 jne	 SHORT $LN287@operator
  0015c	0f 1f 40 00	 npad	 4
$LL288@operator:

; 199  : 		else
; 200  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00160	85 f6		 test	 esi, esi
  00162	74 5a		 je	 SHORT $LN6@operator

; 201  : 				if (_Traits::eq_int_type(_Traits::eof(),

  00164	8b 03		 mov	 eax, DWORD PTR [ebx]
  00166	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00169	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  0016d	0f b7 54 18 40	 movzx	 edx, WORD PTR [eax+ebx+64]
  00172	89 55 e0	 mov	 DWORD PTR $T7[ebp], edx
  00175	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00178	83 38 00	 cmp	 DWORD PTR [eax], 0
  0017b	74 21		 je	 SHORT $LN124@operator
  0017d	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00180	8b 00		 mov	 eax, DWORD PTR [eax]
  00182	85 c0		 test	 eax, eax
  00184	7e 18		 jle	 SHORT $LN124@operator
  00186	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00189	48		 dec	 eax
  0018a	89 02		 mov	 DWORD PTR [edx], eax
  0018c	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0018f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00191	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00194	89 01		 mov	 DWORD PTR [ecx], eax
  00196	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00199	66 89 02	 mov	 WORD PTR [edx], ax
  0019c	eb 06		 jmp	 SHORT $LN295@operator
$LN124@operator:
  0019e	8b 01		 mov	 eax, DWORD PTR [ecx]
  001a0	52		 push	 edx
  001a1	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN295@operator:
  001a4	0f b7 c0	 movzx	 eax, ax
  001a7	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  001ac	66 3b c8	 cmp	 cx, ax
  001af	75 05		 jne	 SHORT $LN5@operator

; 202  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 203  : 					{	// insertion failed, quit
; 204  : 					_State |= ios_base::badbit;

  001b1	83 cf 04	 or	 edi, 4

; 205  : 					break;

  001b4	eb 08		 jmp	 SHORT $LN6@operator
$LN5@operator:

; 199  : 		else
; 200  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  001b6	4e		 dec	 esi
  001b7	eb a7		 jmp	 SHORT $LL288@operator
$LN287@operator:

; 197  : 				!= (streamsize)_Size)
; 198  : 				_State |= ios_base::badbit;

  001b9	bf 04 00 00 00	 mov	 edi, 4
$LN6@operator:

; 206  : 					}
; 207  : 		_Ostr.width(0);

  001be	8b 03		 mov	 eax, DWORD PTR [ebx]
  001c0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c3	c7 44 18 20 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+32], 0
  001cb	c7 44 18 24 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+36], 0
  001d3	eb 35		 jmp	 SHORT $LN296@operator
__catch$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$0:

; 208  : 		_CATCH_IO_(_Ostr)

  001d5	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001d8	8b 01		 mov	 eax, DWORD PTR [ecx]
  001da	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001dd	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  001e1	03 d1		 add	 edx, ecx
  001e3	83 c8 04	 or	 eax, 4
  001e6	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  001ea	75 03		 jne	 SHORT $LN153@operator
  001ec	83 c8 04	 or	 eax, 4
$LN153@operator:
  001ef	83 e0 17	 and	 eax, 23			; 00000017H
  001f2	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  001f5	85 42 10	 test	 DWORD PTR [edx+16], eax
  001f8	0f 85 0e 01 00
	00		 jne	 $LN156@operator
  001fe	b8 00 00 00 00	 mov	 eax, $LN23@operator
  00203	c3		 ret	 0
$LN23@operator:
  00204	8b 5d 08	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  00207	8b 7d e8	 mov	 edi, DWORD PTR __State$[ebp]
$LN296@operator:
  0020a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:

; 209  : 		}
; 210  : 
; 211  : 	_Ostr.setstate(_State);

  00211	8b 03		 mov	 eax, DWORD PTR [ebx]
  00213	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00216	03 d3		 add	 edx, ebx
  00218	85 ff		 test	 edi, edi
  0021a	0f 84 a8 00 00
	00		 je	 $LN221@operator
  00220	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00223	0b c7		 or	 eax, edi
  00225	8b c8		 mov	 ecx, eax
  00227	83 c9 04	 or	 ecx, 4
  0022a	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0022e	0f 45 c8	 cmovne	 ecx, eax
  00231	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00234	83 e1 17	 and	 ecx, 23			; 00000017H
  00237	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  0023a	23 c1		 and	 eax, ecx
  0023c	0f 84 86 00 00
	00		 je	 $LN221@operator
  00242	a8 04		 test	 al, 4
  00244	74 2a		 je	 SHORT $LN218@operator
  00246	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  0024b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  00250	50		 push	 eax
  00251	6a 01		 push	 1
  00253	8d 4d c4	 lea	 ecx, DWORD PTR $T4[ebp]
  00256	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  0025b	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00260	8d 45 c4	 lea	 eax, DWORD PTR $T4[ebp]
  00263	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  0026a	50		 push	 eax
  0026b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN297@operator:
$LN218@operator:
  00270	a8 02		 test	 al, 2
  00272	74 2a		 je	 SHORT $LN220@operator
  00274	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00279	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  0027e	50		 push	 eax
  0027f	6a 01		 push	 1
  00281	8d 4d b0	 lea	 ecx, DWORD PTR $T3[ebp]
  00284	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00289	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  0028e	8d 45 b0	 lea	 eax, DWORD PTR $T3[ebp]
  00291	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00298	50		 push	 eax
  00299	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN298@operator:
$LN220@operator:
  0029e	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  002a3	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  002a8	50		 push	 eax
  002a9	6a 01		 push	 1
  002ab	8d 4d 9c	 lea	 ecx, DWORD PTR $T2[ebp]
  002ae	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  002b3	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  002b8	8d 45 9c	 lea	 eax, DWORD PTR $T2[ebp]
  002bb	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  002c2	50		 push	 eax
  002c3	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN299@operator:
$LN221@operator:

; 212  : 	return (_Ostr);

  002c8	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  002cf	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  002d4	8b 75 d8	 mov	 esi, DWORD PTR __Ok$[ebp]
  002d7	84 c0		 test	 al, al
  002d9	75 07		 jne	 SHORT $LN262@operator
  002db	8b ce		 mov	 ecx, esi
  002dd	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN262@operator:
  002e2	8b 06		 mov	 eax, DWORD PTR [esi]
  002e4	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  002e8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002eb	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  002ef	85 c9		 test	 ecx, ecx
  002f1	74 05		 je	 SHORT $LN266@operator
  002f3	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f5	ff 52 08	 call	 DWORD PTR [edx+8]
$LN266@operator:
  002f8	8b c3		 mov	 eax, ebx

; 213  : 	}

  002fa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00304	59		 pop	 ecx
  00305	5f		 pop	 edi
  00306	5e		 pop	 esi
  00307	5b		 pop	 ebx
  00308	8b e5		 mov	 esp, ebp
  0030a	5d		 pop	 ebp
  0030b	c3		 ret	 0

; 208  : 		_CATCH_IO_(_Ostr)

$LN156@operator:
  0030c	6a 00		 push	 0
  0030e	6a 00		 push	 0
  00310	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN300@operator:
$LN293@operator:
  00315	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$7:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$2:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$43:
  00010	e8 00 00 00 00	 call	 ___std_terminate
  00015	c3		 ret	 0
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$44:
  00016	e8 00 00 00 00	 call	 ___std_terminate
  0001b	c3		 ret	 0
__ehhandler$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
_TEXT	SEGMENT
$T2 = -96						; size = 20
$T3 = -76						; size = 20
$T4 = -56						; size = 20
__Ok$ = -36						; size = 8
__Pad$ = -36						; size = 8
__State$ = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -24						; size = 4
tv1240 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
tv1233 = 12						; size = 4
__Val$ = 12						; size = 4
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 866  : 	{	// insert NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 867  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 868  : 
; 869  : 	ios_base::iostate _State = ios_base::goodbit;
; 870  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0002e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0
  00035	66 83 38 00	 cmp	 WORD PTR [eax], 0
  00039	75 04		 jne	 SHORT $LN26@operator
  0003b	33 db		 xor	 ebx, ebx
  0003d	eb 14		 jmp	 SHORT $LN27@operator
$LN26@operator:
  0003f	8b d8		 mov	 ebx, eax
  00041	8d 4b 02	 lea	 ecx, DWORD PTR [ebx+2]
$LL257@operator:
  00044	66 8b 03	 mov	 ax, WORD PTR [ebx]
  00047	83 c3 02	 add	 ebx, 2
  0004a	66 85 c0	 test	 ax, ax
  0004d	75 f5		 jne	 SHORT $LL257@operator
  0004f	2b d9		 sub	 ebx, ecx
  00051	d1 fb		 sar	 ebx, 1
$LN27@operator:

; 871  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  00053	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00056	8b 01		 mov	 eax, DWORD PTR [ecx]
  00058	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005b	8b 7c 08 24	 mov	 edi, DWORD PTR [eax+ecx+36]
  0005f	8b 74 08 20	 mov	 esi, DWORD PTR [eax+ecx+32]
  00063	85 ff		 test	 edi, edi
  00065	7c 17		 jl	 SHORT $LN17@operator
  00067	7f 0e		 jg	 SHORT $LN259@operator
  00069	85 f6		 test	 esi, esi
  0006b	74 11		 je	 SHORT $LN17@operator
  0006d	85 ff		 test	 edi, edi
  0006f	7c 0d		 jl	 SHORT $LN17@operator
  00071	7f 04		 jg	 SHORT $LN259@operator
  00073	3b f3		 cmp	 esi, ebx
  00075	76 07		 jbe	 SHORT $LN17@operator
$LN259@operator:
  00077	2b f3		 sub	 esi, ebx
  00079	83 df 00	 sbb	 edi, 0
  0007c	eb 0e		 jmp	 SHORT $LN18@operator
$LN17@operator:
  0007e	0f 57 c0	 xorps	 xmm0, xmm0
  00081	66 0f 13 45 dc	 movlpd	 QWORD PTR __Pad$[ebp], xmm0
  00086	8b 7d e0	 mov	 edi, DWORD PTR __Pad$[ebp+4]
  00089	8b 75 dc	 mov	 esi, DWORD PTR __Pad$[ebp]
$LN18@operator:

; 872  : 		? 0 : _Ostr.width() - _Count;
; 873  : 	const typename _Myos::sentry _Ok(_Ostr);

  0008c	8b 54 08 38	 mov	 edx, DWORD PTR [eax+ecx+56]
  00090	89 4d dc	 mov	 DWORD PTR __Ok$[ebp], ecx
  00093	85 d2		 test	 edx, edx
  00095	74 0a		 je	 SHORT $LN39@operator
  00097	8b 02		 mov	 eax, DWORD PTR [edx]
  00099	8b ca		 mov	 ecx, edx
  0009b	ff 50 04	 call	 DWORD PTR [eax+4]
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
$LN39@operator:
  000a1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000aa	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ad	83 7c 08 0c 00	 cmp	 DWORD PTR [eax+ecx+12], 0
  000b2	75 16		 jne	 SHORT $LN35@operator
  000b4	8b 44 08 3c	 mov	 eax, DWORD PTR [eax+ecx+60]
  000b8	85 c0		 test	 eax, eax
  000ba	74 0e		 je	 SHORT $LN35@operator
  000bc	3b c1		 cmp	 eax, ecx
  000be	74 0a		 je	 SHORT $LN35@operator
  000c0	8b c8		 mov	 ecx, eax
  000c2	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
  000c7	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
$LN35@operator:
  000ca	8b 01		 mov	 eax, DWORD PTR [ecx]
  000cc	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000cf	83 7c 0a 0c 00	 cmp	 DWORD PTR [edx+ecx+12], 0
  000d4	0f 94 c0	 sete	 al
  000d7	88 45 e0	 mov	 BYTE PTR __Ok$[ebp+4], al
  000da	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 874  : 
; 875  : 	if (!_Ok)

  000e1	84 c0		 test	 al, al
  000e3	75 0a		 jne	 SHORT $LN8@operator

; 876  : 		_State |= ios_base::badbit;

  000e5	b9 04 00 00 00	 mov	 ecx, 4

; 877  : 	else

  000ea	e9 7d 01 00 00	 jmp	 $LN274@operator
$LN8@operator:

; 878  : 		{	// state okay, insert
; 879  : 		_TRY_IO_BEGIN
; 880  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000ef	8b 44 0a 14	 mov	 eax, DWORD PTR [edx+ecx+20]
  000f3	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000f8	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000fc	83 f8 40	 cmp	 eax, 64			; 00000040H
  000ff	0f 84 9d 00 00
	00		 je	 $LN254@operator
$LL4@operator:

; 881  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  00105	85 ff		 test	 edi, edi
  00107	0f 8c 8e 00 00
	00		 jl	 $LN3@operator
  0010d	7f 08		 jg	 SHORT $LN260@operator
  0010f	85 f6		 test	 esi, esi
  00111	0f 84 84 00 00
	00		 je	 $LN3@operator
$LN260@operator:

; 882  : 				if (_Traits::eq_int_type(_Traits::eof(),

  00117	8b 01		 mov	 eax, DWORD PTR [ecx]
  00119	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011c	0f b7 54 08 40	 movzx	 edx, WORD PTR [eax+ecx+64]
  00121	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  00125	89 55 e8	 mov	 DWORD PTR $T6[ebp], edx
  00128	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0012b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0012e	74 21		 je	 SHORT $LN69@operator
  00130	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00133	8b 00		 mov	 eax, DWORD PTR [eax]
  00135	85 c0		 test	 eax, eax
  00137	7e 18		 jle	 SHORT $LN69@operator
  00139	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0013c	48		 dec	 eax
  0013d	89 02		 mov	 DWORD PTR [edx], eax
  0013f	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00142	8b 11		 mov	 edx, DWORD PTR [ecx]
  00144	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00147	89 01		 mov	 DWORD PTR [ecx], eax
  00149	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  0014c	66 89 02	 mov	 WORD PTR [edx], ax
  0014f	eb 06		 jmp	 SHORT $LN275@operator
$LN69@operator:
  00151	8b 01		 mov	 eax, DWORD PTR [ecx]
  00153	52		 push	 edx
  00154	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN275@operator:
  00157	0f b7 c0	 movzx	 eax, ax
  0015a	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0015f	66 3b c8	 cmp	 cx, ax
  00162	75 29		 jne	 SHORT $LN2@operator
$LN261@operator:

; 883  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 884  : 					{	// insertion failed, quit
; 885  : 					_State |= ios_base::badbit;

  00164	b9 04 00 00 00	 mov	 ecx, 4
$LN268@operator:
  00169	8b 5d 08	 mov	 ebx, DWORD PTR __Ostr$[ebp]
$LN6@operator:

; 900  : 					}
; 901  : 		_Ostr.width(0);

  0016c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0016e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00175	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00178	c7 44 18 20 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+32], 0
  00180	c7 44 18 24 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+36], 0
  00188	e9 e2 00 00 00	 jmp	 $LN22@operator
$LN2@operator:

; 881  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  0018d	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00190	83 c6 ff	 add	 esi, -1
  00193	83 d7 ff	 adc	 edi, -1
  00196	e9 6a ff ff ff	 jmp	 $LL4@operator
$LN3@operator:
  0019b	33 c9		 xor	 ecx, ecx

; 886  : 					break;
; 887  : 					}
; 888  : 
; 889  : 		if (_State == ios_base::goodbit
; 890  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

  0019d	75 ca		 jne	 SHORT $LN268@operator
  0019f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
$LN254@operator:
  001a2	8b 01		 mov	 eax, DWORD PTR [ecx]
  001a4	6a 00		 push	 0
  001a6	53		 push	 ebx
  001a7	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  001aa	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001ad	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  001b1	8b 01		 mov	 eax, DWORD PTR [ecx]
  001b3	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  001b6	ff d0		 call	 eax
  001b8	3b c3		 cmp	 eax, ebx
  001ba	75 a8		 jne	 SHORT $LN261@operator
  001bc	85 d2		 test	 edx, edx
  001be	75 a4		 jne	 SHORT $LN261@operator
  001c0	8b 5d 08	 mov	 ebx, DWORD PTR __Ostr$[ebp]
$LL263@operator:

; 891  : 			_State |= ios_base::badbit;
; 892  : 
; 893  : 		if (_State == ios_base::goodbit)
; 894  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  001c3	85 ff		 test	 edi, edi
  001c5	7c 65		 jl	 SHORT $LN266@operator
  001c7	7f 04		 jg	 SHORT $LN262@operator
  001c9	85 f6		 test	 esi, esi
  001cb	74 5f		 je	 SHORT $LN266@operator
$LN262@operator:

; 895  : 				if (_Traits::eq_int_type(_Traits::eof(),

  001cd	8b 03		 mov	 eax, DWORD PTR [ebx]
  001cf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d2	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  001d6	0f b7 54 18 40	 movzx	 edx, WORD PTR [eax+ebx+64]
  001db	89 55 e8	 mov	 DWORD PTR $T5[ebp], edx
  001de	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  001e1	83 38 00	 cmp	 DWORD PTR [eax], 0
  001e4	74 21		 je	 SHORT $LN99@operator
  001e6	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  001e9	8b 00		 mov	 eax, DWORD PTR [eax]
  001eb	85 c0		 test	 eax, eax
  001ed	7e 18		 jle	 SHORT $LN99@operator
  001ef	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  001f2	48		 dec	 eax
  001f3	89 02		 mov	 DWORD PTR [edx], eax
  001f5	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  001f8	8b 11		 mov	 edx, DWORD PTR [ecx]
  001fa	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  001fd	89 01		 mov	 DWORD PTR [ecx], eax
  001ff	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00202	66 89 02	 mov	 WORD PTR [edx], ax
  00205	eb 06		 jmp	 SHORT $LN276@operator
$LN99@operator:
  00207	8b 01		 mov	 eax, DWORD PTR [ecx]
  00209	52		 push	 edx
  0020a	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN276@operator:
  0020d	0f b7 c0	 movzx	 eax, ax
  00210	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00215	66 3b c8	 cmp	 cx, ax
  00218	75 0a		 jne	 SHORT $LN5@operator

; 896  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 897  : 					{	// insertion failed, quit
; 898  : 					_State |= ios_base::badbit;

  0021a	33 c9		 xor	 ecx, ecx
  0021c	83 c9 04	 or	 ecx, 4

; 899  : 					break;

  0021f	e9 48 ff ff ff	 jmp	 $LN6@operator
$LN5@operator:

; 891  : 			_State |= ios_base::badbit;
; 892  : 
; 893  : 		if (_State == ios_base::goodbit)
; 894  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00224	83 c6 ff	 add	 esi, -1
  00227	83 d7 ff	 adc	 edi, -1
  0022a	eb 97		 jmp	 SHORT $LL263@operator
$LN266@operator:
  0022c	33 c9		 xor	 ecx, ecx
  0022e	e9 39 ff ff ff	 jmp	 $LN6@operator
__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$0:

; 902  : 		_CATCH_IO_(_Ostr)

  00233	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00236	8b 01		 mov	 eax, DWORD PTR [ecx]
  00238	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0023b	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  0023f	03 d1		 add	 edx, ecx
  00241	83 c8 04	 or	 eax, 4
  00244	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00248	75 03		 jne	 SHORT $LN128@operator
  0024a	83 c8 04	 or	 eax, 4
$LN128@operator:
  0024d	83 e0 17	 and	 eax, 23			; 00000017H
  00250	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00253	85 42 10	 test	 DWORD PTR [edx+16], eax
  00256	0f 85 0e 01 00
	00		 jne	 $LN131@operator
  0025c	b8 00 00 00 00	 mov	 eax, $LN23@operator
  00261	c3		 ret	 0
$LN23@operator:
  00262	8b 4d e4	 mov	 ecx, DWORD PTR __State$[ebp]
  00265	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN274@operator:
  0026c	8b 5d 08	 mov	 ebx, DWORD PTR __Ostr$[ebp]
$LN22@operator:

; 903  : 		}
; 904  : 
; 905  : 	_Ostr.setstate(_State);

  0026f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00271	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00274	03 d3		 add	 edx, ebx
  00276	85 c9		 test	 ecx, ecx
  00278	0f 84 a8 00 00
	00		 je	 $LN196@operator
  0027e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00281	0b c1		 or	 eax, ecx
  00283	8b c8		 mov	 ecx, eax
  00285	83 c9 04	 or	 ecx, 4
  00288	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0028c	0f 45 c8	 cmovne	 ecx, eax
  0028f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00292	83 e1 17	 and	 ecx, 23			; 00000017H
  00295	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00298	23 c1		 and	 eax, ecx
  0029a	0f 84 86 00 00
	00		 je	 $LN196@operator
  002a0	a8 04		 test	 al, 4
  002a2	74 2a		 je	 SHORT $LN193@operator
  002a4	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  002a9	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  002ae	50		 push	 eax
  002af	6a 01		 push	 1
  002b1	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  002b4	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  002b9	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  002be	8d 45 c8	 lea	 eax, DWORD PTR $T4[ebp]
  002c1	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  002c8	50		 push	 eax
  002c9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN277@operator:
$LN193@operator:
  002ce	a8 02		 test	 al, 2
  002d0	74 2a		 je	 SHORT $LN195@operator
  002d2	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  002d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  002dc	50		 push	 eax
  002dd	6a 01		 push	 1
  002df	8d 4d b4	 lea	 ecx, DWORD PTR $T3[ebp]
  002e2	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  002e7	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  002ec	8d 45 b4	 lea	 eax, DWORD PTR $T3[ebp]
  002ef	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  002f6	50		 push	 eax
  002f7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN278@operator:
$LN195@operator:
  002fc	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00301	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  00306	50		 push	 eax
  00307	6a 01		 push	 1
  00309	8d 4d a0	 lea	 ecx, DWORD PTR $T2[ebp]
  0030c	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00311	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00316	8d 45 a0	 lea	 eax, DWORD PTR $T2[ebp]
  00319	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00320	50		 push	 eax
  00321	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN279@operator:
$LN196@operator:

; 906  : 	return (_Ostr);

  00326	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  0032d	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  00332	8b 75 dc	 mov	 esi, DWORD PTR __Ok$[ebp]
  00335	84 c0		 test	 al, al
  00337	75 07		 jne	 SHORT $LN237@operator
  00339	8b ce		 mov	 ecx, esi
  0033b	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN237@operator:
  00340	8b 06		 mov	 eax, DWORD PTR [esi]
  00342	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  00346	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00349	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  0034d	85 c9		 test	 ecx, ecx
  0034f	74 05		 je	 SHORT $LN241@operator
  00351	8b 11		 mov	 edx, DWORD PTR [ecx]
  00353	ff 52 08	 call	 DWORD PTR [edx+8]
$LN241@operator:
  00356	8b c3		 mov	 eax, ebx

; 907  : 	}

  00358	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0035b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00362	59		 pop	 ecx
  00363	5f		 pop	 edi
  00364	5e		 pop	 esi
  00365	5b		 pop	 ebx
  00366	8b e5		 mov	 esp, ebp
  00368	5d		 pop	 ebp
  00369	c3		 ret	 0

; 902  : 		_CATCH_IO_(_Ostr)

$LN131@operator:
  0036a	6a 00		 push	 0
  0036c	6a 00		 push	 0
  0036e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN280@operator:
$LN271@operator:
  00373	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$3:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$2:
  00008	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$36:
  00010	e8 00 00 00 00	 call	 ___std_terminate
  00015	c3		 ret	 0
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$37:
  00016	e8 00 00 00 00	 call	 ___std_terminate
  0001b	c3		 ret	 0
__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8d 71 68	 lea	 esi, DWORD PTR [ecx+104]
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0002d	56		 push	 esi
  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  0003b	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00040	83 c4 04	 add	 esp, 4
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	5e		 pop	 esi
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8d 71 98	 lea	 esi, DWORD PTR [ecx-104]
  00026	e8 00 00 00 00	 call	 ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0002b	8d 46 68	 lea	 eax, DWORD PTR [esi+104]
  0002e	50		 push	 eax
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00036	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  0003c	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00041	83 c4 04	 add	 esp, 4
  00044	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00048	74 0e		 je	 SHORT $LN13@scalar
  0004a	68 b0 00 00 00	 push	 176			; 000000b0H
  0004f	56		 push	 esi
  00050	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00055	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00058	8b c6		 mov	 eax, esi
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5e		 pop	 esi
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  0002c	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
  00031	8b 7e 34	 mov	 edi, DWORD PTR [esi+52]
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  0003a	85 ff		 test	 edi, edi
  0003c	74 2a		 je	 SHORT $LN13@scalar
  0003e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00048	85 c9		 test	 ecx, ecx
  0004a	74 11		 je	 SHORT $LN19@scalar
  0004c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004e	ff 50 08	 call	 DWORD PTR [eax+8]
  00051	85 c0		 test	 eax, eax
  00053	74 08		 je	 SHORT $LN19@scalar
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b c8		 mov	 ecx, eax
  00059	6a 01		 push	 1
  0005b	ff 12		 call	 DWORD PTR [edx]
$LN19@scalar:
  0005d	6a 08		 push	 8
  0005f	57		 push	 edi
  00060	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00065	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00068	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0006c	74 0b		 je	 SHORT $LN22@scalar
  0006e	6a 44		 push	 68			; 00000044H
  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00076	83 c4 08	 add	 esp, 8
$LN22@scalar:
  00079	8b c6		 mov	 eax, esi
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEHH@Z
_TEXT	SEGMENT
__Mode$ = 8						; size = 4
?_Getstate@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEHH@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getstate, COMDAT
; _this$ = ecx

; 354  : 		{	// convert open mode to stream state bits

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Mode$[ebp]

; 355  : 		_Strstate _State = (_Strstate)0;
; 356  : 		if (!(_Mode & ios_base::in))
; 357  : 			_State |= _Noread;
; 358  : 		if (!(_Mode & ios_base::out))

  00007	8b c3		 mov	 eax, ebx
  00009	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  00010	f7 d1		 not	 ecx
  00012	83 e1 04	 and	 ecx, 4
  00015	8b d1		 mov	 edx, ecx
  00017	83 ca 02	 or	 edx, 2
  0001a	24 02		 and	 al, 2

; 359  : 			_State |= _Constant;
; 360  : 		if (_Mode & ios_base::app)

  0001c	8b c3		 mov	 eax, ebx
  0001e	0f 45 d1	 cmovne	 edx, ecx
  00021	8b ca		 mov	 ecx, edx
  00023	83 c9 08	 or	 ecx, 8
  00026	24 08		 and	 al, 8
  00028	0f 44 ca	 cmove	 ecx, edx
  0002b	8b c1		 mov	 eax, ecx
  0002d	83 c8 10	 or	 eax, 16			; 00000010H

; 361  : 			_State |= _Append;
; 362  : 		if (_Mode & ios_base::ate)

  00030	80 e3 04	 and	 bl, 4
  00033	5b		 pop	 ebx
  00034	0f 44 c1	 cmove	 eax, ecx

; 363  : 			_State |= _Atend;
; 364  : 		return (_State);
; 365  : 		}

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_Getstate@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEHH@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy, COMDAT
; _this$ = ecx

; 337  : 		{	// discard any allocated buffer and clear pointers

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 338  : 		if (_Mystate & _Allocated)

  00003	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  00007	74 33		 je	 SHORT $LN2@Tidy

; 339  : 			_Al.deallocate(_Mysb::eback(),

  00009	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	85 c9		 test	 ecx, ecx
  00010	74 0a		 je	 SHORT $LN4@Tidy
  00012	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00015	8b 00		 mov	 eax, DWORD PTR [eax]
  00017	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  0001a	eb 0d		 jmp	 SHORT $LN5@Tidy
$LN4@Tidy:
  0001c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
$LN5@Tidy:
  00029	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	2b c8		 sub	 ecx, eax
  00030	d1 f9		 sar	 ecx, 1
  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  00037	e8 00 00 00 00	 call	 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate
$LN2@Tidy:

; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);

  0003c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00045	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00048	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0004e	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 343  : 		_Mysb::setp(0, 0);

  00057	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0005a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00060	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00063	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00069	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0006c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;

  00072	83 66 3c fe	 and	 DWORD PTR [esi+60], -2	; fffffffeH
  00076	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  0007d	5e		 pop	 esi

; 346  : 		}

  0007e	c3		 ret	 0
?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXPB_WIH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
tv270 = 16						; size = 4
__State$ = 16						; size = 4
?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXPB_WIH@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Init, COMDAT
; _this$ = ecx

; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 311  : 		_Seekhigh = 0;
; 312  : 		_Mystate = _State;

  00003	8b 45 10	 mov	 eax, DWORD PTR __State$[ebp]
  00006	53		 push	 ebx

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00014	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00017	85 db		 test	 ebx, ebx
  00019	0f 84 8e 00 00
	00		 je	 $LN2@Init
  0001f	83 e0 06	 and	 eax, 6
  00022	3c 06		 cmp	 al, 6
  00024	0f 84 83 00 00
	00		 je	 $LN2@Init

; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Al.allocate(_Count);

  0002a	57		 push	 edi
  0002b	53		 push	 ebx
  0002c	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  0002f	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  00034	8b f8		 mov	 edi, eax

; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);

  00036	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  00039	50		 push	 eax
  0003a	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0003d	57		 push	 edi
  0003e	e8 00 00 00 00	 call	 _memcpy

; 319  : 			_Seekhigh = _Pnew + _Count;

  00043	8d 14 1b	 lea	 edx, DWORD PTR [ebx+ebx]
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 320  : 
; 321  : 			if (!(_Mystate & _Noread))

  00049	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  0004d	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  00050	89 45 10	 mov	 DWORD PTR tv270[ebp], eax
  00053	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00056	75 0f		 jne	 SHORT $LN3@Init

; 322  : 				_Mysb::setg(_Pnew, _Pnew,

  00058	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0005b	89 38		 mov	 DWORD PTR [eax], edi
  0005d	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00060	89 38		 mov	 DWORD PTR [eax], edi
  00062	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00065	89 18		 mov	 DWORD PTR [eax], ebx
$LN3@Init:

; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))

  00067	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0006a	a8 02		 test	 al, 2
  0006c	75 3a		 jne	 SHORT $LN5@Init

; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,

  0006e	a8 18		 test	 al, 24			; 00000018H
  00070	8b cf		 mov	 ecx, edi
  00072	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00075	0f 45 4d 10	 cmovne	 ecx, DWORD PTR tv270[ebp]
  00079	2b d1		 sub	 edx, ecx
  0007b	03 d7		 add	 edx, edi
  0007d	89 38		 mov	 DWORD PTR [eax], edi
  0007f	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00082	d1 fa		 sar	 edx, 1
  00084	89 08		 mov	 DWORD PTR [eax], ecx
  00086	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00089	89 10		 mov	 DWORD PTR [eax], edx

; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)

  0008b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0008e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00091	75 15		 jne	 SHORT $LN5@Init

; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);

  00093	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00096	89 38		 mov	 DWORD PTR [eax], edi
  00098	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0009b	d1 ff		 sar	 edi, 1
  0009d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000a3	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000a6	89 38		 mov	 DWORD PTR [eax], edi
$LN5@Init:

; 331  : 				}
; 332  : 			_Mystate |= _Allocated;

  000a8	83 4e 3c 01	 or	 DWORD PTR [esi+60], 1
  000ac	5f		 pop	 edi
$LN2@Init:
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx

; 333  : 			}
; 334  : 		}

  000af	5d		 pop	 ebp
  000b0	c2 0c 00	 ret	 12			; 0000000cH
?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXPB_WIH@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
__Off$1$ = -4						; size = 4
tv286 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Ptr$ = 12						; size = 24
__Off$1$ = 36						; size = 4
tv324 = 36						; size = 4
tv297 = 36						; size = 4
__Mode$ = 36						; size = 4
?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekpos, COMDAT
; _this$ = ecx

; 276  : 		{	// change position to _Pos, according to _Mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 277  : 		streamoff _Off = (streamoff)_Ptr;

  00005	8b 5d 18	 mov	 ebx, DWORD PTR __Ptr$[ebp+12]
  00008	56		 push	 esi
  00009	8b 75 14	 mov	 esi, DWORD PTR __Ptr$[ebp+8]
  0000c	03 75 0c	 add	 esi, DWORD PTR __Ptr$[ebp]
  0000f	57		 push	 edi
  00010	13 5d 10	 adc	 ebx, DWORD PTR __Ptr$[ebp+4]
  00013	8b f9		 mov	 edi, ecx

; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  00015	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	85 c0		 test	 eax, eax
  0001c	74 08		 je	 SHORT $LN2@seekpos
  0001e	39 47 38	 cmp	 DWORD PTR [edi+56], eax
  00021	73 03		 jae	 SHORT $LN2@seekpos

; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  00023	89 47 38	 mov	 DWORD PTR [edi+56], eax
$LN2@seekpos:

; 280  : 
; 281  : 		if (_Off == _BADOFF)

  00026	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB+4
  0002b	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  00031	75 08		 jne	 SHORT $LN55@seekpos
  00033	3b d8		 cmp	 ebx, eax
  00035	0f 84 e1 00 00
	00		 je	 $LN11@seekpos
$LN55@seekpos:

; 282  : 			;
; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

  0003b	8b 4d 24	 mov	 ecx, DWORD PTR __Mode$[ebp]
  0003e	f6 c1 01	 test	 cl, 1
  00041	0f 84 83 00 00
	00		 je	 $LN5@seekpos
  00047	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]
  0004c	89 45 fc	 mov	 DWORD PTR tv286[ebp], eax
  0004f	85 c0		 test	 eax, eax
  00051	74 72		 je	 SHORT $LN60@seekpos

; 284  : 			{	// position within read buffer
; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00053	85 db		 test	 ebx, ebx
  00055	7c 66		 jl	 SHORT $LN7@seekpos
  00057	7f 04		 jg	 SHORT $LN56@seekpos
  00059	85 f6		 test	 esi, esi
  0005b	72 60		 jb	 SHORT $LN7@seekpos
$LN56@seekpos:
  0005d	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00065	2b c1		 sub	 eax, ecx
  00067	d1 f8		 sar	 eax, 1
  00069	99		 cdq
  0006a	3b da		 cmp	 ebx, edx
  0006c	7f 4f		 jg	 SHORT $LN7@seekpos
  0006e	7c 04		 jl	 SHORT $LN57@seekpos
  00070	3b f0		 cmp	 esi, eax
  00072	77 49		 ja	 SHORT $LN7@seekpos
$LN57@seekpos:

; 286  : 				{	// change read position
; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  00074	2b 4d fc	 sub	 ecx, DWORD PTR tv286[ebp]
  00077	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0007a	d1 f9		 sar	 ecx, 1
  0007c	03 ce		 add	 ecx, esi
  0007e	89 4d fc	 mov	 DWORD PTR __Off$1$[ebp], ecx
  00081	29 08		 sub	 DWORD PTR [eax], ecx
  00083	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00086	8b 45 fc	 mov	 eax, DWORD PTR __Off$1$[ebp]
  00089	03 c0		 add	 eax, eax
  0008b	01 01		 add	 DWORD PTR [ecx], eax

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  0008d	f6 45 24 02	 test	 BYTE PTR __Mode$[ebp], 2
  00091	0f 84 85 00 00
	00		 je	 $LN11@seekpos
  00097	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	85 c9		 test	 ecx, ecx
  0009e	74 7c		 je	 SHORT $LN11@seekpos

; 289  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),

  000a0	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  000a3	8b 10		 mov	 edx, DWORD PTR [eax]
  000a5	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000a8	8b 00		 mov	 eax, DWORD PTR [eax]
  000aa	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  000ad	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  000b0	2b ca		 sub	 ecx, edx
  000b2	d1 f9		 sar	 ecx, 1
  000b4	89 10		 mov	 DWORD PTR [eax], edx
  000b6	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000b9	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 						_Mysb::epptr());	// change write position to match
; 291  : 				}
; 292  : 			else

  000bb	eb 5f		 jmp	 SHORT $LN11@seekpos
$LN7@seekpos:

; 293  : 				_Off = _BADOFF;

  000bd	8b 1d 04 00 00
	00		 mov	 ebx, DWORD PTR ?_BADOFF@std@@3_JB+4
  000c3	eb 51		 jmp	 SHORT $LN61@seekpos
$LN60@seekpos:
  000c5	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB+4
$LN5@seekpos:

; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  000ca	f6 c1 02	 test	 cl, 2
  000cd	74 45		 je	 SHORT $LN10@seekpos
  000cf	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000d1	89 4d 24	 mov	 DWORD PTR tv297[ebp], ecx
  000d4	85 c9		 test	 ecx, ecx
  000d6	74 3c		 je	 SHORT $LN10@seekpos

; 296  : 			{	// position within write buffer
; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  000d8	85 db		 test	 ebx, ebx
  000da	7c e1		 jl	 SHORT $LN7@seekpos
  000dc	7f 04		 jg	 SHORT $LN58@seekpos
  000de	85 f6		 test	 esi, esi
  000e0	72 db		 jb	 SHORT $LN7@seekpos
$LN58@seekpos:
  000e2	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e7	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  000ea	2b c1		 sub	 eax, ecx
  000ec	d1 f8		 sar	 eax, 1
  000ee	99		 cdq
  000ef	3b da		 cmp	 ebx, edx
  000f1	7f ca		 jg	 SHORT $LN7@seekpos
  000f3	7c 04		 jl	 SHORT $LN59@seekpos
  000f5	3b f0		 cmp	 esi, eax
  000f7	77 c4		 ja	 SHORT $LN7@seekpos
$LN59@seekpos:

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

  000f9	2b 4d 24	 sub	 ecx, DWORD PTR tv297[ebp]
  000fc	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000ff	d1 f9		 sar	 ecx, 1
  00101	03 ce		 add	 ecx, esi
  00103	89 4d 24	 mov	 DWORD PTR __Off$1$[ebp], ecx
  00106	29 08		 sub	 DWORD PTR [eax], ecx
  00108	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  0010b	8b 45 24	 mov	 eax, DWORD PTR __Off$1$[ebp]
  0010e	03 c0		 add	 eax, eax
  00110	01 01		 add	 DWORD PTR [ecx], eax

; 299  : 					- _Mysb::pptr() + _Off));	// change write position
; 300  : 			else

  00112	eb 08		 jmp	 SHORT $LN11@seekpos
$LN10@seekpos:

; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  00114	8b d8		 mov	 ebx, eax
$LN61@seekpos:
  00116	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
$LN11@seekpos:

; 305  : 		return (streampos(_Off));

  0011c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0011f	0f 57 c0	 xorps	 xmm0, xmm0
  00122	5f		 pop	 edi
  00123	89 30		 mov	 DWORD PTR [eax], esi
  00125	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00128	5e		 pop	 esi
  00129	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00130	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00137	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  0013c	5b		 pop	 ebx

; 306  : 		}

  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
tv281 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Off$1$ = 20						; size = 4
__Way$ = 20						; size = 4
__Off$1$ = 24						; size = 4
tv292 = 24						; size = 4
tv287 = 24						; size = 4
__Which$ = 24						; size = 4
?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekoff, COMDAT
; _this$ = ecx

; 227  : 		{	// change position by _Off, according to _Way, _Mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  00009	8b 53 20	 mov	 edx, DWORD PTR [ebx+32]
  0000c	8b 02		 mov	 eax, DWORD PTR [edx]
  0000e	85 c0		 test	 eax, eax
  00010	74 08		 je	 SHORT $LN2@seekoff
  00012	39 43 38	 cmp	 DWORD PTR [ebx+56], eax
  00015	73 03		 jae	 SHORT $LN2@seekoff

; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  00017	89 43 38	 mov	 DWORD PTR [ebx+56], eax
$LN2@seekoff:

; 230  : 
; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

  0001a	8b 4d 18	 mov	 ecx, DWORD PTR __Which$[ebp]
  0001d	f6 c1 01	 test	 cl, 1
  00020	0f 84 e8 00 00
	00		 je	 $LN3@seekoff
  00026	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00029	8b 30		 mov	 esi, DWORD PTR [eax]
  0002b	89 75 fc	 mov	 DWORD PTR tv281[ebp], esi
  0002e	85 f6		 test	 esi, esi
  00030	0f 84 d8 00 00
	00		 je	 $LN3@seekoff

; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)

  00036	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  00039	83 f8 02	 cmp	 eax, 2
  0003c	75 17		 jne	 SHORT $LN5@seekoff

; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  0003e	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00041	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00044	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00047	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0004a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0004c	d1 f8		 sar	 eax, 1
  0004e	99		 cdq
  0004f	03 f0		 add	 esi, eax
  00051	13 fa		 adc	 edi, edx

; 235  : 			else if (_Way == ios_base::cur

  00053	eb 38		 jmp	 SHORT $LN9@seekoff
$LN5@seekoff:

; 236  : 				&& (_Which & ios_base::out) == 0)

  00055	83 f8 01	 cmp	 eax, 1
  00058	75 1b		 jne	 SHORT $LN7@seekoff
  0005a	f6 c1 02	 test	 cl, 2
  0005d	75 1a		 jne	 SHORT $LN74@seekoff

; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());

  0005f	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00062	8b c6		 mov	 eax, esi
  00064	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00067	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0006a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006c	d1 f8		 sar	 eax, 1
  0006e	99		 cdq
  0006f	03 f0		 add	 esi, eax
  00071	13 fa		 adc	 edi, edx
  00073	eb 18		 jmp	 SHORT $LN9@seekoff
$LN7@seekoff:

; 238  : 			else if (_Way != ios_base::beg)

  00075	85 c0		 test	 eax, eax
  00077	74 0e		 je	 SHORT $LN79@seekoff
$LN74@seekoff:

; 239  : 				_Off = _BADOFF;

  00079	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  0007f	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_BADOFF@std@@3_JB+4
  00085	eb 06		 jmp	 SHORT $LN9@seekoff
$LN79@seekoff:
  00087	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0008a	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
$LN9@seekoff:

; 240  : 
; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0008d	85 ff		 test	 edi, edi
  0008f	0f 8c 29 01 00
	00		 jl	 $LN10@seekoff
  00095	7f 08		 jg	 SHORT $LN75@seekoff
  00097	85 f6		 test	 esi, esi
  00099	0f 82 1f 01 00
	00		 jb	 $LN10@seekoff
$LN75@seekoff:
  0009f	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a4	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  000a7	2b c1		 sub	 eax, ecx
  000a9	d1 f8		 sar	 eax, 1
  000ab	99		 cdq
  000ac	3b fa		 cmp	 edi, edx
  000ae	0f 8f 0a 01 00
	00		 jg	 $LN10@seekoff
  000b4	7c 08		 jl	 SHORT $LN76@seekoff
  000b6	3b f0		 cmp	 esi, eax
  000b8	0f 87 00 01 00
	00		 ja	 $LN10@seekoff
$LN76@seekoff:

; 242  : 				{	// change read position
; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  000be	2b 4d fc	 sub	 ecx, DWORD PTR tv281[ebp]
  000c1	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  000c4	d1 f9		 sar	 ecx, 1
  000c6	03 ce		 add	 ecx, esi
  000c8	89 4d 14	 mov	 DWORD PTR __Off$1$[ebp], ecx
  000cb	29 08		 sub	 DWORD PTR [eax], ecx
  000cd	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  000d0	8b 45 14	 mov	 eax, DWORD PTR __Off$1$[ebp]
  000d3	03 c0		 add	 eax, eax
  000d5	01 01		 add	 DWORD PTR [ecx], eax

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000d7	f6 45 18 02	 test	 BYTE PTR __Which$[ebp], 2
  000db	0f 84 e9 00 00
	00		 je	 $LN22@seekoff
  000e1	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  000e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e6	85 c9		 test	 ecx, ecx
  000e8	0f 84 dc 00 00
	00		 je	 $LN22@seekoff

; 245  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),

  000ee	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  000f1	8b 10		 mov	 edx, DWORD PTR [eax]
  000f3	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  000f6	8b 00		 mov	 eax, DWORD PTR [eax]
  000f8	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  000fb	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  000fe	2b ca		 sub	 ecx, edx
  00100	d1 f9		 sar	 ecx, 1
  00102	89 10		 mov	 DWORD PTR [eax], edx
  00104	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  00107	89 08		 mov	 DWORD PTR [eax], ecx

; 246  : 						_Mysb::epptr());	// change write position to match
; 247  : 				}
; 248  : 			else

  00109	e9 bc 00 00 00	 jmp	 $LN22@seekoff
$LN3@seekoff:

; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)

  0010e	f6 c1 02	 test	 cl, 2
  00111	0f 84 9b 00 00
	00		 je	 $LN13@seekoff
  00117	8b 12		 mov	 edx, DWORD PTR [edx]
  00119	89 55 18	 mov	 DWORD PTR tv287[ebp], edx
  0011c	85 d2		 test	 edx, edx
  0011e	0f 84 8e 00 00
	00		 je	 $LN13@seekoff

; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)

  00124	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  00127	83 f8 02	 cmp	 eax, 2
  0012a	75 17		 jne	 SHORT $LN15@seekoff

; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  0012c	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0012f	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00132	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00135	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00138	2b 01		 sub	 eax, DWORD PTR [ecx]
  0013a	d1 f8		 sar	 eax, 1
  0013c	99		 cdq
  0013d	03 f0		 add	 esi, eax
  0013f	13 fa		 adc	 edi, edx
  00141	eb 33		 jmp	 SHORT $LN19@seekoff
$LN15@seekoff:

; 255  : 			else if (_Way == ios_base::cur)

  00143	83 f8 01	 cmp	 eax, 1
  00146	75 16		 jne	 SHORT $LN17@seekoff

; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());

  00148	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0014b	8b c2		 mov	 eax, edx
  0014d	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00150	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00153	2b 01		 sub	 eax, DWORD PTR [ecx]
  00155	d1 f8		 sar	 eax, 1
  00157	99		 cdq
  00158	03 f0		 add	 esi, eax
  0015a	13 fa		 adc	 edi, edx
  0015c	eb 18		 jmp	 SHORT $LN19@seekoff
$LN17@seekoff:

; 257  : 			else if (_Way != ios_base::beg)

  0015e	85 c0		 test	 eax, eax
  00160	74 0e		 je	 SHORT $LN80@seekoff

; 258  : 				_Off = _BADOFF;

  00162	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  00168	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_BADOFF@std@@3_JB+4
  0016e	eb 06		 jmp	 SHORT $LN19@seekoff
$LN80@seekoff:
  00170	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00173	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
$LN19@seekoff:

; 259  : 
; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00176	85 ff		 test	 edi, edi
  00178	7c 44		 jl	 SHORT $LN10@seekoff
  0017a	7f 04		 jg	 SHORT $LN77@seekoff
  0017c	85 f6		 test	 esi, esi
  0017e	72 3e		 jb	 SHORT $LN10@seekoff
$LN77@seekoff:
  00180	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00183	8b 08		 mov	 ecx, DWORD PTR [eax]
  00185	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00188	2b c1		 sub	 eax, ecx
  0018a	d1 f8		 sar	 eax, 1
  0018c	99		 cdq
  0018d	3b fa		 cmp	 edi, edx
  0018f	7f 2d		 jg	 SHORT $LN10@seekoff
  00191	7c 04		 jl	 SHORT $LN78@seekoff
  00193	3b f0		 cmp	 esi, eax
  00195	77 27		 ja	 SHORT $LN10@seekoff
$LN78@seekoff:

; 261  : 				_Mysb::pbump((int)(_Mysb::eback()

  00197	2b 4d 18	 sub	 ecx, DWORD PTR tv287[ebp]
  0019a	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  0019d	d1 f9		 sar	 ecx, 1
  0019f	03 ce		 add	 ecx, esi
  001a1	89 4d 18	 mov	 DWORD PTR __Off$1$[ebp], ecx
  001a4	29 08		 sub	 DWORD PTR [eax], ecx
  001a6	8b 4b 20	 mov	 ecx, DWORD PTR [ebx+32]
  001a9	8b 45 18	 mov	 eax, DWORD PTR __Off$1$[ebp]
  001ac	03 c0		 add	 eax, eax
  001ae	01 01		 add	 DWORD PTR [ecx], eax

; 262  : 					- _Mysb::pptr() + _Off));	// change write position
; 263  : 			else

  001b0	eb 18		 jmp	 SHORT $LN22@seekoff
$LN13@seekoff:

; 264  : 				_Off = _BADOFF;
; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)

  001b2	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  001b5	8b c6		 mov	 eax, esi
  001b7	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  001ba	0b c7		 or	 eax, edi
  001bc	74 0c		 je	 SHORT $LN22@seekoff
$LN10@seekoff:

; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  001be	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  001c4	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_BADOFF@std@@3_JB+4
$LN22@seekoff:

; 271  : 		return (pos_type(_Off));

  001ca	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001cd	0f 57 c0	 xorps	 xmm0, xmm0
  001d0	89 78 04	 mov	 DWORD PTR [eax+4], edi
  001d3	5f		 pop	 edi
  001d4	89 30		 mov	 DWORD PTR [eax], esi
  001d6	5e		 pop	 esi
  001d7	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  001de	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  001e5	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  001ea	5b		 pop	 ebx

; 272  : 		}

  001eb	8b e5		 mov	 esp, ebp
  001ed	5d		 pop	 ebp
  001ee	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGXZ
_TEXT	SEGMENT
?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGXZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::underflow, COMDAT
; _this$ = ecx

; 207  : 		{	// get an element from stream, but don't point past it

  00000	8b d1		 mov	 edx, ecx
  00002	56		 push	 esi
  00003	57		 push	 edi

; 208  : 		if (_Mysb::gptr() == 0)

  00004	8b 7a 1c	 mov	 edi, DWORD PTR [edx+28]
  00007	8b 37		 mov	 esi, DWORD PTR [edi]
  00009	85 f6		 test	 esi, esi
  0000b	75 08		 jne	 SHORT $LN2@underflow

; 209  : 			return (_Traits::eof());	// no character buffer, fail

  0000d	5f		 pop	 edi
  0000e	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00013	5e		 pop	 esi

; 221  : 			}
; 222  : 		}

  00014	c3		 ret	 0
$LN2@underflow:
  00015	53		 push	 ebx

; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())

  00016	8b 5a 2c	 mov	 ebx, DWORD PTR [edx+44]
  00019	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0001b	8d 0c 4e	 lea	 ecx, DWORD PTR [esi+ecx*2]
  0001e	3b f1		 cmp	 esi, ecx
  00020	73 07		 jae	 SHORT $LN4@underflow

; 211  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered

  00022	66 8b 06	 mov	 ax, WORD PTR [esi]
  00025	5b		 pop	 ebx
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 221  : 			}
; 222  : 		}

  00028	c3		 ret	 0
$LN4@underflow:

; 212  : 		else if (_Mystate & _Noread || _Mysb::pptr() == 0
; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

  00029	f6 42 3c 04	 test	 BYTE PTR [edx+60], 4
  0002d	75 2f		 jne	 SHORT $LN8@underflow
  0002f	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	85 c0		 test	 eax, eax
  00036	74 26		 je	 SHORT $LN8@underflow
  00038	3b c6		 cmp	 eax, esi
  0003a	77 05		 ja	 SHORT $LN6@underflow
  0003c	39 72 38	 cmp	 DWORD PTR [edx+56], esi
  0003f	76 1d		 jbe	 SHORT $LN8@underflow
$LN6@underflow:

; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())

  00041	39 42 38	 cmp	 DWORD PTR [edx+56], eax
  00044	73 03		 jae	 SHORT $LN9@underflow

; 218  : 				_Seekhigh = _Mysb::pptr();

  00046	89 42 38	 mov	 DWORD PTR [edx+56], eax
$LN9@underflow:

; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);

  00049	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0004c	2b 07		 sub	 eax, DWORD PTR [edi]
  0004e	d1 f8		 sar	 eax, 1
  00050	89 03		 mov	 DWORD PTR [ebx], eax

; 220  : 			return (_Traits::to_int_type(*_Mysb::gptr()));

  00052	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00055	5b		 pop	 ebx
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	66 8b 00	 mov	 ax, WORD PTR [eax]

; 221  : 			}
; 222  : 		}

  0005d	c3		 ret	 0
$LN8@underflow:
  0005e	5b		 pop	 ebx
  0005f	5f		 pop	 edi

; 214  : 			return (_Traits::eof());	// can't read, fail

  00060	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00065	5e		 pop	 esi

; 221  : 			}
; 222  : 		}

  00066	c3		 ret	 0
?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGXZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 2
?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::pbackfail, COMDAT
; _this$ = ecx

; 190  : 		{	// put an element back to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 191  : 		if (_Mysb::gptr() == 0
; 192  : 			|| _Mysb::gptr() <= _Mysb::eback()
; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  00003	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	bf ff ff 00 00	 mov	 edi, 65535		; 0000ffffH
  0000d	8b 30		 mov	 esi, DWORD PTR [eax]
  0000f	85 f6		 test	 esi, esi
  00011	74 45		 je	 SHORT $LN4@pbackfail
  00013	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00016	3b 30		 cmp	 esi, DWORD PTR [eax]
  00018	76 3e		 jbe	 SHORT $LN4@pbackfail
  0001a	66 8b 55 08	 mov	 dx, WORD PTR __Meta$[ebp]
  0001e	66 3b fa	 cmp	 di, dx
  00021	74 0c		 je	 SHORT $LN2@pbackfail
  00023	66 3b 56 fe	 cmp	 dx, WORD PTR [esi-2]
  00027	74 06		 je	 SHORT $LN2@pbackfail
  00029	f6 41 3c 02	 test	 BYTE PTR [ecx+60], 2
  0002d	75 29		 jne	 SHORT $LN4@pbackfail
$LN2@pbackfail:

; 197  : 		else
; 198  : 			{	// back up one position and store put-back character
; 199  : 			_Mysb::gbump(-1);

  0002f	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00032	ff 00		 inc	 DWORD PTR [eax]
  00034	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00037	83 00 fe	 add	 DWORD PTR [eax], -2	; fffffffeH

; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))

  0003a	66 3b fa	 cmp	 di, dx
  0003d	74 08		 je	 SHORT $LN45@pbackfail

; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);

  0003f	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00042	8b 00		 mov	 eax, DWORD PTR [eax]
  00044	66 89 10	 mov	 WORD PTR [eax], dx

; 202  : 			return (_Traits::not_eof(_Meta));

$LN45@pbackfail:
  00047	33 c9		 xor	 ecx, ecx
  00049	0f b7 c2	 movzx	 eax, dx
  0004c	66 3b d7	 cmp	 dx, di
  0004f	5f		 pop	 edi
  00050	0f 44 c1	 cmove	 eax, ecx
  00053	5e		 pop	 esi

; 203  : 			}
; 204  : 		}

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN4@pbackfail:

; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail

  00058	66 8b c7	 mov	 ax, di
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi

; 203  : 			}
; 204  : 		}

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z
_TEXT	SEGMENT
__Newsize$1$ = -8					; size = 4
__Oldptr$1$ = -4					; size = 4
__Meta$ = 8						; size = 2
?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::overflow, COMDAT
; _this$ = ecx

; 120  : 		{	// put an element to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 121  : 		if (_Mystate & _Constant)

  00009	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0000c	a8 02		 test	 al, 2
  0000e	74 0c		 je	 SHORT $LN4@overflow

; 122  : 			return (_Traits::eof());	// array nonmutable, fail

  00010	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00015	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN4@overflow:
  0001c	53		 push	 ebx

; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  0001d	66 8b 5d 08	 mov	 bx, WORD PTR __Meta$[ebp]
  00021	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00026	66 3b cb	 cmp	 cx, bx
  00029	75 0a		 jne	 SHORT $LN6@overflow

; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  0002b	5b		 pop	 ebx
  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN6@overflow:
  00035	57		 push	 edi

; 125  : 
; 126  : 		if (_Mystate & _Append
; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

  00036	a8 08		 test	 al, 8
  00038	74 23		 je	 SHORT $LN7@overflow
  0003a	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  0003d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0003f	85 c9		 test	 ecx, ecx
  00041	74 1a		 je	 SHORT $LN7@overflow
  00043	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  00046	3b ca		 cmp	 ecx, edx
  00048	73 13		 jae	 SHORT $LN7@overflow

; 128  : 			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());

  0004a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0004d	8b 00		 mov	 eax, DWORD PTR [eax]
  0004f	89 17		 mov	 DWORD PTR [edi], edx
  00051	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  00054	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00057	2b ca		 sub	 ecx, edx
  00059	d1 f9		 sar	 ecx, 1
  0005b	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@overflow:

; 129  : 
; 130  : 		if (_Mysb::pptr() != 0
; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

  0005d	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	85 c9		 test	 ecx, ecx
  00064	74 2e		 je	 SHORT $LN121@overflow
  00066	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00069	8b 3a		 mov	 edi, DWORD PTR [edx]
  0006b	8d 04 79	 lea	 eax, DWORD PTR [ecx+edi*2]
  0006e	3b c8		 cmp	 ecx, eax
  00070	73 1e		 jae	 SHORT $LN8@overflow

; 132  : 			{	// room in buffer, store it
; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  00072	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]

; 134  : 			return (_Meta);

  00075	66 8b c3	 mov	 ax, bx
  00078	89 0a		 mov	 DWORD PTR [edx], ecx
  0007a	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  0007d	5f		 pop	 edi
  0007e	8b 32		 mov	 esi, DWORD PTR [edx]
  00080	8d 4e 02	 lea	 ecx, DWORD PTR [esi+2]
  00083	89 0a		 mov	 DWORD PTR [edx], ecx
  00085	66 89 1e	 mov	 WORD PTR [esi], bx
  00088	5b		 pop	 ebx
  00089	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
$LN8@overflow:

; 135  : 			}
; 136  : 		else
; 137  : 			{	// grow buffer and store element
; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

  00090	85 c9		 test	 ecx, ecx
  00092	75 04		 jne	 SHORT $LN20@overflow
$LN121@overflow:
  00094	33 ff		 xor	 edi, edi
  00096	eb 10		 jmp	 SHORT $LN21@overflow
$LN20@overflow:
  00098	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0009b	8b 38		 mov	 edi, DWORD PTR [eax]
  0009d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000a0	03 ff		 add	 edi, edi
  000a2	2b 38		 sub	 edi, DWORD PTR [eax]
  000a4	03 f9		 add	 edi, ecx
  000a6	d1 ff		 sar	 edi, 1
$LN21@overflow:

; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE

  000a8	8b cf		 mov	 ecx, edi
  000aa	d1 e9		 shr	 ecx, 1
  000ac	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000af	73 07		 jae	 SHORT $LN22@overflow
  000b1	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000b6	eb 08		 jmp	 SHORT $LL2@overflow
$LN22@overflow:

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  000b8	85 c9		 test	 ecx, ecx
  000ba	74 17		 je	 SHORT $LN123@overflow
  000bc	0f 1f 40 00	 npad	 4
$LL2@overflow:
  000c0	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000c5	2b c1		 sub	 eax, ecx
  000c7	3b c7		 cmp	 eax, edi
  000c9	73 04		 jae	 SHORT $LN116@overflow

; 145  : 				_Inc /= 2;	// increment causes overflow, halve it

  000cb	d1 e9		 shr	 ecx, 1

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  000cd	75 f1		 jne	 SHORT $LL2@overflow
$LN116@overflow:

; 146  : 			if (_Inc == 0)

  000cf	85 c9		 test	 ecx, ecx
  000d1	75 0e		 jne	 SHORT $LN10@overflow
$LN123@overflow:
  000d3	5f		 pop	 edi
  000d4	5b		 pop	 ebx

; 147  : 				return (_Traits::eof());	// buffer can't grow, fail

  000d5	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  000da	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c2 04 00	 ret	 4
$LN10@overflow:

; 148  : 
; 149  : 			_Newsize += _Inc;

  000e1	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]

; 150  : 
; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);

  000e4	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  000e7	89 45 f8	 mov	 DWORD PTR __Newsize$1$[ebp], eax
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate

; 152  : 			_Elem *_Oldptr = _Mysb::eback();

  000f0	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  000f3	8b d8		 mov	 ebx, eax
  000f5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f7	89 55 fc	 mov	 DWORD PTR __Oldptr$1$[ebp], edx

; 153  : 
; 154  : 			if (0 < _Oldsize)

  000fa	85 ff		 test	 edi, edi
  000fc	74 15		 je	 SHORT $LN125@overflow

; 155  : 				_Traits::copy(_Newptr, _Oldptr, _Oldsize);

  000fe	8d 0c 3f	 lea	 ecx, DWORD PTR [edi+edi]
  00101	51		 push	 ecx
  00102	52		 push	 edx
  00103	53		 push	 ebx
  00104	e8 00 00 00 00	 call	 _memcpy
  00109	8b 55 fc	 mov	 edx, DWORD PTR __Oldptr$1$[ebp]
  0010c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 156  : 
; 157  : 			if (_Oldsize == 0)

  0010f	85 ff		 test	 edi, edi
  00111	75 45		 jne	 SHORT $LN12@overflow
$LN125@overflow:

; 158  : 				{	// first growth, set up pointers
; 159  : 				_Seekhigh = _Newptr;
; 160  : 				_Mysb::setp(_Newptr, _Newptr + _Newsize);

  00113	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00116	8b 4d f8	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]
  00119	89 5e 38	 mov	 DWORD PTR [esi+56], ebx
  0011c	89 18		 mov	 DWORD PTR [eax], ebx
  0011e	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00121	89 18		 mov	 DWORD PTR [eax], ebx
  00123	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00126	89 08		 mov	 DWORD PTR [eax], ecx

; 161  : 				if (_Mystate & _Noread)
; 162  : 					_Mysb::setg(_Newptr, 0, _Newptr);

  00128	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0012b	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  0012f	89 18		 mov	 DWORD PTR [eax], ebx
  00131	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00134	74 12		 je	 SHORT $LN14@overflow
  00136	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0013c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0013f	d1 fb		 sar	 ebx, 1
  00141	89 18		 mov	 DWORD PTR [eax], ebx

; 163  : 				else

  00143	e9 92 00 00 00	 jmp	 $LN17@overflow
$LN14@overflow:

; 164  : 					_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);

  00148	89 18		 mov	 DWORD PTR [eax], ebx
  0014a	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0014d	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 165  : 				}
; 166  : 			else

  00153	e9 82 00 00 00	 jmp	 $LN17@overflow
$LN12@overflow:

; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);

  00158	8b 46 38	 mov	 eax, DWORD PTR [esi+56]

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

  0015b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0015e	2b c2		 sub	 eax, edx
  00160	d1 f8		 sar	 eax, 1
  00162	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  00165	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00168	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0016b	8b 00		 mov	 eax, DWORD PTR [eax]
  0016d	2b c2		 sub	 eax, edx
  0016f	d1 f8		 sar	 eax, 1
  00171	8d 14 43	 lea	 edx, DWORD PTR [ebx+eax*2]
  00174	8b 01		 mov	 eax, DWORD PTR [ecx]
  00176	2b 45 fc	 sub	 eax, DWORD PTR __Oldptr$1$[ebp]
  00179	d1 f8		 sar	 eax, 1
  0017b	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  0017e	89 01		 mov	 DWORD PTR [ecx], eax
  00180	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00183	8b 4d f8	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]
  00186	03 c9		 add	 ecx, ecx
  00188	2b ca		 sub	 ecx, edx
  0018a	89 10		 mov	 DWORD PTR [eax], edx
  0018c	03 cb		 add	 ecx, ebx
  0018e	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00191	d1 f9		 sar	 ecx, 1
  00193	89 08		 mov	 DWORD PTR [eax], ecx

; 170  : 					_Newptr + (_Mysb::pptr() - _Oldptr),
; 171  : 					_Newptr + _Newsize);
; 172  : 				if (_Mystate & _Noread)

  00195	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  00199	74 17		 je	 SHORT $LN16@overflow

; 173  : 					_Mysb::setg(_Newptr, 0, _Newptr);

  0019b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0019e	89 18		 mov	 DWORD PTR [eax], ebx
  001a0	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001a3	d1 fb		 sar	 ebx, 1
  001a5	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  001ab	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  001ae	89 18		 mov	 DWORD PTR [eax], ebx

; 174  : 				else

  001b0	eb 28		 jmp	 SHORT $LN17@overflow
$LN16@overflow:

; 175  : 					_Mysb::setg(_Newptr,

  001b2	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  001b5	8b 10		 mov	 edx, DWORD PTR [eax]
  001b7	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001ba	8b 00		 mov	 eax, DWORD PTR [eax]
  001bc	2b 45 fc	 sub	 eax, DWORD PTR __Oldptr$1$[ebp]
  001bf	d1 f8		 sar	 eax, 1
  001c1	8d 0c 43	 lea	 ecx, DWORD PTR [ebx+eax*2]
  001c4	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  001c7	2b d1		 sub	 edx, ecx
  001c9	83 c2 02	 add	 edx, 2
  001cc	d1 fa		 sar	 edx, 1
  001ce	89 18		 mov	 DWORD PTR [eax], ebx
  001d0	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001d3	89 08		 mov	 DWORD PTR [eax], ecx
  001d5	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  001d8	89 10		 mov	 DWORD PTR [eax], edx
$LN17@overflow:

; 176  : 						_Newptr + (_Mysb::gptr() - _Oldptr),
; 177  : 						_Mysb::pptr() + 1);
; 178  : 				}
; 179  : 
; 180  : 			if (_Mystate & _Allocated)

  001da	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  001de	74 0c		 je	 SHORT $LN18@overflow

; 181  : 				_Al.deallocate(_Oldptr, _Oldsize);

  001e0	57		 push	 edi
  001e1	ff 75 fc	 push	 DWORD PTR __Oldptr$1$[ebp]
  001e4	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  001e7	e8 00 00 00 00	 call	 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate
$LN18@overflow:

; 182  : 			_Mystate |= _Allocated;
; 183  : 
; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  001ec	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  001ef	83 4e 3c 01	 or	 DWORD PTR [esi+60], 1
  001f3	5f		 pop	 edi
  001f4	5b		 pop	 ebx
  001f5	ff 08		 dec	 DWORD PTR [eax]
  001f7	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  001fa	5e		 pop	 esi
  001fb	8b 11		 mov	 edx, DWORD PTR [ecx]
  001fd	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00200	89 01		 mov	 DWORD PTR [ecx], eax
  00202	66 8b 45 08	 mov	 ax, WORD PTR __Meta$[ebp]
  00206	66 89 02	 mov	 WORD PTR [edx], ax

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  00209	8b e5		 mov	 esp, ebp
  0020b	5d		 pop	 ebp
  0020c	c2 04 00	 ret	 4
?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?str@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
$T1 = -32						; size = 4
__Nul$2 = -28						; size = 24
__Str$3 = -28						; size = 24
__Str$4 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str, COMDAT
; _this$ = ecx

; 93   : 		{	// return string copy of character array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b d1		 mov	 edx, ecx
  00012	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00019	56		 push	 esi
  0001a	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  0001d	8b 4a 3c	 mov	 ecx, DWORD PTR [edx+60]
  00020	f6 c1 02	 test	 cl, 2
  00023	75 66		 jne	 SHORT $LN2@str
  00025	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	85 c0		 test	 eax, eax
  0002c	74 5d		 je	 SHORT $LN2@str

; 95   : 			{	// writable, make string from write buffer
; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  0002e	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  00031	3b c8		 cmp	 ecx, eax
  00033	0f 42 c8	 cmovb	 ecx, eax
  00036	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00039	33 d2		 xor	 edx, edx
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	2b c8		 sub	 ecx, eax
  0003f	d1 f9		 sar	 ecx, 1
  00041	51		 push	 ecx
  00042	50		 push	 eax
  00043	8d 4d e4	 lea	 ecx, DWORD PTR __Str$4[ebp]
  00046	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR __Str$4[ebp+20], 7
  0004d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Str$4[ebp+16], 0
  00054	66 89 55 e4	 mov	 WORD PTR __Str$4[ebp], dx
  00058	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
; 98   : 			return (_Str);

  0005d	33 c0		 xor	 eax, eax
  0005f	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00066	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0006d	8b ce		 mov	 ecx, esi
  0006f	66 89 06	 mov	 WORD PTR [esi], ax
  00072	8d 45 e4	 lea	 eax, DWORD PTR __Str$4[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  0007b	8b 4d f8	 mov	 ecx, DWORD PTR __Str$4[ebp+20]
  0007e	83 f9 08	 cmp	 ecx, 8
  00081	0f 82 8d 00 00
	00		 jb	 $LN950@str
  00087	41		 inc	 ecx
  00088	51		 push	 ecx
  00089	eb 7e		 jmp	 SHORT $LN1047@str
$LN2@str:

; 99   : 			}
; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  0008b	f6 c1 04	 test	 cl, 4
  0008e	75 41		 jne	 SHORT $LN4@str
  00090	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00093	8b 08		 mov	 ecx, DWORD PTR [eax]
  00095	85 c9		 test	 ecx, ecx
  00097	74 38		 je	 SHORT $LN4@str

; 101  : 			{	// readable, make string from read buffer
; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());

  00099	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0009c	8b 00		 mov	 eax, DWORD PTR [eax]
  0009e	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  000a1	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000a4	33 d2		 xor	 edx, edx
  000a6	8b 00		 mov	 eax, DWORD PTR [eax]
  000a8	2b c8		 sub	 ecx, eax
  000aa	d1 f9		 sar	 ecx, 1
  000ac	51		 push	 ecx
  000ad	50		 push	 eax
  000ae	8d 4d e4	 lea	 ecx, DWORD PTR __Str$3[ebp]
  000b1	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR __Str$3[ebp+20], 7
  000b8	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Str$3[ebp+16], 0
  000bf	66 89 55 e4	 mov	 WORD PTR __Str$3[ebp], dx
  000c3	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 103  : 			return (_Str);

  000c8	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000cf	eb 17		 jmp	 SHORT $LN1050@str
$LN4@str:

; 104  : 			}
; 105  : 		else
; 106  : 			{	// inaccessible, return empty string
; 107  : 			_Mystr _Nul;

  000d1	33 c0		 xor	 eax, eax
  000d3	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR __Nul$2[ebp+20], 7
  000da	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Nul$2[ebp+16], 0
  000e1	66 89 45 e4	 mov	 WORD PTR __Nul$2[ebp], ax

; 108  : 			return (_Nul);

  000e5	89 46 10	 mov	 DWORD PTR [esi+16], eax
$LN1050@str:
  000e8	33 c0		 xor	 eax, eax
  000ea	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  000f1	66 89 06	 mov	 WORD PTR [esi], ax
  000f4	8b ce		 mov	 ecx, esi
  000f6	8d 45 e4	 lea	 eax, DWORD PTR __Nul$2[ebp]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  000ff	8b 45 f8	 mov	 eax, DWORD PTR __Nul$2[ebp+20]
  00102	83 f8 08	 cmp	 eax, 8
  00105	72 0d		 jb	 SHORT $LN950@str
  00107	40		 inc	 eax
  00108	50		 push	 eax
$LN1047@str:
  00109	ff 75 e4	 push	 DWORD PTR __Nul$2[ebp]
  0010c	8d 4d e4	 lea	 ecx, DWORD PTR __Nul$2[ebp]
  0010f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN950@str:

; 109  : 			}
; 110  : 		}

  00114	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00117	8b c6		 mov	 eax, esi
  00119	33 cd		 xor	 ecx, ebp
  0011b	5e		 pop	 esi
  0011c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 04 00	 ret	 4
?str@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 75   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@

; 76   : 		_Tidy();

  0002b	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy

; 77   : 		}

  00030	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  00036	8b 76 34	 mov	 esi, DWORD PTR [esi+52]
  00039	85 f6		 test	 esi, esi
  0003b	74 2a		 je	 SHORT $LN9@basic_stri
  0003d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	85 c9		 test	 ecx, ecx
  00049	74 11		 je	 SHORT $LN15@basic_stri
  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	ff 50 08	 call	 DWORD PTR [eax+8]
  00050	85 c0		 test	 eax, eax
  00052	74 08		 je	 SHORT $LN15@basic_stri
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	8b c8		 mov	 ecx, eax
  00058	6a 01		 push	 1
  0005a	ff 12		 call	 DWORD PTR [edx]
$LN15@basic_stri:
  0005c	6a 08		 push	 8
  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00064	83 c4 08	 add	 esp, 8
$LN9@basic_stri:
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00071	59		 pop	 ecx
  00072	5e		 pop	 esi
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$ = 8						; size = 4
??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 28   : 	explicit basic_stringbuf(ios_base::openmode _Mode =

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode

  0002a	e8 00 00 00 00	 call	 ??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
  0002f	8b 5d 08	 mov	 ebx, DWORD PTR __Mode$[ebp]

; 31   : 		_Init(0, 0, _Getstate(_Mode));

  00032	8b c3		 mov	 eax, ebx
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  0003a	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00041	8d 14 9d 00 00
	00 00		 lea	 edx, DWORD PTR [ebx*4]
  00048	f7 d2		 not	 edx
  0004a	83 e2 04	 and	 edx, 4
  0004d	8b ca		 mov	 ecx, edx
  0004f	83 c9 02	 or	 ecx, 2
  00052	24 02		 and	 al, 2
  00054	8b c3		 mov	 eax, ebx
  00056	0f 45 ca	 cmovne	 ecx, edx
  00059	8b d1		 mov	 edx, ecx
  0005b	83 ca 08	 or	 edx, 8
  0005e	24 08		 and	 al, 8
  00060	0f 44 d1	 cmove	 edx, ecx
  00063	8b c2		 mov	 eax, edx
  00065	83 c8 10	 or	 eax, 16			; 00000010H
  00068	80 e3 04	 and	 bl, 4
  0006b	0f 44 c2	 cmove	 eax, edx
  0006e	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 32   : 		}

  00071	8b c6		 mov	 eax, esi
  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
__ehhandler$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	8b 7e 34	 mov	 edi, DWORD PTR [esi+52]
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  0002f	85 ff		 test	 edi, edi
  00031	74 2a		 je	 SHORT $LN10@scalar
  00033	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	85 c9		 test	 ecx, ecx
  0003f	74 11		 je	 SHORT $LN16@scalar
  00041	8b 01		 mov	 eax, DWORD PTR [ecx]
  00043	ff 50 08	 call	 DWORD PTR [eax+8]
  00046	85 c0		 test	 eax, eax
  00048	74 08		 je	 SHORT $LN16@scalar
  0004a	8b 10		 mov	 edx, DWORD PTR [eax]
  0004c	8b c8		 mov	 ecx, eax
  0004e	6a 01		 push	 1
  00050	ff 12		 call	 DWORD PTR [edx]
$LN16@scalar:
  00052	6a 08		 push	 8
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0005a	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0005d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00061	74 0b		 je	 SHORT $LN19@scalar
  00063	6a 38		 push	 56			; 00000038H
  00065	56		 push	 esi
  00066	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006b	83 c4 08	 add	 esp, 8
$LN19@scalar:
  0006e	8b c6		 mov	 eax, esi
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::imbue, COMDAT
; _this$ = ecx

; 449  : 		}

  00000	c2 04 00	 ret	 4
?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sync, COMDAT
; _this$ = ecx

; 444  : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 445  : 		}

  00002	c3		 ret	 0
?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setbuf, COMDAT
; _this$ = ecx

; 439  : 		return (this);

  00000	8b c1		 mov	 eax, ecx

; 440  : 		}

  00002	c2 0c 00	 ret	 12			; 0000000cH
?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekpos, COMDAT
; _this$ = ecx

; 433  : 		{	// change to specified position, according to mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 434  : 		return (streampos(_BADOFF));

  00003	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB
  0000e	89 02		 mov	 DWORD PTR [edx], eax
  00010	8b c2		 mov	 eax, edx
  00012	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3_JB+4
  00018	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0001b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00022	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  00029	66 0f d6 42 10	 movq	 QWORD PTR [edx+16], xmm0

; 435  : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 8
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekoff, COMDAT
; _this$ = ecx

; 427  : 		{	// change position by offset, according to way and mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  : 		return (streampos(_BADOFF));

  00003	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB
  0000e	89 02		 mov	 DWORD PTR [edx], eax
  00010	8b c2		 mov	 eax, edx
  00012	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3_JB+4
  00018	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0001b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00022	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  00029	66 0f d6 42 10	 movq	 QWORD PTR [edx+16], xmm0

; 429  : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z
_TEXT	SEGMENT
__Copied$ = -16						; size = 8
__Size$2$ = -12						; size = 4
_this$1$ = -8						; size = 4
__Copied$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
__Copied$2$ = 16					; size = 4
?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsputn, COMDAT
; _this$ = ecx

; 397  : 		{	// put _Count characters to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 398  : 		streamsize _Size, _Copied;
; 399  : 
; 400  : 		for (_Copied = 0; 0 < _Count; )

  00007	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp+4]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  00010	66 0f 13 45 f0	 movlpd	 QWORD PTR __Copied$[ebp], xmm0
  00015	57		 push	 edi
  00016	85 db		 test	 ebx, ebx
  00018	0f 8c cd 00 00
	00		 jl	 $LN40@xsputn
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00021	7f 08		 jg	 SHORT $LN39@xsputn
  00023	85 ff		 test	 edi, edi
  00025	0f 84 c0 00 00
	00		 je	 $LN40@xsputn
$LN39@xsputn:
  0002b	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  00031	89 55 10	 mov	 DWORD PTR __Copied$2$[ebp], edx
  00034	89 45 fc	 mov	 DWORD PTR __Copied$1$[ebp], eax
  00037	56		 push	 esi
$LL2@xsputn:

; 401  : 			if (0 < (_Size = _Pnavail()))

  00038	e8 00 00 00 00	 call	 ?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pnavail
  0003d	8b f0		 mov	 esi, eax
  0003f	8b c2		 mov	 eax, edx
  00041	89 45 f4	 mov	 DWORD PTR __Size$2$[ebp], eax
  00044	85 c0		 test	 eax, eax
  00046	7c 50		 jl	 SHORT $LN5@xsputn
  00048	7f 04		 jg	 SHORT $LN35@xsputn
  0004a	85 f6		 test	 esi, esi
  0004c	74 4a		 je	 SHORT $LN5@xsputn
$LN35@xsputn:

; 402  : 				{	// copy to write buffer
; 403  : 				if (_Count < _Size)

  0004e	3b d8		 cmp	 ebx, eax
  00050	7f 0b		 jg	 SHORT $LN7@xsputn
  00052	7c 04		 jl	 SHORT $LN36@xsputn
  00054	3b fe		 cmp	 edi, esi
  00056	73 05		 jae	 SHORT $LN7@xsputn
$LN36@xsputn:

; 404  : 					_Size = _Count;

  00058	8b f7		 mov	 esi, edi
  0005a	89 5d f4	 mov	 DWORD PTR __Size$2$[ebp], ebx
$LN7@xsputn:

; 405  : 				_Traits::copy(pptr(), _Ptr, (size_t)_Size);

  0005d	85 f6		 test	 esi, esi
  0005f	74 18		 je	 SHORT $LN16@xsputn
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00064	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  00067	50		 push	 eax
  00068	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	50		 push	 eax
  0006c	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0006f	ff 30		 push	 DWORD PTR [eax]
  00071	e8 00 00 00 00	 call	 _memcpy
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@xsputn:

; 406  : 				_Ptr += _Size;
; 407  : 				_Copied += _Size;

  00079	01 75 fc	 add	 DWORD PTR __Copied$1$[ebp], esi
  0007c	8d 14 36	 lea	 edx, DWORD PTR [esi+esi]
  0007f	8b 45 f4	 mov	 eax, DWORD PTR __Size$2$[ebp]
  00082	11 45 10	 adc	 DWORD PTR __Copied$2$[ebp], eax

; 408  : 				_Count -= _Size;

  00085	2b fe		 sub	 edi, esi

; 409  : 				pbump((int)_Size);

  00087	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0008a	1b d8		 sbb	 ebx, eax
  0008c	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0008f	29 30		 sub	 DWORD PTR [eax], esi
  00091	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00094	01 10		 add	 DWORD PTR [eax], edx
  00096	eb 2f		 jmp	 SHORT $LN9@xsputn
$LN5@xsputn:

; 410  : 				}
; 411  : 			else if (_Traits::eq_int_type(_Traits::eof(),

  00098	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0009b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0009e	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a0	0f b7 00	 movzx	 eax, WORD PTR [eax]
  000a3	50		 push	 eax
  000a4	ff 52 0c	 call	 DWORD PTR [edx+12]
  000a7	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  000ac	66 3b c8	 cmp	 cx, ax
  000af	74 2b		 je	 SHORT $LN42@xsputn

; 412  : 				overflow(_Traits::to_int_type(*_Ptr))))
; 413  : 				break;	// single character put failed, quit
; 414  : 			else
; 415  : 				{	// count character successfully put
; 416  : 				++_Ptr;
; 417  : 				++_Copied;

  000b1	83 45 fc 01	 add	 DWORD PTR __Copied$1$[ebp], 1

; 418  : 				--_Count;

  000b5	ba 02 00 00 00	 mov	 edx, 2
  000ba	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000bd	83 55 10 00	 adc	 DWORD PTR __Copied$2$[ebp], 0
  000c1	83 c7 ff	 add	 edi, -1
  000c4	83 d3 ff	 adc	 ebx, -1
$LN9@xsputn:

; 398  : 		streamsize _Size, _Copied;
; 399  : 
; 400  : 		for (_Copied = 0; 0 < _Count; )

  000c7	01 55 08	 add	 DWORD PTR __Ptr$[ebp], edx
  000ca	85 db		 test	 ebx, ebx
  000cc	0f 8f 66 ff ff
	ff		 jg	 $LL2@xsputn
  000d2	7c 08		 jl	 SHORT $LN42@xsputn
  000d4	85 ff		 test	 edi, edi
  000d6	0f 85 5c ff ff
	ff		 jne	 $LL2@xsputn
$LN42@xsputn:
  000dc	8b 55 10	 mov	 edx, DWORD PTR __Copied$2$[ebp]
  000df	8b 45 fc	 mov	 eax, DWORD PTR __Copied$1$[ebp]
  000e2	5e		 pop	 esi
  000e3	5f		 pop	 edi
  000e4	5b		 pop	 ebx

; 419  : 				}
; 420  : 
; 421  : 		return (_Copied);
; 422  : 		}

  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 0c 00	 ret	 12			; 0000000cH
$LN40@xsputn:

; 398  : 		streamsize _Size, _Copied;
; 399  : 
; 400  : 		for (_Copied = 0; 0 < _Count; )

  000eb	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  000ee	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  000f1	5f		 pop	 edi
  000f2	5b		 pop	 ebx

; 419  : 				}
; 420  : 
; 421  : 		return (_Copied);
; 422  : 		}

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 0c 00	 ret	 12			; 0000000cH
?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsputn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z
_TEXT	SEGMENT
__Copied$ = -16						; size = 8
__Size$2$ = -12						; size = 4
_this$1$ = -8						; size = 4
__Copied$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
__Copied$2$ = 16					; size = 4
?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsgetn, COMDAT
; _this$ = ecx

; 368  : 		{	// get _Count characters from stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 369  : 		int_type _Meta;
; 370  : 		streamsize _Size, _Copied;
; 371  : 
; 372  : 		for (_Copied = 0; 0 < _Count; )

  00007	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp+4]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  00010	66 0f 13 45 f0	 movlpd	 QWORD PTR __Copied$[ebp], xmm0
  00015	57		 push	 edi
  00016	85 db		 test	 ebx, ebx
  00018	0f 8c d3 00 00
	00		 jl	 $LN40@xsgetn
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00021	7f 08		 jg	 SHORT $LN39@xsgetn
  00023	85 ff		 test	 edi, edi
  00025	0f 84 c6 00 00
	00		 je	 $LN40@xsgetn
$LN39@xsgetn:
  0002b	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  00031	89 55 10	 mov	 DWORD PTR __Copied$2$[ebp], edx
  00034	89 45 fc	 mov	 DWORD PTR __Copied$1$[ebp], eax
  00037	56		 push	 esi
$LL2@xsgetn:

; 373  : 			if (0 < (_Size = _Gnavail()))

  00038	e8 00 00 00 00	 call	 ?_Gnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gnavail
  0003d	8b f0		 mov	 esi, eax
  0003f	8b c2		 mov	 eax, edx
  00041	89 45 f4	 mov	 DWORD PTR __Size$2$[ebp], eax
  00044	85 c0		 test	 eax, eax
  00046	7c 52		 jl	 SHORT $LN5@xsgetn
  00048	7f 04		 jg	 SHORT $LN35@xsgetn
  0004a	85 f6		 test	 esi, esi
  0004c	74 4c		 je	 SHORT $LN5@xsgetn
$LN35@xsgetn:

; 374  : 				{	// copy from read buffer
; 375  : 				if (_Count < _Size)

  0004e	3b d8		 cmp	 ebx, eax
  00050	7f 0b		 jg	 SHORT $LN7@xsgetn
  00052	7c 04		 jl	 SHORT $LN36@xsgetn
  00054	3b fe		 cmp	 edi, esi
  00056	73 05		 jae	 SHORT $LN7@xsgetn
$LN36@xsgetn:

; 376  : 					_Size = _Count;

  00058	8b f7		 mov	 esi, edi
  0005a	89 5d f4	 mov	 DWORD PTR __Size$2$[ebp], ebx
$LN7@xsgetn:

; 377  : 				_Traits::copy(_Ptr, gptr(), (size_t)_Size);

  0005d	85 f6		 test	 esi, esi
  0005f	74 17		 je	 SHORT $LN16@xsgetn
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00064	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  00067	50		 push	 eax
  00068	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0006b	ff 30		 push	 DWORD PTR [eax]
  0006d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00070	e8 00 00 00 00	 call	 _memcpy
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@xsgetn:

; 378  : 				_Ptr += _Size;
; 379  : 				_Copied += _Size;

  00078	01 75 fc	 add	 DWORD PTR __Copied$1$[ebp], esi
  0007b	8d 14 36	 lea	 edx, DWORD PTR [esi+esi]
  0007e	8b 45 f4	 mov	 eax, DWORD PTR __Size$2$[ebp]
  00081	11 45 10	 adc	 DWORD PTR __Copied$2$[ebp], eax

; 380  : 				_Count -= _Size;

  00084	2b fe		 sub	 edi, esi

; 381  : 				gbump((int)_Size);

  00086	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00089	1b d8		 sbb	 ebx, eax
  0008b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0008e	29 30		 sub	 DWORD PTR [eax], esi
  00090	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00093	01 10		 add	 DWORD PTR [eax], edx
  00095	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00098	eb 31		 jmp	 SHORT $LN9@xsgetn
$LN5@xsgetn:

; 382  : 				}
; 383  : 			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0009d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009f	ff 50 1c	 call	 DWORD PTR [eax+28]
  000a2	0f b7 c8	 movzx	 ecx, ax
  000a5	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  000aa	66 3b c1	 cmp	 ax, cx
  000ad	74 33		 je	 SHORT $LN42@xsgetn

; 384  : 				break;	// end of file, quit
; 385  : 			else
; 386  : 				{	// get a single character
; 387  : 				*_Ptr++ = _Traits::to_char_type(_Meta);
; 388  : 				++_Copied;

  000af	83 45 fc 01	 add	 DWORD PTR __Copied$1$[ebp], 1

; 389  : 				--_Count;

  000b3	ba 02 00 00 00	 mov	 edx, 2
  000b8	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000bb	83 55 10 00	 adc	 DWORD PTR __Copied$2$[ebp], 0
  000bf	83 c7 ff	 add	 edi, -1
  000c2	83 d3 ff	 adc	 ebx, -1
  000c5	66 89 08	 mov	 WORD PTR [eax], cx
  000c8	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN9@xsgetn:

; 369  : 		int_type _Meta;
; 370  : 		streamsize _Size, _Copied;
; 371  : 
; 372  : 		for (_Copied = 0; 0 < _Count; )

  000cb	03 c2		 add	 eax, edx
  000cd	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  000d0	85 db		 test	 ebx, ebx
  000d2	0f 8f 60 ff ff
	ff		 jg	 $LL2@xsgetn
  000d8	7c 08		 jl	 SHORT $LN42@xsgetn
  000da	85 ff		 test	 edi, edi
  000dc	0f 85 56 ff ff
	ff		 jne	 $LL2@xsgetn
$LN42@xsgetn:
  000e2	8b 55 10	 mov	 edx, DWORD PTR __Copied$2$[ebp]
  000e5	8b 45 fc	 mov	 eax, DWORD PTR __Copied$1$[ebp]
  000e8	5e		 pop	 esi
  000e9	5f		 pop	 edi
  000ea	5b		 pop	 ebx

; 390  : 				}
; 391  : 
; 392  : 		return (_Copied);
; 393  : 		}

  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c2 0c 00	 ret	 12			; 0000000cH
$LN40@xsgetn:

; 369  : 		int_type _Meta;
; 370  : 		streamsize _Size, _Copied;
; 371  : 
; 372  : 		for (_Copied = 0; 0 < _Count; )

  000f1	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  000f4	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  000f7	5f		 pop	 edi
  000f8	5b		 pop	 ebx

; 390  : 				}
; 391  : 
; 392  : 		return (_Copied);
; 393  : 		}

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 0c 00	 ret	 12			; 0000000cH
?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
_TEXT	SEGMENT
?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::uflow, COMDAT
; _this$ = ecx

; 361  : 		{	// get a character from stream, point past it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 362  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 50 18	 call	 DWORD PTR [eax+24]
  00008	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0000d	66 3b c8	 cmp	 cx, ax
  00010	75 04		 jne	 SHORT $LN3@uflow
  00012	8b c1		 mov	 eax, ecx
  00014	5e		 pop	 esi

; 363  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
; 364  : 		}

  00015	c3		 ret	 0
$LN3@uflow:

; 362  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())

  00016	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00019	ff 08		 dec	 DWORD PTR [eax]
  0001b	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0001e	5e		 pop	 esi
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00024	89 01		 mov	 DWORD PTR [ecx], eax
  00026	0f b7 02	 movzx	 eax, WORD PTR [edx]

; 363  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
; 364  : 		}

  00029	c3		 ret	 0
?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::uflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
_TEXT	SEGMENT
?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::underflow, COMDAT
; _this$ = ecx

; 357  : 		return (_Traits::eof());

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 358  : 		}

  00005	c3		 ret	 0
?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ
_TEXT	SEGMENT
?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::showmanyc, COMDAT
; _this$ = ecx

; 352  : 		return (0);

  00000	33 c0		 xor	 eax, eax
  00002	33 d2		 xor	 edx, edx

; 353  : 		}

  00004	c3		 ret	 0
?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::showmanyc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 2
?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbackfail, COMDAT
; _this$ = ecx

; 347  : 		return (_Traits::eof());

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 348  : 		}

  00005	c2 04 00	 ret	 4
?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 2
?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::overflow, COMDAT
; _this$ = ecx

; 342  : 		return (_Traits::eof());

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 343  : 		}

  00005	c2 04 00	 ret	 4
?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Init, COMDAT
; _this$ = ecx

; 319  : 		_IGfirst = &_Gfirst;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 320  : 		_IPfirst = &_Pfirst;

  00006	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]

; 321  : 		_IGnext = &_Gnext;

  00009	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]
  0000c	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000f	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 322  : 		_IPnext = &_Pnext;

  00012	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00015	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 323  : 		_IGcount = &_Gcount;

  00018	8d 41 24	 lea	 eax, DWORD PTR [ecx+36]
  0001b	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 324  : 		_IPcount = &_Pcount;

  0001e	8d 41 28	 lea	 eax, DWORD PTR [ecx+40]
  00021	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 325  : 		setp(0, 0);

  00024	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0002a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00033	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00036	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 326  : 		setg(0, 0, 0);

  0003c	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00045	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00048	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0004e	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 327  : 		}

  00057	c3		 ret	 0
?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pnavail, COMDAT
; _this$ = ecx

; 314  : 		return (*_IPnext != 0 ? *_IPcount : 0);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 07		 je	 SHORT $LN3@Pnavail
  00008	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	99		 cdq

; 315  : 		}

  0000e	c3		 ret	 0
$LN3@Pnavail:

; 314  : 		return (*_IPnext != 0 ? *_IPcount : 0);

  0000f	33 c0		 xor	 eax, eax
  00011	99		 cdq

; 315  : 		}

  00012	c3		 ret	 0
?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pnavail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ
_TEXT	SEGMENT
?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pninc, COMDAT
; _this$ = ecx

; 308  : 		--*_IPcount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 309  : 		return ((*_IPnext)++);

  00005	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00008	8b 02		 mov	 eax, DWORD PTR [edx]
  0000a	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  0000d	89 0a		 mov	 DWORD PTR [edx], ecx

; 310  : 		}

  0000f	c3		 ret	 0
?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Next$ = 12						; size = 4
__Last$ = 16						; size = 4
?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setp, COMDAT
; _this$ = ecx

; 300  : 		{	// set pointers for write buffer, extended version

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 301  : 		*_IPfirst = _First;

  00003	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi

; 302  : 		*_IPnext = _Next;
; 303  : 		*_IPcount = (int)(_Last - _Next);

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	89 02		 mov	 DWORD PTR [edx], eax
  0000f	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00012	8b 55 0c	 mov	 edx, DWORD PTR __Next$[ebp]
  00015	2b f2		 sub	 esi, edx
  00017	d1 fe		 sar	 esi, 1
  00019	89 10		 mov	 DWORD PTR [eax], edx
  0001b	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0001e	89 30		 mov	 DWORD PTR [eax], esi
  00020	5e		 pop	 esi

; 304  : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W0@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setp, COMDAT
; _this$ = ecx

; 293  : 		{	// set pointers for write buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 294  : 		*_IPfirst = _First;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 295  : 		*_IPnext = _First;
; 296  : 		*_IPcount = (int)(_Last - _First);

  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b d6		 sub	 edx, esi
  0000f	89 30		 mov	 DWORD PTR [eax], esi
  00011	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00014	d1 fa		 sar	 edx, 1
  00016	89 30		 mov	 DWORD PTR [eax], esi
  00018	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0001b	5e		 pop	 esi
  0001c	89 10		 mov	 DWORD PTR [eax], edx

; 297  : 		}

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W0@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?pbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbump, COMDAT
; _this$ = ecx

; 287  : 		{	// alter current position in write buffer by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 288  : 		*_IPcount -= _Off;

  00003	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00009	29 10		 sub	 DWORD PTR [eax], edx

; 289  : 		*_IPnext += _Off;

  0000b	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0000e	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  00011	01 01		 add	 DWORD PTR [ecx], eax

; 290  : 		}

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?pbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Gnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Gnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gnavail, COMDAT
; _this$ = ecx

; 283  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 07		 je	 SHORT $LN3@Gnavail
  00008	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	99		 cdq

; 284  : 		}

  0000e	c3		 ret	 0
$LN3@Gnavail:

; 283  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  0000f	33 c0		 xor	 eax, eax
  00011	99		 cdq

; 284  : 		}

  00012	c3		 ret	 0
?_Gnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gnavail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Gninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ
_TEXT	SEGMENT
?_Gninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gninc, COMDAT
; _this$ = ecx

; 271  : 		--*_IGcount;

  00000	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 272  : 		return ((*_IGnext)++);

  00005	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00008	8b 02		 mov	 eax, DWORD PTR [edx]
  0000a	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  0000d	89 0a		 mov	 DWORD PTR [edx], ecx

; 273  : 		}

  0000f	c3		 ret	 0
?_Gninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gninc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?epptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?epptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::epptr, COMDAT
; _this$ = ecx

; 260  : 		return (*_IPnext + *_IPcount);

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]

; 261  : 		}

  0000d	c3		 ret	 0
?epptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::epptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setg@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Next$ = 12						; size = 4
__Last$ = 16						; size = 4
?setg@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setg, COMDAT
; _this$ = ecx

; 252  : 		{	// set pointers for read buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 253  : 		*_IGfirst = _First;

  00003	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi

; 254  : 		*_IGnext = _Next;
; 255  : 		*_IGcount = (int)(_Last - _Next);

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	89 02		 mov	 DWORD PTR [edx], eax
  0000f	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00012	8b 55 0c	 mov	 edx, DWORD PTR __Next$[ebp]
  00015	2b f2		 sub	 esi, edx
  00017	d1 fe		 sar	 esi, 1
  00019	89 10		 mov	 DWORD PTR [eax], edx
  0001b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0001e	89 30		 mov	 DWORD PTR [eax], esi
  00020	5e		 pop	 esi

; 256  : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
?setg@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?gbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?gbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::gbump, COMDAT
; _this$ = ecx

; 246  : 		{	// alter current position in read buffer by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 247  : 		*_IGcount -= _Off;

  00003	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00009	29 10		 sub	 DWORD PTR [eax], edx

; 248  : 		*_IGnext += _Off;

  0000b	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0000e	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  00011	01 01		 add	 DWORD PTR [ecx], eax

; 249  : 		}

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?gbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::gbump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?egptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?egptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::egptr, COMDAT
; _this$ = ecx

; 242  : 		return (*_IGnext + *_IGcount);

  00000	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]

; 243  : 		}

  0000d	c3		 ret	 0
?egptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::egptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?pptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pptr, COMDAT
; _this$ = ecx

; 237  : 		return (*_IPnext);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 238  : 		}

  00005	c3		 ret	 0
?pptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pbase@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?pbase@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbase, COMDAT
; _this$ = ecx

; 232  : 		return (*_IPfirst);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 233  : 		}

  00005	c3		 ret	 0
?pbase@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?gptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?gptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::gptr, COMDAT
; _this$ = ecx

; 227  : 		return (*_IGnext);

  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 228  : 		}

  00005	c3		 ret	 0
?gptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::gptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?eback@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?eback@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::eback, COMDAT
; _this$ = ecx

; 222  : 		return (*_IGfirst);

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 223  : 		}

  00005	c3		 ret	 0
?eback@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::eback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Unlock, COMDAT
; _this$ = ecx

; 217  : 		}

  00000	c3		 ret	 0
?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Lock, COMDAT
; _this$ = ecx

; 213  : 		}

  00000	c3		 ret	 0
?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAE_JPB_W_J@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAE_JPB_W_J@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputn, COMDAT
; _this$ = ecx

; 207  : 		{	// put _Count characters from array beginning at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (xsputn(_Ptr, _Count));

  00003	ff 75 10	 push	 DWORD PTR __Count$[ebp+4]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000e	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00011	ff d0		 call	 eax

; 209  : 		}

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAE_JPB_W_J@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc, COMDAT
; _this$ = ecx

; 199  : 		{	// put a character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 200  : 		return (0 < _Pnavail()

  00003	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00006	83 38 00	 cmp	 DWORD PTR [eax], 0
  00009	74 23		 je	 SHORT $LN3@sputc
  0000b	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0000e	8b 02		 mov	 eax, DWORD PTR [edx]
  00010	85 c0		 test	 eax, eax
  00012	7e 1a		 jle	 SHORT $LN3@sputc
  00014	48		 dec	 eax
  00015	89 02		 mov	 DWORD PTR [edx], eax
  00017	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  0001f	89 01		 mov	 DWORD PTR [ecx], eax
  00021	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00024	66 89 02	 mov	 WORD PTR [edx], ax
  00027	0f b7 c0	 movzx	 eax, ax

; 201  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 202  : 			: overflow(_Traits::to_int_type(_Ch)));
; 203  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN3@sputc:

; 200  : 		return (0 < _Pnavail()

  0002e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00030	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00033	ff 50 0c	 call	 DWORD PTR [eax+12]
  00036	0f b7 c0	 movzx	 eax, ax

; 201  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 202  : 			: overflow(_Traits::to_int_type(_Ch)));
; 203  : 		}

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pubsync, COMDAT
; _this$ = ecx

; 145  : 		return (sync());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 34	 jmp	 DWORD PTR [eax+52]
?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pubsync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 79   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 80   : 		delete _Plocale;

  00023	8b 71 34	 mov	 esi, DWORD PTR [ecx+52]
  00026	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  0002c	85 f6		 test	 esi, esi
  0002e	74 2a		 je	 SHORT $LN6@basic_stre
  00030	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	85 c9		 test	 ecx, ecx
  0003c	74 11		 je	 SHORT $LN12@basic_stre
  0003e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00040	ff 50 08	 call	 DWORD PTR [eax+8]
  00043	85 c0		 test	 eax, eax
  00045	74 08		 je	 SHORT $LN12@basic_stre
  00047	8b 10		 mov	 edx, DWORD PTR [eax]
  00049	8b c8		 mov	 ecx, eax
  0004b	6a 01		 push	 1
  0004d	ff 12		 call	 DWORD PTR [edx]
$LN12@basic_stre:
  0004f	6a 08		 push	 8
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00057	83 c4 08	 add	 esp, 8
$LN6@basic_stre:

; 81   : 		}

  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5e		 pop	 esi
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 26   : 		{	// construct with no buffers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 25   : 		: _Plocale(new locale)

  00026	6a 08		 push	 8

; 26   : 		{	// construct with no buffers

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	8b f8		 mov	 edi, eax
  00035	83 c4 04	 add	 esp, 4
  00038	85 ff		 test	 edi, edi
  0003a	74 16		 je	 SHORT $LN3@basic_stre

; 25   : 		: _Plocale(new locale)

  0003c	6a 01		 push	 1
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00050	eb 02		 jmp	 SHORT $LN4@basic_stre
$LN3@basic_stre:
  00052	33 ff		 xor	 edi, edi
$LN4@basic_stre:

; 27   : 		_Init();

  00054	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00057	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  0005a	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0005d	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00060	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00063	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00066	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00069	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  0006c	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0006f	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  00072	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  00075	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  00078	89 46 30	 mov	 DWORD PTR [esi+48], eax
  0007b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00081	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00084	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0008a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0008d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00093	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00096	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0009c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0009f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000a5	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000a8	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 28   : 		}

  000ae	8b c6		 mov	 eax, esi
  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str, COMDAT
; _this$ = ecx

; 644  : 		{	// return string copy of character array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 645  : 		return (_Stringbuffer.str());

  00004	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00007	83 c1 18	 add	 ecx, 24			; 00000018H
  0000a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00011	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 646  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 635  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx
  00026	8b 47 98	 mov	 eax, DWORD PTR [edi-104]

; 636  : 		}

  00029	8d 4f b0	 lea	 ecx, DWORD PTR [edi-80]
  0002c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002f	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  00037	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  0003a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003d	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  00040	89 44 3a 94	 mov	 DWORD PTR [edx+edi-108], eax
  00044	c7 47 b0 00 00
	00 00		 mov	 DWORD PTR [edi-80], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  0004b	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
  00050	8b 77 e4	 mov	 esi, DWORD PTR [edi-28]
  00053	c7 47 b0 00 00
	00 00		 mov	 DWORD PTR [edi-80], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  0005a	85 f6		 test	 esi, esi
  0005c	74 2a		 je	 SHORT $LN12@basic_stri
  0005e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00061	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	85 c9		 test	 ecx, ecx
  0006a	74 11		 je	 SHORT $LN18@basic_stri
  0006c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006e	ff 50 08	 call	 DWORD PTR [eax+8]
  00071	85 c0		 test	 eax, eax
  00073	74 08		 je	 SHORT $LN18@basic_stri
  00075	8b 10		 mov	 edx, DWORD PTR [eax]
  00077	8b c8		 mov	 ecx, eax
  00079	6a 01		 push	 1
  0007b	ff 12		 call	 DWORD PTR [edx]
$LN18@basic_stri:
  0007d	6a 08		 push	 8
  0007f	56		 push	 esi
  00080	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00085	83 c4 08	 add	 esp, 8
$LN12@basic_stri:
  00088	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  0008b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008e	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
  00096	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  00099	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009c	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  0009f	89 44 39 94	 mov	 DWORD PTR [ecx+edi-108], eax
  000a3	8b 47 a8	 mov	 eax, DWORD PTR [edi-88]
  000a6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a9	c7 44 38 a8 00
	00 00 00	 mov	 DWORD PTR [eax+edi-88], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  000b1	8b 47 a8	 mov	 eax, DWORD PTR [edi-88]
  000b4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b7	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  000ba	89 44 39 a4	 mov	 DWORD PTR [ecx+edi-92], eax
  000be	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  000c1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c4	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  000cc	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  000cf	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d2	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  000d5	89 44 39 94	 mov	 DWORD PTR [ecx+edi-108], eax
  000d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e3	59		 pop	 ecx
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$ = 8						; size = 4
_this$ = 12						; size = 4
_$initVBases$ = 12					; size = 4
??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 591  : 		{	// construct empty character buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00034	83 7d 0c 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  00038	74 22		 je	 SHORT $LN2@basic_stri
  0003a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
  00040	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], OFFSET ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
  00047	c7 47 68 00 00
	00 00		 mov	 DWORD PTR [edi+104], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00055	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_stri:

; 589  : 		: _Mybase(&_Stringbuffer),

  0005c	6a 00		 push	 0
  0005e	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  00061	8b cf		 mov	 ecx, edi
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 ??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::basic_iostream<wchar_t,std::char_traits<wchar_t> >

; 591  : 		{	// construct empty character buffer

  00069	8b 07		 mov	 eax, DWORD PTR [edi]
  0006b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00072	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00075	c7 04 07 00 00
	00 00		 mov	 DWORD PTR [edi+eax], OFFSET ??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  0007c	8b 07		 mov	 eax, DWORD PTR [edi]
  0007e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00081	89 75 0c	 mov	 DWORD PTR _this$[ebp], esi
  00084	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00087	89 44 39 fc	 mov	 DWORD PTR [ecx+edi-4], eax
  0008b	8b ce		 mov	 ecx, esi
  0008d	e8 00 00 00 00	 call	 ??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
  00092	8b 5d 08	 mov	 ebx, DWORD PTR __Mode$[ebp]
  00095	8b c3		 mov	 eax, ebx
  00097	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  0009d	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  000a4	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  000ab	f7 d1		 not	 ecx
  000ad	83 e1 04	 and	 ecx, 4
  000b0	8b d1		 mov	 edx, ecx
  000b2	83 ca 02	 or	 edx, 2
  000b5	24 02		 and	 al, 2
  000b7	8b c3		 mov	 eax, ebx
  000b9	0f 45 d1	 cmovne	 edx, ecx
  000bc	8b ca		 mov	 ecx, edx
  000be	83 c9 08	 or	 ecx, 8
  000c1	24 08		 and	 al, 8
  000c3	0f 44 ca	 cmove	 ecx, edx
  000c6	8b c1		 mov	 eax, ecx
  000c8	83 c8 10	 or	 eax, 16			; 00000010H
  000cb	80 e3 04	 and	 bl, 4
  000ce	0f 44 c1	 cmove	 eax, ecx
  000d1	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 592  : 		}

  000d4	8b c7		 mov	 eax, edi
  000d6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e0	59		 pop	 ecx
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_stri
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 68	 add	 ecx, 104		; 00000068H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN5@basic_stri:
  0001b	c3		 ret	 0
__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$1:
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 20	 add	 ecx, 32			; 00000020H
  00022	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::~basic_iostream<wchar_t,std::char_traits<wchar_t> >
__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$3:
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
__ehhandler$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z:
  0002f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00033	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00036	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
  00045	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8d 51 20	 lea	 edx, DWORD PTR [ecx+32]
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	c7 44 10 e0 00
	00 00 00	 mov	 DWORD PTR [eax+edx-32], OFFSET ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
  00032	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  0003b	89 44 11 dc	 mov	 DWORD PTR [ecx+edx-36], eax
  0003f	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  00042	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00045	c7 44 10 f0 00
	00 00 00	 mov	 DWORD PTR [eax+edx-16], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  0004d	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  00050	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00053	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  00056	89 44 11 ec	 mov	 DWORD PTR [ecx+edx-20], eax
  0005a	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	c7 44 10 e0 00
	00 00 00	 mov	 DWORD PTR [eax+edx-32], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00068	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  0006b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006e	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00071	89 44 11 dc	 mov	 DWORD PTR [ecx+edx-36], eax
  00075	52		 push	 edx
  00076	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007d	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00083	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00088	83 c4 04	 add	 esp, 4
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00095	59		 pop	 ecx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$4:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 71 e0	 lea	 esi, DWORD PTR [ecx-32]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00012	74 0b		 je	 SHORT $LN4@scalar
  00014	6a 68		 push	 104			; 00000068H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_G?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::~basic_iostream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 983  : 		{	// destroy the object

  00000	8b 41 e0	 mov	 eax, DWORD PTR [ecx-32]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 e0 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-32], OFFSET ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
  0000e	8b 41 e0	 mov	 eax, DWORD PTR [ecx-32]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 e0	 lea	 eax, DWORD PTR [edx-32]
  00017	89 44 0a dc	 mov	 DWORD PTR [edx+ecx-36], eax

; 984  : 		}

  0001b	8d 51 f8	 lea	 edx, DWORD PTR [ecx-8]
  0001e	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	c7 44 10 f8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-8], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  0002c	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  0002f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00032	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  00035	89 44 11 f4	 mov	 DWORD PTR [ecx+edx-12], eax
  00039	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  0003c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003f	c7 44 10 e8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-24], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00047	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  0004a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004d	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00050	89 44 11 e4	 mov	 DWORD PTR [ecx+edx-28], eax
  00054	c3		 ret	 0
??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::~basic_iostream<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
_this$ = 12						; size = 4
_$initVBases$ = 12					; size = 4
??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::basic_iostream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 954  : 		{	// construct from stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00032	83 7d 0c 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  00036	74 22		 je	 SHORT $LN2@basic_iost
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
  0003e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], OFFSET ??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
  00045	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00053	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_iost:

; 952  : 		: _Myis(_Strbuf, false),

  0005a	8b 06		 mov	 eax, DWORD PTR [esi]
  0005c	6a 00		 push	 0
  0005e	ff 75 08	 push	 DWORD PTR __Strbuf$[ebp]
  00061	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00064	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  0006b	8b 06		 mov	 eax, DWORD PTR [esi]
  0006d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00070	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00073	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax
  00077	8b 06		 mov	 eax, DWORD PTR [esi]
  00079	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00080	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00087	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008a	03 ce		 add	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init

; 953  : 			_Myos(_Noinit, false)

  00091	8d 56 10	 lea	 edx, DWORD PTR [esi+16]
  00094	89 55 0c	 mov	 DWORD PTR _this$[ebp], edx
  00097	8b 02		 mov	 eax, DWORD PTR [edx]
  00099	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0009c	c7 04 02 00 00
	00 00		 mov	 DWORD PTR [edx+eax], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  000a3	8b 02		 mov	 eax, DWORD PTR [edx]
  000a5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a8	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  000ab	89 44 11 fc	 mov	 DWORD PTR [ecx+edx-4], eax

; 954  : 		{	// construct from stream buffer pointer

  000af	8b 06		 mov	 eax, DWORD PTR [esi]
  000b1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b4	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
  000bb	8b 06		 mov	 eax, DWORD PTR [esi]
  000bd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c0	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  000c3	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax

; 955  : 		}

  000c7	8b c6		 mov	 eax, esi
  000c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5e		 pop	 esi
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_iost
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 20	 add	 ecx, 32			; 00000020H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN5@basic_iost:
  0001b	c3		 ret	 0
__unwindfunclet$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z$1:
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 18	 add	 ecx, 24			; 00000018H
  00022	e9 00 00 00 00	 jmp	 ??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >
__ehhandler$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z:
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z ENDP ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::basic_iostream<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	c7 44 10 f8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-8], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  00032	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0003b	89 44 11 f4	 mov	 DWORD PTR [ecx+edx-12], eax
  0003f	52		 push	 edx
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  0004d	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00052	83 c4 04	 add	 esp, 4
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b d1		 mov	 edx, ecx
  00025	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00028	8d 72 f8	 lea	 esi, DWORD PTR [edx-8]
  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002e	c7 44 10 f8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-8], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0003e	89 44 11 f4	 mov	 DWORD PTR [ecx+edx-12], eax
  00042	52		 push	 edx
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00050	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00055	83 c4 04	 add	 esp, 4
  00058	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005c	74 0b		 je	 SHORT $LN16@scalar
  0005e	6a 50		 push	 80			; 00000050H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00066	83 c4 08	 add	 esp, 8
$LN16@scalar:
  00069	8b c6		 mov	 eax, esi
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
$T2 = -40						; size = 20
__Ok$3 = -20						; size = 8
__$EHRec$ = -12						; size = 12
?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush, COMDAT
; _this$ = ecx

; 574  : 		{	// flush output stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx

; 575  : 		if (_Myios::rdbuf() != 0)

  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	83 7c 30 38 00	 cmp	 DWORD PTR [eax+esi+56], 0
  00032	0f 84 ce 00 00
	00		 je	 $LN102@flush

; 576  : 			{	// buffer exists, flush it
; 577  : 			const sentry _Ok(*this);

  00038	56		 push	 esi
  00039	8d 4d ec	 lea	 ecx, DWORD PTR __Ok$3[ebp]
  0003c	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry

; 578  : 
; 579  : 			if (_Ok && _Myios::rdbuf()->pubsync() == -1)

  00041	80 7d f0 00	 cmp	 BYTE PTR __Ok$3[ebp+4], 0
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	0f 84 83 00 00
	00		 je	 $LN56@flush
  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00057	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  0005b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005d	ff 50 34	 call	 DWORD PTR [eax+52]
  00060	83 f8 ff	 cmp	 eax, -1
  00063	75 70		 jne	 SHORT $LN56@flush

; 580  : 				_Myios::setstate(ios_base::badbit);	// sync failed

  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0006a	8b 44 32 10	 mov	 eax, DWORD PTR [edx+esi+16]
  0006e	03 d6		 add	 edx, esi
  00070	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00073	83 c9 04	 or	 ecx, 4
  00076	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0007a	0f 45 4a 0c	 cmovne	 ecx, DWORD PTR [edx+12]
  0007e	83 e1 13	 and	 ecx, 19			; 00000013H
  00081	83 c9 04	 or	 ecx, 4
  00084	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00087	23 c1		 and	 eax, ecx
  00089	74 4a		 je	 SHORT $LN56@flush
  0008b	a8 04		 test	 al, 4
  0008d	74 2a		 je	 SHORT $LN53@flush
  0008f	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN111@flush:
  00099	50		 push	 eax
  0009a	6a 01		 push	 1
  0009c	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0009f	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000a4	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000a9	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  000ac	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN112@flush:
$LN53@flush:
  000b9	a8 02		 test	 al, 2
  000bb	74 0c		 je	 SHORT $LN55@flush
  000bd	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  000c7	eb d0		 jmp	 SHORT $LN111@flush
$LN55@flush:
  000c9	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000d3	eb c4		 jmp	 SHORT $LN111@flush
$LN56@flush:

; 581  : 			}

  000d5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000dc	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  000e1	84 c0		 test	 al, al
  000e3	75 08		 jne	 SHORT $LN98@flush
  000e5	8b 4d ec	 mov	 ecx, DWORD PTR __Ok$3[ebp]
  000e8	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN98@flush:
  000ed	8b 4d ec	 mov	 ecx, DWORD PTR __Ok$3[ebp]
  000f0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000f4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f9	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  000fd	85 c9		 test	 ecx, ecx
  000ff	74 05		 je	 SHORT $LN102@flush
  00101	8b 01		 mov	 eax, DWORD PTR [ecx]
  00103	ff 50 08	 call	 DWORD PTR [eax+8]
$LN102@flush:

; 582  : 		return (*this);

  00106	8b c6		 mov	 eax, esi

; 583  : 		}

  00108	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0010b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00112	59		 pop	 ecx
  00113	5e		 pop	 esi
  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c3		 ret	 0
$LN110@flush:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Ok$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$14:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$15:
  0000e	e8 00 00 00 00	 call	 ___std_terminate
  00013	c3		 ret	 0
__ehhandler$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ:
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z
_TEXT	SEGMENT
$T2 = -108						; size = 20
$T3 = -88						; size = 20
$T4 = -68						; size = 20
$T5 = -48						; size = 8
$T6 = -40						; size = 8
__Ok$ = -32						; size = 8
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T7 = 8							; size = 8
__Val$ = 8						; size = 8
??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<, COMDAT
; _this$ = ecx

; 396  : 		{	// insert an unsigned long long

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 397  : 		ios_base::iostate _State = ios_base::goodbit;
; 398  : 		const sentry _Ok(*this);

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	33 ff		 xor	 edi, edi
  00034	89 7d e8	 mov	 DWORD PTR __State$[ebp], edi
  00037	89 75 e0	 mov	 DWORD PTR __Ok$[ebp], esi
  0003a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003d	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00041	85 c9		 test	 ecx, ecx
  00043	74 05		 je	 SHORT $LN19@operator
  00045	8b 01		 mov	 eax, DWORD PTR [ecx]
  00047	ff 50 04	 call	 DWORD PTR [eax+4]
$LN19@operator:
  0004a	8b 06		 mov	 eax, DWORD PTR [esi]
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00053	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00056	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  0005b	75 11		 jne	 SHORT $LN15@operator
  0005d	8b 4c 30 3c	 mov	 ecx, DWORD PTR [eax+esi+60]
  00061	85 c9		 test	 ecx, ecx
  00063	74 09		 je	 SHORT $LN15@operator
  00065	3b ce		 cmp	 ecx, esi
  00067	74 05		 je	 SHORT $LN15@operator
  00069	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
$LN15@operator:
  0006e	8b 06		 mov	 eax, DWORD PTR [esi]
  00070	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00073	03 ce		 add	 ecx, esi
  00075	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00079	0f 94 c0	 sete	 al
  0007c	88 45 e4	 mov	 BYTE PTR __Ok$[ebp+4], al
  0007f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 399  : 
; 400  : 		if (_Ok)

  00086	84 c0		 test	 al, al
  00088	74 74		 je	 SHORT $LN12@operator

; 401  : 			{	// state okay, use facet to insert
; 402  : 			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

  0008a	8d 45 d8	 lea	 eax, DWORD PTR $T6[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00093	50		 push	 eax
  00094	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00098	e8 00 00 00 00	 call	 ??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >
  0009d	83 c4 04	 add	 esp, 4
  000a0	8b d8		 mov	 ebx, eax
  000a2	8b 4d dc	 mov	 ecx, DWORD PTR $T6[ebp+4]
  000a5	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  000a9	85 c9		 test	 ecx, ecx
  000ab	74 11		 je	 SHORT $LN44@operator
  000ad	8b 11		 mov	 edx, DWORD PTR [ecx]
  000af	ff 52 08	 call	 DWORD PTR [edx+8]
  000b2	85 c0		 test	 eax, eax
  000b4	74 08		 je	 SHORT $LN44@operator
  000b6	8b 10		 mov	 edx, DWORD PTR [eax]
  000b8	8b c8		 mov	 ecx, eax
  000ba	6a 01		 push	 1
  000bc	ff 12		 call	 DWORD PTR [edx]
$LN44@operator:

; 403  : 
; 404  : 			_TRY_IO_BEGIN
; 405  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 406  : 				_Myios::fill(), _Val).failed())

  000be	8b 06		 mov	 eax, DWORD PTR [esi]
  000c0	ff 75 0c	 push	 DWORD PTR __Val$[ebp+4]
  000c3	8b 13		 mov	 edx, DWORD PTR [ebx]
  000c5	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  000c8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cb	0f b7 44 31 40	 movzx	 eax, WORD PTR [ecx+esi+64]
  000d0	03 ce		 add	 ecx, esi
  000d2	50		 push	 eax
  000d3	51		 push	 ecx
  000d4	c6 45 d0 00	 mov	 BYTE PTR $T5[ebp], 0
  000d8	8d 45 08	 lea	 eax, DWORD PTR $T7[ebp]
  000db	ff 71 38	 push	 DWORD PTR [ecx+56]
  000de	8b cb		 mov	 ecx, ebx
  000e0	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  000e4	ff 75 d0	 push	 DWORD PTR $T5[ebp]
  000e7	50		 push	 eax
  000e8	ff 52 18	 call	 DWORD PTR [edx+24]
  000eb	80 7d 08 00	 cmp	 BYTE PTR $T7[ebp], 0
  000ef	b8 04 00 00 00	 mov	 eax, 4
  000f4	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  000fb	0f 45 f8	 cmovne	 edi, eax
$LN12@operator:

; 409  : 			}
; 410  : 
; 411  : 		_Myios::setstate(_State);

  000fe	8b 06		 mov	 eax, DWORD PTR [esi]
  00100	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00103	03 d6		 add	 edx, esi
  00105	85 ff		 test	 edi, edi
  00107	0f 84 ee 00 00
	00		 je	 $LN134@operator
  0010d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00110	0b c7		 or	 eax, edi
  00112	8b c8		 mov	 ecx, eax
  00114	83 c9 04	 or	 ecx, 4
  00117	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0011b	0f 45 c8	 cmovne	 ecx, eax
  0011e	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00121	83 e1 17	 and	 ecx, 23			; 00000017H
  00124	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00127	23 c1		 and	 eax, ecx
  00129	0f 84 cc 00 00
	00		 je	 $LN134@operator
  0012f	a8 04		 test	 al, 4
  00131	74 70		 je	 SHORT $LN131@operator
  00133	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00138	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  0013d	50		 push	 eax
  0013e	6a 01		 push	 1
  00140	8d 4d bc	 lea	 ecx, DWORD PTR $T4[ebp]
  00143	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00148	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  0014d	8d 45 bc	 lea	 eax, DWORD PTR $T4[ebp]
  00150	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN188@operator:
__catch$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z$0:

; 407  : 				_State |= ios_base::badbit;
; 408  : 			_CATCH_IO_END

  0015d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00160	8b 01		 mov	 eax, DWORD PTR [ecx]
  00162	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00165	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  00169	03 d1		 add	 edx, ecx
  0016b	83 c8 04	 or	 eax, 4
  0016e	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00172	75 03		 jne	 SHORT $LN66@operator
  00174	83 c8 04	 or	 eax, 4
$LN66@operator:
  00177	83 e0 17	 and	 eax, 23			; 00000017H
  0017a	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0017d	85 42 10	 test	 DWORD PTR [edx+16], eax
  00180	75 18		 jne	 SHORT $LN69@operator
  00182	b8 00 00 00 00	 mov	 eax, $LN13@operator
  00187	c3		 ret	 0
$LN13@operator:
  00188	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0018b	8b 7d e8	 mov	 edi, DWORD PTR __State$[ebp]
  0018e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00195	e9 64 ff ff ff	 jmp	 $LN12@operator
$LN69@operator:
  0019a	6a 00		 push	 0
  0019c	6a 00		 push	 0
  0019e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN189@operator:

; 409  : 			}
; 410  : 
; 411  : 		_Myios::setstate(_State);

$LN131@operator:
  001a3	a8 02		 test	 al, 2
  001a5	74 2a		 je	 SHORT $LN133@operator
  001a7	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  001ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  001b1	50		 push	 eax
  001b2	6a 01		 push	 1
  001b4	8d 4d a8	 lea	 ecx, DWORD PTR $T3[ebp]
  001b7	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  001bc	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  001c1	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  001c4	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  001cb	50		 push	 eax
  001cc	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN190@operator:
$LN133@operator:
  001d1	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  001d6	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  001db	50		 push	 eax
  001dc	6a 01		 push	 1
  001de	8d 4d 94	 lea	 ecx, DWORD PTR $T2[ebp]
  001e1	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  001e6	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  001eb	8d 45 94	 lea	 eax, DWORD PTR $T2[ebp]
  001ee	c7 45 94 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  001f5	50		 push	 eax
  001f6	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN191@operator:
$LN134@operator:

; 412  : 		return (*this);

  001fb	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 6
  00202	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  00207	84 c0		 test	 al, al
  00209	75 07		 jne	 SHORT $LN175@operator
  0020b	8b ce		 mov	 ecx, esi
  0020d	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN175@operator:
  00212	8b 06		 mov	 eax, DWORD PTR [esi]
  00214	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+12], 7
  00218	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0021b	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  0021f	85 c9		 test	 ecx, ecx
  00221	74 05		 je	 SHORT $LN179@operator
  00223	8b 01		 mov	 eax, DWORD PTR [ecx]
  00225	ff 50 08	 call	 DWORD PTR [eax+8]
$LN179@operator:
  00228	8b c6		 mov	 eax, esi

; 413  : 		}

  0022a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0022d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00234	59		 pop	 ecx
  00235	5f		 pop	 edi
  00236	5e		 pop	 esi
  00237	5b		 pop	 ebx
  00238	8b e5		 mov	 esp, ebp
  0023a	5d		 pop	 ebp
  0023b	c2 08 00	 ret	 8
$LN187@operator:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z$4:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z$2:
  00008	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z$3:
  00010	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z$5:
  00018	e8 00 00 00 00	 call	 ___std_terminate
  0001d	c3		 ret	 0
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z$32:
  0001e	e8 00 00 00 00	 call	 ___std_terminate
  00023	c3		 ret	 0
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z$33:
  00024	e8 00 00 00 00	 call	 ___std_terminate
  00029	c3		 ret	 0
__ehhandler$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z:
  0002a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00031	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z
  00040	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z
_TEXT	SEGMENT
$T2 = -108						; size = 20
$T3 = -88						; size = 20
$T4 = -68						; size = 20
$T5 = -48						; size = 8
$T6 = -48						; size = 8
$T7 = -40						; size = 8
__Ok$ = -32						; size = 8
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<, COMDAT
; _this$ = ecx

; 356  : 		{	// insert an unsigned long

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 357  : 		ios_base::iostate _State = ios_base::goodbit;
; 358  : 		const sentry _Ok(*this);

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	33 ff		 xor	 edi, edi
  00034	89 7d e8	 mov	 DWORD PTR __State$[ebp], edi
  00037	89 75 e0	 mov	 DWORD PTR __Ok$[ebp], esi
  0003a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003d	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00041	85 c9		 test	 ecx, ecx
  00043	74 05		 je	 SHORT $LN19@operator
  00045	8b 01		 mov	 eax, DWORD PTR [ecx]
  00047	ff 50 04	 call	 DWORD PTR [eax+4]
$LN19@operator:
  0004a	8b 06		 mov	 eax, DWORD PTR [esi]
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00053	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00056	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  0005b	75 11		 jne	 SHORT $LN15@operator
  0005d	8b 4c 30 3c	 mov	 ecx, DWORD PTR [eax+esi+60]
  00061	85 c9		 test	 ecx, ecx
  00063	74 09		 je	 SHORT $LN15@operator
  00065	3b ce		 cmp	 ecx, esi
  00067	74 05		 je	 SHORT $LN15@operator
  00069	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
$LN15@operator:
  0006e	8b 06		 mov	 eax, DWORD PTR [esi]
  00070	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00073	03 ce		 add	 ecx, esi
  00075	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00079	0f 94 c0	 sete	 al
  0007c	88 45 e4	 mov	 BYTE PTR __Ok$[ebp+4], al
  0007f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 359  : 
; 360  : 		if (_Ok)

  00086	84 c0		 test	 al, al
  00088	74 71		 je	 SHORT $LN12@operator

; 361  : 			{	// state okay, use facet to insert
; 362  : 			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

  0008a	8d 45 d8	 lea	 eax, DWORD PTR $T7[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00093	50		 push	 eax
  00094	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00098	e8 00 00 00 00	 call	 ??$use_facet@V?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@@std@@YAABV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > >
  0009d	83 c4 04	 add	 esp, 4
  000a0	8b d8		 mov	 ebx, eax
  000a2	8b 4d dc	 mov	 ecx, DWORD PTR $T7[ebp+4]
  000a5	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  000a9	85 c9		 test	 ecx, ecx
  000ab	74 11		 je	 SHORT $LN44@operator
  000ad	8b 11		 mov	 edx, DWORD PTR [ecx]
  000af	ff 52 08	 call	 DWORD PTR [edx+8]
  000b2	85 c0		 test	 eax, eax
  000b4	74 08		 je	 SHORT $LN44@operator
  000b6	8b 10		 mov	 edx, DWORD PTR [eax]
  000b8	8b c8		 mov	 ecx, eax
  000ba	6a 01		 push	 1
  000bc	ff 12		 call	 DWORD PTR [edx]
$LN44@operator:

; 363  : 
; 364  : 			_TRY_IO_BEGIN
; 365  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 366  : 				_Myios::fill(), _Val).failed())

  000be	8b 06		 mov	 eax, DWORD PTR [esi]
  000c0	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  000c3	8b 13		 mov	 edx, DWORD PTR [ebx]
  000c5	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  000c9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cc	0f b7 44 31 40	 movzx	 eax, WORD PTR [ecx+esi+64]
  000d1	03 ce		 add	 ecx, esi
  000d3	50		 push	 eax
  000d4	51		 push	 ecx
  000d5	c6 45 d0 00	 mov	 BYTE PTR $T6[ebp], 0
  000d9	8d 45 d0	 lea	 eax, DWORD PTR $T5[ebp]
  000dc	ff 71 38	 push	 DWORD PTR [ecx+56]
  000df	8b cb		 mov	 ecx, ebx
  000e1	ff 75 d0	 push	 DWORD PTR $T6[ebp]
  000e4	50		 push	 eax
  000e5	ff 52 20	 call	 DWORD PTR [edx+32]
  000e8	80 7d d0 00	 cmp	 BYTE PTR $T5[ebp], 0
  000ec	b8 04 00 00 00	 mov	 eax, 4
  000f1	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  000f8	0f 45 f8	 cmovne	 edi, eax
$LN12@operator:

; 369  : 			}
; 370  : 
; 371  : 		_Myios::setstate(_State);

  000fb	8b 06		 mov	 eax, DWORD PTR [esi]
  000fd	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00100	03 d6		 add	 edx, esi
  00102	85 ff		 test	 edi, edi
  00104	0f 84 ee 00 00
	00		 je	 $LN134@operator
  0010a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0010d	0b c7		 or	 eax, edi
  0010f	8b c8		 mov	 ecx, eax
  00111	83 c9 04	 or	 ecx, 4
  00114	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00118	0f 45 c8	 cmovne	 ecx, eax
  0011b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0011e	83 e1 17	 and	 ecx, 23			; 00000017H
  00121	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00124	23 c1		 and	 eax, ecx
  00126	0f 84 cc 00 00
	00		 je	 $LN134@operator
  0012c	a8 04		 test	 al, 4
  0012e	74 70		 je	 SHORT $LN131@operator
  00130	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00135	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  0013a	50		 push	 eax
  0013b	6a 01		 push	 1
  0013d	8d 4d bc	 lea	 ecx, DWORD PTR $T4[ebp]
  00140	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00145	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  0014a	8d 45 bc	 lea	 eax, DWORD PTR $T4[ebp]
  0014d	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN188@operator:
__catch$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$0:

; 367  : 				_State |= ios_base::badbit;
; 368  : 			_CATCH_IO_END

  0015a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0015d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0015f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00162	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  00166	03 d1		 add	 edx, ecx
  00168	83 c8 04	 or	 eax, 4
  0016b	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0016f	75 03		 jne	 SHORT $LN66@operator
  00171	83 c8 04	 or	 eax, 4
$LN66@operator:
  00174	83 e0 17	 and	 eax, 23			; 00000017H
  00177	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0017a	85 42 10	 test	 DWORD PTR [edx+16], eax
  0017d	75 18		 jne	 SHORT $LN69@operator
  0017f	b8 00 00 00 00	 mov	 eax, $LN13@operator
  00184	c3		 ret	 0
$LN13@operator:
  00185	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00188	8b 7d e8	 mov	 edi, DWORD PTR __State$[ebp]
  0018b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00192	e9 64 ff ff ff	 jmp	 $LN12@operator
$LN69@operator:
  00197	6a 00		 push	 0
  00199	6a 00		 push	 0
  0019b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN189@operator:

; 369  : 			}
; 370  : 
; 371  : 		_Myios::setstate(_State);

$LN131@operator:
  001a0	a8 02		 test	 al, 2
  001a2	74 2a		 je	 SHORT $LN133@operator
  001a4	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  001a9	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  001ae	50		 push	 eax
  001af	6a 01		 push	 1
  001b1	8d 4d a8	 lea	 ecx, DWORD PTR $T3[ebp]
  001b4	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  001b9	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  001be	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  001c1	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN190@operator:
$LN133@operator:
  001ce	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  001d3	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  001d8	50		 push	 eax
  001d9	6a 01		 push	 1
  001db	8d 4d 94	 lea	 ecx, DWORD PTR $T2[ebp]
  001de	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  001e3	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  001e8	8d 45 94	 lea	 eax, DWORD PTR $T2[ebp]
  001eb	c7 45 94 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  001f2	50		 push	 eax
  001f3	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN191@operator:
$LN134@operator:

; 372  : 		return (*this);

  001f8	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 6
  001ff	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  00204	84 c0		 test	 al, al
  00206	75 07		 jne	 SHORT $LN175@operator
  00208	8b ce		 mov	 ecx, esi
  0020a	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN175@operator:
  0020f	8b 06		 mov	 eax, DWORD PTR [esi]
  00211	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+12], 7
  00215	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00218	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  0021c	85 c9		 test	 ecx, ecx
  0021e	74 05		 je	 SHORT $LN179@operator
  00220	8b 01		 mov	 eax, DWORD PTR [ecx]
  00222	ff 50 08	 call	 DWORD PTR [eax+8]
$LN179@operator:
  00225	8b c6		 mov	 eax, esi

; 373  : 		}

  00227	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0022a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00231	59		 pop	 ecx
  00232	5f		 pop	 edi
  00233	5e		 pop	 esi
  00234	5b		 pop	 ebx
  00235	8b e5		 mov	 esp, ebp
  00237	5d		 pop	 ebp
  00238	c2 04 00	 ret	 4
$LN187@operator:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$4:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$2:
  00008	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$3:
  00010	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$5:
  00018	e8 00 00 00 00	 call	 ___std_terminate
  0001d	c3		 ret	 0
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$32:
  0001e	e8 00 00 00 00	 call	 ___std_terminate
  00023	c3		 ret	 0
__unwindfunclet$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z$33:
  00024	e8 00 00 00 00	 call	 ___std_terminate
  00029	c3		 ret	 0
__ehhandler$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z:
  0002a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00031	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z
  00040	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T2 = -76						; size = 20
$T3 = -56						; size = 20
$T4 = -36						; size = 20
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx, COMDAT
; _this$ = ecx

; 165  : 		{	// perform any wrapup

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 166  : 		_TRY_BEGIN
; 167  : 		if (this->good() && this->flags() & ios_base::unitbuf)

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00036	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00039	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  0003e	0f 85 d3 00 00
	00		 jne	 $LN9@Osfx
  00044	f6 44 30 14 02	 test	 BYTE PTR [eax+esi+20], 2
  00049	0f 84 c8 00 00
	00		 je	 $LN9@Osfx

; 168  : 			if (_Myios::rdbuf()->pubsync() == -1)	// flush stream as needed

  0004f	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00053	8b 01		 mov	 eax, DWORD PTR [ecx]
  00055	ff 50 34	 call	 DWORD PTR [eax+52]
  00058	83 f8 ff	 cmp	 eax, -1
  0005b	0f 85 b6 00 00
	00		 jne	 $LN9@Osfx

; 169  : 				_Myios::setstate(ios_base::badbit);

  00061	8b 06		 mov	 eax, DWORD PTR [esi]
  00063	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00066	8b 44 32 10	 mov	 eax, DWORD PTR [edx+esi+16]
  0006a	03 d6		 add	 edx, esi
  0006c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0006f	83 c9 04	 or	 ecx, 4
  00072	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00076	0f 45 4a 0c	 cmovne	 ecx, DWORD PTR [edx+12]
  0007a	83 e1 13	 and	 ecx, 19			; 00000013H
  0007d	83 c9 04	 or	 ecx, 4
  00080	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00083	23 c1		 and	 eax, ecx
  00085	0f 84 8c 00 00
	00		 je	 $LN9@Osfx
  0008b	a8 04		 test	 al, 4
  0008d	74 2a		 je	 SHORT $LN34@Osfx
  0008f	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  00099	50		 push	 eax
  0009a	6a 01		 push	 1
  0009c	8d 4d dc	 lea	 ecx, DWORD PTR $T4[ebp]
  0009f	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000a4	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000a9	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  000ac	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN80@Osfx:
$LN34@Osfx:
  000b9	a8 02		 test	 al, 2
  000bb	74 2a		 je	 SHORT $LN36@Osfx
  000bd	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  000c7	50		 push	 eax
  000c8	6a 01		 push	 1
  000ca	8d 4d c8	 lea	 ecx, DWORD PTR $T3[ebp]
  000cd	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000d2	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000d7	8d 45 c8	 lea	 eax, DWORD PTR $T3[ebp]
  000da	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN81@Osfx:
$LN36@Osfx:
  000e7	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000f1	50		 push	 eax
  000f2	6a 01		 push	 1
  000f4	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp]
  000f7	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000fc	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00101	8d 45 b4	 lea	 eax, DWORD PTR $T2[ebp]
  00104	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN82@Osfx:
__catch$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$0:

; 170  : 		_CATCH_ALL
; 171  : 		_CATCH_END

  00111	b8 00 00 00 00	 mov	 eax, $LN9@Osfx
  00116	c3		 ret	 0
$LN9@Osfx:

; 172  : 		}

  00117	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0011a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00121	59		 pop	 ecx
  00122	5f		 pop	 edi
  00123	5e		 pop	 esi
  00124	5b		 pop	 ebx
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
$LN79@Osfx:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::~basic_ostream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 88   : 		{	// destroy the object

  00000	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 f8 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-8], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  0000e	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00017	89 44 0a f4	 mov	 DWORD PTR [edx+ecx-12], eax

; 89   : 		}

  0001b	c3		 ret	 0
??1?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::~basic_ostream<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
__Addit$ = 12						; size = 1
_$initVBases$ = 16					; size = 4
??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::basic_ostream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 58   : 	__CLR_OR_THIS_CALL basic_ostream(_Uninitialized, bool _Addit = true)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 59   : 		{	// construct uninitialized

  0002b	83 7d 10 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00036	74 1b		 je	 SHORT $LN2@basic_ostr
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_ostream@_WU?$char_traits@_W@std@@@std@@7B@
  0003e	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_ostr:

; 60   : 		if (_Addit)

  00053	80 7d 0c 00	 cmp	 BYTE PTR __Addit$[ebp], 0
  00057	8b 06		 mov	 eax, DWORD PTR [esi]
  00059	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005c	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  00063	8b 06		 mov	 eax, DWORD PTR [esi]
  00065	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00068	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0006b	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax
  0006f	74 10		 je	 SHORT $LN13@basic_ostr

; 61   : 			this->_Addstd(this);	// suppress for basic_iostream

  00071	8b 06		 mov	 eax, DWORD PTR [esi]
  00073	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00076	03 c6		 add	 eax, esi
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  0007e	83 c4 04	 add	 esp, 4
$LN13@basic_ostr:

; 62   : 		}

  00081	8b c6		 mov	 eax, esi
  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	5e		 pop	 esi
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN8@basic_ostr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 08	 add	 ecx, 8
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN8@basic_ostr:
  0001b	c3		 ret	 0
__ehhandler$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::basic_ostream<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8d 51 18	 lea	 edx, DWORD PTR [ecx+24]
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	c7 44 10 e8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-24], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00032	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0003b	89 44 11 e4	 mov	 DWORD PTR [ecx+edx-28], eax
  0003f	52		 push	 edx
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  0004d	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00052	83 c4 04	 add	 esp, 4
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b d1		 mov	 edx, ecx
  00025	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  00028	8d 72 e8	 lea	 esi, DWORD PTR [edx-24]
  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002e	c7 44 10 e8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-24], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0003e	89 44 11 e4	 mov	 DWORD PTR [ecx+edx-28], eax
  00042	52		 push	 edx
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00050	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00055	83 c4 04	 add	 esp, 4
  00058	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005c	74 0b		 je	 SHORT $LN16@scalar
  0005e	6a 60		 push	 96			; 00000060H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00066	83 c4 08	 add	 esp, 8
$LN16@scalar:
  00069	8b c6		 mov	 eax, esi
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 81   : 		{	// destroy the object

  00000	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 e8 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-24], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  0000e	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 e8	 lea	 eax, DWORD PTR [edx-24]
  00017	89 44 0a e4	 mov	 DWORD PTR [edx+ecx-28], eax

; 82   : 		}

  0001b	c3		 ret	 0
??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
_$initVBases$ = 16					; size = 4
??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::basic_istream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 46   : 		{	// construct from stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002b	83 7d 10 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00036	74 1b		 je	 SHORT $LN2@basic_istr
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_istream@_WU?$char_traits@_W@std@@@std@@7B@
  0003e	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_istr:
  00053	8b 06		 mov	 eax, DWORD PTR [esi]

; 47   : 		_Myios::init(_Strbuf, _Isstd);

  00055	ff 75 0c	 push	 DWORD PTR __Isstd$[ebp]
  00058	ff 75 08	 push	 DWORD PTR __Strbuf$[ebp]
  0005b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005e	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006a	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0006d	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax
  00071	8b 06		 mov	 eax, DWORD PTR [esi]
  00073	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0007a	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00081	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00084	03 ce		 add	 ecx, esi
  00086	e8 00 00 00 00	 call	 ?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init

; 48   : 		}

  0008b	8b c6		 mov	 eax, esi
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	5e		 pop	 esi
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_istr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 18	 add	 ecx, 24			; 00000018H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN5@basic_istr:
  0001b	c3		 ret	 0
__ehhandler$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::basic_istream<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	56		 push	 esi
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00033	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00038	83 c4 04	 add	 esp, 4
  0003b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003f	74 0b		 je	 SHORT $LN10@scalar
  00041	6a 48		 push	 72			; 00000048H
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00049	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0004c	8b c6		 mov	 eax, esi
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00058	59		 pop	 ecx
  00059	5e		 pop	 esi
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAE@XZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::basic_ios<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 183  : 	__CLR_OR_THIS_CALL basic_ios()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  : 		{	// default constructor, do nothing
; 185  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAE@XZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::basic_ios<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z
_TEXT	SEGMENT
$T2 = -60						; size = 20
$T3 = -40						; size = 20
$T4 = -20						; size = 8
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init, COMDAT
; _this$ = ecx

; 170  : 		{	// initialize with stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx

; 171  : 		_Init();	// initialize ios_base

  00029	e8 00 00 00 00	 call	 ?_Init@ios_base@std@@IAEXXZ ; std::ios_base::_Init

; 172  : 		_Mystrbuf = _Strbuf;

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Strbuf$[ebp]

; 173  : 		_Tiestr = 0;
; 174  : 		_Fillch = widen(' ');

  00031	8b ce		 mov	 ecx, esi
  00033	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00036	8d 45 ec	 lea	 eax, DWORD PTR $T4[ebp]
  00039	50		 push	 eax
  0003a	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
  00041	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00046	50		 push	 eax
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004e	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  00053	83 c4 04	 add	 esp, 4
  00056	8b f8		 mov	 edi, eax
  00058	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp+4]
  0005b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00062	85 c9		 test	 ecx, ecx
  00064	74 11		 je	 SHORT $LN11@init
  00066	8b 11		 mov	 edx, DWORD PTR [ecx]
  00068	ff 52 08	 call	 DWORD PTR [edx+8]
  0006b	85 c0		 test	 eax, eax
  0006d	74 08		 je	 SHORT $LN11@init
  0006f	8b 10		 mov	 edx, DWORD PTR [eax]
  00071	8b c8		 mov	 ecx, eax
  00073	6a 01		 push	 1
  00075	ff 12		 call	 DWORD PTR [edx]
$LN11@init:
  00077	8b 07		 mov	 eax, DWORD PTR [edi]
  00079	8b cf		 mov	 ecx, edi
  0007b	6a 20		 push	 32			; 00000020H
  0007d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00084	ff 50 30	 call	 DWORD PTR [eax+48]

; 175  : 
; 176  : 		if (_Mystrbuf == 0)

  00087	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  0008b	66 89 46 40	 mov	 WORD PTR [esi+64], ax
  0008f	75 79		 jne	 SHORT $LN33@init

; 177  : 			setstate(badbit);

  00091	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00094	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00097	83 e0 13	 and	 eax, 19			; 00000013H
  0009a	83 c8 04	 or	 eax, 4
  0009d	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  000a0	23 c8		 and	 ecx, eax
  000a2	74 66		 je	 SHORT $LN33@init
  000a4	f6 c1 04	 test	 cl, 4
  000a7	74 2a		 je	 SHORT $LN30@init
  000a9	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN76@init:
  000b3	50		 push	 eax
  000b4	6a 01		 push	 1
  000b6	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  000b9	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000be	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000c5	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  000c8	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
$LN77@init:
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN78@init:
$LN30@init:
  000d3	f6 c1 02	 test	 cl, 2
  000d6	74 0c		 je	 SHORT $LN32@init
  000d8	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  000e2	eb cf		 jmp	 SHORT $LN76@init
$LN32@init:
  000e4	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000ee	50		 push	 eax
  000ef	6a 01		 push	 1
  000f1	8d 4d c4	 lea	 ecx, DWORD PTR $T2[ebp]
  000f4	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000f9	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00100	8d 45 c4	 lea	 eax, DWORD PTR $T2[ebp]
  00103	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00108	eb c3		 jmp	 SHORT $LN77@init
$LN33@init:

; 178  : 
; 179  : 		if (_Isstd)

  0010a	80 7d 0c 00	 cmp	 BYTE PTR __Isstd$[ebp], 0
  0010e	74 09		 je	 SHORT $LN3@init

; 180  : 			_Addstd(this);	// special handling for standard streams

  00110	56		 push	 esi
  00111	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  00116	83 c4 04	 add	 esp, 4
$LN3@init:

; 181  : 		}

  00119	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00123	59		 pop	 ecx
  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 08 00	 ret	 8
$LN75@init:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z$1:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__ehhandler$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
_TEXT	SEGMENT
$T2 = -20						; size = 8
__$EHRec$ = -12						; size = 12
__Byte$ = 8						; size = 1
?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::widen, COMDAT
; _this$ = ecx

; 130  : 		{	// convert _Byte to character using imbued locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 131  : 		const _Ctype& _Ctype_fac = _USE(getloc(), _Ctype);

  00026	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  0002f	50		 push	 eax
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00037	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  0003c	83 c4 04	 add	 esp, 4
  0003f	8b f0		 mov	 esi, eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp+4]
  00044	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0004b	85 c9		 test	 ecx, ecx
  0004d	74 11		 je	 SHORT $LN7@widen
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	ff 52 08	 call	 DWORD PTR [edx+8]
  00054	85 c0		 test	 eax, eax
  00056	74 08		 je	 SHORT $LN7@widen
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b c8		 mov	 ecx, eax
  0005c	6a 01		 push	 1
  0005e	ff 12		 call	 DWORD PTR [edx]
$LN7@widen:

; 132  : 		return (_Ctype_fac.widen(_Byte));

  00060	8b 06		 mov	 eax, DWORD PTR [esi]
  00062	8b ce		 mov	 ecx, esi
  00064	ff 75 08	 push	 DWORD PTR __Byte$[ebp]
  00067	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006e	ff 50 30	 call	 DWORD PTR [eax+48]

; 133  : 		}

  00071	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00074	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007b	59		 pop	 ecx
  0007c	5e		 pop	 esi
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z$1:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__ehhandler$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::widen
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
_TEXT	SEGMENT
?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::fill, COMDAT
; _this$ = ecx

; 113  : 		return (_Fillch);

  00000	66 8b 41 40	 mov	 ax, WORD PTR [ecx+64]

; 114  : 		}

  00004	c3		 ret	 0
?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::fill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf, COMDAT
; _this$ = ecx

; 92   : 		return (_Mystrbuf);

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]

; 93   : 		}

  00003	c3		 ret	 0
?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::tie, COMDAT
; _this$ = ecx

; 80   : 		return (_Tiestr);

  00000	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]

; 81   : 		}

  00003	c3		 ret	 0
?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::tie
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate, COMDAT
; _this$ = ecx

; 58   : 		{	// merge _State into state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 59   : 		if (_State != goodbit)

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 1a		 je	 SHORT $LN2@setstate

; 60   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

  0000a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0000d	ff 75 0c	 push	 DWORD PTR __Reraise$[ebp]
  00010	0b d0		 or	 edx, eax
  00012	8b c2		 mov	 eax, edx
  00014	83 c8 04	 or	 eax, 4
  00017	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0001b	0f 45 c2	 cmovne	 eax, edx
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN2@setstate:

; 61   : 		}

  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::clear, COMDAT
; _this$ = ecx

; 44   : 		{	// set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __State$[ebp]

; 45   : 		ios_base::clear((iostate)(_Mystrbuf == 0

  00006	ff 75 0c	 push	 DWORD PTR __Reraise$[ebp]
  00009	83 ca 04	 or	 edx, 4
  0000c	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00010	0f 45 55 08	 cmovne	 edx, DWORD PTR __State$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);
; 47   : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 39   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 40   : 		}

  00022	51		 push	 ecx
  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
  00030	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00035	83 c4 04	 add	 esp, 4
  00038	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00042	59		 pop	 ecx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IBEXPAUSecurityTokenKeyfile@GostCrypt@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IBEXPAUSecurityTokenKeyfile@GostCrypt@@0@Z PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1794 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IBEXPAUSecurityTokenKeyfile@GostCrypt@@0@Z ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IBEXXZ PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Xlen, COMDAT
; _this$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IBEXXZ ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXXZ PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi

; 1637 : 		if (this->_Myfirst() != pointer())

  00004	8b 33		 mov	 esi, DWORD PTR [ebx]
  00006	85 f6		 test	 esi, esi
  00008	74 4e		 je	 SHORT $LN2@Tidy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  0000a	57		 push	 edi
  0000b	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  0000e	3b f7		 cmp	 esi, edi
  00010	74 0e		 je	 SHORT $LN43@Tidy
$LL44@Tidy:
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ??1SecurityTokenKeyfile@GostCrypt@@QAE@XZ
  00019	83 c6 70	 add	 esi, 112		; 00000070H
  0001c	3b f7		 cmp	 esi, edi
  0001e	75 f2		 jne	 SHORT $LL44@Tidy
$LN43@Tidy:

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

  00020	8b 33		 mov	 esi, DWORD PTR [ebx]
  00022	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00027	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0002a	2b ce		 sub	 ecx, esi
  0002c	f7 e9		 imul	 ecx
  0002e	03 d1		 add	 edx, ecx
  00030	8b cb		 mov	 ecx, ebx
  00032	c1 fa 06	 sar	 edx, 6
  00035	8b c2		 mov	 eax, edx
  00037	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003a	03 c2		 add	 eax, edx
  0003c	50		 push	 eax
  0003d	56		 push	 esi
  0003e	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@I@Z ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::deallocate

; 1642 : 				this->_Myend() - this->_Myfirst());
; 1643 : 			this->_Myfirst() = pointer();

  00043	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0

; 1644 : 			this->_Mylast() = pointer();

  00049	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1645 : 			this->_Myend() = pointer();

  00050	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  00057	5f		 pop	 edi
$LN2@Tidy:

; 1646 : 			}
; 1647 : 		}

  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	c3		 ret	 0
?_Tidy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXXZ ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv275 = 8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 1627 : 		if (_Unused_capacity() < _Count)

  00006	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  00010	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00013	2b f7		 sub	 esi, edi
  00015	f7 ee		 imul	 esi
  00017	03 d6		 add	 edx, esi
  00019	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  0001c	c1 fa 06	 sar	 edx, 6
  0001f	8b c2		 mov	 eax, edx
  00021	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00024	03 c2		 add	 eax, edx
  00026	3b c6		 cmp	 eax, esi
  00028	73 62		 jae	 SHORT $LN2@Reserve

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

  0002a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0002c	2b f8		 sub	 edi, eax
  0002e	89 45 08	 mov	 DWORD PTR tv275[ebp], eax
  00031	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00036	f7 ef		 imul	 edi
  00038	b8 92 24 49 02	 mov	 eax, 38347922		; 02492492H
  0003d	03 d7		 add	 edx, edi
  0003f	c1 fa 06	 sar	 edx, 6
  00042	8b ca		 mov	 ecx, edx
  00044	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00047	03 ca		 add	 ecx, edx
  00049	2b c1		 sub	 eax, ecx
  0004b	3b c6		 cmp	 eax, esi
  0004d	72 44		 jb	 SHORT $LN134@Reserve

; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

  0004f	8d 3c 31	 lea	 edi, DWORD PTR [ecx+esi]
  00052	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00057	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0005a	2b 4d 08	 sub	 ecx, DWORD PTR tv275[ebp]
  0005d	f7 e9		 imul	 ecx
  0005f	03 d1		 add	 edx, ecx
  00061	33 c9		 xor	 ecx, ecx
  00063	c1 fa 06	 sar	 edx, 6
  00066	8b f2		 mov	 esi, edx
  00068	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0006b	03 f2		 add	 esi, edx
  0006d	ba 92 24 49 02	 mov	 edx, 38347922		; 02492492H
  00072	8b c6		 mov	 eax, esi
  00074	d1 e8		 shr	 eax, 1
  00076	2b d0		 sub	 edx, eax
  00078	03 c6		 add	 eax, esi
  0007a	3b d6		 cmp	 edx, esi
  0007c	0f 43 c8	 cmovae	 ecx, eax
  0007f	3b cf		 cmp	 ecx, edi
  00081	0f 43 f9	 cmovae	 edi, ecx
  00084	8b cb		 mov	 ecx, ebx
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Reallocate
$LN2@Reserve:
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx

; 1632 : 			}
; 1633 : 		}

  0008f	5d		 pop	 ebp
  00090	c2 04 00	 ret	 4
$LN134@Reserve:

; 1630 : 				_Xlen();

  00093	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00098	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN136@Reserve:
$LN133@Reserve:
  0009d	cc		 int	 3
?_Reserve@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
__Size$1$ = -24						; size = 4
__Ptr$ = -24						; size = 4
__Last$1$ = -20						; size = 4
$T2 = -20						; size = 1
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d e4	 mov	 DWORD PTR _this$[ebp], edi

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  00030	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEPAUSecurityTokenKeyfile@GostCrypt@@I@Z ; std::allocator<GostCrypt::SecurityTokenKeyfile>::allocate

; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);

  00038	51		 push	 ecx
  00039	c6 45 ec 00	 mov	 BYTE PTR $T2[ebp], 0
  0003d	8b d8		 mov	 ebx, eax
  0003f	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00042	89 5d e8	 mov	 DWORD PTR __Ptr$[ebp], ebx
  00045	57		 push	 edi
  00046	53		 push	 ebx
  00047	ff 77 04	 push	 DWORD PTR [edi+4]
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00051	ff 37		 push	 DWORD PTR [edi]
  00053	e8 00 00 00 00	 call	 ??$_Uninitialized_move_al_unchecked1@PAUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<GostCrypt::SecurityTokenKeyfile *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >

; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();

  00058	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0005b	83 c4 18	 add	 esp, 24			; 00000018H
  0005e	8b 37		 mov	 esi, DWORD PTR [edi]
  00060	8b c8		 mov	 ecx, eax
  00062	89 45 ec	 mov	 DWORD PTR __Last$1$[ebp], eax
  00065	2b ce		 sub	 ecx, esi
  00067	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0006c	f7 e9		 imul	 ecx
  0006e	03 d1		 add	 edx, ecx
  00070	c1 fa 06	 sar	 edx, 6
  00073	8b c2		 mov	 eax, edx
  00075	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00078	03 c2		 add	 eax, edx
  0007a	89 45 e8	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1612 : 		if (this->_Myfirst() != pointer())

  0007d	85 f6		 test	 esi, esi
  0007f	74 37		 je	 SHORT $LN3@Reallocate

; 1613 : 			{	// destroy and deallocate old array
; 1614 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  00081	3b 75 ec	 cmp	 esi, DWORD PTR __Last$1$[ebp]
  00084	74 0f		 je	 SHORT $LN126@Reallocate
$LL127@Reallocate:
  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 ??1SecurityTokenKeyfile@GostCrypt@@QAE@XZ
  0008d	83 c6 70	 add	 esi, 112		; 00000070H
  00090	3b 75 ec	 cmp	 esi, DWORD PTR __Last$1$[ebp]
  00093	75 f1		 jne	 SHORT $LL127@Reallocate
$LN126@Reallocate:

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

  00095	8b 37		 mov	 esi, DWORD PTR [edi]
  00097	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0009c	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0009f	2b ce		 sub	 ecx, esi
  000a1	f7 e9		 imul	 ecx
  000a3	03 d1		 add	 edx, ecx
  000a5	8b cf		 mov	 ecx, edi
  000a7	c1 fa 06	 sar	 edx, 6
  000aa	8b c2		 mov	 eax, edx
  000ac	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000af	03 c2		 add	 eax, edx
  000b1	50		 push	 eax
  000b2	56		 push	 esi
  000b3	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@I@Z ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::deallocate
$LN3@Reallocate:

; 1616 : 				this->_Myend() - this->_Myfirst());
; 1617 : 			}
; 1618 : 
; 1619 : 		this->_Orphan_all();
; 1620 : 		this->_Myend() = _Ptr + _Count;

  000b8	6b 45 08 70	 imul	 eax, DWORD PTR __Count$[ebp], 112
  000bc	03 c3		 add	 eax, ebx
  000be	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1621 : 		this->_Mylast() = _Ptr + _Size;

  000c1	6b 45 e8 70	 imul	 eax, DWORD PTR __Size$1$[ebp], 112
  000c5	03 c3		 add	 eax, ebx
  000c7	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1622 : 		this->_Myfirst() = _Ptr;

  000ca	89 1f		 mov	 DWORD PTR [edi], ebx

; 1623 : 		}

  000cc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000cf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d6	59		 pop	 ecx
  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z$0:

; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);

  000e0	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  000e3	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	ff 75 e8	 push	 DWORD PTR __Ptr$[ebp]
  000e9	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@I@Z ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::deallocate

; 1608 : 		_RERAISE;

  000ee	6a 00		 push	 0
  000f0	6a 00		 push	 0
  000f2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN207@Reallocate:
$LN206@Reallocate:
  000f7	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Reallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IBE_NPBUSecurityTokenKeyfile@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IBE_NPBUSecurityTokenKeyfile@GostCrypt@@@Z PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Inside, COMDAT
; _this$ = ecx

; 1596 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1598 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1598 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IBE_NPBUSecurityTokenKeyfile@GostCrypt@@@Z ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IBEII@Z PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1586 : 		size_type _Capacity = capacity();

  00004	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00007	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000c	2b 31		 sub	 esi, DWORD PTR [ecx]
  0000e	f7 ee		 imul	 esi
  00010	03 d6		 add	 edx, esi
  00012	c1 fa 06	 sar	 edx, 6
  00015	8b f2		 mov	 esi, edx
  00017	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001a	03 f2		 add	 esi, edx

; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0001c	ba 92 24 49 02	 mov	 edx, 38347922		; 02492492H
  00021	8b c6		 mov	 eax, esi
  00023	d1 e8		 shr	 eax, 1
  00025	2b d0		 sub	 edx, eax
  00027	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  0002a	33 c0		 xor	 eax, eax
  0002c	3b d6		 cmp	 edx, esi
  0002e	5e		 pop	 esi
  0002f	0f 43 c1	 cmovae	 eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

  00032	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00035	0f 42 45 08	 cmovb	 eax, DWORD PTR __Count$[ebp]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Grow_to@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IBEII@Z ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXPAUSecurityTokenKeyfile@GostCrypt@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXPAUSecurityTokenKeyfile@GostCrypt@@0@Z PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Destroy, COMDAT
; _this$ = ecx

; 1580 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 0f		 je	 SHORT $LN13@Destroy
  0000f	90		 npad	 1
$LL14@Destroy:
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1SecurityTokenKeyfile@GostCrypt@@QAE@XZ
  00017	83 c6 70	 add	 esi, 112		; 00000070H
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $LL14@Destroy
$LN13@Destroy:
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 1582 : 		}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?_Destroy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXPAUSecurityTokenKeyfile@GostCrypt@@0@Z ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAE_NI@Z PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Buy, COMDAT
; _this$ = ecx

; 1561 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1562 : 		this->_Myfirst() = pointer();
; 1563 : 		this->_Mylast() = pointer();
; 1564 : 		this->_Myend() = pointer();
; 1565 : 
; 1566 : 		if (_Capacity == 0)

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Capacity$[ebp]
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00010	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00017	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001e	85 ff		 test	 edi, edi
  00020	75 08		 jne	 SHORT $LN2@Buy

; 1567 : 			return (false);

  00022	5f		 pop	 edi
  00023	32 c0		 xor	 al, al
  00025	5e		 pop	 esi

; 1577 : 		}

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN2@Buy:

; 1568 : 		else if (max_size() < _Capacity)

  0002a	81 ff 92 24 49
	02		 cmp	 edi, 38347922		; 02492492H
  00030	77 1b		 ja	 SHORT $LN109@Buy

; 1570 : 		else
; 1571 : 			{	// nonempty array, allocate storage
; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEPAUSecurityTokenKeyfile@GostCrypt@@I@Z ; std::allocator<GostCrypt::SecurityTokenKeyfile>::allocate
  00038	89 06		 mov	 DWORD PTR [esi], eax

; 1573 : 			this->_Mylast() = this->_Myfirst();

  0003a	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

  0003d	6b c7 70	 imul	 eax, edi, 112
  00040	5f		 pop	 edi
  00041	03 06		 add	 eax, DWORD PTR [esi]
  00043	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1575 : 			}
; 1576 : 		return (true);

  00046	b0 01		 mov	 al, 1
  00048	5e		 pop	 esi

; 1577 : 		}

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
$LN109@Buy:

; 1569 : 			_Xlen();	// result too long

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00052	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN111@Buy:
$LN108@Buy:
  00057	cc		 int	 3
?_Buy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXABUSecurityTokenKeyfile@GostCrypt@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
$T5 = 8							; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXABUSecurityTokenKeyfile@GostCrypt@@@Z PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::push_back, COMDAT
; _this$ = ecx

; 1276 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?push_back@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXABUSecurityTokenKeyfile@GostCrypt@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx

; 1277 : 		if (_Inside(_STD addressof(_Val)))

  00027	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0002d	3b f9		 cmp	 edi, ecx
  0002f	73 45		 jae	 SHORT $LN2@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	3b c7		 cmp	 eax, edi
  00035	77 3f		 ja	 SHORT $LN2@push_back

; 1278 : 			{	// push back an element
; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

  00037	2b f8		 sub	 edi, eax
  00039	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0003e	f7 ef		 imul	 edi
  00040	03 d7		 add	 edx, edi
  00042	c1 fa 06	 sar	 edx, 6
  00045	8b fa		 mov	 edi, edx
  00047	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0004a	03 fa		 add	 edi, edx

; 1280 : 			if (this->_Mylast() == this->_Myend())

  0004c	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0004f	75 09		 jne	 SHORT $LN4@push_back

; 1281 : 				_Reserve(1);

  00051	6a 01		 push	 1
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?_Reserve@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Reserve
$LN4@push_back:

; 1282 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

  0005a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005d	6b c7 70	 imul	 eax, edi, 112
  00060	89 4d 08	 mov	 DWORD PTR $T5[ebp], ecx
  00063	89 4d f0	 mov	 DWORD PTR $T3[ebp], ecx
  00066	03 06		 add	 eax, DWORD PTR [esi]
  00068	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006f	85 c9		 test	 ecx, ecx
  00071	74 2b		 je	 SHORT $LN210@push_back
  00073	50		 push	 eax

; 1284 : 				this->_Myfirst()[_Idx]);
; 1285 : 			++this->_Mylast();
; 1286 : 			}
; 1287 : 		else

  00074	eb 23		 jmp	 SHORT $LN229@push_back
$LN2@push_back:

; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

  00076	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00079	75 09		 jne	 SHORT $LN5@push_back

; 1290 : 				_Reserve(1);

  0007b	6a 01		 push	 1
  0007d	8b ce		 mov	 ecx, esi
  0007f	e8 00 00 00 00	 call	 ?_Reserve@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXI@Z ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Reserve
$LN5@push_back:

; 1291 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1292 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

  00084	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00087	89 4d 08	 mov	 DWORD PTR $T4[ebp], ecx
  0008a	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  0008d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00094	85 c9		 test	 ecx, ecx
  00096	74 06		 je	 SHORT $LN210@push_back
  00098	57		 push	 edi
$LN229@push_back:
  00099	e8 00 00 00 00	 call	 ??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z
$LN210@push_back:

; 1293 : 				_Val);
; 1294 : 			++this->_Mylast();

  0009e	83 46 04 70	 add	 DWORD PTR [esi+4], 112	; 00000070H

; 1295 : 			}
; 1296 : 		}

  000a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ac	59		 pop	 ecx
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXABUSecurityTokenKeyfile@GostCrypt@@@Z$33:
  00000	8b 45 08	 mov	 eax, DWORD PTR $T5[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__unwindfunclet$?push_back@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXABUSecurityTokenKeyfile@GostCrypt@@@Z$57:
  00011	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  00014	50		 push	 eax
  00015	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0001e	83 c4 08	 add	 esp, 8
  00021	c3		 ret	 0
__ehhandler$?push_back@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXABUSecurityTokenKeyfile@GostCrypt@@@Z:
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?push_back@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXABUSecurityTokenKeyfile@GostCrypt@@@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?push_back@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXABUSecurityTokenKeyfile@GostCrypt@@@Z ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::push_back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?front@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEAAUSecurityTokenKeyfile@GostCrypt@@XZ
_TEXT	SEGMENT
?front@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEAAUSecurityTokenKeyfile@GostCrypt@@XZ PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::front, COMDAT
; _this$ = ecx

; 1257 : 		return (*begin());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1258 : 		}

  00002	c3		 ret	 0
?front@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEAAUSecurityTokenKeyfile@GostCrypt@@XZ ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?empty@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBE_NXZ PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::empty, COMDAT
; _this$ = ecx

; 1189 : 		{	// test if sequence is empty

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00005	0f 94 c0	 sete	 al

; 1190 : 		return (this->_Myfirst() == this->_Mylast());
; 1191 : 		}

  00008	c3		 ret	 0
?empty@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBE_NXZ ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBEIXZ PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::max_size, COMDAT
; _this$ = ecx

; 1185 : 		return (this->_Getal().max_size());

  00000	b8 92 24 49 02	 mov	 eax, 38347922		; 02492492H

; 1186 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBEIXZ ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBEIXZ PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::size, COMDAT
; _this$ = ecx

; 1179 : 		{	// return length of sequence

  00000	56		 push	 esi

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

  00001	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00004	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00009	2b 31		 sub	 esi, DWORD PTR [ecx]
  0000b	f7 ee		 imul	 esi
  0000d	03 d6		 add	 edx, esi
  0000f	c1 fa 06	 sar	 edx, 6
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx
  00019	5e		 pop	 esi

; 1181 : 		}

  0001a	c3		 ret	 0
?size@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBEIXZ ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::end, COMDAT
; _this$ = ecx

; 1072 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1073 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1074 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::begin, COMDAT
; _this$ = ecx

; 1062 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1063 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1064 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::begin, COMDAT
; _this$ = ecx

; 1057 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1058 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1059 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBEIXZ PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1047 : 		{	// micro-optimization for capacity() - size()

  00000	56		 push	 esi

; 1048 : 		return (this->_Myend() - this->_Mylast());

  00001	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00004	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00009	2b 71 04	 sub	 esi, DWORD PTR [ecx+4]
  0000c	f7 ee		 imul	 esi
  0000e	03 d6		 add	 edx, esi
  00010	c1 fa 06	 sar	 edx, 6
  00013	8b c2		 mov	 eax, edx
  00015	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00018	03 c2		 add	 eax, edx
  0001a	5e		 pop	 esi

; 1049 : 		}

  0001b	c3		 ret	 0
?_Unused_capacity@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBEIXZ ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBEIXZ PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::capacity, COMDAT
; _this$ = ecx

; 1042 : 		{	// return current length of allocated storage

  00000	56		 push	 esi

; 1043 : 		return (this->_Myend() - this->_Myfirst());

  00001	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00004	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00009	2b 31		 sub	 esi, DWORD PTR [ecx]
  0000b	f7 ee		 imul	 esi
  0000d	03 d6		 add	 edx, esi
  0000f	c1 fa 06	 sar	 edx, 6
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx
  00019	5e		 pop	 esi

; 1044 : 		}

  0001a	c3		 ret	 0
?capacity@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBEIXZ ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::~vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >, COMDAT
; _this$ = ecx

; 976  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Tidy
??1?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::~vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Assign_rv@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Assign_rv, COMDAT
; _this$ = ecx

; 868  : 		{	// move from _Right, stealing its contents

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 869  : 		this->_Swap_all((_Myt&)_Right);
; 870  : 		this->_Myfirst() = _Right._Myfirst();

  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 871  : 		this->_Mylast() = _Right._Mylast();

  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 872  : 		this->_Myend() = _Right._Myend();

  00010	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00013	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 873  : 
; 874  : 		_Right._Myfirst() = pointer();

  00016	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 875  : 		_Right._Mylast() = pointer();

  0001c	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 876  : 		_Right._Myend() = pointer();

  00023	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 877  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?_Assign_rv@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >, COMDAT
; _this$ = ecx

; 841  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 842  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());

  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0000c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00013	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	89 01		 mov	 DWORD PTR [ecx], eax
  0001e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00021	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00024	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00027	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 843  : 		}

  0002a	8b c1		 mov	 eax, ecx
  0002c	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00032	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  00039	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 1
__Right$ = 8						; size = 4
??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >, COMDAT
; _this$ = ecx

; 748  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 749  : 		if (_Buy(_Right.size()))

  00030	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00033	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0003e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00045	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0004c	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0004f	2b 0b		 sub	 ecx, DWORD PTR [ebx]
  00051	f7 e9		 imul	 ecx
  00053	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00059	03 d1		 add	 edx, ecx
  0005b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00062	c1 fa 06	 sar	 edx, 6
  00065	8b fa		 mov	 edi, edx
  00067	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0006e	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00071	03 fa		 add	 edi, edx
  00073	74 49		 je	 SHORT $LN7@vector
  00075	81 ff 92 24 49
	02		 cmp	 edi, 38347922		; 02492492H
  0007b	76 0a		 jbe	 SHORT $LN58@vector
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00082	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN257@vector:
$LN58@vector:
  00087	57		 push	 edi
  00088	8b ce		 mov	 ecx, esi
  0008a	e8 00 00 00 00	 call	 ?allocate@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEPAUSecurityTokenKeyfile@GostCrypt@@I@Z ; std::allocator<GostCrypt::SecurityTokenKeyfile>::allocate
  0008f	89 06		 mov	 DWORD PTR [esi], eax
  00091	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 750  : 			_TRY_BEGIN
; 751  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),

  00094	51		 push	 ecx
  00095	6b c7 70	 imul	 eax, edi, 112
  00098	c6 45 08 00	 mov	 BYTE PTR $T2[ebp], 0
  0009c	ff 75 08	 push	 DWORD PTR $T2[ebp]
  0009f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000a6	56		 push	 esi
  000a7	03 06		 add	 eax, DWORD PTR [esi]
  000a9	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000ac	ff 36		 push	 DWORD PTR [esi]
  000ae	ff 73 04	 push	 DWORD PTR [ebx+4]
  000b1	ff 33		 push	 DWORD PTR [ebx]
  000b3	e8 00 00 00 00	 call	 ??$_Uninitialized_copy_al_unchecked1@PBUSecurityTokenKeyfile@GostCrypt@@PAU12@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@YAPAUSecurityTokenKeyfile@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::SecurityTokenKeyfile const *,GostCrypt::SecurityTokenKeyfile *,std::allocator<GostCrypt::SecurityTokenKeyfile> >
  000b8	83 c4 18	 add	 esp, 24			; 00000018H
  000bb	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN7@vector:

; 756  : 			_CATCH_END
; 757  : 		}

  000be	8b c6		 mov	 eax, esi
  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c2 04 00	 ret	 4
__catch$??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$0:

; 752  : 				this->_Myfirst());
; 753  : 			_CATCH_ALL
; 754  : 			_Tidy();

  000d4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Tidy

; 755  : 			_RERAISE;

  000dc	6a 00		 push	 0
  000de	6a 00		 push	 0
  000e0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN258@vector:
$LN256@vector:
  000e5	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >, COMDAT
; _this$ = ecx

; 706  : 		: _Mybase()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 708  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >,std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 489  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >::_Vector_val<std::_Simple_types<GostCrypt::SecurityTokenKeyfile> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABQAUSecurityTokenKeyfile@GostCrypt@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABQAUSecurityTokenKeyfile@GostCrypt@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 669  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABQAUSecurityTokenKeyfile@GostCrypt@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAPAUSecurityTokenKeyfile@GostCrypt@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAPAUSecurityTokenKeyfile@GostCrypt@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 664  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAPAUSecurityTokenKeyfile@GostCrypt@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABQAUSecurityTokenKeyfile@GostCrypt@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABQAUSecurityTokenKeyfile@GostCrypt@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 659  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABQAUSecurityTokenKeyfile@GostCrypt@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAPAUSecurityTokenKeyfile@GostCrypt@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAPAUSecurityTokenKeyfile@GostCrypt@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 654  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAPAUSecurityTokenKeyfile@GostCrypt@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABQAUSecurityTokenKeyfile@GostCrypt@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABQAUSecurityTokenKeyfile@GostCrypt@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 649  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABQAUSecurityTokenKeyfile@GostCrypt@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAPAUSecurityTokenKeyfile@GostCrypt@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAPAUSecurityTokenKeyfile@GostCrypt@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 644  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAPAUSecurityTokenKeyfile@GostCrypt@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 639  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 634  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 629  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 624  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Swap_all, COMDAT
; _this$ = ecx

; 618  : 		_Get_data()._Swap_all(_Right._Get_data());
; 619  : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >, COMDAT
; _this$ = ecx

; 519  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 521  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >::_Vector_alloc<std::_Vec_base_types<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	b8 92 24 49 02	 mov	 eax, 38347922		; 02492492H

; 1009 : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@I@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d 92 24 49 02	 cmp	 eax, 38347922		; 02492492H
  0000e	77 31		 ja	 SHORT $LN16@deallocate
  00010	6b c0 70	 imul	 eax, eax, 112
  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN7@deallocate
  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN18@deallocate
  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN19@deallocate
  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN20@deallocate
  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN21@deallocate
  00032	8b c8		 mov	 ecx, eax
$LN7@deallocate:
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 988  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:
  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:
  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:
  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  0005a	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEPAUSecurityTokenKeyfile@GostCrypt@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEPAUSecurityTokenKeyfile@GostCrypt@@I@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 977  : 		}

  00003	5d		 pop	 ebp

; 976  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEPAUSecurityTokenKeyfile@GostCrypt@@I@Z ; std::allocator<GostCrypt::SecurityTokenKeyfile>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEPAUSecurityTokenKeyfile@GostCrypt@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SA?AV?$allocator@USecurityTokenKeyfile@GostCrypt@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SA?AV?$allocator@USecurityTokenKeyfile@GostCrypt@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<GostCrypt::SecurityTokenKeyfile> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SA?AV?$allocator@USecurityTokenKeyfile@GostCrypt@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<GostCrypt::SecurityTokenKeyfile> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAIABV?$allocator@USecurityTokenKeyfile@GostCrypt@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAIABV?$allocator@USecurityTokenKeyfile@GostCrypt@@@2@@Z PROC ; std::allocator_traits<std::allocator<GostCrypt::SecurityTokenKeyfile> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	b8 92 24 49 02	 mov	 eax, 38347922		; 02492492H

; 870  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@SAIABV?$allocator@USecurityTokenKeyfile@GostCrypt@@@2@@Z ENDP ; std::allocator_traits<std::allocator<GostCrypt::SecurityTokenKeyfile> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QBEIXZ PROC ; std::allocator<GostCrypt::SecurityTokenKeyfile>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 92 24 49 02	 mov	 eax, 38347922		; 02492492H

; 750  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QBEIXZ ENDP ; std::allocator<GostCrypt::SecurityTokenKeyfile>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEPAUSecurityTokenKeyfile@GostCrypt@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEPAUSecurityTokenKeyfile@GostCrypt@@I@Z PROC ; std::allocator<GostCrypt::SecurityTokenKeyfile>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d 92 24 49 02	 cmp	 eax, 38347922		; 02492492H
  00013	77 3c		 ja	 SHORT $LN14@allocate
  00015	6b c0 70	 imul	 eax, eax, 112
  00018	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001d	72 23		 jb	 SHORT $LN6@allocate
  0001f	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00022	3b c8		 cmp	 ecx, eax
  00024	76 30		 jbe	 SHORT $LN16@allocate
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002c	8b c8		 mov	 ecx, eax
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c9		 test	 ecx, ecx
  00033	74 26		 je	 SHORT $LN17@allocate
  00035	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00038	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0003b	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00048	83 c4 04	 add	 esp, 4
  0004b	85 c0		 test	 eax, eax
  0004d	75 bb		 jne	 SHORT $LN12@allocate
  0004f	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:
  00051	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:
  00056	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:
  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:
  00060	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00065	cc		 int	 3
?allocate@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEPAUSecurityTokenKeyfile@GostCrypt@@I@Z ENDP ; std::allocator<GostCrypt::SecurityTokenKeyfile>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@I@Z PROC ; std::allocator<GostCrypt::SecurityTokenKeyfile>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d 92 24 49 02	 cmp	 eax, 38347922		; 02492492H
  0000e	77 31		 ja	 SHORT $LN13@deallocate
  00010	6b c0 70	 imul	 eax, eax, 112
  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN5@deallocate
  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN15@deallocate
  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN16@deallocate
  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN17@deallocate
  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN18@deallocate
  00032	8b c8		 mov	 ecx, eax
$LN5@deallocate:
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 721  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:
  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:
  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:
  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005a	cc		 int	 3
?deallocate@?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@I@Z ENDP ; std::allocator<GostCrypt::SecurityTokenKeyfile>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAE@ABV01@@Z PROC ; std::allocator<GostCrypt::SecurityTokenKeyfile>::allocator<GostCrypt::SecurityTokenKeyfile>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<GostCrypt::SecurityTokenKeyfile>::allocator<GostCrypt::SecurityTokenKeyfile>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAE@XZ PROC ; std::allocator<GostCrypt::SecurityTokenKeyfile>::allocator<GostCrypt::SecurityTokenKeyfile>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@QAE@XZ ENDP ; std::allocator<GostCrypt::SecurityTokenKeyfile>::allocator<GostCrypt::SecurityTokenKeyfile>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?CheckLibraryStatus@SecurityToken@GostCrypt@@KAXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?CheckLibraryStatus@SecurityToken@GostCrypt@@KAXXZ PROC	; GostCrypt::SecurityToken::CheckLibraryStatus, COMDAT

; 85   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 86   : 		if (!Initialized)

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?Initialized@SecurityToken@GostCrypt@@1_NA, 0 ; GostCrypt::SecurityToken::Initialized
  0000b	74 04		 je	 SHORT $LN11@CheckLibra

; 88   : 	}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN11@CheckLibra:

; 87   : 			throw SecurityTokenLibraryNotInitialized();

  00011	68 00 00 00 00	 push	 OFFSET __TI2?AUSecurityTokenLibraryNotInitialized@GostCrypt@@
  00016	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  00019	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7SecurityTokenLibraryNotInitialized@GostCrypt@@6B@
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@CheckLibra:
$LN10@CheckLibra:
  00026	cc		 int	 3
?CheckLibraryStatus@SecurityToken@GostCrypt@@KAXXZ ENDP	; GostCrypt::SecurityToken::CheckLibraryStatus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?OpenSession@SecurityToken@GostCrypt@@KAXK@Z
_TEXT	SEGMENT
$T1 = -100						; size = 24
$T2 = -76						; size = 8
_session$ = -68						; size = 4
_slotId$GSCopy$ = -64					; size = 4
$T3 = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_slotId$ = 8						; size = 4
?OpenSession@SecurityToken@GostCrypt@@KAXK@Z PROC	; GostCrypt::SecurityToken::OpenSession, COMDAT

; 707  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _slotId$[ebp]
  00013	56		 push	 esi

; 708  : 		if (Sessions.find (slotId) != Sessions.end())

  00014	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A
  0001a	8b d6		 mov	 edx, esi
  0001c	89 4d c0	 mov	 DWORD PTR _slotId$GSCopy$[ebp], ecx
  0001f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00022	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00026	75 1d		 jne	 SHORT $LN245@OpenSessio
$LL55@OpenSessio:
  00028	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  0002b	73 05		 jae	 SHORT $LN57@OpenSessio
  0002d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00030	eb 04		 jmp	 SHORT $LN58@OpenSessio
$LN57@OpenSessio:
  00032	8b d0		 mov	 edx, eax
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
$LN58@OpenSessio:
  00036	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0003a	74 ec		 je	 SHORT $LL55@OpenSessio
  0003c	3b d6		 cmp	 edx, esi
  0003e	74 05		 je	 SHORT $LN245@OpenSessio
  00040	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  00043	73 65		 jae	 SHORT $LN1@OpenSessio
$LN245@OpenSessio:
  00045	53		 push	 ebx

; 709  : 			return;
; 710  : 
; 711  : 		CK_SESSION_HANDLE session;
; 712  : 
; 713  : 		CK_FLAGS flags = CKF_SERIAL_SESSION;
; 714  : 
; 715  : 		if (!(GetTokenInfo (slotId).Flags & CKF_WRITE_PROTECTED))

  00046	51		 push	 ecx
  00047	8d 45 c4	 lea	 eax, DWORD PTR $T3[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z ; GostCrypt::SecurityToken::GetTokenInfo
  00050	83 c4 08	 add	 esp, 8
  00053	8d 4d c4	 lea	 ecx, DWORD PTR $T3[ebp]
  00056	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00059	d1 eb		 shr	 ebx, 1
  0005b	f6 d3		 not	 bl
  0005d	e8 00 00 00 00	 call	 ??1SecurityTokenInfo@GostCrypt@@QAE@XZ

; 716  : 			 flags |= CKF_RW_SESSION;
; 717  : 
; 718  : 		CK_RV status = Pkcs11Functions->C_OpenSession (slotId, flags, NULL_PTR, NULL_PTR, &session);

  00062	8d 45 bc	 lea	 eax, DWORD PTR _session$[ebp]
  00065	50		 push	 eax
  00066	33 c0		 xor	 eax, eax
  00068	80 e3 01	 and	 bl, 1
  0006b	6a 00		 push	 0
  0006d	0f 95 c0	 setne	 al
  00070	6a 00		 push	 0
  00072	8d 04 45 04 00
	00 00		 lea	 eax, DWORD PTR [eax*2+4]
  00079	50		 push	 eax
  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  0007f	ff 75 c0	 push	 DWORD PTR _slotId$GSCopy$[ebp]
  00082	8b 40 32	 mov	 eax, DWORD PTR [eax+50]
  00085	ff d0		 call	 eax
  00087	83 c4 14	 add	 esp, 20			; 00000014H
  0008a	5b		 pop	 ebx

; 719  : 		if (status != CKR_OK)

  0008b	85 c0		 test	 eax, eax
  0008d	75 2a		 jne	 SHORT $LN247@OpenSessio

; 721  : 
; 722  : 		Sessions[slotId].Handle = session;

  0008f	8d 45 c0	 lea	 eax, DWORD PTR _slotId$GSCopy$[ebp]
  00092	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  00097	50		 push	 eax
  00098	8d 45 b4	 lea	 eax, DWORD PTR $T2[ebp]
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  000a1	8b 45 b4	 mov	 eax, DWORD PTR $T2[ebp]
  000a4	8b 4d bc	 mov	 ecx, DWORD PTR _session$[ebp]
  000a7	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN1@OpenSessio:

; 723  : 	}

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ad	33 cd		 xor	 ecx, ebp
  000af	5e		 pop	 esi
  000b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
$LN247@OpenSessio:

; 720  : 			throw Pkcs11Exception (status);

  000b9	89 45 a0	 mov	 DWORD PTR $T1[ebp+4], eax
  000bc	8d 45 9c	 lea	 eax, DWORD PTR $T1[ebp]
  000bf	68 00 00 00 00	 push	 OFFSET __TI2?AUPkcs11Exception@GostCrypt@@
  000c4	50		 push	 eax
  000c5	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  000cc	c6 45 a4 00	 mov	 BYTE PTR $T1[ebp+8], 0
  000d0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN249@OpenSessio:
$LN246@OpenSessio:
  000d5	cc		 int	 3
?OpenSession@SecurityToken@GostCrypt@@KAXK@Z ENDP	; GostCrypt::SecurityToken::OpenSession
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z
_TEXT	SEGMENT
$T2 = -380						; size = 24
_s$3 = -356						; size = 176
$T4 = -180						; size = 8
$T5 = -172						; size = 8
_e$6 = -164						; size = 4
$T7 = -160						; size = 4
$T8 = -156						; size = 4
$T9 = -152						; size = 8
$T10 = -152						; size = 8
_this$11 = -148						; size = 4
_this$ = -148						; size = 4
_finally625$12 = -148					; size = 4
_slotId$GSCopy$ = -144					; size = 4
_tokenInfo$ = -140					; size = 56
_sessionInfo$13 = -84					; size = 16
$T14 = -76						; size = 8
$T15 = -68						; size = 24
$T16 = -68						; size = 24
_pin$17 = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_slotId$ = 8						; size = 4
?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z PROC ; GostCrypt::SecurityToken::LoginUserIfRequired, COMDAT

; 575  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 70 01 00
	00		 sub	 esp, 368		; 00000170H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _slotId$[ebp]
  00034	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp], 0

; 576  : 		CheckLibraryStatus();

  0003e	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?Initialized@SecurityToken@GostCrypt@@1_NA, 0 ; GostCrypt::SecurityToken::Initialized
  00045	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _slotId$GSCopy$[ebp], ecx
  0004b	75 1b		 jne	 SHORT $LN40@LoginUserI
  0004d	68 00 00 00 00	 push	 OFFSET __TI2?AUSecurityTokenLibraryNotInitialized@GostCrypt@@
  00052	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00058	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], OFFSET ??_7SecurityTokenLibraryNotInitialized@GostCrypt@@6B@
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1147@LoginUserI:
$LN40@LoginUserI:

; 577  : 		CK_RV status;
; 578  : 
; 579  : 		if (Sessions.find (slotId) == Sessions.end())

  00068	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A
  0006e	8b d6		 mov	 edx, esi
  00070	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00073	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00077	0f 85 c1 00 00
	00		 jne	 $LN1143@LoginUserI
  0007d	0f 1f 00	 npad	 3
$LL97@LoginUserI:
  00080	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  00083	73 05		 jae	 SHORT $LN99@LoginUserI
  00085	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00088	eb 04		 jmp	 SHORT $LN100@LoginUserI
$LN99@LoginUserI:
  0008a	8b d0		 mov	 edx, eax
  0008c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN100@LoginUserI:
  0008e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00092	74 ec		 je	 SHORT $LL97@LoginUserI
  00094	3b d6		 cmp	 edx, esi
  00096	0f 84 a2 00 00
	00		 je	 $LN1143@LoginUserI
  0009c	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  0009f	0f 82 99 00 00
	00		 jb	 $LN1143@LoginUserI

; 582  : 		}
; 583  : 		else
; 584  : 		{
; 585  : 			CK_SESSION_INFO sessionInfo;
; 586  : 			status = Pkcs11Functions->C_GetSessionInfo (Sessions[slotId].Handle, &sessionInfo);

  000a5	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _slotId$GSCopy$[ebp]
  000ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  000b0	50		 push	 eax
  000b1	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  000bd	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR $T10[ebp]
  000c3	8d 4d ac	 lea	 ecx, DWORD PTR _sessionInfo$13[ebp]
  000c6	51		 push	 ecx
  000c7	ff 70 14	 push	 DWORD PTR [eax+20]
  000ca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  000cf	8b 40 3e	 mov	 eax, DWORD PTR [eax+62]
  000d2	ff d0		 call	 eax
  000d4	83 c4 08	 add	 esp, 8

; 587  : 			
; 588  : 			if (status == CKR_OK)

  000d7	85 c0		 test	 eax, eax
  000d9	75 39		 jne	 SHORT $LN6@LoginUserI

; 589  : 			{
; 590  : 				Sessions[slotId].UserLoggedIn = (sessionInfo.state == CKS_RO_USER_FUNCTIONS || sessionInfo.state == CKS_RW_USER_FUNCTIONS);

  000db	8b 45 b0	 mov	 eax, DWORD PTR _sessionInfo$13[ebp+4]
  000de	83 f8 01	 cmp	 eax, 1
  000e1	74 09		 je	 SHORT $LN18@LoginUserI
  000e3	83 f8 03	 cmp	 eax, 3
  000e6	74 04		 je	 SHORT $LN18@LoginUserI
  000e8	33 db		 xor	 ebx, ebx
  000ea	eb 05		 jmp	 SHORT $LN19@LoginUserI
$LN18@LoginUserI:
  000ec	bb 01 00 00 00	 mov	 ebx, 1
$LN19@LoginUserI:
  000f1	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _slotId$GSCopy$[ebp]
  000f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  000fc	50		 push	 eax
  000fd	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  00109	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  0010f	88 58 18	 mov	 BYTE PTR [eax+24], bl

; 591  : 			}
; 592  : 			else

  00112	eb 33		 jmp	 SHORT $LN7@LoginUserI
$LN6@LoginUserI:

; 593  : 			{
; 594  : 				try
; 595  : 				{
; 596  : 					CloseSession (slotId);

  00114	ff b5 70 ff ff
	ff		 push	 DWORD PTR _slotId$GSCopy$[ebp]
  0011a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00121	e8 00 00 00 00	 call	 ?CloseSession@SecurityToken@GostCrypt@@KAXK@Z ; GostCrypt::SecurityToken::CloseSession
  00126	83 c4 04	 add	 esp, 4
$LN32@LoginUserI:

; 599  : 				OpenSession (slotId);

  00129	ff b5 70 ff ff
	ff		 push	 DWORD PTR _slotId$GSCopy$[ebp]
  0012f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00136	eb 07		 jmp	 SHORT $LN1146@LoginUserI
__catch$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$0:

; 597  : 				}
; 598  : 				catch (...) { }

  00138	b8 00 00 00 00	 mov	 eax, $LN32@LoginUserI
  0013d	c3		 ret	 0
$LN1143@LoginUserI:

; 580  : 		{
; 581  : 			OpenSession (slotId);

  0013e	51		 push	 ecx
$LN1146@LoginUserI:
  0013f	e8 00 00 00 00	 call	 ?OpenSession@SecurityToken@GostCrypt@@KAXK@Z ; GostCrypt::SecurityToken::OpenSession
  00144	83 c4 04	 add	 esp, 4
$LN7@LoginUserI:

; 600  : 			}
; 601  : 		}
; 602  : 
; 603  : 		SecurityTokenInfo tokenInfo = GetTokenInfo (slotId);

  00147	ff b5 70 ff ff
	ff		 push	 DWORD PTR _slotId$GSCopy$[ebp]
  0014d	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _tokenInfo$[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z ; GostCrypt::SecurityToken::GetTokenInfo
  00159	83 c4 08	 add	 esp, 8
$LN36@LoginUserI:

; 604  : 
; 605  : 		while (!Sessions[slotId].UserLoggedIn && (tokenInfo.Flags & CKF_LOGIN_REQUIRED))

  0015c	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _slotId$GSCopy$[ebp]
  00162	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  00169	50		 push	 eax
  0016a	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00170	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  0017b	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  00181	80 78 18 00	 cmp	 BYTE PTR [eax+24], 0
  00185	0f 85 59 03 00
	00		 jne	 $LN3@LoginUserI
  0018b	f6 85 78 ff ff
	ff 04		 test	 BYTE PTR _tokenInfo$[ebp+4], 4
  00192	0f 84 4c 03 00
	00		 je	 $LN3@LoginUserI

; 606  : 		{
; 607  : 			try
; 608  : 			{
; 609  : 				if (tokenInfo.Flags & CKF_PROTECTED_AUTHENTICATION_PATH)

  00198	f7 85 78 ff ff
	ff 00 01 00 00	 test	 DWORD PTR _tokenInfo$[ebp+4], 256 ; 00000100H
  001a2	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  001a6	74 64		 je	 SHORT $LN10@LoginUserI

; 610  : 				{
; 611  : 					status = Pkcs11Functions->C_Login (Sessions[slotId].Handle, CKU_USER, NULL_PTR, 0);

  001a8	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _slotId$GSCopy$[ebp]
  001ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  001b3	50		 push	 eax
  001b4	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001ba	50		 push	 eax
  001bb	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  001c0	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  001c6	6a 00		 push	 0
  001c8	6a 00		 push	 0
  001ca	6a 01		 push	 1
  001cc	ff 70 14	 push	 DWORD PTR [eax+20]
  001cf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  001d4	8b 40 4a	 mov	 eax, DWORD PTR [eax+74]
  001d7	ff d0		 call	 eax
  001d9	83 c4 10	 add	 esp, 16			; 00000010H

; 612  : 					if (status != CKR_OK)

  001dc	85 c0		 test	 eax, eax
  001de	0f 84 c9 02 00
	00		 je	 $LN1075@LoginUserI

; 613  : 						throw Pkcs11Exception (status);

  001e4	89 85 88 fe ff
	ff		 mov	 DWORD PTR $T2[ebp+4], eax
  001ea	8d 85 84 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f0	68 00 00 00 00	 push	 OFFSET __TI2?AUPkcs11Exception@GostCrypt@@
  001f5	50		 push	 eax
  001f6	c7 85 84 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  00200	c6 85 8c fe ff
	ff 00		 mov	 BYTE PTR $T2[ebp+8], 0
  00207	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1148@LoginUserI:
$LN10@LoginUserI:

; 614  : 				}
; 615  : 				else
; 616  : 				{
; 617  : 					string pin = tokenInfo.LabelUtf8;

  0020c	6a ff		 push	 -1
  0020e	6a 00		 push	 0
  00210	8d 45 94	 lea	 eax, DWORD PTR _tokenInfo$[ebp+32]
  00213	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _pin$17[ebp+20], 15 ; 0000000fH
  0021a	50		 push	 eax
  0021b	8d 4d d4	 lea	 ecx, DWORD PTR _pin$17[ebp]
  0021e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pin$17[ebp+16], 0
  00225	c6 45 d4 00	 mov	 BYTE PTR _pin$17[ebp], 0
  00229	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0022e	83 7d 8c 00	 cmp	 DWORD PTR _tokenInfo$[ebp+24], 0

; 618  : 					if (tokenInfo.Label.empty())

  00232	0f 85 ee 01 00
	00		 jne	 $LN979@LoginUserI

; 619  : 					{
; 620  : 						stringstream s;

  00238	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$3[ebp], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  00242	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$3[ebp+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  0024c	83 8d 64 ff ff
	ff 01		 or	 DWORD PTR $T8[ebp], 1
  00253	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _s$3[ebp+24]
  00259	6a 00		 push	 0
  0025b	0f 57 c0	 xorps	 xmm0, xmm0
  0025e	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  00262	50		 push	 eax
  00263	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR _s$3[ebp+104]
  00269	c7 85 04 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$3[ebp+104], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00273	c7 85 00 ff ff
	ff 50 00 00 00	 mov	 DWORD PTR _s$3[ebp+100], 80 ; 00000050H
  0027d	66 0f 13 85 a4
	fe ff ff	 movlpd	 QWORD PTR _s$3[ebp+8], xmm0
  00285	e8 00 00 00 00	 call	 ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
  0028a	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _s$3[ebp+16]
  00290	89 85 6c ff ff
	ff		 mov	 DWORD PTR _this$11[ebp], eax
  00296	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _s$3[ebp+16]
  0029c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0029f	c7 84 05 ac fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _s$3[ebp+eax+16], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  002aa	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _s$3[ebp+16]
  002b0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002b3	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  002b6	89 84 0d a8 fe
	ff ff		 mov	 DWORD PTR _s$3[ebp+ecx+12], eax
  002bd	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _s$3[ebp]
  002c3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002c6	c7 84 05 9c fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _s$3[ebp+eax], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  002d1	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _s$3[ebp]
  002d7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002da	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  002dd	89 84 0d 98 fe
	ff ff		 mov	 DWORD PTR _s$3[ebp+ecx-4], eax
  002e4	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _s$3[ebp]
  002ea	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  002f1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002f4	c7 84 05 9c fe
	ff ff 00 00 00
	00		 mov	 DWORD PTR _s$3[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  002ff	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _s$3[ebp]
  00305	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00308	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  0030b	89 84 0d 98 fe
	ff ff		 mov	 DWORD PTR _s$3[ebp+ecx-4], eax
  00312	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR _s$3[ebp+24]
  00318	8b c8		 mov	 ecx, eax
  0031a	89 85 6c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
  00320	e8 00 00 00 00	 call	 ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
  00325	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$3[ebp+24], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0032f	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$3[ebp+80], 0
  00339	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$3[ebp+84], 0

; 621  : 						s << "#" << slotId;

  00343	8d 85 ac fe ff
	ff		 lea	 eax, DWORD PTR _s$3[ebp+16]
  00349	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+12], 12 ; 0000000cH
  0034d	68 00 00 00 00	 push	 OFFSET ??_C@_01IPJKGB@?$CD?$AA@
  00352	50		 push	 eax
  00353	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00358	83 c4 08	 add	 esp, 8
  0035b	8b c8		 mov	 ecx, eax
  0035d	ff b5 70 ff ff
	ff		 push	 DWORD PTR _slotId$GSCopy$[ebp]
  00363	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 622  : 						pin = s.str();

  00368	8d 45 bc	 lea	 eax, DWORD PTR $T16[ebp]
  0036b	50		 push	 eax
  0036c	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR _s$3[ebp]
  00372	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  00377	8b f0		 mov	 esi, eax
  00379	8d 45 d4	 lea	 eax, DWORD PTR _pin$17[ebp]
  0037c	3b c6		 cmp	 eax, esi
  0037e	74 30		 je	 SHORT $LN565@LoginUserI
  00380	8b 45 e8	 mov	 eax, DWORD PTR _pin$17[ebp+20]
  00383	83 f8 10	 cmp	 eax, 16			; 00000010H
  00386	72 0d		 jb	 SHORT $LN571@LoginUserI
  00388	40		 inc	 eax
  00389	8d 4d d4	 lea	 ecx, DWORD PTR _pin$17[ebp]
  0038c	50		 push	 eax
  0038d	ff 75 d4	 push	 DWORD PTR _pin$17[ebp]
  00390	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN571@LoginUserI:
  00395	56		 push	 esi
  00396	8d 4d d4	 lea	 ecx, DWORD PTR _pin$17[ebp]
  00399	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _pin$17[ebp+20], 15 ; 0000000fH
  003a0	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pin$17[ebp+16], 0
  003a7	c6 45 d4 00	 mov	 BYTE PTR _pin$17[ebp], 0
  003ab	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN565@LoginUserI:
  003b0	8b 45 d0	 mov	 eax, DWORD PTR $T16[ebp+20]
  003b3	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+12], 12 ; 0000000cH
  003b7	83 f8 10	 cmp	 eax, 16			; 00000010H
  003ba	72 42		 jb	 SHORT $LN941@LoginUserI
  003bc	8b 4d bc	 mov	 ecx, DWORD PTR $T16[ebp]
  003bf	40		 inc	 eax
  003c0	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  003c5	72 2e		 jb	 SHORT $LN936@LoginUserI
  003c7	f6 c1 1f	 test	 cl, 31			; 0000001fH
  003ca	74 05		 je	 SHORT $LN937@LoginUserI
  003cc	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1149@LoginUserI:
$LN937@LoginUserI:
  003d1	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  003d4	3b c1		 cmp	 eax, ecx
  003d6	72 05		 jb	 SHORT $LN938@LoginUserI
  003d8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1150@LoginUserI:
$LN938@LoginUserI:
  003dd	2b c8		 sub	 ecx, eax
  003df	83 f9 04	 cmp	 ecx, 4
  003e2	73 05		 jae	 SHORT $LN939@LoginUserI
  003e4	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1151@LoginUserI:
$LN939@LoginUserI:
  003e9	83 f9 23	 cmp	 ecx, 35			; 00000023H
  003ec	76 05		 jbe	 SHORT $LN940@LoginUserI
  003ee	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1152@LoginUserI:
$LN940@LoginUserI:
  003f3	8b c8		 mov	 ecx, eax
$LN936@LoginUserI:
  003f5	51		 push	 ecx
  003f6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  003fb	83 c4 04	 add	 esp, 4
$LN941@LoginUserI:

; 623  : 					}

  003fe	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR _s$3[ebp+104]
  00404	e8 00 00 00 00	 call	 ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  00409	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR _s$3[ebp+104]
  0040f	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+12], 14 ; 0000000eH
  00413	50		 push	 eax
  00414	c7 85 04 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$3[ebp+104], OFFSET ??_7ios_base@std@@6B@
  0041e	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00423	83 c4 04	 add	 esp, 4
$LN979@LoginUserI:

; 624  : 
; 625  : 					finally_do_arg (string*, &pin, { burn ((void *) finally_arg->c_str(), finally_arg->size()); });

  00426	8d 45 d4	 lea	 eax, DWORD PTR _pin$17[ebp]
  00429	89 85 6c ff ff
	ff		 mov	 DWORD PTR _finally625$12[ebp], eax

; 626  : 
; 627  : 					(*PinCallback) (pin);

  0042f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?PinCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@A ; GostCrypt::SecurityToken::PinCallback
  00435	8d 55 d4	 lea	 edx, DWORD PTR _pin$17[ebp]
  00438	52		 push	 edx
  00439	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+12], 15 ; 0000000fH
  0043d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0043f	ff 50 04	 call	 DWORD PTR [eax+4]

; 628  : 					Login (slotId, pin);

  00442	8d 45 d4	 lea	 eax, DWORD PTR _pin$17[ebp]
  00445	50		 push	 eax
  00446	ff b5 70 ff ff
	ff		 push	 DWORD PTR _slotId$GSCopy$[ebp]
  0044c	e8 00 00 00 00	 call	 ?Login@SecurityToken@GostCrypt@@KAXKABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GostCrypt::SecurityToken::Login
  00451	83 c4 08	 add	 esp, 8

; 629  : 				}

  00454	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _finally625$12[ebp]
  0045a	e8 00 00 00 00	 call	 ??1Finally625@?BI@??LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z@QAE@XZ ; `GostCrypt::SecurityToken::LoginUserIfRequired'::`24'::Finally625::~Finally625
  0045f	8b 45 e8	 mov	 eax, DWORD PTR _pin$17[ebp+20]
  00462	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  00466	83 f8 10	 cmp	 eax, 16			; 00000010H
  00469	72 42		 jb	 SHORT $LN1075@LoginUserI
  0046b	8b 4d d4	 mov	 ecx, DWORD PTR _pin$17[ebp]
  0046e	40		 inc	 eax
  0046f	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00474	72 2e		 jb	 SHORT $LN1070@LoginUserI
  00476	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00479	74 05		 je	 SHORT $LN1071@LoginUserI
  0047b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1153@LoginUserI:
$LN1071@LoginUserI:
  00480	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00483	3b c1		 cmp	 eax, ecx
  00485	72 05		 jb	 SHORT $LN1072@LoginUserI
  00487	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1154@LoginUserI:
$LN1072@LoginUserI:
  0048c	2b c8		 sub	 ecx, eax
  0048e	83 f9 04	 cmp	 ecx, 4
  00491	73 05		 jae	 SHORT $LN1073@LoginUserI
  00493	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1155@LoginUserI:
$LN1073@LoginUserI:
  00498	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0049b	76 05		 jbe	 SHORT $LN1074@LoginUserI
  0049d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1156@LoginUserI:
$LN1074@LoginUserI:
  004a2	8b c8		 mov	 ecx, eax
$LN1070@LoginUserI:
  004a4	51		 push	 ecx
  004a5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  004aa	83 c4 04	 add	 esp, 4
$LN1075@LoginUserI:

; 630  : 
; 631  : 				Sessions[slotId].UserLoggedIn = true;

  004ad	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _slotId$GSCopy$[ebp]
  004b3	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  004b8	50		 push	 eax
  004b9	8d 45 b4	 lea	 eax, DWORD PTR $T14[ebp]
  004bc	50		 push	 eax
  004bd	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  004c2	8b 45 b4	 mov	 eax, DWORD PTR $T14[ebp]
  004c5	c6 40 18 01	 mov	 BYTE PTR [eax+24], 1

; 648  : 			}
; 649  : 		}

  004c9	e9 8e fc ff ff	 jmp	 $LN36@LoginUserI
__catch$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$2:

; 632  : 			}
; 633  : 			catch (Pkcs11Exception &e)
; 634  : 			{
; 635  : 				CK_RV error = e.GetErrorCode();

  004ce	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _e$6[ebp]
  004d4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 636  : 
; 637  : 				if (error == CKR_USER_ALREADY_LOGGED_IN)

  004d7	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  004dc	75 2d		 jne	 SHORT $LN14@LoginUserI

; 638  : 				{
; 639  : 					break;

  004de	b8 00 00 00 00	 mov	 eax, $LN3@LoginUserI
  004e3	c3		 ret	 0
$LN3@LoginUserI:

; 650  : 	}

  004e4	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _tokenInfo$[ebp]
  004ea	e8 00 00 00 00	 call	 ??1SecurityTokenInfo@GostCrypt@@QAE@XZ
  004ef	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  004f2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004f9	59		 pop	 ecx
  004fa	5f		 pop	 edi
  004fb	5e		 pop	 esi
  004fc	5b		 pop	 ebx
  004fd	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00500	33 cd		 xor	 ecx, ebp
  00502	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00507	8b e5		 mov	 esp, ebp
  00509	5d		 pop	 ebp
  0050a	c3		 ret	 0
$LN14@LoginUserI:

; 640  : 				}
; 641  : 				else if (error == CKR_PIN_INCORRECT && !(tokenInfo.Flags & CKF_PROTECTED_AUTHENTICATION_PATH))

  0050b	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  00510	75 2f		 jne	 SHORT $LN16@LoginUserI
  00512	f7 85 78 ff ff
	ff 00 01 00 00	 test	 DWORD PTR _tokenInfo$[ebp+4], 256 ; 00000100H
  0051c	75 23		 jne	 SHORT $LN16@LoginUserI

; 642  : 				{
; 643  : 					(*WarningCallback) (Pkcs11Exception (CKR_PIN_INCORRECT));

  0051e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?WarningCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@A ; GostCrypt::SecurityToken::WarningCallback
  00524	8d 55 bc	 lea	 edx, DWORD PTR $T15[ebp]
  00527	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T15[ebp], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  0052e	89 45 c0	 mov	 DWORD PTR $T15[ebp+4], eax
  00531	c6 45 c4 00	 mov	 BYTE PTR $T15[ebp+8], 0
  00535	8b 01		 mov	 eax, DWORD PTR [ecx]
  00537	52		 push	 edx
  00538	ff 50 04	 call	 DWORD PTR [eax+4]

; 644  : 					continue;

  0053b	b8 00 00 00 00	 mov	 eax, $LN36@LoginUserI
  00540	c3		 ret	 0
$LN16@LoginUserI:

; 645  : 				}
; 646  : 
; 647  : 				throw;

  00541	6a 00		 push	 0
  00543	6a 00		 push	 0
  00545	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1157@LoginUserI:
$LN1145@LoginUserI:
  0054a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$4:
  00000	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _tokenInfo$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SecurityTokenInfo@GostCrypt@@QAE@XZ
__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$5:
  0000b	8d 4d d4	 lea	 ecx, DWORD PTR _pin$17[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$90:
  00013	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	0f 84 12 00 00
	00		 je	 $LN490@LoginUserI
  00022	83 a5 64 ff ff
	ff fe		 and	 DWORD PTR $T8[ebp], -2	; fffffffeH
  00029	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR _s$3[ebp+104]
  0002f	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN490@LoginUserI:
  00034	c3		 ret	 0
__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$94:
  00035	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _s$3[ebp+24]
  0003b	e9 00 00 00 00	 jmp	 ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$91:
  00040	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _s$3[ebp+32]
  00046	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$98:
  0004b	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$6:
  00056	8d 8d 9c fe ff
	ff		 lea	 ecx, DWORD PTR _s$3[ebp]
  0005c	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$100:
  00061	e8 00 00 00 00	 call	 ___std_terminate
  00066	c3		 ret	 0
__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$197:
  00067	e8 00 00 00 00	 call	 ___std_terminate
  0006c	c3		 ret	 0
__unwindfunclet$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z$8:
  0006d	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _finally625$12[ebp]
  00073	e9 00 00 00 00	 jmp	 ??1Finally625@?BI@??LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z@QAE@XZ ; `GostCrypt::SecurityToken::LoginUserIfRequired'::`24'::Finally625::~Finally625
__ehhandler$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z:
  00078	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0007c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0007f	8b 8a 80 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-384]
  00085	33 c8		 xor	 ecx, eax
  00087	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008c	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0008f	33 c8		 xor	 ecx, eax
  00091	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00096	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z
  0009b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z ENDP ; GostCrypt::SecurityToken::LoginUserIfRequired
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?Login@SecurityToken@GostCrypt@@KAXKABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = -32						; size = 24
$T2 = -8						; size = 8
$T3 = -8						; size = 8
$T4 = -8						; size = 8
_slotId$ = 8						; size = 4
_pin$ = 12						; size = 4
?Login@SecurityToken@GostCrypt@@KAXKABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; GostCrypt::SecurityToken::Login, COMDAT

; 552  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 553  : 		if (Sessions.find (slotId) == Sessions.end())

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _slotId$[ebp]
  00006	83 ec 20	 sub	 esp, 32			; 00000020H
  00009	56		 push	 esi
  0000a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A
  00010	8b d6		 mov	 edx, esi
  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00019	75 3f		 jne	 SHORT $LN306@Login
  0001b	0f 1f 44 00 00	 npad	 5
$LL55@Login:
  00020	39 48 10	 cmp	 DWORD PTR [eax+16], ecx
  00023	73 05		 jae	 SHORT $LN57@Login
  00025	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00028	eb 04		 jmp	 SHORT $LN58@Login
$LN57@Login:
  0002a	8b d0		 mov	 edx, eax
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN58@Login:
  0002e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00032	74 ec		 je	 SHORT $LL55@Login
  00034	3b d6		 cmp	 edx, esi
  00036	74 22		 je	 SHORT $LN306@Login
  00038	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  0003b	72 1d		 jb	 SHORT $LN306@Login

; 555  : 		else if (Sessions[slotId].UserLoggedIn)

  0003d	8d 45 08	 lea	 eax, DWORD PTR _slotId$[ebp]
  00040	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  00045	50		 push	 eax
  00046	8d 45 f8	 lea	 eax, DWORD PTR $T4[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  0004f	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00052	80 78 18 00	 cmp	 BYTE PTR [eax+24], 0
  00056	75 61		 jne	 SHORT $LN1@Login
  00058	eb 09		 jmp	 SHORT $LN4@Login
$LN306@Login:

; 554  : 			OpenSession (slotId);

  0005a	51		 push	 ecx
  0005b	e8 00 00 00 00	 call	 ?OpenSession@SecurityToken@GostCrypt@@KAXK@Z ; GostCrypt::SecurityToken::OpenSession
  00060	83 c4 04	 add	 esp, 4
$LN4@Login:

; 556  : 			return;
; 557  : 
; 558  : 		CK_RV status = Pkcs11Functions->C_Login (Sessions[slotId].Handle, CKU_USER, (CK_CHAR_PTR) pin.c_str(), pin.size());

  00063	8b 75 0c	 mov	 esi, DWORD PTR _pin$[ebp]
  00066	57		 push	 edi
  00067	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0006b	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0006e	72 02		 jb	 SHORT $LN260@Login
  00070	8b 36		 mov	 esi, DWORD PTR [esi]
$LN260@Login:
  00072	8d 45 08	 lea	 eax, DWORD PTR _slotId$[ebp]
  00075	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  0007a	50		 push	 eax
  0007b	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  00084	8b 45 f8	 mov	 eax, DWORD PTR $T3[ebp]
  00087	57		 push	 edi
  00088	56		 push	 esi
  00089	6a 01		 push	 1
  0008b	ff 70 14	 push	 DWORD PTR [eax+20]
  0008e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  00093	8b 40 4a	 mov	 eax, DWORD PTR [eax+74]
  00096	ff d0		 call	 eax
  00098	83 c4 10	 add	 esp, 16			; 00000010H
  0009b	5f		 pop	 edi

; 559  : 
; 560  : 		if (status != CKR_OK)

  0009c	85 c0		 test	 eax, eax
  0009e	75 1e		 jne	 SHORT $LN308@Login

; 562  : 
; 563  : 		Sessions[slotId].UserLoggedIn = true;

  000a0	8d 45 08	 lea	 eax, DWORD PTR _slotId$[ebp]
  000a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  000a8	50		 push	 eax
  000a9	8d 45 f8	 lea	 eax, DWORD PTR $T2[ebp]
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  000b2	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  000b5	c6 40 18 01	 mov	 BYTE PTR [eax+24], 1
$LN1@Login:
  000b9	5e		 pop	 esi

; 564  : 	}

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
$LN308@Login:

; 561  : 			throw Pkcs11Exception (status);

  000be	89 45 e4	 mov	 DWORD PTR $T1[ebp+4], eax
  000c1	8d 45 e0	 lea	 eax, DWORD PTR $T1[ebp]
  000c4	68 00 00 00 00	 push	 OFFSET __TI2?AUPkcs11Exception@GostCrypt@@
  000c9	50		 push	 eax
  000ca	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  000d1	c6 45 e8 00	 mov	 BYTE PTR $T1[ebp+8], 0
  000d5	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN310@Login:
$LN307@Login:
  000da	cc		 int	 3
?Login@SecurityToken@GostCrypt@@KAXKABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; GostCrypt::SecurityToken::Login
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?GetTokenSlots@SecurityToken@GostCrypt@@KA?AV?$list@KV?$allocator@K@std@@@std@@XZ
_TEXT	SEGMENT
$T2 = -184						; size = 24
___$ReturnUdt$GSCopy$ = -160				; size = 4
$T3 = -156						; size = 24
_slotArray$4 = -144					; size = 12
$T5 = -132						; size = 4
$T6 = -128						; size = 4
_slotCount$ = -124					; size = 4
_slotInfo$7 = -120					; size = 104
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetTokenSlots@SecurityToken@GostCrypt@@KA?AV?$list@KV?$allocator@K@std@@@std@@XZ PROC ; GostCrypt::SecurityToken::GetTokenSlots, COMDAT

; 497  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetTokenSlots@SecurityToken@GostCrypt@@KA?AV?$list@KV?$allocator@K@std@@@std@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00031	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], 0

; 498  : 		CheckLibraryStatus();

  0003b	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?Initialized@SecurityToken@GostCrypt@@1_NA, 0 ; GostCrypt::SecurityToken::Initialized
  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00049	89 9d 60 ff ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], ebx
  0004f	75 15		 jne	 SHORT $LN15@GetTokenSl
  00051	68 00 00 00 00	 push	 OFFSET __TI2?AUSecurityTokenLibraryNotInitialized@GostCrypt@@
  00056	8d 45 80	 lea	 eax, DWORD PTR $T6[ebp]
  00059	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], OFFSET ??_7SecurityTokenLibraryNotInitialized@GostCrypt@@6B@
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN208@GetTokenSl:
$LN15@GetTokenSl:

; 499  : 
; 500  : 		list <CK_SLOT_ID> slots;

  00066	6a 00		 push	 0
  00068	6a 00		 push	 0
  0006a	8b cb		 mov	 ecx, ebx
  0006c	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00072	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00079	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@KV?$allocator@K@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned long,std::allocator<unsigned long> > >::_Buynode0
  0007e	89 03		 mov	 DWORD PTR [ebx], eax

; 525  : 
; 526  : 		return slots;

  00080	8d 45 84	 lea	 eax, DWORD PTR _slotCount$[ebp]
  00083	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0008a	50		 push	 eax
  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  00090	6a 00		 push	 0
  00092	6a 01		 push	 1
  00094	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T5[ebp], 1
  0009e	8b 40 12	 mov	 eax, DWORD PTR [eax+18]
  000a1	ff d0		 call	 eax
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a6	85 c0		 test	 eax, eax
  000a8	74 28		 je	 SHORT $LN5@GetTokenSl

; 501  : 		CK_ULONG slotCount;
; 502  : 
; 503  : 		CK_RV status = Pkcs11Functions->C_GetSlotList (TRUE, NULL_PTR, &slotCount);
; 504  : 		if (status != CKR_OK)
; 505  : 			throw Pkcs11Exception (status);

  000aa	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T3[ebp+4], eax
  000b0	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000b6	68 00 00 00 00	 push	 OFFSET __TI2?AUPkcs11Exception@GostCrypt@@
  000bb	50		 push	 eax
  000bc	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  000c6	c6 85 6c ff ff
	ff 00		 mov	 BYTE PTR $T3[ebp+8], 0
  000cd	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN209@GetTokenSl:
$LN5@GetTokenSl:

; 506  : 
; 507  : 		if (slotCount > 0)

  000d2	8b 45 84	 mov	 eax, DWORD PTR _slotCount$[ebp]
  000d5	85 c0		 test	 eax, eax
  000d7	0f 84 b3 00 00
	00		 je	 $LN113@GetTokenSl

; 508  : 		{
; 509  : 			vector <CK_SLOT_ID> slotArray (slotCount);

  000dd	50		 push	 eax
  000de	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _slotArray$4[ebp]
  000e4	e8 00 00 00 00	 call	 ??0?$vector@KV?$allocator@K@std@@@std@@QAE@I@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >

; 510  : 			status = Pkcs11Functions->C_GetSlotList (TRUE, &slotArray.front(), &slotCount);

  000e9	8b b5 70 ff ff
	ff		 mov	 esi, DWORD PTR _slotArray$4[ebp]
  000ef	8d 45 84	 lea	 eax, DWORD PTR _slotCount$[ebp]
  000f2	50		 push	 eax
  000f3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  000f8	56		 push	 esi
  000f9	6a 01		 push	 1
  000fb	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00102	8b 40 12	 mov	 eax, DWORD PTR [eax+18]
  00105	ff d0		 call	 eax
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH

; 511  : 			if (status != CKR_OK)

  0010a	85 c0		 test	 eax, eax
  0010c	74 28		 je	 SHORT $LN7@GetTokenSl

; 512  : 				throw Pkcs11Exception (status);

  0010e	89 85 4c ff ff
	ff		 mov	 DWORD PTR $T2[ebp+4], eax
  00114	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0011a	68 00 00 00 00	 push	 OFFSET __TI2?AUPkcs11Exception@GostCrypt@@
  0011f	50		 push	 eax
  00120	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  0012a	c6 85 50 ff ff
	ff 00		 mov	 BYTE PTR $T2[ebp+8], 0
  00131	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN210@GetTokenSl:
$LN7@GetTokenSl:

; 513  : 
; 514  : 			for (size_t i = 0; i < slotCount; i++)

  00136	33 ff		 xor	 edi, edi
  00138	39 7d 84	 cmp	 DWORD PTR _slotCount$[ebp], edi
  0013b	76 37		 jbe	 SHORT $LN3@GetTokenSl
  0013d	0f 1f 00	 npad	 3
$LL4@GetTokenSl:

; 515  : 			{
; 516  : 				CK_SLOT_INFO slotInfo;
; 517  : 				status = Pkcs11Functions->C_GetSlotInfo (slotArray[i], &slotInfo);

  00140	8d 45 88	 lea	 eax, DWORD PTR _slotInfo$7[ebp]
  00143	50		 push	 eax
  00144	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  00149	ff 36		 push	 DWORD PTR [esi]
  0014b	8b 40 16	 mov	 eax, DWORD PTR [eax+22]
  0014e	ff d0		 call	 eax
  00150	83 c4 08	 add	 esp, 8

; 518  : 
; 519  : 				if (status != CKR_OK || !(slotInfo.flags & CKF_TOKEN_PRESENT))

  00153	85 c0		 test	 eax, eax
  00155	75 0e		 jne	 SHORT $LN2@GetTokenSl
  00157	f6 45 e8 01	 test	 BYTE PTR _slotInfo$7[ebp+96], 1
  0015b	74 08		 je	 SHORT $LN2@GetTokenSl

; 520  : 					continue;
; 521  : 
; 522  : 				slots.push_back (slotArray[i]);

  0015d	56		 push	 esi
  0015e	8b cb		 mov	 ecx, ebx
  00160	e8 00 00 00 00	 call	 ?push_back@?$list@KV?$allocator@K@std@@@std@@QAEXABK@Z ; std::list<unsigned long,std::allocator<unsigned long> >::push_back
$LN2@GetTokenSl:

; 513  : 
; 514  : 			for (size_t i = 0; i < slotCount; i++)

  00165	47		 inc	 edi
  00166	83 c6 04	 add	 esi, 4
  00169	3b 7d 84	 cmp	 edi, DWORD PTR _slotCount$[ebp]
  0016c	72 d2		 jb	 SHORT $LL4@GetTokenSl
  0016e	8b b5 70 ff ff
	ff		 mov	 esi, DWORD PTR _slotArray$4[ebp]
$LN3@GetTokenSl:

; 523  : 			}
; 524  : 		}

  00174	85 f6		 test	 esi, esi
  00176	74 18		 je	 SHORT $LN113@GetTokenSl
  00178	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _slotArray$4[ebp+8]
  0017e	2b ce		 sub	 ecx, esi
  00180	c1 f9 02	 sar	 ecx, 2
  00183	51		 push	 ecx
  00184	56		 push	 esi
  00185	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _slotArray$4[ebp]
  0018b	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
$LN113@GetTokenSl:

; 525  : 
; 526  : 		return slots;

  00190	8b c3		 mov	 eax, ebx

; 527  : 	}

  00192	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00195	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0019c	59		 pop	 ecx
  0019d	5f		 pop	 edi
  0019e	5e		 pop	 esi
  0019f	5b		 pop	 ebx
  001a0	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a3	33 cd		 xor	 ecx, ebp
  001a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c3		 ret	 0
$LN207@GetTokenSl:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTokenSlots@SecurityToken@GostCrypt@@KA?AV?$list@KV?$allocator@K@std@@@std@@XZ$0:
  00000	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  00006	83 e0 01	 and	 eax, 1
  00009	0f 84 12 00 00
	00		 je	 $LN12@GetTokenSl
  0000f	83 a5 7c ff ff
	ff fe		 and	 DWORD PTR $T5[ebp], -2	; fffffffeH
  00016	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$list@KV?$allocator@K@std@@@std@@QAE@XZ ; std::list<unsigned long,std::allocator<unsigned long> >::~list<unsigned long,std::allocator<unsigned long> >
$LN12@GetTokenSl:
  00021	c3		 ret	 0
__unwindfunclet$?GetTokenSlots@SecurityToken@GostCrypt@@KA?AV?$list@KV?$allocator@K@std@@@std@@XZ$1:
  00022	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _slotArray$4[ebp]
  00028	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
__ehhandler$?GetTokenSlots@SecurityToken@GostCrypt@@KA?AV?$list@KV?$allocator@K@std@@@std@@XZ:
  0002d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00031	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00034	8b 8a 44 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-188]
  0003a	33 c8		 xor	 ecx, eax
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00044	33 c8		 xor	 ecx, eax
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetTokenSlots@SecurityToken@GostCrypt@@KA?AV?$list@KV?$allocator@K@std@@@std@@XZ
  00050	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetTokenSlots@SecurityToken@GostCrypt@@KA?AV?$list@KV?$allocator@K@std@@@std@@XZ ENDP ; GostCrypt::SecurityToken::GetTokenSlots
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?GetObjectAttribute@SecurityToken@GostCrypt@@KAXKKKAAV?$vector@EV?$allocator@E@std@@@std@@@Z
_TEXT	SEGMENT
_attribute$ = -36					; size = 12
$T1 = -24						; size = 24
$T2 = -12						; size = 12
$T3 = -8						; size = 8
$T4 = -8						; size = 8
$T5 = -8						; size = 8
_slotId$ = 8						; size = 4
_tokenObject$ = 12					; size = 4
_attributeType$ = 16					; size = 4
_attributeValue$ = 20					; size = 4
?GetObjectAttribute@SecurityToken@GostCrypt@@KAXKKKAAV?$vector@EV?$allocator@E@std@@@std@@@Z PROC ; GostCrypt::SecurityToken::GetObjectAttribute, COMDAT

; 464  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 465  : 		attributeValue.clear();

  00008	8b 7d 14	 mov	 edi, DWORD PTR _attributeValue$[ebp]
  0000b	8b 07		 mov	 eax, DWORD PTR [edi]
  0000d	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 466  : 
; 467  : 		if (Sessions.find (slotId) == Sessions.end())

  00010	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A
  00016	8b ca		 mov	 ecx, edx
  00018	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001b	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0001f	75 20		 jne	 SHORT $LN81@GetObjectA
  00021	8b 75 08	 mov	 esi, DWORD PTR _slotId$[ebp]
$LL95@GetObjectA:
  00024	39 70 10	 cmp	 DWORD PTR [eax+16], esi
  00027	73 05		 jae	 SHORT $LN97@GetObjectA
  00029	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002c	eb 04		 jmp	 SHORT $LN98@GetObjectA
$LN97@GetObjectA:
  0002e	8b c8		 mov	 ecx, eax
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
$LN98@GetObjectA:
  00032	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00036	74 ec		 je	 SHORT $LL95@GetObjectA
  00038	3b ca		 cmp	 ecx, edx
  0003a	74 05		 je	 SHORT $LN81@GetObjectA
  0003c	3b 71 10	 cmp	 esi, DWORD PTR [ecx+16]
  0003f	73 02		 jae	 SHORT $LN225@GetObjectA
$LN81@GetObjectA:
  00041	8b ca		 mov	 ecx, edx
$LN225@GetObjectA:
  00043	3b ca		 cmp	 ecx, edx
  00045	0f 84 9b 00 00
	00		 je	 $LN345@GetObjectA

; 469  : 
; 470  : 		CK_ATTRIBUTE attribute;
; 471  : 		attribute.type = attributeType;

  0004b	8b 45 10	 mov	 eax, DWORD PTR _attributeType$[ebp]

; 472  : 		attribute.pValue = NULL_PTR;
; 473  : 
; 474  : 		CK_RV status = Pkcs11Functions->C_GetAttributeValue (Sessions[slotId].Handle, tokenObject, &attribute, 1);

  0004e	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  00053	89 45 dc	 mov	 DWORD PTR _attribute$[ebp], eax
  00056	8d 45 08	 lea	 eax, DWORD PTR _slotId$[ebp]
  00059	50		 push	 eax
  0005a	8d 45 f8	 lea	 eax, DWORD PTR $T4[ebp]
  0005d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _attribute$[ebp+4], 0
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  0006a	8b 75 0c	 mov	 esi, DWORD PTR _tokenObject$[ebp]
  0006d	8d 45 dc	 lea	 eax, DWORD PTR _attribute$[ebp]
  00070	6a 01		 push	 1
  00072	50		 push	 eax
  00073	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00076	56		 push	 esi
  00077	ff 70 14	 push	 DWORD PTR [eax+20]
  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  0007f	8b 40 62	 mov	 eax, DWORD PTR [eax+98]
  00082	ff d0		 call	 eax
  00084	83 c4 10	 add	 esp, 16			; 00000010H

; 475  : 		if (status != CKR_OK)

  00087	85 c0		 test	 eax, eax
  00089	75 77		 jne	 SHORT $LN347@GetObjectA

; 477  : 
; 478  : 		if (attribute.ulValueLen == 0)

  0008b	8b 45 e4	 mov	 eax, DWORD PTR _attribute$[ebp+8]
  0008e	85 c0		 test	 eax, eax
  00090	74 4e		 je	 SHORT $LN5@GetObjectA

; 479  : 			return;
; 480  : 
; 481  : 		attributeValue = vector <byte> (attribute.ulValueLen);

  00092	50		 push	 eax
  00093	8d 4d f4	 lea	 ecx, DWORD PTR $T2[ebp]
  00096	e8 00 00 00 00	 call	 ??0?$vector@EV?$allocator@E@std@@@std@@QAE@I@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
  0009b	50		 push	 eax
  0009c	8b cf		 mov	 ecx, edi
  0009e	e8 00 00 00 00	 call	 ??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@$$QAV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=
  000a3	8d 4d f4	 lea	 ecx, DWORD PTR $T2[ebp]
  000a6	e8 00 00 00 00	 call	 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy

; 482  : 		attribute.pValue = &attributeValue.front();

  000ab	8b 07		 mov	 eax, DWORD PTR [edi]

; 483  : 
; 484  : 		status = Pkcs11Functions->C_GetAttributeValue (Sessions[slotId].Handle, tokenObject, &attribute, 1);

  000ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  000b2	89 45 e0	 mov	 DWORD PTR _attribute$[ebp+4], eax
  000b5	8d 45 08	 lea	 eax, DWORD PTR _slotId$[ebp]
  000b8	50		 push	 eax
  000b9	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  000c2	6a 01		 push	 1
  000c4	8d 45 dc	 lea	 eax, DWORD PTR _attribute$[ebp]
  000c7	50		 push	 eax
  000c8	8b 45 f8	 mov	 eax, DWORD PTR $T3[ebp]
  000cb	56		 push	 esi
  000cc	ff 70 14	 push	 DWORD PTR [eax+20]
  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  000d4	8b 40 62	 mov	 eax, DWORD PTR [eax+98]
  000d7	ff d0		 call	 eax
  000d9	83 c4 10	 add	 esp, 16			; 00000010H

; 485  : 		if (status != CKR_OK)

  000dc	85 c0		 test	 eax, eax
  000de	75 22		 jne	 SHORT $LN347@GetObjectA
$LN5@GetObjectA:
  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi

; 486  : 			throw Pkcs11Exception (status);
; 487  : 	}

  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
$LN345@GetObjectA:

; 468  : 			throw ParameterIncorrect (SRC_POS);

  000e6	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  000eb	8d 45 f8	 lea	 eax, DWORD PTR $T5[ebp]
  000ee	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  000f5	50		 push	 eax
  000f6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+4], OFFSET ??_C@_0DB@KHBANPMA@GostCrypt?3?3SecurityToken?3?3GetObj@
  000fd	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN348@GetObjectA:
$LN347@GetObjectA:

; 476  : 			throw Pkcs11Exception (status);

  00102	89 45 ec	 mov	 DWORD PTR $T1[ebp+4], eax
  00105	8d 45 e8	 lea	 eax, DWORD PTR $T1[ebp]
  00108	68 00 00 00 00	 push	 OFFSET __TI2?AUPkcs11Exception@GostCrypt@@
  0010d	50		 push	 eax
  0010e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  00115	c6 45 f0 00	 mov	 BYTE PTR $T1[ebp+8], 0
  00119	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN349@GetObjectA:
$LN343@GetObjectA:
  0011e	cc		 int	 3
?GetObjectAttribute@SecurityToken@GostCrypt@@KAXKKKAAV?$vector@EV?$allocator@E@std@@@std@@@Z ENDP ; GostCrypt::SecurityToken::GetObjectAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z
_TEXT	SEGMENT
$T2 = -72						; size = 24
_findTemplate$ = -48					; size = 12
$T3 = -36						; size = 8
$T4 = -36						; size = 8
$T5 = -36						; size = 8
_finally431$ = -28					; size = 4
$T6 = -24						; size = 4
_objectCount$ = -20					; size = 4
_object$7 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_slotId$ = 12						; size = 4
_objectClass$ = 16					; size = 4
?GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z PROC ; GostCrypt::SecurityToken::GetObjects, COMDAT

; 418  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], 0

; 419  : 		if (Sessions.find (slotId) == Sessions.end())

  0002e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A
  00034	8b ce		 mov	 ecx, esi
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00040	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00044	0f 85 9d 01 00
	00		 jne	 $LN517@GetObjects
  0004a	8b 55 0c	 mov	 edx, DWORD PTR _slotId$[ebp]
  0004d	0f 1f 00	 npad	 3
$LL60@GetObjects:
  00050	39 50 10	 cmp	 DWORD PTR [eax+16], edx
  00053	73 05		 jae	 SHORT $LN62@GetObjects
  00055	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00058	eb 04		 jmp	 SHORT $LN63@GetObjects
$LN62@GetObjects:
  0005a	8b c8		 mov	 ecx, eax
  0005c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN63@GetObjects:
  0005e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00062	74 ec		 je	 SHORT $LL60@GetObjects
  00064	3b ce		 cmp	 ecx, esi
  00066	0f 84 7b 01 00
	00		 je	 $LN517@GetObjects
  0006c	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0006f	0f 82 72 01 00
	00		 jb	 $LN517@GetObjects

; 421  : 
; 422  : 		CK_ATTRIBUTE findTemplate;
; 423  : 		findTemplate.type = CKA_CLASS;
; 424  : 		findTemplate.pValue = &objectClass;

  00075	8d 45 10	 lea	 eax, DWORD PTR _objectClass$[ebp]
  00078	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _findTemplate$[ebp], 0
  0007f	89 45 d4	 mov	 DWORD PTR _findTemplate$[ebp+4], eax

; 425  : 		findTemplate.ulValueLen = sizeof (objectClass);
; 426  : 
; 427  : 		CK_RV status = Pkcs11Functions->C_FindObjectsInit (Sessions[slotId].Handle, &findTemplate, 1);

  00082	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  00087	8d 45 0c	 lea	 eax, DWORD PTR _slotId$[ebp]
  0008a	c7 45 d8 04 00
	00 00		 mov	 DWORD PTR _findTemplate$[ebp+8], 4
  00091	50		 push	 eax
  00092	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  0009b	8b 45 dc	 mov	 eax, DWORD PTR $T4[ebp]
  0009e	8d 4d d0	 lea	 ecx, DWORD PTR _findTemplate$[ebp]
  000a1	6a 01		 push	 1
  000a3	51		 push	 ecx
  000a4	ff 70 14	 push	 DWORD PTR [eax+20]
  000a7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  000ac	8b 40 6a	 mov	 eax, DWORD PTR [eax+106]
  000af	ff d0		 call	 eax
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 428  : 		if (status != CKR_OK)

  000b4	85 c0		 test	 eax, eax
  000b6	74 1c		 je	 SHORT $LN5@GetObjects
$LN510@GetObjects:

; 429  : 			throw Pkcs11Exception (status);

  000b8	89 45 bc	 mov	 DWORD PTR $T2[ebp+4], eax
  000bb	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  000be	68 00 00 00 00	 push	 OFFSET __TI2?AUPkcs11Exception@GostCrypt@@
  000c3	50		 push	 eax
  000c4	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  000cb	c6 45 c0 00	 mov	 BYTE PTR $T2[ebp+8], 0
  000cf	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN521@GetObjects:
$LN5@GetObjects:

; 430  : 
; 431  : 		finally_do_arg (CK_SLOT_ID, slotId, { Pkcs11Functions->C_FindObjectsFinal (Sessions[finally_arg].Handle); });

  000d4	8b 45 0c	 mov	 eax, DWORD PTR _slotId$[ebp]
  000d7	89 45 e4	 mov	 DWORD PTR _finally431$[ebp], eax

; 432  : 
; 433  : 		CK_ULONG objectCount;	
; 434  : 		vector <CK_OBJECT_HANDLE> objects;

  000da	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  000dd	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000e4	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  000ea	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  000f1	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 447  : 		}
; 448  : 
; 449  : 		return objects;

  000f8	8d 45 0c	 lea	 eax, DWORD PTR _slotId$[ebp]
  000fb	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR $T6[ebp], 1
  00102	50		 push	 eax
  00103	8d 45 dc	 lea	 eax, DWORD PTR $T3[ebp]
  00106	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  00111	8d 45 ec	 lea	 eax, DWORD PTR _objectCount$[ebp]
  00114	50		 push	 eax
  00115	6a 01		 push	 1
  00117	8d 45 f0	 lea	 eax, DWORD PTR _object$7[ebp]
  0011a	50		 push	 eax
  0011b	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0011e	ff 70 14	 push	 DWORD PTR [eax+20]
  00121	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  00126	8b 40 6e	 mov	 eax, DWORD PTR [eax+110]
  00129	ff d0		 call	 eax
  0012b	83 c4 10	 add	 esp, 16			; 00000010H
  0012e	85 c0		 test	 eax, eax
  00130	75 86		 jne	 SHORT $LN510@GetObjects
$LL2@GetObjects:

; 441  : 				throw Pkcs11Exception (status);
; 442  : 
; 443  : 			if (objectCount != 1)

  00132	83 7d ec 01	 cmp	 DWORD PTR _objectCount$[ebp], 1
  00136	0f 85 90 00 00
	00		 jne	 $LN511@GetObjects

; 444  : 				break;
; 445  : 
; 446  : 			objects.push_back (object);

  0013c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0013f	8d 4d f0	 lea	 ecx, DWORD PTR _object$7[ebp]
  00142	3b c8		 cmp	 ecx, eax
  00144	73 2c		 jae	 SHORT $LN284@GetObjects
  00146	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00148	8d 55 f0	 lea	 edx, DWORD PTR _object$7[ebp]
  0014b	3b ca		 cmp	 ecx, edx
  0014d	77 23		 ja	 SHORT $LN284@GetObjects
  0014f	8b fa		 mov	 edi, edx
  00151	2b f9		 sub	 edi, ecx
  00153	c1 ff 02	 sar	 edi, 2
  00156	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00159	75 09		 jne	 SHORT $LN286@GetObjects
  0015b	6a 01		 push	 1
  0015d	8b ce		 mov	 ecx, esi
  0015f	e8 00 00 00 00	 call	 ?_Reserve@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reserve
$LN286@GetObjects:
  00164	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00167	85 c9		 test	 ecx, ecx
  00169	74 21		 je	 SHORT $LN491@GetObjects
  0016b	8b 06		 mov	 eax, DWORD PTR [esi]
  0016d	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00170	eb 18		 jmp	 SHORT $LN520@GetObjects
$LN284@GetObjects:
  00172	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00175	75 09		 jne	 SHORT $LN287@GetObjects
  00177	6a 01		 push	 1
  00179	8b ce		 mov	 ecx, esi
  0017b	e8 00 00 00 00	 call	 ?_Reserve@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reserve
$LN287@GetObjects:
  00180	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00183	85 c9		 test	 ecx, ecx
  00185	74 05		 je	 SHORT $LN491@GetObjects
  00187	8b 45 f0	 mov	 eax, DWORD PTR _object$7[ebp]
$LN520@GetObjects:
  0018a	89 01		 mov	 DWORD PTR [ecx], eax
$LN491@GetObjects:
  0018c	83 46 04 04	 add	 DWORD PTR [esi+4], 4
  00190	8d 45 0c	 lea	 eax, DWORD PTR _slotId$[ebp]
  00193	50		 push	 eax
  00194	8d 45 dc	 lea	 eax, DWORD PTR $T3[ebp]
  00197	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  001a2	8d 45 ec	 lea	 eax, DWORD PTR _objectCount$[ebp]
  001a5	50		 push	 eax
  001a6	6a 01		 push	 1
  001a8	8d 45 f0	 lea	 eax, DWORD PTR _object$7[ebp]
  001ab	50		 push	 eax
  001ac	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  001af	ff 70 14	 push	 DWORD PTR [eax+20]
  001b2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  001b7	8b 40 6e	 mov	 eax, DWORD PTR [eax+110]
  001ba	ff d0		 call	 eax
  001bc	83 c4 10	 add	 esp, 16			; 00000010H
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 6b ff ff
	ff		 je	 $LL2@GetObjects

; 435  : 
; 436  : 		while (true)
; 437  : 		{
; 438  : 			CK_OBJECT_HANDLE object;
; 439  : 			CK_RV status = Pkcs11Functions->C_FindObjects (Sessions[slotId].Handle, &object, 1, &objectCount);
; 440  : 			if (status != CKR_OK)

  001c7	e9 ec fe ff ff	 jmp	 $LN510@GetObjects
$LN511@GetObjects:

; 447  : 		}
; 448  : 
; 449  : 		return objects;

  001cc	8d 4d e4	 lea	 ecx, DWORD PTR _finally431$[ebp]
  001cf	e8 00 00 00 00	 call	 ??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ ; `GostCrypt::SecurityToken::GetObjects'::`2'::Finally431::~Finally431
  001d4	8b c6		 mov	 eax, esi

; 450  : 	}

  001d6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e0	59		 pop	 ecx
  001e1	5f		 pop	 edi
  001e2	5e		 pop	 esi
  001e3	8b e5		 mov	 esp, ebp
  001e5	5d		 pop	 ebp
  001e6	c3		 ret	 0
$LN517@GetObjects:

; 420  : 			throw ParameterIncorrect (SRC_POS);

  001e7	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  001ec	8d 45 dc	 lea	 eax, DWORD PTR $T5[ebp]
  001ef	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  001f6	50		 push	 eax
  001f7	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+4], OFFSET ??_C@_0CJ@KMNLDKPC@GostCrypt?3?3SecurityToken?3?3GetObj@
  001fe	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN522@GetObjects:
$LN519@GetObjects:
  00203	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _finally431$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Finally431@?1??GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z@QAE@XZ ; `GostCrypt::SecurityToken::GetObjects'::`2'::Finally431::~Finally431
__unwindfunclet$?GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z$1:
  00008	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  0000b	83 e0 01	 and	 eax, 1
  0000e	0f 84 0c 00 00
	00		 je	 $LN11@GetObjects
  00014	83 65 e8 fe	 and	 DWORD PTR $T6[ebp], -2	; fffffffeH
  00018	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
$LN11@GetObjects:
  00020	c3		 ret	 0
__ehhandler$?GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z ENDP ; GostCrypt::SecurityToken::GetObjects
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?CloseSession@SecurityToken@GostCrypt@@KAXK@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
$T2 = -8						; size = 8
$T3 = -4						; size = 4
_slotId$ = 8						; size = 4
?CloseSession@SecurityToken@GostCrypt@@KAXK@Z PROC	; GostCrypt::SecurityToken::CloseSession, COMDAT

; 146  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 147  : 		if (Sessions.find (slotId) == Sessions.end())

  00007	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A
  0000d	8b ce		 mov	 ecx, esi
  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00016	0f 85 8d 00 00
	00		 jne	 $LN422@CloseSessi
  0001c	8b 55 08	 mov	 edx, DWORD PTR _slotId$[ebp]
  0001f	90		 npad	 1
$LL52@CloseSessi:
  00020	39 50 10	 cmp	 DWORD PTR [eax+16], edx
  00023	73 05		 jae	 SHORT $LN54@CloseSessi
  00025	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00028	eb 04		 jmp	 SHORT $LN55@CloseSessi
$LN54@CloseSessi:
  0002a	8b c8		 mov	 ecx, eax
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN55@CloseSessi:
  0002e	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00032	74 ec		 je	 SHORT $LL52@CloseSessi
  00034	3b ce		 cmp	 ecx, esi
  00036	74 71		 je	 SHORT $LN422@CloseSessi
  00038	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0003b	72 6c		 jb	 SHORT $LN422@CloseSessi

; 149  : 
; 150  : 		Pkcs11Functions->C_CloseSession (Sessions[slotId].Handle);

  0003d	8d 45 08	 lea	 eax, DWORD PTR _slotId$[ebp]
  00040	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  00045	50		 push	 eax
  00046	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  0004f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00052	ff 70 14	 push	 DWORD PTR [eax+20]
  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  0005a	8b 40 36	 mov	 eax, DWORD PTR [eax+54]
  0005d	ff d0		 call	 eax

; 151  : 		Sessions.erase (Sessions.find (slotId));

  0005f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A
  00065	83 c4 04	 add	 esp, 4
  00068	8b ce		 mov	 ecx, esi
  0006a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0006d	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00071	75 20		 jne	 SHORT $LN239@CloseSessi
  00073	8b 55 08	 mov	 edx, DWORD PTR _slotId$[ebp]
$LL253@CloseSessi:
  00076	39 50 10	 cmp	 DWORD PTR [eax+16], edx
  00079	73 05		 jae	 SHORT $LN255@CloseSessi
  0007b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007e	eb 04		 jmp	 SHORT $LN256@CloseSessi
$LN255@CloseSessi:
  00080	8b c8		 mov	 ecx, eax
  00082	8b 00		 mov	 eax, DWORD PTR [eax]
$LN256@CloseSessi:
  00084	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00088	74 ec		 je	 SHORT $LL253@CloseSessi
  0008a	3b ce		 cmp	 ecx, esi
  0008c	74 05		 je	 SHORT $LN239@CloseSessi
  0008e	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00091	73 02		 jae	 SHORT $LN383@CloseSessi
$LN239@CloseSessi:
  00093	8b ce		 mov	 ecx, esi
$LN383@CloseSessi:
  00095	51		 push	 ecx
  00096	8d 45 fc	 lea	 eax, DWORD PTR $T3[ebp]
  00099	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::erase
  000a4	5e		 pop	 esi

; 152  : 	}

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
$LN422@CloseSessi:

; 148  : 			throw ParameterIncorrect (SRC_POS);

  000a9	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  000ae	8d 45 f8	 lea	 eax, DWORD PTR $T2[ebp]
  000b1	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  000b8	50		 push	 eax
  000b9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_0CL@GPMOMIPC@GostCrypt?3?3SecurityToken?3?3CloseS@
  000c0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN423@CloseSessi:
$LN421@CloseSessi:
  000c5	cc		 int	 3
?CloseSession@SecurityToken@GostCrypt@@KAXK@Z ENDP	; GostCrypt::SecurityToken::CloseSession
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?IsKeyfilePathValid@SecurityToken@GostCrypt@@SA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_securityTokenKeyfilePath$ = 8				; size = 4
?IsKeyfilePathValid@SecurityToken@GostCrypt@@SA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; GostCrypt::SecurityToken::IsKeyfilePathValid, COMDAT

; 538  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 539  : 		return securityTokenKeyfilePath.find (GST_SECURITY_TOKEN_KEYFILE_URL_PREFIX) == 0;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _securityTokenKeyfilePath$[ebp]
  00006	6a 08		 push	 8
  00008	6a 00		 push	 0
  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@ELBDEFGA@?$AAt?$AAo?$AAk?$AAe?$AAn?$AA?3?$AA?1?$AA?1?$AA?$AA@
  0000f	e8 00 00 00 00	 call	 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
  00014	85 c0		 test	 eax, eax
  00016	0f 94 c0	 sete	 al

; 540  : 	}

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?IsKeyfilePathValid@SecurityToken@GostCrypt@@SA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; GostCrypt::SecurityToken::IsKeyfilePathValid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?InitLibrary@SecurityToken@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$auto_ptr@UGetPinFunctor@GostCrypt@@@4@V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@4@@Z
_TEXT	SEGMENT
$T2 = -44						; size = 24
$T3 = -20						; size = 8
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
_pkcs11LibraryPath$ = 8					; size = 4
_pinCallback$ = 12					; size = 4
_warningCallback$ = 16					; size = 4
?InitLibrary@SecurityToken@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$auto_ptr@UGetPinFunctor@GostCrypt@@@4@V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@4@@Z PROC ; GostCrypt::SecurityToken::InitLibrary, COMDAT

; 663  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?InitLibrary@SecurityToken@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$auto_ptr@UGetPinFunctor@GostCrypt@@@4@V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@4@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 664  : 		if (Initialized)

  00026	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?Initialized@SecurityToken@GostCrypt@@1_NA, 0 ; GostCrypt::SecurityToken::Initialized
  0002d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00034	74 27		 je	 SHORT $LN14@InitLibrar

; 665  : 			CloseLibrary();

  00036	e8 00 00 00 00	 call	 ?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ ; GostCrypt::SecurityToken::CloseAllSessions
  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  00040	6a 00		 push	 0
  00042	8b 40 06	 mov	 eax, DWORD PTR [eax+6]
  00045	ff d0		 call	 eax
  00047	83 c4 04	 add	 esp, 4
  0004a	ff 35 00 00 00
	00		 push	 DWORD PTR ?Pkcs11LibraryHandle@SecurityToken@GostCrypt@@1PAUHINSTANCE__@@A ; GostCrypt::SecurityToken::Pkcs11LibraryHandle
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  00056	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?Initialized@SecurityToken@GostCrypt@@1_NA, 0 ; GostCrypt::SecurityToken::Initialized
$LN14@InitLibrar:

; 666  : 
; 667  : #ifdef GST_WINDOWS
; 668  : 		Pkcs11LibraryHandle = LoadLibraryA (pkcs11LibraryPath.c_str());

  0005d	8b 45 08	 mov	 eax, DWORD PTR _pkcs11LibraryPath$[ebp]
  00060	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00064	72 02		 jb	 SHORT $LN30@InitLibrar
  00066	8b 00		 mov	 eax, DWORD PTR [eax]
$LN30@InitLibrar:
  00068	50		 push	 eax
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  0006f	a3 00 00 00 00	 mov	 DWORD PTR ?Pkcs11LibraryHandle@SecurityToken@GostCrypt@@1PAUHINSTANCE__@@A, eax ; GostCrypt::SecurityToken::Pkcs11LibraryHandle

; 669  : #else
; 670  : 		Pkcs11LibraryHandle = dlopen (pkcs11LibraryPath.c_str(), RTLD_NOW | RTLD_LOCAL);
; 671  : #endif
; 672  : 		throw_sys_if (!Pkcs11LibraryHandle);

  00074	85 c0		 test	 eax, eax
  00076	75 1e		 jne	 SHORT $LN2@InitLibrar
  00078	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00085	89 45 f0	 mov	 DWORD PTR $T3[ebp+4], eax
  00088	8d 45 ec	 lea	 eax, DWORD PTR $T3[ebp]
  0008b	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN90@InitLibrar:
$LN2@InitLibrar:

; 673  : 
; 674  : 		typedef CK_RV (*C_GetFunctionList_t) (CK_FUNCTION_LIST_PTR_PTR ppFunctionList);
; 675  : #ifdef GST_WINDOWS
; 676  : 		C_GetFunctionList_t C_GetFunctionList = (C_GetFunctionList_t) GetProcAddress (Pkcs11LibraryHandle, "C_GetFunctionList");

  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GHFGDNNP@C_GetFunctionList?$AA@
  0009b	50		 push	 eax
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8

; 677  : #else
; 678  : 		C_GetFunctionList_t C_GetFunctionList = (C_GetFunctionList_t) dlsym (Pkcs11LibraryHandle, "C_GetFunctionList");
; 679  : #endif
; 680  : 
; 681  : 		if (!C_GetFunctionList)

  000a2	85 c0		 test	 eax, eax
  000a4	75 15		 jne	 SHORT $LN7@InitLibrar

; 682  : 			throw SecurityTokenLibraryNotInitialized();

  000a6	68 00 00 00 00	 push	 OFFSET __TI2?AUSecurityTokenLibraryNotInitialized@GostCrypt@@
  000ab	8d 45 08	 lea	 eax, DWORD PTR $T4[ebp]
  000ae	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7SecurityTokenLibraryNotInitialized@GostCrypt@@6B@
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN91@InitLibrar:
$LN7@InitLibrar:

; 683  : 
; 684  : 		CK_RV status = C_GetFunctionList (&Pkcs11Functions);

  000bb	68 00 00 00 00	 push	 OFFSET ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  000c0	ff d0		 call	 eax
  000c2	83 c4 04	 add	 esp, 4

; 685  : 		if (status != CKR_OK)

  000c5	85 c0		 test	 eax, eax
  000c7	74 1c		 je	 SHORT $LN8@InitLibrar
$LN89@InitLibrar:

; 686  : 			throw Pkcs11Exception (status);

  000c9	89 45 d8	 mov	 DWORD PTR $T2[ebp+4], eax
  000cc	8d 45 d4	 lea	 eax, DWORD PTR $T2[ebp]
  000cf	68 00 00 00 00	 push	 OFFSET __TI2?AUPkcs11Exception@GostCrypt@@
  000d4	50		 push	 eax
  000d5	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  000dc	c6 45 dc 00	 mov	 BYTE PTR $T2[ebp+8], 0
  000e0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN92@InitLibrar:
$LN8@InitLibrar:

; 687  : 
; 688  : 		status = Pkcs11Functions->C_Initialize (NULL_PTR);

  000e5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  000ea	6a 00		 push	 0
  000ec	8b 40 02	 mov	 eax, DWORD PTR [eax+2]
  000ef	ff d0		 call	 eax
  000f1	83 c4 04	 add	 esp, 4

; 689  : 		if (status != CKR_OK)

  000f4	85 c0		 test	 eax, eax
  000f6	75 d1		 jne	 SHORT $LN89@InitLibrar

; 690  : 			throw Pkcs11Exception (status);
; 691  : 
; 692  : 		PinCallback = pinCallback;

  000f8	8b 75 0c	 mov	 esi, DWORD PTR _pinCallback$[ebp]
  000fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?PinCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@A ; GostCrypt::SecurityToken::PinCallback
  00101	89 45 0c	 mov	 DWORD PTR _pinCallback$[ebp], eax
  00104	3b f1		 cmp	 esi, ecx
  00106	74 0d		 je	 SHORT $LN63@InitLibrar
  00108	85 c9		 test	 ecx, ecx
  0010a	74 09		 je	 SHORT $LN63@InitLibrar
  0010c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0010e	6a 01		 push	 1
  00110	ff 10		 call	 DWORD PTR [eax]
  00112	8b 45 0c	 mov	 eax, DWORD PTR _pinCallback$[ebp]
$LN63@InitLibrar:

; 693  : 		WarningCallback = warningCallback;

  00115	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?WarningCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@A ; GostCrypt::SecurityToken::WarningCallback
  0011b	33 c9		 xor	 ecx, ecx
  0011d	89 35 00 00 00
	00		 mov	 DWORD PTR ?PinCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@A, esi ; GostCrypt::SecurityToken::PinCallback
  00123	8b 75 10	 mov	 esi, DWORD PTR _warningCallback$[ebp]
  00126	89 4d 10	 mov	 DWORD PTR _warningCallback$[ebp], ecx
  00129	3b f2		 cmp	 esi, edx
  0012b	74 12		 je	 SHORT $LN74@InitLibrar
  0012d	85 d2		 test	 edx, edx
  0012f	74 0e		 je	 SHORT $LN74@InitLibrar
  00131	8b 02		 mov	 eax, DWORD PTR [edx]
  00133	8b ca		 mov	 ecx, edx
  00135	6a 01		 push	 1
  00137	ff 10		 call	 DWORD PTR [eax]
  00139	8b 4d 10	 mov	 ecx, DWORD PTR _warningCallback$[ebp]
  0013c	8b 45 0c	 mov	 eax, DWORD PTR _pinCallback$[ebp]
$LN74@InitLibrar:
  0013f	89 35 00 00 00
	00		 mov	 DWORD PTR ?WarningCallback@SecurityToken@GostCrypt@@1V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@A, esi ; GostCrypt::SecurityToken::WarningCallback

; 694  : 
; 695  : 		Initialized = true;

  00145	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?Initialized@SecurityToken@GostCrypt@@1_NA, 1 ; GostCrypt::SecurityToken::Initialized

; 696  : 	}

  0014c	85 c0		 test	 eax, eax
  0014e	74 0b		 je	 SHORT $LN78@InitLibrar
  00150	8b 10		 mov	 edx, DWORD PTR [eax]
  00152	8b c8		 mov	 ecx, eax
  00154	6a 01		 push	 1
  00156	ff 12		 call	 DWORD PTR [edx]
  00158	8b 4d 10	 mov	 ecx, DWORD PTR _warningCallback$[ebp]
$LN78@InitLibrar:
  0015b	85 c9		 test	 ecx, ecx
  0015d	74 06		 je	 SHORT $LN83@InitLibrar
  0015f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00161	6a 01		 push	 1
  00163	ff 10		 call	 DWORD PTR [eax]
$LN83@InitLibrar:
  00165	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00168	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016f	59		 pop	 ecx
  00170	5e		 pop	 esi
  00171	8b e5		 mov	 esp, ebp
  00173	5d		 pop	 ebp
  00174	c3		 ret	 0
$LN88@InitLibrar:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InitLibrary@SecurityToken@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$auto_ptr@UGetPinFunctor@GostCrypt@@@4@V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@4@@Z$0:
  00000	8d 4d 10	 lea	 ecx, DWORD PTR _warningCallback$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$auto_ptr@USendExceptionFunctor@GostCrypt@@@std@@QAE@XZ ; std::auto_ptr<GostCrypt::SendExceptionFunctor>::~auto_ptr<GostCrypt::SendExceptionFunctor>
__unwindfunclet$?InitLibrary@SecurityToken@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$auto_ptr@UGetPinFunctor@GostCrypt@@@4@V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@4@@Z$1:
  00008	8d 4d 0c	 lea	 ecx, DWORD PTR _pinCallback$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$auto_ptr@UGetPinFunctor@GostCrypt@@@std@@QAE@XZ ; std::auto_ptr<GostCrypt::GetPinFunctor>::~auto_ptr<GostCrypt::GetPinFunctor>
__ehhandler$?InitLibrary@SecurityToken@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$auto_ptr@UGetPinFunctor@GostCrypt@@@4@V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@4@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?InitLibrary@SecurityToken@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$auto_ptr@UGetPinFunctor@GostCrypt@@@4@V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@4@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?InitLibrary@SecurityToken@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$auto_ptr@UGetPinFunctor@GostCrypt@@@4@V?$auto_ptr@USendExceptionFunctor@GostCrypt@@@4@@Z ENDP ; GostCrypt::SecurityToken::InitLibrary
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -252				; size = 4
$T2 = -248						; size = 4
___$ReturnUdt$GSCopy$1$ = -244				; size = 4
__Ch$ = -240						; size = 1
_info$ = -236						; size = 160
$T3 = -76						; size = 24
$T4 = -76						; size = 24
$T5 = -76						; size = 24
_label$ = -52						; size = 33
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_slotId$ = 12						; size = 4
?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z PROC ; GostCrypt::SecurityToken::GetTokenInfo, COMDAT

; 363  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]

; 364  : 		CK_TOKEN_INFO info;
; 365  : 		CK_RV status = Pkcs11Functions->C_GetTokenInfo (slotId, &info);

  00030	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _info$[ebp]
  00036	50		 push	 eax
  00037	ff 75 0c	 push	 DWORD PTR _slotId$[ebp]
  0003a	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  00044	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00050	89 bd 0c ff ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], edi
  00056	89 bd 04 ff ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], edi
  0005c	8b 40 1a	 mov	 eax, DWORD PTR [eax+26]
  0005f	ff d0		 call	 eax
  00061	83 c4 08	 add	 esp, 8

; 366  : 		if (status != CKR_OK)

  00064	85 c0		 test	 eax, eax
  00066	74 1c		 je	 SHORT $LN2@GetTokenIn

; 367  : 			throw Pkcs11Exception (status);

  00068	89 45 b8	 mov	 DWORD PTR $T5[ebp+4], eax
  0006b	8d 45 b4	 lea	 eax, DWORD PTR $T5[ebp]
  0006e	68 00 00 00 00	 push	 OFFSET __TI2?AUPkcs11Exception@GostCrypt@@
  00073	50		 push	 eax
  00074	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  0007b	c6 45 bc 00	 mov	 BYTE PTR $T5[ebp+8], 0
  0007f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN767@GetTokenIn:
$LN2@GetTokenIn:

; 368  : 
; 369  : 		SecurityTokenInfo token;

  00084	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  00087	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0008e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00095	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00099	72 04		 jb	 SHORT $LN120@GetTokenIn
  0009b	8b 06		 mov	 eax, DWORD PTR [esi]
  0009d	eb 02		 jmp	 SHORT $LN121@GetTokenIn
$LN120@GetTokenIn:
  0009f	8b c6		 mov	 eax, esi
$LN121@GetTokenIn:
  000a1	83 c7 20	 add	 edi, 32			; 00000020H
  000a4	33 c9		 xor	 ecx, ecx
  000a6	66 89 08	 mov	 WORD PTR [eax], cx
  000a9	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
  000b0	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  000b3	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  000b7	72 04		 jb	 SHORT $LN227@GetTokenIn
  000b9	8b 07		 mov	 eax, DWORD PTR [edi]
  000bb	eb 02		 jmp	 SHORT $LN228@GetTokenIn
$LN227@GetTokenIn:
  000bd	8b c7		 mov	 eax, edi
$LN228@GetTokenIn:
  000bf	88 08		 mov	 BYTE PTR [eax], cl

; 387  : #else
; 388  : 		token.Label = StringConverter::ToWide (token.LabelUtf8);
; 389  : #endif
; 390  : 		return token;

  000c1	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  000c7	0f 57 c0	 xorps	 xmm0, xmm0
  000ca	8b 45 0c	 mov	 eax, DWORD PTR _slotId$[ebp]
  000cd	0f 10 8d 14 ff
	ff ff		 movups	 xmm1, XMMWORD PTR _info$[ebp]
  000d4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000db	89 01		 mov	 DWORD PTR [ecx], eax
  000dd	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _info$[ebp+96]
  000e3	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000e6	0f 11 45 cc	 movups	 XMMWORD PTR _label$[ebp], xmm0
  000ea	c7 85 08 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T2[ebp], 1
  000f4	0f 11 45 dc	 movups	 XMMWORD PTR _label$[ebp+16], xmm0
  000f8	c6 45 ec 00	 mov	 BYTE PTR _label$[ebp+32], 0
  000fc	0f 10 85 24 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _info$[ebp+16]
  00103	66 0f 7e c8	 movd	 eax, xmm1
  00107	0f 11 4d cc	 movups	 XMMWORD PTR _label$[ebp], xmm1
  0010b	0f 11 45 dc	 movups	 XMMWORD PTR _label$[ebp+16], xmm0
  0010f	84 c0		 test	 al, al
  00111	75 04		 jne	 SHORT $LN240@GetTokenIn

; 370  : 		token.SlotId = slotId;
; 371  : 		token.Flags = info.flags;
; 372  : 
; 373  : 		char label[sizeof (info.label) + 1];
; 374  : 		memset (label, 0, sizeof (label));
; 375  : 		memcpy (label, info.label, sizeof (info.label));
; 376  : 
; 377  : 		token.LabelUtf8 = label;

  00113	33 c9		 xor	 ecx, ecx
  00115	eb 12		 jmp	 SHORT $LN241@GetTokenIn
$LN240@GetTokenIn:
  00117	8d 4d cc	 lea	 ecx, DWORD PTR _label$[ebp]
  0011a	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0011d	0f 1f 00	 npad	 3
$LL764@GetTokenIn:
  00120	8a 01		 mov	 al, BYTE PTR [ecx]
  00122	41		 inc	 ecx
  00123	84 c0		 test	 al, al
  00125	75 f9		 jne	 SHORT $LL764@GetTokenIn
  00127	2b ca		 sub	 ecx, edx
$LN241@GetTokenIn:
  00129	51		 push	 ecx
  0012a	8d 45 cc	 lea	 eax, DWORD PTR _label$[ebp]
  0012d	8b cf		 mov	 ecx, edi
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 378  : 
; 379  : 		size_t lastSpace = token.LabelUtf8.find_last_not_of (' ');

  00135	6a 01		 push	 1
  00137	6a ff		 push	 -1
  00139	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR __Ch$[ebp]
  0013f	c6 85 10 ff ff
	ff 20		 mov	 BYTE PTR __Ch$[ebp], 32	; 00000020H
  00146	50		 push	 eax
  00147	8b cf		 mov	 ecx, edi
  00149	e8 00 00 00 00	 call	 ?find_last_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_not_of

; 380  : 		if (lastSpace == string::npos)

  0014e	83 f8 ff	 cmp	 eax, -1
  00151	75 1b		 jne	 SHORT $LN3@GetTokenIn

; 381  : 			token.LabelUtf8.clear();

  00153	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00157	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  0015e	72 07		 jb	 SHORT $LN257@GetTokenIn
  00160	8b 07		 mov	 eax, DWORD PTR [edi]
  00162	c6 00 00	 mov	 BYTE PTR [eax], 0

; 382  : 		else

  00165	eb 33		 jmp	 SHORT $LN270@GetTokenIn

; 381  : 			token.LabelUtf8.clear();

$LN257@GetTokenIn:
  00167	8b c7		 mov	 eax, edi
  00169	c6 00 00	 mov	 BYTE PTR [eax], 0

; 382  : 		else

  0016c	eb 2c		 jmp	 SHORT $LN270@GetTokenIn
$LN3@GetTokenIn:

; 383  : 			token.LabelUtf8 = token.LabelUtf8.substr (0, lastSpace + 1);

  0016e	40		 inc	 eax
  0016f	8b cf		 mov	 ecx, edi
  00171	50		 push	 eax
  00172	6a 00		 push	 0
  00174	8d 45 b4	 lea	 eax, DWORD PTR $T4[ebp]
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  0017d	50		 push	 eax
  0017e	8b cf		 mov	 ecx, edi
  00180	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  00185	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp+20]
  00188	83 f8 10	 cmp	 eax, 16			; 00000010H
  0018b	72 0d		 jb	 SHORT $LN270@GetTokenIn
  0018d	40		 inc	 eax
  0018e	8d 4d b4	 lea	 ecx, DWORD PTR $T4[ebp]
  00191	50		 push	 eax
  00192	ff 75 b4	 push	 DWORD PTR $T4[ebp]
  00195	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN270@GetTokenIn:

; 384  : 
; 385  : #if defined (GST_WINDOWS) && !defined (GST_PROTOTYPE)
; 386  : 		token.Label = Utf8StringToWide (token.LabelUtf8);

  0019a	8d 45 b4	 lea	 eax, DWORD PTR $T3[ebp]
  0019d	57		 push	 edi
  0019e	50		 push	 eax
  0019f	e8 00 00 00 00	 call	 ?Utf8StringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; Utf8StringToWide
  001a4	83 c4 08	 add	 esp, 8
  001a7	8b f8		 mov	 edi, eax
  001a9	3b f7		 cmp	 esi, edi
  001ab	74 3a		 je	 SHORT $LN369@GetTokenIn
  001ad	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001b0	83 f8 08	 cmp	 eax, 8
  001b3	72 0b		 jb	 SHORT $LN375@GetTokenIn
  001b5	40		 inc	 eax
  001b6	8b ce		 mov	 ecx, esi
  001b8	50		 push	 eax
  001b9	ff 36		 push	 DWORD PTR [esi]
  001bb	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN375@GetTokenIn:
  001c0	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  001c7	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  001cb	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  001d2	72 04		 jb	 SHORT $LN465@GetTokenIn
  001d4	8b 06		 mov	 eax, DWORD PTR [esi]
  001d6	eb 02		 jmp	 SHORT $LN466@GetTokenIn
$LN465@GetTokenIn:
  001d8	8b c6		 mov	 eax, esi
$LN466@GetTokenIn:
  001da	33 c9		 xor	 ecx, ecx
  001dc	66 89 08	 mov	 WORD PTR [eax], cx
  001df	8b ce		 mov	 ecx, esi
  001e1	57		 push	 edi
  001e2	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN369@GetTokenIn:
  001e7	8b 4d c8	 mov	 ecx, DWORD PTR $T3[ebp+20]
  001ea	83 f9 08	 cmp	 ecx, 8
  001ed	72 0d		 jb	 SHORT $LN667@GetTokenIn
  001ef	41		 inc	 ecx
  001f0	51		 push	 ecx
  001f1	ff 75 b4	 push	 DWORD PTR $T3[ebp]
  001f4	8d 4d b4	 lea	 ecx, DWORD PTR $T3[ebp]
  001f7	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN667@GetTokenIn:

; 387  : #else
; 388  : 		token.Label = StringConverter::ToWide (token.LabelUtf8);
; 389  : #endif
; 390  : 		return token;

  001fc	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]

; 391  : 	}

  00202	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00205	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0020c	59		 pop	 ecx
  0020d	5f		 pop	 edi
  0020e	5e		 pop	 esi
  0020f	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00212	33 cd		 xor	 ecx, ebp
  00214	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00219	8b e5		 mov	 esp, ebp
  0021b	5d		 pop	 ebp
  0021c	c3		 ret	 0
$LN766@GetTokenIn:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z$0:
  00000	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  00006	83 e0 01	 and	 eax, 1
  00009	0f 84 12 00 00
	00		 je	 $LN7@GetTokenIn
  0000f	83 a5 08 ff ff
	ff fe		 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00016	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1SecurityTokenInfo@GostCrypt@@QAE@XZ
$LN7@GetTokenIn:
  00021	c3		 ret	 0
__unwindfunclet$?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z$90:
  00022	e8 00 00 00 00	 call	 ___std_terminate
  00027	c3		 ret	 0
__ehhandler$?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z:
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 8a 04 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-252]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0003f	33 c8		 xor	 ecx, eax
  00041	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00046	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z
  0004b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z ENDP ; GostCrypt::SecurityToken::GetTokenInfo
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ
_TEXT	SEGMENT
$T2 = -164						; size = 24
_e$3 = -140						; size = 4
___$ReturnUdt$GSCopy$ = -136				; size = 4
_slotId$4 = -132					; size = 4
_$S5$5 = -128						; size = 24
$T6 = -104						; size = 8
$T7 = -96						; size = 8
_forEachContainer$8 = -88				; size = 4
$T9 = -84						; size = 4
_unrecognizedTokenPresent$ = -77			; size = 1
$T10 = -76						; size = 56
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ PROC ; GostCrypt::SecurityToken::GetAvailableTokens, COMDAT

; 326  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]

; 327  : 		bool unrecognizedTokenPresent = false;
; 328  : 		list <SecurityTokenInfo> tokens;

  00034	8b cf		 mov	 ecx, edi
  00036	6a 00		 push	 0
  00038	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR $T9[ebp], 0
  0003f	6a 00		 push	 0
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00048	89 bd 78 ff ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], edi
  0004e	c6 45 b3 00	 mov	 BYTE PTR _unrecognizedTokenPresent$[ebp], 0
  00052	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00058	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0005f	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> > >::_Buynode0
  00064	89 07		 mov	 DWORD PTR [edi], eax

; 350  : 
; 351  : 		return tokens;

  00066	8d 45 a0	 lea	 eax, DWORD PTR $T7[ebp]
  00069	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00070	50		 push	 eax
  00071	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR $T9[ebp], 1
  00078	e8 00 00 00 00	 call	 ?GetTokenSlots@SecurityToken@GostCrypt@@KA?AV?$list@KV?$allocator@K@std@@@std@@XZ ; GostCrypt::SecurityToken::GetTokenSlots
  0007d	50		 push	 eax
  0007e	8d 45 80	 lea	 eax, DWORD PTR _$S5$5[ebp]
  00081	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00091	8d 75 80	 lea	 esi, DWORD PTR _$S5$5[ebp]
  00094	89 75 a8	 mov	 DWORD PTR _forEachContainer$8[ebp], esi
  00097	8b 45 a0	 mov	 eax, DWORD PTR $T7[ebp]
  0009a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	89 00		 mov	 DWORD PTR [eax], eax
  000a2	8b 45 a0	 mov	 eax, DWORD PTR $T7[ebp]
  000a5	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000a8	8b 45 a0	 mov	 eax, DWORD PTR $T7[ebp]
  000ab	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR $T7[ebp+4], 0
  000b2	3b c8		 cmp	 ecx, eax
  000b4	74 17		 je	 SHORT $LN58@GetAvailab

; 329  : 
; 330  : 		foreach (const CK_SLOT_ID &slotId, GetTokenSlots())

$LL59@GetAvailab:
  000b6	8b 31		 mov	 esi, DWORD PTR [ecx]
  000b8	51		 push	 ecx
  000b9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000be	8b 45 a0	 mov	 eax, DWORD PTR $T7[ebp]
  000c1	83 c4 04	 add	 esp, 4
  000c4	8b ce		 mov	 ecx, esi
  000c6	3b f0		 cmp	 esi, eax
  000c8	75 ec		 jne	 SHORT $LL59@GetAvailab
  000ca	8b 75 a8	 mov	 esi, DWORD PTR _forEachContainer$8[ebp]
$LN58@GetAvailab:
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d3	83 c4 04	 add	 esp, 4
$LL4@GetAvailab:
  000d6	8b 06		 mov	 eax, DWORD PTR [esi]
  000d8	8d 4d 80	 lea	 ecx, DWORD PTR _$S5$5[ebp]
  000db	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000de	ff d0		 call	 eax
  000e0	84 c0		 test	 al, al
  000e2	0f 84 ce 01 00
	00		 je	 $LN3@GetAvailab
  000e8	8b 5d 94	 mov	 ebx, DWORD PTR _$S5$5[ebp+20]
  000eb	8b 45 ac	 mov	 eax, DWORD PTR $T9[ebp]
  000ee	83 c3 08	 add	 ebx, 8
  000f1	89 9d 7c ff ff
	ff		 mov	 DWORD PTR _slotId$4[ebp], ebx
  000f7	a8 02		 test	 al, 2
  000f9	74 45		 je	 SHORT $LL1128@GetAvailab
  000fb	83 e0 fd	 and	 eax, -3			; fffffffdH
  000fe	89 45 ac	 mov	 DWORD PTR $T9[ebp], eax
  00101	8b 45 98	 mov	 eax, DWORD PTR $T6[ebp]
  00104	8b 08		 mov	 ecx, DWORD PTR [eax]
  00106	89 00		 mov	 DWORD PTR [eax], eax
  00108	8b 45 98	 mov	 eax, DWORD PTR $T6[ebp]
  0010b	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0010e	8b 45 98	 mov	 eax, DWORD PTR $T6[ebp]
  00111	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T6[ebp+4], 0
  00118	3b c8		 cmp	 ecx, eax
  0011a	74 18		 je	 SHORT $LN290@GetAvailab
  0011c	0f 1f 40 00	 npad	 4
$LL291@GetAvailab:
  00120	8b 31		 mov	 esi, DWORD PTR [ecx]
  00122	51		 push	 ecx
  00123	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00128	8b 45 98	 mov	 eax, DWORD PTR $T6[ebp]
  0012b	83 c4 04	 add	 esp, 4
  0012e	8b ce		 mov	 ecx, esi
  00130	3b f0		 cmp	 esi, eax
  00132	75 ec		 jne	 SHORT $LL291@GetAvailab
$LN290@GetAvailab:
  00134	50		 push	 eax
  00135	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0013a	83 c4 04	 add	 esp, 4
  0013d	0f 1f 00	 npad	 3
$LL1128@GetAvailab:
  00140	33 c0		 xor	 eax, eax
  00142	38 45 85	 cmp	 BYTE PTR _$S5$5[ebp+5], al
  00145	0f 94 c0	 sete	 al
  00148	88 45 85	 mov	 BYTE PTR _$S5$5[ebp+5], al
  0014b	84 c0		 test	 al, al
  0014d	0f 84 53 01 00
	00		 je	 $LN2@GetAvailab

; 331  : 		{
; 332  : 			try
; 333  : 			{
; 334  : 				tokens.push_back (GetTokenInfo (slotId));

  00153	ff 33		 push	 DWORD PTR [ebx]
  00155	8d 45 b4	 lea	 eax, DWORD PTR $T10[ebp]
  00158	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 ?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z ; GostCrypt::SecurityToken::GetTokenInfo
  00162	83 c4 08	 add	 esp, 8
  00165	8b 37		 mov	 esi, DWORD PTR [edi]
  00167	8b cf		 mov	 ecx, edi
  00169	50		 push	 eax
  0016a	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  0016e	ff 76 04	 push	 DWORD PTR [esi+4]
  00171	56		 push	 esi
  00172	e8 00 00 00 00	 call	 ??$_Buynode@USecurityTokenInfo@GostCrypt@@@?$_List_buy@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@USecurityTokenInfo@GostCrypt@@PAX@1@PAU21@0$$QAUSecurityTokenInfo@GostCrypt@@@Z ; std::_List_buy<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::_Buynode<GostCrypt::SecurityTokenInfo>
  00177	8b c8		 mov	 ecx, eax
  00179	b8 fe ff ff 03	 mov	 eax, 67108862		; 03fffffeH
  0017e	2b 47 04	 sub	 eax, DWORD PTR [edi+4]
  00181	83 f8 01	 cmp	 eax, 1
  00184	73 0a		 jae	 SHORT $LN548@GetAvailab
  00186	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0018b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN1134@GetAvailab:
$LN548@GetAvailab:
  00190	ff 47 04	 inc	 DWORD PTR [edi+4]
  00193	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00196	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00199	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  0019d	89 08		 mov	 DWORD PTR [eax], ecx
  0019f	8b 4d e8	 mov	 ecx, DWORD PTR $T10[ebp+52]
  001a2	83 f9 10	 cmp	 ecx, 16			; 00000010H
  001a5	72 42		 jb	 SHORT $LN689@GetAvailab
  001a7	8b 45 d4	 mov	 eax, DWORD PTR $T10[ebp+32]
  001aa	41		 inc	 ecx
  001ab	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001b1	72 2d		 jb	 SHORT $LN684@GetAvailab
  001b3	a8 1f		 test	 al, 31			; 0000001fH
  001b5	74 05		 je	 SHORT $LN685@GetAvailab
  001b7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1135@GetAvailab:
$LN685@GetAvailab:
  001bc	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  001bf	3b c8		 cmp	 ecx, eax
  001c1	72 05		 jb	 SHORT $LN686@GetAvailab
  001c3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1136@GetAvailab:
$LN686@GetAvailab:
  001c8	2b c1		 sub	 eax, ecx
  001ca	83 f8 04	 cmp	 eax, 4
  001cd	73 05		 jae	 SHORT $LN687@GetAvailab
  001cf	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1137@GetAvailab:
$LN687@GetAvailab:
  001d4	83 f8 23	 cmp	 eax, 35			; 00000023H
  001d7	76 05		 jbe	 SHORT $LN688@GetAvailab
  001d9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1138@GetAvailab:
$LN688@GetAvailab:
  001de	8b c1		 mov	 eax, ecx
$LN684@GetAvailab:
  001e0	50		 push	 eax
  001e1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001e6	83 c4 04	 add	 esp, 4
$LN689@GetAvailab:
  001e9	8b 45 d0	 mov	 eax, DWORD PTR $T10[ebp+28]
  001ec	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR $T10[ebp+52], 15 ; 0000000fH
  001f3	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T10[ebp+48], 0
  001fa	c6 45 d4 00	 mov	 BYTE PTR $T10[ebp+32], 0
  001fe	83 f8 08	 cmp	 eax, 8
  00201	0f 82 86 00 00
	00		 jb	 $LN809@GetAvailab
  00207	8b 4d bc	 mov	 ecx, DWORD PTR $T10[ebp+8]
  0020a	40		 inc	 eax
  0020b	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00210	76 05		 jbe	 SHORT $LN803@GetAvailab
  00212	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1139@GetAvailab:
$LN803@GetAvailab:
  00217	03 c0		 add	 eax, eax
  00219	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0021e	72 2f		 jb	 SHORT $LN804@GetAvailab
  00220	f6 45 bc 1f	 test	 BYTE PTR $T10[ebp+8], 31 ; 0000001fH
  00224	74 05		 je	 SHORT $LN805@GetAvailab
  00226	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1140@GetAvailab:
$LN805@GetAvailab:
  0022b	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0022e	3b c1		 cmp	 eax, ecx
  00230	72 05		 jb	 SHORT $LN806@GetAvailab
  00232	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1141@GetAvailab:
$LN806@GetAvailab:
  00237	2b c8		 sub	 ecx, eax
  00239	83 f9 04	 cmp	 ecx, 4
  0023c	73 05		 jae	 SHORT $LN807@GetAvailab
  0023e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1142@GetAvailab:
$LN807@GetAvailab:
  00243	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00246	76 05		 jbe	 SHORT $LN808@GetAvailab
  00248	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1143@GetAvailab:
$LN808@GetAvailab:
  0024d	8b c8		 mov	 ecx, eax
$LN804@GetAvailab:
  0024f	51		 push	 ecx
  00250	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00255	83 c4 04	 add	 esp, 4
  00258	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  0025f	c6 45 84 01	 mov	 BYTE PTR _$S5$5[ebp+4], 1
  00263	e9 d8 fe ff ff	 jmp	 $LL1128@GetAvailab
__catch$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ$0:

; 335  : 			}
; 336  : 			catch (Pkcs11Exception &e)
; 337  : 			{
; 338  : 				if (e.GetErrorCode() == CKR_TOKEN_NOT_RECOGNIZED)

  00268	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _e$3[ebp]
  0026e	81 78 04 e1 00
	00 00		 cmp	 DWORD PTR [eax+4], 225	; 000000e1H
  00275	75 26		 jne	 SHORT $LN9@GetAvailab

; 339  : 				{
; 340  : 					unrecognizedTokenPresent = true;

  00277	c6 45 b3 01	 mov	 BYTE PTR _unrecognizedTokenPresent$[ebp], 1

; 341  : 					continue;

  0027b	b8 00 00 00 00	 mov	 eax, $LN25@GetAvailab
  00280	c3		 ret	 0
$LN25@GetAvailab:
  00281	8b 9d 7c ff ff
	ff		 mov	 ebx, DWORD PTR _slotId$4[ebp]
  00287	8b bd 78 ff ff
	ff		 mov	 edi, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]

; 331  : 		{
; 332  : 			try
; 333  : 			{
; 334  : 				tokens.push_back (GetTokenInfo (slotId));

$LN809@GetAvailab:
  0028d	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3

; 329  : 
; 330  : 		foreach (const CK_SLOT_ID &slotId, GetTokenSlots())

  00294	c6 45 84 01	 mov	 BYTE PTR _$S5$5[ebp+4], 1
  00298	e9 a3 fe ff ff	 jmp	 $LL1128@GetAvailab
$LN9@GetAvailab:

; 342  : 				}
; 343  : 
; 344  : 				throw;

  0029d	6a 00		 push	 0
  0029f	6a 00		 push	 0
  002a1	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1144@GetAvailab:
$LN2@GetAvailab:

; 329  : 
; 330  : 		foreach (const CK_SLOT_ID &slotId, GetTokenSlots())

  002a6	8b 75 a8	 mov	 esi, DWORD PTR _forEachContainer$8[ebp]
  002a9	8d 4d 80	 lea	 ecx, DWORD PTR _$S5$5[ebp]
  002ac	8b 06		 mov	 eax, DWORD PTR [esi]
  002ae	ff 50 08	 call	 DWORD PTR [eax+8]
  002b1	e9 20 fe ff ff	 jmp	 $LL4@GetAvailab
$LN3@GetAvailab:

; 345  : 			}
; 346  : 		}

  002b6	8b 45 88	 mov	 eax, DWORD PTR _$S5$5[ebp+8]
  002b9	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  002bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  002bf	89 00		 mov	 DWORD PTR [eax], eax
  002c1	8b 45 88	 mov	 eax, DWORD PTR _$S5$5[ebp+8]
  002c4	89 40 04	 mov	 DWORD PTR [eax+4], eax
  002c7	8b 45 88	 mov	 eax, DWORD PTR _$S5$5[ebp+8]
  002ca	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _$S5$5[ebp+12], 0
  002d1	3b c8		 cmp	 ecx, eax
  002d3	74 14		 je	 SHORT $LN852@GetAvailab
$LL853@GetAvailab:
  002d5	8b 31		 mov	 esi, DWORD PTR [ecx]
  002d7	51		 push	 ecx
  002d8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002dd	8b 45 88	 mov	 eax, DWORD PTR _$S5$5[ebp+8]
  002e0	83 c4 04	 add	 esp, 4
  002e3	8b ce		 mov	 ecx, esi
  002e5	3b f0		 cmp	 esi, eax
  002e7	75 ec		 jne	 SHORT $LL853@GetAvailab
$LN852@GetAvailab:
  002e9	50		 push	 eax
  002ea	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002ef	83 c4 04	 add	 esp, 4

; 347  : 
; 348  : 		if (tokens.empty() && unrecognizedTokenPresent)

  002f2	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  002f6	75 32		 jne	 SHORT $LN10@GetAvailab
  002f8	80 7d b3 00	 cmp	 BYTE PTR _unrecognizedTokenPresent$[ebp], 0
  002fc	74 2c		 je	 SHORT $LN10@GetAvailab

; 349  : 			throw Pkcs11Exception (CKR_TOKEN_NOT_RECOGNIZED);

  002fe	68 00 00 00 00	 push	 OFFSET __TI2?AUPkcs11Exception@GostCrypt@@
  00303	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00309	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  00313	50		 push	 eax
  00314	c7 85 60 ff ff
	ff e1 00 00 00	 mov	 DWORD PTR $T2[ebp+4], 225 ; 000000e1H
  0031e	c6 85 64 ff ff
	ff 00		 mov	 BYTE PTR $T2[ebp+8], 0
  00325	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1145@GetAvailab:
$LN10@GetAvailab:

; 350  : 
; 351  : 		return tokens;

  0032a	8b c7		 mov	 eax, edi

; 352  : 	}

  0032c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0032f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00336	59		 pop	 ecx
  00337	5f		 pop	 edi
  00338	5e		 pop	 esi
  00339	5b		 pop	 ebx
  0033a	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033d	33 cd		 xor	 ecx, ebp
  0033f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00344	8b e5		 mov	 esp, ebp
  00346	5d		 pop	 ebp
  00347	c3		 ret	 0
$LN1133@GetAvailab:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ$2:
  00000	8b 45 ac	 mov	 eax, DWORD PTR $T9[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN17@GetAvailab
  0000c	83 65 ac fe	 and	 DWORD PTR $T9[ebp], -2	; fffffffeH
  00010	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@QAE@XZ ; std::list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >::~list<GostCrypt::SecurityTokenInfo,std::allocator<GostCrypt::SecurityTokenInfo> >
$LN17@GetAvailab:
  0001b	c3		 ret	 0
__unwindfunclet$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ$3:
  0001c	8d 4d a0	 lea	 ecx, DWORD PTR $T7[ebp]
  0001f	e9 00 00 00 00	 jmp	 ??1?$list@KV?$allocator@K@std@@@std@@QAE@XZ ; std::list<unsigned long,std::allocator<unsigned long> >::~list<unsigned long,std::allocator<unsigned long> >
__unwindfunclet$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ$4:
  00024	8d 4d 80	 lea	 ecx, DWORD PTR _$S5$5[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ$6:
  0002c	8d 4d b4	 lea	 ecx, DWORD PTR $T10[ebp]
  0002f	e9 00 00 00 00	 jmp	 ??1SecurityTokenInfo@GostCrypt@@QAE@XZ
__ehhandler$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ:
  00034	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00038	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003b	8b 8a 58 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-168]
  00041	33 c8		 xor	 ecx, eax
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0004b	33 c8		 xor	 ecx, eax
  0004d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00052	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ
  00057	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetAvailableTokens@SecurityToken@GostCrypt@@SA?AV?$list@USecurityTokenInfo@GostCrypt@@V?$allocator@USecurityTokenInfo@GostCrypt@@@std@@@std@@XZ ENDP ; GostCrypt::SecurityToken::GetAvailableTokens
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?GetKeyfileData@SecurityToken@GostCrypt@@SAXABUSecurityTokenKeyfile@2@AAV?$vector@EV?$allocator@E@std@@@std@@@Z
_TEXT	SEGMENT
_keyfile$ = 8						; size = 4
_keyfileData$ = 12					; size = 4
?GetKeyfileData@SecurityToken@GostCrypt@@SAXABUSecurityTokenKeyfile@2@AAV?$vector@EV?$allocator@E@std@@@std@@@Z PROC ; GostCrypt::SecurityToken::GetKeyfileData, COMDAT

; 403  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 404  : 		LoginUserIfRequired (keyfile.SlotId);

  00004	8b 75 08	 mov	 esi, DWORD PTR _keyfile$[ebp]
  00007	ff 76 34	 push	 DWORD PTR [esi+52]
  0000a	e8 00 00 00 00	 call	 ?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z ; GostCrypt::SecurityToken::LoginUserIfRequired

; 405  : 		GetObjectAttribute (keyfile.SlotId, keyfile.Handle, CKA_VALUE, keyfileData);

  0000f	ff 75 0c	 push	 DWORD PTR _keyfileData$[ebp]
  00012	6a 11		 push	 17			; 00000011H
  00014	ff 36		 push	 DWORD PTR [esi]
  00016	ff 76 34	 push	 DWORD PTR [esi+52]
  00019	e8 00 00 00 00	 call	 ?GetObjectAttribute@SecurityToken@GostCrypt@@KAXKKKAAV?$vector@EV?$allocator@E@std@@@std@@@Z ; GostCrypt::SecurityToken::GetObjectAttribute
  0001e	83 c4 14	 add	 esp, 20			; 00000014H
  00021	5e		 pop	 esi

; 406  : 	}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?GetKeyfileData@SecurityToken@GostCrypt@@SAXABUSecurityTokenKeyfile@2@AAV?$vector@EV?$allocator@E@std@@@std@@@Z ENDP ; GostCrypt::SecurityToken::GetKeyfileData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z
_TEXT	SEGMENT
$T2 = -432						; size = 24
_e$3 = -408						; size = 4
_$S3$4 = -404						; size = 24
$T5 = -380						; size = 12
$T6 = -368						; size = 12
$T7 = -356						; size = 8
_label$8 = -348						; size = 12
$T9 = -336						; size = 8
_forEachContainer$10 = -328				; size = 4
___$ReturnUdt$GSCopy$ = -324				; size = 4
_slotId$11 = -320					; size = 4
_privateAttrib$12 = -316				; size = 12
___$ReturnUdt$GSCopy$1$ = -304				; size = 4
$T13 = -300						; size = 4
$T14 = -294						; size = 1
_unrecognizedTokenPresent$ = -293			; size = 1
$T15 = -292						; size = 24
_token$16 = -268					; size = 56
$T17 = -212						; size = 24
_keyfile$18 = -188					; size = 112
$T19 = -76						; size = 56
_$S4$20 = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_slotIdFilter$ = 12					; size = 4
_keyfileIdFilter$ = 16					; size = 24
?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z PROC ; GostCrypt::SecurityToken::GetAvailableKeyfiles, COMDAT

; 247  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a4 01 00
	00		 sub	 esp, 420		; 000001a4H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00034	89 b5 d0 fe ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], esi
  0003a	89 b5 bc fe ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi
  00040	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp], 0
  0004a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 248  : 		bool unrecognizedTokenPresent = false;

  00051	c6 85 db fe ff
	ff 00		 mov	 BYTE PTR _unrecognizedTokenPresent$[ebp], 0

; 249  : 		vector <SecurityTokenKeyfile> keyfiles;

  00058	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0005e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00065	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 314  : 
; 315  : 		return keyfiles;

  0006c	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  00072	bb 01 00 00 00	 mov	 ebx, 1
  00077	50		 push	 eax
  00078	89 9d d4 fe ff
	ff		 mov	 DWORD PTR $T13[ebp], ebx
  0007e	e8 00 00 00 00	 call	 ?GetTokenSlots@SecurityToken@GostCrypt@@KA?AV?$list@KV?$allocator@K@std@@@std@@XZ ; GostCrypt::SecurityToken::GetTokenSlots
  00083	50		 push	 eax
  00084	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR _$S3$4[ebp]
  0008a	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@01@ABV?$list@KV?$allocator@K@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::list<unsigned long,std::allocator<unsigned long> > >
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH
  00097	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR _$S3$4[ebp]
  0009d	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _forEachContainer$10[ebp], eax
  000a3	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  000a9	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  000ad	8b 08		 mov	 ecx, DWORD PTR [eax]
  000af	89 00		 mov	 DWORD PTR [eax], eax
  000b1	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  000b7	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000ba	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  000c0	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+4], 0
  000ca	3b c8		 cmp	 ecx, eax
  000cc	74 19		 je	 SHORT $LN74@GetAvailab
  000ce	66 90		 npad	 2

; 250  : 
; 251  : 		foreach (const CK_SLOT_ID &slotId, GetTokenSlots())

$LL75@GetAvailab:
  000d0	8b 31		 mov	 esi, DWORD PTR [ecx]
  000d2	51		 push	 ecx
  000d3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d8	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  000de	83 c4 04	 add	 esp, 4
  000e1	8b ce		 mov	 ecx, esi
  000e3	3b f0		 cmp	 esi, eax
  000e5	75 e9		 jne	 SHORT $LL75@GetAvailab
$LN74@GetAvailab:
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ed	83 c4 04	 add	 esp, 4
$LL4@GetAvailab:
  000f0	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _forEachContainer$10[ebp]
  000f6	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR _$S3$4[ebp]
  000fc	8b 00		 mov	 eax, DWORD PTR [eax]
  000fe	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00101	ff d0		 call	 eax
  00103	84 c0		 test	 al, al
  00105	0f 84 61 06 00
	00		 je	 $LN3@GetAvailab
  0010b	8b bd 80 fe ff
	ff		 mov	 edi, DWORD PTR _$S3$4[ebp+20]
  00111	83 c7 08	 add	 edi, 8
  00114	89 bd c0 fe ff
	ff		 mov	 DWORD PTR _slotId$11[ebp], edi
  0011a	f6 c3 02	 test	 bl, 2
  0011d	74 51		 je	 SHORT $LL3197@GetAvailab
  0011f	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  00125	83 e3 fd	 and	 ebx, -3			; fffffffdH
  00128	89 9d d4 fe ff
	ff		 mov	 DWORD PTR $T13[ebp], ebx
  0012e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00130	89 00		 mov	 DWORD PTR [eax], eax
  00132	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  00138	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0013b	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  00141	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+4], 0
  0014b	3b c8		 cmp	 ecx, eax
  0014d	74 18		 je	 SHORT $LN306@GetAvailab
  0014f	90		 npad	 1
$LL307@GetAvailab:
  00150	8b 31		 mov	 esi, DWORD PTR [ecx]
  00152	51		 push	 ecx
  00153	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00158	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  0015e	83 c4 04	 add	 esp, 4
  00161	8b ce		 mov	 ecx, esi
  00163	3b f0		 cmp	 esi, eax
  00165	75 e9		 jne	 SHORT $LL307@GetAvailab
$LN306@GetAvailab:
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0016d	83 c4 04	 add	 esp, 4
$LL3197@GetAvailab:
  00170	33 c0		 xor	 eax, eax
  00172	38 85 71 fe ff
	ff		 cmp	 BYTE PTR _$S3$4[ebp+5], al
  00178	0f 94 c0	 sete	 al
  0017b	88 85 71 fe ff
	ff		 mov	 BYTE PTR _$S3$4[ebp+5], al
  00181	84 c0		 test	 al, al
  00183	0f 84 c7 05 00
	00		 je	 $LN2@GetAvailab

; 252  : 		{
; 253  : 			SecurityTokenInfo token;

  00189	33 c0		 xor	 eax, eax
  0018b	c7 85 10 ff ff
	ff 07 00 00 00	 mov	 DWORD PTR _token$16[ebp+28], 7
  00195	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _token$16[ebp+24], 0
  0019f	66 89 85 fc fe
	ff ff		 mov	 WORD PTR _token$16[ebp+8], ax
  001a6	c7 85 28 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR _token$16[ebp+52], 15 ; 0000000fH
  001b0	89 85 24 ff ff
	ff		 mov	 DWORD PTR _token$16[ebp+48], eax
  001b6	88 85 14 ff ff
	ff		 mov	 BYTE PTR _token$16[ebp+32], al

; 254  : 
; 255  : 			if (slotIdFilter && *slotIdFilter != slotId)

  001bc	8b 45 0c	 mov	 eax, DWORD PTR _slotIdFilter$[ebp]
  001bf	85 c0		 test	 eax, eax
  001c1	74 13		 je	 SHORT $LN14@GetAvailab
  001c3	8b 00		 mov	 eax, DWORD PTR [eax]
  001c5	3b 07		 cmp	 eax, DWORD PTR [edi]
  001c7	74 0d		 je	 SHORT $LN14@GetAvailab

; 256  : 				continue;

  001c9	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  001cd	c6 85 70 fe ff
	ff 01		 mov	 BYTE PTR _$S3$4[ebp+4], 1
  001d4	eb 9a		 jmp	 SHORT $LL3197@GetAvailab
$LN14@GetAvailab:

; 257  : 
; 258  : 			try
; 259  : 			{
; 260  : 				LoginUserIfRequired (slotId);

  001d6	ff 37		 push	 DWORD PTR [edi]
  001d8	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  001dc	e8 00 00 00 00	 call	 ?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z ; GostCrypt::SecurityToken::LoginUserIfRequired
  001e1	83 c4 04	 add	 esp, 4

; 261  : 				token = GetTokenInfo (slotId);

  001e4	8d 45 b4	 lea	 eax, DWORD PTR $T19[ebp]
  001e7	ff 37		 push	 DWORD PTR [edi]
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 ?GetTokenInfo@SecurityToken@GostCrypt@@SA?AUSecurityTokenInfo@2@K@Z ; GostCrypt::SecurityToken::GetTokenInfo
  001ef	83 c4 08	 add	 esp, 8
  001f2	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _token$16[ebp]
  001f8	50		 push	 eax
  001f9	e8 00 00 00 00	 call	 ??4SecurityTokenInfo@GostCrypt@@QAEAAU01@$$QAU01@@Z
  001fe	8b 45 e8	 mov	 eax, DWORD PTR $T19[ebp+52]
  00201	83 f8 10	 cmp	 eax, 16			; 00000010H
  00204	72 42		 jb	 SHORT $LN1105@GetAvailab
  00206	8b 4d d4	 mov	 ecx, DWORD PTR $T19[ebp+32]
  00209	40		 inc	 eax
  0020a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0020f	72 2e		 jb	 SHORT $LN1100@GetAvailab
  00211	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00214	74 05		 je	 SHORT $LN1101@GetAvailab
  00216	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN3209@GetAvailab:
$LN1101@GetAvailab:
  0021b	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0021e	3b c1		 cmp	 eax, ecx
  00220	72 05		 jb	 SHORT $LN1102@GetAvailab
  00222	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN3210@GetAvailab:
$LN1102@GetAvailab:
  00227	2b c8		 sub	 ecx, eax
  00229	83 f9 04	 cmp	 ecx, 4
  0022c	73 05		 jae	 SHORT $LN1103@GetAvailab
  0022e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN3211@GetAvailab:
$LN1103@GetAvailab:
  00233	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00236	76 05		 jbe	 SHORT $LN1104@GetAvailab
  00238	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN3212@GetAvailab:
$LN1104@GetAvailab:
  0023d	8b c8		 mov	 ecx, eax
$LN1100@GetAvailab:
  0023f	51		 push	 ecx
  00240	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00245	83 c4 04	 add	 esp, 4
$LN1105@GetAvailab:
  00248	8b 45 d0	 mov	 eax, DWORD PTR $T19[ebp+28]
  0024b	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR $T19[ebp+52], 15 ; 0000000fH
  00252	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T19[ebp+48], 0
  00259	c6 45 d4 00	 mov	 BYTE PTR $T19[ebp+32], 0
  0025d	83 f8 08	 cmp	 eax, 8
  00260	72 51		 jb	 SHORT $LN1225@GetAvailab
  00262	8b 4d bc	 mov	 ecx, DWORD PTR $T19[ebp+8]
  00265	40		 inc	 eax
  00266	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0026b	76 05		 jbe	 SHORT $LN1219@GetAvailab
  0026d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN3213@GetAvailab:
$LN1219@GetAvailab:
  00272	03 c0		 add	 eax, eax
  00274	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00279	72 2f		 jb	 SHORT $LN1220@GetAvailab
  0027b	f6 45 bc 1f	 test	 BYTE PTR $T19[ebp+8], 31 ; 0000001fH
  0027f	74 05		 je	 SHORT $LN1221@GetAvailab
  00281	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN3214@GetAvailab:
$LN1221@GetAvailab:
  00286	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00289	3b c1		 cmp	 eax, ecx
  0028b	72 05		 jb	 SHORT $LN1222@GetAvailab
  0028d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN3215@GetAvailab:
$LN1222@GetAvailab:
  00292	2b c8		 sub	 ecx, eax
  00294	83 f9 04	 cmp	 ecx, 4
  00297	73 05		 jae	 SHORT $LN1223@GetAvailab
  00299	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN3216@GetAvailab:
$LN1223@GetAvailab:
  0029e	83 f9 23	 cmp	 ecx, 35			; 00000023H
  002a1	76 05		 jbe	 SHORT $LN1224@GetAvailab
  002a3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN3217@GetAvailab:
$LN1224@GetAvailab:
  002a8	8b c8		 mov	 ecx, eax
$LN1220@GetAvailab:
  002aa	51		 push	 ecx
  002ab	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002b0	83 c4 04	 add	 esp, 4
$LN1225@GetAvailab:

; 276  : 			}
; 277  : 
; 278  : 			foreach (const CK_OBJECT_HANDLE &dataHandle, GetObjects (slotId, CKO_DATA))

  002b3	6a 00		 push	 0
  002b5	ff 37		 push	 DWORD PTR [edi]
  002b7	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  002bd	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 5
  002c4	50		 push	 eax
  002c5	e8 00 00 00 00	 call	 ?GetObjects@SecurityToken@GostCrypt@@KA?AV?$vector@KV?$allocator@K@std@@@std@@KK@Z ; GostCrypt::SecurityToken::GetObjects
  002ca	50		 push	 eax
  002cb	8d 45 d0	 lea	 eax, DWORD PTR _$S4$20[ebp]
  002ce	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+12], 8
  002d2	50		 push	 eax
  002d3	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@01@ABV?$vector@KV?$allocator@K@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::vector<unsigned long,std::allocator<unsigned long> > >
  002d8	83 c4 14	 add	 esp, 20			; 00000014H
  002db	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
  002e1	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  002e5	85 c9		 test	 ecx, ecx
  002e7	74 36		 je	 SHORT $LN1262@GetAvailab
  002e9	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR $T6[ebp+8]
  002ef	2b c1		 sub	 eax, ecx
  002f1	c1 f8 02	 sar	 eax, 2
  002f4	50		 push	 eax
  002f5	51		 push	 ecx
  002f6	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  002fc	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
  00301	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], 0
  0030b	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+4], 0
  00315	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+8], 0
$LN1262@GetAvailab:
  0031f	8b 45 d0	 mov	 eax, DWORD PTR _$S4$20[ebp]
  00322	8d 4d d0	 lea	 ecx, DWORD PTR _$S4$20[ebp]
  00325	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00328	ff d0		 call	 eax
  0032a	84 c0		 test	 al, al
  0032c	0f 84 4e 03 00
	00		 je	 $LN9@GetAvailab
$LL10@GetAvailab:
  00332	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR $T13[ebp]
  00338	8b 5d e8	 mov	 ebx, DWORD PTR _$S4$20[ebp+24]
  0033b	a8 04		 test	 al, 4
  0033d	74 49		 je	 SHORT $LN1363@GetAvailab
  0033f	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  00345	83 e0 fb	 and	 eax, -5			; fffffffbH
  00348	89 85 d4 fe ff
	ff		 mov	 DWORD PTR $T13[ebp], eax
  0034e	85 c9		 test	 ecx, ecx
  00350	74 36		 je	 SHORT $LN1363@GetAvailab
  00352	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR $T5[ebp+8]
  00358	2b c1		 sub	 eax, ecx
  0035a	c1 f8 02	 sar	 eax, 2
  0035d	50		 push	 eax
  0035e	51		 push	 ecx
  0035f	8d 8d 84 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00365	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
  0036a	c7 85 84 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], 0
  00374	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+4], 0
  0037e	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+8], 0
$LN1363@GetAvailab:
  00388	33 c0		 xor	 eax, eax
  0038a	38 45 d5	 cmp	 BYTE PTR _$S4$20[ebp+5], al
  0038d	0f 94 c0	 sete	 al
  00390	88 45 d5	 mov	 BYTE PTR _$S4$20[ebp+5], al
  00393	84 c0		 test	 al, al
  00395	0f 84 c9 02 00
	00		 je	 $LN8@GetAvailab
  0039b	0f 1f 44 00 00	 npad	 5
$LL13@GetAvailab:

; 279  : 			{
; 280  : 				SecurityTokenKeyfile keyfile;

  003a0	33 c0		 xor	 eax, eax
  003a2	c7 85 5c ff ff
	ff 07 00 00 00	 mov	 DWORD PTR _keyfile$18[ebp+24], 7
  003ac	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _keyfile$18[ebp+20], 0
  003b6	66 89 85 48 ff
	ff ff		 mov	 WORD PTR _keyfile$18[ebp+4], ax
  003bd	c7 85 74 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR _keyfile$18[ebp+48], 15 ; 0000000fH
  003c7	89 85 70 ff ff
	ff		 mov	 DWORD PTR _keyfile$18[ebp+44], eax
  003cd	88 85 60 ff ff
	ff		 mov	 BYTE PTR _keyfile$18[ebp+28], al
  003d3	c7 45 98 07 00
	00 00		 mov	 DWORD PTR _keyfile$18[ebp+84], 7
  003da	89 45 94	 mov	 DWORD PTR _keyfile$18[ebp+80], eax
  003dd	66 89 45 84	 mov	 WORD PTR _keyfile$18[ebp+64], ax
  003e1	c7 45 b0 0f 00
	00 00		 mov	 DWORD PTR _keyfile$18[ebp+108], 15 ; 0000000fH
  003e8	89 45 ac	 mov	 DWORD PTR _keyfile$18[ebp+104], eax
  003eb	88 45 9c	 mov	 BYTE PTR _keyfile$18[ebp+88], al

; 281  : 				keyfile.Handle = dataHandle;

  003ee	8b 03		 mov	 eax, DWORD PTR [ebx]

; 282  : 				keyfile.SlotId = slotId;
; 283  : 				keyfile.Token = token;

  003f0	8d 4d 84	 lea	 ecx, DWORD PTR _keyfile$18[ebp+64]
  003f3	89 85 44 ff ff
	ff		 mov	 DWORD PTR _keyfile$18[ebp], eax
  003f9	8b 07		 mov	 eax, DWORD PTR [edi]
  003fb	89 85 78 ff ff
	ff		 mov	 DWORD PTR _keyfile$18[ebp+52], eax
  00401	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _token$16[ebp]
  00407	89 85 7c ff ff
	ff		 mov	 DWORD PTR _keyfile$18[ebp+56], eax
  0040d	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _token$16[ebp+4]
  00413	6a ff		 push	 -1
  00415	89 45 80	 mov	 DWORD PTR _keyfile$18[ebp+60], eax
  00418	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _token$16[ebp+8]
  0041e	6a 00		 push	 0
  00420	50		 push	 eax
  00421	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+12], 11 ; 0000000bH
  00425	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0042a	6a ff		 push	 -1
  0042c	6a 00		 push	 0
  0042e	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _token$16[ebp+32]
  00434	50		 push	 eax
  00435	8d 4d 9c	 lea	 ecx, DWORD PTR _keyfile$18[ebp+88]
  00438	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 284  : 
; 285  : 				vector <byte> privateAttrib;

  0043d	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _privateAttrib$12[ebp], 0
  00447	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _privateAttrib$12[ebp+4], 0
  00451	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _privateAttrib$12[ebp+8], 0

; 286  : 				GetObjectAttribute (slotId, dataHandle, CKA_PRIVATE, privateAttrib);

  0045b	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _privateAttrib$12[ebp]
  00461	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+12], 12 ; 0000000cH
  00465	50		 push	 eax
  00466	6a 02		 push	 2
  00468	ff 33		 push	 DWORD PTR [ebx]
  0046a	ff 37		 push	 DWORD PTR [edi]
  0046c	e8 00 00 00 00	 call	 ?GetObjectAttribute@SecurityToken@GostCrypt@@KAXKKKAAV?$vector@EV?$allocator@E@std@@@std@@@Z ; GostCrypt::SecurityToken::GetObjectAttribute

; 287  : 
; 288  : 				if (privateAttrib.size() == sizeof (CK_BBOOL) && *(CK_BBOOL *) &privateAttrib.front() != CK_TRUE)

  00471	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _privateAttrib$12[ebp+4]
  00477	83 c4 10	 add	 esp, 16			; 00000010H
  0047a	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _privateAttrib$12[ebp]
  00480	2b c1		 sub	 eax, ecx
  00482	83 f8 01	 cmp	 eax, 1
  00485	75 08		 jne	 SHORT $LN17@GetAvailab
  00487	38 01		 cmp	 BYTE PTR [ecx], al
  00489	0f 85 30 02 00
	00		 jne	 $LN3207@GetAvailab
$LN17@GetAvailab:

; 289  : 					continue;
; 290  : 
; 291  : 				vector <byte> label;

  0048f	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _label$8[ebp], 0
  00499	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _label$8[ebp+4], 0
  004a3	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _label$8[ebp+8], 0

; 292  : 				GetObjectAttribute (slotId, dataHandle, CKA_LABEL, label);

  004ad	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR _label$8[ebp]
  004b3	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+12], 13 ; 0000000dH
  004b7	50		 push	 eax
  004b8	6a 03		 push	 3
  004ba	ff 33		 push	 DWORD PTR [ebx]
  004bc	ff 37		 push	 DWORD PTR [edi]
  004be	e8 00 00 00 00	 call	 ?GetObjectAttribute@SecurityToken@GostCrypt@@KAXKKKAAV?$vector@EV?$allocator@E@std@@@std@@@Z ; GostCrypt::SecurityToken::GetObjectAttribute
  004c3	83 c4 10	 add	 esp, 16			; 00000010H

; 293  : 				label.push_back (0);

  004c6	c6 85 da fe ff
	ff 00		 mov	 BYTE PTR $T14[ebp], 0
  004cd	8d 85 da fe ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  004d3	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR _label$8[ebp]
  004d9	50		 push	 eax
  004da	e8 00 00 00 00	 call	 ?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back

; 294  : 
; 295  : 				keyfile.IdUtf8 = (char *) &label.front();

  004df	8b b5 a4 fe ff
	ff		 mov	 esi, DWORD PTR _label$8[ebp]
  004e5	80 3e 00	 cmp	 BYTE PTR [esi], 0
  004e8	75 04		 jne	 SHORT $LN2275@GetAvailab
  004ea	33 c0		 xor	 eax, eax
  004ec	eb 0e		 jmp	 SHORT $LN2276@GetAvailab
$LN2275@GetAvailab:
  004ee	8b c6		 mov	 eax, esi
  004f0	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL3196@GetAvailab:
  004f3	8a 08		 mov	 cl, BYTE PTR [eax]
  004f5	40		 inc	 eax
  004f6	84 c9		 test	 cl, cl
  004f8	75 f9		 jne	 SHORT $LL3196@GetAvailab
  004fa	2b c2		 sub	 eax, edx
$LN2276@GetAvailab:
  004fc	50		 push	 eax
  004fd	56		 push	 esi
  004fe	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _keyfile$18[ebp+28]
  00504	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 296  : 
; 297  : #if defined (GST_WINDOWS) && !defined (GST_PROTOTYPE)
; 298  : 				keyfile.Id = Utf8StringToWide ((const char *) &label.front());

  00509	56		 push	 esi
  0050a	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  00510	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00515	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  0051b	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+12], 14 ; 0000000eH
  0051f	50		 push	 eax
  00520	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  00526	50		 push	 eax
  00527	e8 00 00 00 00	 call	 ?Utf8StringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; Utf8StringToWide
  0052c	83 c4 08	 add	 esp, 8
  0052f	8b f0		 mov	 esi, eax
  00531	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _keyfile$18[ebp+4]
  00537	3b c6		 cmp	 eax, esi
  00539	74 47		 je	 SHORT $LN2311@GetAvailab
  0053b	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _keyfile$18[ebp+24]
  00541	83 f8 08	 cmp	 eax, 8
  00544	72 13		 jb	 SHORT $LN2317@GetAvailab
  00546	40		 inc	 eax
  00547	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _keyfile$18[ebp+4]
  0054d	50		 push	 eax
  0054e	ff b5 48 ff ff
	ff		 push	 DWORD PTR _keyfile$18[ebp+4]
  00554	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN2317@GetAvailab:
  00559	33 c0		 xor	 eax, eax
  0055b	c7 85 5c ff ff
	ff 07 00 00 00	 mov	 DWORD PTR _keyfile$18[ebp+24], 7
  00565	56		 push	 esi
  00566	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _keyfile$18[ebp+4]
  0056c	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _keyfile$18[ebp+20], 0
  00576	66 89 85 48 ff
	ff ff		 mov	 WORD PTR _keyfile$18[ebp+4], ax
  0057d	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN2311@GetAvailab:
  00582	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR $T17[ebp+20]
  00588	83 f8 08	 cmp	 eax, 8
  0058b	72 13		 jb	 SHORT $LN2609@GetAvailab
  0058d	40		 inc	 eax
  0058e	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  00594	50		 push	 eax
  00595	ff b5 2c ff ff
	ff		 push	 DWORD PTR $T17[ebp]
  0059b	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN2609@GetAvailab:
  005a0	33 c0		 xor	 eax, eax
  005a2	c7 85 40 ff ff
	ff 07 00 00 00	 mov	 DWORD PTR $T17[ebp+20], 7
  005ac	66 89 85 2c ff
	ff ff		 mov	 WORD PTR $T17[ebp], ax
  005b3	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR $T15[ebp+20]
  005b9	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+16], 0
  005c3	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+12], 13 ; 0000000dH
  005c7	83 f8 10	 cmp	 eax, 16			; 00000010H
  005ca	72 13		 jb	 SHORT $LN2712@GetAvailab
  005cc	40		 inc	 eax
  005cd	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  005d3	50		 push	 eax
  005d4	ff b5 dc fe ff
	ff		 push	 DWORD PTR $T15[ebp]
  005da	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN2712@GetAvailab:

; 299  : #else
; 300  : 				keyfile.Id = StringConverter::ToWide ((const char *) &label.front());
; 301  : #endif
; 302  : 				if (keyfile.Id.empty() || (!keyfileIdFilter.empty() && keyfileIdFilter != keyfile.Id))

  005df	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _keyfile$18[ebp+20]
  005e5	85 d2		 test	 edx, edx
  005e7	0f 84 c7 00 00
	00		 je	 $LN19@GetAvailab
  005ed	8b 75 20	 mov	 esi, DWORD PTR _keyfileIdFilter$[ebp+16]
  005f0	85 f6		 test	 esi, esi
  005f2	74 33		 je	 SHORT $LN18@GetAvailab
  005f4	83 bd 5c ff ff
	ff 08		 cmp	 DWORD PTR _keyfile$18[ebp+24], 8
  005fb	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _keyfile$18[ebp+4]
  00601	52		 push	 edx
  00602	0f 43 8d 48 ff
	ff ff		 cmovae	 ecx, DWORD PTR _keyfile$18[ebp+4]
  00609	8d 45 10	 lea	 eax, DWORD PTR _keyfileIdFilter$[ebp]
  0060c	83 7d 24 08	 cmp	 DWORD PTR _keyfileIdFilter$[ebp+20], 8
  00610	51		 push	 ecx
  00611	0f 43 45 10	 cmovae	 eax, DWORD PTR _keyfileIdFilter$[ebp]
  00615	56		 push	 esi
  00616	50		 push	 eax
  00617	e8 00 00 00 00	 call	 ?_Traits_compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAHQB_WI0I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Traits_compare
  0061c	83 c4 10	 add	 esp, 16			; 00000010H
  0061f	85 c0		 test	 eax, eax
  00621	0f 85 8d 00 00
	00		 jne	 $LN19@GetAvailab
$LN18@GetAvailab:

; 304  : 
; 305  : 				keyfiles.push_back (keyfile);

  00627	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  0062d	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _keyfile$18[ebp]
  00633	50		 push	 eax
  00634	e8 00 00 00 00	 call	 ?push_back@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXABUSecurityTokenKeyfile@GostCrypt@@@Z ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::push_back
  00639	83 7d 20 00	 cmp	 DWORD PTR _keyfileIdFilter$[ebp+16], 0

; 309  : 			}

  0063d	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR _label$8[ebp]
  00643	74 75		 je	 SHORT $LN3208@GetAvailab

; 306  : 
; 307  : 				if (!keyfileIdFilter.empty())
; 308  : 					break;

  00645	e8 00 00 00 00	 call	 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
  0064a	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _privateAttrib$12[ebp]
  00650	e8 00 00 00 00	 call	 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
  00655	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _keyfile$18[ebp]
  0065b	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  0065f	e8 00 00 00 00	 call	 ??1SecurityTokenKeyfile@GostCrypt@@QAE@XZ
$LN8@GetAvailab:

; 276  : 			}
; 277  : 
; 278  : 			foreach (const CK_OBJECT_HANDLE &dataHandle, GetObjects (slotId, CKO_DATA))

  00664	8b 45 d0	 mov	 eax, DWORD PTR _$S4$20[ebp]
  00667	8d 4d d0	 lea	 ecx, DWORD PTR _$S4$20[ebp]
  0066a	ff 50 08	 call	 DWORD PTR [eax+8]
  0066d	8b 45 d0	 mov	 eax, DWORD PTR _$S4$20[ebp]
  00670	8d 4d d0	 lea	 ecx, DWORD PTR _$S4$20[ebp]
  00673	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00676	ff d0		 call	 eax
  00678	84 c0		 test	 al, al
  0067a	0f 85 b2 fc ff
	ff		 jne	 $LL10@GetAvailab
$LN9@GetAvailab:

; 309  : 			}

  00680	8b 4d d8	 mov	 ecx, DWORD PTR _$S4$20[ebp+8]
  00683	85 c9		 test	 ecx, ecx
  00685	74 12		 je	 SHORT $LN2923@GetAvailab
  00687	8b 45 e0	 mov	 eax, DWORD PTR _$S4$20[ebp+16]
  0068a	2b c1		 sub	 eax, ecx
  0068c	c1 f8 02	 sar	 eax, 2
  0068f	50		 push	 eax
  00690	51		 push	 ecx
  00691	8d 4d d8	 lea	 ecx, DWORD PTR _$S4$20[ebp+8]
  00694	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
$LN2923@GetAvailab:

; 310  : 		}

  00699	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _token$16[ebp]
  0069f	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  006a3	e8 00 00 00 00	 call	 ??1SecurityTokenInfo@GostCrypt@@QAE@XZ
  006a8	c6 85 70 fe ff
	ff 01		 mov	 BYTE PTR _$S3$4[ebp+4], 1
  006af	e9 bc fa ff ff	 jmp	 $LL3197@GetAvailab
$LN19@GetAvailab:

; 303  : 					continue;

  006b4	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR _label$8[ebp]
$LN3208@GetAvailab:
  006ba	e8 00 00 00 00	 call	 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
$LN3207@GetAvailab:
  006bf	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _privateAttrib$12[ebp]
  006c5	e8 00 00 00 00	 call	 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
  006ca	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _keyfile$18[ebp]
  006d0	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  006d4	e8 00 00 00 00	 call	 ??1SecurityTokenKeyfile@GostCrypt@@QAE@XZ
  006d9	33 c0		 xor	 eax, eax
  006db	c6 45 d4 01	 mov	 BYTE PTR _$S4$20[ebp+4], 1
  006df	38 45 d5	 cmp	 BYTE PTR _$S4$20[ebp+5], al
  006e2	0f 94 c0	 sete	 al
  006e5	88 45 d5	 mov	 BYTE PTR _$S4$20[ebp+5], al
  006e8	84 c0		 test	 al, al
  006ea	0f 85 b0 fc ff
	ff		 jne	 $LL13@GetAvailab

; 276  : 			}
; 277  : 
; 278  : 			foreach (const CK_OBJECT_HANDLE &dataHandle, GetObjects (slotId, CKO_DATA))

  006f0	e9 6f ff ff ff	 jmp	 $LN8@GetAvailab
__catch$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$0:

; 262  : 			}
; 263  : 			catch (UserAbort &)
; 264  : 			{
; 265  : 				continue;

  006f5	b8 00 00 00 00	 mov	 eax, $LN55@GetAvailab
  006fa	c3		 ret	 0
$LN55@GetAvailab:

; 272  : 					continue;

  006fb	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _token$16[ebp]
  00701	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  00708	e8 00 00 00 00	 call	 ??1SecurityTokenInfo@GostCrypt@@QAE@XZ
  0070d	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  00713	8b bd c0 fe ff
	ff		 mov	 edi, DWORD PTR _slotId$11[ebp]
  00719	89 85 d0 fe ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0071f	c6 85 70 fe ff
	ff 01		 mov	 BYTE PTR _$S3$4[ebp+4], 1
  00726	e9 45 fa ff ff	 jmp	 $LL3197@GetAvailab
__catch$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$1:

; 266  : 			}
; 267  : 			catch (Pkcs11Exception &e)
; 268  : 			{
; 269  : 				if (e.GetErrorCode() == CKR_TOKEN_NOT_RECOGNIZED)

  0072b	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR _e$3[ebp]
  00731	81 78 04 e1 00
	00 00		 cmp	 DWORD PTR [eax+4], 225	; 000000e1H
  00738	75 0d		 jne	 SHORT $LN16@GetAvailab

; 270  : 				{
; 271  : 					unrecognizedTokenPresent = true;

  0073a	c6 85 db fe ff
	ff 01		 mov	 BYTE PTR _unrecognizedTokenPresent$[ebp], 1

; 272  : 					continue;

  00741	b8 00 00 00 00	 mov	 eax, $LN55@GetAvailab
  00746	c3		 ret	 0
$LN16@GetAvailab:

; 273  : 				}
; 274  : 
; 275  : 				throw;

  00747	6a 00		 push	 0
  00749	6a 00		 push	 0
  0074b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3218@GetAvailab:
$LN2@GetAvailab:

; 250  : 
; 251  : 		foreach (const CK_SLOT_ID &slotId, GetTokenSlots())

  00750	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _forEachContainer$10[ebp]
  00756	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR _$S3$4[ebp]
  0075c	8b 00		 mov	 eax, DWORD PTR [eax]
  0075e	ff 50 08	 call	 DWORD PTR [eax+8]
  00761	8b 9d d4 fe ff
	ff		 mov	 ebx, DWORD PTR $T13[ebp]
  00767	e9 84 f9 ff ff	 jmp	 $LL4@GetAvailab
$LN3@GetAvailab:

; 310  : 		}

  0076c	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR _$S3$4[ebp]
  00772	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00776	e8 00 00 00 00	 call	 ??1?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAE@XZ

; 311  : 
; 312  : 		if (keyfiles.empty() && unrecognizedTokenPresent)

  0077b	8b b5 d0 fe ff
	ff		 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  00781	8b 06		 mov	 eax, DWORD PTR [esi]
  00783	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00786	75 35		 jne	 SHORT $LN21@GetAvailab
  00788	80 bd db fe ff
	ff 00		 cmp	 BYTE PTR _unrecognizedTokenPresent$[ebp], 0
  0078f	74 2c		 je	 SHORT $LN21@GetAvailab

; 313  : 			throw Pkcs11Exception (CKR_TOKEN_NOT_RECOGNIZED);

  00791	68 00 00 00 00	 push	 OFFSET __TI2?AUPkcs11Exception@GostCrypt@@
  00796	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0079c	c7 85 50 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  007a6	50		 push	 eax
  007a7	c7 85 54 fe ff
	ff e1 00 00 00	 mov	 DWORD PTR $T2[ebp+4], 225 ; 000000e1H
  007b1	c6 85 58 fe ff
	ff 00		 mov	 BYTE PTR $T2[ebp+8], 0
  007b8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3219@GetAvailab:
$LN21@GetAvailab:

; 314  : 
; 315  : 		return keyfiles;

  007bd	8b 4d 24	 mov	 ecx, DWORD PTR _keyfileIdFilter$[ebp+20]
  007c0	83 f9 08	 cmp	 ecx, 8
  007c3	72 0d		 jb	 SHORT $LN3047@GetAvailab
  007c5	41		 inc	 ecx
  007c6	51		 push	 ecx
  007c7	ff 75 10	 push	 DWORD PTR _keyfileIdFilter$[ebp]
  007ca	8d 4d 10	 lea	 ecx, DWORD PTR _keyfileIdFilter$[ebp]
  007cd	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN3047@GetAvailab:
  007d2	8b c6		 mov	 eax, esi

; 316  : 	}

  007d4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  007d7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  007de	59		 pop	 ecx
  007df	5f		 pop	 edi
  007e0	5e		 pop	 esi
  007e1	5b		 pop	 ebx
  007e2	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007e5	33 cd		 xor	 ecx, ebp
  007e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007ec	8b e5		 mov	 esp, ebp
  007ee	5d		 pop	 ebp
  007ef	c3		 ret	 0
$LN3206@GetAvailab:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$3:
  00000	8d 4d 10	 lea	 ecx, DWORD PTR _keyfileIdFilter$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$4:
  00008	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR $T13[ebp]
  0000e	83 e0 01	 and	 eax, 1
  00011	0f 84 12 00 00
	00		 je	 $LN32@GetAvailab
  00017	83 a5 d4 fe ff
	ff fe		 and	 DWORD PTR $T13[ebp], -2	; fffffffeH
  0001e	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  00024	e9 00 00 00 00	 jmp	 ??1?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@XZ ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::~vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >
$LN32@GetAvailab:
  00029	c3		 ret	 0
__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$5:
  0002a	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00030	e9 00 00 00 00	 jmp	 ??1?$list@KV?$allocator@K@std@@@std@@QAE@XZ ; std::list<unsigned long,std::allocator<unsigned long> >::~list<unsigned long,std::allocator<unsigned long> >
__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$6:
  00035	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR _$S3$4[ebp]
  0003b	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$list@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$8:
  00040	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _token$16[ebp]
  00046	e9 00 00 00 00	 jmp	 ??1SecurityTokenInfo@GostCrypt@@QAE@XZ
__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$10:
  0004b	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00051	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$11:
  00056	8d 4d d0	 lea	 ecx, DWORD PTR _$S4$20[ebp]
  00059	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$vector@KV?$allocator@K@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$13:
  0005e	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR _keyfile$18[ebp]
  00064	e9 00 00 00 00	 jmp	 ??1SecurityTokenKeyfile@GostCrypt@@QAE@XZ
__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$14:
  00069	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR _privateAttrib$12[ebp]
  0006f	e9 00 00 00 00	 jmp	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$15:
  00074	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR _label$8[ebp]
  0007a	e9 00 00 00 00	 jmp	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$16:
  0007f	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  00085	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z$545:
  0008a	e8 00 00 00 00	 call	 ___std_terminate
  0008f	c3		 ret	 0
__ehhandler$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z:
  00090	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00094	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00097	8b 8a 4c fe ff
	ff		 mov	 ecx, DWORD PTR [edx-436]
  0009d	33 c8		 xor	 ecx, eax
  0009f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a4	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  000a7	33 c8		 xor	 ecx, eax
  000a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ae	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z
  000b3	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z ENDP ; GostCrypt::SecurityToken::GetAvailableKeyfiles
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?DeleteKeyfile@SecurityToken@GostCrypt@@SAXABUSecurityTokenKeyfile@2@@Z
_TEXT	SEGMENT
$T1 = -32						; size = 24
$T2 = -8						; size = 8
_keyfile$ = 8						; size = 4
?DeleteKeyfile@SecurityToken@GostCrypt@@SAXABUSecurityTokenKeyfile@2@@Z PROC ; GostCrypt::SecurityToken::DeleteKeyfile, COMDAT

; 229  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 230  : 		LoginUserIfRequired (keyfile.SlotId);

  00008	8b 7d 08	 mov	 edi, DWORD PTR _keyfile$[ebp]
  0000b	ff 77 34	 push	 DWORD PTR [edi+52]
  0000e	8d 77 34	 lea	 esi, DWORD PTR [edi+52]
  00011	e8 00 00 00 00	 call	 ?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z ; GostCrypt::SecurityToken::LoginUserIfRequired
  00016	83 c4 04	 add	 esp, 4

; 231  : 		
; 232  : 		CK_RV status = Pkcs11Functions->C_DestroyObject (Sessions[keyfile.SlotId].Handle, keyfile.Handle);

  00019	8d 45 f8	 lea	 eax, DWORD PTR $T2[ebp]
  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  00028	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0002b	ff 37		 push	 DWORD PTR [edi]
  0002d	ff 70 14	 push	 DWORD PTR [eax+20]
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  00035	8b 40 5a	 mov	 eax, DWORD PTR [eax+90]
  00038	ff d0		 call	 eax
  0003a	83 c4 08	 add	 esp, 8
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi

; 233  : 		if (status != CKR_OK)

  0003f	85 c0		 test	 eax, eax
  00041	75 04		 jne	 SHORT $LN27@DeleteKeyf

; 235  : 	}

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN27@DeleteKeyf:

; 234  : 			throw Pkcs11Exception (status);

  00047	89 45 e4	 mov	 DWORD PTR $T1[ebp+4], eax
  0004a	8d 45 e0	 lea	 eax, DWORD PTR $T1[ebp]
  0004d	68 00 00 00 00	 push	 OFFSET __TI2?AUPkcs11Exception@GostCrypt@@
  00052	50		 push	 eax
  00053	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  0005a	c6 45 e8 00	 mov	 BYTE PTR $T1[ebp+8], 0
  0005e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN29@DeleteKeyf:
$LN26@DeleteKeyf:
  00063	cc		 int	 3
?DeleteKeyfile@SecurityToken@GostCrypt@@SAXABUSecurityTokenKeyfile@2@@Z ENDP ; GostCrypt::SecurityToken::DeleteKeyfile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z
_TEXT	SEGMENT
$T2 = -208						; size = 24
$T3 = -196						; size = 12
$T4 = -184						; size = 24
$T5 = -172						; size = 12
_dataClass$ = -160					; size = 4
_$S2$6 = -156						; size = 28
_objectData$ = -128					; size = 12
_keyfileHandle$ = -116					; size = 4
_name$GSCopy$1$ = -112					; size = 4
tv3257 = -108						; size = 4
$T7 = -104						; size = 4
$T8 = -100						; size = 8
tv3250 = -96						; size = 4
$T9 = -96						; size = 4
__Right_size$1$ = -92					; size = 4
$T10 = -88						; size = 8
$T11 = -88						; size = 8
_keyfileData$GSCopy$1$ = -84				; size = 4
_finally211$ = -84					; size = 4
_trueVal$ = -77						; size = 1
_keyfileTemplate$ = -76					; size = 60
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_slotId$ = 8						; size = 4
_keyfileData$ = 12					; size = 4
_name$ = 16						; size = 4
?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z PROC ; GostCrypt::SecurityToken::CreateKeyfile, COMDAT

; 165  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 75 10	 mov	 esi, DWORD PTR _name$[ebp]
  00031	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0

; 166  : 		if (name.empty())

  00035	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
  00038	8b 5d 0c	 mov	 ebx, DWORD PTR _keyfileData$[ebp]
  0003b	89 5d ac	 mov	 DWORD PTR _keyfileData$GSCopy$1$[ebp], ebx
  0003e	89 75 90	 mov	 DWORD PTR _name$GSCopy$1$[ebp], esi
  00041	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T7[ebp], 0
  00048	89 7d a0	 mov	 DWORD PTR tv3250[ebp], edi
  0004b	75 1c		 jne	 SHORT $LN10@CreateKeyf

; 167  : 			throw ParameterIncorrect (SRC_POS);

  0004d	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00052	8d 45 a8	 lea	 eax, DWORD PTR $T11[ebp]
  00055	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T11[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0005c	50		 push	 eax
  0005d	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR $T11[ebp+4], OFFSET ??_C@_0CM@EILIPAOO@GostCrypt?3?3SecurityToken?3?3Create@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1192@CreateKeyf:
$LN10@CreateKeyf:

; 168  : 
; 169  : 		LoginUserIfRequired (slotId);

  00069	ff 75 08	 push	 DWORD PTR _slotId$[ebp]
  0006c	e8 00 00 00 00	 call	 ?LoginUserIfRequired@SecurityToken@GostCrypt@@KAXK@Z ; GostCrypt::SecurityToken::LoginUserIfRequired

; 170  : 
; 171  : 		foreach (const SecurityTokenKeyfile &keyfile, GetAvailableKeyfiles (&slotId))

  00071	83 ec 14	 sub	 esp, 20			; 00000014H
  00074	8b c4		 mov	 eax, esp
  00076	c7 40 14 07 00
	00 00		 mov	 DWORD PTR [eax+20], 7
  0007d	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  00084	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00088	72 02		 jb	 SHORT $LN148@CreateKeyf
  0008a	8b 00		 mov	 eax, DWORD PTR [eax]
$LN148@CreateKeyf:
  0008c	33 c9		 xor	 ecx, ecx
  0008e	66 89 08	 mov	 WORD PTR [eax], cx
  00091	8d 45 08	 lea	 eax, DWORD PTR _slotId$[ebp]
  00094	50		 push	 eax
  00095	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z ; GostCrypt::SecurityToken::GetAvailableKeyfiles
  000a1	50		 push	 eax
  000a2	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _$S2$6[ebp]
  000a8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@01@ABV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> > >
  000b5	83 c4 28	 add	 esp, 40			; 00000028H
  000b8	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  000be	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000c2	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Tidy
  000c7	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _$S2$6[ebp]
  000cd	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _$S2$6[ebp]
  000d3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d6	ff d0		 call	 eax
  000d8	84 c0		 test	 al, al
  000da	0f 84 23 01 00
	00		 je	 $LN3@CreateKeyf
$LL4@CreateKeyf:
  000e0	8b 45 98	 mov	 eax, DWORD PTR $T7[ebp]
  000e3	8b 9d 7c ff ff
	ff		 mov	 ebx, DWORD PTR _$S2$6[ebp+24]
  000e9	a8 01		 test	 al, 1
  000eb	74 11		 je	 SHORT $LN275@CreateKeyf
  000ed	83 e0 fe	 and	 eax, -2			; fffffffeH
  000f0	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  000f6	89 45 98	 mov	 DWORD PTR $T7[ebp], eax
  000f9	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Tidy
$LN275@CreateKeyf:
  000fe	33 c9		 xor	 ecx, ecx
  00100	38 8d 69 ff ff
	ff		 cmp	 BYTE PTR _$S2$6[ebp+5], cl
  00106	0f 94 c1	 sete	 cl
  00109	89 4d 94	 mov	 DWORD PTR tv3257[ebp], ecx
  0010c	88 8d 69 ff ff
	ff		 mov	 BYTE PTR _$S2$6[ebp+5], cl
  00112	84 c9		 test	 cl, cl
  00114	0f 84 be 00 00
	00		 je	 $LN2@CreateKeyf

; 172  : 		{
; 173  : 			if (keyfile.IdUtf8 == name)

  0011a	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0011c	89 4d a4	 mov	 DWORD PTR __Right_size$1$[ebp], ecx
  0011f	90		 npad	 1
$LL7@CreateKeyf:
  00120	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00124	72 02		 jb	 SHORT $LN306@CreateKeyf
  00126	8b 36		 mov	 esi, DWORD PTR [esi]
$LN306@CreateKeyf:
  00128	83 7b 30 10	 cmp	 DWORD PTR [ebx+48], 16	; 00000010H
  0012c	72 05		 jb	 SHORT $LN329@CreateKeyf
  0012e	8b 53 1c	 mov	 edx, DWORD PTR [ebx+28]
  00131	eb 03		 jmp	 SHORT $LN330@CreateKeyf
$LN329@CreateKeyf:
  00133	8d 53 1c	 lea	 edx, DWORD PTR [ebx+28]
$LN330@CreateKeyf:
  00136	8b 7b 2c	 mov	 edi, DWORD PTR [ebx+44]
  00139	8b c1		 mov	 eax, ecx
  0013b	3b f9		 cmp	 edi, ecx
  0013d	0f 42 c7	 cmovb	 eax, edi
  00140	85 c0		 test	 eax, eax
  00142	74 5f		 je	 SHORT $LN334@CreateKeyf
  00144	83 e8 04	 sub	 eax, 4
  00147	72 18		 jb	 SHORT $LN1184@CreateKeyf
  00149	0f 1f 80 00 00
	00 00		 npad	 7
$LL1185@CreateKeyf:
  00150	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00152	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  00154	75 10		 jne	 SHORT $LN1183@CreateKeyf
  00156	83 c2 04	 add	 edx, 4
  00159	83 c6 04	 add	 esi, 4
  0015c	83 e8 04	 sub	 eax, 4
  0015f	73 ef		 jae	 SHORT $LL1185@CreateKeyf
$LN1184@CreateKeyf:
  00161	83 f8 fc	 cmp	 eax, -4			; fffffffcH
  00164	74 34		 je	 SHORT $LN1182@CreateKeyf
$LN1183@CreateKeyf:
  00166	8a 0a		 mov	 cl, BYTE PTR [edx]
  00168	3a 0e		 cmp	 cl, BYTE PTR [esi]
  0016a	75 27		 jne	 SHORT $LN1186@CreateKeyf
  0016c	83 f8 fd	 cmp	 eax, -3			; fffffffdH
  0016f	74 29		 je	 SHORT $LN1182@CreateKeyf
  00171	8a 4a 01	 mov	 cl, BYTE PTR [edx+1]
  00174	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  00177	75 1a		 jne	 SHORT $LN1186@CreateKeyf
  00179	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  0017c	74 1c		 je	 SHORT $LN1182@CreateKeyf
  0017e	8a 4a 02	 mov	 cl, BYTE PTR [edx+2]
  00181	3a 4e 02	 cmp	 cl, BYTE PTR [esi+2]
  00184	75 0d		 jne	 SHORT $LN1186@CreateKeyf
  00186	83 f8 ff	 cmp	 eax, -1
  00189	74 0f		 je	 SHORT $LN1182@CreateKeyf
  0018b	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  0018e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00191	74 07		 je	 SHORT $LN1182@CreateKeyf
$LN1186@CreateKeyf:
  00193	1b c0		 sbb	 eax, eax
  00195	83 c8 01	 or	 eax, 1
  00198	eb 02		 jmp	 SHORT $LN1187@CreateKeyf
$LN1182@CreateKeyf:
  0019a	33 c0		 xor	 eax, eax
$LN1187@CreateKeyf:
  0019c	85 c0		 test	 eax, eax
  0019e	75 0d		 jne	 SHORT $LN333@CreateKeyf
  001a0	8b 4d a4	 mov	 ecx, DWORD PTR __Right_size$1$[ebp]
$LN334@CreateKeyf:
  001a3	3b f9		 cmp	 edi, ecx
  001a5	72 06		 jb	 SHORT $LN333@CreateKeyf
  001a7	0f 86 df 00 00
	00		 jbe	 $LN1148@CreateKeyf
$LN333@CreateKeyf:

; 170  : 
; 171  : 		foreach (const SecurityTokenKeyfile &keyfile, GetAvailableKeyfiles (&slotId))

  001ad	8b 75 90	 mov	 esi, DWORD PTR _name$GSCopy$1$[ebp]
  001b0	33 c0		 xor	 eax, eax
  001b2	38 45 94	 cmp	 BYTE PTR tv3257[ebp], al
  001b5	c6 85 68 ff ff
	ff 01		 mov	 BYTE PTR _$S2$6[ebp+4], 1
  001bc	0f 94 c0	 sete	 al
  001bf	8a c8		 mov	 cl, al
  001c1	89 4d 94	 mov	 DWORD PTR tv3257[ebp], ecx
  001c4	88 8d 69 ff ff
	ff		 mov	 BYTE PTR _$S2$6[ebp+5], cl
  001ca	8b 4d a4	 mov	 ecx, DWORD PTR __Right_size$1$[ebp]
  001cd	84 c0		 test	 al, al
  001cf	0f 85 4b ff ff
	ff		 jne	 $LL7@CreateKeyf
  001d5	8b 7d a0	 mov	 edi, DWORD PTR tv3250[ebp]
$LN2@CreateKeyf:
  001d8	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _$S2$6[ebp]
  001de	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _$S2$6[ebp]
  001e4	ff 50 08	 call	 DWORD PTR [eax+8]
  001e7	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _$S2$6[ebp]
  001ed	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _$S2$6[ebp]
  001f3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f6	ff d0		 call	 eax
  001f8	84 c0		 test	 al, al
  001fa	0f 85 e0 fe ff
	ff		 jne	 $LL4@CreateKeyf
  00200	8b 5d ac	 mov	 ebx, DWORD PTR _keyfileData$GSCopy$1$[ebp]
$LN3@CreateKeyf:

; 175  : 		}

  00203	8b b5 6c ff ff
	ff		 mov	 esi, DWORD PTR _$S2$6[ebp+8]
  00209	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00210	85 f6		 test	 esi, esi
  00212	0f 84 18 02 00
	00		 je	 $LN355@CreateKeyf
  00218	8b bd 70 ff ff
	ff		 mov	 edi, DWORD PTR _$S2$6[ebp+12]
  0021e	3b f7		 cmp	 esi, edi
  00220	0f 84 e2 01 00
	00		 je	 $LN1181@CreateKeyf
  00226	83 c6 6c	 add	 esi, 108		; 0000006cH
  00229	0f 1f 80 00 00
	00 00		 npad	 7
$LL397@CreateKeyf:
  00230	8b 06		 mov	 eax, DWORD PTR [esi]
  00232	83 f8 10	 cmp	 eax, 16			; 00000010H
  00235	72 3e		 jb	 SHORT $LN503@CreateKeyf
  00237	8b 4e ec	 mov	 ecx, DWORD PTR [esi-20]
  0023a	40		 inc	 eax
  0023b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00240	72 2a		 jb	 SHORT $LN498@CreateKeyf
  00242	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00245	0f 85 a9 02 00
	00		 jne	 $LN1153@CreateKeyf
  0024b	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0024e	3b c1		 cmp	 eax, ecx
  00250	0f 83 9e 02 00
	00		 jae	 $LN1153@CreateKeyf
  00256	2b c8		 sub	 ecx, eax
  00258	83 f9 04	 cmp	 ecx, 4
  0025b	0f 82 93 02 00
	00		 jb	 $LN1153@CreateKeyf
  00261	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00264	0f 87 8a 02 00
	00		 ja	 $LN1153@CreateKeyf
  0026a	8b c8		 mov	 ecx, eax
$LN498@CreateKeyf:
  0026c	51		 push	 ecx
  0026d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00272	83 c4 04	 add	 esp, 4
$LN503@CreateKeyf:
  00275	c7 06 0f 00 00
	00		 mov	 DWORD PTR [esi], 15	; 0000000fH
  0027b	83 3e 10	 cmp	 DWORD PTR [esi], 16	; 00000010H
  0027e	c7 46 fc 00 00
	00 00		 mov	 DWORD PTR [esi-4], 0
  00285	72 1a		 jb	 SHORT $LN526@CreateKeyf
  00287	8b 46 ec	 mov	 eax, DWORD PTR [esi-20]
  0028a	eb 18		 jmp	 SHORT $LN527@CreateKeyf
$LN1148@CreateKeyf:

; 174  : 				throw SecurityTokenKeyfileAlreadyExists();

  0028c	68 00 00 00 00	 push	 OFFSET __TI2?AUSecurityTokenKeyfileAlreadyExists@GostCrypt@@
  00291	8d 45 a0	 lea	 eax, DWORD PTR $T9[ebp]
  00294	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR $T9[ebp], OFFSET ??_7SecurityTokenKeyfileAlreadyExists@GostCrypt@@6B@
  0029b	50		 push	 eax
  0029c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1193@CreateKeyf:

; 175  : 		}

$LN526@CreateKeyf:
  002a1	8d 46 ec	 lea	 eax, DWORD PTR [esi-20]
$LN527@CreateKeyf:
  002a4	c6 00 00	 mov	 BYTE PTR [eax], 0
  002a7	8b 46 e8	 mov	 eax, DWORD PTR [esi-24]
  002aa	83 f8 08	 cmp	 eax, 8
  002ad	72 4b		 jb	 SHORT $LN623@CreateKeyf
  002af	8b 4e d4	 mov	 ecx, DWORD PTR [esi-44]
  002b2	40		 inc	 eax
  002b3	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  002b8	0f 87 36 02 00
	00		 ja	 $LN1153@CreateKeyf
  002be	03 c0		 add	 eax, eax
  002c0	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  002c5	72 2a		 jb	 SHORT $LN618@CreateKeyf
  002c7	f6 c1 1f	 test	 cl, 31			; 0000001fH
  002ca	0f 85 24 02 00
	00		 jne	 $LN1153@CreateKeyf
  002d0	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  002d3	3b c1		 cmp	 eax, ecx
  002d5	0f 83 19 02 00
	00		 jae	 $LN1153@CreateKeyf
  002db	2b c8		 sub	 ecx, eax
  002dd	83 f9 04	 cmp	 ecx, 4
  002e0	0f 82 0e 02 00
	00		 jb	 $LN1153@CreateKeyf
  002e6	83 f9 23	 cmp	 ecx, 35			; 00000023H
  002e9	0f 87 05 02 00
	00		 ja	 $LN1153@CreateKeyf
  002ef	8b c8		 mov	 ecx, eax
$LN618@CreateKeyf:
  002f1	51		 push	 ecx
  002f2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002f7	83 c4 04	 add	 esp, 4
$LN623@CreateKeyf:
  002fa	c7 46 e8 07 00
	00 00		 mov	 DWORD PTR [esi-24], 7
  00301	83 7e e8 08	 cmp	 DWORD PTR [esi-24], 8
  00305	c7 46 e4 00 00
	00 00		 mov	 DWORD PTR [esi-28], 0
  0030c	72 05		 jb	 SHORT $LN646@CreateKeyf
  0030e	8b 46 d4	 mov	 eax, DWORD PTR [esi-44]
  00311	eb 03		 jmp	 SHORT $LN647@CreateKeyf
$LN646@CreateKeyf:
  00313	8d 46 d4	 lea	 eax, DWORD PTR [esi-44]
$LN647@CreateKeyf:
  00316	33 c9		 xor	 ecx, ecx
  00318	66 89 08	 mov	 WORD PTR [eax], cx
  0031b	8b 46 c4	 mov	 eax, DWORD PTR [esi-60]
  0031e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00321	72 3e		 jb	 SHORT $LN741@CreateKeyf
  00323	8b 4e b0	 mov	 ecx, DWORD PTR [esi-80]
  00326	40		 inc	 eax
  00327	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0032c	72 2a		 jb	 SHORT $LN736@CreateKeyf
  0032e	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00331	0f 85 bd 01 00
	00		 jne	 $LN1153@CreateKeyf
  00337	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0033a	3b c1		 cmp	 eax, ecx
  0033c	0f 83 b2 01 00
	00		 jae	 $LN1153@CreateKeyf
  00342	2b c8		 sub	 ecx, eax
  00344	83 f9 04	 cmp	 ecx, 4
  00347	0f 82 a7 01 00
	00		 jb	 $LN1153@CreateKeyf
  0034d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00350	0f 87 9e 01 00
	00		 ja	 $LN1153@CreateKeyf
  00356	8b c8		 mov	 ecx, eax
$LN736@CreateKeyf:
  00358	51		 push	 ecx
  00359	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0035e	83 c4 04	 add	 esp, 4
$LN741@CreateKeyf:
  00361	c7 46 c4 0f 00
	00 00		 mov	 DWORD PTR [esi-60], 15	; 0000000fH
  00368	83 7e c4 10	 cmp	 DWORD PTR [esi-60], 16	; 00000010H
  0036c	c7 46 c0 00 00
	00 00		 mov	 DWORD PTR [esi-64], 0
  00373	72 05		 jb	 SHORT $LN764@CreateKeyf
  00375	8b 46 b0	 mov	 eax, DWORD PTR [esi-80]
  00378	eb 03		 jmp	 SHORT $LN765@CreateKeyf
$LN764@CreateKeyf:
  0037a	8d 46 b0	 lea	 eax, DWORD PTR [esi-80]
$LN765@CreateKeyf:
  0037d	c6 00 00	 mov	 BYTE PTR [eax], 0
  00380	8b 46 ac	 mov	 eax, DWORD PTR [esi-84]
  00383	83 f8 08	 cmp	 eax, 8
  00386	72 4b		 jb	 SHORT $LN860@CreateKeyf
  00388	8b 4e 98	 mov	 ecx, DWORD PTR [esi-104]
  0038b	40		 inc	 eax
  0038c	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00391	0f 87 5d 01 00
	00		 ja	 $LN1153@CreateKeyf
  00397	03 c0		 add	 eax, eax
  00399	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0039e	72 2a		 jb	 SHORT $LN855@CreateKeyf
  003a0	f6 c1 1f	 test	 cl, 31			; 0000001fH
  003a3	0f 85 4b 01 00
	00		 jne	 $LN1153@CreateKeyf
  003a9	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  003ac	3b c1		 cmp	 eax, ecx
  003ae	0f 83 40 01 00
	00		 jae	 $LN1153@CreateKeyf
  003b4	2b c8		 sub	 ecx, eax
  003b6	83 f9 04	 cmp	 ecx, 4
  003b9	0f 82 35 01 00
	00		 jb	 $LN1153@CreateKeyf
  003bf	83 f9 23	 cmp	 ecx, 35			; 00000023H
  003c2	0f 87 2c 01 00
	00		 ja	 $LN1153@CreateKeyf
  003c8	8b c8		 mov	 ecx, eax
$LN855@CreateKeyf:
  003ca	51		 push	 ecx
  003cb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  003d0	83 c4 04	 add	 esp, 4
$LN860@CreateKeyf:
  003d3	c7 46 ac 07 00
	00 00		 mov	 DWORD PTR [esi-84], 7
  003da	83 7e ac 08	 cmp	 DWORD PTR [esi-84], 8
  003de	c7 46 a8 00 00
	00 00		 mov	 DWORD PTR [esi-88], 0
  003e5	72 05		 jb	 SHORT $LN883@CreateKeyf
  003e7	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  003ea	eb 03		 jmp	 SHORT $LN884@CreateKeyf
$LN883@CreateKeyf:
  003ec	8d 46 98	 lea	 eax, DWORD PTR [esi-104]
$LN884@CreateKeyf:
  003ef	83 c6 70	 add	 esi, 112		; 00000070H
  003f2	33 c9		 xor	 ecx, ecx
  003f4	66 89 08	 mov	 WORD PTR [eax], cx
  003f7	8d 46 94	 lea	 eax, DWORD PTR [esi-108]
  003fa	3b c7		 cmp	 eax, edi
  003fc	0f 85 2e fe ff
	ff		 jne	 $LL397@CreateKeyf
  00402	8b b5 6c ff ff
	ff		 mov	 esi, DWORD PTR _$S2$6[ebp+8]
$LN1181@CreateKeyf:
  00408	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _$S2$6[ebp+16]
  0040e	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00413	2b ce		 sub	 ecx, esi
  00415	f7 e9		 imul	 ecx
  00417	03 d1		 add	 edx, ecx
  00419	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _$S2$6[ebp+8]
  0041f	c1 fa 06	 sar	 edx, 6
  00422	8b c2		 mov	 eax, edx
  00424	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00427	03 c2		 add	 eax, edx
  00429	50		 push	 eax
  0042a	56		 push	 esi
  0042b	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAEXPAUSecurityTokenKeyfile@GostCrypt@@I@Z ; std::_Wrap_alloc<std::allocator<GostCrypt::SecurityTokenKeyfile> >::deallocate
$LN355@CreateKeyf:

; 176  : 
; 177  : 		CK_OBJECT_CLASS dataClass = CKO_DATA;
; 178  : 		CK_BBOOL trueVal = CK_TRUE;
; 179  : 
; 180  : 		CK_ATTRIBUTE keyfileTemplate[] =
; 181  : 		{
; 182  : 			{ CKA_CLASS, &dataClass, sizeof (dataClass) },

  00430	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _dataClass$[ebp]
  00436	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _dataClass$[ebp], 0
  00440	89 45 b8	 mov	 DWORD PTR _keyfileTemplate$[ebp+4], eax

; 183  : 			{ CKA_TOKEN, &trueVal, sizeof (trueVal) },

  00443	8d 45 b3	 lea	 eax, DWORD PTR _trueVal$[ebp]
  00446	89 45 c4	 mov	 DWORD PTR _keyfileTemplate$[ebp+16], eax

; 184  : 			{ CKA_PRIVATE, &trueVal, sizeof (trueVal) },

  00449	89 45 d0	 mov	 DWORD PTR _keyfileTemplate$[ebp+28], eax

; 185  : 			{ CKA_LABEL, (CK_UTF8CHAR *) name.c_str(), name.size() },

  0044c	8b 45 90	 mov	 eax, DWORD PTR _name$GSCopy$1$[ebp]
  0044f	c6 45 b3 01	 mov	 BYTE PTR _trueVal$[ebp], 1
  00453	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _keyfileTemplate$[ebp], 0
  0045a	c7 45 bc 04 00
	00 00		 mov	 DWORD PTR _keyfileTemplate$[ebp+8], 4
  00461	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00465	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR _keyfileTemplate$[ebp+12], 1
  0046c	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _keyfileTemplate$[ebp+20], 1
  00473	c7 45 cc 02 00
	00 00		 mov	 DWORD PTR _keyfileTemplate$[ebp+24], 2
  0047a	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _keyfileTemplate$[ebp+32], 1
  00481	c7 45 d8 03 00
	00 00		 mov	 DWORD PTR _keyfileTemplate$[ebp+36], 3
  00488	72 02		 jb	 SHORT $LN979@CreateKeyf
  0048a	8b 00		 mov	 eax, DWORD PTR [eax]
$LN979@CreateKeyf:

; 186  : 			{ CKA_VALUE, &keyfileData.front(), keyfileData.size() }

  0048c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0048e	89 45 dc	 mov	 DWORD PTR _keyfileTemplate$[ebp+40], eax
  00491	8b 45 a0	 mov	 eax, DWORD PTR tv3250[ebp]
  00494	89 4d e8	 mov	 DWORD PTR _keyfileTemplate$[ebp+52], ecx
  00497	c7 45 e4 11 00
	00 00		 mov	 DWORD PTR _keyfileTemplate$[ebp+48], 17 ; 00000011H
  0049e	8b 00		 mov	 eax, DWORD PTR [eax]
  004a0	89 45 e0	 mov	 DWORD PTR _keyfileTemplate$[ebp+44], eax
  004a3	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  004a6	2b c1		 sub	 eax, ecx

; 187  : 		};
; 188  : 
; 189  : 		CK_OBJECT_HANDLE keyfileHandle;
; 190  : 
; 191  : 		CK_RV status = Pkcs11Functions->C_CreateObject (Sessions[slotId].Handle, keyfileTemplate, array_capacity (keyfileTemplate), &keyfileHandle);

  004a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  004ad	89 45 ec	 mov	 DWORD PTR _keyfileTemplate$[ebp+56], eax
  004b0	8d 45 08	 lea	 eax, DWORD PTR _slotId$[ebp]
  004b3	50		 push	 eax
  004b4	8d 45 a8	 lea	 eax, DWORD PTR $T10[ebp]
  004b7	50		 push	 eax
  004b8	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  004bd	8b 45 a8	 mov	 eax, DWORD PTR $T10[ebp]
  004c0	8d 4d 8c	 lea	 ecx, DWORD PTR _keyfileHandle$[ebp]
  004c3	51		 push	 ecx
  004c4	6a 05		 push	 5
  004c6	8d 4d b4	 lea	 ecx, DWORD PTR _keyfileTemplate$[ebp]
  004c9	51		 push	 ecx
  004ca	ff 70 14	 push	 DWORD PTR [eax+20]
  004cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  004d2	8b 40 52	 mov	 eax, DWORD PTR [eax+82]
  004d5	ff d0		 call	 eax
  004d7	83 c4 10	 add	 esp, 16			; 00000010H

; 192  : 
; 193  : 		switch (status)

  004da	83 f8 21	 cmp	 eax, 33			; 00000021H
  004dd	0f 84 db 00 00
	00		 je	 $LN12@CreateKeyf
  004e3	3d b5 00 00 00	 cmp	 eax, 181		; 000000b5H
  004e8	75 0f		 jne	 SHORT $LN8@CreateKeyf

; 197  : 			break;
; 198  : 
; 199  : 		case CKR_SESSION_READ_ONLY:
; 200  : 			status = CKR_TOKEN_WRITE_PROTECTED;

  004ea	b8 e2 00 00 00	 mov	 eax, 226		; 000000e2H
  004ef	e9 cf 00 00 00	 jmp	 $LN1178@CreateKeyf
$LN1153@CreateKeyf:

; 175  : 		}

  004f4	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1194@CreateKeyf:
$LN8@CreateKeyf:

; 201  : 			break;
; 202  : 		}
; 203  : 
; 204  : 		if (status != CKR_OK)

  004f9	85 c0		 test	 eax, eax
  004fb	0f 85 c2 00 00
	00		 jne	 $LN1178@CreateKeyf

; 206  : 
; 207  : 		// Some tokens report success even if the new object was truncated to fit in the available memory
; 208  : 		vector <byte> objectData;

  00501	89 45 80	 mov	 DWORD PTR _objectData$[ebp], eax
  00504	89 45 84	 mov	 DWORD PTR _objectData$[ebp+4], eax
  00507	89 45 88	 mov	 DWORD PTR _objectData$[ebp+8], eax

; 209  : 
; 210  : 		GetObjectAttribute (slotId, keyfileHandle, CKA_VALUE, objectData);

  0050a	8d 45 80	 lea	 eax, DWORD PTR _objectData$[ebp]
  0050d	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00514	50		 push	 eax
  00515	6a 11		 push	 17			; 00000011H
  00517	ff 75 8c	 push	 DWORD PTR _keyfileHandle$[ebp]
  0051a	ff 75 08	 push	 DWORD PTR _slotId$[ebp]
  0051d	e8 00 00 00 00	 call	 ?GetObjectAttribute@SecurityToken@GostCrypt@@KAXKKKAAV?$vector@EV?$allocator@E@std@@@std@@@Z ; GostCrypt::SecurityToken::GetObjectAttribute

; 211  : 		finally_do_arg (vector <byte> *, &objectData, { if (!finally_arg->empty()) burn (&finally_arg->front(), finally_arg->size()); });

  00522	8d 45 80	 lea	 eax, DWORD PTR _objectData$[ebp]
  00525	83 c4 10	 add	 esp, 16			; 00000010H
  00528	89 45 ac	 mov	 DWORD PTR _finally211$[ebp], eax

; 212  : 
; 213  : 		if (objectData.size() != keyfileData.size())

  0052b	8b 55 84	 mov	 edx, DWORD PTR _objectData$[ebp+4]
  0052e	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00531	2b 55 80	 sub	 edx, DWORD PTR _objectData$[ebp]
  00534	2b 03		 sub	 eax, DWORD PTR [ebx]
  00536	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0053a	3b d0		 cmp	 edx, eax
  0053c	74 54		 je	 SHORT $LN15@CreateKeyf

; 214  : 		{
; 215  : 			Pkcs11Functions->C_DestroyObject (Sessions[slotId].Handle, keyfileHandle);

  0053e	8d 45 08	 lea	 eax, DWORD PTR _slotId$[ebp]
  00541	b9 00 00 00 00	 mov	 ecx, OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  00546	50		 push	 eax
  00547	8d 45 9c	 lea	 eax, DWORD PTR $T8[ebp]
  0054a	50		 push	 eax
  0054b	e8 00 00 00 00	 call	 ??$_Try_emplace@ABK$$V@?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@std@@_N@1@ABK@Z ; std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > >::_Try_emplace<unsigned long const &>
  00550	8b 45 9c	 mov	 eax, DWORD PTR $T8[ebp]
  00553	ff 75 8c	 push	 DWORD PTR _keyfileHandle$[ebp]
  00556	ff 70 14	 push	 DWORD PTR [eax+20]
  00559	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  0055e	8b 40 5a	 mov	 eax, DWORD PTR [eax+90]
  00561	ff d0		 call	 eax
  00563	83 c4 08	 add	 esp, 8

; 216  : 			throw Pkcs11Exception (CKR_DEVICE_MEMORY);

  00566	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  00570	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00576	c7 85 34 ff ff
	ff 31 00 00 00	 mov	 DWORD PTR $T2[ebp+4], 49 ; 00000031H
  00580	c6 85 38 ff ff
	ff 00		 mov	 BYTE PTR $T2[ebp+8], 0
  00587	68 00 00 00 00	 push	 OFFSET __TI2?AUPkcs11Exception@GostCrypt@@
  0058c	50		 push	 eax
  0058d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1195@CreateKeyf:
$LN15@CreateKeyf:

; 217  : 		}
; 218  : 	}

  00592	8d 4d ac	 lea	 ecx, DWORD PTR _finally211$[ebp]
  00595	e8 00 00 00 00	 call	 ??1Finally211@?1??CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@QAE@XZ ; `GostCrypt::SecurityToken::CreateKeyfile'::`2'::Finally211::~Finally211
  0059a	8d 4d 80	 lea	 ecx, DWORD PTR _objectData$[ebp]
  0059d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
  005a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005ac	59		 pop	 ecx
  005ad	5f		 pop	 edi
  005ae	5e		 pop	 esi
  005af	5b		 pop	 ebx
  005b0	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005b3	33 cd		 xor	 ecx, ebp
  005b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005ba	8b e5		 mov	 esp, ebp
  005bc	5d		 pop	 ebp
  005bd	c3		 ret	 0
$LN12@CreateKeyf:

; 194  : 		{
; 195  : 		case CKR_DATA_LEN_RANGE:
; 196  : 			status = CKR_DEVICE_MEMORY;

  005be	b8 31 00 00 00	 mov	 eax, 49			; 00000031H
$LN1178@CreateKeyf:

; 205  : 			throw Pkcs11Exception (status);

  005c3	89 85 4c ff ff
	ff		 mov	 DWORD PTR $T4[ebp+4], eax
  005c9	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  005cf	68 00 00 00 00	 push	 OFFSET __TI2?AUPkcs11Exception@GostCrypt@@
  005d4	50		 push	 eax
  005d5	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  005df	c6 85 50 ff ff
	ff 00		 mov	 BYTE PTR $T4[ebp+8], 0
  005e6	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1196@CreateKeyf:
$LN1191@CreateKeyf:
  005eb	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z$1:
  00000	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@XZ ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::~vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >
__unwindfunclet$?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z$2:
  0000b	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _$S2$6[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z$5:
  00016	8d 4d 80	 lea	 ecx, DWORD PTR _objectData$[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
__unwindfunclet$?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z$6:
  0001e	8d 4d ac	 lea	 ecx, DWORD PTR _finally211$[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1Finally211@?1??CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@5@@Z@QAE@XZ ; `GostCrypt::SecurityToken::CreateKeyfile'::`2'::Finally211::~Finally211
__ehhandler$?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z:
  00026	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002d	8b 8a 2c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-212]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0003d	33 c8		 xor	 ecx, eax
  0003f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00044	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z
  00049	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateKeyfile@SecurityToken@GostCrypt@@SAXKAAV?$vector@EV?$allocator@E@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@4@@Z ENDP ; GostCrypt::SecurityToken::CreateKeyfile
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?CloseLibrary@SecurityToken@GostCrypt@@SAXXZ
_TEXT	SEGMENT
?CloseLibrary@SecurityToken@GostCrypt@@SAXXZ PROC	; GostCrypt::SecurityToken::CloseLibrary, COMDAT

; 99   : 		if (Initialized)

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?Initialized@SecurityToken@GostCrypt@@1_NA, 0 ; GostCrypt::SecurityToken::Initialized
  00007	74 27		 je	 SHORT $LN2@CloseLibra

; 100  : 		{
; 101  : 			CloseAllSessions();

  00009	e8 00 00 00 00	 call	 ?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ ; GostCrypt::SecurityToken::CloseAllSessions

; 102  : 			Pkcs11Functions->C_Finalize (NULL_PTR);

  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Pkcs11Functions@SecurityToken@GostCrypt@@1PAUCK_FUNCTION_LIST@@A ; GostCrypt::SecurityToken::Pkcs11Functions
  00013	6a 00		 push	 0
  00015	8b 40 06	 mov	 eax, DWORD PTR [eax+6]
  00018	ff d0		 call	 eax
  0001a	83 c4 04	 add	 esp, 4

; 103  : 
; 104  : #ifdef GST_WINDOWS
; 105  : 			FreeLibrary (Pkcs11LibraryHandle);

  0001d	ff 35 00 00 00
	00		 push	 DWORD PTR ?Pkcs11LibraryHandle@SecurityToken@GostCrypt@@1PAUHINSTANCE__@@A ; GostCrypt::SecurityToken::Pkcs11LibraryHandle
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 106  : #else
; 107  : 			dlclose (Pkcs11LibraryHandle);
; 108  : #endif
; 109  : 			Initialized = false;

  00029	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?Initialized@SecurityToken@GostCrypt@@1_NA, 0 ; GostCrypt::SecurityToken::Initialized
$LN2@CloseLibra:

; 110  : 		}
; 111  : 	}

  00030	c3		 ret	 0
?CloseLibrary@SecurityToken@GostCrypt@@SAXXZ ENDP	; GostCrypt::SecurityToken::CloseLibrary
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ
_TEXT	SEGMENT
_$S1$2 = -56						; size = 24
_p$3 = -32						; size = 12
$T4 = -20						; size = 4
_forEachContainer$5 = -20				; size = 4
__$EHRec$ = -16						; size = 16
?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ PROC	; GostCrypt::SecurityToken::CloseAllSessions, COMDAT

; 121  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 122  : 		if (!Initialized)

  0002b	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?Initialized@SecurityToken@GostCrypt@@1_NA, 0 ; GostCrypt::SecurityToken::Initialized
  00032	0f 84 a1 00 00
	00		 je	 $LN209@CloseAllSe

; 123  : 			return;
; 124  : 
; 125  : 		typedef pair <CK_SLOT_ID, Pkcs11Session> SessionMapPair;
; 126  : 
; 127  : 		foreach (SessionMapPair p, Sessions)

  00038	8d 45 c8	 lea	 eax, DWORD PTR _$S1$2[ebp]
  0003b	68 00 00 00 00	 push	 OFFSET ?Sessions@SecurityToken@GostCrypt@@1V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@A ; GostCrypt::SecurityToken::Sessions
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@01@ABV?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::map<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> > > >
  00046	83 c4 08	 add	 esp, 8
  00049	8d 7d c8	 lea	 edi, DWORD PTR _$S1$2[ebp]
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00053	89 7d ec	 mov	 DWORD PTR _forEachContainer$5[ebp], edi
$LL4@CloseAllSe:
  00056	8b 07		 mov	 eax, DWORD PTR [edi]
  00058	8d 4d c8	 lea	 ecx, DWORD PTR _$S1$2[ebp]
  0005b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005e	ff d0		 call	 eax
  00060	84 c0		 test	 al, al
  00062	74 58		 je	 SHORT $LN3@CloseAllSe
  00064	8b 45 dc	 mov	 eax, DWORD PTR _$S1$2[ebp+20]
  00067	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  0006a	89 75 e0	 mov	 DWORD PTR _p$3[ebp], esi
  0006d	0f 1f 00	 npad	 3
$LL7@CloseAllSe:
  00070	33 c0		 xor	 eax, eax
  00072	38 45 cd	 cmp	 BYTE PTR _$S1$2[ebp+5], al
  00075	0f 94 c0	 sete	 al
  00078	88 45 cd	 mov	 BYTE PTR _$S1$2[ebp+5], al
  0007b	84 c0		 test	 al, al
  0007d	74 33		 je	 SHORT $LN2@CloseAllSe

; 128  : 		{
; 129  : 			try
; 130  : 			{
; 131  : 				CloseSession (p.first);

  0007f	56		 push	 esi
  00080	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00084	e8 00 00 00 00	 call	 ?CloseSession@SecurityToken@GostCrypt@@KAXK@Z ; GostCrypt::SecurityToken::CloseSession
  00089	83 c4 04	 add	 esp, 4
  0008c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00093	c6 45 cc 01	 mov	 BYTE PTR _$S1$2[ebp+4], 1
  00097	eb d7		 jmp	 SHORT $LL7@CloseAllSe
__catch$?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ$0:

; 132  : 			}
; 133  : 			catch (...) { }

  00099	b8 00 00 00 00	 mov	 eax, $LN17@CloseAllSe
  0009e	c3		 ret	 0
$LN17@CloseAllSe:
  0009f	8b 7d ec	 mov	 edi, DWORD PTR _forEachContainer$5[ebp]
  000a2	8b 75 e0	 mov	 esi, DWORD PTR _p$3[ebp]
  000a5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 123  : 			return;
; 124  : 
; 125  : 		typedef pair <CK_SLOT_ID, Pkcs11Session> SessionMapPair;
; 126  : 
; 127  : 		foreach (SessionMapPair p, Sessions)

  000ac	c6 45 cc 01	 mov	 BYTE PTR _$S1$2[ebp+4], 1
  000b0	eb be		 jmp	 SHORT $LL7@CloseAllSe
$LN2@CloseAllSe:
  000b2	8b 07		 mov	 eax, DWORD PTR [edi]
  000b4	8d 4d c8	 lea	 ecx, DWORD PTR _$S1$2[ebp]
  000b7	ff 50 08	 call	 DWORD PTR [eax+8]
  000ba	eb 9a		 jmp	 SHORT $LL4@CloseAllSe
$LN3@CloseAllSe:

; 134  : 		}

  000bc	8b 45 d0	 mov	 eax, DWORD PTR _$S1$2[ebp+8]
  000bf	8d 4d d0	 lea	 ecx, DWORD PTR _$S1$2[ebp+8]
  000c2	50		 push	 eax
  000c3	ff 30		 push	 DWORD PTR [eax]
  000c5	8d 45 ec	 lea	 eax, DWORD PTR $T4[ebp]
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned long,GostCrypt::Pkcs11Session,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,GostCrypt::Pkcs11Session> >,0> >::erase
  000ce	ff 75 d0	 push	 DWORD PTR _$S1$2[ebp+8]
  000d1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d6	83 c4 04	 add	 esp, 4
$LN209@CloseAllSe:

; 135  : 	}

  000d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e3	59		 pop	 ecx
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ$2:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _$S1$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$map@KUPkcs11Session@GostCrypt@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKUPkcs11Session@GostCrypt@@@std@@@4@@std@@@ForEach@GostCrypt@@UAE@XZ
__ehhandler$?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CloseAllSessions@SecurityToken@GostCrypt@@SAXXZ ENDP	; GostCrypt::SecurityToken::CloseAllSessions
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.h
;	COMDAT ??0Pkcs11Session@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??0Pkcs11Session@GostCrypt@@QAE@XZ PROC			; GostCrypt::Pkcs11Session::Pkcs11Session, COMDAT
; _this$ = ecx

; 158  : 		Pkcs11Session () : UserLoggedIn (false) { }

  00000	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00004	8b c1		 mov	 eax, ecx
  00006	c3		 ret	 0
??0Pkcs11Session@GostCrypt@@QAE@XZ ENDP			; GostCrypt::Pkcs11Session::Pkcs11Session
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SecurityTokenKeyfileNotFound@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0SecurityTokenKeyfileNotFound@GostCrypt@@QAE@ABU01@@Z PROC ; GostCrypt::SecurityTokenKeyfileNotFound::SecurityTokenKeyfileNotFound, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SecurityTokenKeyfileNotFound@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c2 04 00	 ret	 4
??0SecurityTokenKeyfileNotFound@GostCrypt@@QAE@ABU01@@Z ENDP ; GostCrypt::SecurityTokenKeyfileNotFound::SecurityTokenKeyfileNotFound
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SecurityTokenKeyfileNotFound@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??0SecurityTokenKeyfileNotFound@GostCrypt@@QAE@XZ PROC	; GostCrypt::SecurityTokenKeyfileNotFound::SecurityTokenKeyfileNotFound, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SecurityTokenKeyfileNotFound@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0SecurityTokenKeyfileNotFound@GostCrypt@@QAE@XZ ENDP	; GostCrypt::SecurityTokenKeyfileNotFound::SecurityTokenKeyfileNotFound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.h
;	COMDAT ?Show@SecurityTokenKeyfileNotFound@GostCrypt@@UBEXPAUHWND__@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
?Show@SecurityTokenKeyfileNotFound@GostCrypt@@UBEXPAUHWND__@@@Z PROC ; GostCrypt::SecurityTokenKeyfileNotFound::Show, COMDAT
; _this$ = ecx

; 150  : 		void Show (HWND parent) const { Error ("TOKEN_KEYFILE_NOT_FOUND"); }

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BBCBGCML@TOKEN_KEYFILE_NOT_FOUND?$AA@
  00005	e8 00 00 00 00	 call	 _Error
  0000a	59		 pop	 ecx
  0000b	c2 04 00	 ret	 4
?Show@SecurityTokenKeyfileNotFound@GostCrypt@@UBEXPAUHWND__@@@Z ENDP ; GostCrypt::SecurityTokenKeyfileNotFound::Show
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SecurityTokenKeyfileAlreadyExists@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0SecurityTokenKeyfileAlreadyExists@GostCrypt@@QAE@ABU01@@Z PROC ; GostCrypt::SecurityTokenKeyfileAlreadyExists::SecurityTokenKeyfileAlreadyExists, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SecurityTokenKeyfileAlreadyExists@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c2 04 00	 ret	 4
??0SecurityTokenKeyfileAlreadyExists@GostCrypt@@QAE@ABU01@@Z ENDP ; GostCrypt::SecurityTokenKeyfileAlreadyExists::SecurityTokenKeyfileAlreadyExists
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SecurityTokenKeyfileAlreadyExists@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??0SecurityTokenKeyfileAlreadyExists@GostCrypt@@QAE@XZ PROC ; GostCrypt::SecurityTokenKeyfileAlreadyExists::SecurityTokenKeyfileAlreadyExists, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SecurityTokenKeyfileAlreadyExists@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0SecurityTokenKeyfileAlreadyExists@GostCrypt@@QAE@XZ ENDP ; GostCrypt::SecurityTokenKeyfileAlreadyExists::SecurityTokenKeyfileAlreadyExists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.h
;	COMDAT ?Show@SecurityTokenKeyfileAlreadyExists@GostCrypt@@UBEXPAUHWND__@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
?Show@SecurityTokenKeyfileAlreadyExists@GostCrypt@@UBEXPAUHWND__@@@Z PROC ; GostCrypt::SecurityTokenKeyfileAlreadyExists::Show, COMDAT
; _this$ = ecx

; 145  : 		void Show (HWND parent) const { Error ("TOKEN_KEYFILE_ALREADY_EXISTS"); }

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@LMLDGKPH@TOKEN_KEYFILE_ALREADY_EXISTS?$AA@
  00005	e8 00 00 00 00	 call	 _Error
  0000a	59		 pop	 ecx
  0000b	c2 04 00	 ret	 4
?Show@SecurityTokenKeyfileAlreadyExists@GostCrypt@@UBEXPAUHWND__@@@Z ENDP ; GostCrypt::SecurityTokenKeyfileAlreadyExists::Show
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0InvalidSecurityTokenKeyfilePath@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0InvalidSecurityTokenKeyfilePath@GostCrypt@@QAE@ABU01@@Z PROC ; GostCrypt::InvalidSecurityTokenKeyfilePath::InvalidSecurityTokenKeyfilePath, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7InvalidSecurityTokenKeyfilePath@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c2 04 00	 ret	 4
??0InvalidSecurityTokenKeyfilePath@GostCrypt@@QAE@ABU01@@Z ENDP ; GostCrypt::InvalidSecurityTokenKeyfilePath::InvalidSecurityTokenKeyfilePath
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0InvalidSecurityTokenKeyfilePath@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??0InvalidSecurityTokenKeyfilePath@GostCrypt@@QAE@XZ PROC ; GostCrypt::InvalidSecurityTokenKeyfilePath::InvalidSecurityTokenKeyfilePath, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7InvalidSecurityTokenKeyfilePath@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0InvalidSecurityTokenKeyfilePath@GostCrypt@@QAE@XZ ENDP ; GostCrypt::InvalidSecurityTokenKeyfilePath::InvalidSecurityTokenKeyfilePath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.h
;	COMDAT ?Show@InvalidSecurityTokenKeyfilePath@GostCrypt@@UBEXPAUHWND__@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
?Show@InvalidSecurityTokenKeyfilePath@GostCrypt@@UBEXPAUHWND__@@@Z PROC ; GostCrypt::InvalidSecurityTokenKeyfilePath::Show, COMDAT
; _this$ = ecx

; 140  : 		void Show (HWND parent) const { Error ("INVALID_TOKEN_KEYFILE_PATH"); }

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@JIBHLIDC@INVALID_TOKEN_KEYFILE_PATH?$AA@
  00005	e8 00 00 00 00	 call	 _Error
  0000a	59		 pop	 ecx
  0000b	c2 04 00	 ret	 4
?Show@InvalidSecurityTokenKeyfilePath@GostCrypt@@UBEXPAUHWND__@@@Z ENDP ; GostCrypt::InvalidSecurityTokenKeyfilePath::Show
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SecurityTokenLibraryNotInitialized@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0SecurityTokenLibraryNotInitialized@GostCrypt@@QAE@ABU01@@Z PROC ; GostCrypt::SecurityTokenLibraryNotInitialized::SecurityTokenLibraryNotInitialized, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SecurityTokenLibraryNotInitialized@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c2 04 00	 ret	 4
??0SecurityTokenLibraryNotInitialized@GostCrypt@@QAE@ABU01@@Z ENDP ; GostCrypt::SecurityTokenLibraryNotInitialized::SecurityTokenLibraryNotInitialized
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SecurityTokenLibraryNotInitialized@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??0SecurityTokenLibraryNotInitialized@GostCrypt@@QAE@XZ PROC ; GostCrypt::SecurityTokenLibraryNotInitialized::SecurityTokenLibraryNotInitialized, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SecurityTokenLibraryNotInitialized@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0SecurityTokenLibraryNotInitialized@GostCrypt@@QAE@XZ ENDP ; GostCrypt::SecurityTokenLibraryNotInitialized::SecurityTokenLibraryNotInitialized
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.h
;	COMDAT ?Show@SecurityTokenLibraryNotInitialized@GostCrypt@@UBEXPAUHWND__@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
?Show@SecurityTokenLibraryNotInitialized@GostCrypt@@UBEXPAUHWND__@@@Z PROC ; GostCrypt::SecurityTokenLibraryNotInitialized::Show, COMDAT
; _this$ = ecx

; 135  : 		void Show (HWND parent) const { Error (SecurityTokenLibraryPath[0] == 0 ? "NO_PKCS11_MODULE_SPECIFIED" : "PKCS11_MODULE_INIT_FAILED"); }

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _SecurityTokenLibraryPath, 0
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BK@OPPAPAFF@PKCS11_MODULE_INIT_FAILED?$AA@
  0000c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BL@NECJIJNL@NO_PKCS11_MODULE_SPECIFIED?$AA@
  00011	0f 45 c1	 cmovne	 eax, ecx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _Error
  0001a	59		 pop	 ecx
  0001b	c2 04 00	 ret	 4
?Show@SecurityTokenLibraryNotInitialized@GostCrypt@@UBEXPAUHWND__@@@Z ENDP ; GostCrypt::SecurityTokenLibraryNotInitialized::Show
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0Pkcs11Exception@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0Pkcs11Exception@GostCrypt@@QAE@ABU01@@Z PROC		; GostCrypt::Pkcs11Exception::Pkcs11Exception, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  0000c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00012	8a 42 08	 mov	 al, BYTE PTR [edx+8]
  00015	88 41 08	 mov	 BYTE PTR [ecx+8], al
  00018	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0001b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0001e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00021	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00024	8b c1		 mov	 eax, ecx
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0Pkcs11Exception@GostCrypt@@QAE@ABU01@@Z ENDP		; GostCrypt::Pkcs11Exception::Pkcs11Exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.h
;	COMDAT ?GetErrorCode@Pkcs11Exception@GostCrypt@@QBEKXZ
_TEXT	SEGMENT
?GetErrorCode@Pkcs11Exception@GostCrypt@@QBEKXZ PROC	; GostCrypt::Pkcs11Exception::GetErrorCode, COMDAT
; _this$ = ecx

; 106  : 		CK_RV GetErrorCode () const { return ErrorCode; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetErrorCode@Pkcs11Exception@GostCrypt@@QBEKXZ ENDP	; GostCrypt::Pkcs11Exception::GetErrorCode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_s$ = -196						; size = 176
_this$2 = -20						; size = 4
_this$ = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; GostCrypt::Pkcs11Exception::operator std::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 726  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f1		 mov	 esi, ecx
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 727  : 		if (ErrorCode == CKR_OK)

  00033	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00036	85 d2		 test	 edx, edx
  00038	75 22		 jne	 SHORT $LN5@basic_stri

; 728  : 			return string();

  0003a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003d	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
  00044	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00047	88 10		 mov	 BYTE PTR [eax], dl

; 838  : 
; 839  : 	}

  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN5@basic_stri:

; 729  : 
; 730  : 		static const struct
; 731  : 		{
; 732  : 			CK_RV ErrorCode;
; 733  : 			const char *ErrorString;
; 734  : 		} ErrorStrings[] =
; 735  : 		{
; 736  : #			define GST_TOKEN_ERR(CODE) { CODE, #CODE },
; 737  : 
; 738  : 			GST_TOKEN_ERR (CKR_CANCEL)
; 739  : 			GST_TOKEN_ERR (CKR_HOST_MEMORY)
; 740  : 			GST_TOKEN_ERR (CKR_SLOT_ID_INVALID)
; 741  : 			GST_TOKEN_ERR (CKR_GENERAL_ERROR)
; 742  : 			GST_TOKEN_ERR (CKR_FUNCTION_FAILED)
; 743  : 			GST_TOKEN_ERR (CKR_ARGUMENTS_BAD)
; 744  : 			GST_TOKEN_ERR (CKR_NO_EVENT)
; 745  : 			GST_TOKEN_ERR (CKR_NEED_TO_CREATE_THREADS)
; 746  : 			GST_TOKEN_ERR (CKR_CANT_LOCK)
; 747  : 			GST_TOKEN_ERR (CKR_ATTRIBUTE_READ_ONLY)
; 748  : 			GST_TOKEN_ERR (CKR_ATTRIBUTE_SENSITIVE)
; 749  : 			GST_TOKEN_ERR (CKR_ATTRIBUTE_TYPE_INVALID)
; 750  : 			GST_TOKEN_ERR (CKR_ATTRIBUTE_VALUE_INVALID)
; 751  : 			GST_TOKEN_ERR (CKR_DATA_INVALID)
; 752  : 			GST_TOKEN_ERR (CKR_DATA_LEN_RANGE)
; 753  : 			GST_TOKEN_ERR (CKR_DEVICE_ERROR)
; 754  : 			GST_TOKEN_ERR (CKR_DEVICE_MEMORY)
; 755  : 			GST_TOKEN_ERR (CKR_DEVICE_REMOVED)
; 756  : 			GST_TOKEN_ERR (CKR_ENCRYPTED_DATA_INVALID)
; 757  : 			GST_TOKEN_ERR (CKR_ENCRYPTED_DATA_LEN_RANGE)
; 758  : 			GST_TOKEN_ERR (CKR_FUNCTION_CANCELED)
; 759  : 			GST_TOKEN_ERR (CKR_FUNCTION_NOT_PARALLEL)
; 760  : 			GST_TOKEN_ERR (CKR_FUNCTION_NOT_SUPPORTED)
; 761  : 			GST_TOKEN_ERR (CKR_KEY_HANDLE_INVALID)
; 762  : 			GST_TOKEN_ERR (CKR_KEY_SIZE_RANGE)
; 763  : 			GST_TOKEN_ERR (CKR_KEY_TYPE_INCONSISTENT)
; 764  : 			GST_TOKEN_ERR (CKR_KEY_NOT_NEEDED)
; 765  : 			GST_TOKEN_ERR (CKR_KEY_CHANGED)
; 766  : 			GST_TOKEN_ERR (CKR_KEY_NEEDED)
; 767  : 			GST_TOKEN_ERR (CKR_KEY_INDIGESTIBLE)
; 768  : 			GST_TOKEN_ERR (CKR_KEY_FUNCTION_NOT_PERMITTED)
; 769  : 			GST_TOKEN_ERR (CKR_KEY_NOT_WRAPPABLE)
; 770  : 			GST_TOKEN_ERR (CKR_KEY_UNEXTRACTABLE)
; 771  : 			GST_TOKEN_ERR (CKR_MECHANISM_INVALID)
; 772  : 			GST_TOKEN_ERR (CKR_MECHANISM_PARAM_INVALID)
; 773  : 			GST_TOKEN_ERR (CKR_OBJECT_HANDLE_INVALID)
; 774  : 			GST_TOKEN_ERR (CKR_OPERATION_ACTIVE)
; 775  : 			GST_TOKEN_ERR (CKR_OPERATION_NOT_INITIALIZED)
; 776  : 			GST_TOKEN_ERR (CKR_PIN_INCORRECT)
; 777  : 			GST_TOKEN_ERR (CKR_PIN_INVALID)
; 778  : 			GST_TOKEN_ERR (CKR_PIN_LEN_RANGE)
; 779  : 			GST_TOKEN_ERR (CKR_PIN_EXPIRED)
; 780  : 			GST_TOKEN_ERR (CKR_PIN_LOCKED)
; 781  : 			GST_TOKEN_ERR (CKR_SESSION_CLOSED)
; 782  : 			GST_TOKEN_ERR (CKR_SESSION_COUNT)
; 783  : 			GST_TOKEN_ERR (CKR_SESSION_HANDLE_INVALID)
; 784  : 			GST_TOKEN_ERR (CKR_SESSION_PARALLEL_NOT_SUPPORTED)
; 785  : 			GST_TOKEN_ERR (CKR_SESSION_READ_ONLY)
; 786  : 			GST_TOKEN_ERR (CKR_SESSION_EXISTS)
; 787  : 			GST_TOKEN_ERR (CKR_SESSION_READ_ONLY_EXISTS)
; 788  : 			GST_TOKEN_ERR (CKR_SESSION_READ_WRITE_SO_EXISTS)
; 789  : 			GST_TOKEN_ERR (CKR_SIGNATURE_INVALID)
; 790  : 			GST_TOKEN_ERR (CKR_SIGNATURE_LEN_RANGE)
; 791  : 			GST_TOKEN_ERR (CKR_TEMPLATE_INCOMPLETE)
; 792  : 			GST_TOKEN_ERR (CKR_TEMPLATE_INCONSISTENT)
; 793  : 			GST_TOKEN_ERR (CKR_TOKEN_NOT_PRESENT)
; 794  : 			GST_TOKEN_ERR (CKR_TOKEN_NOT_RECOGNIZED)
; 795  : 			GST_TOKEN_ERR (CKR_TOKEN_WRITE_PROTECTED)
; 796  : 			GST_TOKEN_ERR (CKR_UNWRAPPING_KEY_HANDLE_INVALID)
; 797  : 			GST_TOKEN_ERR (CKR_UNWRAPPING_KEY_SIZE_RANGE)
; 798  : 			GST_TOKEN_ERR (CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT)
; 799  : 			GST_TOKEN_ERR (CKR_USER_ALREADY_LOGGED_IN)
; 800  : 			GST_TOKEN_ERR (CKR_USER_NOT_LOGGED_IN)
; 801  : 			GST_TOKEN_ERR (CKR_USER_PIN_NOT_INITIALIZED)
; 802  : 			GST_TOKEN_ERR (CKR_USER_TYPE_INVALID)
; 803  : 			GST_TOKEN_ERR (CKR_USER_ANOTHER_ALREADY_LOGGED_IN)
; 804  : 			GST_TOKEN_ERR (CKR_USER_TOO_MANY_TYPES)
; 805  : 			GST_TOKEN_ERR (CKR_WRAPPED_KEY_INVALID)
; 806  : 			GST_TOKEN_ERR (CKR_WRAPPED_KEY_LEN_RANGE)
; 807  : 			GST_TOKEN_ERR (CKR_WRAPPING_KEY_HANDLE_INVALID)
; 808  : 			GST_TOKEN_ERR (CKR_WRAPPING_KEY_SIZE_RANGE)
; 809  : 			GST_TOKEN_ERR (CKR_WRAPPING_KEY_TYPE_INCONSISTENT)
; 810  : 			GST_TOKEN_ERR (CKR_RANDOM_SEED_NOT_SUPPORTED)
; 811  : 			GST_TOKEN_ERR (CKR_RANDOM_NO_RNG)
; 812  : 			GST_TOKEN_ERR (CKR_DOMAIN_PARAMS_INVALID)
; 813  : 			GST_TOKEN_ERR (CKR_BUFFER_TOO_SMALL)
; 814  : 			GST_TOKEN_ERR (CKR_SAVED_STATE_INVALID)
; 815  : 			GST_TOKEN_ERR (CKR_INFORMATION_SENSITIVE)
; 816  : 			GST_TOKEN_ERR (CKR_STATE_UNSAVEABLE)
; 817  : 			GST_TOKEN_ERR (CKR_CRYPTOKI_NOT_INITIALIZED)
; 818  : 			GST_TOKEN_ERR (CKR_CRYPTOKI_ALREADY_INITIALIZED)
; 819  : 			GST_TOKEN_ERR (CKR_MUTEX_BAD)
; 820  : 			GST_TOKEN_ERR (CKR_MUTEX_NOT_LOCKED)
; 821  : 			GST_TOKEN_ERR (CKR_NEW_PIN_MODE)
; 822  : 			GST_TOKEN_ERR (CKR_NEXT_OTP)
; 823  : 			GST_TOKEN_ERR (CKR_FUNCTION_REJECTED)
; 824  : 
; 825  : #undef		GST_TOKEN_ERR
; 826  : 		};
; 827  : 
; 828  : 
; 829  : 		for (size_t i = 0; i < array_capacity (ErrorStrings); ++i)

  0005c	33 c0		 xor	 eax, eax
  0005e	66 90		 npad	 2
$LL4@basic_stri:

; 830  : 		{
; 831  : 			if (ErrorStrings[i].ErrorCode == ErrorCode)

  00060	39 14 c5 00 00
	00 00		 cmp	 DWORD PTR ?ErrorStrings@?1???BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4QBU<unnamed-type-ErrorStrings>@?1???B12@QBE?AV34@XZ@B[eax*8], edx
  00067	0f 84 78 01 00
	00		 je	 $LN325@basic_stri

; 729  : 
; 730  : 		static const struct
; 731  : 		{
; 732  : 			CK_RV ErrorCode;
; 733  : 			const char *ErrorString;
; 734  : 		} ErrorStrings[] =
; 735  : 		{
; 736  : #			define GST_TOKEN_ERR(CODE) { CODE, #CODE },
; 737  : 
; 738  : 			GST_TOKEN_ERR (CKR_CANCEL)
; 739  : 			GST_TOKEN_ERR (CKR_HOST_MEMORY)
; 740  : 			GST_TOKEN_ERR (CKR_SLOT_ID_INVALID)
; 741  : 			GST_TOKEN_ERR (CKR_GENERAL_ERROR)
; 742  : 			GST_TOKEN_ERR (CKR_FUNCTION_FAILED)
; 743  : 			GST_TOKEN_ERR (CKR_ARGUMENTS_BAD)
; 744  : 			GST_TOKEN_ERR (CKR_NO_EVENT)
; 745  : 			GST_TOKEN_ERR (CKR_NEED_TO_CREATE_THREADS)
; 746  : 			GST_TOKEN_ERR (CKR_CANT_LOCK)
; 747  : 			GST_TOKEN_ERR (CKR_ATTRIBUTE_READ_ONLY)
; 748  : 			GST_TOKEN_ERR (CKR_ATTRIBUTE_SENSITIVE)
; 749  : 			GST_TOKEN_ERR (CKR_ATTRIBUTE_TYPE_INVALID)
; 750  : 			GST_TOKEN_ERR (CKR_ATTRIBUTE_VALUE_INVALID)
; 751  : 			GST_TOKEN_ERR (CKR_DATA_INVALID)
; 752  : 			GST_TOKEN_ERR (CKR_DATA_LEN_RANGE)
; 753  : 			GST_TOKEN_ERR (CKR_DEVICE_ERROR)
; 754  : 			GST_TOKEN_ERR (CKR_DEVICE_MEMORY)
; 755  : 			GST_TOKEN_ERR (CKR_DEVICE_REMOVED)
; 756  : 			GST_TOKEN_ERR (CKR_ENCRYPTED_DATA_INVALID)
; 757  : 			GST_TOKEN_ERR (CKR_ENCRYPTED_DATA_LEN_RANGE)
; 758  : 			GST_TOKEN_ERR (CKR_FUNCTION_CANCELED)
; 759  : 			GST_TOKEN_ERR (CKR_FUNCTION_NOT_PARALLEL)
; 760  : 			GST_TOKEN_ERR (CKR_FUNCTION_NOT_SUPPORTED)
; 761  : 			GST_TOKEN_ERR (CKR_KEY_HANDLE_INVALID)
; 762  : 			GST_TOKEN_ERR (CKR_KEY_SIZE_RANGE)
; 763  : 			GST_TOKEN_ERR (CKR_KEY_TYPE_INCONSISTENT)
; 764  : 			GST_TOKEN_ERR (CKR_KEY_NOT_NEEDED)
; 765  : 			GST_TOKEN_ERR (CKR_KEY_CHANGED)
; 766  : 			GST_TOKEN_ERR (CKR_KEY_NEEDED)
; 767  : 			GST_TOKEN_ERR (CKR_KEY_INDIGESTIBLE)
; 768  : 			GST_TOKEN_ERR (CKR_KEY_FUNCTION_NOT_PERMITTED)
; 769  : 			GST_TOKEN_ERR (CKR_KEY_NOT_WRAPPABLE)
; 770  : 			GST_TOKEN_ERR (CKR_KEY_UNEXTRACTABLE)
; 771  : 			GST_TOKEN_ERR (CKR_MECHANISM_INVALID)
; 772  : 			GST_TOKEN_ERR (CKR_MECHANISM_PARAM_INVALID)
; 773  : 			GST_TOKEN_ERR (CKR_OBJECT_HANDLE_INVALID)
; 774  : 			GST_TOKEN_ERR (CKR_OPERATION_ACTIVE)
; 775  : 			GST_TOKEN_ERR (CKR_OPERATION_NOT_INITIALIZED)
; 776  : 			GST_TOKEN_ERR (CKR_PIN_INCORRECT)
; 777  : 			GST_TOKEN_ERR (CKR_PIN_INVALID)
; 778  : 			GST_TOKEN_ERR (CKR_PIN_LEN_RANGE)
; 779  : 			GST_TOKEN_ERR (CKR_PIN_EXPIRED)
; 780  : 			GST_TOKEN_ERR (CKR_PIN_LOCKED)
; 781  : 			GST_TOKEN_ERR (CKR_SESSION_CLOSED)
; 782  : 			GST_TOKEN_ERR (CKR_SESSION_COUNT)
; 783  : 			GST_TOKEN_ERR (CKR_SESSION_HANDLE_INVALID)
; 784  : 			GST_TOKEN_ERR (CKR_SESSION_PARALLEL_NOT_SUPPORTED)
; 785  : 			GST_TOKEN_ERR (CKR_SESSION_READ_ONLY)
; 786  : 			GST_TOKEN_ERR (CKR_SESSION_EXISTS)
; 787  : 			GST_TOKEN_ERR (CKR_SESSION_READ_ONLY_EXISTS)
; 788  : 			GST_TOKEN_ERR (CKR_SESSION_READ_WRITE_SO_EXISTS)
; 789  : 			GST_TOKEN_ERR (CKR_SIGNATURE_INVALID)
; 790  : 			GST_TOKEN_ERR (CKR_SIGNATURE_LEN_RANGE)
; 791  : 			GST_TOKEN_ERR (CKR_TEMPLATE_INCOMPLETE)
; 792  : 			GST_TOKEN_ERR (CKR_TEMPLATE_INCONSISTENT)
; 793  : 			GST_TOKEN_ERR (CKR_TOKEN_NOT_PRESENT)
; 794  : 			GST_TOKEN_ERR (CKR_TOKEN_NOT_RECOGNIZED)
; 795  : 			GST_TOKEN_ERR (CKR_TOKEN_WRITE_PROTECTED)
; 796  : 			GST_TOKEN_ERR (CKR_UNWRAPPING_KEY_HANDLE_INVALID)
; 797  : 			GST_TOKEN_ERR (CKR_UNWRAPPING_KEY_SIZE_RANGE)
; 798  : 			GST_TOKEN_ERR (CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT)
; 799  : 			GST_TOKEN_ERR (CKR_USER_ALREADY_LOGGED_IN)
; 800  : 			GST_TOKEN_ERR (CKR_USER_NOT_LOGGED_IN)
; 801  : 			GST_TOKEN_ERR (CKR_USER_PIN_NOT_INITIALIZED)
; 802  : 			GST_TOKEN_ERR (CKR_USER_TYPE_INVALID)
; 803  : 			GST_TOKEN_ERR (CKR_USER_ANOTHER_ALREADY_LOGGED_IN)
; 804  : 			GST_TOKEN_ERR (CKR_USER_TOO_MANY_TYPES)
; 805  : 			GST_TOKEN_ERR (CKR_WRAPPED_KEY_INVALID)
; 806  : 			GST_TOKEN_ERR (CKR_WRAPPED_KEY_LEN_RANGE)
; 807  : 			GST_TOKEN_ERR (CKR_WRAPPING_KEY_HANDLE_INVALID)
; 808  : 			GST_TOKEN_ERR (CKR_WRAPPING_KEY_SIZE_RANGE)
; 809  : 			GST_TOKEN_ERR (CKR_WRAPPING_KEY_TYPE_INCONSISTENT)
; 810  : 			GST_TOKEN_ERR (CKR_RANDOM_SEED_NOT_SUPPORTED)
; 811  : 			GST_TOKEN_ERR (CKR_RANDOM_NO_RNG)
; 812  : 			GST_TOKEN_ERR (CKR_DOMAIN_PARAMS_INVALID)
; 813  : 			GST_TOKEN_ERR (CKR_BUFFER_TOO_SMALL)
; 814  : 			GST_TOKEN_ERR (CKR_SAVED_STATE_INVALID)
; 815  : 			GST_TOKEN_ERR (CKR_INFORMATION_SENSITIVE)
; 816  : 			GST_TOKEN_ERR (CKR_STATE_UNSAVEABLE)
; 817  : 			GST_TOKEN_ERR (CKR_CRYPTOKI_NOT_INITIALIZED)
; 818  : 			GST_TOKEN_ERR (CKR_CRYPTOKI_ALREADY_INITIALIZED)
; 819  : 			GST_TOKEN_ERR (CKR_MUTEX_BAD)
; 820  : 			GST_TOKEN_ERR (CKR_MUTEX_NOT_LOCKED)
; 821  : 			GST_TOKEN_ERR (CKR_NEW_PIN_MODE)
; 822  : 			GST_TOKEN_ERR (CKR_NEXT_OTP)
; 823  : 			GST_TOKEN_ERR (CKR_FUNCTION_REJECTED)
; 824  : 
; 825  : #undef		GST_TOKEN_ERR
; 826  : 		};
; 827  : 
; 828  : 
; 829  : 		for (size_t i = 0; i < array_capacity (ErrorStrings); ++i)

  0006d	40		 inc	 eax
  0006e	83 f8 56	 cmp	 eax, 86			; 00000056H
  00071	72 ed		 jb	 SHORT $LL4@basic_stri

; 833  : 		}
; 834  : 
; 835  : 		stringstream s;

  00073	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$[ebp], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0007d	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$[ebp+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00087	6a 00		 push	 0
  00089	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp+24]
  0008f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00096	0f 57 c0	 xorps	 xmm0, xmm0
  00099	c7 45 f0 02 00
	00 00		 mov	 DWORD PTR $T3[ebp], 2
  000a0	50		 push	 eax
  000a1	8d 4d a4	 lea	 ecx, DWORD PTR _s$[ebp+104]
  000a4	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _s$[ebp+104], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  000ab	c7 45 a0 50 00
	00 00		 mov	 DWORD PTR _s$[ebp+100], 80 ; 00000050H
  000b2	66 0f 13 85 44
	ff ff ff	 movlpd	 QWORD PTR _s$[ebp+8], xmm0
  000ba	e8 00 00 00 00	 call	 ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
  000bf	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp+16]
  000c5	89 45 ec	 mov	 DWORD PTR _this$2[ebp], eax
  000c8	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp+16]
  000ce	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d1	c7 84 05 4c ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _s$[ebp+eax+16], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  000dc	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp+16]
  000e2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000e5	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  000e8	89 84 0d 48 ff
	ff ff		 mov	 DWORD PTR _s$[ebp+ecx+12], eax
  000ef	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  000f5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f8	c7 84 05 3c ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _s$[ebp+eax], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  00103	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00109	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0010c	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  0010f	89 84 0d 38 ff
	ff ff		 mov	 DWORD PTR _s$[ebp+ecx-4], eax
  00116	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  0011c	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  00123	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00126	c7 84 05 3c ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _s$[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00131	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _s$[ebp]
  00137	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013a	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  0013d	89 84 0d 38 ff
	ff ff		 mov	 DWORD PTR _s$[ebp+ecx-4], eax
  00144	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp+24]
  0014a	8b c8		 mov	 ecx, eax
  0014c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
  0014f	e8 00 00 00 00	 call	 ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
  00154	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _s$[ebp+24], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0015e	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _s$[ebp+80], 0
  00165	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _s$[ebp+84], 0

; 836  : 		s << "0x" << hex << ErrorCode;

  0016c	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _s$[ebp+16]
  00172	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7
  00179	68 00 00 00 00	 push	 OFFSET ??_C@_02MDDDDAID@0x?$AA@
  0017e	50		 push	 eax
  0017f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00184	8b d0		 mov	 edx, eax
  00186	83 c4 08	 add	 esp, 8
  00189	85 d2		 test	 edx, edx
  0018b	75 04		 jne	 SHORT $LN309@basic_stri
  0018d	33 c9		 xor	 ecx, ecx
  0018f	eb 07		 jmp	 SHORT $LN310@basic_stri
$LN309@basic_stri:
  00191	8b 02		 mov	 eax, DWORD PTR [edx]
  00193	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00196	03 ca		 add	 ecx, edx
$LN310@basic_stri:
  00198	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0019b	25 ff f9 ff ff	 and	 eax, -1537		; fffff9ffH
  001a0	0d 00 08 00 00	 or	 eax, 2048		; 00000800H
  001a5	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  001a8	8b ca		 mov	 ecx, edx
  001aa	ff 76 04	 push	 DWORD PTR [esi+4]
  001ad	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 837  : 		return s.str();

  001b2	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  001b5	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  001bb	56		 push	 esi
  001bc	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  001c1	8d 4d a4	 lea	 ecx, DWORD PTR _s$[ebp+104]
  001c4	e8 00 00 00 00	 call	 ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  001c9	8d 45 a4	 lea	 eax, DWORD PTR _s$[ebp+104]
  001cc	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 8
  001d3	50		 push	 eax
  001d4	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _s$[ebp+104], OFFSET ??_7ios_base@std@@6B@
  001db	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  001e0	83 c4 04	 add	 esp, 4
  001e3	eb 3d		 jmp	 SHORT $LN332@basic_stri
$LN325@basic_stri:

; 832  : 				return ErrorStrings[i].ErrorString;

  001e5	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  001e8	8b 14 c5 04 00
	00 00		 mov	 edx, DWORD PTR ?ErrorStrings@?1???BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4QBU<unnamed-type-ErrorStrings>@?1???B12@QBE?AV34@XZ@B[eax*8+4]
  001ef	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  001f6	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  001fd	c6 06 00	 mov	 BYTE PTR [esi], 0
  00200	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00203	75 04		 jne	 SHORT $LN230@basic_stri
  00205	33 c9		 xor	 ecx, ecx
  00207	eb 10		 jmp	 SHORT $LN231@basic_stri
$LN230@basic_stri:
  00209	8b ca		 mov	 ecx, edx
  0020b	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
  0020e	66 90		 npad	 2
$LL330@basic_stri:
  00210	8a 01		 mov	 al, BYTE PTR [ecx]
  00212	41		 inc	 ecx
  00213	84 c0		 test	 al, al
  00215	75 f9		 jne	 SHORT $LL330@basic_stri
  00217	2b cf		 sub	 ecx, edi
$LN231@basic_stri:
  00219	51		 push	 ecx
  0021a	52		 push	 edx
  0021b	8b ce		 mov	 ecx, esi
  0021d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN332@basic_stri:
  00222	8b c6		 mov	 eax, esi

; 838  : 
; 839  : 	}

  00224	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00227	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0022e	59		 pop	 ecx
  0022f	5f		 pop	 edi
  00230	5e		 pop	 esi
  00231	8b e5		 mov	 esp, ebp
  00233	5d		 pop	 ebp
  00234	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$55:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00003	83 e0 02	 and	 eax, 2
  00006	0f 84 0c 00 00
	00		 je	 $LN236@basic_stri
  0000c	83 65 f0 fd	 and	 DWORD PTR $T3[ebp], -3	; fffffffdH
  00010	8d 4d a4	 lea	 ecx, DWORD PTR _s$[ebp+104]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN236@basic_stri:
  00018	c3		 ret	 0
__unwindfunclet$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$59:
  00019	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp+24]
  0001f	e9 00 00 00 00	 jmp	 ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
__unwindfunclet$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$56:
  00024	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp+32]
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
__unwindfunclet$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$63:
  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__unwindfunclet$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1:
  00037	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$67:
  00042	e8 00 00 00 00	 call	 ___std_terminate
  00047	c3		 ret	 0
__ehhandler$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
  00048	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0004f	8b 8a 3c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-196]
  00055	33 c8		 xor	 ecx, eax
  00057	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
  00061	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; GostCrypt::Pkcs11Exception::operator std::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z
_TEXT	SEGMENT
_subjectErrorCode$2 = -16704				; size = 176
_this$3 = -16528					; size = 4
_this$ = -16528						; size = 4
$T4 = -16524						; size = 4
$T5 = -16520						; size = 24
$T6 = -16496						; size = 24
_err$7 = -16472						; size = 24
$T8 = -16448						; size = 24
$T9 = -16448						; size = 24
$T10 = -16448						; size = 24
_errorString$ = -16424					; size = 24
_err$11 = -16400					; size = 16384
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_parent$ = 8						; size = 4
?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z PROC	; GostCrypt::Pkcs11Exception::Show, COMDAT
; _this$ = ecx

; 852  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 34 41 00 00	 mov	 eax, 16692		; 00004134H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	56		 push	 esi
  00026	57		 push	 edi
  00027	50		 push	 eax
  00028	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00031	8b f9		 mov	 edi, ecx

; 853  : 		string errorString = string (*this);

  00033	8d 85 c0 bf ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  00039	c7 85 74 bf ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ??BPkcs11Exception@GostCrypt@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GostCrypt::Pkcs11Exception::operator std::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00049	8b f0		 mov	 esi, eax
  0004b	c7 85 ec bf ff
	ff 0f 00 00 00	 mov	 DWORD PTR _errorString$[ebp+20], 15 ; 0000000fH
  00055	c7 85 e8 bf ff
	ff 00 00 00 00	 mov	 DWORD PTR _errorString$[ebp+16], 0
  0005f	c6 85 d8 bf ff
	ff 00		 mov	 BYTE PTR _errorString$[ebp], 0
  00066	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0006a	73 1b		 jae	 SHORT $LN149@Show
  0006c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0006f	83 c0 01	 add	 eax, 1
  00072	74 21		 je	 SHORT $LN150@Show
  00074	50		 push	 eax
  00075	8d 85 d8 bf ff
	ff		 lea	 eax, DWORD PTR _errorString$[ebp]
  0007b	56		 push	 esi
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _memmove
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	eb 0e		 jmp	 SHORT $LN150@Show
$LN149@Show:
  00087	8b 06		 mov	 eax, DWORD PTR [esi]
  00089	89 85 d8 bf ff
	ff		 mov	 DWORD PTR _errorString$[ebp], eax
  0008f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN150@Show:
  00095	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00098	89 85 e8 bf ff
	ff		 mov	 DWORD PTR _errorString$[ebp+16], eax
  0009e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000a1	89 85 ec bf ff
	ff		 mov	 DWORD PTR _errorString$[ebp+20], eax
  000a7	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  000ae	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b2	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000b9	72 02		 jb	 SHORT $LN375@Show
  000bb	8b 36		 mov	 esi, DWORD PTR [esi]
$LN375@Show:
  000bd	c6 06 00	 mov	 BYTE PTR [esi], 0
  000c0	8b 85 d4 bf ff
	ff		 mov	 eax, DWORD PTR $T10[ebp+20]
  000c6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000cd	83 f8 10	 cmp	 eax, 16			; 00000010H
  000d0	72 13		 jb	 SHORT $LN387@Show
  000d2	40		 inc	 eax
  000d3	8d 8d c0 bf ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  000d9	50		 push	 eax
  000da	ff b5 c0 bf ff
	ff		 push	 DWORD PTR $T10[ebp]
  000e0	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN387@Show:
  000e5	83 bd e8 bf ff
	ff 00		 cmp	 DWORD PTR _errorString$[ebp+16], 0

; 854  : 
; 855  : 		if (!errorString.empty())

  000ec	0f 84 69 03 00
	00		 je	 $LN939@Show

; 856  : 		{
; 857  : 			wstringstream subjectErrorCode;

  000f2	c7 85 c0 be ff
	ff 00 00 00 00	 mov	 DWORD PTR _subjectErrorCode$2[ebp], OFFSET ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
  000fc	c7 85 d0 be ff
	ff 00 00 00 00	 mov	 DWORD PTR _subjectErrorCode$2[ebp+16], OFFSET ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
  00106	6a 00		 push	 0
  00108	8d 85 d8 be ff
	ff		 lea	 eax, DWORD PTR _subjectErrorCode$2[ebp+24]
  0010e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00112	0f 57 c0	 xorps	 xmm0, xmm0
  00115	c7 85 74 bf ff
	ff 01 00 00 00	 mov	 DWORD PTR $T4[ebp], 1
  0011f	50		 push	 eax
  00120	8d 8d 28 bf ff
	ff		 lea	 ecx, DWORD PTR _subjectErrorCode$2[ebp+104]
  00126	c7 85 28 bf ff
	ff 00 00 00 00	 mov	 DWORD PTR _subjectErrorCode$2[ebp+104], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00130	c7 85 24 bf ff
	ff 50 00 00 00	 mov	 DWORD PTR _subjectErrorCode$2[ebp+100], 80 ; 00000050H
  0013a	66 0f 13 85 c8
	be ff ff	 movlpd	 QWORD PTR _subjectErrorCode$2[ebp+8], xmm0
  00142	e8 00 00 00 00	 call	 ?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init
  00147	8d 85 d0 be ff
	ff		 lea	 eax, DWORD PTR _subjectErrorCode$2[ebp+16]
  0014d	89 85 70 bf ff
	ff		 mov	 DWORD PTR _this$3[ebp], eax
  00153	8b 85 d0 be ff
	ff		 mov	 eax, DWORD PTR _subjectErrorCode$2[ebp+16]
  00159	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0015c	c7 84 05 d0 be
	ff ff 00 00 00
	00		 mov	 DWORD PTR _subjectErrorCode$2[ebp+eax+16], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  00167	8b 85 d0 be ff
	ff		 mov	 eax, DWORD PTR _subjectErrorCode$2[ebp+16]
  0016d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00170	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  00173	89 84 0d cc be
	ff ff		 mov	 DWORD PTR _subjectErrorCode$2[ebp+ecx+12], eax
  0017a	8b 85 c0 be ff
	ff		 mov	 eax, DWORD PTR _subjectErrorCode$2[ebp]
  00180	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00183	c7 84 05 c0 be
	ff ff 00 00 00
	00		 mov	 DWORD PTR _subjectErrorCode$2[ebp+eax], OFFSET ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
  0018e	8b 85 c0 be ff
	ff		 mov	 eax, DWORD PTR _subjectErrorCode$2[ebp]
  00194	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00197	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  0019a	89 84 0d bc be
	ff ff		 mov	 DWORD PTR _subjectErrorCode$2[ebp+ecx-4], eax
  001a1	8b 85 c0 be ff
	ff		 mov	 eax, DWORD PTR _subjectErrorCode$2[ebp]
  001a7	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6
  001ae	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b1	c7 84 05 c0 be
	ff ff 00 00 00
	00		 mov	 DWORD PTR _subjectErrorCode$2[ebp+eax], OFFSET ??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  001bc	8b 85 c0 be ff
	ff		 mov	 eax, DWORD PTR _subjectErrorCode$2[ebp]
  001c2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001c5	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  001c8	89 84 0d bc be
	ff ff		 mov	 DWORD PTR _subjectErrorCode$2[ebp+ecx-4], eax
  001cf	8d 85 d8 be ff
	ff		 lea	 eax, DWORD PTR _subjectErrorCode$2[ebp+24]
  001d5	8b c8		 mov	 ecx, eax
  001d7	89 85 70 bf ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
  001dd	e8 00 00 00 00	 call	 ??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
  001e2	c7 85 d8 be ff
	ff 00 00 00 00	 mov	 DWORD PTR _subjectErrorCode$2[ebp+24], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  001ec	c7 85 10 bf ff
	ff 00 00 00 00	 mov	 DWORD PTR _subjectErrorCode$2[ebp+80], 0
  001f6	c7 85 14 bf ff
	ff 00 00 00 00	 mov	 DWORD PTR _subjectErrorCode$2[ebp+84], 0

; 858  : 			if (SubjectErrorCodeValid)

  00200	80 7f 08 00	 cmp	 BYTE PTR [edi+8], 0
  00204	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00208	74 21		 je	 SHORT $LN6@Show

; 859  : 				subjectErrorCode << L": " << SubjectErrorCode;

  0020a	ff 77 14	 push	 DWORD PTR [edi+20]
  0020d	8d 85 d0 be ff
	ff		 lea	 eax, DWORD PTR _subjectErrorCode$2[ebp+16]
  00213	ff 77 10	 push	 DWORD PTR [edi+16]
  00216	68 00 00 00 00	 push	 OFFSET ??_C@_15ELOONFKJ@?$AA?3?$AA?5?$AA?$AA@
  0021b	50		 push	 eax
  0021c	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  00221	83 c4 08	 add	 esp, 8
  00224	8b c8		 mov	 ecx, eax
  00226	e8 00 00 00 00	 call	 ??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_K@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<
$LN6@Show:

; 860  : 
; 861  : 			if (!GetDictionaryValue (errorString.c_str()))

  0022b	83 bd ec bf ff
	ff 10		 cmp	 DWORD PTR _errorString$[ebp+20], 16 ; 00000010H
  00232	8d 85 d8 bf ff
	ff		 lea	 eax, DWORD PTR _errorString$[ebp]
  00238	0f 43 85 d8 bf
	ff ff		 cmovae	 eax, DWORD PTR _errorString$[ebp]
  0023f	50		 push	 eax
  00240	e8 00 00 00 00	 call	 _GetDictionaryValue
  00245	83 c4 04	 add	 esp, 4
  00248	85 c0		 test	 eax, eax
  0024a	0f 85 20 01 00
	00		 jne	 $LN7@Show

; 862  : 			{
; 863  : 				if (errorString.find ("CKR_") == 0)

  00250	6a 04		 push	 4
  00252	50		 push	 eax
  00253	68 00 00 00 00	 push	 OFFSET ??_C@_04DIIAEOAC@CKR_?$AA@
  00258	8d 8d d8 bf ff
	ff		 lea	 ecx, DWORD PTR _errorString$[ebp]
  0025e	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00263	85 c0		 test	 eax, eax
  00265	0f 85 7e 00 00
	00		 jne	 $LN3@Show

; 864  : 				{
; 865  : 					errorString = errorString.substr (4);

  0026b	6a ff		 push	 -1
  0026d	6a 04		 push	 4
  0026f	8d 85 c0 bf ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  00275	50		 push	 eax
  00276	8d 8d d8 bf ff
	ff		 lea	 ecx, DWORD PTR _errorString$[ebp]
  0027c	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  00281	50		 push	 eax
  00282	8d 8d d8 bf ff
	ff		 lea	 ecx, DWORD PTR _errorString$[ebp]
  00288	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  0028d	8d 8d c0 bf ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00293	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 866  : 					for (size_t i = 0; i < errorString.size(); ++i)

  00298	8b bd e8 bf ff
	ff		 mov	 edi, DWORD PTR _errorString$[ebp+16]
  0029e	33 c9		 xor	 ecx, ecx
  002a0	85 ff		 test	 edi, edi
  002a2	74 45		 je	 SHORT $LN3@Show
  002a4	8b 95 ec bf ff
	ff		 mov	 edx, DWORD PTR _errorString$[ebp+20]
  002aa	8b b5 d8 bf ff
	ff		 mov	 esi, DWORD PTR _errorString$[ebp]
$LL4@Show:

; 867  : 					{
; 868  : 						if (errorString[i] == '_')

  002b0	83 fa 10	 cmp	 edx, 16			; 00000010H
  002b3	8d 85 d8 bf ff
	ff		 lea	 eax, DWORD PTR _errorString$[ebp]
  002b9	0f 43 c6	 cmovae	 eax, esi
  002bc	80 3c 08 5f	 cmp	 BYTE PTR [eax+ecx], 95	; 0000005fH
  002c0	75 22		 jne	 SHORT $LN2@Show

; 869  : 							errorString[i] = ' ';

  002c2	83 fa 10	 cmp	 edx, 16			; 00000010H
  002c5	8d 85 d8 bf ff
	ff		 lea	 eax, DWORD PTR _errorString$[ebp]
  002cb	0f 43 c6	 cmovae	 eax, esi
  002ce	c6 04 08 20	 mov	 BYTE PTR [eax+ecx], 32	; 00000020H
  002d2	8b 95 ec bf ff
	ff		 mov	 edx, DWORD PTR _errorString$[ebp+20]
  002d8	8b bd e8 bf ff
	ff		 mov	 edi, DWORD PTR _errorString$[ebp+16]
  002de	8b b5 d8 bf ff
	ff		 mov	 esi, DWORD PTR _errorString$[ebp]
$LN2@Show:

; 866  : 					for (size_t i = 0; i < errorString.size(); ++i)

  002e4	41		 inc	 ecx
  002e5	3b cf		 cmp	 ecx, edi
  002e7	72 c7		 jb	 SHORT $LL4@Show
$LN3@Show:

; 870  : 					}
; 871  : 				}
; 872  : 				wchar_t err[8192];
; 873  : 				wsprintfW (err, L"%s:\n\n%hs%s", GetString ("SECURITY_TOKEN_ERROR"), errorString.c_str(), subjectErrorCode.str().c_str());

  002e9	8d 85 c0 bf ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  002ef	50		 push	 eax
  002f0	8d 8d c0 be ff
	ff		 lea	 ecx, DWORD PTR _subjectErrorCode$2[ebp]
  002f6	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
  002fb	8b c8		 mov	 ecx, eax
  002fd	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00301	72 02		 jb	 SHORT $LN668@Show
  00303	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN668@Show:
  00305	83 bd ec bf ff
	ff 10		 cmp	 DWORD PTR _errorString$[ebp+20], 16 ; 00000010H
  0030c	8d 85 d8 bf ff
	ff		 lea	 eax, DWORD PTR _errorString$[ebp]
  00312	51		 push	 ecx
  00313	0f 43 85 d8 bf
	ff ff		 cmovae	 eax, DWORD PTR _errorString$[ebp]
  0031a	50		 push	 eax
  0031b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@NKGFDJIN@SECURITY_TOKEN_ERROR?$AA@
  00320	e8 00 00 00 00	 call	 _GetString
  00325	83 c4 04	 add	 esp, 4
  00328	50		 push	 eax
  00329	8d 85 f0 bf ff
	ff		 lea	 eax, DWORD PTR _err$11[ebp]
  0032f	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@PNNJJJBG@?$AA?$CF?$AAs?$AA?3?$AA?6?$AA?6?$AA?$CF?$AAh?$AAs?$AA?$CF?$AAs?$AA?$AA@
  00334	50		 push	 eax
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfW
  0033b	8b 85 d4 bf ff
	ff		 mov	 eax, DWORD PTR $T8[ebp+20]
  00341	83 c4 14	 add	 esp, 20			; 00000014H
  00344	83 f8 08	 cmp	 eax, 8
  00347	72 13		 jb	 SHORT $LN694@Show
  00349	40		 inc	 eax
  0034a	8d 8d c0 bf ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00350	50		 push	 eax
  00351	ff b5 c0 bf ff
	ff		 push	 DWORD PTR $T8[ebp]
  00357	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN694@Show:

; 874  : 				ErrorDirect (err);

  0035c	8d 85 f0 bf ff
	ff		 lea	 eax, DWORD PTR _err$11[ebp]
  00362	50		 push	 eax
  00363	e8 00 00 00 00	 call	 _ErrorDirect
  00368	83 c4 04	 add	 esp, 4

; 875  : 			}
; 876  : 			else

  0036b	e9 c3 00 00 00	 jmp	 $LN835@Show
$LN7@Show:

; 877  : 			{
; 878  : 				wstring err = GetString (errorString.c_str());

  00370	83 bd ec bf ff
	ff 10		 cmp	 DWORD PTR _errorString$[ebp+20], 16 ; 00000010H
  00377	8d 85 d8 bf ff
	ff		 lea	 eax, DWORD PTR _errorString$[ebp]
  0037d	0f 43 85 d8 bf
	ff ff		 cmovae	 eax, DWORD PTR _errorString$[ebp]
  00384	50		 push	 eax
  00385	e8 00 00 00 00	 call	 _GetString
  0038a	83 c4 04	 add	 esp, 4
  0038d	8d 8d a8 bf ff
	ff		 lea	 ecx, DWORD PTR _err$7[ebp]
  00393	50		 push	 eax
  00394	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 879  : 
; 880  : 				if (SubjectErrorCodeValid)

  00399	80 7f 08 00	 cmp	 BYTE PTR [edi+8], 0
  0039d	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  003a1	74 55		 je	 SHORT $LN11@Show

; 881  : 					err += L"\n\nError code" + subjectErrorCode.str();

  003a3	8d 85 78 bf ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  003a9	50		 push	 eax
  003aa	8d 8d c0 be ff
	ff		 lea	 ecx, DWORD PTR _subjectErrorCode$2[ebp]
  003b0	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
  003b5	50		 push	 eax
  003b6	8d 85 90 bf ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  003bc	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  003c0	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@FLCMNAGD@?$AA?6?$AA?6?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAc?$AAo?$AAd?$AAe?$AA?$AA@
  003c5	50		 push	 eax
  003c6	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W$$QAV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  003cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  003ce	6a ff		 push	 -1
  003d0	6a 00		 push	 0
  003d2	50		 push	 eax
  003d3	8d 8d a8 bf ff
	ff		 lea	 ecx, DWORD PTR _err$7[ebp]
  003d9	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  003dd	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  003e2	8d 8d 90 bf ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  003e8	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  003ed	8d 8d 78 bf ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  003f3	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN11@Show:

; 882  : 
; 883  : 				ErrorDirect (err.c_str());

  003f8	83 bd bc bf ff
	ff 08		 cmp	 DWORD PTR _err$7[ebp+20], 8
  003ff	8d 85 a8 bf ff
	ff		 lea	 eax, DWORD PTR _err$7[ebp]
  00405	0f 43 85 a8 bf
	ff ff		 cmovae	 eax, DWORD PTR _err$7[ebp]
  0040c	50		 push	 eax
  0040d	e8 00 00 00 00	 call	 _ErrorDirect

; 884  : 			}

  00412	8b 85 bc bf ff
	ff		 mov	 eax, DWORD PTR _err$7[ebp+20]
  00418	83 c4 04	 add	 esp, 4
  0041b	83 f8 08	 cmp	 eax, 8
  0041e	72 13		 jb	 SHORT $LN835@Show
  00420	40		 inc	 eax
  00421	8d 8d a8 bf ff
	ff		 lea	 ecx, DWORD PTR _err$7[ebp]
  00427	50		 push	 eax
  00428	ff b5 a8 bf ff
	ff		 push	 DWORD PTR _err$7[ebp]
  0042e	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN835@Show:

; 885  : 		}

  00433	8d 8d 28 bf ff
	ff		 lea	 ecx, DWORD PTR _subjectErrorCode$2[ebp+104]
  00439	e8 00 00 00 00	 call	 ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0043e	8d 85 28 bf ff
	ff		 lea	 eax, DWORD PTR _subjectErrorCode$2[ebp+104]
  00444	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00448	50		 push	 eax
  00449	c7 85 28 bf ff
	ff 00 00 00 00	 mov	 DWORD PTR _subjectErrorCode$2[ebp+104], OFFSET ??_7ios_base@std@@6B@
  00453	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00458	83 c4 04	 add	 esp, 4
$LN939@Show:

; 886  : 	}

  0045b	8b 85 ec bf ff
	ff		 mov	 eax, DWORD PTR _errorString$[ebp+20]
  00461	83 f8 10	 cmp	 eax, 16			; 00000010H
  00464	72 45		 jb	 SHORT $LN1027@Show
  00466	8b 8d d8 bf ff
	ff		 mov	 ecx, DWORD PTR _errorString$[ebp]
  0046c	40		 inc	 eax
  0046d	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00472	72 2e		 jb	 SHORT $LN1022@Show
  00474	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00477	74 05		 je	 SHORT $LN1023@Show
  00479	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1065@Show:
$LN1023@Show:
  0047e	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00481	3b c1		 cmp	 eax, ecx
  00483	72 05		 jb	 SHORT $LN1024@Show
  00485	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1066@Show:
$LN1024@Show:
  0048a	2b c8		 sub	 ecx, eax
  0048c	83 f9 04	 cmp	 ecx, 4
  0048f	73 05		 jae	 SHORT $LN1025@Show
  00491	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1067@Show:
$LN1025@Show:
  00496	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00499	76 05		 jbe	 SHORT $LN1026@Show
  0049b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1068@Show:
$LN1026@Show:
  004a0	8b c8		 mov	 ecx, eax
$LN1022@Show:
  004a2	51		 push	 ecx
  004a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  004a8	83 c4 04	 add	 esp, 4
$LN1027@Show:
  004ab	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004ae	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004b5	59		 pop	 ecx
  004b6	5f		 pop	 edi
  004b7	5e		 pop	 esi
  004b8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004bb	33 cd		 xor	 ecx, ebp
  004bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004c2	8b e5		 mov	 esp, ebp
  004c4	5d		 pop	 ebp
  004c5	c2 04 00	 ret	 4
$LN1064@Show:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$1:
  00000	8d 8d d8 bf ff
	ff		 lea	 ecx, DWORD PTR _errorString$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$137:
  0000b	8b 85 74 bf ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  00011	83 e0 01	 and	 eax, 1
  00014	0f 84 12 00 00
	00		 je	 $LN498@Show
  0001a	83 a5 74 bf ff
	ff fe		 and	 DWORD PTR $T4[ebp], -2	; fffffffeH
  00021	8d 8d 28 bf ff
	ff		 lea	 ecx, DWORD PTR _subjectErrorCode$2[ebp+104]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN498@Show:
  0002c	c3		 ret	 0
__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$141:
  0002d	8d 8d d8 be ff
	ff		 lea	 ecx, DWORD PTR _subjectErrorCode$2[ebp+24]
  00033	e9 00 00 00 00	 jmp	 ??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >
__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$138:
  00038	8d 8d e0 be ff
	ff		 lea	 ecx, DWORD PTR _subjectErrorCode$2[ebp+32]
  0003e	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::~basic_iostream<wchar_t,std::char_traits<wchar_t> >
__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$145:
  00043	8b 8d 70 bf ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$2:
  0004e	8d 8d c0 be ff
	ff		 lea	 ecx, DWORD PTR _subjectErrorCode$2[ebp]
  00054	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$5:
  00059	8d 8d a8 bf ff
	ff		 lea	 ecx, DWORD PTR _err$7[ebp]
  0005f	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$6:
  00064	8d 8d 78 bf ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0006a	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$7:
  0006f	8d 8d 90 bf ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00075	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z$226:
  0007a	e8 00 00 00 00	 call	 ___std_terminate
  0007f	c3		 ret	 0
__ehhandler$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z:
  00080	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00084	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00087	8b 8a c0 be ff
	ff		 mov	 ecx, DWORD PTR [edx-16704]
  0008d	33 c8		 xor	 ecx, eax
  0008f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00094	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00097	33 c8		 xor	 ecx, eax
  00099	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z
  000a3	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Show@Pkcs11Exception@GostCrypt@@UBEXPAUHWND__@@@Z ENDP	; GostCrypt::Pkcs11Exception::Show
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.h
;	COMDAT ??0Pkcs11Exception@GostCrypt@@QAE@K@Z
_TEXT	SEGMENT
_errorCode$ = 8						; size = 4
??0Pkcs11Exception@GostCrypt@@QAE@K@Z PROC		; GostCrypt::Pkcs11Exception::Pkcs11Exception, COMDAT
; _this$ = ecx

; 89   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 			: ErrorCode (errorCode),

  00003	8b 45 08	 mov	 eax, DWORD PTR _errorCode$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 90   : 		}

  00009	8b c1		 mov	 eax, ecx
  0000b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Pkcs11Exception@GostCrypt@@6B@
  00011	c6 41 08 00	 mov	 BYTE PTR [ecx+8], 0
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??0Pkcs11Exception@GostCrypt@@QAE@K@Z ENDP		; GostCrypt::Pkcs11Exception::Pkcs11Exception
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GSecurityTokenKeyfile@GostCrypt@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GSecurityTokenKeyfile@GostCrypt@@QAEPAXI@Z PROC	; GostCrypt::SecurityTokenKeyfile::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1SecurityTokenKeyfile@GostCrypt@@QAE@XZ
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 70		 push	 112			; 00000070H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GSecurityTokenKeyfile@GostCrypt@@QAEPAXI@Z ENDP	; GostCrypt::SecurityTokenKeyfile::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4SecurityTokenKeyfile@GostCrypt@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4SecurityTokenKeyfile@GostCrypt@@QAEAAU01@ABU01@@Z PROC ; GostCrypt::SecurityTokenKeyfile::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 07		 mov	 eax, DWORD PTR [edi]
  0000c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000f	89 06		 mov	 DWORD PTR [esi], eax
  00011	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00014	3b c8		 cmp	 ecx, eax
  00016	74 0a		 je	 SHORT $LN4@operator
  00018	6a ff		 push	 -1
  0001a	6a 00		 push	 0
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN4@operator:
  00022	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
  00025	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  00028	3b c8		 cmp	 ecx, eax
  0002a	74 0a		 je	 SHORT $LN137@operator
  0002c	6a ff		 push	 -1
  0002e	6a 00		 push	 0
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN137@operator:
  00036	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  00039	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  0003c	89 46 34	 mov	 DWORD PTR [esi+52], eax
  0003f	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00042	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00045	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00048	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0004b	8d 47 40	 lea	 eax, DWORD PTR [edi+64]
  0004e	3b c8		 cmp	 ecx, eax
  00050	74 0a		 je	 SHORT $LN270@operator
  00052	6a ff		 push	 -1
  00054	6a 00		 push	 0
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN270@operator:
  0005c	83 c7 58	 add	 edi, 88			; 00000058H
  0005f	8d 4e 58	 lea	 ecx, DWORD PTR [esi+88]
  00062	3b cf		 cmp	 ecx, edi
  00064	74 0a		 je	 SHORT $LN533@operator
  00066	6a ff		 push	 -1
  00068	6a 00		 push	 0
  0006a	57		 push	 edi
  0006b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN533@operator:
  00070	5f		 pop	 edi
  00071	8b c6		 mov	 eax, esi
  00073	5e		 pop	 esi
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
??4SecurityTokenKeyfile@GostCrypt@@QAEAAU01@ABU01@@Z ENDP ; GostCrypt::SecurityTokenKeyfile::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SecurityTokenKeyfile@GostCrypt@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0SecurityTokenKeyfile@GostCrypt@@QAE@$$QAU01@@Z PROC	; GostCrypt::SecurityTokenKeyfile::SecurityTokenKeyfile, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0000f	8b 06		 mov	 eax, DWORD PTR [esi]
  00011	89 07		 mov	 DWORD PTR [edi], eax
  00013	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00016	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00024	50		 push	 eax
  00025	66 89 11	 mov	 WORD PTR [ecx], dx
  00028	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  0002d	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
  00030	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  00033	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0003a	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00041	50		 push	 eax
  00042	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00045	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0004a	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0004d	8d 4f 40	 lea	 ecx, DWORD PTR [edi+64]
  00050	89 47 34	 mov	 DWORD PTR [edi+52], eax
  00053	33 d2		 xor	 edx, edx
  00055	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00058	89 47 38	 mov	 DWORD PTR [edi+56], eax
  0005b	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0005e	89 47 3c	 mov	 DWORD PTR [edi+60], eax
  00061	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  00064	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  0006b	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00072	50		 push	 eax
  00073	66 89 11	 mov	 WORD PTR [ecx], dx
  00076	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  0007b	8d 4f 58	 lea	 ecx, DWORD PTR [edi+88]
  0007e	8d 46 58	 lea	 eax, DWORD PTR [esi+88]
  00081	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00088	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0008f	50		 push	 eax
  00090	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00093	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00098	8b c7		 mov	 eax, edi
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
??0SecurityTokenKeyfile@GostCrypt@@QAE@$$QAU01@@Z ENDP	; GostCrypt::SecurityTokenKeyfile::SecurityTokenKeyfile
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z PROC	; GostCrypt::SecurityTokenKeyfile::SecurityTokenKeyfile, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  0002e	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00031	8b 07		 mov	 eax, DWORD PTR [edi]
  00033	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00036	89 06		 mov	 DWORD PTR [esi], eax
  00038	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  0003f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00046	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  0004a	72 04		 jb	 SHORT $LN126@SecurityTo
  0004c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004e	eb 02		 jmp	 SHORT $LN127@SecurityTo
$LN126@SecurityTo:
  00050	8b c1		 mov	 eax, ecx
$LN127@SecurityTo:
  00052	6a ff		 push	 -1
  00054	33 db		 xor	 ebx, ebx
  00056	53		 push	 ebx
  00057	52		 push	 edx
  00058	66 89 18	 mov	 WORD PTR [eax], bx
  0005b	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00060	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  00063	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00066	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0006d	8d 57 1c	 lea	 edx, DWORD PTR [edi+28]
  00070	89 59 10	 mov	 DWORD PTR [ecx+16], ebx
  00073	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00077	72 04		 jb	 SHORT $LN251@SecurityTo
  00079	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007b	eb 02		 jmp	 SHORT $LN252@SecurityTo
$LN251@SecurityTo:
  0007d	8b c1		 mov	 eax, ecx
$LN252@SecurityTo:
  0007f	6a ff		 push	 -1
  00081	6a 00		 push	 0
  00083	52		 push	 edx
  00084	c6 00 00	 mov	 BYTE PTR [eax], 0
  00087	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0008c	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  0008f	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  00092	89 46 34	 mov	 DWORD PTR [esi+52], eax
  00095	8d 47 38	 lea	 eax, DWORD PTR [edi+56]
  00098	50		 push	 eax
  00099	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0009d	e8 00 00 00 00	 call	 ??0SecurityTokenInfo@GostCrypt@@QAE@ABU01@@Z
  000a2	8b c6		 mov	 eax, esi
  000a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ae	59		 pop	 ecx
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SecurityTokenKeyfile@GostCrypt@@QAE@ABU01@@Z ENDP	; GostCrypt::SecurityTokenKeyfile::SecurityTokenKeyfile
; Function compile flags: /Ogtp
;	COMDAT ??1SecurityTokenKeyfile@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??1SecurityTokenKeyfile@GostCrypt@@QAE@XZ PROC		; GostCrypt::SecurityTokenKeyfile::~SecurityTokenKeyfile, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
  00004	8d 4f 38	 lea	 ecx, DWORD PTR [edi+56]
  00007	e8 00 00 00 00	 call	 ??1SecurityTokenInfo@GostCrypt@@QAE@XZ
  0000c	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  0000f	8d 77 1c	 lea	 esi, DWORD PTR [edi+28]
  00012	83 f8 10	 cmp	 eax, 16			; 00000010H
  00015	72 0b		 jb	 SHORT $LN9@SecurityTo
  00017	40		 inc	 eax
  00018	8b ce		 mov	 ecx, esi
  0001a	50		 push	 eax
  0001b	ff 36		 push	 DWORD PTR [esi]
  0001d	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN9@SecurityTo:
  00022	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00029	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0002d	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00034	72 02		 jb	 SHORT $LN97@SecurityTo
  00036	8b 36		 mov	 esi, DWORD PTR [esi]
$LN97@SecurityTo:
  00038	c6 06 00	 mov	 BYTE PTR [esi], 0
  0003b	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0003e	83 f8 08	 cmp	 eax, 8
  00041	72 0d		 jb	 SHORT $LN110@SecurityTo
  00043	40		 inc	 eax
  00044	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00047	50		 push	 eax
  00048	ff 77 04	 push	 DWORD PTR [edi+4]
  0004b	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN110@SecurityTo:
  00050	c7 47 18 07 00
	00 00		 mov	 DWORD PTR [edi+24], 7
  00057	83 7f 18 08	 cmp	 DWORD PTR [edi+24], 8
  0005b	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
  00062	72 0b		 jb	 SHORT $LN200@SecurityTo
  00064	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00067	33 c9		 xor	 ecx, ecx
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	66 89 08	 mov	 WORD PTR [eax], cx
  0006e	c3		 ret	 0
$LN200@SecurityTo:
  0006f	33 c0		 xor	 eax, eax
  00071	66 89 47 04	 mov	 WORD PTR [edi+4], ax
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	c3		 ret	 0
??1SecurityTokenKeyfile@GostCrypt@@QAE@XZ ENDP		; GostCrypt::SecurityTokenKeyfile::~SecurityTokenKeyfile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ
_TEXT	SEGMENT
_path$ = -224						; size = 176
_this$2 = -48						; size = 4
_this$ = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ PROC ; GostCrypt::SecurityTokenKeyfile::operator GostCrypt::SecurityTokenKeyfilePath, COMDAT
; _this$ = ecx

; 71   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f1		 mov	 esi, ecx
  0002f	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00032	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 72   : 		wstringstream path;

  00039	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _path$[ebp], OFFSET ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
  00043	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _path$[ebp+16], OFFSET ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
  0004d	6a 00		 push	 0
  0004f	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR _path$[ebp+24]
  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005c	0f 57 c0	 xorps	 xmm0, xmm0
  0005f	c7 45 d4 02 00
	00 00		 mov	 DWORD PTR $T3[ebp], 2
  00066	50		 push	 eax
  00067	8d 4d 88	 lea	 ecx, DWORD PTR _path$[ebp+104]
  0006a	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _path$[ebp+104], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00071	c7 45 84 50 00
	00 00		 mov	 DWORD PTR _path$[ebp+100], 80 ; 00000050H
  00078	66 0f 13 85 28
	ff ff ff	 movlpd	 QWORD PTR _path$[ebp+8], xmm0
  00080	e8 00 00 00 00	 call	 ?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init
  00085	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _path$[ebp+16]
  0008b	89 45 d0	 mov	 DWORD PTR _this$2[ebp], eax
  0008e	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _path$[ebp+16]
  00094	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00097	c7 84 05 30 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _path$[ebp+eax+16], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  000a2	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _path$[ebp+16]
  000a8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ab	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  000ae	89 84 0d 2c ff
	ff ff		 mov	 DWORD PTR _path$[ebp+ecx+12], eax
  000b5	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _path$[ebp]
  000bb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000be	c7 84 05 20 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _path$[ebp+eax], OFFSET ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
  000c9	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _path$[ebp]
  000cf	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d2	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  000d5	89 84 0d 1c ff
	ff ff		 mov	 DWORD PTR _path$[ebp+ecx-4], eax
  000dc	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _path$[ebp]
  000e2	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  000e9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ec	c7 84 05 20 ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _path$[ebp+eax], OFFSET ??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  000f7	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _path$[ebp]
  000fd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00100	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00103	89 84 0d 1c ff
	ff ff		 mov	 DWORD PTR _path$[ebp+ecx-4], eax
  0010a	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR _path$[ebp+24]
  00110	8b c8		 mov	 ecx, eax
  00112	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
  00115	e8 00 00 00 00	 call	 ??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
  0011a	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _path$[ebp+24], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  00124	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _path$[ebp+80], 0
  0012e	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _path$[ebp+84], 0

; 73   : 		path << GST_SECURITY_TOKEN_KEYFILE_URL_PREFIX GST_SECURITY_TOKEN_KEYFILE_URL_SLOT L"/" << SlotId << L"/" GST_SECURITY_TOKEN_KEYFILE_URL_FILE L"/" << Id;

  00138	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0013b	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7
  00142	50		 push	 eax
  00143	68 00 00 00 00	 push	 OFFSET ??_C@_1O@HIAFDIDB@?$AA?1?$AAf?$AAi?$AAl?$AAe?$AA?1?$AA?$AA@
  00148	ff 76 34	 push	 DWORD PTR [esi+52]
  0014b	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _path$[ebp+16]
  00151	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@IPMKACB@?$AAt?$AAo?$AAk?$AAe?$AAn?$AA?3?$AA?1?$AA?1?$AAs?$AAl?$AAo?$AAt?$AA?1?$AA?$AA@
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  0015c	83 c4 08	 add	 esp, 8
  0015f	8b c8		 mov	 ecx, eax
  00161	e8 00 00 00 00	 call	 ??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@K@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::operator<<
  00166	50		 push	 eax
  00167	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  0016c	83 c4 08	 add	 esp, 8
  0016f	50		 push	 eax
  00170	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00175	83 c4 08	 add	 esp, 8

; 74   : 		return path.str();

  00178	8d 45 d8	 lea	 eax, DWORD PTR $T4[ebp]
  0017b	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
  00187	8b c8		 mov	 ecx, eax
  00189	c7 47 14 07 00
	00 00		 mov	 DWORD PTR [edi+20], 7
  00190	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00197	83 7f 14 08	 cmp	 DWORD PTR [edi+20], 8
  0019b	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0019f	72 04		 jb	 SHORT $LN225@SecurityTo
  001a1	8b 07		 mov	 eax, DWORD PTR [edi]
  001a3	eb 02		 jmp	 SHORT $LN226@SecurityTo
$LN225@SecurityTo:
  001a5	8b c7		 mov	 eax, edi
$LN226@SecurityTo:
  001a7	33 d2		 xor	 edx, edx
  001a9	6a ff		 push	 -1
  001ab	52		 push	 edx
  001ac	51		 push	 ecx
  001ad	8b cf		 mov	 ecx, edi
  001af	66 89 10	 mov	 WORD PTR [eax], dx
  001b2	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  001b7	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp+20]
  001ba	83 f8 08	 cmp	 eax, 8
  001bd	72 0d		 jb	 SHORT $LN238@SecurityTo
  001bf	40		 inc	 eax
  001c0	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  001c3	50		 push	 eax
  001c4	ff 75 d8	 push	 DWORD PTR $T4[ebp]
  001c7	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN238@SecurityTo:
  001cc	33 c0		 xor	 eax, eax
  001ce	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 7
  001d5	8d 4d 88	 lea	 ecx, DWORD PTR _path$[ebp+104]
  001d8	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+16], 0
  001df	66 89 45 d8	 mov	 WORD PTR $T4[ebp], ax
  001e3	e8 00 00 00 00	 call	 ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  001e8	8d 45 88	 lea	 eax, DWORD PTR _path$[ebp+104]
  001eb	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 9
  001f2	50		 push	 eax
  001f3	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _path$[ebp+104], OFFSET ??_7ios_base@std@@6B@
  001fa	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  001ff	83 c4 04	 add	 esp, 4
  00202	8b c7		 mov	 eax, edi

; 75   : 	}

  00204	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00207	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0020e	59		 pop	 ecx
  0020f	5f		 pop	 edi
  00210	5e		 pop	 esi
  00211	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00214	33 cd		 xor	 ecx, ebp
  00216	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021b	8b e5		 mov	 esp, ebp
  0021d	5d		 pop	 ebp
  0021e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ$3:
  00000	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00003	83 e0 02	 and	 eax, 2
  00006	0f 84 0c 00 00
	00		 je	 $LN13@SecurityTo
  0000c	83 65 d4 fd	 and	 DWORD PTR $T3[ebp], -3	; fffffffdH
  00010	8d 4d 88	 lea	 ecx, DWORD PTR _path$[ebp+104]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN13@SecurityTo:
  00018	c3		 ret	 0
__unwindfunclet$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ$7:
  00019	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp+24]
  0001f	e9 00 00 00 00	 jmp	 ??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >
__unwindfunclet$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ$4:
  00024	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp+32]
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::~basic_iostream<wchar_t,std::char_traits<wchar_t> >
__unwindfunclet$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ$11:
  0002f	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
__unwindfunclet$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ$0:
  00037	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
__unwindfunclet$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ$1:
  00042	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00045	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ$74:
  0004a	e8 00 00 00 00	 call	 ___std_terminate
  0004f	c3		 ret	 0
__ehhandler$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ:
  00050	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00054	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00057	8b 8a 20 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-224]
  0005d	33 c8		 xor	 ecx, eax
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00067	33 c8		 xor	 ecx, eax
  00069	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ
  00073	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??BSecurityTokenKeyfile@GostCrypt@@QBE?AUSecurityTokenKeyfilePath@1@XZ ENDP ; GostCrypt::SecurityTokenKeyfile::operator GostCrypt::SecurityTokenKeyfilePath
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.cpp
;	COMDAT ??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z
_TEXT	SEGMENT
_this$GSCopy$ = -112					; size = 4
_keyfiles$ = -108					; size = 12
_slotId$ = -96						; size = 4
_this$ = -96						; size = 4
_keyIdPos$1$ = -92					; size = 4
$T2 = -92						; size = 4
$T3 = -92						; size = 4
$T4 = -88						; size = 24
_pathStr$ = -64						; size = 24
$T5 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_path$ = 8						; size = 4
??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z PROC ; GostCrypt::SecurityTokenKeyfile::SecurityTokenKeyfile, COMDAT
; _this$ = ecx

; 47   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 64	 sub	 esp, 100		; 00000064H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 a0	 mov	 DWORD PTR _this$[ebp], esi
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00033	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  00036	c7 47 14 07 00
	00 00		 mov	 DWORD PTR [edi+20], 7
  0003d	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00044	83 7f 14 08	 cmp	 DWORD PTR [edi+20], 8
  00048	89 75 90	 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  0004b	72 04		 jb	 SHORT $LN116@SecurityTo
  0004d	8b 07		 mov	 eax, DWORD PTR [edi]
  0004f	eb 02		 jmp	 SHORT $LN117@SecurityTo
$LN116@SecurityTo:
  00051	8b c7		 mov	 eax, edi
$LN117@SecurityTo:
  00053	33 d2		 xor	 edx, edx
  00055	66 89 10	 mov	 WORD PTR [eax], dx
  00058	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  0005b	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx
  0005e	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
  00065	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00068	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0006c	72 02		 jb	 SHORT $LN224@SecurityTo
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
$LN224@SecurityTo:
  00070	c6 00 00	 mov	 BYTE PTR [eax], 0
  00073	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  00076	c7 40 14 07 00
	00 00		 mov	 DWORD PTR [eax+20], 7
  0007d	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  00084	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00088	72 02		 jb	 SHORT $LN336@SecurityTo
  0008a	8b 00		 mov	 eax, DWORD PTR [eax]
$LN336@SecurityTo:
  0008c	33 d2		 xor	 edx, edx
  0008e	66 89 10	 mov	 WORD PTR [eax], dx
  00091	8d 46 58	 lea	 eax, DWORD PTR [esi+88]
  00094	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
  0009b	89 50 10	 mov	 DWORD PTR [eax+16], edx
  0009e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  000a2	72 02		 jb	 SHORT $LN443@SecurityTo
  000a4	8b 00		 mov	 eax, DWORD PTR [eax]
$LN443@SecurityTo:
  000a6	88 10		 mov	 BYTE PTR [eax], dl

; 48   : 		wstring pathStr = path;

  000a8	8d 45 c0	 lea	 eax, DWORD PTR _pathStr$[ebp]
  000ab	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ??BSecurityTokenKeyfilePath@GostCrypt@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; GostCrypt::SecurityTokenKeyfilePath::operator std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 49   : 		unsigned long slotId;
; 50   : 
; 51   : 		if (swscanf (pathStr.c_str(), GST_SECURITY_TOKEN_KEYFILE_URL_PREFIX GST_SECURITY_TOKEN_KEYFILE_URL_SLOT L"/%lu", &slotId) != 1)

  000b5	83 7d d4 08	 cmp	 DWORD PTR _pathStr$[ebp+20], 8
  000b9	8d 4d a0	 lea	 ecx, DWORD PTR _slotId$[ebp]
  000bc	51		 push	 ecx
  000bd	8d 45 c0	 lea	 eax, DWORD PTR _pathStr$[ebp]
  000c0	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000c4	0f 43 45 c0	 cmovae	 eax, DWORD PTR _pathStr$[ebp]
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@OMDFECBP@?$AAt?$AAo?$AAk?$AAe?$AAn?$AA?3?$AA?1?$AA?1?$AAs?$AAl?$AAo?$AAt?$AA?1?$AA?$CF?$AAl?$AAu?$AA?$AA@
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 _swscanf
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d6	83 f8 01	 cmp	 eax, 1
  000d9	74 15		 je	 SHORT $LN2@SecurityTo
$LN891@SecurityTo:

; 52   : 			throw InvalidSecurityTokenKeyfilePath();

  000db	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7InvalidSecurityTokenKeyfilePath@GostCrypt@@6B@
  000e2	68 00 00 00 00	 push	 OFFSET __TI2?AUInvalidSecurityTokenKeyfilePath@GostCrypt@@
$LN892@SecurityTo:
  000e7	8d 45 a4	 lea	 eax, DWORD PTR $T3[ebp]
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN893@SecurityTo:
$LN2@SecurityTo:

; 53   : 
; 54   : 		SlotId = slotId;

  000f0	8b 45 a0	 mov	 eax, DWORD PTR _slotId$[ebp]
  000f3	8d 5e 34	 lea	 ebx, DWORD PTR [esi+52]

; 55   : 
; 56   : 		size_t keyIdPos = pathStr.find (L"/" GST_SECURITY_TOKEN_KEYFILE_URL_FILE L"/");

  000f6	6a 06		 push	 6
  000f8	6a 00		 push	 0
  000fa	68 00 00 00 00	 push	 OFFSET ??_C@_1O@HIAFDIDB@?$AA?1?$AAf?$AAi?$AAl?$AAe?$AA?1?$AA?$AA@
  000ff	8d 4d c0	 lea	 ecx, DWORD PTR _pathStr$[ebp]
  00102	89 03		 mov	 DWORD PTR [ebx], eax
  00104	e8 00 00 00 00	 call	 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
  00109	89 45 a4	 mov	 DWORD PTR _keyIdPos$1$[ebp], eax

; 57   : 		if (keyIdPos == string::npos)

  0010c	83 f8 ff	 cmp	 eax, -1
  0010f	74 ca		 je	 SHORT $LN891@SecurityTo

; 58   : 			throw InvalidSecurityTokenKeyfilePath();
; 59   : 
; 60   : 		Id = pathStr.substr (keyIdPos + wstring (L"/" GST_SECURITY_TOKEN_KEYFILE_URL_FILE L"/").size());

  00111	68 00 00 00 00	 push	 OFFSET ??_C@_1O@HIAFDIDB@?$AA?1?$AAf?$AAi?$AAl?$AAe?$AA?1?$AA?$AA@
  00116	8d 4d a8	 lea	 ecx, DWORD PTR $T4[ebp]
  00119	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0011e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00121	8d 4d c0	 lea	 ecx, DWORD PTR _pathStr$[ebp]
  00124	03 45 a4	 add	 eax, DWORD PTR _keyIdPos$1$[ebp]
  00127	6a ff		 push	 -1
  00129	50		 push	 eax
  0012a	8d 45 d8	 lea	 eax, DWORD PTR $T5[ebp]
  0012d	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
  00137	50		 push	 eax
  00138	8b cf		 mov	 ecx, edi
  0013a	e8 00 00 00 00	 call	 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
  0013f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp+20]
  00142	83 f8 08	 cmp	 eax, 8
  00145	72 0d		 jb	 SHORT $LN502@SecurityTo
  00147	40		 inc	 eax
  00148	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  0014b	50		 push	 eax
  0014c	ff 75 d8	 push	 DWORD PTR $T5[ebp]
  0014f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN502@SecurityTo:
  00154	33 c0		 xor	 eax, eax
  00156	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR $T5[ebp+20], 7
  0015d	66 89 45 d8	 mov	 WORD PTR $T5[ebp], ax
  00161	8b 45 bc	 mov	 eax, DWORD PTR $T4[ebp+20]
  00164	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+16], 0
  0016b	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0016f	83 f8 08	 cmp	 eax, 8
  00172	72 0d		 jb	 SHORT $LN605@SecurityTo
  00174	40		 inc	 eax
  00175	8d 4d a8	 lea	 ecx, DWORD PTR $T4[ebp]
  00178	50		 push	 eax
  00179	ff 75 a8	 push	 DWORD PTR $T4[ebp]
  0017c	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN605@SecurityTo:

; 61   : 
; 62   : 		vector <SecurityTokenKeyfile> keyfiles = SecurityToken::GetAvailableKeyfiles (&SlotId, Id);

  00181	83 ec 18	 sub	 esp, 24			; 00000018H
  00184	8b cc		 mov	 ecx, esp
  00186	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  0018d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00194	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00198	72 04		 jb	 SHORT $LN822@SecurityTo
  0019a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0019c	eb 02		 jmp	 SHORT $LN823@SecurityTo
$LN822@SecurityTo:
  0019e	8b c1		 mov	 eax, ecx
$LN823@SecurityTo:
  001a0	33 d2		 xor	 edx, edx
  001a2	6a ff		 push	 -1
  001a4	52		 push	 edx
  001a5	57		 push	 edi
  001a6	66 89 10	 mov	 WORD PTR [eax], dx
  001a9	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  001ae	8d 45 94	 lea	 eax, DWORD PTR _keyfiles$[ebp]
  001b1	53		 push	 ebx
  001b2	50		 push	 eax
  001b3	e8 00 00 00 00	 call	 ?GetAvailableKeyfiles@SecurityToken@GostCrypt@@SA?AV?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@PAKV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@4@@Z ; GostCrypt::SecurityToken::GetAvailableKeyfiles
  001b8	83 c4 20	 add	 esp, 32			; 00000020H

; 63   : 
; 64   : 		if (keyfiles.empty())

  001bb	8b 45 94	 mov	 eax, DWORD PTR _keyfiles$[ebp]
  001be	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  001c2	3b 45 98	 cmp	 eax, DWORD PTR _keyfiles$[ebp+4]
  001c5	75 11		 jne	 SHORT $LN4@SecurityTo

; 65   : 			throw SecurityTokenKeyfileNotFound();

  001c7	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SecurityTokenKeyfileNotFound@GostCrypt@@6B@
  001ce	68 00 00 00 00	 push	 OFFSET __TI2?AUSecurityTokenKeyfileNotFound@GostCrypt@@
  001d3	e9 0f ff ff ff	 jmp	 $LN892@SecurityTo
$LN4@SecurityTo:

; 66   : 
; 67   : 		*this = keyfiles.front();

  001d8	50		 push	 eax
  001d9	8b ce		 mov	 ecx, esi
  001db	e8 00 00 00 00	 call	 ??4SecurityTokenKeyfile@GostCrypt@@QAEAAU01@ABU01@@Z

; 68   : 	}

  001e0	8d 4d 94	 lea	 ecx, DWORD PTR _keyfiles$[ebp]
  001e3	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::_Tidy
  001e8	8d 4d c0	 lea	 ecx, DWORD PTR _pathStr$[ebp]
  001eb	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  001f0	8b c6		 mov	 eax, esi
  001f2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001f5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001fc	59		 pop	 ecx
  001fd	5f		 pop	 edi
  001fe	5e		 pop	 esi
  001ff	5b		 pop	 ebx
  00200	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00203	33 cd		 xor	 ecx, ebp
  00205	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020a	8b e5		 mov	 esp, ebp
  0020c	5d		 pop	 ebp
  0020d	c2 04 00	 ret	 4
$LN890@SecurityTo:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z$0:
  00000	8b 4d 90	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z$1:
  0000b	8b 4d 90	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0000e	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z$2:
  00016	8b 4d 90	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00019	83 c1 38	 add	 ecx, 56			; 00000038H
  0001c	e9 00 00 00 00	 jmp	 ??1SecurityTokenInfo@GostCrypt@@QAE@XZ
__unwindfunclet$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z$3:
  00021	8d 4d c0	 lea	 ecx, DWORD PTR _pathStr$[ebp]
  00024	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z$4:
  00029	8d 4d a8	 lea	 ecx, DWORD PTR $T4[ebp]
  0002c	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z$7:
  00031	8d 4d 94	 lea	 ecx, DWORD PTR _keyfiles$[ebp]
  00034	e9 00 00 00 00	 jmp	 ??1?$vector@USecurityTokenKeyfile@GostCrypt@@V?$allocator@USecurityTokenKeyfile@GostCrypt@@@std@@@std@@QAE@XZ ; std::vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >::~vector<GostCrypt::SecurityTokenKeyfile,std::allocator<GostCrypt::SecurityTokenKeyfile> >
__ehhandler$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z:
  00039	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00040	8b 4a 8c	 mov	 ecx, DWORD PTR [edx-116]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0004d	33 c8		 xor	 ecx, eax
  0004f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00054	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z
  00059	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SecurityTokenKeyfile@GostCrypt@@QAE@ABUSecurityTokenKeyfilePath@1@@Z ENDP ; GostCrypt::SecurityTokenKeyfile::SecurityTokenKeyfile
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.h
;	COMDAT ??0SecurityTokenKeyfile@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0SecurityTokenKeyfile@GostCrypt@@QAE@XZ PROC		; GostCrypt::SecurityTokenKeyfile::SecurityTokenKeyfile, COMDAT
; _this$ = ecx

; 72   : 		SecurityTokenKeyfile () { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 41 18 07 00
	00 00		 mov	 DWORD PTR [ecx+24], 7
  0000b	33 c0		 xor	 eax, eax
  0000d	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00014	66 89 41 04	 mov	 WORD PTR [ecx+4], ax
  00018	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
  0001b	c7 41 30 0f 00
	00 00		 mov	 DWORD PTR [ecx+48], 15	; 0000000fH
  00022	88 41 1c	 mov	 BYTE PTR [ecx+28], al
  00025	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00028	c7 41 54 07 00
	00 00		 mov	 DWORD PTR [ecx+84], 7
  0002f	66 89 41 40	 mov	 WORD PTR [ecx+64], ax
  00033	89 41 68	 mov	 DWORD PTR [ecx+104], eax
  00036	c7 41 6c 0f 00
	00 00		 mov	 DWORD PTR [ecx+108], 15	; 0000000fH
  0003d	88 41 58	 mov	 BYTE PTR [ecx+88], al
  00040	8b c1		 mov	 eax, ecx
  00042	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??0SecurityTokenKeyfile@GostCrypt@@QAE@XZ ENDP		; GostCrypt::SecurityTokenKeyfile::SecurityTokenKeyfile
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1SecurityTokenKeyfilePath@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??1SecurityTokenKeyfilePath@GostCrypt@@QAE@XZ PROC	; GostCrypt::SecurityTokenKeyfilePath::~SecurityTokenKeyfilePath, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 08	 cmp	 eax, 8
  00009	72 09		 jb	 SHORT $LN9@SecurityTo
  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN9@SecurityTo:
  00014	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0001b	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	72 09		 jb	 SHORT $LN99@SecurityTo
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	33 c9		 xor	 ecx, ecx
  0002c	5e		 pop	 esi
  0002d	66 89 08	 mov	 WORD PTR [eax], cx
  00030	c3		 ret	 0
$LN99@SecurityTo:
  00031	33 c0		 xor	 eax, eax
  00033	66 89 06	 mov	 WORD PTR [esi], ax
  00036	5e		 pop	 esi
  00037	c3		 ret	 0
??1SecurityTokenKeyfilePath@GostCrypt@@QAE@XZ ENDP	; GostCrypt::SecurityTokenKeyfilePath::~SecurityTokenKeyfilePath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.h
;	COMDAT ??BSecurityTokenKeyfilePath@GostCrypt@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??BSecurityTokenKeyfilePath@GostCrypt@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ PROC ; GostCrypt::SecurityTokenKeyfilePath::operator std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 66   : 		operator wstring () const { return Path; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00008	33 c0		 xor	 eax, eax
  0000a	6a ff		 push	 -1
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00015	8b ce		 mov	 ecx, esi
  00017	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00025	66 89 06	 mov	 WORD PTR [esi], ax
  00028	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0002d	8b c6		 mov	 eax, esi
  0002f	5e		 pop	 esi
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??BSecurityTokenKeyfilePath@GostCrypt@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ENDP ; GostCrypt::SecurityTokenKeyfilePath::operator std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\securitytoken.h
;	COMDAT ??0SecurityTokenKeyfilePath@GostCrypt@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_path$ = 8						; size = 4
??0SecurityTokenKeyfilePath@GostCrypt@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; GostCrypt::SecurityTokenKeyfilePath::SecurityTokenKeyfilePath, COMDAT
; _this$ = ecx

; 65   : 		SecurityTokenKeyfilePath (const wstring &path) : Path (path) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c0		 xor	 eax, eax
  00009	6a ff		 push	 -1
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _path$[ebp]
  0000f	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00016	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001d	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00020	66 89 06	 mov	 WORD PTR [esi], ax
  00023	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00028	8b c6		 mov	 eax, esi
  0002a	5e		 pop	 esi
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??0SecurityTokenKeyfilePath@GostCrypt@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; GostCrypt::SecurityTokenKeyfilePath::SecurityTokenKeyfilePath
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GSecurityTokenInfo@GostCrypt@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GSecurityTokenInfo@GostCrypt@@QAEPAXI@Z PROC		; GostCrypt::SecurityTokenInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1SecurityTokenInfo@GostCrypt@@QAE@XZ
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 38		 push	 56			; 00000038H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GSecurityTokenInfo@GostCrypt@@QAEPAXI@Z ENDP		; GostCrypt::SecurityTokenInfo::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4SecurityTokenInfo@GostCrypt@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??4SecurityTokenInfo@GostCrypt@@QAEAAU01@$$QAU01@@Z PROC ; GostCrypt::SecurityTokenInfo::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4SecurityTokenInfo@GostCrypt@@QAEAAU01@$$QAU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___that$[ebp]
  0002a	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  0002d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0002f	8d 4b 08	 lea	 ecx, DWORD PTR [ebx+8]
  00032	89 07		 mov	 DWORD PTR [edi], eax
  00034	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00037	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0003a	3b f1		 cmp	 esi, ecx
  0003c	74 3d		 je	 SHORT $LN7@operator
  0003e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00041	83 f8 08	 cmp	 eax, 8
  00044	72 0e		 jb	 SHORT $LN13@operator
  00046	40		 inc	 eax
  00047	8b ce		 mov	 ecx, esi
  00049	50		 push	 eax
  0004a	ff 36		 push	 DWORD PTR [esi]
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
  00051	8d 4b 08	 lea	 ecx, DWORD PTR [ebx+8]
$LN13@operator:
  00054	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0005b	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0005f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00066	72 04		 jb	 SHORT $LN103@operator
  00068	8b 06		 mov	 eax, DWORD PTR [esi]
  0006a	eb 02		 jmp	 SHORT $LN104@operator
$LN103@operator:
  0006c	8b c6		 mov	 eax, esi
$LN104@operator:
  0006e	33 d2		 xor	 edx, edx
  00070	51		 push	 ecx
  00071	8b ce		 mov	 ecx, esi
  00073	66 89 10	 mov	 WORD PTR [eax], dx
  00076	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN7@operator:
  0007b	83 c3 20	 add	 ebx, 32			; 00000020H
  0007e	8d 77 20	 lea	 esi, DWORD PTR [edi+32]
  00081	3b f3		 cmp	 esi, ebx
  00083	74 38		 je	 SHORT $LN593@operator
  00085	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00088	83 f8 10	 cmp	 eax, 16			; 00000010H
  0008b	72 0b		 jb	 SHORT $LN309@operator
  0008d	40		 inc	 eax
  0008e	8b ce		 mov	 ecx, esi
  00090	50		 push	 eax
  00091	ff 36		 push	 DWORD PTR [esi]
  00093	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN309@operator:
  00098	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0009f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000a3	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000aa	72 04		 jb	 SHORT $LN397@operator
  000ac	8b 06		 mov	 eax, DWORD PTR [esi]
  000ae	eb 02		 jmp	 SHORT $LN398@operator
$LN397@operator:
  000b0	8b c6		 mov	 eax, esi
$LN398@operator:
  000b2	53		 push	 ebx
  000b3	8b ce		 mov	 ecx, esi
  000b5	c6 00 00	 mov	 BYTE PTR [eax], 0
  000b8	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN593@operator:
  000bd	8b c7		 mov	 eax, edi
  000bf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c9	59		 pop	 ecx
  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4SecurityTokenInfo@GostCrypt@@QAEAAU01@$$QAU01@@Z$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__unwindfunclet$??4SecurityTokenInfo@GostCrypt@@QAEAAU01@$$QAU01@@Z$68:
  00006	e8 00 00 00 00	 call	 ___std_terminate
  0000b	c3		 ret	 0
__ehhandler$??4SecurityTokenInfo@GostCrypt@@QAEAAU01@$$QAU01@@Z:
  0000c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00010	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00013	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00016	33 c8		 xor	 ecx, eax
  00018	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4SecurityTokenInfo@GostCrypt@@QAEAAU01@$$QAU01@@Z
  00022	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4SecurityTokenInfo@GostCrypt@@QAEAAU01@$$QAU01@@Z ENDP ; GostCrypt::SecurityTokenInfo::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4SecurityTokenInfo@GostCrypt@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4SecurityTokenInfo@GostCrypt@@QAEAAU01@ABU01@@Z PROC	; GostCrypt::SecurityTokenInfo::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 07		 mov	 eax, DWORD PTR [edi]
  0000c	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0000f	89 06		 mov	 DWORD PTR [esi], eax
  00011	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00014	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00017	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  0001a	3b c8		 cmp	 ecx, eax
  0001c	74 0a		 je	 SHORT $LN4@operator
  0001e	6a ff		 push	 -1
  00020	6a 00		 push	 0
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN4@operator:
  00028	83 c7 20	 add	 edi, 32			; 00000020H
  0002b	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  0002e	3b cf		 cmp	 ecx, edi
  00030	74 0a		 je	 SHORT $LN267@operator
  00032	6a ff		 push	 -1
  00034	6a 00		 push	 0
  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN267@operator:
  0003c	5f		 pop	 edi
  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??4SecurityTokenInfo@GostCrypt@@QAEAAU01@ABU01@@Z ENDP	; GostCrypt::SecurityTokenInfo::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SecurityTokenInfo@GostCrypt@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0SecurityTokenInfo@GostCrypt@@QAE@$$QAU01@@Z PROC	; GostCrypt::SecurityTokenInfo::SecurityTokenInfo, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0000f	8b 06		 mov	 eax, DWORD PTR [esi]
  00011	89 07		 mov	 DWORD PTR [edi], eax
  00013	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00016	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00019	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0001c	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  00023	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0002a	50		 push	 eax
  0002b	66 89 11	 mov	 WORD PTR [ecx], dx
  0002e	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  00033	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  00036	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  00039	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00040	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00047	50		 push	 eax
  00048	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0004b	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00050	8b c7		 mov	 eax, edi
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??0SecurityTokenInfo@GostCrypt@@QAE@$$QAU01@@Z ENDP	; GostCrypt::SecurityTokenInfo::SecurityTokenInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SecurityTokenInfo@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0SecurityTokenInfo@GostCrypt@@QAE@ABU01@@Z PROC	; GostCrypt::SecurityTokenInfo::SecurityTokenInfo, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SecurityTokenInfo@GostCrypt@@QAE@ABU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  0002e	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00031	8b 07		 mov	 eax, DWORD PTR [edi]
  00033	8d 57 08	 lea	 edx, DWORD PTR [edi+8]
  00036	89 06		 mov	 DWORD PTR [esi], eax
  00038	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0003b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0003e	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  00045	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0004c	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00050	72 04		 jb	 SHORT $LN125@SecurityTo
  00052	8b 01		 mov	 eax, DWORD PTR [ecx]
  00054	eb 02		 jmp	 SHORT $LN126@SecurityTo
$LN125@SecurityTo:
  00056	8b c1		 mov	 eax, ecx
$LN126@SecurityTo:
  00058	6a ff		 push	 -1
  0005a	33 db		 xor	 ebx, ebx
  0005c	53		 push	 ebx
  0005d	52		 push	 edx
  0005e	66 89 18	 mov	 WORD PTR [eax], bx
  00061	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00066	6a ff		 push	 -1
  00068	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  0006b	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0006e	8d 47 20	 lea	 eax, DWORD PTR [edi+32]
  00071	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00078	53		 push	 ebx
  00079	89 59 10	 mov	 DWORD PTR [ecx+16], ebx
  0007c	50		 push	 eax
  0007d	88 19		 mov	 BYTE PTR [ecx], bl
  0007f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00084	8b c6		 mov	 eax, esi
  00086	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00089	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00090	59		 pop	 ecx
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SecurityTokenInfo@GostCrypt@@QAE@ABU01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 08	 add	 ecx, 8
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$??0SecurityTokenInfo@GostCrypt@@QAE@ABU01@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SecurityTokenInfo@GostCrypt@@QAE@ABU01@@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SecurityTokenInfo@GostCrypt@@QAE@ABU01@@Z ENDP	; GostCrypt::SecurityTokenInfo::SecurityTokenInfo
; Function compile flags: /Ogtp
;	COMDAT ??1SecurityTokenInfo@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??1SecurityTokenInfo@GostCrypt@@QAE@XZ PROC		; GostCrypt::SecurityTokenInfo::~SecurityTokenInfo, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
  00004	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  00007	8d 77 20	 lea	 esi, DWORD PTR [edi+32]
  0000a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0000d	72 0b		 jb	 SHORT $LN9@SecurityTo
  0000f	40		 inc	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	50		 push	 eax
  00013	ff 36		 push	 DWORD PTR [esi]
  00015	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN9@SecurityTo:
  0001a	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00021	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00025	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002c	72 02		 jb	 SHORT $LN97@SecurityTo
  0002e	8b 36		 mov	 esi, DWORD PTR [esi]
$LN97@SecurityTo:
  00030	c6 06 00	 mov	 BYTE PTR [esi], 0
  00033	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00036	83 f8 08	 cmp	 eax, 8
  00039	72 0d		 jb	 SHORT $LN110@SecurityTo
  0003b	40		 inc	 eax
  0003c	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0003f	50		 push	 eax
  00040	ff 77 08	 push	 DWORD PTR [edi+8]
  00043	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN110@SecurityTo:
  00048	c7 47 1c 07 00
	00 00		 mov	 DWORD PTR [edi+28], 7
  0004f	83 7f 1c 08	 cmp	 DWORD PTR [edi+28], 8
  00053	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
  0005a	72 0b		 jb	 SHORT $LN200@SecurityTo
  0005c	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0005f	33 c9		 xor	 ecx, ecx
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	66 89 08	 mov	 WORD PTR [eax], cx
  00066	c3		 ret	 0
$LN200@SecurityTo:
  00067	33 c0		 xor	 eax, eax
  00069	66 89 47 08	 mov	 WORD PTR [edi+8], ax
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	c3		 ret	 0
??1SecurityTokenInfo@GostCrypt@@QAE@XZ ENDP		; GostCrypt::SecurityTokenInfo::~SecurityTokenInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SecurityTokenInfo@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??0SecurityTokenInfo@GostCrypt@@QAE@XZ PROC		; GostCrypt::SecurityTokenInfo::SecurityTokenInfo, COMDAT
; _this$ = ecx
  00000	33 c0		 xor	 eax, eax
  00002	c7 41 1c 07 00
	00 00		 mov	 DWORD PTR [ecx+28], 7
  00009	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00010	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
  00014	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  00017	c7 41 34 0f 00
	00 00		 mov	 DWORD PTR [ecx+52], 15	; 0000000fH
  0001e	88 41 20	 mov	 BYTE PTR [ecx+32], al
  00021	8b c1		 mov	 eax, ecx
  00023	c3		 ret	 0
??0SecurityTokenInfo@GostCrypt@@QAE@XZ ENDP		; GostCrypt::SecurityTokenInfo::SecurityTokenInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2439 : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2440 : 	return (_STD move(_Left.append(_Right)));

  00004	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000f	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00012	75 04		 jne	 SHORT $LN9@operator
  00014	33 c0		 xor	 eax, eax
  00016	eb 11		 jmp	 SHORT $LN10@operator
$LN9@operator:
  00018	8b c2		 mov	 eax, edx
  0001a	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0001d	0f 1f 00	 npad	 3
$LL139@operator:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL139@operator
  00027	2b c6		 sub	 eax, esi
$LN10@operator:
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  0002c	50		 push	 eax
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00033	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00036	8b ce		 mov	 ecx, esi
  00038	50		 push	 eax
  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00040	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00047	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004a	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0004f	8b c6		 mov	 eax, esi
  00051	5e		 pop	 esi

; 2441 : 	}

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2417 : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2418 : 	return (_STD move(_Right.insert(0, _Left)));

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Left$[ebp]
  00007	56		 push	 esi
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000f	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00012	75 04		 jne	 SHORT $LN9@operator
  00014	33 c0		 xor	 eax, eax
  00016	eb 11		 jmp	 SHORT $LN10@operator
$LN9@operator:
  00018	8b c2		 mov	 eax, edx
  0001a	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0001d	0f 1f 00	 npad	 3
$LL139@operator:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL139@operator
  00027	2b c6		 sub	 eax, esi
$LN10@operator:
  00029	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002c	50		 push	 eax
  0002d	52		 push	 edx
  0002e	6a 00		 push	 0
  00030	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00035	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00038	8b ce		 mov	 ecx, esi
  0003a	50		 push	 eax
  0003b	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00042	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00049	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004c	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00051	8b c6		 mov	 eax, esi
  00053	5e		 pop	 esi

; 2419 : 	}

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z PROC	; GostCrypt::ParameterIncorrect::ParameterIncorrect, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z ENDP	; GostCrypt::ParameterIncorrect::ParameterIncorrect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z
_TEXT	SEGMENT
_msgBody$ = -88						; size = 24
$T2 = -64						; size = 24
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_parent$ = 8						; size = 4
?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z PROC ; GostCrypt::ParameterIncorrect::Show, COMDAT
; _this$ = ecx

; 57   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 58   : 			string msgBody = "Parameter incorrect.\n\n\n(If you report a bug in connection with this, please include the following technical information in the bug report:\n" + string (SrcPos) + ")";

  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	8b 7d 08	 mov	 edi, DWORD PTR _parent$[ebp]
  00030	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
  00037	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0
  0003e	c6 45 d8 00	 mov	 BYTE PTR $T3[ebp], 0
  00042	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00045	75 04		 jne	 SHORT $LN116@Show
  00047	33 c9		 xor	 ecx, ecx
  00049	eb 0e		 jmp	 SHORT $LN117@Show
$LN116@Show:
  0004b	8b ca		 mov	 ecx, edx
  0004d	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL438@Show:
  00050	8a 01		 mov	 al, BYTE PTR [ecx]
  00052	41		 inc	 ecx
  00053	84 c0		 test	 al, al
  00055	75 f9		 jne	 SHORT $LL438@Show
  00057	2b ce		 sub	 ecx, esi
$LN117@Show:
  00059	51		 push	 ecx
  0005a	52		 push	 edx
  0005b	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  0005e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00063	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  00066	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006d	50		 push	 eax
  0006e	8d 45 c0	 lea	 eax, DWORD PTR $T2[ebp]
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0IM@CKBKFPJM@Parameter?5incorrect?4?6?6?6?$CIIf?5you?5r@
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_01PKGAHCOL@?$CJ?$AA@
  00081	50		 push	 eax
  00082	8d 45 a8	 lea	 eax, DWORD PTR _msgBody$[ebp]
  00085	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0008f	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp+20]
  00092	83 c4 18	 add	 esp, 24			; 00000018H
  00095	83 f8 10	 cmp	 eax, 16			; 00000010H
  00098	72 0d		 jb	 SHORT $LN124@Show
  0009a	40		 inc	 eax
  0009b	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  0009e	50		 push	 eax
  0009f	ff 75 c0	 push	 DWORD PTR $T2[ebp]
  000a2	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN124@Show:
  000a7	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp+20]
  000aa	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
  000b1	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0
  000b8	c6 45 c0 00	 mov	 BYTE PTR $T2[ebp], 0
  000bc	83 f8 10	 cmp	 eax, 16			; 00000010H
  000bf	72 0d		 jb	 SHORT $LN225@Show
  000c1	40		 inc	 eax
  000c2	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  000c5	50		 push	 eax
  000c6	ff 75 d8	 push	 DWORD PTR $T3[ebp]
  000c9	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN225@Show:

; 59   : 			MessageBox (parent, msgBody.c_str(), "GostCrypt", MB_ICONERROR | MB_SETFOREGROUND);

  000ce	83 7d bc 10	 cmp	 DWORD PTR _msgBody$[ebp+20], 16 ; 00000010H
  000d2	8d 45 a8	 lea	 eax, DWORD PTR _msgBody$[ebp]
  000d5	68 10 00 01 00	 push	 65552			; 00010010H
  000da	0f 43 45 a8	 cmovae	 eax, DWORD PTR _msgBody$[ebp]
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  000e3	50		 push	 eax
  000e4	57		 push	 edi
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 60   : 		}

  000eb	8b 45 bc	 mov	 eax, DWORD PTR _msgBody$[ebp+20]
  000ee	83 f8 10	 cmp	 eax, 16			; 00000010H
  000f1	72 0d		 jb	 SHORT $LN343@Show
  000f3	40		 inc	 eax
  000f4	8d 4d a8	 lea	 ecx, DWORD PTR _msgBody$[ebp]
  000f7	50		 push	 eax
  000f8	ff 75 a8	 push	 DWORD PTR _msgBody$[ebp]
  000fb	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN343@Show:
  00100	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00103	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010a	59		 pop	 ecx
  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00110	33 cd		 xor	 ecx, ebp
  00112	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z$1:
  00008	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z ENDP ; GostCrypt::ParameterIncorrect::Show
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ??0ParameterIncorrect@GostCrypt@@QAE@PBD@Z
_TEXT	SEGMENT
_srcPos$ = 8						; size = 4
??0ParameterIncorrect@GostCrypt@@QAE@PBD@Z PROC		; GostCrypt::ParameterIncorrect::ParameterIncorrect, COMDAT
; _this$ = ecx

; 54   : 		ParameterIncorrect (const char *srcPos) : SrcPos (srcPos) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _srcPos$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00009	8b c1		 mov	 eax, ecx
  0000b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0ParameterIncorrect@GostCrypt@@QAE@PBD@Z ENDP		; GostCrypt::ParameterIncorrect::ParameterIncorrect
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SystemException@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0SystemException@GostCrypt@@QAE@ABU01@@Z PROC		; GostCrypt::SystemException::SystemException, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SystemException@GostCrypt@@6B@
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0SystemException@GostCrypt@@QAE@ABU01@@Z ENDP		; GostCrypt::SystemException::SystemException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ?Show@SystemException@GostCrypt@@UBEXPAUHWND__@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
?Show@SystemException@GostCrypt@@UBEXPAUHWND__@@@Z PROC	; GostCrypt::SystemException::Show, COMDAT
; _this$ = ecx

; 27   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   : 			SetLastError (ErrorCode);

  00003	ff 71 04	 push	 DWORD PTR [ecx+4]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 29   : 			handleWin32Error (parent);

  0000c	ff 75 08	 push	 DWORD PTR _parent$[ebp]
  0000f	e8 00 00 00 00	 call	 _handleWin32Error
  00014	83 c4 04	 add	 esp, 4

; 30   : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?Show@SystemException@GostCrypt@@UBEXPAUHWND__@@@Z ENDP	; GostCrypt::SystemException::Show
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ??0SystemException@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??0SystemException@GostCrypt@@QAE@XZ PROC		; GostCrypt::SystemException::SystemException, COMDAT
; _this$ = ecx

; 24   : 		SystemException () : ErrorCode (GetLastError()) { }

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7SystemException@GostCrypt@@6B@
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0000f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00012	8b c6		 mov	 eax, esi
  00014	5e		 pop	 esi
  00015	c3		 ret	 0
??0SystemException@GostCrypt@@QAE@XZ ENDP		; GostCrypt::SystemException::SystemException
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0Exception@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0Exception@GostCrypt@@QAE@ABU01@@Z PROC		; GostCrypt::Exception::Exception, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Exception@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c2 04 00	 ret	 4
??0Exception@GostCrypt@@QAE@ABU01@@Z ENDP		; GostCrypt::Exception::Exception
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0Exception@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??0Exception@GostCrypt@@QAE@XZ PROC			; GostCrypt::Exception::Exception, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Exception@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0Exception@GostCrypt@@QAE@XZ ENDP			; GostCrypt::Exception::Exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 17787: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17788:     volatile char *vptr = (volatile char *)ptr;
; 17789: 
; 17790: #if defined(_M_AMD64)
; 17791: 
; 17792:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 17793: 
; 17794: #else
; 17795: 
; 17796:     while (cnt) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR _cnt$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	8b c8		 mov	 ecx, eax
  0000b	85 d2		 test	 edx, edx
  0000d	74 0c		 je	 SHORT $LN3@RtlSecureZ
  0000f	90		 npad	 1
$LL2@RtlSecureZ:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

  00013	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 17809:         cnt--;

  00016	83 ea 01	 sub	 edx, 1
  00019	75 f5		 jne	 SHORT $LL2@RtlSecureZ
$LN3@RtlSecureZ:

; 17810:     }
; 17811: 
; 17812: #endif // _M_AMD64
; 17813: 
; 17814:     return ptr;
; 17815: }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GContainer@ForEach@GostCrypt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GContainer@ForEach@GostCrypt@@UAEPAXI@Z PROC		; GostCrypt::ForEach::Container::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00010	74 0b		 je	 SHORT $LN7@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_GContainer@ForEach@GostCrypt@@UAEPAXI@Z ENDP		; GostCrypt::ForEach::Container::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?InnerIsNotEnd@Container@ForEach@GostCrypt@@QBE_NXZ
_TEXT	SEGMENT
?InnerIsNotEnd@Container@ForEach@GostCrypt@@QBE_NXZ PROC ; GostCrypt::ForEach::Container::InnerIsNotEnd, COMDAT
; _this$ = ecx

; 23   : 			bool InnerIsNotEnd () const { return InnerEndCondition = !InnerEndCondition; }

  00000	33 c0		 xor	 eax, eax
  00002	38 41 05	 cmp	 BYTE PTR [ecx+5], al
  00005	0f 94 c0	 sete	 al
  00008	88 41 05	 mov	 BYTE PTR [ecx+5], al
  0000b	c3		 ret	 0
?InnerIsNotEnd@Container@ForEach@GostCrypt@@QBE_NXZ ENDP ; GostCrypt::ForEach::Container::InnerIsNotEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?Continue@Container@ForEach@GostCrypt@@QBEXXZ
_TEXT	SEGMENT
?Continue@Container@ForEach@GostCrypt@@QBEXXZ PROC	; GostCrypt::ForEach::Container::Continue, COMDAT
; _this$ = ecx

; 22   : 			void Continue () const { InnerContinue = true; }

  00000	c6 41 04 01	 mov	 BYTE PTR [ecx+4], 1
  00004	c3		 ret	 0
?Continue@Container@ForEach@GostCrypt@@QBEXXZ ENDP	; GostCrypt::ForEach::Container::Continue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??1Container@ForEach@GostCrypt@@UAE@XZ
_TEXT	SEGMENT
??1Container@ForEach@GostCrypt@@UAE@XZ PROC		; GostCrypt::ForEach::Container::~Container, COMDAT
; _this$ = ecx

; 20   : 			virtual ~Container () { }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00006	c3		 ret	 0
??1Container@ForEach@GostCrypt@@UAE@XZ ENDP		; GostCrypt::ForEach::Container::~Container
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??0Container@ForEach@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??0Container@ForEach@GostCrypt@@QAE@XZ PROC		; GostCrypt::ForEach::Container::Container, COMDAT
; _this$ = ecx

; 19   : 			Container () : InnerContinue (true), InnerEndCondition (false) { }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	66 c7 41 04 01
	00		 mov	 WORD PTR [ecx+4], 1
  0000e	c3		 ret	 0
??0Container@ForEach@GostCrypt@@QAE@XZ ENDP		; GostCrypt::ForEach::Container::Container
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran, COMDAT
; _this$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	72 04		 jb	 SHORT $LN17@Check_offs

; 2273 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN17@Check_offs:

; 2272 : 			_Xran();

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN19@Check_offs:
$LN16@Check_offs:
  00019	cc		 int	 3
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen, COMDAT
; _this$ = ecx

; 2266 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2249 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 29		 je	 SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00010	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00014	72 23		 jb	 SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0e		 je	 SHORT $LN57@Tidy

; 2256 : 				_Traits::copy(this->_Bx()._Buf,

  0001d	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00020	50		 push	 eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	e8 00 00 00 00	 call	 _memcpy
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@Tidy:

; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  0002b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002e	8b ce		 mov	 ecx, esi
  00030	40		 inc	 eax
  00031	50		 push	 eax
  00032	53		 push	 ebx
  00033	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
  00038	5b		 pop	 ebx
$LN4@Tidy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00039	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7

; 2261 : 		_Eos(_Newsize);

  00040	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00044	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00047	72 0e		 jb	 SHORT $LN94@Tidy
  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	33 c9		 xor	 ecx, ecx
  0004d	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 2262 : 		}

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8

; 2261 : 		_Eos(_Newsize);

$LN94@Tidy:
  00057	33 c0		 xor	 eax, eax
  00059	66 89 04 7e	 mov	 WORD PTR [esi+edi*2], ax
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi

; 2262 : 		}

  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	74 2e		 je	 SHORT $LN4@Inside
  0000b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000e	83 f8 08	 cmp	 eax, 8
  00011	72 04		 jb	 SHORT $LN16@Inside
  00013	8b 31		 mov	 esi, DWORD PTR [ecx]
  00015	eb 02		 jmp	 SHORT $LN17@Inside
$LN16@Inside:
  00017	8b f1		 mov	 esi, ecx
$LN17@Inside:
  00019	3b d6		 cmp	 edx, esi
  0001b	72 1c		 jb	 SHORT $LN4@Inside
  0001d	83 f8 08	 cmp	 eax, 8
  00020	72 04		 jb	 SHORT $LN30@Inside
  00022	8b 31		 mov	 esi, DWORD PTR [ecx]
  00024	eb 02		 jmp	 SHORT $LN31@Inside
$LN30@Inside:
  00026	8b f1		 mov	 esi, ecx
$LN31@Inside:
  00028	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002b	8d 04 46	 lea	 eax, DWORD PTR [esi+eax*2]
  0002e	3b c2		 cmp	 eax, edx
  00030	76 07		 jbe	 SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

  00032	b0 01		 mov	 al, 1
  00034	5e		 pop	 esi

; 2244 : 		}

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

  00039	32 c0		 xor	 al, al
  0003b	5e		 pop	 esi

; 2244 : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2225 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH
  0000d	77 5b		 ja	 SHORT $LN89@Grow

; 2227 : 		if (this->_Myres() < _Newsize)

  0000f	39 71 14	 cmp	 DWORD PTR [ecx+20], esi
  00012	73 13		 jae	 SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00014	ff 71 10	 push	 DWORD PTR [ecx+16]
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0001d	85 f6		 test	 esi, esi
  0001f	5e		 pop	 esi
  00020	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00027	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  0002b	74 1f		 je	 SHORT $LN5@Grow
  0002d	83 fe 08	 cmp	 esi, 8
  00030	73 1a		 jae	 SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  00032	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00035	3b f0		 cmp	 esi, eax
  00037	0f 42 c6	 cmovb	 eax, esi
  0003a	50		 push	 eax
  0003b	6a 01		 push	 1
  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
  00042	85 f6		 test	 esi, esi
  00044	5e		 pop	 esi
  00045	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

  0004c	85 f6		 test	 esi, esi
  0004e	75 12		 jne	 SHORT $LN88@Grow

; 2233 : 			_Eos(0);	// new size is zero, just null terminate

  00050	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00054	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  00057	72 02		 jb	 SHORT $LN80@Grow
  00059	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN80@Grow:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 f6		 test	 esi, esi
  0005f	66 89 01	 mov	 WORD PTR [ecx], ax
$LN88@Grow:
  00062	0f 95 c0	 setne	 al
  00065	5e		 pop	 esi

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
$LN89@Grow:

; 2226 : 			_Xlen();	// result too long

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0006f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN91@Grow:
$LN87@Grow:
  00074	cc		 int	 3
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

  00003	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00007	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0000a	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000d	72 0c		 jb	 SHORT $LN11@Eos
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	33 c9		 xor	 ecx, ecx
  00013	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 2220 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

$LN11@Eos:
  0001b	33 c0		 xor	 eax, eax
  0001d	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax

; 2220 : 		}

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$1$ = -24						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f8		 mov	 edi, eax
  00035	83 cf 07	 or	 edi, 7

; 2184 : 		if (max_size() < _Newres)

  00038	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  0003e	76 04		 jbe	 SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

  00040	8b f8		 mov	 edi, eax
  00042	eb 27		 jmp	 SHORT $LN108@Copy
$LN2@Copy:

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  00044	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00047	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0004c	f7 e7		 mul	 edi
  0004e	8b cb		 mov	 ecx, ebx
  00050	d1 e9		 shr	 ecx, 1
  00052	d1 ea		 shr	 edx, 1
  00054	3b ca		 cmp	 ecx, edx
  00056	76 13		 jbe	 SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00058	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH

; 2189 : 			_Newres = this->_Myres()

  0005d	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]
  00060	2b c1		 sub	 eax, ecx
  00062	3b d8		 cmp	 ebx, eax
  00064	76 05		 jbe	 SHORT $LN108@Copy

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()

  00066	bf fe ff ff 7f	 mov	 edi, 2147483646		; 7ffffffeH
$LN108@Copy:

; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  0006b	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0006e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00075	50		 push	 eax
  00076	8b ce		 mov	 ecx, esi
  00078	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  0007d	8b d0		 mov	 edx, eax
  0007f	eb 29		 jmp	 SHORT $LN429@Copy
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  00081	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax
  0008a	40		 inc	 eax
  0008b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0008e	50		 push	 eax
  0008f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00093	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  00098	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

  0009b	b8 00 00 00 00	 mov	 eax, $LN426@Copy
  000a0	c3		 ret	 0
$LN426@Copy:
  000a1	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000a4	8b 7d 08	 mov	 edi, DWORD PTR __Newres$[ebp]
  000a7	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN429@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

  000aa	8b 5d 0c	 mov	 ebx, DWORD PTR __Oldlen$[ebp]
  000ad	89 55 e8	 mov	 DWORD PTR __Ptr$1$[ebp], edx
  000b0	85 db		 test	 ebx, ebx
  000b2	74 1e		 je	 SHORT $LN260@Copy

; 2208 : 			_Traits::copy(_Unfancy(_Ptr), this->_Myptr(),

  000b4	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000b8	72 04		 jb	 SHORT $LN251@Copy
  000ba	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000bc	eb 02		 jmp	 SHORT $LN252@Copy
$LN251@Copy:
  000be	8b ce		 mov	 ecx, esi
$LN252@Copy:
  000c0	85 db		 test	 ebx, ebx
  000c2	74 0e		 je	 SHORT $LN260@Copy
  000c4	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  000c7	50		 push	 eax
  000c8	51		 push	 ecx
  000c9	52		 push	 edx
  000ca	e8 00 00 00 00	 call	 _memcpy
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN260@Copy:

; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);

  000d2	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000d5	83 f8 08	 cmp	 eax, 8
  000d8	72 0b		 jb	 SHORT $LN266@Copy
  000da	40		 inc	 eax
  000db	8b ce		 mov	 ecx, esi
  000dd	50		 push	 eax
  000de	ff 36		 push	 DWORD PTR [esi]
  000e0	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN266@Copy:
  000e5	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  000ec	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000f0	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000f7	72 04		 jb	 SHORT $LN356@Copy
  000f9	8b 06		 mov	 eax, DWORD PTR [esi]
  000fb	eb 02		 jmp	 SHORT $LN357@Copy
$LN356@Copy:
  000fd	8b c6		 mov	 eax, esi
$LN357@Copy:
  000ff	33 c9		 xor	 ecx, ecx
  00101	66 89 08	 mov	 WORD PTR [eax], cx

; 2211 : 		this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Ptr);

  00104	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  00107	89 06		 mov	 DWORD PTR [esi], eax

; 2212 : 		this->_Myres() = _Newres;

  00109	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 2213 : 		_Eos(_Oldlen);

  0010c	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00110	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00113	72 02		 jb	 SHORT $LN420@Copy
  00115	8b f0		 mov	 esi, eax
$LN420@Copy:
  00117	33 c0		 xor	 eax, eax
  00119	66 89 04 5e	 mov	 WORD PTR [esi+ebx*2], ax

; 2214 : 		}

  0011d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00120	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00127	59		 pop	 ecx
  00128	5f		 pop	 edi
  00129	5e		 pop	 esi
  0012a	5b		 pop	 ebx
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

  00131	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00134	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00137	83 f8 08	 cmp	 eax, 8
  0013a	72 0b		 jb	 SHORT $LN144@Copy
  0013c	40		 inc	 eax
  0013d	8b ce		 mov	 ecx, esi
  0013f	50		 push	 eax
  00140	ff 36		 push	 DWORD PTR [esi]
  00142	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN144@Copy:
  00147	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0014e	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00152	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00159	72 02		 jb	 SHORT $LN235@Copy
  0015b	8b 36		 mov	 esi, DWORD PTR [esi]
$LN235@Copy:
  0015d	33 c0		 xor	 eax, eax

; 2203 : 			_RERAISE;

  0015f	50		 push	 eax
  00160	50		 push	 eax
  00161	66 89 06	 mov	 WORD PTR [esi], ax
  00164	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN430@Copy:
$LN428@Copy:
  00169	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 2
?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Chassign, COMDAT
; _this$ = ecx

; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx

; 2175 : 		if (_Count == 1)

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00008	83 f9 01	 cmp	 ecx, 1
  0000b	75 17		 jne	 SHORT $LN2@Chassign

; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);

  0000d	83 7a 14 08	 cmp	 DWORD PTR [edx+20], 8
  00011	72 02		 jb	 SHORT $LN15@Chassign
  00013	8b 12		 mov	 edx, DWORD PTR [edx]
$LN15@Chassign:
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00018	66 8b 45 10	 mov	 ax, WORD PTR __Ch$[ebp]
  0001c	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 2179 : 		}

  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Chassign:

; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

  00024	83 7a 14 08	 cmp	 DWORD PTR [edx+20], 8
  00028	72 02		 jb	 SHORT $LN32@Chassign
  0002a	8b 12		 mov	 edx, DWORD PTR [edx]
$LN32@Chassign:
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0002f	57		 push	 edi
  00030	8d 3c 42	 lea	 edi, DWORD PTR [edx+eax*2]
  00033	85 c9		 test	 ecx, ecx
  00035	74 16		 je	 SHORT $LN47@Chassign
  00037	8b 45 10	 mov	 eax, DWORD PTR __Ch$[ebp]
  0003a	0f b7 d0	 movzx	 edx, ax
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e2 10	 shl	 edx, 16			; 00000010H
  00042	0b c2		 or	 eax, edx
  00044	d1 e9		 shr	 ecx, 1
  00046	f3 ab		 rep stosd
  00048	13 c9		 adc	 ecx, ecx
  0004a	66 f3 ab	 rep stosw
$LN47@Chassign:
  0004d	5f		 pop	 edi

; 2179 : 		}

  0004e	5d		 pop	 ebp
  0004f	c2 0c 00	 ret	 12			; 0000000cH
?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Chassign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::get_allocator, COMDAT
; _this$ = ecx

; 2168 : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2169 : 		allocator_type _Ret(this->_Getal());
; 2170 : 		return (_Ret);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2171 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare, COMDAT
; _this$ = ecx

; 2120 : 		{	// compare [0, _Mysize()) with _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  0000b	8d 70 10	 lea	 esi, DWORD PTR [eax+16]
  0000e	72 02		 jb	 SHORT $LN22@compare
  00010	8b 00		 mov	 eax, DWORD PTR [eax]
$LN22@compare:
  00012	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00016	8d 51 10	 lea	 edx, DWORD PTR [ecx+16]
  00019	72 02		 jb	 SHORT $LN45@compare
  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN45@compare:
  0001d	ff 36		 push	 DWORD PTR [esi]
  0001f	50		 push	 eax
  00020	ff 32		 push	 DWORD PTR [edx]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ?_Traits_compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAHQB_WI0I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Traits_compare
  00028	83 c4 10	 add	 esp, 16			; 00000010H
  0002b	5e		 pop	 esi

; 2122 : 			_Right._Myptr(), _Right._Mysize()));
; 2123 : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

  00009	39 45 0c	 cmp	 DWORD PTR __Size$[ebp], eax
  0000c	0f 46 45 0c	 cmovbe	 eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Traits_compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAHQB_WI0I@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Left_size$ = 12					; size = 4
__Right$ = 16						; size = 4
__Right_size$ = 20					; size = 4
?_Traits_compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAHQB_WI0I@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Traits_compare, COMDAT

; 2094 : 		{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Left_size$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 14	 mov	 edi, DWORD PTR __Right_size$[ebp]
  0000b	3b df		 cmp	 ebx, edi
  0000d	8b cf		 mov	 ecx, edi
  0000f	0f 42 cb	 cmovb	 ecx, ebx

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

  00012	85 c9		 test	 ecx, ecx
  00014	75 04		 jne	 SHORT $LN8@Traits_com
  00016	33 c0		 xor	 eax, eax
  00018	eb 21		 jmp	 SHORT $LN10@Traits_com
$LN8@Traits_com:
  0001a	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  0001d	56		 push	 esi
  0001e	8b 75 08	 mov	 esi, DWORD PTR __Left$[ebp]
  00021	85 c9		 test	 ecx, ecx
  00023	74 13		 je	 SHORT $LN12@Traits_com
$LL13@Traits_com:
  00025	66 8b 06	 mov	 ax, WORD PTR [esi]
  00028	66 3b 02	 cmp	 ax, WORD PTR [edx]
  0002b	75 1d		 jne	 SHORT $LN17@Traits_com
  0002d	83 c6 02	 add	 esi, 2
  00030	83 c2 02	 add	 edx, 2
  00033	83 e9 01	 sub	 ecx, 1
  00036	75 ed		 jne	 SHORT $LL13@Traits_com
$LN12@Traits_com:
  00038	33 c0		 xor	 eax, eax
$LN21@Traits_com:
  0003a	5e		 pop	 esi
$LN10@Traits_com:

; 2097 : 
; 2098 : 		if (_Ans != 0)

  0003b	85 c0		 test	 eax, eax
  0003d	75 1d		 jne	 SHORT $LN4@Traits_com

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

  0003f	3b fb		 cmp	 edi, ebx
  00041	76 15		 jbe	 SHORT $LN22@Traits_com

; 2102 : 			return (-1);

  00043	5f		 pop	 edi
  00044	83 c8 ff	 or	 eax, -1
  00047	5b		 pop	 ebx

; 2105 : 			return (1);
; 2106 : 
; 2107 : 		return (0);
; 2108 : 		}

  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
$LN17@Traits_com:

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

  0004a	0f b7 06	 movzx	 eax, WORD PTR [esi]
  0004d	66 3b 02	 cmp	 ax, WORD PTR [edx]
  00050	1b c0		 sbb	 eax, eax
  00052	83 e0 fe	 and	 eax, -2			; fffffffeH
  00055	40		 inc	 eax
  00056	eb e2		 jmp	 SHORT $LN21@Traits_com
$LN22@Traits_com:

; 2103 : 
; 2104 : 		if (_Left_size > _Right_size)

  00058	1b c0		 sbb	 eax, eax
  0005a	f7 d8		 neg	 eax
$LN4@Traits_com:
  0005c	5f		 pop	 edi
  0005d	5b		 pop	 ebx

; 2105 : 			return (1);
; 2106 : 
; 2107 : 		return (0);
; 2108 : 		}

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?_Traits_compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAHQB_WI0I@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Traits_compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr, COMDAT
; _this$ = ecx

; 2088 : 		{	// return [_Off, _Off + _Count) as new string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 2089 : 		return (_Myt(*this, _Off, _Count, get_allocator()));

  00005	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	33 c0		 xor	 eax, eax
  0000d	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00017	51		 push	 ecx
  00018	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0001f	8b ce		 mov	 ecx, esi
  00021	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00028	66 89 06	 mov	 WORD PTR [esi], ax
  0002b	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi

; 2090 : 		}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 0c 00	 ret	 12			; 0000000cH
?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find, COMDAT
; _this$ = ecx

; 1895 : 		{	// look for [_Ptr, <null>) beginning at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1896 : 		_DEBUG_POINTER(_Ptr);
; 1897 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  0000b	75 11		 jne	 SHORT $LN5@find
  0000d	33 d2		 xor	 edx, edx
  0000f	52		 push	 edx
  00010	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
  00019	5e		 pop	 esi

; 1898 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8

; 1896 : 		_DEBUG_POINTER(_Ptr);
; 1897 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));

$LN5@find:
  0001e	8b d6		 mov	 edx, esi
  00020	57		 push	 edi
  00021	8d 7a 02	 lea	 edi, DWORD PTR [edx+2]
$LL7@find:
  00024	66 8b 02	 mov	 ax, WORD PTR [edx]
  00027	83 c2 02	 add	 edx, 2
  0002a	66 85 c0	 test	 ax, ax
  0002d	75 f5		 jne	 SHORT $LL7@find
  0002f	2b d7		 sub	 edx, edi
  00031	5f		 pop	 edi
  00032	d1 fa		 sar	 edx, 1
  00034	52		 push	 edx
  00035	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
  0003e	5e		 pop	 esi

; 1898 : 		}

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z
_TEXT	SEGMENT
tv175 = -12						; size = 4
tv335 = -8						; size = 4
_this$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Vptr$1$ = 12						; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find, COMDAT
; _this$ = ecx

; 1875 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1876 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1877 : 		if (_Count == 0 && _Off <= this->_Mysize())

  00006	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	89 75 fc	 mov	 DWORD PTR _this$1$[ebp], esi
  00012	85 c9		 test	 ecx, ecx
  00014	75 0e		 jne	 SHORT $LN5@find
  00016	3b 56 10	 cmp	 edx, DWORD PTR [esi+16]
  00019	77 09		 ja	 SHORT $LN5@find

; 1878 : 			return (_Off);	// null string always matches (if inside string)

  0001b	8b c2		 mov	 eax, edx
  0001d	5e		 pop	 esi

; 1892 : 		}

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
$LN5@find:
  00024	53		 push	 ebx

; 1879 : 
; 1880 : 		size_type _Nm;
; 1881 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))

  00025	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  00028	57		 push	 edi
  00029	3b d3		 cmp	 edx, ebx
  0002b	0f 83 a7 00 00
	00		 jae	 $LN3@find
  00031	2b da		 sub	 ebx, edx
  00033	3b cb		 cmp	 ecx, ebx
  00035	0f 87 9d 00 00
	00		 ja	 $LN3@find

; 1882 : 			{	// room for match, look for it
; 1883 : 			const _Elem *_Uptr, *_Vptr;
; 1884 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;

  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	2b c1		 sub	 eax, ecx
  00042	03 d8		 add	 ebx, eax
  00044	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00047	89 45 f8	 mov	 DWORD PTR tv335[ebp], eax
  0004a	83 f8 08	 cmp	 eax, 8
  0004d	72 04		 jb	 SHORT $LN46@find
  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	eb 02		 jmp	 SHORT $LN47@find
$LN46@find:
  00053	8b c6		 mov	 eax, esi
$LN47@find:
  00055	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
$LN104@find:
  00058	89 45 0c	 mov	 DWORD PTR __Vptr$1$[ebp], eax

; 1885 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;

  0005b	85 db		 test	 ebx, ebx
  0005d	74 18		 je	 SHORT $LN102@find
  0005f	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00062	8b cb		 mov	 ecx, ebx
  00064	0f b7 12	 movzx	 edx, WORD PTR [edx]
$LL57@find:
  00067	66 39 10	 cmp	 WORD PTR [eax], dx
  0006a	74 47		 je	 SHORT $LN87@find
  0006c	83 c0 02	 add	 eax, 2
  0006f	83 e9 01	 sub	 ecx, 1
  00072	75 f3		 jne	 SHORT $LL57@find
  00074	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
$LN102@find:
  00077	33 c0		 xor	 eax, eax
$LN54@find:
  00079	85 c0		 test	 eax, eax
  0007b	74 5b		 je	 SHORT $LN3@find

; 1887 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)

  0007d	85 c9		 test	 ecx, ecx
  0007f	74 1a		 je	 SHORT $LN98@find
  00081	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00084	8b f9		 mov	 edi, ecx
  00086	8b f0		 mov	 esi, eax
$LL67@find:
  00088	66 8b 0e	 mov	 cx, WORD PTR [esi]
  0008b	66 3b 0a	 cmp	 cx, WORD PTR [edx]
  0008e	75 28		 jne	 SHORT $LN103@find
  00090	83 c6 02	 add	 esi, 2
  00093	83 c2 02	 add	 edx, 2
  00096	83 ef 01	 sub	 edi, 1
  00099	75 ed		 jne	 SHORT $LL67@find
$LN98@find:

; 1888 : 					return (_Uptr - this->_Myptr());	// found a match

  0009b	83 7d f8 08	 cmp	 DWORD PTR tv335[ebp], 8
  0009f	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
  000a2	72 02		 jb	 SHORT $LN81@find
  000a4	8b 36		 mov	 esi, DWORD PTR [esi]
$LN81@find:
  000a6	5f		 pop	 edi
  000a7	2b c6		 sub	 eax, esi
  000a9	5b		 pop	 ebx
  000aa	d1 f8		 sar	 eax, 1
  000ac	5e		 pop	 esi

; 1892 : 		}

  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c2 0c 00	 ret	 12			; 0000000cH
$LN87@find:

; 1885 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;

  000b3	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  000b6	eb c1		 jmp	 SHORT $LN54@find
$LN103@find:

; 1887 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)

  000b8	1b c9		 sbb	 ecx, ecx
  000ba	83 e1 fe	 and	 ecx, -2			; fffffffeH
  000bd	83 c1 01	 add	 ecx, 1
  000c0	74 d9		 je	 SHORT $LN98@find

; 1886 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)

  000c2	8b d0		 mov	 edx, eax
  000c4	83 c9 ff	 or	 ecx, -1
  000c7	2b 55 0c	 sub	 edx, DWORD PTR __Vptr$1$[ebp]
  000ca	d1 fa		 sar	 edx, 1
  000cc	2b ca		 sub	 ecx, edx
  000ce	03 d9		 add	 ebx, ecx
  000d0	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  000d3	83 c0 02	 add	 eax, 2
  000d6	eb 80		 jmp	 SHORT $LN104@find
$LN3@find:
  000d8	5f		 pop	 edi
  000d9	5b		 pop	 ebx

; 1889 : 			}
; 1890 : 
; 1891 : 		return (npos);	// no match

  000da	83 c8 ff	 or	 eax, -1
  000dd	5e		 pop	 esi

; 1892 : 		}

  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c2 0c 00	 ret	 12			; 0000000cH
?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIPB_WII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::empty, COMDAT
; _this$ = ecx

; 1803 : 		{	// test if sequence is empty

  00000	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00004	0f 94 c0	 sete	 al

; 1804 : 		return (this->_Mysize() == 0);
; 1805 : 		}

  00007	c3		 ret	 0
?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH

; 1772 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT
; _this$ = ecx

; 1765 : 		return (this->_Mysize());

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1766 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 1743 : 		return (this->_Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN13@c_str
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1744 : 		}

  00008	c3		 ret	 0

; 1743 : 		return (this->_Myptr());

$LN13@c_str:
  00009	8b c1		 mov	 eax, ecx

; 1744 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[], COMDAT
; _this$ = ecx

; 1679 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1680 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1681 : 		if (this->_Mysize() < _Off)	// sic
; 1682 : 			_DEBUG_ERROR("string subscript out of range");
; 1683 : 
; 1684 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1685 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1686 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1687 : 
; 1688 : 		return (this->_Myptr()[_Off]);

  00003	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	72 02		 jb	 SHORT $LN13@operator
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN13@operator:
  0000e	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 1689 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end, COMDAT
; _this$ = ecx

; 1606 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1607 : 		auto _Mydata = &this->_Get_data();
; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

  00003	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00007	72 11		 jb	 SHORT $LN11@end
  00009	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  00011	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00014	89 08		 mov	 DWORD PTR [eax], ecx

; 1609 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1607 : 		auto _Mydata = &this->_Get_data();
; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

$LN11@end:
  0001a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0001d	8b d1		 mov	 edx, ecx
  0001f	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00025	89 08		 mov	 DWORD PTR [eax], ecx

; 1609 : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin, COMDAT
; _this$ = ecx

; 1594 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1595 : 		auto _Mydata = &this->_Get_data();
; 1596 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));

  00003	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	72 02		 jb	 SHORT $LN11@begin
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN11@begin:
  0000e	89 08		 mov	 DWORD PTR [eax], ecx

; 1597 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace, COMDAT
; _this$ = ecx

; 1584 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1585 : 		if (_First2 == _Last2)

  00003	8b 55 10	 mov	 edx, DWORD PTR __First2$[ebp]

; 1586 : 			erase(_First - begin(), _Last - _First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 4d 14	 mov	 ecx, DWORD PTR __Last2$[ebp]
  0000f	3b d1		 cmp	 edx, ecx
  00011	75 39		 jne	 SHORT $LN2@replace
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	2b c8		 sub	 ecx, eax
  00018	d1 f9		 sar	 ecx, 1
  0001a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0001e	72 16		 jb	 SHORT $LN24@replace
  00020	8b 16		 mov	 edx, DWORD PTR [esi]
  00022	2b c2		 sub	 eax, edx
  00024	51		 push	 ecx
  00025	d1 f8		 sar	 eax, 1
  00027	8b ce		 mov	 ecx, esi
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  0002f	8b c6		 mov	 eax, esi
  00031	5e		 pop	 esi

; 1591 : 		}

  00032	5d		 pop	 ebp
  00033	c2 10 00	 ret	 16			; 00000010H

; 1586 : 			erase(_First - begin(), _Last - _First);

$LN24@replace:
  00036	8b d6		 mov	 edx, esi
  00038	2b c2		 sub	 eax, edx
  0003a	51		 push	 ecx
  0003b	d1 f8		 sar	 eax, 1
  0003d	8b ce		 mov	 ecx, esi
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  00045	8b c6		 mov	 eax, esi
  00047	5e		 pop	 esi

; 1591 : 		}

  00048	5d		 pop	 ebp
  00049	c2 10 00	 ret	 16			; 00000010H
$LN2@replace:
  0004c	53		 push	 ebx
  0004d	57		 push	 edi

; 1587 : 		else
; 1588 : 			replace(_First - begin(), _Last - _First,

  0004e	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  00051	2b ca		 sub	 ecx, edx
  00053	2b f8		 sub	 edi, eax
  00055	d1 f9		 sar	 ecx, 1
  00057	d1 ff		 sar	 edi, 1
  00059	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0005d	72 04		 jb	 SHORT $LN76@replace
  0005f	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00061	eb 02		 jmp	 SHORT $LN77@replace
$LN76@replace:
  00063	8b de		 mov	 ebx, esi
$LN77@replace:
  00065	51		 push	 ecx
  00066	52		 push	 edx
  00067	2b c3		 sub	 eax, ebx
  00069	8b ce		 mov	 ecx, esi
  0006b	57		 push	 edi
  0006c	d1 f8		 sar	 eax, 1
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace
  00074	5f		 pop	 edi
  00075	5b		 pop	 ebx

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  00076	8b c6		 mov	 eax, esi
  00078	5e		 pop	 esi

; 1591 : 		}

  00079	5d		 pop	 ebp
  0007a	c2 10 00	 ret	 16			; 00000010H
?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIPB_WI@Z
_TEXT	SEGMENT
__Nm$1$ = -12						; size = 4
__N0$2$ = -8						; size = 4
tv906 = -4						; size = 4
__Off$ = 8						; size = 4
tv907 = 12						; size = 4
tv904 = 12						; size = 4
tv873 = 12						; size = 4
__N0$ = 12						; size = 4
tv903 = 16						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIPB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace, COMDAT
; _this$ = ecx

; 1453 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1454 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1455 : 		if (_Inside(_Ptr))

  00007	8b 5d 10	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 db		 test	 ebx, ebx
  0000f	74 50		 je	 SHORT $LN2@replace
  00011	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00014	83 f9 08	 cmp	 ecx, 8
  00017	72 04		 jb	 SHORT $LN24@replace
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	eb 02		 jmp	 SHORT $LN25@replace
$LN24@replace:
  0001d	8b c6		 mov	 eax, esi
$LN25@replace:
  0001f	3b d8		 cmp	 ebx, eax
  00021	72 3e		 jb	 SHORT $LN2@replace
  00023	83 f9 08	 cmp	 ecx, 8
  00026	72 04		 jb	 SHORT $LN38@replace
  00028	8b 16		 mov	 edx, DWORD PTR [esi]
  0002a	eb 02		 jmp	 SHORT $LN39@replace
$LN38@replace:
  0002c	8b d6		 mov	 edx, esi
$LN39@replace:
  0002e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00031	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00034	3b c3		 cmp	 eax, ebx
  00036	76 29		 jbe	 SHORT $LN2@replace

; 1456 : 			return (replace(_Off, _N0, *this,

  00038	83 f9 08	 cmp	 ecx, 8
  0003b	72 04		 jb	 SHORT $LN61@replace
  0003d	8b 06		 mov	 eax, DWORD PTR [esi]
  0003f	eb 02		 jmp	 SHORT $LN62@replace
$LN61@replace:
  00041	8b c6		 mov	 eax, esi
$LN62@replace:
  00043	ff 75 14	 push	 DWORD PTR __Count$[ebp]
  00046	2b d8		 sub	 ebx, eax
  00048	8b ce		 mov	 ecx, esi
  0004a	d1 fb		 sar	 ebx, 1
  0004c	53		 push	 ebx
  0004d	56		 push	 esi
  0004e	ff 75 0c	 push	 DWORD PTR __N0$[ebp]
  00051	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00054	e8 00 00 00 00	 call	 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx

; 1480 : 		}

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 10 00	 ret	 16			; 00000010H
$LN2@replace:

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);

  00061	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00064	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00067	3b c1		 cmp	 eax, ecx
  00069	0f 82 97 01 00
	00		 jb	 $LN318@replace

; 1460 : 		_N0 = _Clamp_suffix_size(_Off, _N0);

  0006f	8b d0		 mov	 edx, eax
  00071	2b d1		 sub	 edx, ecx
  00073	8b 4d 0c	 mov	 ecx, DWORD PTR __N0$[ebp]
  00076	3b ca		 cmp	 ecx, edx
  00078	57		 push	 edi

; 1461 : 		if (npos - _Count <= this->_Mysize() - _N0)

  00079	8b 7d 14	 mov	 edi, DWORD PTR __Count$[ebp]
  0007c	0f 47 ca	 cmova	 ecx, edx
  0007f	2b c1		 sub	 eax, ecx
  00081	89 4d f8	 mov	 DWORD PTR __N0$2$[ebp], ecx
  00084	89 45 0c	 mov	 DWORD PTR tv873[ebp], eax
  00087	8b c7		 mov	 eax, edi
  00089	f7 d0		 not	 eax
  0008b	3b 45 0c	 cmp	 eax, DWORD PTR tv873[ebp]
  0008e	0f 86 7c 01 00
	00		 jbe	 $LN320@replace

; 1463 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;

  00094	2b d1		 sub	 edx, ecx
  00096	89 55 f4	 mov	 DWORD PTR __Nm$1$[ebp], edx

; 1464 : 
; 1465 : 		if (_Count < _N0)

  00099	3b f9		 cmp	 edi, ecx
  0009b	73 4e		 jae	 SHORT $LN145@replace

; 1466 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  0009d	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000a0	83 f8 08	 cmp	 eax, 8
  000a3	72 0a		 jb	 SHORT $LN124@replace
  000a5	8b 1e		 mov	 ebx, DWORD PTR [esi]
  000a7	89 5d 0c	 mov	 DWORD PTR tv907[ebp], ebx
  000aa	8b 5d 10	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  000ad	eb 03		 jmp	 SHORT $LN125@replace
$LN124@replace:
  000af	89 75 0c	 mov	 DWORD PTR tv907[ebp], esi
$LN125@replace:
  000b2	83 f8 08	 cmp	 eax, 8
  000b5	72 07		 jb	 SHORT $LN138@replace
  000b7	8b 06		 mov	 eax, DWORD PTR [esi]
  000b9	89 45 fc	 mov	 DWORD PTR tv906[ebp], eax
  000bc	eb 03		 jmp	 SHORT $LN139@replace
$LN138@replace:
  000be	89 75 fc	 mov	 DWORD PTR tv906[ebp], esi
$LN139@replace:
  000c1	85 d2		 test	 edx, edx
  000c3	74 26		 je	 SHORT $LN145@replace
  000c5	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  000c8	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000cb	50		 push	 eax
  000cc	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  000cf	8b 4d 0c	 mov	 ecx, DWORD PTR tv907[ebp]
  000d2	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000d5	8b 4d fc	 mov	 ecx, DWORD PTR tv906[ebp]
  000d8	50		 push	 eax
  000d9	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  000dc	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _memmove
  000e5	8b 4d f8	 mov	 ecx, DWORD PTR __N0$2$[ebp]
  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN145@replace:

; 1467 : 				this->_Myptr() + _Off + _N0,
; 1468 : 				_Nm);	// smaller hole, move tail up
; 1469 : 		const size_type _Num = this->_Mysize() + _Count - _N0;

  000eb	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000ee	8b f8		 mov	 edi, eax
  000f0	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  000f3	2b f9		 sub	 edi, ecx
  000f5	03 fa		 add	 edi, edx

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

  000f7	85 d2		 test	 edx, edx
  000f9	75 08		 jne	 SHORT $LN6@replace
  000fb	85 c9		 test	 ecx, ecx
  000fd	0f 84 f8 00 00
	00		 je	 $LN312@replace
$LN6@replace:
  00103	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00109	0f 87 0b 01 00
	00		 ja	 $LN321@replace
  0010f	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00112	73 31		 jae	 SHORT $LN159@replace
  00114	50		 push	 eax
  00115	57		 push	 edi
  00116	8b ce		 mov	 ecx, esi
  00118	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0011d	8b 4d f8	 mov	 ecx, DWORD PTR __N0$2$[ebp]
  00120	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  00123	85 ff		 test	 edi, edi
  00125	0f 84 d0 00 00
	00		 je	 $LN312@replace
$LN317@replace:

; 1472 : 			{	// make room and rearrange
; 1473 : 			if (_N0 < _Count)

  0012b	3b ca		 cmp	 ecx, edx
  0012d	0f 83 80 00 00
	00		 jae	 $LN274@replace

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

  00133	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00136	83 f8 08	 cmp	 eax, 8
  00139	72 39		 jb	 SHORT $LN253@replace
  0013b	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0013d	89 5d 0c	 mov	 DWORD PTR tv904[ebp], ebx
  00140	8b 5d 10	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00143	eb 32		 jmp	 SHORT $LN254@replace

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

$LN159@replace:
  00145	85 ff		 test	 edi, edi
  00147	75 e2		 jne	 SHORT $LN317@replace
  00149	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0014c	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00150	72 12		 jb	 SHORT $LN236@replace
  00152	8b 06		 mov	 eax, DWORD PTR [esi]
  00154	33 c9		 xor	 ecx, ecx
  00156	5f		 pop	 edi
  00157	66 89 08	 mov	 WORD PTR [eax], cx

; 1478 : 			}
; 1479 : 		return (*this);

  0015a	8b c6		 mov	 eax, esi
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx

; 1480 : 		}

  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 10 00	 ret	 16			; 00000010H

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

$LN236@replace:
  00164	8b c6		 mov	 eax, esi
  00166	33 c9		 xor	 ecx, ecx
  00168	5f		 pop	 edi
  00169	5e		 pop	 esi
  0016a	5b		 pop	 ebx
  0016b	66 89 08	 mov	 WORD PTR [eax], cx

; 1480 : 		}

  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c2 10 00	 ret	 16			; 00000010H

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

$LN253@replace:
  00174	89 75 0c	 mov	 DWORD PTR tv904[ebp], esi
$LN254@replace:
  00177	83 f8 08	 cmp	 eax, 8
  0017a	72 07		 jb	 SHORT $LN267@replace
  0017c	8b 06		 mov	 eax, DWORD PTR [esi]
  0017e	89 45 10	 mov	 DWORD PTR tv903[ebp], eax
  00181	eb 03		 jmp	 SHORT $LN268@replace
$LN267@replace:
  00183	89 75 10	 mov	 DWORD PTR tv903[ebp], esi
$LN268@replace:
  00186	8b 45 f4	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00189	85 c0		 test	 eax, eax
  0018b	74 26		 je	 SHORT $LN274@replace
  0018d	03 c0		 add	 eax, eax
  0018f	50		 push	 eax
  00190	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00193	03 c1		 add	 eax, ecx
  00195	8b 4d 0c	 mov	 ecx, DWORD PTR tv904[ebp]
  00198	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0019b	8b 4d 10	 mov	 ecx, DWORD PTR tv903[ebp]
  0019e	50		 push	 eax
  0019f	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  001a2	03 c2		 add	 eax, edx
  001a4	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 _memmove
  001ad	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  001b0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN274@replace:

; 1475 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1476 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

  001b3	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  001b7	72 04		 jb	 SHORT $LN287@replace
  001b9	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001bb	eb 02		 jmp	 SHORT $LN288@replace
$LN287@replace:
  001bd	8b ce		 mov	 ecx, esi
$LN288@replace:
  001bf	85 d2		 test	 edx, edx
  001c1	74 14		 je	 SHORT $LN294@replace
  001c3	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  001c6	50		 push	 eax
  001c7	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  001ca	53		 push	 ebx
  001cb	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 _memcpy
  001d4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN294@replace:

; 1477 : 			_Eos(_Num);

  001d7	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  001db	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  001de	72 13		 jb	 SHORT $LN307@replace
  001e0	8b 06		 mov	 eax, DWORD PTR [esi]
  001e2	33 c9		 xor	 ecx, ecx
  001e4	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1478 : 			}
; 1479 : 		return (*this);

  001e8	8b c6		 mov	 eax, esi
  001ea	5f		 pop	 edi
  001eb	5e		 pop	 esi
  001ec	5b		 pop	 ebx

; 1480 : 		}

  001ed	8b e5		 mov	 esp, ebp
  001ef	5d		 pop	 ebp
  001f0	c2 10 00	 ret	 16			; 00000010H

; 1477 : 			_Eos(_Num);

$LN307@replace:
  001f3	8b c6		 mov	 eax, esi
  001f5	33 c9		 xor	 ecx, ecx
  001f7	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN312@replace:

; 1478 : 			}
; 1479 : 		return (*this);

  001fb	5f		 pop	 edi
  001fc	8b c6		 mov	 eax, esi
  001fe	5e		 pop	 esi
  001ff	5b		 pop	 ebx

; 1480 : 		}

  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c2 10 00	 ret	 16			; 00000010H
$LN318@replace:

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);

  00206	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0020b	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN322@replace:
$LN320@replace:

; 1462 : 			_Xlen();	// result too long

  00210	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00215	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN323@replace:
$LN321@replace:

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

  0021a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0021f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN324@replace:
$LN315@replace:
  00224	cc		 int	 3
?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIPB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z
_TEXT	SEGMENT
tv1837 = -12						; size = 4
__Max_effective_size$1$ = -12				; size = 4
tv1838 = -8						; size = 4
tv1854 = -4						; size = 4
tv1842 = -4						; size = 4
__Nm$1$ = -4						; size = 4
tv1836 = 8						; size = 4
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
tv1846 = 16						; size = 4
tv1814 = 16						; size = 4
__Right$ = 16						; size = 4
tv1844 = 20						; size = 4
tv1840 = 20						; size = 4
__Roff$ = 20						; size = 4
tv1827 = 24						; size = 4
__Newsize$1$ = 24					; size = 4
__Count$ = 24						; size = 4
?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace, COMDAT
; _this$ = ecx

; 1389 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1390 : 		_Check_offset(_Off);

  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0000c	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0000f	3b d1		 cmp	 edx, ecx
  00011	0f 82 ed 03 00
	00		 jb	 $LN625@replace

; 1391 : 		_Right._Check_offset(_Roff);

  00017	53		 push	 ebx
  00018	8b 5d 10	 mov	 ebx, DWORD PTR __Right$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  0001f	3b 7d 14	 cmp	 edi, DWORD PTR __Roff$[ebp]
  00022	0f 82 e6 03 00
	00		 jb	 $LN627@replace

; 1392 : 		_N0 = _Clamp_suffix_size(_Off, _N0);

  00028	8b 5d 0c	 mov	 ebx, DWORD PTR __N0$[ebp]
  0002b	8b c2		 mov	 eax, edx
  0002d	2b c1		 sub	 eax, ecx
  0002f	3b d8		 cmp	 ebx, eax
  00031	89 45 fc	 mov	 DWORD PTR __Nm$1$[ebp], eax
  00034	0f 47 d8	 cmova	 ebx, eax

; 1393 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00037	2b 7d 14	 sub	 edi, DWORD PTR __Roff$[ebp]
  0003a	89 7d f4	 mov	 DWORD PTR __Max_effective_size$1$[ebp], edi
  0003d	8b 7d 18	 mov	 edi, DWORD PTR __Count$[ebp]
  00040	3b 7d f4	 cmp	 edi, DWORD PTR __Max_effective_size$1$[ebp]
  00043	89 5d 0c	 mov	 DWORD PTR __N0$[ebp], ebx

; 1394 : 		if (npos - _Count <= this->_Mysize() - _N0)

  00046	8b da		 mov	 ebx, edx
  00048	0f 47 7d f4	 cmova	 edi, DWORD PTR __Max_effective_size$1$[ebp]
  0004c	2b 5d 0c	 sub	 ebx, DWORD PTR __N0$[ebp]
  0004f	8b c7		 mov	 eax, edi
  00051	f7 d0		 not	 eax
  00053	89 5d 18	 mov	 DWORD PTR tv1827[ebp], ebx
  00056	3b c3		 cmp	 eax, ebx
  00058	8b 5d 10	 mov	 ebx, DWORD PTR __Right$[ebp]
  0005b	0f 86 b7 03 00
	00		 jbe	 $LN628@replace

; 1396 : 
; 1397 : 		const size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1398 : 		const size_type _Newsize = this->_Mysize() + _Count - _N0;

  00061	8b 4d 18	 mov	 ecx, DWORD PTR tv1827[ebp]
  00064	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00067	03 cf		 add	 ecx, edi
  00069	2b 45 0c	 sub	 eax, DWORD PTR __N0$[ebp]

; 1399 : 		if (this->_Mysize() < _Newsize)

  0006c	3b d1		 cmp	 edx, ecx
  0006e	89 4d 18	 mov	 DWORD PTR __Newsize$1$[ebp], ecx
  00071	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00074	89 45 fc	 mov	 DWORD PTR __Nm$1$[ebp], eax
  00077	73 49		 jae	 SHORT $LN194@replace

; 1400 : 			_Grow(_Newsize);

  00079	81 7d 18 fe ff
	ff 7f		 cmp	 DWORD PTR __Newsize$1$[ebp], 2147483646 ; 7ffffffeH
  00080	0f 87 9c 03 00
	00		 ja	 $LN629@replace
  00086	8b 5d 18	 mov	 ebx, DWORD PTR __Newsize$1$[ebp]
  00089	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  0008c	8b 5d 10	 mov	 ebx, DWORD PTR __Right$[ebp]
  0008f	73 10		 jae	 SHORT $LN112@replace
  00091	52		 push	 edx
  00092	ff 75 18	 push	 DWORD PTR __Newsize$1$[ebp]
  00095	8b ce		 mov	 ecx, esi
  00097	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0009c	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  0009f	eb 1e		 jmp	 SHORT $LN622@replace
$LN112@replace:
  000a1	83 7d 18 00	 cmp	 DWORD PTR __Newsize$1$[ebp], 0
  000a5	75 1b		 jne	 SHORT $LN194@replace
  000a7	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000ae	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000b2	72 04		 jb	 SHORT $LN189@replace
  000b4	8b 16		 mov	 edx, DWORD PTR [esi]
  000b6	eb 02		 jmp	 SHORT $LN190@replace
$LN189@replace:
  000b8	8b d6		 mov	 edx, esi
$LN190@replace:
  000ba	33 c9		 xor	 ecx, ecx
  000bc	66 89 0a	 mov	 WORD PTR [edx], cx
$LN622@replace:
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
$LN194@replace:

; 1401 : 
; 1402 : 		if (_Count == _N0)

  000c2	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  000c5	3b fa		 cmp	 edi, edx
  000c7	75 2f		 jne	 SHORT $LN4@replace

; 1403 : 			{	// only one movement required, so _Traits::move handles any overlap
; 1404 : 			_Traits::move(this->_Myptr() + _Off,

  000c9	83 7b 14 08	 cmp	 DWORD PTR [ebx+20], 8
  000cd	72 02		 jb	 SHORT $LN206@replace
  000cf	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN206@replace:
  000d1	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000d5	72 04		 jb	 SHORT $LN220@replace
  000d7	8b 16		 mov	 edx, DWORD PTR [esi]
  000d9	eb 02		 jmp	 SHORT $LN221@replace
$LN220@replace:
  000db	8b d6		 mov	 edx, esi
$LN221@replace:
  000dd	85 ff		 test	 edi, edi
  000df	0f 84 f1 02 00
	00		 je	 $LN601@replace
  000e5	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  000e8	50		 push	 eax
  000e9	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  000ec	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  000ef	50		 push	 eax
  000f0	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000f3	e9 d5 02 00 00	 jmp	 $LN623@replace
$LN4@replace:

; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (this != &_Right)

  000f8	3b f3		 cmp	 esi, ebx
  000fa	0f 84 80 00 00
	00		 je	 $LN6@replace

; 1408 : 			{	// no overlap, just move down and copy in new stuff
; 1409 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00100	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00103	83 fa 08	 cmp	 edx, 8
  00106	72 0a		 jb	 SHORT $LN240@replace
  00108	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0010a	89 5d fc	 mov	 DWORD PTR tv1854[ebp], ebx
  0010d	8b 5d 10	 mov	 ebx, DWORD PTR __Right$[ebp]
  00110	eb 06		 jmp	 SHORT $LN241@replace
$LN240@replace:
  00112	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00115	89 75 fc	 mov	 DWORD PTR tv1854[ebp], esi
$LN241@replace:
  00118	83 fa 08	 cmp	 edx, 8
  0011b	72 04		 jb	 SHORT $LN254@replace
  0011d	8b 16		 mov	 edx, DWORD PTR [esi]
  0011f	eb 02		 jmp	 SHORT $LN255@replace
$LN254@replace:
  00121	8b d6		 mov	 edx, esi
$LN255@replace:
  00123	85 c0		 test	 eax, eax
  00125	74 21		 je	 SHORT $LN261@replace
  00127	8b 5d fc	 mov	 ebx, DWORD PTR tv1854[ebp]
  0012a	03 c0		 add	 eax, eax
  0012c	50		 push	 eax
  0012d	8b 45 0c	 mov	 eax, DWORD PTR __N0$[ebp]
  00130	03 c1		 add	 eax, ecx
  00132	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  00135	50		 push	 eax
  00136	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00139	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 _memmove
  00142	8b 5d 10	 mov	 ebx, DWORD PTR __Right$[ebp]
  00145	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN261@replace:

; 1410 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1411 : 			_Traits::copy(this->_Myptr() + _Off,

  00148	83 7b 14 08	 cmp	 DWORD PTR [ebx+20], 8
  0014c	72 02		 jb	 SHORT $LN274@replace
  0014e	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN274@replace:
  00150	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00154	72 04		 jb	 SHORT $LN288@replace
  00156	8b 16		 mov	 edx, DWORD PTR [esi]
  00158	eb 02		 jmp	 SHORT $LN289@replace
$LN288@replace:
  0015a	8b d6		 mov	 edx, esi
$LN289@replace:
  0015c	85 ff		 test	 edi, edi
  0015e	0f 84 72 02 00
	00		 je	 $LN601@replace
  00164	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00167	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  0016a	50		 push	 eax
  0016b	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  0016e	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  00171	50		 push	 eax
  00172	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 _memcpy
  0017b	e9 53 02 00 00	 jmp	 $LN624@replace
$LN6@replace:

; 1412 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1413 : 			}
; 1414 : 		else if (_Count < _N0)

  00180	3b fa		 cmp	 edi, edx
  00182	73 72		 jae	 SHORT $LN8@replace

; 1415 : 			{	// hole doesn't get larger, just copy in substring
; 1416 : 			_Traits::move(this->_Myptr() + _Off,

  00184	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00187	83 f8 08	 cmp	 eax, 8
  0018a	72 04		 jb	 SHORT $LN308@replace
  0018c	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0018e	eb 02		 jmp	 SHORT $LN309@replace
$LN308@replace:
  00190	8b de		 mov	 ebx, esi
$LN309@replace:
  00192	83 f8 08	 cmp	 eax, 8
  00195	72 04		 jb	 SHORT $LN322@replace
  00197	8b 16		 mov	 edx, DWORD PTR [esi]
  00199	eb 02		 jmp	 SHORT $LN323@replace
$LN322@replace:
  0019b	8b d6		 mov	 edx, esi
$LN323@replace:
  0019d	85 ff		 test	 edi, edi
  0019f	74 17		 je	 SHORT $LN329@replace
  001a1	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  001a4	50		 push	 eax
  001a5	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  001a8	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  001ab	50		 push	 eax
  001ac	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 _memmove
  001b5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN329@replace:

; 1417 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1418 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  001b8	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001bb	83 f8 08	 cmp	 eax, 8
  001be	72 04		 jb	 SHORT $LN342@replace
  001c0	8b 1e		 mov	 ebx, DWORD PTR [esi]
  001c2	eb 02		 jmp	 SHORT $LN343@replace
$LN342@replace:
  001c4	8b de		 mov	 ebx, esi
$LN343@replace:
  001c6	83 f8 08	 cmp	 eax, 8
  001c9	72 04		 jb	 SHORT $LN356@replace
  001cb	8b 16		 mov	 edx, DWORD PTR [esi]
  001cd	eb 02		 jmp	 SHORT $LN357@replace
$LN356@replace:
  001cf	8b d6		 mov	 edx, esi
$LN357@replace:
  001d1	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  001d4	85 c0		 test	 eax, eax
  001d6	0f 84 fa 01 00
	00		 je	 $LN601@replace
  001dc	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  001df	03 c0		 add	 eax, eax
  001e1	50		 push	 eax
  001e2	8b 45 0c	 mov	 eax, DWORD PTR __N0$[ebp]
  001e5	03 c1		 add	 eax, ecx
  001e7	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  001ea	50		 push	 eax
  001eb	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  001ee	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  001f1	e9 d7 01 00 00	 jmp	 $LN623@replace
$LN8@replace:

; 1419 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1420 : 			}
; 1421 : 		else if (_Roff <= _Off)

  001f6	8b 5d 14	 mov	 ebx, DWORD PTR __Roff$[ebp]
  001f9	3b d9		 cmp	 ebx, ecx
  001fb	0f 87 80 00 00
	00		 ja	 $LN10@replace

; 1422 : 			{	// hole gets larger, substring begins before hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00201	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00204	83 fa 08	 cmp	 edx, 8
  00207	72 0a		 jb	 SHORT $LN376@replace
  00209	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0020b	89 5d 10	 mov	 DWORD PTR tv1846[ebp], ebx
  0020e	8b 5d 14	 mov	 ebx, DWORD PTR __Roff$[ebp]
  00211	eb 03		 jmp	 SHORT $LN377@replace
$LN376@replace:
  00213	89 75 10	 mov	 DWORD PTR tv1846[ebp], esi
$LN377@replace:
  00216	83 fa 08	 cmp	 edx, 8
  00219	72 04		 jb	 SHORT $LN390@replace
  0021b	8b 16		 mov	 edx, DWORD PTR [esi]
  0021d	eb 02		 jmp	 SHORT $LN391@replace
$LN390@replace:
  0021f	8b d6		 mov	 edx, esi
$LN391@replace:
  00221	85 c0		 test	 eax, eax
  00223	74 24		 je	 SHORT $LN397@replace
  00225	8b 5d 10	 mov	 ebx, DWORD PTR tv1846[ebp]
  00228	03 c0		 add	 eax, eax
  0022a	50		 push	 eax
  0022b	8b 45 0c	 mov	 eax, DWORD PTR __N0$[ebp]
  0022e	03 c1		 add	 eax, ecx
  00230	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  00233	50		 push	 eax
  00234	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00237	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0023a	50		 push	 eax
  0023b	e8 00 00 00 00	 call	 _memmove
  00240	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00243	83 c4 0c	 add	 esp, 12			; 0000000cH
  00246	8b 5d 14	 mov	 ebx, DWORD PTR __Roff$[ebp]
$LN397@replace:

; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,

  00249	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0024c	83 f8 08	 cmp	 eax, 8
  0024f	72 07		 jb	 SHORT $LN410@replace
  00251	8b 16		 mov	 edx, DWORD PTR [esi]
  00253	89 55 14	 mov	 DWORD PTR tv1844[ebp], edx
  00256	eb 03		 jmp	 SHORT $LN411@replace
$LN410@replace:
  00258	89 75 14	 mov	 DWORD PTR tv1844[ebp], esi
$LN411@replace:
  0025b	83 f8 08	 cmp	 eax, 8
  0025e	72 04		 jb	 SHORT $LN424@replace
  00260	8b 16		 mov	 edx, DWORD PTR [esi]
  00262	eb 02		 jmp	 SHORT $LN425@replace
$LN424@replace:
  00264	8b d6		 mov	 edx, esi
$LN425@replace:
  00266	85 ff		 test	 edi, edi
  00268	0f 84 68 01 00
	00		 je	 $LN601@replace
  0026e	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00271	50		 push	 eax
  00272	8b 45 14	 mov	 eax, DWORD PTR tv1844[ebp]
  00275	8d 04 58	 lea	 eax, DWORD PTR [eax+ebx*2]
  00278	50		 push	 eax
  00279	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0027c	e9 4c 01 00 00	 jmp	 $LN623@replace
$LN10@replace:

; 1426 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1427 : 			}
; 1428 : 		else if (_Off + _N0 <= _Roff)

  00281	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00284	89 45 10	 mov	 DWORD PTR tv1814[ebp], eax
  00287	3b c3		 cmp	 eax, ebx
  00289	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  0028c	0f 87 83 00 00
	00		 ja	 $LN12@replace

; 1429 : 			{	// hole gets larger, substring begins after hole
; 1430 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00292	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00295	83 fa 08	 cmp	 edx, 8
  00298	72 0a		 jb	 SHORT $LN444@replace
  0029a	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0029c	89 5d fc	 mov	 DWORD PTR tv1842[ebp], ebx
  0029f	8b 5d 14	 mov	 ebx, DWORD PTR __Roff$[ebp]
  002a2	eb 03		 jmp	 SHORT $LN445@replace
$LN444@replace:
  002a4	89 75 fc	 mov	 DWORD PTR tv1842[ebp], esi
$LN445@replace:
  002a7	83 fa 08	 cmp	 edx, 8
  002aa	72 04		 jb	 SHORT $LN458@replace
  002ac	8b 16		 mov	 edx, DWORD PTR [esi]
  002ae	eb 02		 jmp	 SHORT $LN459@replace
$LN458@replace:
  002b0	8b d6		 mov	 edx, esi
$LN459@replace:
  002b2	85 c0		 test	 eax, eax
  002b4	74 22		 je	 SHORT $LN465@replace
  002b6	8b 5d 10	 mov	 ebx, DWORD PTR tv1814[ebp]
  002b9	03 c0		 add	 eax, eax
  002bb	50		 push	 eax
  002bc	8b 45 fc	 mov	 eax, DWORD PTR tv1842[ebp]
  002bf	8d 04 58	 lea	 eax, DWORD PTR [eax+ebx*2]
  002c2	50		 push	 eax
  002c3	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  002c6	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002c9	50		 push	 eax
  002ca	e8 00 00 00 00	 call	 _memmove
  002cf	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  002d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d5	8b 5d 14	 mov	 ebx, DWORD PTR __Roff$[ebp]
$LN465@replace:

; 1431 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1432 : 			_Traits::move(this->_Myptr() + _Off,

  002d8	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  002db	83 f8 08	 cmp	 eax, 8
  002de	72 07		 jb	 SHORT $LN478@replace
  002e0	8b 16		 mov	 edx, DWORD PTR [esi]
  002e2	89 55 14	 mov	 DWORD PTR tv1840[ebp], edx
  002e5	eb 03		 jmp	 SHORT $LN479@replace
$LN478@replace:
  002e7	89 75 14	 mov	 DWORD PTR tv1840[ebp], esi
$LN479@replace:
  002ea	83 f8 08	 cmp	 eax, 8
  002ed	72 04		 jb	 SHORT $LN492@replace
  002ef	8b 16		 mov	 edx, DWORD PTR [esi]
  002f1	eb 02		 jmp	 SHORT $LN493@replace
$LN492@replace:
  002f3	8b d6		 mov	 edx, esi
$LN493@replace:
  002f5	85 ff		 test	 edi, edi
  002f7	0f 84 d9 00 00
	00		 je	 $LN601@replace
  002fd	2b 5d 0c	 sub	 ebx, DWORD PTR __N0$[ebp]
  00300	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00303	50		 push	 eax
  00304	8b 45 14	 mov	 eax, DWORD PTR tv1840[ebp]
  00307	03 df		 add	 ebx, edi
  00309	8d 04 58	 lea	 eax, DWORD PTR [eax+ebx*2]
  0030c	50		 push	 eax
  0030d	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]

; 1433 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1434 : 				_Count);	// fill hole
; 1435 : 			}
; 1436 : 		else

  00310	e9 b8 00 00 00	 jmp	 $LN623@replace
$LN12@replace:

; 1437 : 			{	// hole gets larger, substring begins in hole
; 1438 : 			_Traits::move(this->_Myptr() + _Off,

  00315	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00318	83 f8 08	 cmp	 eax, 8
  0031b	72 0a		 jb	 SHORT $LN512@replace
  0031d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0031f	89 4d f8	 mov	 DWORD PTR tv1838[ebp], ecx
  00322	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00325	eb 03		 jmp	 SHORT $LN513@replace
$LN512@replace:
  00327	89 75 f8	 mov	 DWORD PTR tv1838[ebp], esi
$LN513@replace:
  0032a	83 f8 08	 cmp	 eax, 8
  0032d	72 07		 jb	 SHORT $LN526@replace
  0032f	8b 06		 mov	 eax, DWORD PTR [esi]
  00331	89 45 f4	 mov	 DWORD PTR tv1837[ebp], eax
  00334	eb 03		 jmp	 SHORT $LN527@replace
$LN526@replace:
  00336	89 75 f4	 mov	 DWORD PTR tv1837[ebp], esi
$LN527@replace:
  00339	85 d2		 test	 edx, edx
  0033b	74 1d		 je	 SHORT $LN533@replace
  0033d	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  00340	50		 push	 eax
  00341	8b 45 f8	 mov	 eax, DWORD PTR tv1838[ebp]
  00344	8d 04 58	 lea	 eax, DWORD PTR [eax+ebx*2]
  00347	50		 push	 eax
  00348	8b 45 f4	 mov	 eax, DWORD PTR tv1837[ebp]
  0034b	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  0034e	50		 push	 eax
  0034f	e8 00 00 00 00	 call	 _memmove
  00354	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00357	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN533@replace:

; 1439 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  0035a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0035d	83 f8 08	 cmp	 eax, 8
  00360	72 07		 jb	 SHORT $LN546@replace
  00362	8b 16		 mov	 edx, DWORD PTR [esi]
  00364	89 55 08	 mov	 DWORD PTR tv1836[ebp], edx
  00367	eb 03		 jmp	 SHORT $LN547@replace
$LN546@replace:
  00369	89 75 08	 mov	 DWORD PTR tv1836[ebp], esi
$LN547@replace:
  0036c	83 f8 08	 cmp	 eax, 8
  0036f	72 04		 jb	 SHORT $LN560@replace
  00371	8b 16		 mov	 edx, DWORD PTR [esi]
  00373	eb 02		 jmp	 SHORT $LN561@replace
$LN560@replace:
  00375	8b d6		 mov	 edx, esi
$LN561@replace:
  00377	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  0037a	85 c0		 test	 eax, eax
  0037c	74 1f		 je	 SHORT $LN567@replace
  0037e	8b 5d 10	 mov	 ebx, DWORD PTR tv1814[ebp]
  00381	03 c0		 add	 eax, eax
  00383	50		 push	 eax
  00384	8b 45 08	 mov	 eax, DWORD PTR tv1836[ebp]
  00387	8d 04 58	 lea	 eax, DWORD PTR [eax+ebx*2]
  0038a	50		 push	 eax
  0038b	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0038e	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00391	50		 push	 eax
  00392	e8 00 00 00 00	 call	 _memmove
  00397	8b 5d 14	 mov	 ebx, DWORD PTR __Roff$[ebp]
  0039a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN567@replace:

; 1441 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1442 : 			_Traits::move(this->_Myptr() + _Off + _N0,

  0039d	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  003a0	83 f8 08	 cmp	 eax, 8
  003a3	72 04		 jb	 SHORT $LN580@replace
  003a5	8b 16		 mov	 edx, DWORD PTR [esi]
  003a7	eb 02		 jmp	 SHORT $LN581@replace
$LN580@replace:
  003a9	8b d6		 mov	 edx, esi
$LN581@replace:
  003ab	83 f8 08	 cmp	 eax, 8
  003ae	72 04		 jb	 SHORT $LN594@replace
  003b0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003b2	eb 02		 jmp	 SHORT $LN595@replace
$LN594@replace:
  003b4	8b ce		 mov	 ecx, esi
$LN595@replace:
  003b6	8b c7		 mov	 eax, edi
  003b8	2b 45 0c	 sub	 eax, DWORD PTR __N0$[ebp]
  003bb	74 19		 je	 SHORT $LN601@replace
  003bd	03 c0		 add	 eax, eax
  003bf	50		 push	 eax
  003c0	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]
  003c3	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  003c6	50		 push	 eax
  003c7	8b 45 10	 mov	 eax, DWORD PTR tv1814[ebp]
  003ca	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
$LN623@replace:
  003cd	50		 push	 eax
  003ce	e8 00 00 00 00	 call	 _memmove
$LN624@replace:
  003d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN601@replace:

; 1443 : 				this->_Myptr() + _Roff + _Count,
; 1444 : 				_Count - _N0);	// fill rest of new hole
; 1445 : 			}
; 1446 : 
; 1447 : 		_Eos(_Newsize);

  003d6	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  003da	8b 4d 18	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]
  003dd	5f		 pop	 edi
  003de	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  003e1	5b		 pop	 ebx
  003e2	72 11		 jb	 SHORT $LN614@replace
  003e4	8b 06		 mov	 eax, DWORD PTR [esi]
  003e6	33 d2		 xor	 edx, edx
  003e8	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1448 : 		return (*this);

  003ec	8b c6		 mov	 eax, esi
  003ee	5e		 pop	 esi

; 1449 : 		}

  003ef	8b e5		 mov	 esp, ebp
  003f1	5d		 pop	 ebp
  003f2	c2 14 00	 ret	 20			; 00000014H

; 1443 : 				this->_Myptr() + _Roff + _Count,
; 1444 : 				_Count - _N0);	// fill rest of new hole
; 1445 : 			}
; 1446 : 
; 1447 : 		_Eos(_Newsize);

$LN614@replace:
  003f5	8b c6		 mov	 eax, esi
  003f7	33 d2		 xor	 edx, edx
  003f9	5e		 pop	 esi
  003fa	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1449 : 		}

  003fe	8b e5		 mov	 esp, ebp
  00400	5d		 pop	 ebp
  00401	c2 14 00	 ret	 20			; 00000014H
$LN625@replace:

; 1390 : 		_Check_offset(_Off);

  00404	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00409	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN630@replace:
$LN627@replace:

; 1391 : 		_Right._Check_offset(_Roff);

  0040e	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00413	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN631@replace:
$LN628@replace:

; 1395 : 			_Xlen();	// result too long

  00418	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0041d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN632@replace:
$LN629@replace:

; 1400 : 			_Grow(_Newsize);

  00422	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00427	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN633@replace:
$LN621@replace:
  0042c	cc		 int	 3
?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1348 : 		_Check_offset(_Off);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	0f 82 88 00 00
	00		 jb	 $LN95@erase

; 1349 : 		if (this->_Mysize() - _Off <= _Count)

  00015	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00018	8b c7		 mov	 eax, edi
  0001a	2b c1		 sub	 eax, ecx
  0001c	3b c2		 cmp	 eax, edx
  0001e	77 27		 ja	 SHORT $LN2@erase

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

  00020	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00023	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00027	72 10		 jb	 SHORT $LN41@erase
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	33 d2		 xor	 edx, edx
  0002d	5f		 pop	 edi
  0002e	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1357 : 			}
; 1358 : 		return (*this);

  00032	8b c6		 mov	 eax, esi
  00034	5e		 pop	 esi

; 1359 : 		}

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

$LN41@erase:
  00039	8b c6		 mov	 eax, esi
  0003b	33 d2		 xor	 edx, edx
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1359 : 		}

  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
$LN2@erase:

; 1351 : 		else if (0 < _Count)

  00047	85 d2		 test	 edx, edx
  00049	74 4a		 je	 SHORT $LN92@erase

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;

  0004b	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0004f	72 04		 jb	 SHORT $LN58@erase
  00051	8b 06		 mov	 eax, DWORD PTR [esi]
  00053	eb 02		 jmp	 SHORT $LN59@erase
$LN58@erase:
  00055	8b c6		 mov	 eax, esi
$LN59@erase:

; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

  00057	2b fa		 sub	 edi, edx
  00059	53		 push	 ebx
  0005a	8d 1c 48	 lea	 ebx, DWORD PTR [eax+ecx*2]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  0005d	8b c7		 mov	 eax, edi
  0005f	2b c1		 sub	 eax, ecx
  00061	74 10		 je	 SHORT $LN74@erase
  00063	03 c0		 add	 eax, eax
  00065	50		 push	 eax
  00066	8d 04 53	 lea	 eax, DWORD PTR [ebx+edx*2]
  00069	50		 push	 eax
  0006a	53		 push	 ebx
  0006b	e8 00 00 00 00	 call	 _memmove
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@erase:

; 1356 : 			_Eos(_Newsize);

  00073	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00077	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0007a	5b		 pop	 ebx
  0007b	72 10		 jb	 SHORT $LN87@erase
  0007d	8b 06		 mov	 eax, DWORD PTR [esi]
  0007f	33 c9		 xor	 ecx, ecx
  00081	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1357 : 			}
; 1358 : 		return (*this);

  00085	8b c6		 mov	 eax, esi
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 1359 : 		}

  00089	5d		 pop	 ebp
  0008a	c2 08 00	 ret	 8

; 1356 : 			_Eos(_Newsize);

$LN87@erase:
  0008d	8b c6		 mov	 eax, esi
  0008f	33 c9		 xor	 ecx, ecx
  00091	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN92@erase:

; 1357 : 			}
; 1358 : 		return (*this);

  00095	5f		 pop	 edi
  00096	8b c6		 mov	 eax, esi
  00098	5e		 pop	 esi

; 1359 : 		}

  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
$LN95@erase:

; 1348 : 		_Check_offset(_Off);

  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000a2	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN97@erase:
$LN94@erase:
  000a7	cc		 int	 3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1341 : 		_Check_offset(_Off);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	72 29		 jb	 SHORT $LN37@erase

; 1342 : 		_Eos(_Off);

  0000b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000e	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00012	72 10		 jb	 SHORT $LN29@erase
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	56		 push	 esi
  00017	33 f6		 xor	 esi, esi
  00019	66 89 34 42	 mov	 WORD PTR [edx+eax*2], si

; 1343 : 		return (*this);

  0001d	8b c1		 mov	 eax, ecx
  0001f	5e		 pop	 esi

; 1344 : 		}

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4

; 1342 : 		_Eos(_Off);

$LN29@erase:
  00024	8b d1		 mov	 edx, ecx
  00026	56		 push	 esi
  00027	33 f6		 xor	 esi, esi
  00029	66 89 34 42	 mov	 WORD PTR [edx+eax*2], si

; 1343 : 		return (*this);

  0002d	8b c1		 mov	 eax, ecx
  0002f	5e		 pop	 esi

; 1344 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN37@erase:

; 1341 : 		_Check_offset(_Off);

  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00039	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN39@erase:
$LN36@erase:
  0003e	cc		 int	 3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II_W@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
tv569 = 12						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 2
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert, COMDAT
; _this$ = ecx

; 1278 : 		{	// insert _Count * _Ch at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1279 : 		_Check_offset(_Off);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000e	3b ca		 cmp	 ecx, edx
  00010	0f 82 e1 00 00
	00		 jb	 $LN190@insert

; 1280 : 		if (npos - this->_Mysize() <= _Count)

  00016	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00019	8b c1		 mov	 eax, ecx
  0001b	f7 d0		 not	 eax
  0001d	3b c3		 cmp	 eax, ebx
  0001f	0f 86 dc 00 00
	00		 jbe	 $LN192@insert

; 1282 : 		const size_type _Num = this->_Mysize() + _Count;

  00025	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]

; 1283 : 		if (0 < _Count && _Grow(_Num))

  00028	85 db		 test	 ebx, ebx
  0002a	0f 84 be 00 00
	00		 je	 $LN185@insert
  00030	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00036	0f 87 cf 00 00
	00		 ja	 $LN193@insert
  0003c	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0003f	73 23		 jae	 SHORT $LN43@insert
  00041	51		 push	 ecx
  00042	57		 push	 edi
  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0004a	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  0004d	85 ff		 test	 edi, edi
  0004f	0f 84 99 00 00
	00		 je	 $LN185@insert
$LN189@insert:

; 1284 : 			{	// make room and insert new stuff
; 1285 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00055	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00058	83 f8 08	 cmp	 eax, 8
  0005b	72 32		 jb	 SHORT $LN146@insert
  0005d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005f	89 4d 0c	 mov	 DWORD PTR tv569[ebp], ecx
  00062	eb 2e		 jmp	 SHORT $LN147@insert

; 1283 : 		if (0 < _Count && _Grow(_Num))

$LN43@insert:
  00064	85 ff		 test	 edi, edi
  00066	75 ed		 jne	 SHORT $LN189@insert
  00068	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0006b	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0006f	72 10		 jb	 SHORT $LN120@insert
  00071	8b 06		 mov	 eax, DWORD PTR [esi]
  00073	33 c9		 xor	 ecx, ecx
  00075	5f		 pop	 edi
  00076	66 89 08	 mov	 WORD PTR [eax], cx

; 1290 : 			}
; 1291 : 		return (*this);

  00079	8b c6		 mov	 eax, esi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx

; 1292 : 		}

  0007d	5d		 pop	 ebp
  0007e	c2 0c 00	 ret	 12			; 0000000cH

; 1283 : 		if (0 < _Count && _Grow(_Num))

$LN120@insert:
  00081	8b c6		 mov	 eax, esi
  00083	33 c9		 xor	 ecx, ecx
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	66 89 08	 mov	 WORD PTR [eax], cx

; 1292 : 		}

  0008b	5d		 pop	 ebp
  0008c	c2 0c 00	 ret	 12			; 0000000cH

; 1284 : 			{	// make room and insert new stuff
; 1285 : 			_Traits::move(this->_Myptr() + _Off + _Count,

$LN146@insert:
  0008f	89 75 0c	 mov	 DWORD PTR tv569[ebp], esi
$LN147@insert:
  00092	83 f8 08	 cmp	 eax, 8
  00095	72 04		 jb	 SHORT $LN160@insert
  00097	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00099	eb 02		 jmp	 SHORT $LN161@insert
$LN160@insert:
  0009b	8b ce		 mov	 ecx, esi
$LN161@insert:
  0009d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000a0	2b c2		 sub	 eax, edx
  000a2	74 1c		 je	 SHORT $LN167@insert
  000a4	03 c0		 add	 eax, eax
  000a6	50		 push	 eax
  000a7	8b 45 0c	 mov	 eax, DWORD PTR tv569[ebp]
  000aa	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  000ad	50		 push	 eax
  000ae	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  000b1	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 _memmove
  000ba	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN167@insert:

; 1286 : 				this->_Myptr() + _Off,
; 1287 : 				this->_Mysize() - _Off);	// empty out hole
; 1288 : 			_Chassign(_Off, _Count, _Ch);	// fill hole

  000c0	ff 75 10	 push	 DWORD PTR __Ch$[ebp]
  000c3	8b ce		 mov	 ecx, esi
  000c5	53		 push	 ebx
  000c6	52		 push	 edx
  000c7	e8 00 00 00 00	 call	 ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Chassign

; 1289 : 			_Eos(_Num);

  000cc	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000d0	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000d3	72 11		 jb	 SHORT $LN180@insert
  000d5	8b 06		 mov	 eax, DWORD PTR [esi]
  000d7	33 c9		 xor	 ecx, ecx
  000d9	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1290 : 			}
; 1291 : 		return (*this);

  000dd	8b c6		 mov	 eax, esi
  000df	5f		 pop	 edi
  000e0	5e		 pop	 esi
  000e1	5b		 pop	 ebx

; 1292 : 		}

  000e2	5d		 pop	 ebp
  000e3	c2 0c 00	 ret	 12			; 0000000cH

; 1289 : 			_Eos(_Num);

$LN180@insert:
  000e6	8b c6		 mov	 eax, esi
  000e8	33 c9		 xor	 ecx, ecx
  000ea	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN185@insert:

; 1290 : 			}
; 1291 : 		return (*this);

  000ee	5f		 pop	 edi
  000ef	8b c6		 mov	 eax, esi
  000f1	5e		 pop	 esi
  000f2	5b		 pop	 ebx

; 1292 : 		}

  000f3	5d		 pop	 ebp
  000f4	c2 0c 00	 ret	 12			; 0000000cH
$LN190@insert:

; 1279 : 		_Check_offset(_Off);

  000f7	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000fc	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN194@insert:
$LN192@insert:

; 1281 : 			_Xlen();	// result too long

  00101	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00106	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN195@insert:
$LN193@insert:

; 1283 : 		if (0 < _Count && _Grow(_Num))

  0010b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00110	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN196@insert:
$LN187@insert:
  00115	cc		 int	 3
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_W@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert, COMDAT
; _this$ = ecx

; 1271 : 		{	// insert [_Ptr, <null>) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1272 : 		_DEBUG_POINTER(_Ptr);
; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  0000b	75 11		 jne	 SHORT $LN5@insert
  0000d	33 d2		 xor	 edx, edx
  0000f	52		 push	 edx
  00010	56		 push	 esi
  00011	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00014	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
  00019	5e		 pop	 esi

; 1274 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8

; 1272 : 		_DEBUG_POINTER(_Ptr);
; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

$LN5@insert:
  0001e	8b d6		 mov	 edx, esi
  00020	57		 push	 edi
  00021	8d 7a 02	 lea	 edi, DWORD PTR [edx+2]
$LL7@insert:
  00024	66 8b 02	 mov	 ax, WORD PTR [edx]
  00027	83 c2 02	 add	 edx, 2
  0002a	66 85 c0	 test	 ax, ax
  0002d	75 f5		 jne	 SHORT $LL7@insert
  0002f	2b d7		 sub	 edx, edi
  00031	5f		 pop	 edi
  00032	d1 fa		 sar	 edx, 1
  00034	52		 push	 edx
  00035	56		 push	 esi
  00036	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00039	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
  0003e	5e		 pop	 esi

; 1274 : 		}

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z
_TEXT	SEGMENT
tv794 = -4						; size = 4
__Off$ = 8						; size = 4
tv795 = 12						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert, COMDAT
; _this$ = ecx

; 1250 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1251 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1252 : 		if (_Inside(_Ptr))

  00006	8b 7d 0c	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	85 ff		 test	 edi, edi
  0000d	74 4d		 je	 SHORT $LN2@insert
  0000f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00012	83 f9 08	 cmp	 ecx, 8
  00015	72 04		 jb	 SHORT $LN21@insert
  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	eb 02		 jmp	 SHORT $LN22@insert
$LN21@insert:
  0001b	8b c6		 mov	 eax, esi
$LN22@insert:
  0001d	3b f8		 cmp	 edi, eax
  0001f	72 3b		 jb	 SHORT $LN2@insert
  00021	83 f9 08	 cmp	 ecx, 8
  00024	72 04		 jb	 SHORT $LN35@insert
  00026	8b 16		 mov	 edx, DWORD PTR [esi]
  00028	eb 02		 jmp	 SHORT $LN36@insert
$LN35@insert:
  0002a	8b d6		 mov	 edx, esi
$LN36@insert:
  0002c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002f	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00032	3b c7		 cmp	 eax, edi
  00034	76 26		 jbe	 SHORT $LN2@insert

; 1253 : 			return (insert(_Off, *this,

  00036	83 f9 08	 cmp	 ecx, 8
  00039	72 04		 jb	 SHORT $LN58@insert
  0003b	8b 06		 mov	 eax, DWORD PTR [esi]
  0003d	eb 02		 jmp	 SHORT $LN59@insert
$LN58@insert:
  0003f	8b c6		 mov	 eax, esi
$LN59@insert:
  00041	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00044	2b f8		 sub	 edi, eax
  00046	8b ce		 mov	 ecx, esi
  00048	d1 ff		 sar	 edi, 1
  0004a	57		 push	 edi
  0004b	56		 push	 esi
  0004c	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  0004f	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi

; 1268 : 		}

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 0c 00	 ret	 12			; 0000000cH
$LN2@insert:

; 1254 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1255 : 		_Check_offset(_Off);

  0005c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0005f	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  00062	0f 82 0b 01 00
	00		 jb	 $LN268@insert

; 1256 : 		if (npos - this->_Mysize() <= _Count)

  00068	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  0006b	8b c1		 mov	 eax, ecx
  0006d	f7 d0		 not	 eax
  0006f	3b c2		 cmp	 eax, edx
  00071	0f 86 06 01 00
	00		 jbe	 $LN270@insert

; 1258 : 		const size_type _Num = this->_Mysize() + _Count;

  00077	53		 push	 ebx
  00078	8d 1c 11	 lea	 ebx, DWORD PTR [ecx+edx]

; 1259 : 		if (0 < _Count && _Grow(_Num))

  0007b	85 d2		 test	 edx, edx
  0007d	0f 84 e5 00 00
	00		 je	 $LN262@insert
  00083	81 fb fe ff ff
	7f		 cmp	 ebx, 2147483646		; 7ffffffeH
  00089	0f 87 f8 00 00
	00		 ja	 $LN271@insert
  0008f	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00092	73 23		 jae	 SHORT $LN100@insert
  00094	51		 push	 ecx
  00095	53		 push	 ebx
  00096	8b ce		 mov	 ecx, esi
  00098	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0009d	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  000a0	85 db		 test	 ebx, ebx
  000a2	0f 84 c0 00 00
	00		 je	 $LN262@insert
$LN267@insert:

; 1260 : 			{	// make room and insert new stuff
; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  000a8	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000ab	83 f8 08	 cmp	 eax, 8
  000ae	72 36		 jb	 SHORT $LN203@insert
  000b0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b2	89 4d 0c	 mov	 DWORD PTR tv795[ebp], ecx
  000b5	eb 32		 jmp	 SHORT $LN204@insert

; 1259 : 		if (0 < _Count && _Grow(_Num))

$LN100@insert:
  000b7	85 db		 test	 ebx, ebx
  000b9	75 ed		 jne	 SHORT $LN267@insert
  000bb	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000be	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000c2	72 12		 jb	 SHORT $LN177@insert
  000c4	8b 06		 mov	 eax, DWORD PTR [esi]
  000c6	33 c9		 xor	 ecx, ecx
  000c8	5b		 pop	 ebx
  000c9	5f		 pop	 edi
  000ca	66 89 08	 mov	 WORD PTR [eax], cx

; 1266 : 			}
; 1267 : 		return (*this);

  000cd	8b c6		 mov	 eax, esi
  000cf	5e		 pop	 esi

; 1268 : 		}

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 0c 00	 ret	 12			; 0000000cH

; 1259 : 		if (0 < _Count && _Grow(_Num))

$LN177@insert:
  000d6	8b c6		 mov	 eax, esi
  000d8	33 c9		 xor	 ecx, ecx
  000da	5b		 pop	 ebx
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	66 89 08	 mov	 WORD PTR [eax], cx

; 1268 : 		}

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 0c 00	 ret	 12			; 0000000cH

; 1260 : 			{	// make room and insert new stuff
; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

$LN203@insert:
  000e6	89 75 0c	 mov	 DWORD PTR tv795[ebp], esi
$LN204@insert:
  000e9	83 f8 08	 cmp	 eax, 8
  000ec	72 07		 jb	 SHORT $LN217@insert
  000ee	8b 06		 mov	 eax, DWORD PTR [esi]
  000f0	89 45 fc	 mov	 DWORD PTR tv794[ebp], eax
  000f3	eb 03		 jmp	 SHORT $LN218@insert
$LN217@insert:
  000f5	89 75 fc	 mov	 DWORD PTR tv794[ebp], esi
$LN218@insert:
  000f8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  000fe	2b c1		 sub	 eax, ecx
  00100	74 1f		 je	 SHORT $LN224@insert
  00102	03 c0		 add	 eax, eax
  00104	50		 push	 eax
  00105	8b 45 0c	 mov	 eax, DWORD PTR tv795[ebp]
  00108	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  0010b	50		 push	 eax
  0010c	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  0010f	8b 4d fc	 mov	 ecx, DWORD PTR tv794[ebp]
  00112	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 _memmove
  0011b	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0011e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN224@insert:

; 1262 : 				this->_Myptr() + _Off,
; 1263 : 				this->_Mysize() - _Off);	// empty out hole
; 1264 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

  00121	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00125	72 04		 jb	 SHORT $LN237@insert
  00127	8b 16		 mov	 edx, DWORD PTR [esi]
  00129	eb 02		 jmp	 SHORT $LN238@insert
$LN237@insert:
  0012b	8b d6		 mov	 edx, esi
$LN238@insert:
  0012d	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00130	85 c0		 test	 eax, eax
  00132	74 10		 je	 SHORT $LN244@insert
  00134	03 c0		 add	 eax, eax
  00136	50		 push	 eax
  00137	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0013a	57		 push	 edi
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _memcpy
  00141	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN244@insert:

; 1265 : 			_Eos(_Num);

  00144	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00148	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  0014b	72 13		 jb	 SHORT $LN257@insert
  0014d	8b 06		 mov	 eax, DWORD PTR [esi]
  0014f	33 c9		 xor	 ecx, ecx
  00151	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx

; 1266 : 			}
; 1267 : 		return (*this);

  00155	8b c6		 mov	 eax, esi
  00157	5b		 pop	 ebx
  00158	5f		 pop	 edi
  00159	5e		 pop	 esi

; 1268 : 		}

  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c2 0c 00	 ret	 12			; 0000000cH

; 1265 : 			_Eos(_Num);

$LN257@insert:
  00160	8b c6		 mov	 eax, esi
  00162	33 c9		 xor	 ecx, ecx
  00164	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx
$LN262@insert:

; 1266 : 			}
; 1267 : 		return (*this);

  00168	5b		 pop	 ebx
  00169	5f		 pop	 edi
  0016a	8b c6		 mov	 eax, esi
  0016c	5e		 pop	 esi

; 1268 : 		}

  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c2 0c 00	 ret	 12			; 0000000cH
$LN268@insert:

; 1254 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1255 : 		_Check_offset(_Off);

  00173	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00178	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN272@insert:
$LN270@insert:

; 1257 : 			_Xlen();	// result too long

  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00182	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN273@insert:
$LN271@insert:

; 1259 : 		if (0 < _Count && _Grow(_Num))

  00187	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0018c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN274@insert:
$LN265@insert:
  00191	cc		 int	 3
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z
_TEXT	SEGMENT
tv845 = 8						; size = 4
tv843 = 8						; size = 4
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
tv846 = 16						; size = 4
__Roff$ = 16						; size = 4
tv848 = 20						; size = 4
__Count$ = 20						; size = 4
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert, COMDAT
; _this$ = ecx

; 1223 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 1224 : 		_Check_offset(_Off);

  00008	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000b	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  0000e	0f 82 76 01 00
	00		 jb	 $LN291@insert

; 1225 : 		_Right._Check_offset(_Roff);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00017	8b 55 10	 mov	 edx, DWORD PTR __Roff$[ebp]
  0001a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0001d	3b c2		 cmp	 eax, edx
  0001f	0f 82 6f 01 00
	00		 jb	 $LN293@insert

; 1226 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00025	8b 7d 14	 mov	 edi, DWORD PTR __Count$[ebp]
  00028	2b c2		 sub	 eax, edx
  0002a	3b f8		 cmp	 edi, eax
  0002c	0f 47 f8	 cmova	 edi, eax

; 1227 : 		if (npos - this->_Mysize() <= _Count)

  0002f	8b c1		 mov	 eax, ecx
  00031	f7 d0		 not	 eax
  00033	3b c7		 cmp	 eax, edi
  00035	0f 86 63 01 00
	00		 jbe	 $LN294@insert

; 1229 : 
; 1230 : 		const size_type _Num = this->_Mysize() + _Count;

  0003b	8d 1c 39	 lea	 ebx, DWORD PTR [ecx+edi]

; 1231 : 		if (0 < _Count && _Grow(_Num))

  0003e	85 ff		 test	 edi, edi
  00040	0f 84 3b 01 00
	00		 je	 $LN285@insert
  00046	81 fb fe ff ff
	7f		 cmp	 ebx, 2147483646		; 7ffffffeH
  0004c	0f 87 56 01 00
	00		 ja	 $LN295@insert
  00052	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00055	73 20		 jae	 SHORT $LN75@insert
  00057	51		 push	 ecx
  00058	53		 push	 ebx
  00059	8b ce		 mov	 ecx, esi
  0005b	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00060	85 db		 test	 ebx, ebx
  00062	0f 84 19 01 00
	00		 je	 $LN285@insert
$LN289@insert:

; 1232 : 			{	// make room and insert new stuff
; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00068	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0006b	83 f8 08	 cmp	 eax, 8
  0006e	72 32		 jb	 SHORT $LN178@insert
  00070	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00072	89 4d 14	 mov	 DWORD PTR tv848[ebp], ecx
  00075	eb 2e		 jmp	 SHORT $LN179@insert

; 1231 : 		if (0 < _Count && _Grow(_Num))

$LN75@insert:
  00077	85 db		 test	 ebx, ebx
  00079	75 ed		 jne	 SHORT $LN289@insert
  0007b	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  0007e	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00082	72 10		 jb	 SHORT $LN152@insert
  00084	8b 06		 mov	 eax, DWORD PTR [esi]
  00086	33 c9		 xor	 ecx, ecx
  00088	5f		 pop	 edi
  00089	66 89 08	 mov	 WORD PTR [eax], cx

; 1244 : 			}
; 1245 : 		return (*this);

  0008c	8b c6		 mov	 eax, esi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx

; 1246 : 		}

  00090	5d		 pop	 ebp
  00091	c2 10 00	 ret	 16			; 00000010H

; 1231 : 		if (0 < _Count && _Grow(_Num))

$LN152@insert:
  00094	8b c6		 mov	 eax, esi
  00096	33 c9		 xor	 ecx, ecx
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx
  0009b	66 89 08	 mov	 WORD PTR [eax], cx

; 1246 : 		}

  0009e	5d		 pop	 ebp
  0009f	c2 10 00	 ret	 16			; 00000010H

; 1232 : 			{	// make room and insert new stuff
; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

$LN178@insert:
  000a2	89 75 14	 mov	 DWORD PTR tv848[ebp], esi
$LN179@insert:
  000a5	83 f8 08	 cmp	 eax, 8
  000a8	72 04		 jb	 SHORT $LN192@insert
  000aa	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000ac	eb 02		 jmp	 SHORT $LN193@insert
$LN192@insert:
  000ae	8b ce		 mov	 ecx, esi
$LN193@insert:
  000b0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b3	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000b6	2b c2		 sub	 eax, edx
  000b8	74 1c		 je	 SHORT $LN199@insert
  000ba	03 c0		 add	 eax, eax
  000bc	50		 push	 eax
  000bd	8b 45 14	 mov	 eax, DWORD PTR tv848[ebp]
  000c0	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  000c3	50		 push	 eax
  000c4	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  000c7	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _memmove
  000d0	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN199@insert:

; 1234 : 				this->_Myptr() + _Off,
; 1235 : 				this->_Mysize() - _Off);	// empty out hole
; 1236 : 			if (this == &_Right)

  000d6	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  000d9	3b f1		 cmp	 esi, ecx
  000db	75 4c		 jne	 SHORT $LN4@insert

; 1237 : 				_Traits::move(this->_Myptr() + _Off,

  000dd	8b 45 10	 mov	 eax, DWORD PTR __Roff$[ebp]
  000e0	3b d0		 cmp	 edx, eax
  000e2	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  000e5	0f 43 c8	 cmovae	 ecx, eax
  000e8	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000eb	83 f8 08	 cmp	 eax, 8
  000ee	72 0a		 jb	 SHORT $LN212@insert
  000f0	8b 16		 mov	 edx, DWORD PTR [esi]
  000f2	89 55 10	 mov	 DWORD PTR tv846[ebp], edx
  000f5	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000f8	eb 03		 jmp	 SHORT $LN213@insert
$LN212@insert:
  000fa	89 75 10	 mov	 DWORD PTR tv846[ebp], esi
$LN213@insert:
  000fd	83 f8 08	 cmp	 eax, 8
  00100	72 07		 jb	 SHORT $LN226@insert
  00102	8b 06		 mov	 eax, DWORD PTR [esi]
  00104	89 45 08	 mov	 DWORD PTR tv845[ebp], eax
  00107	eb 03		 jmp	 SHORT $LN227@insert
$LN226@insert:
  00109	89 75 08	 mov	 DWORD PTR tv845[ebp], esi
$LN227@insert:
  0010c	85 ff		 test	 edi, edi
  0010e	74 4f		 je	 SHORT $LN267@insert
  00110	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00113	50		 push	 eax
  00114	8b 45 10	 mov	 eax, DWORD PTR tv846[ebp]
  00117	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  0011a	50		 push	 eax
  0011b	8b 45 08	 mov	 eax, DWORD PTR tv845[ebp]
  0011e	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 _memmove

; 1238 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1239 : 						_Count);	// substring
; 1240 : 			else

  00127	eb 33		 jmp	 SHORT $LN290@insert
$LN4@insert:

; 1241 : 				_Traits::copy(this->_Myptr() + _Off,

  00129	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  0012d	72 02		 jb	 SHORT $LN246@insert
  0012f	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN246@insert:
  00131	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00135	72 07		 jb	 SHORT $LN260@insert
  00137	8b 06		 mov	 eax, DWORD PTR [esi]
  00139	89 45 08	 mov	 DWORD PTR tv843[ebp], eax
  0013c	eb 03		 jmp	 SHORT $LN261@insert
$LN260@insert:
  0013e	89 75 08	 mov	 DWORD PTR tv843[ebp], esi
$LN261@insert:
  00141	85 ff		 test	 edi, edi
  00143	74 1a		 je	 SHORT $LN267@insert
  00145	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00148	50		 push	 eax
  00149	8b 45 10	 mov	 eax, DWORD PTR __Roff$[ebp]
  0014c	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0014f	50		 push	 eax
  00150	8b 45 08	 mov	 eax, DWORD PTR tv843[ebp]
  00153	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 _memcpy
$LN290@insert:
  0015c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN267@insert:

; 1242 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1243 : 			_Eos(_Num);

  0015f	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00163	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00166	72 11		 jb	 SHORT $LN280@insert
  00168	8b 06		 mov	 eax, DWORD PTR [esi]
  0016a	33 c9		 xor	 ecx, ecx
  0016c	5f		 pop	 edi
  0016d	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx

; 1244 : 			}
; 1245 : 		return (*this);

  00171	8b c6		 mov	 eax, esi
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx

; 1246 : 		}

  00175	5d		 pop	 ebp
  00176	c2 10 00	 ret	 16			; 00000010H

; 1242 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1243 : 			_Eos(_Num);

$LN280@insert:
  00179	8b c6		 mov	 eax, esi
  0017b	33 c9		 xor	 ecx, ecx
  0017d	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx
$LN285@insert:

; 1244 : 			}
; 1245 : 		return (*this);

  00181	5f		 pop	 edi
  00182	8b c6		 mov	 eax, esi
  00184	5e		 pop	 esi
  00185	5b		 pop	 ebx

; 1246 : 		}

  00186	5d		 pop	 ebp
  00187	c2 10 00	 ret	 16			; 00000010H
$LN291@insert:

; 1224 : 		_Check_offset(_Off);

  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0018f	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN296@insert:
$LN293@insert:

; 1225 : 		_Right._Check_offset(_Roff);

  00194	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00199	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN297@insert:
$LN294@insert:

; 1228 : 			_Xlen();	// result too long

  0019e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  001a3	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN298@insert:
$LN295@insert:

; 1231 : 		if (0 < _Count && _Grow(_Num))

  001a8	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  001ad	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN299@insert:
$LN287@insert:
  001b2	cc		 int	 3
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 2
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1186 : 		{	// assign _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1187 : 		if (_Count == npos)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	83 ff ff	 cmp	 edi, -1
  0000d	74 79		 je	 SHORT $LN114@assign

; 1189 : 
; 1190 : 		if (_Grow(_Count))

  0000f	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00015	77 7b		 ja	 SHORT $LN116@assign
  00017	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0001a	73 33		 jae	 SHORT $LN10@assign
  0001c	ff 76 10	 push	 DWORD PTR [esi+16]
  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00025	85 ff		 test	 edi, edi
  00027	74 57		 je	 SHORT $LN109@assign
$LN113@assign:

; 1191 : 			{	// make room and assign new stuff
; 1192 : 			_Chassign(0, _Count, _Ch);

  00029	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  0002c	8b ce		 mov	 ecx, esi
  0002e	57		 push	 edi
  0002f	6a 00		 push	 0
  00031	e8 00 00 00 00	 call	 ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Chassign

; 1193 : 			_Eos(_Count);

  00036	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0003a	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0003d	72 39		 jb	 SHORT $LN104@assign
  0003f	8b 06		 mov	 eax, DWORD PTR [esi]
  00041	33 c9		 xor	 ecx, ecx
  00043	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1194 : 			}
; 1195 : 		return (*this);

  00047	8b c6		 mov	 eax, esi
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi

; 1196 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8

; 1189 : 
; 1190 : 		if (_Grow(_Count))

$LN10@assign:
  0004f	85 ff		 test	 edi, edi
  00051	75 d6		 jne	 SHORT $LN113@assign
  00053	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00057	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0005a	72 0f		 jb	 SHORT $LN87@assign
  0005c	8b 06		 mov	 eax, DWORD PTR [esi]
  0005e	33 c9		 xor	 ecx, ecx
  00060	5f		 pop	 edi
  00061	66 89 08	 mov	 WORD PTR [eax], cx

; 1194 : 			}
; 1195 : 		return (*this);

  00064	8b c6		 mov	 eax, esi
  00066	5e		 pop	 esi

; 1196 : 		}

  00067	5d		 pop	 ebp
  00068	c2 08 00	 ret	 8

; 1189 : 
; 1190 : 		if (_Grow(_Count))

$LN87@assign:
  0006b	8b c6		 mov	 eax, esi
  0006d	33 c9		 xor	 ecx, ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	66 89 08	 mov	 WORD PTR [eax], cx

; 1196 : 		}

  00074	5d		 pop	 ebp
  00075	c2 08 00	 ret	 8

; 1193 : 			_Eos(_Count);

$LN104@assign:
  00078	8b c6		 mov	 eax, esi
  0007a	33 c9		 xor	 ecx, ecx
  0007c	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN109@assign:

; 1194 : 			}
; 1195 : 		return (*this);

  00080	5f		 pop	 edi
  00081	8b c6		 mov	 eax, esi
  00083	5e		 pop	 esi

; 1196 : 		}

  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
$LN114@assign:

; 1188 : 			_Xlen();	// result too long

  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0008d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN117@assign:
$LN116@assign:

; 1189 : 
; 1190 : 		if (_Grow(_Count))

  00092	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00097	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN118@assign:
$LN111@assign:
  0009c	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000d	75 0e		 jne	 SHORT $LN5@assign
  0000f	33 c0		 xor	 eax, eax
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00018	5e		 pop	 esi

; 1183 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

$LN5@assign:
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL7@assign:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL7@assign
  0002e	2b c7		 sub	 eax, edi
  00030	8b ce		 mov	 ecx, esi
  00032	5f		 pop	 edi
  00033	d1 f8		 sar	 eax, 1
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0003c	5e		 pop	 esi

; 1183 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1166 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1167 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 48		 je	 SHORT $LN2@assign
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 08	 cmp	 ecx, 8
  00014	72 04		 jb	 SHORT $LN20@assign
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN21@assign
$LN20@assign:
  0001a	8b c6		 mov	 eax, esi
$LN21@assign:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 36		 jb	 SHORT $LN2@assign
  00020	83 f9 08	 cmp	 ecx, 8
  00023	72 04		 jb	 SHORT $LN34@assign
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN35@assign
$LN34@assign:
  00029	8b d6		 mov	 edx, esi
$LN35@assign:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00031	3b c3		 cmp	 eax, ebx
  00033	76 21		 jbe	 SHORT $LN2@assign

; 1168 : 			return (assign(*this,

  00035	83 f9 08	 cmp	 ecx, 8
  00038	72 04		 jb	 SHORT $LN57@assign
  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	eb 02		 jmp	 SHORT $LN58@assign
$LN57@assign:
  0003e	8b c6		 mov	 eax, esi
$LN58@assign:
  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	2b d8		 sub	 ebx, eax
  00045	8b ce		 mov	 ecx, esi
  00047	d1 fb		 sar	 ebx, 1
  00049	53		 push	 ebx
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 1177 : 		}

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN2@assign:
  00056	57		 push	 edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  00057	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0005a	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00060	0f 87 88 00 00
	00		 ja	 $LN189@assign
  00066	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00069	73 19		 jae	 SHORT $LN63@assign
  0006b	ff 76 10	 push	 DWORD PTR [esi+16]
  0006e	8b ce		 mov	 ecx, esi
  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00076	85 ff		 test	 edi, edi
  00078	74 6b		 je	 SHORT $LN183@assign
$LN188@assign:

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  0007a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0007e	72 2f		 jb	 SHORT $LN158@assign
  00080	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00082	eb 2d		 jmp	 SHORT $LN159@assign

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN63@assign:
  00084	85 ff		 test	 edi, edi
  00086	75 f2		 jne	 SHORT $LN188@assign
  00088	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0008c	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0008f	72 10		 jb	 SHORT $LN140@assign
  00091	8b 06		 mov	 eax, DWORD PTR [esi]
  00093	33 c9		 xor	 ecx, ecx
  00095	5f		 pop	 edi
  00096	66 89 08	 mov	 WORD PTR [eax], cx

; 1175 : 			}
; 1176 : 		return (*this);

  00099	8b c6		 mov	 eax, esi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx

; 1177 : 		}

  0009d	5d		 pop	 ebp
  0009e	c2 08 00	 ret	 8

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN140@assign:
  000a1	8b c6		 mov	 eax, esi
  000a3	33 c9		 xor	 ecx, ecx
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx
  000a8	66 89 08	 mov	 WORD PTR [eax], cx

; 1177 : 		}

  000ab	5d		 pop	 ebp
  000ac	c2 08 00	 ret	 8

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

$LN158@assign:
  000af	8b ce		 mov	 ecx, esi
$LN159@assign:
  000b1	85 ff		 test	 edi, edi
  000b3	74 0e		 je	 SHORT $LN165@assign
  000b5	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  000b8	50		 push	 eax
  000b9	53		 push	 ebx
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 _memcpy
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN165@assign:

; 1174 : 			_Eos(_Count);

  000c3	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000c7	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ca	72 11		 jb	 SHORT $LN178@assign
  000cc	8b 06		 mov	 eax, DWORD PTR [esi]
  000ce	33 c9		 xor	 ecx, ecx
  000d0	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1175 : 			}
; 1176 : 		return (*this);

  000d4	8b c6		 mov	 eax, esi
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx

; 1177 : 		}

  000d9	5d		 pop	 ebp
  000da	c2 08 00	 ret	 8

; 1174 : 			_Eos(_Count);

$LN178@assign:
  000dd	8b c6		 mov	 eax, esi
  000df	33 c9		 xor	 ecx, ecx
  000e1	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN183@assign:

; 1175 : 			}
; 1176 : 		return (*this);

  000e5	5f		 pop	 edi
  000e6	8b c6		 mov	 eax, esi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx

; 1177 : 		}

  000ea	5d		 pop	 ebp
  000eb	c2 08 00	 ret	 8
$LN189@assign:

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f3	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN191@assign:
$LN186@assign:
  000f8	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1150 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 e3 00 00
	00		 jb	 $LN210@assign

; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00019	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
  0001c	2b c1		 sub	 eax, ecx
  0001e	3b f8		 cmp	 edi, eax
  00020	0f 47 f8	 cmova	 edi, eax

; 1152 : 
; 1153 : 		if (this == &_Right)

  00023	3b f3		 cmp	 esi, ebx
  00025	75 33		 jne	 SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  0002d	0f 82 d3 00 00
	00		 jb	 $LN212@assign
  00033	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00036	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0003a	72 04		 jb	 SHORT $LN63@assign
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	eb 02		 jmp	 SHORT $LN64@assign
$LN63@assign:
  00040	8b d6		 mov	 edx, esi
$LN64@assign:
  00042	33 ff		 xor	 edi, edi
  00044	51		 push	 ecx
  00045	57		 push	 edi
  00046	8b ce		 mov	 ecx, esi
  00048	66 89 3c 42	 mov	 WORD PTR [edx+eax*2], di
  0004c	e8 00 00 00 00	 call	 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
  00051	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  00052	8b c6		 mov	 eax, esi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx

; 1162 : 		}

  00056	5d		 pop	 ebp
  00057	c2 0c 00	 ret	 12			; 0000000cH
$LN2@assign:

; 1155 : 		else if (_Grow(_Count))

  0005a	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00060	0f 87 aa 00 00
	00		 ja	 $LN213@assign
  00066	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00069	73 24		 jae	 SHORT $LN72@assign
  0006b	ff 76 10	 push	 DWORD PTR [esi+16]
  0006e	8b ce		 mov	 ecx, esi
  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00076	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  00079	85 ff		 test	 edi, edi
  0007b	74 76		 je	 SHORT $LN205@assign
$LN209@assign:

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

  0007d	83 7b 14 08	 cmp	 DWORD PTR [ebx+20], 8
  00081	72 02		 jb	 SHORT $LN166@assign
  00083	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN166@assign:
  00085	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00089	72 2f		 jb	 SHORT $LN180@assign
  0008b	8b 16		 mov	 edx, DWORD PTR [esi]
  0008d	eb 2d		 jmp	 SHORT $LN181@assign

; 1155 : 		else if (_Grow(_Count))

$LN72@assign:
  0008f	85 ff		 test	 edi, edi
  00091	75 ea		 jne	 SHORT $LN209@assign
  00093	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00097	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0009a	72 10		 jb	 SHORT $LN149@assign
  0009c	8b 06		 mov	 eax, DWORD PTR [esi]
  0009e	33 c9		 xor	 ecx, ecx
  000a0	5f		 pop	 edi
  000a1	66 89 08	 mov	 WORD PTR [eax], cx

; 1160 : 			}
; 1161 : 		return (*this);

  000a4	8b c6		 mov	 eax, esi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx

; 1162 : 		}

  000a8	5d		 pop	 ebp
  000a9	c2 0c 00	 ret	 12			; 0000000cH

; 1155 : 		else if (_Grow(_Count))

$LN149@assign:
  000ac	8b c6		 mov	 eax, esi
  000ae	33 c9		 xor	 ecx, ecx
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	66 89 08	 mov	 WORD PTR [eax], cx

; 1162 : 		}

  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

$LN180@assign:
  000ba	8b d6		 mov	 edx, esi
$LN181@assign:
  000bc	85 ff		 test	 edi, edi
  000be	74 11		 je	 SHORT $LN187@assign
  000c0	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  000c3	50		 push	 eax
  000c4	8d 04 4b	 lea	 eax, DWORD PTR [ebx+ecx*2]
  000c7	50		 push	 eax
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 _memcpy
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN187@assign:

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

  000d1	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000d5	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000d8	72 11		 jb	 SHORT $LN200@assign
  000da	8b 06		 mov	 eax, DWORD PTR [esi]
  000dc	33 c9		 xor	 ecx, ecx
  000de	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1160 : 			}
; 1161 : 		return (*this);

  000e2	8b c6		 mov	 eax, esi
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 1162 : 		}

  000e7	5d		 pop	 ebp
  000e8	c2 0c 00	 ret	 12			; 0000000cH

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

$LN200@assign:
  000eb	8b c6		 mov	 eax, esi
  000ed	33 c9		 xor	 ecx, ecx
  000ef	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN205@assign:

; 1160 : 			}
; 1161 : 		return (*this);

  000f3	5f		 pop	 edi
  000f4	8b c6		 mov	 eax, esi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx

; 1162 : 		}

  000f8	5d		 pop	 ebp
  000f9	c2 0c 00	 ret	 12			; 0000000cH
$LN210@assign:

; 1150 : 		_Right._Check_offset(_Roff);

  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00101	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN214@assign:
$LN212@assign:

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0010b	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN215@assign:
$LN213@assign:

; 1155 : 		else if (_Grow(_Count))

  00110	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00115	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN216@assign:
$LN207@assign:
  0011a	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1143 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1144 : 		return (assign(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 1145 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1071 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 d0 00 00
	00		 jb	 $LN203@append

; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

  00019	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0001c	2b c1		 sub	 eax, ecx
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00021	3b c8		 cmp	 ecx, eax
  00023	0f 47 c8	 cmova	 ecx, eax
  00026	8b c2		 mov	 eax, edx
  00028	f7 d0		 not	 eax
  0002a	89 4d 10	 mov	 DWORD PTR __Count$[ebp], ecx
  0002d	3b c1		 cmp	 eax, ecx
  0002f	0f 86 be 00 00
	00		 jbe	 $LN205@append

; 1075 : 
; 1076 : 		const size_type _Num = this->_Mysize() + _Count;

  00035	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 1077 : 		if (0 < _Count && _Grow(_Num))

  00038	85 c9		 test	 ecx, ecx
  0003a	0f 84 a0 00 00
	00		 je	 $LN198@append
  00040	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00046	0f 87 b1 00 00
	00		 ja	 $LN206@append
  0004c	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0004f	73 22		 jae	 SHORT $LN56@append
  00051	52		 push	 edx
  00052	57		 push	 edi
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0005a	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005d	85 ff		 test	 edi, edi
  0005f	74 7f		 je	 SHORT $LN198@append
$LN202@append:

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

  00061	83 7b 14 08	 cmp	 DWORD PTR [ebx+20], 8
  00065	72 02		 jb	 SHORT $LN150@append
  00067	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN150@append:
  00069	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0006d	72 2f		 jb	 SHORT $LN164@append
  0006f	8b 16		 mov	 edx, DWORD PTR [esi]
  00071	eb 2d		 jmp	 SHORT $LN165@append

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN56@append:
  00073	85 ff		 test	 edi, edi
  00075	75 ea		 jne	 SHORT $LN202@append
  00077	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0007a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0007e	72 10		 jb	 SHORT $LN133@append
  00080	8b 06		 mov	 eax, DWORD PTR [esi]
  00082	33 c9		 xor	 ecx, ecx
  00084	5f		 pop	 edi
  00085	66 89 08	 mov	 WORD PTR [eax], cx

; 1082 : 			}
; 1083 : 		return (*this);

  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx

; 1084 : 		}

  0008c	5d		 pop	 ebp
  0008d	c2 0c 00	 ret	 12			; 0000000cH

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN133@append:
  00090	8b c6		 mov	 eax, esi
  00092	33 c9		 xor	 ecx, ecx
  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	66 89 08	 mov	 WORD PTR [eax], cx

; 1084 : 		}

  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

$LN164@append:
  0009e	8b d6		 mov	 edx, esi
$LN165@append:
  000a0	85 c9		 test	 ecx, ecx
  000a2	74 1a		 je	 SHORT $LN180@append
  000a4	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  000a7	50		 push	 eax
  000a8	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  000ab	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  000ae	50		 push	 eax
  000af	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b2	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _memcpy
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN180@append:

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

  000be	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000c2	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000c5	72 11		 jb	 SHORT $LN193@append
  000c7	8b 06		 mov	 eax, DWORD PTR [esi]
  000c9	33 c9		 xor	 ecx, ecx
  000cb	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1082 : 			}
; 1083 : 		return (*this);

  000cf	8b c6		 mov	 eax, esi
  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx

; 1084 : 		}

  000d4	5d		 pop	 ebp
  000d5	c2 0c 00	 ret	 12			; 0000000cH

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

$LN193@append:
  000d8	8b c6		 mov	 eax, esi
  000da	33 c9		 xor	 ecx, ecx
  000dc	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN198@append:

; 1082 : 			}
; 1083 : 		return (*this);

  000e0	5f		 pop	 edi
  000e1	8b c6		 mov	 eax, esi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx

; 1084 : 		}

  000e5	5d		 pop	 ebp
  000e6	c2 0c 00	 ret	 12			; 0000000cH
$LN203@append:

; 1071 : 		_Right._Check_offset(_Roff);

  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000ee	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN207@append:
$LN205@append:

; 1074 : 			_Xlen();	// result too long

  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f8	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN208@append:
$LN206@append:

; 1077 : 		if (0 < _Count && _Grow(_Num))

  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00102	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN209@append:
$LN200@append:
  00107	cc		 int	 3
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1064 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1065 : 		return (append(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 1066 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=, COMDAT
; _this$ = ecx

; 1049 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1050 : 		return (append(_Right));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 1051 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 1023 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1024 : 		if (this != &_Right)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b f0		 cmp	 esi, eax
  0000b	74 0a		 je	 SHORT $LN134@operator

; 1025 : 			{	// different, assign it
; 1026 : 			if (this->_Getal() != _Right._Getal()
; 1027 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1028 : 				{	// change allocator before copying
; 1029 : 				_Tidy(true);
; 1030 : 				this->_Copy_alloc(_Right._Getal());
; 1031 : 				}
; 1032 : 
; 1033 : 			assign(_Right);

  0000d	6a ff		 push	 -1
  0000f	6a 00		 push	 0
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN134@operator:

; 1034 : 			}
; 1035 : 		return (*this);

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi

; 1036 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1017 : 		_Tidy(true);

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 08	 cmp	 eax, 8
  00009	72 09		 jb	 SHORT $LN6@basic_stri
  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN6@basic_stri:
  00014	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0001b	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	72 09		 jb	 SHORT $LN96@basic_stri
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	33 c9		 xor	 ecx, ecx
  0002c	5e		 pop	 esi
  0002d	66 89 08	 mov	 WORD PTR [eax], cx

; 1018 : 		}

  00030	c3		 ret	 0

; 1017 : 		_Tidy(true);

$LN96@basic_stri:
  00031	33 c0		 xor	 eax, eax
  00033	66 89 06	 mov	 WORD PTR [esi], ax
  00036	5e		 pop	 esi

; 1018 : 		}

  00037	c3		 ret	 0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv, COMDAT
; _this$ = ecx

; 961  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0000e	73 17		 jae	 SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	83 c0 01	 add	 eax, 1
  00016	74 1d		 je	 SHORT $LN3@Assign_rv
  00018	03 c0		 add	 eax, eax
  0001a	50		 push	 eax
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 964  : 				_Right._Mysize() + 1);
; 965  : 		else

  00025	eb 0e		 jmp	 SHORT $LN3@Assign_rv
$LN2@Assign_rv:

; 966  : 			{	// copy pointer
; 967  : 			this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Right._Bx()._Ptr);

  00027	85 ff		 test	 edi, edi
  00029	74 04		 je	 SHORT $LN86@Assign_rv
  0002b	8b 06		 mov	 eax, DWORD PTR [esi]
  0002d	89 07		 mov	 DWORD PTR [edi], eax
$LN86@Assign_rv:

; 968  : 			_Right._Bx()._Ptr = pointer();

  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

  00035	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00038	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

  0003b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0003e	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 972  : 		_Right._Tidy();

  00041	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00048	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0004c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00053	72 0d		 jb	 SHORT $LN231@Assign_rv
  00055	8b 06		 mov	 eax, DWORD PTR [esi]
  00057	33 c9		 xor	 ecx, ecx
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	66 89 08	 mov	 WORD PTR [eax], cx

; 973  : 		}

  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4

; 972  : 		_Right._Tidy();

$LN231@Assign_rv:
  00062	33 c0		 xor	 eax, eax
  00064	5f		 pop	 edi
  00065	66 89 06	 mov	 WORD PTR [esi], ax
  00068	5e		 pop	 esi

; 973  : 		}

  00069	5d		 pop	 ebp
  0006a	c2 04 00	 ret	 4
?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@$$QAV12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@$$QAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 946  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@$$QAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 947  : 		if (this == &_Right)

  00025	3b 75 08	 cmp	 esi, DWORD PTR __Right$[ebp]
  00028	74 3a		 je	 SHORT $LN279@assign

; 948  : 			;
; 949  : 		else if (get_allocator() != _Right.get_allocator()
; 950  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 951  : 			*this = _Right;
; 952  : 		else
; 953  : 			{	// not same, clear this and steal from _Right
; 954  : 			_Tidy(true);

  0002a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002d	83 f8 08	 cmp	 eax, 8
  00030	72 09		 jb	 SHORT $LN179@assign
  00032	40		 inc	 eax
  00033	50		 push	 eax
  00034	ff 36		 push	 DWORD PTR [esi]
  00036	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN179@assign:
  0003b	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00042	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00046	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004d	72 04		 jb	 SHORT $LN269@assign
  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	eb 02		 jmp	 SHORT $LN270@assign
$LN269@assign:
  00053	8b c6		 mov	 eax, esi
$LN270@assign:

; 955  : 			_Assign_rv(_STD forward<_Myt>(_Right));

  00055	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00058	33 c9		 xor	 ecx, ecx
  0005a	66 89 08	 mov	 WORD PTR [eax], cx
  0005d	8b ce		 mov	 ecx, esi
  0005f	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN279@assign:

; 956  : 			}
; 957  : 		return (*this);

  00064	8b c6		 mov	 eax, esi

; 958  : 		}

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	5e		 pop	 esi
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@$$QAV12@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@$$QAV12@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@$$QAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 928  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 929  : 		if (this != &_Right)

  00025	3b 75 08	 cmp	 esi, DWORD PTR __Right$[ebp]
  00028	74 3a		 je	 SHORT $LN296@operator

; 930  : 			{	// different, assign it
; 931  : 			_Tidy(true);

  0002a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002d	83 f8 08	 cmp	 eax, 8
  00030	72 09		 jb	 SHORT $LN10@operator
  00032	40		 inc	 eax
  00033	50		 push	 eax
  00034	ff 36		 push	 DWORD PTR [esi]
  00036	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN10@operator:
  0003b	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00042	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00046	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004d	72 04		 jb	 SHORT $LN100@operator
  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	eb 02		 jmp	 SHORT $LN101@operator
$LN100@operator:
  00053	8b c6		 mov	 eax, esi
$LN101@operator:

; 932  : 
; 933  : 			if (_Alty::propagate_on_container_move_assignment::value
; 934  : 				&& this->_Getal() != _Right._Getal())
; 935  : 				this->_Move_alloc(_Right._Getal());
; 936  : 
; 937  : 			if (this->_Getal() != _Right._Getal())
; 938  : 				assign(_Right.begin(), _Right.end());
; 939  : 			else
; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

  00055	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00058	33 c9		 xor	 ecx, ecx
  0005a	66 89 08	 mov	 WORD PTR [eax], cx
  0005d	8b ce		 mov	 ecx, esi
  0005f	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN296@operator:

; 941  : 			}
; 942  : 		return (*this);

  00064	8b c6		 mov	 eax, esi

; 943  : 		}

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	5e		 pop	 esi
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 911  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 912  : 		_Tidy();
; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00004	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	33 c0		 xor	 eax, eax
  0000b	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00012	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00019	66 89 06	 mov	 WORD PTR [esi], ax
  0001c	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv

; 914  : 		}

  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 2
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 850  : 		{	// construct from _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 851  : 		_Tidy();
; 852  : 		assign(_Count, _Ch);

  00004	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	33 c0		 xor	 eax, eax
  0000b	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  0000e	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00015	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001c	66 89 06	 mov	 WORD PTR [esi], ax
  0001f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 853  : 		}

  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00012	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00019	66 89 06	 mov	 WORD PTR [esi], ax
  0001c	66 39 02	 cmp	 WORD PTR [edx], ax
  0001f	75 12		 jne	 SHORT $LN113@basic_stri
  00021	33 c9		 xor	 ecx, ecx
  00023	51		 push	 ecx
  00024	52		 push	 edx
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 839  : 		}

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

$LN113@basic_stri:
  00033	8b ca		 mov	 ecx, edx
  00035	57		 push	 edi
  00036	8d 79 02	 lea	 edi, DWORD PTR [ecx+2]
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL115@basic_stri:
  00040	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00043	83 c1 02	 add	 ecx, 2
  00046	66 85 c0	 test	 ax, ax
  00049	75 f5		 jne	 SHORT $LL115@basic_stri
  0004b	2b cf		 sub	 ecx, edi
  0004d	d1 f9		 sar	 ecx, 1
  0004f	5f		 pop	 edi
  00050	51		 push	 ecx
  00051	52		 push	 edx
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 839  : 		}

  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 822  : 		{	// construct from [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 823  : 		_Tidy();
; 824  : 		assign(_Ptr, _Count);

  00004	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	33 c0		 xor	 eax, eax
  0000b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000e	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00015	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001c	66 89 06	 mov	 WORD PTR [esi], ax
  0001f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 825  : 		}

  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$ = 20						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 815  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 816  : 		_Tidy();
; 817  : 		assign(_Right, _Roff, _Count);

  00004	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	33 c0		 xor	 eax, eax
  0000b	ff 75 0c	 push	 DWORD PTR __Roff$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00011	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00018	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001f	66 89 06	 mov	 WORD PTR [esi], ax
  00022	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 818  : 		}

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 795  : 		_Tidy();

  00000	33 c0		 xor	 eax, eax
  00002	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  00009	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00010	66 89 01	 mov	 WORD PTR [ecx], ax

; 796  : 		}

  00013	8b c1		 mov	 eax, ecx
  00015	c3		 ret	 0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 781  : 		_Tidy();

  00006	33 c0		 xor	 eax, eax

; 782  : 		assign(_Right, 0, npos);

  00008	6a ff		 push	 -1
  0000a	50		 push	 eax
  0000b	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000e	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00015	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001c	66 89 06	 mov	 WORD PTR [esi], ax
  0001f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 783  : 		}

  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 735  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 730  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 725  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

  00000	8b c1		 mov	 eax, ecx

; 715  : 		}

  00002	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 708  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 703  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 698  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 693  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Move_alloc, COMDAT
; _this$ = ecx

; 607  : 		_Pocma(_Getal(), _Al);
; 608  : 		}

  00000	c2 04 00	 ret	 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 602  : 		_Pocca(_Getal(), _Al);
; 603  : 		}

  00000	c2 04 00	 ret	 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

; 588  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 590  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 583  : 		return (_Get_data()._Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 584  : 		}

  00008	c3		 ret	 0

; 583  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 584  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 578  : 		return (_Get_data()._Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 579  : 		}

  00008	c3		 ret	 0

; 578  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 579  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 534  : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 499  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1009 : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000e	77 30		 ja	 SHORT $LN16@deallocate
  00010	03 c0		 add	 eax, eax
  00012	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00017	72 1a		 jb	 SHORT $LN7@deallocate
  00019	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001c	75 27		 jne	 SHORT $LN18@deallocate
  0001e	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00021	3b c1		 cmp	 eax, ecx
  00023	73 25		 jae	 SHORT $LN19@deallocate
  00025	2b c8		 sub	 ecx, eax
  00027	83 f9 04	 cmp	 ecx, 4
  0002a	72 23		 jb	 SHORT $LN20@deallocate
  0002c	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0002f	77 23		 ja	 SHORT $LN21@deallocate
  00031	8b c8		 mov	 ecx, eax
$LN7@deallocate:
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4

; 988  : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00040	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:
  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  00059	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 977  : 		}

  00003	5d		 pop	 ebp

; 976  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??4?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEAAU01@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 963  : 		_Mybase::operator=(_STD move(_Right));
; 964  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 965  : 		}

  00002	c2 04 00	 ret	 4
??4?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?address@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEPA_WAA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?address@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEPA_WAA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::address, COMDAT
; _this$ = ecx

; 925  : 		{	// return address of mutable _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 926  : 		return (pointer_traits<pointer>::pointer_to(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 927  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?address@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEPA_WAA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 870  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@_W@std@@QBEIXZ PROC		; std::allocator<wchar_t>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 750  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@_W@std@@QBEIXZ ENDP		; std::allocator<wchar_t>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z PROC		; std::allocator<wchar_t>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00013	77 3b		 ja	 SHORT $LN14@allocate
  00015	03 c0		 add	 eax, eax
  00017	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001c	72 23		 jb	 SHORT $LN6@allocate
  0001e	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00021	3b c8		 cmp	 ecx, eax
  00023	76 30		 jbe	 SHORT $LN16@allocate
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002b	8b c8		 mov	 ecx, eax
  0002d	83 c4 04	 add	 esp, 4
  00030	85 c9		 test	 ecx, ecx
  00032	74 26		 je	 SHORT $LN17@allocate
  00034	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00037	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0003a	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00047	83 c4 04	 add	 esp, 4
  0004a	85 c0		 test	 eax, eax
  0004c	75 bc		 jne	 SHORT $LN12@allocate
  0004e	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:
  00050	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:
  00055	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:
  0005a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:
  0005f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00064	cc		 int	 3
?allocate@?$allocator@_W@std@@QAEPA_WI@Z ENDP		; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000e	77 30		 ja	 SHORT $LN13@deallocate
  00010	03 c0		 add	 eax, eax
  00012	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00017	72 1a		 jb	 SHORT $LN5@deallocate
  00019	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001c	75 27		 jne	 SHORT $LN15@deallocate
  0001e	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00021	3b c1		 cmp	 eax, ecx
  00023	73 25		 jae	 SHORT $LN16@deallocate
  00025	2b c8		 sub	 ecx, eax
  00027	83 f9 04	 cmp	 ecx, 4
  0002a	72 23		 jb	 SHORT $LN17@deallocate
  0002c	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0002f	77 23		 ja	 SHORT $LN18@deallocate
  00031	8b c8		 mov	 ecx, eax
$LN5@deallocate:
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4

; 721  : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00040	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:
  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  00059	cc		 int	 3
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@_W@std@@QAE@ABV01@@Z PROC		; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@_W@std@@QAE@ABV01@@Z ENDP		; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_W@std@@QAE@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?hex@std@@YAAAVios_base@1@AAV21@@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
?hex@std@@YAAAVios_base@1@AAV21@@Z PROC			; std::hex, COMDAT

; 238  : 	{	// set basefield to hex

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 239  : 	_Iosbase.setf(ios_base::hex, ios_base::basefield);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iosbase$[ebp]
  00006	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00009	81 e1 ff f9 ff
	ff		 and	 ecx, -1537		; fffff9ffH
  0000f	81 c9 00 08 00
	00		 or	 ecx, 2048		; 00000800H
  00015	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 240  : 	return (_Iosbase);
; 241  : 	}

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?hex@std@@YAAAVios_base@1@AAV21@@Z ENDP			; std::hex
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gios_base@std@@UAEPAXI@Z PROC			; std::ios_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Gios_base@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	56		 push	 esi
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00033	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00038	83 c4 04	 add	 esp, 4
  0003b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003f	74 0b		 je	 SHORT $LN7@scalar
  00041	6a 38		 push	 56			; 00000038H
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00049	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0004c	8b c6		 mov	 eax, esi
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00058	59		 pop	 ecx
  00059	5e		 pop	 esi
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gios_base@std@@UAEPAXI@Z$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_Gios_base@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Gios_base@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Gios_base@std@@UAEPAXI@Z ENDP			; std::ios_base::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?_Init@ios_base@std@@IAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?_Init@ios_base@std@@IAEXXZ PROC			; std::ios_base::_Init, COMDAT
; _this$ = ecx

; 538  : 		{	// initialize a new ios_base

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Init@ios_base@std@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 539  : 		_Ploc = 0;
; 540  : 		_Stdstr = 0;
; 541  : 		_Except = goodbit;
; 542  : 		_Fmtfl = (fmtflags)(skipws | dec);
; 543  : 		_Prec = 6;
; 544  : 		_Wide = 0;
; 545  : 		_Arr = 0;
; 546  : 		_Calls = 0;
; 547  : 		clear(goodbit);

  00026	6a 00		 push	 0
  00028	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
  0002f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00036	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0003d	c7 46 14 01 02
	00 00		 mov	 DWORD PTR [esi+20], 513	; 00000201H
  00044	c7 46 18 06 00
	00 00		 mov	 DWORD PTR [esi+24], 6
  0004b	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00052	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  00059	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  00060	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00067	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
  0006e	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH@Z ; std::ios_base::clear

; 548  : 		_Ploc = new locale;

  00073	6a 08		 push	 8
  00075	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007a	8b f8		 mov	 edi, eax
  0007c	83 c4 04	 add	 esp, 4
  0007f	85 ff		 test	 edi, edi
  00081	74 28		 je	 SHORT $LN3@Init
  00083	6a 01		 push	 1
  00085	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0008c	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  00091	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00094	83 c4 04	 add	 esp, 4
  00097	89 7e 30	 mov	 DWORD PTR [esi+48], edi

; 549  : 		}

  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a4	59		 pop	 ecx
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
$LN3@Init:

; 548  : 		_Ploc = new locale;

  000ab	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0

; 549  : 		}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Init@ios_base@std@@IAEXXZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$?_Init@ios_base@std@@IAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Init@ios_base@std@@IAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Init@ios_base@std@@IAEXXZ ENDP			; std::ios_base::_Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ??0ios_base@std@@IAE@XZ
_TEXT	SEGMENT
??0ios_base@std@@IAE@XZ PROC				; std::ios_base::ios_base, COMDAT
; _this$ = ecx

; 534  : 		{	// default constructor

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@

; 535  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0ios_base@std@@IAE@XZ ENDP				; std::ios_base::ios_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ??1ios_base@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ios_base@std@@UAE@XZ PROC				; std::ios_base::~ios_base, COMDAT
; _this$ = ecx

; 523  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1ios_base@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 524  : 		_Ios_base_dtor(this);

  00022	51		 push	 ecx
  00023	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
  00029	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0002e	83 c4 04	 add	 esp, 4

; 525  : 		}

  00031	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00034	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003b	59		 pop	 ecx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ios_base@std@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ios_base@std@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ios_base@std@@UAE@XZ ENDP				; std::ios_base::~ios_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 434  : 		{	// get locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 435  : 		return (*_Ploc);

  00024	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00027	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0002e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00031	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	ff 52 04	 call	 DWORD PTR [edx+4]
  00043	8b c6		 mov	 eax, esi

; 436  : 		}

  00045	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00048	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004f	59		 pop	 ecx
  00050	5e		 pop	 esi
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getloc@ios_base@std@@QBE?AVlocale@2@XZ$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$?getloc@ios_base@std@@QBE?AVlocale@2@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?width@ios_base@std@@QAE_J_J@Z
_TEXT	SEGMENT
__Newwidth$ = 8						; size = 8
?width@ios_base@std@@QAE_J_J@Z PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 427  : 		{	// set width to argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  : 		streamsize _Oldwidth = _Wide;

  00003	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00006	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00009	56		 push	 esi

; 429  : 		_Wide = _Newwidth;

  0000a	8b 75 08	 mov	 esi, DWORD PTR __Newwidth$[ebp]
  0000d	89 71 20	 mov	 DWORD PTR [ecx+32], esi
  00010	8b 75 0c	 mov	 esi, DWORD PTR __Newwidth$[ebp+4]
  00013	89 71 24	 mov	 DWORD PTR [ecx+36], esi
  00016	5e		 pop	 esi

; 430  : 		return (_Oldwidth);
; 431  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?width@ios_base@std@@QAE_J_J@Z ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?width@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
?width@ios_base@std@@QBE_JXZ PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 423  : 		return (_Wide);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]

; 424  : 		}

  00006	c3		 ret	 0
?width@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?precision@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
?precision@ios_base@std@@QBE_JXZ PROC			; std::ios_base::precision, COMDAT
; _this$ = ecx

; 411  : 		return (_Prec);

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 412  : 		}

  00006	c3		 ret	 0
?precision@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::precision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?setf@ios_base@std@@QAEHHH@Z
_TEXT	SEGMENT
__Newfmtflags$ = 8					; size = 4
__Mask$ = 12						; size = 4
?setf@ios_base@std@@QAEHHH@Z PROC			; std::ios_base::setf, COMDAT
; _this$ = ecx

; 397  : 		{	// merge in format flags argument under mask argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 398  : 		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
; 399  : 		_Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Newfmtflags$[ebp]
  00006	23 55 0c	 and	 edx, DWORD PTR __Mask$[ebp]
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Mask$[ebp]
  0000e	8b d9		 mov	 ebx, ecx
  00010	f7 d7		 not	 edi
  00012	0f b7 ca	 movzx	 ecx, dx
  00015	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00018	23 f8		 and	 edi, eax
  0001a	0b f9		 or	 edi, ecx
  0001c	89 7b 14	 mov	 DWORD PTR [ebx+20], edi
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx

; 400  : 			| ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));
; 401  : 		return (_Oldfmtflags);
; 402  : 		}

  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?setf@ios_base@std@@QAEHHH@Z ENDP			; std::ios_base::setf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 378  : 		return (_Fmtfl);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 379  : 		}

  00003	c3		 ret	 0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 338  : 		{	// test if no state bits are set

  00000	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00004	0f 94 c0	 sete	 al

; 339  : 		return (rdstate() == goodbit);
; 340  : 		}

  00007	c3		 ret	 0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 315  : 		return (_Mystate);

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 316  : 		}

  00003	c3		 ret	 0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -20						; size = 20
__State$ = 8						; size = 4
?clear@ios_base@std@@QAEXH@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 302  : 		{	// set state to argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 303  : 		clear(_State, false);

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	83 e0 17	 and	 eax, 23			; 00000017H
  0000c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0000f	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00012	23 c8		 and	 ecx, eax
  00014	74 22		 je	 SHORT $LN11@clear
  00016	f6 c1 04	 test	 cl, 4
  00019	75 23		 jne	 SHORT $LN52@clear
  0001b	f6 c1 02	 test	 cl, 2
  0001e	74 0c		 je	 SHORT $LN10@clear
  00020	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  0002a	eb 1c		 jmp	 SHORT $LN51@clear
$LN10@clear:
  0002c	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  00036	eb 10		 jmp	 SHORT $LN51@clear
$LN11@clear:

; 304  : 		}

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
$LN52@clear:

; 303  : 		clear(_State, false);

  0003e	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN51@clear:
  00048	50		 push	 eax
  00049	6a 01		 push	 1
  0004b	8d 4d ec	 lea	 ecx, DWORD PTR $T1[ebp]
  0004e	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00053	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00058	8d 45 ec	 lea	 eax, DWORD PTR $T1[ebp]
  0005b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN54@clear:
$LN50@clear:
  00068	cc		 int	 3
?clear@ios_base@std@@QAEXH@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T1 = -20						; size = 20
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 287  : 		{	// set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 288  : 		_Mystate = (iostate)(_State & _Statmask);

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	83 e0 17	 and	 eax, 23			; 00000017H
  0000c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 289  : 		if ((_Mystate & _Except) == 0)

  0000f	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00012	23 c8		 and	 ecx, eax
  00014	74 28		 je	 SHORT $LN9@clear

; 290  : 			;
; 291  : 		else if (_Reraise)

  00016	80 7d 0c 00	 cmp	 BYTE PTR __Reraise$[ebp], 0
  0001a	75 28		 jne	 SHORT $LN49@clear

; 293  : 		else if (_Mystate & _Except & badbit)

  0001c	f6 c1 04	 test	 cl, 4
  0001f	75 2c		 jne	 SHORT $LN51@clear

; 295  : 		else if (_Mystate & _Except & failbit)

  00021	f6 c1 02	 test	 cl, 2
  00024	74 0c		 je	 SHORT $LN8@clear

; 296  : 			_THROW_NCEE(failure, "ios_base::failbit set");

  00026	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  00030	eb 25		 jmp	 SHORT $LN48@clear
$LN8@clear:

; 297  : 		else
; 298  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

  00032	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  0003c	eb 19		 jmp	 SHORT $LN48@clear
$LN9@clear:

; 299  : 		}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
$LN49@clear:

; 292  : 			_RERAISE;

  00044	6a 00		 push	 0
  00046	6a 00		 push	 0
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN52@clear:
$LN51@clear:

; 294  : 			_THROW_NCEE(failure, "ios_base::badbit set");

  0004d	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN48@clear:
  00057	50		 push	 eax
  00058	6a 01		 push	 1
  0005a	8d 4d ec	 lea	 ecx, DWORD PTR $T1[ebp]
  0005d	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00062	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00067	8d 45 ec	 lea	 eax, DWORD PTR $T1[ebp]
  0006a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN53@clear:
$LN47@clear:
  00077	cc		 int	 3
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 14		 push	 20			; 00000014H
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00010	50		 push	 eax
  00011	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
  00017	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001b	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ___std_exception_copy
  00024	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
  0002a	83 c4 08	 add	 esp, 8
  0002d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00030	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00039	8b c7		 mov	 eax, edi
  0003b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7failure@ios_base@std@@6B@
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx
  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 238  : 			{	// construct with message

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 237  : 			: system_error(_Errcode, _Message)

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00007	56		 push	 esi
  00008	ff 75 08	 push	 DWORD PTR __Message$[ebp]

; 238  : 			{	// construct with message

  0000b	8b f1		 mov	 esi, ecx
  0000d	ff 70 04	 push	 DWORD PTR [eax+4]
  00010	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00013	ff 30		 push	 DWORD PTR [eax]
  00015	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  0001a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@

; 239  : 			}

  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ
_TEXT	SEGMENT
??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ PROC ; std::_Immortalize<std::_Iostream_error_category>, COMDAT

; 698  : 	/* MAGIC */ static _Immortalizer<_Ty> _Static;

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __tls_index
  0000c	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
  00014	3b 81 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[ecx]
  0001a	7f 06		 jg	 SHORT $LN22@Immortaliz
$LN20@Immortaliz:

; 699  : 	return (*reinterpret_cast<_Ty *>(&_Static._Storage));

  0001c	b8 00 00 00 00	 mov	 eax, OFFSET ?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Static

; 700  : 	}

  00021	c3		 ret	 0
$LN22@Immortaliz:

; 698  : 	/* MAGIC */ static _Immortalizer<_Ty> _Static;

  00022	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
  00027	e8 00 00 00 00	 call	 __Init_thread_header
  0002c	83 c4 04	 add	 esp, 4
  0002f	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA, -1 ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
  00036	75 e4		 jne	 SHORT $LN20@Immortaliz
  00038	68 00 00 00 00	 push	 OFFSET ??__F_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ@YAXXZ ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::`dynamic atexit destructor for '_Static''
  0003d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A, OFFSET ??_7_Iostream_error_category@std@@6B@
  00047	c7 05 04 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A+4, 5
  00051	e8 00 00 00 00	 call	 _atexit
  00056	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
  0005b	e8 00 00 00 00	 call	 __Init_thread_footer
  00060	83 c4 08	 add	 esp, 8
  00063	eb b7		 jmp	 SHORT $LN20@Immortaliz
??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ENDP ; std::_Immortalize<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
  00010	74 0b		 je	 SHORT $LN13@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN13@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@
  00006	c3		 ret	 0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 626  : 		{	// convert to name of error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 627  : 		if (_Errcode == (int)io_errc::stream)

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000e	56		 push	 esi

; 628  : 			return ("iostream stream error");

  0000f	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00012	83 f8 01	 cmp	 eax, 1
  00015	75 28		 jne	 SHORT $LN2@message
  00017	6a 15		 push	 21			; 00000015H
  00019	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00020	8b ce		 mov	 ecx, esi
  00022	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
  0002e	c6 06 00	 mov	 BYTE PTR [esi], 0
  00031	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 629  : 		else
; 630  : 			return (_Generic_error_category::message(_Errcode));

  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi

; 631  : 		}

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN2@message:

; 629  : 		else
; 630  : 			return (_Generic_error_category::message(_Errcode));

  0003f	50		 push	 eax
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi

; 631  : 		}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 622  : 		return ("iostream");

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 623  : 		}

  00005	c3		 ret	 0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 616  : 		{	// default constructor

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Iostream_error_category@std@@6B@

; 617  : 		_Addr = _Iostream_addr;
; 618  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 05 00
	00 00		 mov	 DWORD PTR [ecx+4], 5
  0000f	c3		 ret	 0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
  00010	74 0b		 je	 SHORT $LN10@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@
  00006	c3		 ret	 0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 605  : 		{	// convert to name of error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 606  : 		return (_Syserror_map(_Errcode));

  00005	ff 75 0c	 push	 DWORD PTR __Errcode$[ebp]
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000f	e8 00 00 00 00	 call	 ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map
  00014	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00017	8b d0		 mov	 edx, eax
  00019	83 c4 04	 add	 esp, 4
  0001c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00023	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002a	c6 06 00	 mov	 BYTE PTR [esi], 0
  0002d	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00030	75 14		 jne	 SHORT $LN115@message
  00032	33 c9		 xor	 ecx, ecx
  00034	51		 push	 ecx
  00035	52		 push	 edx
  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi

; 607  : 		}

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 606  : 		return (_Syserror_map(_Errcode));

$LN115@message:
  00046	8b ca		 mov	 ecx, edx
  00048	57		 push	 edi
  00049	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
  0004c	0f 1f 40 00	 npad	 4
$LL117@message:
  00050	8a 01		 mov	 al, BYTE PTR [ecx]
  00052	41		 inc	 ecx
  00053	84 c0		 test	 al, al
  00055	75 f9		 jne	 SHORT $LL117@message
  00057	2b cf		 sub	 ecx, edi
  00059	5f		 pop	 edi
  0005a	51		 push	 ecx
  0005b	52		 push	 edx
  0005c	8b ce		 mov	 ecx, esi
  0005e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00063	8b c6		 mov	 eax, esi
  00065	5e		 pop	 esi

; 607  : 		}

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 601  : 		return ("generic");

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 602  : 		}

  00005	c3		 ret	 0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 595  : 		{	// default constructor

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Generic_error_category@std@@6B@

; 596  : 		_Addr = _Generic_addr;
; 597  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 03 00
	00 00		 mov	 DWORD PTR [ecx+4], 3
  0000f	c3		 ret	 0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN15@scalar
  0001e	6a 14		 push	 20			; 00000014H
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN15@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00010	50		 push	 eax
  00011	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
  00017	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001b	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ___std_exception_copy
  00024	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
  0002a	83 c4 08	 add	 esp, 8
  0002d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00030	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00039	8b c7		 mov	 eax, edi
  0003b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7system_error@std@@6B@
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx
  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@PBD@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0system_error@std@@QAE@Verror_code@1@PBD@Z PROC	; std::system_error::system_error, COMDAT
; _this$ = ecx

; 548  : 		{	// construct from error code and message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f1		 mov	 esi, ecx
  0002c	89 75 d4	 mov	 DWORD PTR _this$[ebp], esi
  0002f	8b 55 10	 mov	 edx, DWORD PTR __Message$[ebp]

; 547  : 		: _Mybase(_Errcode, _Message)

  00032	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
  00039	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0
  00040	c6 45 d8 00	 mov	 BYTE PTR $T2[ebp], 0
  00044	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00047	75 04		 jne	 SHORT $LN115@system_err
  00049	33 c9		 xor	 ecx, ecx
  0004b	eb 0e		 jmp	 SHORT $LN116@system_err
$LN115@system_err:
  0004d	8b ca		 mov	 ecx, edx
  0004f	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL218@system_err:
  00052	8a 01		 mov	 al, BYTE PTR [ecx]
  00054	41		 inc	 ecx
  00055	84 c0		 test	 al, al
  00057	75 f9		 jne	 SHORT $LL218@system_err
  00059	2b cf		 sub	 ecx, edi
$LN116@system_err:
  0005b	51		 push	 ecx
  0005c	52		 push	 edx
  0005d	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00060	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00065	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  00068	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006f	50		 push	 eax
  00070	ff 75 0c	 push	 DWORD PTR __Errcode$[ebp+4]
  00073	8b ce		 mov	 ecx, esi
  00075	ff 75 08	 push	 DWORD PTR __Errcode$[ebp]
  00078	e8 00 00 00 00	 call	 ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
  0007d	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp+20]
  00080	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00083	72 0d		 jb	 SHORT $LN219@system_err
  00085	41		 inc	 ecx
  00086	51		 push	 ecx
  00087	ff 75 d8	 push	 DWORD PTR $T2[ebp]
  0008a	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0008d	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN219@system_err:

; 549  : 		}

  00092	8b c6		 mov	 eax, esi

; 548  : 		{	// construct from error code and message string

  00094	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@

; 549  : 		}

  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a4	59		 pop	 ecx
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000aa	33 cd		 xor	 ecx, ebp
  000ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0system_error@std@@QAE@Verror_code@1@PBD@Z ENDP	; std::system_error::system_error
; Function compile flags: /Ogtp
;	COMDAT ??_G_System_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_System_error@std@@UAEPAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 14		 push	 20			; 00000014H
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_G_System_error@std@@UAEPAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0_System_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0_System_error@std@@QAE@ABV01@@Z PROC			; std::_System_error::_System_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00010	50		 push	 eax
  00011	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
  00017	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001b	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ___std_exception_copy
  00024	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
  0002a	83 c4 08	 add	 esp, 8
  0002d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00030	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00039	8b c7		 mov	 eax, edi
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
??0_System_error@std@@QAE@ABV01@@Z ENDP			; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_System_error@std@@UAE@XZ
_TEXT	SEGMENT
??1_System_error@std@@UAE@XZ PROC			; std::_System_error::~_System_error, COMDAT
; _this$ = ecx
  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1_System_error@std@@UAE@XZ ENDP			; std::_System_error::~_System_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__InitData$1 = -36					; size = 8
_this$ = -32						; size = 4
$T2 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 523  : 		{	// construct from error code and message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR __Message$[ebp]
  00013	56		 push	 esi
  00014	83 ec 18	 sub	 esp, 24			; 00000018H
  00017	8b f1		 mov	 esi, ecx
  00019	8b cc		 mov	 ecx, esp
  0001b	89 75 e0	 mov	 DWORD PTR _this$[ebp], esi
  0001e	6a ff		 push	 -1
  00020	6a 00		 push	 0
  00022	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00029	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00030	50		 push	 eax
  00031	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00034	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00039	ff 75 0c	 push	 DWORD PTR __Errcode$[ebp+4]
  0003c	8d 45 e4	 lea	 eax, DWORD PTR $T2[ebp]
  0003f	ff 75 08	 push	 DWORD PTR __Errcode$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
  00048	8b c8		 mov	 ecx, eax
  0004a	83 c4 24	 add	 esp, 36			; 00000024H
  0004d	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00051	72 02		 jb	 SHORT $LN147@System_err

; 522  : 		: runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode)

  00053	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN147@System_err:
  00055	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00058	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0005e	0f 57 c0	 xorps	 xmm0, xmm0
  00061	89 4d dc	 mov	 DWORD PTR __InitData$1[ebp], ecx
  00064	50		 push	 eax
  00065	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00069	8d 45 dc	 lea	 eax, DWORD PTR __InitData$1[ebp]
  0006c	50		 push	 eax
  0006d	c6 45 e0 01	 mov	 BYTE PTR __InitData$1[ebp+4], 1
  00071	e8 00 00 00 00	 call	 ___std_exception_copy
  00076	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp+20]
  00079	83 c4 08	 add	 esp, 8
  0007c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
  00082	83 f8 10	 cmp	 eax, 16			; 00000010H
  00085	72 0d		 jb	 SHORT $LN158@System_err
  00087	40		 inc	 eax
  00088	8d 4d e4	 lea	 ecx, DWORD PTR $T2[ebp]
  0008b	50		 push	 eax
  0008c	ff 75 e4	 push	 DWORD PTR $T2[ebp]
  0008f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN158@System_err:
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Errcode$[ebp]

; 524  : 		}

  00097	8b c6		 mov	 eax, esi
  00099	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR __Errcode$[ebp+4]
  0009f	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_System_error@std@@6B@
  000ab	33 cd		 xor	 ecx, ebp
  000ad	5e		 pop	 esi
  000ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 0c 00	 ret	 12			; 0000000cH
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
_TEXT	SEGMENT
$T2 = -44						; size = 4
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 8
__Message$ = 20						; size = 24
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z PROC ; std::_System_error::_Makestr, COMDAT

; 513  : 		{	// compose error message

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0002c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00033	83 7d 24 00	 cmp	 DWORD PTR __Message$[ebp+16], 0
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 514  : 		if (!_Message.empty())

  0003e	74 0f		 je	 SHORT $LN2@Makestr

; 515  : 			_Message.append(": ");

  00040	6a 02		 push	 2
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
  00047	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  0004a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2@Makestr:

; 516  : 		_Message.append(_Errcode.message());

  0004f	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  00052	50		 push	 eax
  00053	8d 4d 0c	 lea	 ecx, DWORD PTR __Errcode$[ebp]
  00056	e8 00 00 00 00	 call	 ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
  0005b	6a ff		 push	 -1
  0005d	6a 00		 push	 0
  0005f	50		 push	 eax
  00060	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  00063	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00067	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0006c	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp+20]
  0006f	83 f8 10	 cmp	 eax, 16			; 00000010H
  00072	72 0d		 jb	 SHORT $LN34@Makestr
  00074	40		 inc	 eax
  00075	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00078	50		 push	 eax
  00079	ff 75 d8	 push	 DWORD PTR $T3[ebp]
  0007c	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN34@Makestr:

; 517  : 		return (_Message);

  00081	8d 45 14	 lea	 eax, DWORD PTR __Message$[ebp]
  00084	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0008b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00092	8b ce		 mov	 ecx, esi
  00094	50		 push	 eax
  00095	c6 06 00	 mov	 BYTE PTR [esi], 0
  00098	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0009d	8b 4d 28	 mov	 ecx, DWORD PTR __Message$[ebp+20]
  000a0	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000a3	72 0d		 jb	 SHORT $LN355@Makestr
  000a5	41		 inc	 ecx
  000a6	51		 push	 ecx
  000a7	ff 75 14	 push	 DWORD PTR __Message$[ebp]
  000aa	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  000ad	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN355@Makestr:
  000b2	8b c6		 mov	 eax, esi

; 518  : 		}

  000b4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000be	59		 pop	 ecx
  000bf	5e		 pop	 esi
  000c0	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c3	33 cd		 xor	 ecx, ebp
  000c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ENDP ; std::_System_error::_Makestr
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??8std@@YA_NABVerror_condition@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??8std@@YA_NABVerror_condition@0@0@Z PROC		; std::operator==, COMDAT

; 392  : 	{	// test errors for equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 393  : 	return (_Left.category() == _Right.category()

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Right$[ebp]
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00010	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00013	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00016	75 0b		 jne	 SHORT $LN3@operator
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	3b 06		 cmp	 eax, DWORD PTR [esi]
  0001c	75 05		 jne	 SHORT $LN3@operator
  0001e	b0 01		 mov	 al, 1
  00020	5e		 pop	 esi

; 394  : 		&& _Left.value() == _Right.value());
; 395  : 	}

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
$LN3@operator:

; 393  : 	return (_Left.category() == _Right.category()

  00023	32 c0		 xor	 al, al
  00025	5e		 pop	 esi

; 394  : 		&& _Left.value() == _Right.value());
; 395  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??8std@@YA_NABVerror_condition@0@0@Z ENDP		; std::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 346  : 		return (*_Mycat);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 347  : 		}

  00003	c3		 ret	 0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 341  : 		return (_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 342  : 		}

  00002	c3		 ret	 0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 307  : 		{	// construct from error code and category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 306  : 		: _Myval(_Val), _Mycat(&_Cat)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Cat$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 308  : 		}

  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT
; _this$ = ecx

; 279  : 		{	// get name of error code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 280  : 		return (category().message(value()));

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	ff 31		 push	 DWORD PTR [ecx]
  00009	8b c8		 mov	 ecx, eax
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00015	8b 10		 mov	 edx, DWORD PTR [eax]
  00017	ff 52 08	 call	 DWORD PTR [edx+8]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 281  : 		}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 273  : 		return (*_Mycat);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 274  : 		}

  00003	c3		 ret	 0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 268  : 		return (_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 269  : 		}

  00002	c3		 ret	 0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0error_code@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_code@std@@QAE@HABVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT
; _this$ = ecx

; 234  : 		{	// construct from error code and category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 233  : 		: _Myval(_Val), _Mycat(&_Cat)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Cat$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 235  : 		}

  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0error_code@std@@QAE@HABVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
  00010	74 0b		 je	 SHORT $LN7@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 191  : 		{	// compare categories for equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0000c	0f 94 c0	 sete	 al

; 192  : 		return (_Addr == _Right._Addr);
; 193  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 462  : 	{	// test if conditions same for this category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 463  : 	return (*this == _Code.category() && _Code.value() == _Errval);

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __Code$[ebp]
  0000a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000d	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00010	75 0e		 jne	 SHORT $LN3@equivalent
  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	3b 45 0c	 cmp	 eax, DWORD PTR __Errval$[ebp]
  00017	75 07		 jne	 SHORT $LN3@equivalent
  00019	b0 01		 mov	 al, 1
  0001b	5e		 pop	 esi

; 464  : 	}

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
$LN3@equivalent:

; 463  : 	return (*this == _Code.category() && _Code.value() == _Errval);

  00020	32 c0		 xor	 al, al
  00022	5e		 pop	 esi

; 464  : 	}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 455  : 	{	// test if error code same condition

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 456  : 	return (default_error_condition(_Errval) == _Cond);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8d 55 f8	 lea	 edx, DWORD PTR $T1[ebp]
  00008	83 ec 08	 sub	 esp, 8
  0000b	56		 push	 esi
  0000c	ff 75 08	 push	 DWORD PTR __Errval$[ebp]
  0000f	52		 push	 edx
  00010	ff 50 0c	 call	 DWORD PTR [eax+12]
  00013	8b 75 0c	 mov	 esi, DWORD PTR __Cond$[ebp]
  00016	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001f	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00022	75 0f		 jne	 SHORT $LN5@equivalent
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	3b 06		 cmp	 eax, DWORD PTR [esi]
  00028	75 09		 jne	 SHORT $LN5@equivalent
  0002a	b0 01		 mov	 al, 1
  0002c	5e		 pop	 esi

; 457  : 	}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8

; 456  : 	return (default_error_condition(_Errval) == _Cond);

$LN5@equivalent:
  00033	32 c0		 xor	 al, al
  00035	5e		 pop	 esi

; 457  : 	}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 448  : 	{	// make error_condition for error code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 449  : 	return (error_condition(_Errval, *this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Errval$[ebp]
  00009	89 10		 mov	 DWORD PTR [eax], edx
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 450  : 	}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 174  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@

; 175  : 		}

  00006	c3		 ret	 0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 169  : 		{	// default constructor

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@

; 170  : 		_Addr = reinterpret_cast<uintptr_t>(this);
; 171  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  0000b	c3		 ret	 0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?iostream_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?iostream_category@std@@YAABVerror_category@1@XZ PROC	; std::iostream_category, COMDAT

; 709  : 	return (_Immortalize<_Iostream_error_category>());

  00000	e9 00 00 00 00	 jmp	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
?iostream_category@std@@YAABVerror_category@1@XZ ENDP	; std::iostream_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errno$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z PROC ; std::make_error_code, COMDAT

; 479  : 	{	// make an error_code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 480  : 	return (error_code((int)_Errno, iostream_category()));

  00003	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00008	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Errno$[ebp]
  0000e	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00011	8b c2		 mov	 eax, edx
  00013	89 0a		 mov	 DWORD PTR [edx], ecx

; 481  : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@_W@std@@MAEPAXI@Z PROC			; std::ctype<wchar_t>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@_W@std@@6B@
  00010	74 0b		 je	 SHORT $LN5@scalar
  00012	ff 76 0c	 push	 DWORD PTR [esi+12]
  00015	e8 00 00 00 00	 call	 _free
  0001a	83 c4 04	 add	 esp, 4
$LN5@scalar:
  0001d	ff 76 14	 push	 DWORD PTR [esi+20]
  00020	e8 00 00 00 00	 call	 _free
  00025	83 c4 04	 add	 esp, 4
  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00032	74 0b		 je	 SHORT $LN17@scalar
  00034	6a 44		 push	 68			; 00000044H
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003c	83 c4 08	 add	 esp, 8
$LN17@scalar:
  0003f	8b c6		 mov	 eax, esi
  00041	5e		 pop	 esi
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
??_G?$ctype@_W@std@@MAEPAXI@Z ENDP			; std::ctype<wchar_t>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z
_TEXT	SEGMENT
__Mbst$1 = -28						; size = 8
tv164 = -20						; size = 4
tv168 = -16						; size = 4
__Buf$2 = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dflt$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z PROC	; std::ctype<wchar_t>::do_narrow, COMDAT
; _this$ = ecx

; 2779 : 		{	// narrow elements in [_First, _Last) to chars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 14	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00014	33 d2		 xor	 edx, edx
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0001e	2b fe		 sub	 edi, esi
  00020	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv168[ebp], 0
  00027	47		 inc	 edi
  00028	d1 ef		 shr	 edi, 1
  0002a	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0002d	0f 47 fa	 cmova	 edi, edx

; 2780 : 		_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2781 : 		for (; _First != _Last; ++_First, ++_Dest)

  00030	85 ff		 test	 edi, edi
  00032	74 4e		 je	 SHORT $LN14@do_narrow
  00034	83 c1 18	 add	 ecx, 24			; 00000018H
  00037	89 4d ec	 mov	 DWORD PTR tv164[ebp], ecx
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL4@do_narrow:

; 2782 : 			*_Dest = _Donarrow(*_First, _Dflt);

  00040	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00043	0f 57 c0	 xorps	 xmm0, xmm0
  00046	51		 push	 ecx
  00047	8d 4d e4	 lea	 ecx, DWORD PTR __Mbst$1[ebp]
  0004a	66 0f d6 45 e4	 movq	 QWORD PTR __Mbst$1[ebp], xmm0
  0004f	51		 push	 ecx
  00050	50		 push	 eax
  00051	8d 45 f4	 lea	 eax, DWORD PTR __Buf$2[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 __Wcrtomb
  0005a	0f b6 4d 10	 movzx	 ecx, BYTE PTR __Dflt$[ebp]
  0005e	8d 5b 01	 lea	 ebx, DWORD PTR [ebx+1]
  00061	0f b6 55 f4	 movzx	 edx, BYTE PTR __Buf$2[ebp]
  00065	83 c4 10	 add	 esp, 16			; 00000010H
  00068	83 f8 01	 cmp	 eax, 1
  0006b	8b 45 f0	 mov	 eax, DWORD PTR tv168[ebp]
  0006e	0f 45 d1	 cmovne	 edx, ecx
  00071	8b 4d ec	 mov	 ecx, DWORD PTR tv164[ebp]
  00074	40		 inc	 eax
  00075	88 53 ff	 mov	 BYTE PTR [ebx-1], dl
  00078	83 c6 02	 add	 esi, 2
  0007b	89 45 f0	 mov	 DWORD PTR tv168[ebp], eax
  0007e	3b c7		 cmp	 eax, edi
  00080	75 be		 jne	 SHORT $LL4@do_narrow
$LN14@do_narrow:

; 2783 : 		return (_First);
; 2784 : 		}

  00082	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00085	8b c6		 mov	 eax, esi
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	33 cd		 xor	 ecx, ebp
  0008b	5b		 pop	 ebx
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z ENDP	; std::ctype<wchar_t>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_narrow@?$ctype@_W@std@@MBED_WD@Z
_TEXT	SEGMENT
__Mbst$1 = -20						; size = 8
__Buf$2 = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
__Ch$ = 8						; size = 2
__Dflt$ = 12						; size = 1
?do_narrow@?$ctype@_W@std@@MBED_WD@Z PROC		; std::ctype<wchar_t>::do_narrow, COMDAT
; _this$ = ecx

; 2773 : 		{	// narrow element to char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2774 : 		return (_Donarrow(_Ch, _Dflt));

  00010	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	50		 push	 eax
  00017	8d 45 ec	 lea	 eax, DWORD PTR __Mbst$1[ebp]
  0001a	66 0f d6 45 ec	 movq	 QWORD PTR __Mbst$1[ebp], xmm0
  0001f	50		 push	 eax
  00020	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00023	8d 45 f4	 lea	 eax, DWORD PTR __Buf$2[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __Wcrtomb
  0002c	0f b6 4d 0c	 movzx	 ecx, BYTE PTR __Dflt$[ebp]
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	0f b6 55 f4	 movzx	 edx, BYTE PTR __Buf$2[ebp]
  00037	83 f8 01	 cmp	 eax, 1
  0003a	0f 45 d1	 cmovne	 edx, ecx

; 2775 : 		}

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	33 cd		 xor	 ecx, ebp
  00042	8a c2		 mov	 al, dl
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
?do_narrow@?$ctype@_W@std@@MBED_WD@Z ENDP		; std::ctype<wchar_t>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Donarrow@?$ctype@_W@std@@IBED_WD@Z
_TEXT	SEGMENT
__Mbst$ = -20						; size = 8
__Buf$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
__Ch$ = 8						; size = 2
__Dflt$ = 12						; size = 1
?_Donarrow@?$ctype@_W@std@@IBED_WD@Z PROC		; std::ctype<wchar_t>::_Donarrow, COMDAT
; _this$ = ecx

; 2765 : 		{	// narrow element to char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2766 : 		char _Buf[MB_LEN_MAX];
; 2767 : 		_Mbstinit(_Mbst);
; 2768 : 		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1

  00010	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	50		 push	 eax
  00017	8d 45 ec	 lea	 eax, DWORD PTR __Mbst$[ebp]
  0001a	66 0f d6 45 ec	 movq	 QWORD PTR __Mbst$[ebp], xmm0
  0001f	50		 push	 eax
  00020	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00023	8d 45 f4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __Wcrtomb
  0002c	0f b6 4d 0c	 movzx	 ecx, BYTE PTR __Dflt$[ebp]
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	0f b6 55 f4	 movzx	 edx, BYTE PTR __Buf$[ebp]
  00037	83 f8 01	 cmp	 eax, 1
  0003a	0f 45 d1	 cmovne	 edx, ecx

; 2769 : 			? _Dflt : _Buf[0]);
; 2770 : 		}

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	33 cd		 xor	 ecx, ebp
  00042	8a c2		 mov	 al, dl
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
?_Donarrow@?$ctype@_W@std@@IBED_WD@Z ENDP		; std::ctype<wchar_t>::_Donarrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z
_TEXT	SEGMENT
__Mbst$1 = -16						; size = 8
tv129 = -8						; size = 4
tv160 = -4						; size = 4
__Wc$2 = 8						; size = 2
__First$ = 8						; size = 4
__Byte$ = 12						; size = 1
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z PROC		; std::ctype<wchar_t>::do_widen, COMDAT
; _this$ = ecx

; 2757 : 		{	// widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000a	33 d2		 xor	 edx, edx
  0000c	57		 push	 edi
  0000d	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  00010	2b fe		 sub	 edi, esi
  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv160[ebp], 0
  00019	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001c	0f 47 fa	 cmova	 edi, edx

; 2758 : 		_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2759 : 		for (; _First != _Last; ++_First, ++_Dest)

  0001f	85 ff		 test	 edi, edi
  00021	74 56		 je	 SHORT $LN12@do_widen
  00023	83 c1 18	 add	 ecx, 24			; 00000018H
  00026	53		 push	 ebx
  00027	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  0002a	89 4d f8	 mov	 DWORD PTR tv129[ebp], ecx
  0002d	0f 1f 00	 npad	 3
$LL4@do_widen:

; 2760 : 			*_Dest = _Dowiden(*_First);

  00030	8a 06		 mov	 al, BYTE PTR [esi]
  00032	0f 57 c0	 xorps	 xmm0, xmm0
  00035	88 45 0c	 mov	 BYTE PTR __Byte$[ebp], al
  00038	8d 45 f0	 lea	 eax, DWORD PTR __Mbst$1[ebp]
  0003b	51		 push	 ecx
  0003c	50		 push	 eax
  0003d	6a 01		 push	 1
  0003f	8d 45 0c	 lea	 eax, DWORD PTR __Byte$[ebp]
  00042	66 0f d6 45 f0	 movq	 QWORD PTR __Mbst$1[ebp], xmm0
  00047	50		 push	 eax
  00048	8d 45 08	 lea	 eax, DWORD PTR __Wc$2[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 __Mbrtowc
  00051	0f b7 4d 08	 movzx	 ecx, WORD PTR __Wc$2[ebp]
  00055	8d 5b 02	 lea	 ebx, DWORD PTR [ebx+2]
  00058	83 c4 14	 add	 esp, 20			; 00000014H
  0005b	85 c0		 test	 eax, eax
  0005d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00062	0f 48 c8	 cmovs	 ecx, eax
  00065	8b 45 fc	 mov	 eax, DWORD PTR tv160[ebp]
  00068	40		 inc	 eax
  00069	66 89 4b fe	 mov	 WORD PTR [ebx-2], cx
  0006d	8b 4d f8	 mov	 ecx, DWORD PTR tv129[ebp]
  00070	46		 inc	 esi
  00071	89 45 fc	 mov	 DWORD PTR tv160[ebp], eax
  00074	3b c7		 cmp	 eax, edi
  00076	75 b8		 jne	 SHORT $LL4@do_widen
  00078	5b		 pop	 ebx
$LN12@do_widen:
  00079	5f		 pop	 edi

; 2761 : 		return (_First);

  0007a	8b c6		 mov	 eax, esi
  0007c	5e		 pop	 esi

; 2762 : 		}

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z ENDP		; std::ctype<wchar_t>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_widen@?$ctype@_W@std@@MBE_WD@Z
_TEXT	SEGMENT
__Mbst$1 = -12						; size = 8
__Wc$2 = -4						; size = 2
__Byte$ = 8						; size = 1
__Byte$ = 8						; size = 1
?do_widen@?$ctype@_W@std@@MBE_WD@Z PROC			; std::ctype<wchar_t>::do_widen, COMDAT
; _this$ = ecx

; 2751 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2752 : 		return (_Dowiden(_Byte));

  00006	8a 45 08	 mov	 al, BYTE PTR __Byte$[ebp]
  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	88 45 08	 mov	 BYTE PTR __Byte$[ebp], al
  0000f	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00012	50		 push	 eax
  00013	8d 45 f4	 lea	 eax, DWORD PTR __Mbst$1[ebp]
  00016	66 0f d6 45 f4	 movq	 QWORD PTR __Mbst$1[ebp], xmm0
  0001b	50		 push	 eax
  0001c	6a 01		 push	 1
  0001e	8d 45 08	 lea	 eax, DWORD PTR __Byte$[ebp]
  00021	50		 push	 eax
  00022	8d 45 fc	 lea	 eax, DWORD PTR __Wc$2[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 __Mbrtowc
  0002b	0f b7 4d fc	 movzx	 ecx, WORD PTR __Wc$2[ebp]
  0002f	83 c4 14	 add	 esp, 20			; 00000014H
  00032	85 c0		 test	 eax, eax
  00034	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00039	0f 48 ca	 cmovs	 ecx, edx
  0003c	66 8b c1	 mov	 ax, cx

; 2753 : 		}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?do_widen@?$ctype@_W@std@@MBE_WD@Z ENDP			; std::ctype<wchar_t>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Dowiden@?$ctype@_W@std@@IBE_WD@Z
_TEXT	SEGMENT
__Mbst$ = -12						; size = 8
__Wc$ = -4						; size = 2
__Byte$ = 8						; size = 1
?_Dowiden@?$ctype@_W@std@@IBE_WD@Z PROC			; std::ctype<wchar_t>::_Dowiden, COMDAT
; _this$ = ecx

; 2743 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2744 : 		_Mbstinit(_Mbst);
; 2745 : 		wchar_t _Wc;
; 2746 : 		return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0

  00006	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	50		 push	 eax
  0000d	8d 45 f4	 lea	 eax, DWORD PTR __Mbst$[ebp]
  00010	66 0f d6 45 f4	 movq	 QWORD PTR __Mbst$[ebp], xmm0
  00015	50		 push	 eax
  00016	6a 01		 push	 1
  00018	8d 45 08	 lea	 eax, DWORD PTR __Byte$[ebp]
  0001b	50		 push	 eax
  0001c	8d 45 fc	 lea	 eax, DWORD PTR __Wc$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 __Mbrtowc
  00025	0f b7 4d fc	 movzx	 ecx, WORD PTR __Wc$[ebp]
  00029	83 c4 14	 add	 esp, 20			; 00000014H
  0002c	85 c0		 test	 eax, eax
  0002e	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00033	0f 48 ca	 cmovs	 ecx, edx
  00036	66 8b c1	 mov	 ax, cx

; 2747 : 			? (wchar_t)WEOF : _Wc);
; 2748 : 		}

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Dowiden@?$ctype@_W@std@@IBE_WD@Z ENDP			; std::ctype<wchar_t>::_Dowiden
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv131 = 12						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z PROC	; std::ctype<wchar_t>::do_toupper, COMDAT
; _this$ = ecx

; 2735 : 		{	// convert [_First, _Last) in place to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	43		 inc	 ebx
  00010	d1 eb		 shr	 ebx, 1
  00012	57		 push	 edi
  00013	33 ff		 xor	 edi, edi
  00015	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00018	0f 47 da	 cmova	 ebx, edx

; 2736 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2737 : 		for (; _First != _Last; ++_First)

  0001b	85 db		 test	 ebx, ebx
  0001d	74 21		 je	 SHORT $LN10@do_toupper
  0001f	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00022	89 45 0c	 mov	 DWORD PTR tv131[ebp], eax
$LL4@do_toupper:

; 2738 : 			*_First = _Towupper(*_First, &_Ctype);

  00025	50		 push	 eax
  00026	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 __Towupper
  0002f	66 89 06	 mov	 WORD PTR [esi], ax
  00032	47		 inc	 edi
  00033	8b 45 0c	 mov	 eax, DWORD PTR tv131[ebp]
  00036	83 c4 08	 add	 esp, 8
  00039	83 c6 02	 add	 esi, 2
  0003c	3b fb		 cmp	 edi, ebx
  0003e	75 e5		 jne	 SHORT $LL4@do_toupper
$LN10@do_toupper:
  00040	5f		 pop	 edi

; 2739 : 		return ((const _Elem *)_First);

  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 2740 : 		}

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z ENDP	; std::ctype<wchar_t>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_toupper@?$ctype@_W@std@@MBE_W_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?do_toupper@?$ctype@_W@std@@MBE_W_W@Z PROC		; std::ctype<wchar_t>::do_toupper, COMDAT
; _this$ = ecx

; 2729 : 		{	// convert element to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2730 : 		return (_Towupper(_Ch, &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  0000a	e8 00 00 00 00	 call	 __Towupper
  0000f	83 c4 08	 add	 esp, 8

; 2731 : 		}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?do_toupper@?$ctype@_W@std@@MBE_W_W@Z ENDP		; std::ctype<wchar_t>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv131 = 12						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z PROC	; std::ctype<wchar_t>::do_tolower, COMDAT
; _this$ = ecx

; 2721 : 		{	// convert [_First, _Last) in place to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	43		 inc	 ebx
  00010	d1 eb		 shr	 ebx, 1
  00012	57		 push	 edi
  00013	33 ff		 xor	 edi, edi
  00015	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00018	0f 47 da	 cmova	 ebx, edx

; 2722 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2723 : 		for (; _First != _Last; ++_First)

  0001b	85 db		 test	 ebx, ebx
  0001d	74 21		 je	 SHORT $LN10@do_tolower
  0001f	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00022	89 45 0c	 mov	 DWORD PTR tv131[ebp], eax
$LL4@do_tolower:

; 2724 : 			*_First = _Towlower(*_First, &_Ctype);

  00025	50		 push	 eax
  00026	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 __Towlower
  0002f	66 89 06	 mov	 WORD PTR [esi], ax
  00032	47		 inc	 edi
  00033	8b 45 0c	 mov	 eax, DWORD PTR tv131[ebp]
  00036	83 c4 08	 add	 esp, 8
  00039	83 c6 02	 add	 esi, 2
  0003c	3b fb		 cmp	 edi, ebx
  0003e	75 e5		 jne	 SHORT $LL4@do_tolower
$LN10@do_tolower:
  00040	5f		 pop	 edi

; 2725 : 		return ((const _Elem *)_First);

  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 2726 : 		}

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z ENDP	; std::ctype<wchar_t>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_tolower@?$ctype@_W@std@@MBE_W_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?do_tolower@?$ctype@_W@std@@MBE_W_W@Z PROC		; std::ctype<wchar_t>::do_tolower, COMDAT
; _this$ = ecx

; 2715 : 		{	// convert element to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2716 : 		return (_Towlower(_Ch, &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  0000a	e8 00 00 00 00	 call	 __Towlower
  0000f	83 c4 08	 add	 esp, 8

; 2717 : 		}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?do_tolower@?$ctype@_W@std@@MBE_W_W@Z ENDP		; std::ctype<wchar_t>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z PROC	; std::ctype<wchar_t>::do_scan_not, COMDAT
; _this$ = ecx

; 2707 : 		{	// find first in [_First, _Last) not fitting mask classification

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 2708 : 		_DEBUG_RANGE(_First, _Last);
; 2709 : 		for (; _First != _Last && is(_Maskval, *_First); ++_First)

  00005	8b 75 0c	 mov	 esi, DWORD PTR __First$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	3b f7		 cmp	 esi, edi
  00010	74 1b		 je	 SHORT $LN12@do_scan_no
$LL4@do_scan_no:
  00012	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00015	8b cb		 mov	 ecx, ebx
  00017	8b 13		 mov	 edx, DWORD PTR [ebx]
  00019	50		 push	 eax
  0001a	ff 75 08	 push	 DWORD PTR __Maskval$[ebp]
  0001d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00020	ff d0		 call	 eax
  00022	84 c0		 test	 al, al
  00024	74 07		 je	 SHORT $LN12@do_scan_no
  00026	83 c6 02	 add	 esi, 2
  00029	3b f7		 cmp	 esi, edi
  0002b	75 e5		 jne	 SHORT $LL4@do_scan_no
$LN12@do_scan_no:
  0002d	5f		 pop	 edi

; 2710 : 			;
; 2711 : 		return (_First);

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx

; 2712 : 		}

  00032	5d		 pop	 ebp
  00033	c2 0c 00	 ret	 12			; 0000000cH
?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z ENDP	; std::ctype<wchar_t>::do_scan_not
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z PROC	; std::ctype<wchar_t>::do_scan_is, COMDAT
; _this$ = ecx

; 2698 : 		{	// find first in [_First, _Last) that fits mask classification

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 2699 : 		_DEBUG_RANGE(_First, _Last);
; 2700 : 		for (; _First != _Last && !is(_Maskval, *_First); ++_First)

  00005	8b 75 0c	 mov	 esi, DWORD PTR __First$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	3b f7		 cmp	 esi, edi
  00010	74 1b		 je	 SHORT $LN12@do_scan_is
$LL4@do_scan_is:
  00012	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00015	8b cb		 mov	 ecx, ebx
  00017	8b 13		 mov	 edx, DWORD PTR [ebx]
  00019	50		 push	 eax
  0001a	ff 75 08	 push	 DWORD PTR __Maskval$[ebp]
  0001d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00020	ff d0		 call	 eax
  00022	84 c0		 test	 al, al
  00024	75 07		 jne	 SHORT $LN12@do_scan_is
  00026	83 c6 02	 add	 esi, 2
  00029	3b f7		 cmp	 esi, edi
  0002b	75 e5		 jne	 SHORT $LL4@do_scan_is
$LN12@do_scan_is:
  0002d	5f		 pop	 edi

; 2701 : 			;
; 2702 : 		return (_First);

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx

; 2703 : 		}

  00032	5d		 pop	 ebp
  00033	c2 0c 00	 ret	 12			; 0000000cH
?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z ENDP	; std::ctype<wchar_t>::do_scan_is
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z PROC		; std::ctype<wchar_t>::do_is, COMDAT
; _this$ = ecx

; 2691 : 		{	// get mask sequence for elements in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2692 : 		_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2693 : 		return (_CSTD _Getwctypes(_First, _Last, _Dest, &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 __Getwctypes
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 2694 : 		}

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z ENDP		; std::ctype<wchar_t>::do_is
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_is@?$ctype@_W@std@@MBE_NF_W@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 2
?do_is@?$ctype@_W@std@@MBE_NF_W@Z PROC			; std::ctype<wchar_t>::do_is, COMDAT
; _this$ = ecx

; 2685 : 		{	// test if element fits any mask classifications

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2686 : 		return ((_CSTD _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  0000a	e8 00 00 00 00	 call	 __Getwctype
  0000f	83 c4 08	 add	 esp, 8
  00012	66 85 45 08	 test	 WORD PTR __Maskval$[ebp], ax
  00016	0f 95 c0	 setne	 al

; 2687 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?do_is@?$ctype@_W@std@@MBE_NF_W@Z ENDP			; std::ctype<wchar_t>::do_is
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Init@?$ctype@_W@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T1 = -60						; size = 44
$T2 = -16						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$ctype@_W@std@@IAEXABV_Locinfo@2@@Z PROC	; std::ctype<wchar_t>::_Init, COMDAT
; _this$ = ecx

; 2679 : 		{	// initialize from _Lobj

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 2680 : 		_Ctype = _Lobj._Getctype();

  00006	8d 45 f0	 lea	 eax, DWORD PTR $T2[ebp]
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 __Getctype
  00012	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]

; 2681 : 		_Cvt = _Lobj._Getcvt();

  00015	8d 45 c4	 lea	 eax, DWORD PTR $T1[ebp]
  00018	50		 push	 eax
  00019	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0
  0001d	e8 00 00 00 00	 call	 __Getcvt
  00022	83 c4 08	 add	 esp, 8
  00025	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00028	0f 11 46 18	 movups	 XMMWORD PTR [esi+24], xmm0
  0002c	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  00030	0f 11 46 28	 movups	 XMMWORD PTR [esi+40], xmm0
  00034	f3 0f 7e 40 20	 movq	 xmm0, QWORD PTR [eax+32]
  00039	66 0f d6 46 38	 movq	 QWORD PTR [esi+56], xmm0
  0003e	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00041	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00044	5e		 pop	 esi

; 2682 : 		}

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
?_Init@?$ctype@_W@std@@IAEXABV_Locinfo@2@@Z ENDP	; std::ctype<wchar_t>::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??1?$ctype@_W@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@_W@std@@MAE@XZ PROC				; std::ctype<wchar_t>::~ctype<wchar_t>, COMDAT
; _this$ = ecx

; 2671 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2672 : 		if (_Ctype._Delfl)

  00003	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@_W@std@@6B@
  0000d	74 0b		 je	 SHORT $LN2@ctype

; 2673 : 			_CSTD free((void *)_Ctype._Table);

  0000f	ff 76 0c	 push	 DWORD PTR [esi+12]
  00012	e8 00 00 00 00	 call	 _free
  00017	83 c4 04	 add	 esp, 4
$LN2@ctype:

; 2674 : 
; 2675 : 		_CSTD free(_Ctype._LocaleName);

  0001a	ff 76 14	 push	 DWORD PTR [esi+20]
  0001d	e8 00 00 00 00	 call	 _free
  00022	83 c4 04	 add	 esp, 4

; 2676 : 		}

  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002b	5e		 pop	 esi
  0002c	c3		 ret	 0
??1?$ctype@_W@std@@MAE@XZ ENDP				; std::ctype<wchar_t>::~ctype<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 52
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<wchar_t>::_Getcat, COMDAT

; 2662 : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2663 : 		if (_Ppf != 0 && *_Ppf == 0)

  00028	8b 75 08	 mov	 esi, DWORD PTR __Ppf$[ebp]
  0002b	33 db		 xor	 ebx, ebx
  0002d	89 5d f0	 mov	 DWORD PTR $T3[ebp], ebx
  00030	85 f6		 test	 esi, esi
  00032	74 60		 je	 SHORT $LN19@Getcat
  00034	39 1e		 cmp	 DWORD PTR [esi], ebx
  00036	75 5c		 jne	 SHORT $LN19@Getcat

; 2664 : 			*_Ppf = new ctype<_Elem>(

  00038	6a 44		 push	 68			; 00000044H
  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	8b f8		 mov	 edi, eax
  00041	83 c4 04	 add	 esp, 4
  00044	89 7d 08	 mov	 DWORD PTR $T4[ebp], edi
  00047	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0004a	85 ff		 test	 edi, edi
  0004c	74 35		 je	 SHORT $LN4@Getcat
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR __Ploc$[ebp]
  00051	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00054	85 c9		 test	 ecx, ecx
  00056	75 07		 jne	 SHORT $LN12@Getcat
  00058	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0005d	eb 0a		 jmp	 SHORT $LN17@Getcat
$LN12@Getcat:
  0005f	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00062	85 c0		 test	 eax, eax
  00064	75 03		 jne	 SHORT $LN17@Getcat
  00066	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
$LN17@Getcat:
  00069	50		 push	 eax
  0006a	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0006d	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00072	6a 00		 push	 0
  00074	50		 push	 eax
  00075	8b cf		 mov	 ecx, edi
  00077	bb 01 00 00 00	 mov	 ebx, 1
  0007c	e8 00 00 00 00	 call	 ??0?$ctype@_W@std@@QAE@ABV_Locinfo@1@I@Z ; std::ctype<wchar_t>::ctype<wchar_t>
  00081	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00083	33 c0		 xor	 eax, eax
$LN5@Getcat:
  00085	89 06		 mov	 DWORD PTR [esi], eax
  00087	f6 c3 01	 test	 bl, 1
  0008a	74 08		 je	 SHORT $LN19@Getcat
  0008c	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0008f	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN19@Getcat:

; 2665 : 				_Locinfo(_Ploc->c_str()));
; 2666 : 		return (_X_CTYPE);

  00094	b8 02 00 00 00	 mov	 eax, 2

; 2667 : 		}

  00099	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a3	59		 pop	 ecx
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 44		 push	 68			; 00000044H
  00002	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<wchar_t>::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0?$ctype@_W@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
$T1 = -64						; size = 44
$T2 = -20						; size = 16
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@_W@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<wchar_t>::ctype<wchar_t>, COMDAT
; _this$ = ecx

; 2656 : 		{	// construct from specified locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 2655 : 		: ctype_base(_Refs)

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  00009	56		 push	 esi

; 2656 : 		{	// construct from specified locale

  0000a	8b f1		 mov	 esi, ecx
  0000c	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000f	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2657 : 		_Init(_Lobj);

  00012	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00015	50		 push	 eax
  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@_W@std@@6B@
  0001c	e8 00 00 00 00	 call	 __Getctype
  00021	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00024	8d 45 c0	 lea	 eax, DWORD PTR $T1[ebp]
  00027	50		 push	 eax
  00028	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0
  0002c	e8 00 00 00 00	 call	 __Getcvt
  00031	83 c4 08	 add	 esp, 8
  00034	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00037	0f 11 46 18	 movups	 XMMWORD PTR [esi+24], xmm0
  0003b	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  0003f	0f 11 46 28	 movups	 XMMWORD PTR [esi+40], xmm0
  00043	f3 0f 7e 40 20	 movq	 xmm0, QWORD PTR [eax+32]
  00048	66 0f d6 46 38	 movq	 QWORD PTR [esi+56], xmm0
  0004d	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00050	89 46 40	 mov	 DWORD PTR [esi+64], eax

; 2658 : 		}

  00053	8b c6		 mov	 eax, esi
  00055	5e		 pop	 esi
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
??0?$ctype@_W@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<wchar_t>::ctype<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?widen@?$ctype@_W@std@@QBEPBDPBD0PA_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?widen@?$ctype@_W@std@@QBEPBDPBD0PA_W@Z PROC		; std::ctype<wchar_t>::widen, COMDAT
; _this$ = ecx

; 2629 : 		{	// widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2630 : 		return (do_widen(_First, _Last, _Dest));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2631 : 		}

  00005	5d		 pop	 ebp

; 2630 : 		return (do_widen(_First, _Last, _Dest));

  00006	ff 60 2c	 jmp	 DWORD PTR [eax+44]
?widen@?$ctype@_W@std@@QBEPBDPBD0PA_W@Z ENDP		; std::ctype<wchar_t>::widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?widen@?$ctype@_W@std@@QBE_WD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?widen@?$ctype@_W@std@@QBE_WD@Z PROC			; std::ctype<wchar_t>::widen, COMDAT
; _this$ = ecx

; 2623 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2624 : 		return (do_widen(_Byte));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2625 : 		}

  00005	5d		 pop	 ebp

; 2624 : 		return (do_widen(_Byte));

  00006	ff 60 30	 jmp	 DWORD PTR [eax+48]
?widen@?$ctype@_W@std@@QBE_WD@Z ENDP			; std::ctype<wchar_t>::widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?is@?$ctype@_W@std@@QBE_NF_W@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 2
?is@?$ctype@_W@std@@QBE_NF_W@Z PROC			; std::ctype<wchar_t>::is, COMDAT
; _this$ = ecx

; 2580 : 		{	// test if element fits any mask classifications

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2581 : 		return (do_is(_Maskval, _Ch));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 2582 : 		}

  00008	5d		 pop	 ebp

; 2581 : 		return (do_is(_Maskval, _Ch));

  00009	ff e0		 jmp	 eax
?is@?$ctype@_W@std@@QBE_NF_W@Z ENDP			; std::ctype<wchar_t>::is
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 553  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 554  :  #if _NO_LOCALES
; 555  : 	static _Wrap_facet<_Facet> _Wfac;
; 556  : 	return (*(_Facet *)&_Wfac);
; 557  : 
; 558  :  #else /* _NO_LOCALES */
; 559  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 560  : 		const locale::facet *_Psave =
; 561  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 562  : 
; 563  : 		size_t _Id = _Facet::id;

  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
  00038	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	89 5d f0	 mov	 DWORD PTR __Psave$5[ebp], ebx
  00048	85 ff		 test	 edi, edi
  0004a	75 2f		 jne	 SHORT $LN11@use_facet
  0004c	57		 push	 edi
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, edi ; std::ctype<char>::id
  0005b	75 10		 jne	 SHORT $LN12@use_facet
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00062	40		 inc	 eax
  00063	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, eax ; std::ctype<char>::id
$LN12@use_facet:
  0006d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00070	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00075	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
$LN11@use_facet:

; 564  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0007e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00081	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00084	73 0c		 jae	 SHORT $LN20@use_facet
  00086	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00089	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  0008c	85 f6		 test	 esi, esi
  0008e	75 77		 jne	 SHORT $LN7@use_facet
  00090	eb 02		 jmp	 SHORT $LN28@use_facet
$LN20@use_facet:
  00092	33 f6		 xor	 esi, esi
$LN28@use_facet:
  00094	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00098	74 10		 je	 SHORT $LN17@use_facet
  0009a	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009f	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000a2	73 0a		 jae	 SHORT $LN29@use_facet
  000a4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a7	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN17@use_facet:

; 565  : 
; 566  : 		if (_Pf != 0)

  000aa	85 f6		 test	 esi, esi
  000ac	75 59		 jne	 SHORT $LN7@use_facet
$LN29@use_facet:

; 567  : 			;	// got facet from locale
; 568  : 		else if (_Psave != 0)

  000ae	85 db		 test	 ebx, ebx
  000b0	74 04		 je	 SHORT $LN4@use_facet

; 569  : 			_Pf = _Psave;	// lazy facet already allocated

  000b2	8b f3		 mov	 esi, ebx
  000b4	eb 51		 jmp	 SHORT $LN7@use_facet
$LN4@use_facet:

; 570  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000b6	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  000b9	8d 45 f0	 lea	 eax, DWORD PTR __Psave$5[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
  000c2	83 c4 08	 add	 esp, 8
  000c5	83 f8 ff	 cmp	 eax, -1
  000c8	75 24		 jne	 SHORT $LN6@use_facet

; 571  : 
; 572  :  #if _HAS_EXCEPTIONS
; 573  : 
; 574  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000ca	0f 57 c0	 xorps	 xmm0, xmm0
  000cd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7bad_cast@std@@6B@
  000d4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000d9	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  000dc	66 0f d6 45 e0	 movq	 QWORD PTR $T2[ebp+4], xmm0
  000e1	50		 push	 eax
  000e2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@use_facet:
$LN6@use_facet:

; 575  : 
; 576  :  #else /* _HAS_EXCEPTIONS */
; 577  : 			abort();	// lazy disallowed
; 578  :  #endif /* _HAS_EXCEPTIONS */
; 579  : 
; 580  : 		else
; 581  : 			{	// queue up lazy facet for destruction
; 582  : 			_Pf = _Psave;

  000ee	8b 75 f0	 mov	 esi, DWORD PTR __Psave$5[ebp]

; 583  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 584  : 
; 585  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 586  : 			_Pfmod->_Incref();

  000f1	8b ce		 mov	 ecx, esi
  000f3	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<char> >::_Psave
  000f9	8b 16		 mov	 edx, DWORD PTR [esi]
  000fb	ff 52 04	 call	 DWORD PTR [edx+4]

; 587  : 
; 588  :  #if defined(_M_CEE)
; 589  : 			_Facet_Register_m(_Pfmod);
; 590  : 
; 591  :  #else /* defined(_M_CEE) */
; 592  : 			_Facet_Register(_Pfmod);

  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  00104	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 593  :  #endif /* defined(_M_CEE) */
; 594  : 			}
; 595  : 
; 596  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00107	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0010a	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0010f	8b c6		 mov	 eax, esi

; 597  : 	_END_LOCK()
; 598  :  #endif /* _NO_LOCALES */
; 599  : 	}	// end of use_facet body

  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN31@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
; Function compile flags: /Ogtp
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  0000f	85 c0		 test	 eax, eax
  00011	7e 0a		 jle	 SHORT $LN22@scalar
  00013	ff 76 0c	 push	 DWORD PTR [esi+12]
  00016	e8 00 00 00 00	 call	 _free
  0001b	eb 0a		 jmp	 SHORT $LN23@scalar
$LN22@scalar:
  0001d	79 0b		 jns	 SHORT $LN10@scalar
  0001f	ff 76 0c	 push	 DWORD PTR [esi+12]
  00022	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
$LN23@scalar:
  00027	83 c4 04	 add	 esp, 4
$LN10@scalar:
  0002a	ff 76 14	 push	 DWORD PTR [esi+20]
  0002d	e8 00 00 00 00	 call	 _free
  00032	83 c4 04	 add	 esp, 4
  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0003b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003f	74 0b		 je	 SHORT $LN21@scalar
  00041	6a 18		 push	 24			; 00000018H
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00049	83 c4 08	 add	 esp, 8
$LN21@scalar:
  0004c	8b c6		 mov	 eax, esi
  0004e	5e		 pop	 esi
  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2558 : 		{	// narrow elements in [_First, _Last) to chars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2559 : 		_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2560 : 		_CSTD memcpy(_Dest, _First, _Last - _First);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	52		 push	 edx
  0000d	ff 75 14	 push	 DWORD PTR __Dest$[ebp]
  00010	e8 00 00 00 00	 call	 _memcpy

; 2561 : 		return (_Last);

  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2562 : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2552 : 		{	// narrow char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2553 : 		return (_Ch);

  00003	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]

; 2554 : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2545 : 		{	// widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2546 : 		_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2547 : 		_CSTD memcpy(_Dest, _First, _Last - _First);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	52		 push	 edx
  0000d	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00010	e8 00 00 00 00	 call	 _memcpy

; 2548 : 		return (_Last);

  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2549 : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2539 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2540 : 		return (_Byte);

  00003	8a 45 08	 mov	 al, BYTE PTR __Byte$[ebp]

; 2541 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv132 = 12						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2531 : 		{	// convert [_First, _Last) in place to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	57		 push	 edi
  00010	33 ff		 xor	 edi, edi
  00012	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00015	0f 47 da	 cmova	 ebx, edx

; 2532 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2533 : 		for (; _First != _Last; ++_First)

  00018	85 db		 test	 ebx, ebx
  0001a	74 1e		 je	 SHORT $LN10@do_toupper
  0001c	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  0001f	89 45 0c	 mov	 DWORD PTR tv132[ebp], eax
$LL4@do_toupper:

; 2534 : 			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);

  00022	50		 push	 eax
  00023	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __Toupper
  0002c	88 06		 mov	 BYTE PTR [esi], al
  0002e	47		 inc	 edi
  0002f	8b 45 0c	 mov	 eax, DWORD PTR tv132[ebp]
  00032	83 c4 08	 add	 esp, 8
  00035	46		 inc	 esi
  00036	3b fb		 cmp	 edi, ebx
  00038	75 e8		 jne	 SHORT $LL4@do_toupper
$LN10@do_toupper:
  0003a	5f		 pop	 edi

; 2535 : 		return ((const _Elem *)_First);

  0003b	8b c6		 mov	 eax, esi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx

; 2536 : 		}

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2525 : 		{	// convert element to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2526 : 		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __Toupper
  00011	83 c4 08	 add	 esp, 8

; 2527 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv132 = 12						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2517 : 		{	// convert [_First, _Last) in place to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	57		 push	 edi
  00010	33 ff		 xor	 edi, edi
  00012	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00015	0f 47 da	 cmova	 ebx, edx

; 2518 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2519 : 		for (; _First != _Last; ++_First)

  00018	85 db		 test	 ebx, ebx
  0001a	74 1e		 je	 SHORT $LN10@do_tolower
  0001c	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  0001f	89 45 0c	 mov	 DWORD PTR tv132[ebp], eax
$LL4@do_tolower:

; 2520 : 			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);

  00022	50		 push	 eax
  00023	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __Tolower
  0002c	88 06		 mov	 BYTE PTR [esi], al
  0002e	47		 inc	 edi
  0002f	8b 45 0c	 mov	 eax, DWORD PTR tv132[ebp]
  00032	83 c4 08	 add	 esp, 8
  00035	46		 inc	 esi
  00036	3b fb		 cmp	 edi, ebx
  00038	75 e8		 jne	 SHORT $LL4@do_tolower
$LN10@do_tolower:
  0003a	5f		 pop	 edi

; 2521 : 		return ((const _Elem *)_First);

  0003b	8b c6		 mov	 eax, esi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx

; 2522 : 		}

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2511 : 		{	// convert element to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2512 : 		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __Tolower
  00011	83 c4 08	 add	 esp, 8

; 2513 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 2501 : 		{	// free any allocated storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2502 : 		if (0 < _Ctype._Delfl)

  00003	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00006	85 c0		 test	 eax, eax
  00008	7e 18		 jle	 SHORT $LN6@Tidy

; 2503 : 			_CSTD free((void *)_Ctype._Table);

  0000a	ff 76 0c	 push	 DWORD PTR [esi+12]
  0000d	e8 00 00 00 00	 call	 _free

; 2505 : 			delete[] _Ctype._Table;

  00012	83 c4 04	 add	 esp, 4

; 2506 : 
; 2507 : 		_CSTD free(_Ctype._LocaleName);

  00015	ff 76 14	 push	 DWORD PTR [esi+20]
  00018	e8 00 00 00 00	 call	 _free
  0001d	83 c4 04	 add	 esp, 4
  00020	5e		 pop	 esi

; 2508 : 		}

  00021	c3		 ret	 0
$LN6@Tidy:

; 2504 : 		else if (_Ctype._Delfl < 0)

  00022	79 0b		 jns	 SHORT $LN4@Tidy

; 2505 : 			delete[] _Ctype._Table;

  00024	ff 76 0c	 push	 DWORD PTR [esi+12]
  00027	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002c	83 c4 04	 add	 esp, 4
$LN4@Tidy:

; 2506 : 
; 2507 : 		_CSTD free(_Ctype._LocaleName);

  0002f	ff 76 14	 push	 DWORD PTR [esi+20]
  00032	e8 00 00 00 00	 call	 _free
  00037	83 c4 04	 add	 esp, 4
  0003a	5e		 pop	 esi

; 2508 : 		}

  0003b	c3		 ret	 0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 2496 : 		{	// initialize from _Lobj

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 2497 : 		_Ctype = _Lobj._Getctype();

  00006	8d 45 f0	 lea	 eax, DWORD PTR $T1[ebp]
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 __Getctype
  00012	83 c4 04	 add	 esp, 4
  00015	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00018	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0
  0001c	5e		 pop	 esi

; 2498 : 		}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2491 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2492 : 		_Tidy();

  00003	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  0000c	85 c0		 test	 eax, eax
  0000e	7e 0a		 jle	 SHORT $LN17@ctype
  00010	ff 76 0c	 push	 DWORD PTR [esi+12]
  00013	e8 00 00 00 00	 call	 _free
  00018	eb 0a		 jmp	 SHORT $LN18@ctype
$LN17@ctype:
  0001a	79 0b		 jns	 SHORT $LN6@ctype
  0001c	ff 76 0c	 push	 DWORD PTR [esi+12]
  0001f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
$LN18@ctype:
  00024	83 c4 04	 add	 esp, 4
$LN6@ctype:
  00027	ff 76 14	 push	 DWORD PTR [esi+20]
  0002a	e8 00 00 00 00	 call	 _free
  0002f	83 c4 04	 add	 esp, 4

; 2493 : 		}

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00038	5e		 pop	 esi
  00039	c3		 ret	 0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -84						; size = 52
$T3 = -32						; size = 16
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T5 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2468 : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2469 : 		if (_Ppf != 0 && *_Ppf == 0)

  00028	8b 7d 08	 mov	 edi, DWORD PTR __Ppf$[ebp]
  0002b	33 db		 xor	 ebx, ebx
  0002d	89 5d f0	 mov	 DWORD PTR $T4[ebp], ebx
  00030	85 ff		 test	 edi, edi
  00032	74 76		 je	 SHORT $LN34@Getcat
  00034	39 1f		 cmp	 DWORD PTR [edi], ebx
  00036	75 72		 jne	 SHORT $LN34@Getcat

; 2470 : 			*_Ppf = new ctype<_Elem>(

  00038	6a 18		 push	 24			; 00000018H
  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	8b f0		 mov	 esi, eax
  00041	83 c4 04	 add	 esp, 4
  00044	89 75 08	 mov	 DWORD PTR $T5[ebp], esi
  00047	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0004a	85 f6		 test	 esi, esi
  0004c	74 4b		 je	 SHORT $LN4@Getcat
  0004e	8b 45 0c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00051	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00054	85 c9		 test	 ecx, ecx
  00056	75 07		 jne	 SHORT $LN12@Getcat
  00058	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0005d	eb 0a		 jmp	 SHORT $LN17@Getcat
$LN12@Getcat:
  0005f	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00062	85 c0		 test	 eax, eax
  00064	75 03		 jne	 SHORT $LN17@Getcat
  00066	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
$LN17@Getcat:
  00069	50		 push	 eax
  0006a	8d 4d ac	 lea	 ecx, DWORD PTR $T2[ebp]
  0006d	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00072	8d 45 e0	 lea	 eax, DWORD PTR $T3[ebp]
  00075	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0007c	50		 push	 eax
  0007d	bb 01 00 00 00	 mov	 ebx, 1
  00082	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  00088	e8 00 00 00 00	 call	 __Getctype
  0008d	83 c4 04	 add	 esp, 4
  00090	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00093	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0
  00097	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00099	33 f6		 xor	 esi, esi
$LN5@Getcat:
  0009b	89 37		 mov	 DWORD PTR [edi], esi
  0009d	f6 c3 01	 test	 bl, 1
  000a0	74 08		 je	 SHORT $LN34@Getcat
  000a2	8d 4d ac	 lea	 ecx, DWORD PTR $T2[ebp]
  000a5	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN34@Getcat:

; 2471 : 				_Locinfo(_Ploc->c_str()));
; 2472 : 		return (_X_CTYPE);

  000aa	b8 02 00 00 00	 mov	 eax, 2

; 2473 : 		}

  000af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b9	59		 pop	 ecx
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 18		 push	 24			; 00000018H
  00002	8b 45 08	 mov	 eax, DWORD PTR $T5[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
$T1 = -20						; size = 16
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 2462 : 		{	// construct from current locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 2461 : 		: ctype_base(_Refs)

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  00009	56		 push	 esi

; 2462 : 		{	// construct from current locale

  0000a	8b f1		 mov	 esi, ecx
  0000c	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000f	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2463 : 		_Init(_Lobj);

  00012	8d 45 ec	 lea	 eax, DWORD PTR $T1[ebp]
  00015	50		 push	 eax
  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  0001c	e8 00 00 00 00	 call	 __Getctype
  00021	83 c4 04	 add	 esp, 4
  00024	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]

; 2464 : 		}

  00027	8b c6		 mov	 eax, esi
  00029	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0
  0002d	5e		 pop	 esi
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<char>::ctype<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z PROC		; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2421 : 		{	// widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2422 : 		return (do_widen(_First, _Last, _Dest));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2423 : 		}

  00005	5d		 pop	 ebp

; 2422 : 		return (do_widen(_First, _Last, _Dest));

  00006	ff 60 1c	 jmp	 DWORD PTR [eax+28]
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?widen@?$ctype@D@std@@QBEDD@Z PROC			; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2415 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2416 : 		return (do_widen(_Byte));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 40 20	 mov	 eax, DWORD PTR [eax+32]

; 2417 : 		}

  00008	5d		 pop	 ebp

; 2416 : 		return (do_widen(_Byte));

  00009	ff e0		 jmp	 eax
?widen@?$ctype@D@std@@QBEDD@Z ENDP			; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN13@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN13@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 2108 : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 2103 : 		{	// default constructor

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2102 : 		: locale::facet(_Refs)

  00004	8b 45 08	 mov	 eax, DWORD PTR __Refs$[ebp]
  00007	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2104 : 		}

  0000a	8b c1		 mov	 eax, ecx
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ctype_base@std@@6B@
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Mbst2$ = -24						; size = 8
__Mbst1$ = -16						; size = 8
__Count1$1$ = -8					; size = 4
__Wc$ = -4						; size = 2
__Ptrdest$1$ = 8					; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
__Cvt$ = 16						; size = 4
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z PROC	; std::_Maklocstr<wchar_t>, COMDAT

; 740  : 	{	// convert C string to wchar_t sequence using _Cvtvec

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx

; 741  : 	size_t _Count, _Count1;
; 742  : 	size_t _Wchars;
; 743  : 	const char *_Ptr1;
; 744  : 	int _Bytes;
; 745  : 	wchar_t _Wc;
; 746  : 	_Mbstinit(_Mbst1);
; 747  : 
; 748  : 	_Count1 = _CSTD strlen(_Ptr) + 1;

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	8b cb		 mov	 ecx, ebx
  0000f	66 0f d6 45 f0	 movq	 QWORD PTR __Mbst1$[ebp], xmm0
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL22@Maklocstr:
  00020	8a 01		 mov	 al, BYTE PTR [ecx]
  00022	41		 inc	 ecx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL22@Maklocstr
  00027	2b ca		 sub	 ecx, edx

; 749  : 	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;

  00029	33 f6		 xor	 esi, esi
  0002b	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0002e	89 45 f8	 mov	 DWORD PTR __Count1$1$[ebp], eax
  00031	8b f8		 mov	 edi, eax
  00033	85 c0		 test	 eax, eax
  00035	74 23		 je	 SHORT $LN14@Maklocstr
$LL4@Maklocstr:

; 751  : 		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)

  00037	ff 75 10	 push	 DWORD PTR __Cvt$[ebp]
  0003a	8d 45 f0	 lea	 eax, DWORD PTR __Mbst1$[ebp]
  0003d	50		 push	 eax
  0003e	57		 push	 edi
  0003f	8d 45 fc	 lea	 eax, DWORD PTR __Wc$[ebp]
  00042	53		 push	 ebx
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 __Mbrtowc
  00049	83 c4 14	 add	 esp, 20			; 00000014H
  0004c	85 c0		 test	 eax, eax
  0004e	7e 07		 jle	 SHORT $LN23@Maklocstr

; 750  : 		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)

  00050	03 d8		 add	 ebx, eax
  00052	46		 inc	 esi
  00053	2b f8		 sub	 edi, eax
  00055	75 e0		 jne	 SHORT $LL4@Maklocstr
$LN23@Maklocstr:
  00057	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
$LN14@Maklocstr:

; 752  : 			break;
; 753  : 	++_Wchars;	// count terminating nul

  0005a	46		 inc	 esi

; 754  : 
; 755  : 	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Wchars, sizeof (wchar_t),

  0005b	6a 02		 push	 2
  0005d	56		 push	 esi
  0005e	e8 00 00 00 00	 call	 _calloc
  00063	83 c4 08	 add	 esp, 8
  00066	89 45 08	 mov	 DWORD PTR __Ptrdest$1$[ebp], eax

; 756  : 		_CRT_BLOCK, __FILE__, __LINE__);
; 757  : 
; 758  : 	if (!_Ptrdest)

  00069	85 c0		 test	 eax, eax
  0006b	74 44		 je	 SHORT $LN26@Maklocstr

; 760  : 	wchar_t *_Ptrnext = _Ptrdest;

  0006d	0f 57 c0	 xorps	 xmm0, xmm0
  00070	8b f8		 mov	 edi, eax

; 761  : 	_Mbstinit(_Mbst2);

  00072	66 0f d6 45 e8	 movq	 QWORD PTR __Mbst2$[ebp], xmm0

; 762  : 
; 763  :  #pragma warning(push)
; 764  :  #pragma warning(disable: 6011)	/* quiet prefast noise */
; 765  : 	for (; 0 < _Wchars;

  00077	85 f6		 test	 esi, esi
  00079	74 2a		 je	 SHORT $LN15@Maklocstr
  0007b	0f 1f 44 00 00	 npad	 5
$LL7@Maklocstr:

; 767  : 		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)

  00080	ff 75 10	 push	 DWORD PTR __Cvt$[ebp]
  00083	8d 45 e8	 lea	 eax, DWORD PTR __Mbst2$[ebp]
  00086	50		 push	 eax
  00087	ff 75 f8	 push	 DWORD PTR __Count1$1$[ebp]
  0008a	53		 push	 ebx
  0008b	57		 push	 edi
  0008c	e8 00 00 00 00	 call	 __Mbrtowc
  00091	83 c4 14	 add	 esp, 20			; 00000014H
  00094	85 c0		 test	 eax, eax
  00096	7e 0a		 jle	 SHORT $LN24@Maklocstr

; 766  : 		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)

  00098	03 d8		 add	 ebx, eax
  0009a	83 c7 02	 add	 edi, 2
  0009d	83 ee 01	 sub	 esi, 1
  000a0	75 de		 jne	 SHORT $LL7@Maklocstr
$LN24@Maklocstr:
  000a2	8b 45 08	 mov	 eax, DWORD PTR __Ptrdest$1$[ebp]
$LN15@Maklocstr:

; 768  : 			break;
; 769  : 	*_Ptrnext = L'\0';

  000a5	33 c9		 xor	 ecx, ecx
  000a7	66 89 0f	 mov	 WORD PTR [edi], cx
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx

; 770  :  #pragma warning(pop)
; 771  : 
; 772  : 	return (_Ptrdest);
; 773  : 	}

  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
$LN26@Maklocstr:

; 759  : 		_Xbad_alloc();

  000b1	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN28@Maklocstr:
$LN25@Maklocstr:
  000b6	cc		 int	 3
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Mbst1$ = -12						; size = 8
__Wc$ = -4						; size = 2
__Byte$ = 8						; size = 1
___formal$ = 12						; size = 4
__Cvt$ = 16						; size = 4
??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z PROC	; std::_Maklocchr<wchar_t>, COMDAT

; 693  : 	{	// convert char to wchar_t using _Cvtvec

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 694  : 	wchar_t _Wc = L'\0';
; 695  : 	_Mbstinit(_Mbst1);
; 696  : 	_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);

  00006	ff 75 10	 push	 DWORD PTR __Cvt$[ebp]
  00009	8d 45 f4	 lea	 eax, DWORD PTR __Mbst1$[ebp]
  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Wc$[ebp], 0
  00013	50		 push	 eax
  00014	6a 01		 push	 1
  00016	8d 45 08	 lea	 eax, DWORD PTR __Byte$[ebp]
  00019	0f 57 c0	 xorps	 xmm0, xmm0
  0001c	50		 push	 eax
  0001d	8d 45 fc	 lea	 eax, DWORD PTR __Wc$[ebp]
  00020	66 0f d6 45 f4	 movq	 QWORD PTR __Mbst1$[ebp], xmm0
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 __Mbrtowc

; 697  : 	return (_Wc);

  0002b	66 8b 45 fc	 mov	 ax, WORD PTR __Wc$[ebp]
  0002f	83 c4 14	 add	 esp, 20			; 00000014H

; 698  : 	}

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z ENDP	; std::_Maklocchr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Glocale@std@@QAEPAXI@Z PROC				; std::locale::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Glocale@std@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002f	85 c9		 test	 ecx, ecx
  00031	74 11		 je	 SHORT $LN7@scalar
  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	ff 50 08	 call	 DWORD PTR [eax+8]
  00038	85 c0		 test	 eax, eax
  0003a	74 08		 je	 SHORT $LN7@scalar
  0003c	8b 10		 mov	 edx, DWORD PTR [eax]
  0003e	8b c8		 mov	 ecx, eax
  00040	6a 01		 push	 1
  00042	ff 12		 call	 DWORD PTR [edx]
$LN7@scalar:
  00044	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00048	74 0b		 je	 SHORT $LN10@scalar
  0004a	6a 08		 push	 8
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00052	83 c4 08	 add	 esp, 8
$LN10@scalar:
  00055	8b c6		 mov	 eax, esi
  00057	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00061	59		 pop	 ecx
  00062	5e		 pop	 esi
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Glocale@std@@QAEPAXI@Z$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_Glocale@std@@QAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Glocale@std@@QAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Glocale@std@@QAEPAXI@Z ENDP				; std::locale::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 458  : 		{	// look up a facet in locale object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 459  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __Id$[ebp]
  0000a	3b 71 0c	 cmp	 esi, DWORD PTR [ecx+12]
  0000d	73 0c		 jae	 SHORT $LN6@Getfacet
  0000f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00012	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]

; 460  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 461  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00015	85 c0		 test	 eax, eax
  00017	75 21		 jne	 SHORT $LN3@Getfacet
  00019	eb 02		 jmp	 SHORT $LN10@Getfacet
$LN6@Getfacet:

; 459  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  0001b	33 c0		 xor	 eax, eax
$LN10@Getfacet:

; 460  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 461  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  0001d	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00021	74 17		 je	 SHORT $LN3@Getfacet

; 462  : 			return (_Facptr);	// found facet or not transparent
; 463  : 		else
; 464  : 			{	// look in current locale
; 465  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  00023	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 466  : 			return (_Id < _Ptr0->_Facetcount

  00028	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  0002b	73 0b		 jae	 SHORT $LN8@Getfacet
  0002d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00030	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00033	5e		 pop	 esi

; 467  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 468  : 				: 0);	// no entry in current locale
; 469  : 			}
; 470  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN8@Getfacet:

; 466  : 			return (_Id < _Ptr0->_Facetcount

  00038	33 c0		 xor	 eax, eax
$LN3@Getfacet:
  0003a	5e		 pop	 esi

; 467  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 468  : 				: 0);	// no entry in current locale
; 469  : 			}
; 470  : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?c_str@locale@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@locale@std@@QBEPBDXZ PROC			; std::locale::c_str, COMDAT
; _this$ = ecx

; 454  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 06		 jne	 SHORT $LN3@c_str
  00007	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@

; 455  : 		}

  0000c	c3		 ret	 0
$LN3@c_str:

; 454  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

  0000d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00010	85 c9		 test	 ecx, ecx
  00012	74 03		 je	 SHORT $LN7@c_str
  00014	8b c1		 mov	 eax, ecx

; 455  : 		}

  00016	c3		 ret	 0

; 454  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

$LN7@c_str:
  00017	83 c0 1c	 add	 eax, 28			; 0000001cH

; 455  : 		}

  0001a	c3		 ret	 0
?c_str@locale@std@@QBEPBDXZ ENDP			; std::locale::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 430  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1locale@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 431  : 		if (_Ptr != 0)

  00022	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00025	85 c9		 test	 ecx, ecx
  00027	74 11		 je	 SHORT $LN4@locale

; 432  : 			delete _Ptr->_Decref();

  00029	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002b	ff 50 08	 call	 DWORD PTR [eax+8]
  0002e	85 c0		 test	 eax, eax
  00030	74 08		 je	 SHORT $LN4@locale
  00032	8b 10		 mov	 edx, DWORD PTR [eax]
  00034	8b c8		 mov	 ecx, eax
  00036	6a 01		 push	 1
  00038	ff 12		 call	 DWORD PTR [edx]
$LN4@locale:

; 433  : 		}

  0003a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00044	59		 pop	 ecx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1locale@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1locale@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0locale@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??0locale@std@@QAE@XZ PROC				; std::locale::locale, COMDAT
; _this$ = ecx

; 331  : 		{	// construct from current locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0locale@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 330  : 		: _Ptr(_Init(true))

  00025	6a 01		 push	 1
  00027	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  0002c	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0002f	83 c4 04	 add	 esp, 4

; 332  : 		}

  00032	8b c6		 mov	 eax, esi
  00034	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00037	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003e	59		 pop	 ecx
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0locale@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0locale@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0locale@std@@QAE@XZ ENDP				; std::locale::locale
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 325  : 		{	// construct by copying

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0locale@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 324  : 		: _Ptr(_Right._Ptr)

  00025	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00028	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 326  : 		_Ptr->_Incref();

  0002e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00030	ff 50 04	 call	 DWORD PTR [eax+4]

; 327  : 		}

  00033	8b c6		 mov	 eax, esi
  00035	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00038	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003f	59		 pop	 ecx
  00040	5e		 pop	 esi
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0locale@std@@QAE@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0locale@std@@QAE@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
; Function compile flags: /Ogtp
;	COMDAT ??_Gfacet@locale@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@MAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN10@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_Gfacet@locale@std@@MAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??1facet@locale@std@@MAE@XZ
_TEXT	SEGMENT
??1facet@locale@std@@MAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 172  : 			}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1facet@locale@std@@MAE@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 165  : 		explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 166  : 			{	// construct with initial reference count
; 167  : 			_Init_atomic_counter(_Myrefs, (_Atomic_integral_t)_Initrefs);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Initrefs$[ebp]
  00007	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 168  : 			}

  0000a	8b c1		 mov	 eax, ecx
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
_TEXT	SEGMENT
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ PROC	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 155  : 			if (_MT_DECR(_Myrefs) == 0)

  00000	83 c8 ff	 or	 eax, -1
  00003	f0 0f c1 41 04	 lock	  xadd	 DWORD PTR [ecx+4], eax
  00008	b8 00 00 00 00	 mov	 eax, 0
  0000d	0f 44 c1	 cmove	 eax, ecx

; 156  : 				return (this);
; 157  : 			else
; 158  : 				return (0);
; 159  : 			}

  00010	c3		 ret	 0
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ENDP	; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UAEXXZ
_TEXT	SEGMENT
?_Incref@facet@locale@std@@UAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 150  : 			_MT_INCR(_Myrefs);

  00000	f0 ff 41 04	 lock	  inc	 DWORD PTR [ecx+4]

; 151  : 			}

  00004	c3		 ret	 0
?_Incref@facet@locale@std@@UAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$1 = -4						; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 114  : 			{	// get stamp, with lazy allocation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 115  : 			if (_Id == 0)

  00007	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0000a	75 24		 jne	 SHORT $LN6@operator

; 116  : 				{	// still zero, allocate stamp
; 117  : 				_BEGIN_LOCK(_LOCK_LOCALE)

  0000c	6a 00		 push	 0
  0000e	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 118  : 					if (_Id == 0)

  00016	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00019	75 0d		 jne	 SHORT $LN3@operator

; 119  : 						_Id = ++_Id_cnt;

  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00020	40		 inc	 eax
  00021	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00026	89 06		 mov	 DWORD PTR [esi], eax
$LN3@operator:

; 120  : 				_END_LOCK()

  00028	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  0002b	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
$LN6@operator:

; 121  : 				}
; 122  : 			return (_Id);

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	5e		 pop	 esi

; 123  : 			}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 110  : 			{	// construct with specified stamp value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 109  : 			: _Id(_Val)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 111  : 			}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G_Facet_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Facet_base@std@@UAEPAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN7@scalar
  00012	6a 04		 push	 4
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G_Facet_base@std@@UAEPAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0_Facet_base@std@@QAE@XZ
_TEXT	SEGMENT
??0_Facet_base@std@@QAE@XZ PROC				; std::_Facet_base::_Facet_base, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0_Facet_base@std@@QAE@XZ ENDP				; std::_Facet_base::_Facet_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xfacet
;	COMDAT ??1_Facet_base@std@@UAE@XZ
_TEXT	SEGMENT
??1_Facet_base@std@@UAE@XZ PROC				; std::_Facet_base::~_Facet_base, COMDAT
; _this$ = ecx

; 24   : 		{	// ensure that derived classes can be destroyed properly

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@

; 25   : 		}

  00006	c3		 ret	 0
??1_Facet_base@std@@UAE@XZ ENDP				; std::_Facet_base::~_Facet_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@_W@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@_W@std@@AAEXXZ PROC			; std::_Yarn<wchar_t>::_Tidy, COMDAT
; _this$ = ecx

; 3796 : 		{	// discard any string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3797 : 		if (_Myptr != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN4@Tidy

; 3798 : 
; 3799 :  #ifdef _DEBUG
; 3800 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3801 : 
; 3802 :  #else /* _DEBUG */
; 3803 : 			_CSTD free(_Myptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN4@Tidy:

; 3804 :  #endif /* _DEBUG */
; 3805 : 
; 3806 : 		_Myptr = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 3807 : 		}

  00019	c3		 ret	 0
?_Tidy@?$_Yarn@_W@std@@AAEXXZ ENDP			; std::_Yarn<wchar_t>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 3770 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3771 : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Yarn
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN6@Yarn:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 3772 : 		}

  00019	c3		 ret	 0
??1?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 3719 : 		: _Myptr(0), _Nul(0)

  00000	33 c0		 xor	 eax, eax
  00002	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00008	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 3721 : 		}

  0000c	8b c1		 mov	 eax, ecx
  0000e	c3		 ret	 0
??0?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@D@std@@AAEXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT
; _this$ = ecx

; 3796 : 		{	// discard any string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3797 : 		if (_Myptr != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN4@Tidy

; 3798 : 
; 3799 :  #ifdef _DEBUG
; 3800 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3801 : 
; 3802 :  #else /* _DEBUG */
; 3803 : 			_CSTD free(_Myptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN4@Tidy:

; 3804 :  #endif /* _DEBUG */
; 3805 : 
; 3806 : 		_Myptr = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 3807 : 		}

  00019	c3		 ret	 0
?_Tidy@?$_Yarn@D@std@@AAEXXZ ENDP			; std::_Yarn<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?c_str@?$_Yarn@D@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$_Yarn@D@std@@QBEPBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT
; _this$ = ecx

; 3781 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	75 03		 jne	 SHORT $LN4@c_str
  00006	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
$LN4@c_str:

; 3782 : 		}

  00009	c3		 ret	 0
?c_str@?$_Yarn@D@std@@QBEPBDXZ ENDP			; std::_Yarn<char>::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 3770 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3771 : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Yarn
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN6@Yarn:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 3772 : 		}

  00019	c3		 ret	 0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT
; _this$ = ecx

; 3719 : 		: _Myptr(0), _Nul(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 3721 : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  0000c	c3		 ret	 0
??0?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Gettrue@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Gettrue, COMDAT
; _this$ = ecx

; 172  : 		return ("true");

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04LOAJBDKD@true?$AA@

; 173  : 		}

  00005	c3		 ret	 0
?_Gettrue@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Gettrue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Getfalse@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Getfalse, COMDAT
; _this$ = ecx

; 167  : 		return ("false");

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05LAPONLG@false?$AA@

; 168  : 		}

  00005	c3		 ret	 0
?_Getfalse@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Getfalse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ PROC		; std::_Locinfo::_Getlconv, COMDAT
; _this$ = ecx

; 127  : 		return (localeconv());

  00000	e9 00 00 00 00	 jmp	 _localeconv
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ENDP		; std::_Locinfo::_Getlconv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT
$T1 = -44						; size = 44
___$ReturnUdt$ = 8					; size = 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ PROC		; std::_Locinfo::_Getcvt, COMDAT
; _this$ = ecx

; 121  : 		{	// return codecvt stuff

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 122  : 		return (::_Getcvt());

  00006	8d 45 d4	 lea	 eax, DWORD PTR $T1[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __Getcvt
  0000f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00012	83 c4 04	 add	 esp, 4
  00015	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00018	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0001b	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  0001e	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  00022	0f 11 42 10	 movups	 XMMWORD PTR [edx+16], xmm0
  00026	f3 0f 7e 40 20	 movq	 xmm0, QWORD PTR [eax+32]
  0002b	8b c2		 mov	 eax, edx
  0002d	66 0f d6 42 20	 movq	 QWORD PTR [edx+32], xmm0
  00032	89 4a 28	 mov	 DWORD PTR [edx+40], ecx

; 123  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ENDP		; std::_Locinfo::_Getcvt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 116  : 		{	// return ctype stuff

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 117  : 		return (::_Getctype());

  00006	8d 45 f0	 lea	 eax, DWORD PTR $T1[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __Getctype
  0000f	83 c4 04	 add	 esp, 4
  00012	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00015	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00018	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 118  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 94   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Locinfo@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 95   : 		_Locinfo_dtor(this);

  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor

; 96   : 		}

  0002b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c0		 test	 eax, eax
  00033	74 09		 je	 SHORT $LN7@Locinfo
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _free
  0003b	83 c4 04	 add	 esp, 4
$LN7@Locinfo:
  0003e	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
  00045	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00048	85 c0		 test	 eax, eax
  0004a	74 09		 je	 SHORT $LN13@Locinfo
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _free
  00052	83 c4 04	 add	 esp, 4
$LN13@Locinfo:
  00055	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  0005c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0005f	85 c0		 test	 eax, eax
  00061	74 09		 je	 SHORT $LN19@Locinfo
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _free
  00069	83 c4 04	 add	 esp, 4
$LN19@Locinfo:
  0006c	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00073	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00076	85 c0		 test	 eax, eax
  00078	74 09		 je	 SHORT $LN25@Locinfo
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _free
  00080	83 c4 04	 add	 esp, 4
$LN25@Locinfo:
  00083	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0008a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0008d	85 c0		 test	 eax, eax
  0008f	74 09		 je	 SHORT $LN31@Locinfo
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 _free
  00097	83 c4 04	 add	 esp, 4
$LN31@Locinfo:
  0009a	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  000a1	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000a4	85 c0		 test	 eax, eax
  000a6	74 09		 je	 SHORT $LN37@Locinfo
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _free
  000ae	83 c4 04	 add	 esp, 4
$LN37@Locinfo:
  000b1	8b ce		 mov	 ecx, esi
  000b3	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  000ba	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  000bf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c9	59		 pop	 ecx
  000ca	5e		 pop	 esi
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Locinfo@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__InitData$3 = -24					; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 76   : 		{	// construct from NTBS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_Locinfo@std@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 73   : 		: _Lock(_LOCK_LOCALE)

  0002b	6a 00		 push	 0
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 76   : 		{	// construct from NTBS

  00039	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00040	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0
  00044	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0004b	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  0004f	33 c0		 xor	 eax, eax
  00051	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00058	66 89 46 18	 mov	 WORD PTR [esi+24], ax
  0005c	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  0005f	66 89 46 20	 mov	 WORD PTR [esi+32], ax
  00063	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00066	88 46 28	 mov	 BYTE PTR [esi+40], al
  00069	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0006c	88 46 30	 mov	 BYTE PTR [esi+48], al

; 77   : 		if (_Pch == 0)

  0006f	8b 45 08	 mov	 eax, DWORD PTR __Pch$[ebp]
  00072	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00076	85 c0		 test	 eax, eax
  00078	75 3f		 jne	 SHORT $LN2@Locinfo

; 78   : 			_THROW_NCEE(runtime_error, "bad locale name");

  0007a	8d 45 e0	 lea	 eax, DWORD PTR $T2[ebp+4]
  0007d	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7exception@std@@6B@
  00084	50		 push	 eax
  00085	8d 45 e8	 lea	 eax, DWORD PTR __InitData$3[ebp]
  00088	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __InitData$3[ebp], OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
  0008f	0f 57 c0	 xorps	 xmm0, xmm0
  00092	c6 45 ec 01	 mov	 BYTE PTR __InitData$3[ebp+4], 1
  00096	50		 push	 eax
  00097	66 0f d6 45 e0	 movq	 QWORD PTR $T2[ebp+4], xmm0
  0009c	e8 00 00 00 00	 call	 ___std_exception_copy
  000a1	83 c4 08	 add	 esp, 8
  000a4	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7runtime_error@std@@6B@
  000ab	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  000ae	68 00 00 00 00	 push	 OFFSET __TI2?AVruntime_error@std@@
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN29@Locinfo:
$LN2@Locinfo:

; 79   : 		_Locinfo_ctor(this, _Pch);

  000b9	50		 push	 eax
  000ba	56		 push	 esi
  000bb	e8 00 00 00 00	 call	 ?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
  000c0	83 c4 08	 add	 esp, 8

; 80   : 		}

  000c3	8b c6		 mov	 eax, esi
  000c5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cf	59		 pop	 ecx
  000d0	5e		 pop	 esi
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c2 04 00	 ret	 4
$LN28@Locinfo:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 14	 add	 ecx, 20			; 00000014H
  00024	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002f	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5:
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 24	 add	 ecx, 36			; 00000024H
  0003a	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6:
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00045	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
  0004a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00051	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00054	33 c8		 xor	 ecx, eax
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
  00060	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
; Function compile flags: /Ogtp
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_cast@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx
  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 125  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 126  :     }

  00003	8b c1		 mov	 eax, ecx
  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0
  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@
  00017	c3		 ret	 0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??0?$tuple@$$V@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$tuple@$$V@std@@QAE@ABV01@@Z PROC			; std::tuple<>::tuple<>, COMDAT
; _this$ = ecx

; 244  : 		{	// copy construct
; 245  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$tuple@$$V@std@@QAE@ABV01@@Z ENDP			; std::tuple<>::tuple<>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??0?$tuple@$$V@std@@QAE@XZ
_TEXT	SEGMENT
??0?$tuple@$$V@std@@QAE@XZ PROC				; std::tuple<>::tuple<>, COMDAT
; _this$ = ecx

; 235  : 		{	// default construct
; 236  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$tuple@$$V@std@@QAE@XZ ENDP				; std::tuple<>::tuple<>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
__InitData$1 = -8					; size = 8
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@PBD@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 168  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 167  : 		: _Mybase(_Message)

  00006	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	56		 push	 esi

; 168  : 		{	// construct from message string

  0000d	8b f1		 mov	 esi, ecx
  0000f	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00012	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  00015	89 45 f8	 mov	 DWORD PTR __InitData$1[ebp], eax
  00018	8d 45 f8	 lea	 eax, DWORD PTR __InitData$1[ebp]
  0001b	52		 push	 edx
  0001c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00022	50		 push	 eax
  00023	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00027	c6 45 fc 01	 mov	 BYTE PTR __InitData$1[ebp+4], 1
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	83 c4 08	 add	 esp, 8
  00033	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 169  : 		}

  00039	8b c6		 mov	 eax, esi
  0003b	5e		 pop	 esi
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@PBD@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__InitData$1 = -8					; size = 8
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 162  : 		: _Mybase(_Message.c_str())

  00006	8b 55 08	 mov	 edx, DWORD PTR __Message$[ebp]
  00009	56		 push	 esi

; 163  : 		{	// construct from message string

  0000a	8b f1		 mov	 esi, ecx
  0000c	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000f	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00013	72 02		 jb	 SHORT $LN17@runtime_er

; 162  : 		: _Mybase(_Message.c_str())

  00015	8b 12		 mov	 edx, DWORD PTR [edx]
$LN17@runtime_er:
  00017	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00020	0f 57 c0	 xorps	 xmm0, xmm0
  00023	89 55 f8	 mov	 DWORD PTR __InitData$1[ebp], edx
  00026	50		 push	 eax
  00027	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0002b	8d 45 f8	 lea	 eax, DWORD PTR __InitData$1[ebp]
  0002e	50		 push	 eax
  0002f	c6 45 fc 01	 mov	 BYTE PTR __InitData$1[ebp+4], 1
  00033	e8 00 00 00 00	 call	 ___std_exception_copy
  00038	83 c4 08	 add	 esp, 8

; 163  : 		{	// construct from message string

  0003b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 164  : 		}

  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	72 04		 jb	 SHORT $LN17@Check_offs

; 2273 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN17@Check_offs:

; 2272 : 			_Xran();

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN19@Check_offs:
$LN16@Check_offs:
  00019	cc		 int	 3
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2266 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2249 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 26		 je	 SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 20		 jb	 SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN57@Tidy

; 2256 : 				_Traits::copy(this->_Bx()._Buf,

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@Tidy:

; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00028	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002b	8b ce		 mov	 ecx, esi
  0002d	40		 inc	 eax
  0002e	50		 push	 eax
  0002f	53		 push	 ebx
  00030	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  00035	5b		 pop	 ebx
$LN4@Tidy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00036	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2261 : 		_Eos(_Newsize);

  0003d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00041	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00044	72 0c		 jb	 SHORT $LN92@Tidy
  00046	8b 06		 mov	 eax, DWORD PTR [esi]
  00048	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi

; 2262 : 		}

  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8

; 2261 : 		_Eos(_Newsize);

$LN92@Tidy:
  00052	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 2262 : 		}

  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	74 2d		 je	 SHORT $LN4@Inside
  0000b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00011	72 04		 jb	 SHORT $LN16@Inside
  00013	8b 31		 mov	 esi, DWORD PTR [ecx]
  00015	eb 02		 jmp	 SHORT $LN17@Inside
$LN16@Inside:
  00017	8b f1		 mov	 esi, ecx
$LN17@Inside:
  00019	3b d6		 cmp	 edx, esi
  0001b	72 1b		 jb	 SHORT $LN4@Inside
  0001d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00020	72 04		 jb	 SHORT $LN30@Inside
  00022	8b 31		 mov	 esi, DWORD PTR [ecx]
  00024	eb 02		 jmp	 SHORT $LN31@Inside
$LN30@Inside:
  00026	8b f1		 mov	 esi, ecx
$LN31@Inside:
  00028	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002b	03 c6		 add	 eax, esi
  0002d	3b c2		 cmp	 eax, edx
  0002f	76 07		 jbe	 SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

  00031	b0 01		 mov	 al, 1
  00033	5e		 pop	 esi

; 2244 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 2244 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2225 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0000a	77 59		 ja	 SHORT $LN89@Grow

; 2227 : 		if (this->_Myres() < _Newsize)

  0000c	39 71 14	 cmp	 DWORD PTR [ecx+20], esi
  0000f	73 13		 jae	 SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00011	ff 71 10	 push	 DWORD PTR [ecx+16]
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0001a	85 f6		 test	 esi, esi
  0001c	5e		 pop	 esi
  0001d	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00024	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  00028	74 1f		 je	 SHORT $LN5@Grow
  0002a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0002d	73 1a		 jae	 SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  0002f	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00032	3b f0		 cmp	 esi, eax
  00034	0f 42 c6	 cmovb	 eax, esi
  00037	50		 push	 eax
  00038	6a 01		 push	 1
  0003a	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  0003f	85 f6		 test	 esi, esi
  00041	5e		 pop	 esi
  00042	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

  00049	85 f6		 test	 esi, esi
  0004b	75 10		 jne	 SHORT $LN88@Grow

; 2233 : 			_Eos(0);	// new size is zero, just null terminate

  0004d	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00051	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  00054	72 02		 jb	 SHORT $LN80@Grow
  00056	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN80@Grow:
  00058	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0005b	85 f6		 test	 esi, esi
$LN88@Grow:
  0005d	0f 95 c0	 setne	 al
  00060	5e		 pop	 esi

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN89@Grow:

; 2226 : 			_Xlen();	// result too long

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0006a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN91@Grow:
$LN87@Grow:
  0006f	cc		 int	 3
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0000a	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000d	72 0a		 jb	 SHORT $LN11@Eos
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0

; 2220 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

$LN11@Eos:
  00019	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0

; 2220 : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f8		 mov	 edi, eax
  00035	83 cf 0f	 or	 edi, 15			; 0000000fH

; 2184 : 		if (max_size() < _Newres)

  00038	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0003b	76 04		 jbe	 SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

  0003d	8b f8		 mov	 edi, eax
  0003f	eb 27		 jmp	 SHORT $LN108@Copy
$LN2@Copy:

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  00041	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00044	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00049	f7 e7		 mul	 edi
  0004b	8b cb		 mov	 ecx, ebx
  0004d	d1 e9		 shr	 ecx, 1
  0004f	d1 ea		 shr	 edx, 1
  00051	3b ca		 cmp	 ecx, edx
  00053	76 13		 jbe	 SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 2189 : 			_Newres = this->_Myres()

  0005a	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]
  0005d	2b c1		 sub	 eax, ecx
  0005f	3b d8		 cmp	 ebx, eax
  00061	76 05		 jbe	 SHORT $LN108@Copy

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()

  00063	bf fe ff ff ff	 mov	 edi, -2			; fffffffeH
$LN108@Copy:

; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  00068	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0006b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00072	85 c0		 test	 eax, eax
  00074	75 04		 jne	 SHORT $LN136@Copy
  00076	33 db		 xor	 ebx, ebx
  00078	eb 6d		 jmp	 SHORT $LN19@Copy
$LN136@Copy:
  0007a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0007f	72 29		 jb	 SHORT $LN138@Copy
  00081	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00084	3b c8		 cmp	 ecx, eax
  00086	77 05		 ja	 SHORT $LN140@Copy
  00088	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN435@Copy:
$LN140@Copy:
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00093	83 c4 04	 add	 esp, 4
  00096	85 c0		 test	 eax, eax
  00098	75 05		 jne	 SHORT $LN141@Copy
  0009a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN436@Copy:
$LN141@Copy:
  0009f	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  000a2	83 e3 e0	 and	 ebx, -32		; ffffffe0H
  000a5	89 43 fc	 mov	 DWORD PTR [ebx-4], eax
  000a8	eb 3d		 jmp	 SHORT $LN19@Copy
$LN138@Copy:
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b0	8b d8		 mov	 ebx, eax
  000b2	83 c4 04	 add	 esp, 4
  000b5	85 db		 test	 ebx, ebx
  000b7	75 2e		 jne	 SHORT $LN19@Copy
  000b9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN437@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000be	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  000c1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax
  000c7	40		 inc	 eax
  000c8	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  000cb	50		 push	 eax
  000cc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000d0	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  000d5	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

  000d8	b8 00 00 00 00	 mov	 eax, $LN432@Copy
  000dd	c3		 ret	 0
$LN432@Copy:
  000de	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000e1	8b 7d 08	 mov	 edi, DWORD PTR __Newres$[ebp]
  000e4	8b 5d e8	 mov	 ebx, DWORD PTR __Ptr$[ebp]
$LN19@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

  000e7	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  000ea	85 c0		 test	 eax, eax
  000ec	74 1b		 je	 SHORT $LN270@Copy

; 2208 : 			_Traits::copy(_Unfancy(_Ptr), this->_Myptr(),

  000ee	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000f2	72 04		 jb	 SHORT $LN261@Copy
  000f4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000f6	eb 02		 jmp	 SHORT $LN262@Copy
$LN261@Copy:
  000f8	8b ce		 mov	 ecx, esi
$LN262@Copy:
  000fa	85 c0		 test	 eax, eax
  000fc	74 0b		 je	 SHORT $LN270@Copy
  000fe	50		 push	 eax
  000ff	51		 push	 ecx
  00100	53		 push	 ebx
  00101	e8 00 00 00 00	 call	 _memcpy
  00106	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN270@Copy:

; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);

  00109	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0010c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0010f	72 0b		 jb	 SHORT $LN274@Copy
  00111	40		 inc	 eax
  00112	8b ce		 mov	 ecx, esi
  00114	50		 push	 eax
  00115	ff 36		 push	 DWORD PTR [esi]
  00117	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN274@Copy:
  0011c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00123	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00127	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0012e	72 04		 jb	 SHORT $LN362@Copy
  00130	8b 06		 mov	 eax, DWORD PTR [esi]
  00132	eb 02		 jmp	 SHORT $LN363@Copy
$LN362@Copy:
  00134	8b c6		 mov	 eax, esi
$LN363@Copy:
  00136	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2211 : 		this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Ptr);
; 2212 : 		this->_Myres() = _Newres;
; 2213 : 		_Eos(_Oldlen);

  00139	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  0013c	89 1e		 mov	 DWORD PTR [esi], ebx
  0013e	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00141	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00145	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00148	72 02		 jb	 SHORT $LN426@Copy
  0014a	8b f3		 mov	 esi, ebx
$LN426@Copy:
  0014c	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0

; 2214 : 		}

  00150	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00153	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015a	59		 pop	 ecx
  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

  00164	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00167	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0016a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0016d	72 0b		 jb	 SHORT $LN156@Copy
  0016f	40		 inc	 eax
  00170	8b ce		 mov	 ecx, esi
  00172	50		 push	 eax
  00173	ff 36		 push	 DWORD PTR [esi]
  00175	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN156@Copy:
  0017a	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00181	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00185	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0018c	72 02		 jb	 SHORT $LN245@Copy
  0018e	8b 36		 mov	 esi, DWORD PTR [esi]
$LN245@Copy:

; 2203 : 			_RERAISE;

  00190	6a 00		 push	 0
  00192	6a 00		 push	 0
  00194	c6 06 00	 mov	 BYTE PTR [esi], 0
  00197	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN438@Copy:
$LN434@Copy:
  0019c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2175 : 		if (_Count == 1)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b d1		 mov	 edx, ecx
  00008	83 f8 01	 cmp	 eax, 1
  0000b	75 15		 jne	 SHORT $LN2@Chassign

; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);

  0000d	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00011	72 02		 jb	 SHORT $LN16@Chassign
  00013	8b 12		 mov	 edx, DWORD PTR [edx]
$LN16@Chassign:
  00015	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00018	8a 4d 10	 mov	 cl, BYTE PTR __Ch$[ebp]
  0001b	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 2179 : 		}

  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Chassign:

; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

  00022	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00026	72 02		 jb	 SHORT $LN33@Chassign
  00028	8b 12		 mov	 edx, DWORD PTR [edx]
$LN33@Chassign:
  0002a	50		 push	 eax
  0002b	0f be 45 10	 movsx	 eax, BYTE PTR __Ch$[ebp]
  0002f	50		 push	 eax
  00030	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00033	03 c2		 add	 eax, edx
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _memset
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2179 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$ = ecx

; 2168 : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2169 : 		allocator_type _Ret(this->_Getal());
; 2170 : 		return (_Ret);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2171 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 2120 : 		{	// compare [0, _Mysize()) with _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  0000c	8d 72 10	 lea	 esi, DWORD PTR [edx+16]
  0000f	72 02		 jb	 SHORT $LN22@compare
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
$LN22@compare:
  00013	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00017	8d 79 10	 lea	 edi, DWORD PTR [ecx+16]
  0001a	72 02		 jb	 SHORT $LN45@compare
  0001c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN45@compare:
  0001e	8b 36		 mov	 esi, DWORD PTR [esi]
  00020	8b c6		 mov	 eax, esi
  00022	8b 3f		 mov	 edi, DWORD PTR [edi]
  00024	3b fe		 cmp	 edi, esi
  00026	0f 42 c7	 cmovb	 eax, edi
  00029	50		 push	 eax
  0002a	52		 push	 edx
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	85 c0		 test	 eax, eax
  00036	75 11		 jne	 SHORT $LN52@compare
  00038	3b f7		 cmp	 esi, edi
  0003a	76 09		 jbe	 SHORT $LN54@compare
  0003c	5f		 pop	 edi
  0003d	83 c8 ff	 or	 eax, -1
  00040	5e		 pop	 esi

; 2122 : 			_Right._Myptr(), _Right._Mysize()));
; 2123 : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN54@compare:

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

  00045	1b c0		 sbb	 eax, eax
  00047	f7 d8		 neg	 eax
$LN52@compare:
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi

; 2122 : 			_Right._Myptr(), _Right._Mysize()));
; 2123 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

  00009	39 45 0c	 cmp	 DWORD PTR __Size$[ebp], eax
  0000c	0f 46 45 0c	 cmovbe	 eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Traits_compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAHQBDI0I@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Left_size$ = 12					; size = 4
__Right$ = 16						; size = 4
__Right_size$ = 20					; size = 4
?_Traits_compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAHQBDI0I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Traits_compare, COMDAT

; 2094 : 		{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

  00004	8b 75 14	 mov	 esi, DWORD PTR __Right_size$[ebp]
  00007	8b c6		 mov	 eax, esi
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR __Left_size$[ebp]
  0000d	3b fe		 cmp	 edi, esi
  0000f	0f 42 c7	 cmovb	 eax, edi

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

  00012	50		 push	 eax
  00013	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  00016	ff 75 08	 push	 DWORD PTR __Left$[ebp]
  00019	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2097 : 
; 2098 : 		if (_Ans != 0)

  00021	85 c0		 test	 eax, eax
  00023	75 0f		 jne	 SHORT $LN4@Traits_com

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

  00025	3b f7		 cmp	 esi, edi
  00027	76 07		 jbe	 SHORT $LN6@Traits_com

; 2102 : 			return (-1);

  00029	5f		 pop	 edi
  0002a	83 c8 ff	 or	 eax, -1
  0002d	5e		 pop	 esi

; 2105 : 			return (1);
; 2106 : 
; 2107 : 		return (0);
; 2108 : 		}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN6@Traits_com:

; 2103 : 
; 2104 : 		if (_Left_size > _Right_size)

  00030	1b c0		 sbb	 eax, eax
  00032	f7 d8		 neg	 eax
$LN4@Traits_com:
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi

; 2105 : 			return (1);
; 2106 : 
; 2107 : 		return (0);
; 2108 : 		}

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?_Traits_compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAHQBDI0I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Traits_compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT
; _this$ = ecx

; 2088 : 		{	// return [_Off, _Off + _Count) as new string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 2089 : 		return (_Myt(*this, _Off, _Count, get_allocator()));

  00005	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00015	51		 push	 ecx
  00016	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001d	8b ce		 mov	 ecx, esi
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	c6 06 00	 mov	 BYTE PTR [esi], 0
  00029	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi

; 2090 : 		}

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find_last_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
__Off$ = 12						; size = 4
?find_last_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_not_of, COMDAT
; _this$ = ecx

; 2083 : 		{	// look for non _Ch before _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2084 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));

  00003	6a 01		 push	 1
  00005	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00008	8d 45 08	 lea	 eax, DWORD PTR __Ch$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?find_last_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_not_of

; 2085 : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?find_last_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_not_of
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find_last_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?find_last_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_not_of, COMDAT
; _this$ = ecx

; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 2060 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2061 : 		if (0 < this->_Mysize())

  00008	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0000b	85 c0		 test	 eax, eax
  0000d	74 5a		 je	 SHORT $LN73@find_last_

; 2062 : 			{	// worth searching, do it
; 2063 : 			const _Elem *_Uptr = this->_Myptr()
; 2064 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);

  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Off$[ebp]
  00012	3b c8		 cmp	 ecx, eax
  00014	72 03		 jb	 SHORT $LN11@find_last_
  00016	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
$LN11@find_last_:
  00019	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  0001d	72 04		 jb	 SHORT $LN49@find_last_
  0001f	8b 07		 mov	 eax, DWORD PTR [edi]
  00021	eb 02		 jmp	 SHORT $LN50@find_last_
$LN49@find_last_:
  00023	8b c7		 mov	 eax, edi
$LN50@find_last_:
  00025	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp]
  00028	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  0002b	0f 1f 44 00 00	 npad	 5
$LL4@find_last_:

; 2066 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)

  00030	85 db		 test	 ebx, ebx
  00032	74 22		 je	 SHORT $LN76@find_last_
  00034	0f be 06	 movsx	 eax, BYTE PTR [esi]
  00037	53		 push	 ebx
  00038	50		 push	 eax
  00039	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0003c	e8 00 00 00 00	 call	 _memchr
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	85 c0		 test	 eax, eax
  00046	74 0e		 je	 SHORT $LN76@find_last_

; 2068 : 				else if (_Uptr == this->_Myptr())

  00048	8b cf		 mov	 ecx, edi
  0004a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  0004f	3b f0		 cmp	 esi, eax
  00051	74 16		 je	 SHORT $LN73@find_last_

; 2065 : 			for (; ; --_Uptr)

  00053	4e		 dec	 esi
  00054	eb da		 jmp	 SHORT $LL4@find_last_
$LN76@find_last_:

; 2067 : 					return (_Uptr - this->_Myptr());

  00056	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  0005a	72 02		 jb	 SHORT $LN67@find_last_
  0005c	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN67@find_last_:
  0005e	2b f7		 sub	 esi, edi
  00060	5f		 pop	 edi
  00061	8b c6		 mov	 eax, esi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx

; 2072 : 		}

  00065	5d		 pop	 ebp
  00066	c2 0c 00	 ret	 12			; 0000000cH
$LN73@find_last_:
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi

; 2069 : 					break;
; 2070 : 			}
; 2071 : 		return (npos);

  0006b	83 c8 ff	 or	 eax, -1
  0006e	5b		 pop	 ebx

; 2072 : 		}

  0006f	5d		 pop	 ebp
  00070	c2 0c 00	 ret	 12			; 0000000cH
?find_last_not_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_not_of
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1895 : 		{	// look for [_Ptr, <null>) beginning at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1896 : 		_DEBUG_POINTER(_Ptr);
; 1897 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 11		 jne	 SHORT $LN5@find
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00018	5e		 pop	 esi

; 1898 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8

; 1896 : 		_DEBUG_POINTER(_Ptr);
; 1897 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));

$LN5@find:
  0001d	8b d6		 mov	 edx, esi
  0001f	57		 push	 edi
  00020	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@find:
  00023	8a 02		 mov	 al, BYTE PTR [edx]
  00025	42		 inc	 edx
  00026	84 c0		 test	 al, al
  00028	75 f9		 jne	 SHORT $LL7@find
  0002a	2b d7		 sub	 edx, edi
  0002c	5f		 pop	 edi
  0002d	52		 push	 edx
  0002e	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00037	5e		 pop	 esi

; 1898 : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1875 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1876 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1877 : 		if (_Count == 0 && _Off <= this->_Mysize())

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00007	53		 push	 ebx
  00008	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000b	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000e	85 db		 test	 ebx, ebx
  00010	75 0e		 jne	 SHORT $LN5@find
  00012	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00015	77 09		 ja	 SHORT $LN5@find

; 1878 : 			return (_Off);	// null string always matches (if inside string)

  00017	8b c2		 mov	 eax, edx
  00019	5b		 pop	 ebx

; 1892 : 		}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
$LN5@find:
  00020	56		 push	 esi

; 1879 : 
; 1880 : 		size_type _Nm;
; 1881 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))

  00021	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  00024	57		 push	 edi
  00025	3b d6		 cmp	 edx, esi
  00027	73 6a		 jae	 SHORT $LN3@find
  00029	2b f2		 sub	 esi, edx
  0002b	3b de		 cmp	 ebx, esi
  0002d	77 64		 ja	 SHORT $LN3@find

; 1882 : 			{	// room for match, look for it
; 1883 : 			const _Elem *_Uptr, *_Vptr;
; 1884 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	2b c3		 sub	 eax, ebx
  00036	03 f0		 add	 esi, eax
  00038	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0003c	72 02		 jb	 SHORT $LN46@find
  0003e	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN46@find:
  00040	8d 1c 11	 lea	 ebx, DWORD PTR [ecx+edx]
$LL4@find:

; 1885 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;

  00043	85 f6		 test	 esi, esi
  00045	74 4c		 je	 SHORT $LN3@find
  00047	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004a	56		 push	 esi
  0004b	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0004e	50		 push	 eax
  0004f	53		 push	 ebx
  00050	e8 00 00 00 00	 call	 _memchr
  00055	8b f8		 mov	 edi, eax
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	85 ff		 test	 edi, edi
  0005c	74 35		 je	 SHORT $LN3@find

; 1887 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)

  0005e	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00061	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00064	57		 push	 edi
  00065	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	85 c0		 test	 eax, eax
  0006f	74 0a		 je	 SHORT $LN69@find

; 1886 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)

  00071	2b df		 sub	 ebx, edi
  00073	4b		 dec	 ebx
  00074	03 f3		 add	 esi, ebx
  00076	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]
  00079	eb c8		 jmp	 SHORT $LL4@find
$LN69@find:

; 1888 : 					return (_Uptr - this->_Myptr());	// found a match

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  0007e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00082	72 02		 jb	 SHORT $LN64@find
  00084	8b 00		 mov	 eax, DWORD PTR [eax]
$LN64@find:
  00086	2b f8		 sub	 edi, eax
  00088	8b c7		 mov	 eax, edi
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx

; 1892 : 		}

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 0c 00	 ret	 12			; 0000000cH
$LN3@find:
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi

; 1889 : 			}
; 1890 : 
; 1891 : 		return (npos);	// no match

  00095	83 c8 ff	 or	 eax, -1
  00098	5b		 pop	 ebx

; 1892 : 		}

  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 1803 : 		{	// test if sequence is empty

  00000	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00004	0f 94 c0	 sete	 al

; 1804 : 		return (this->_Mysize() == 0);
; 1805 : 		}

  00007	c3		 ret	 0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Ch$ = 12						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1780 : 		{	// determine new length, padding with _Ch elements as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1781 : 		if (_Newsize <= this->_Mysize())

  00003	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00009	3b c2		 cmp	 eax, edx
  0000b	77 13		 ja	 SHORT $LN2@resize

; 1782 : 			_Eos(_Newsize);

  0000d	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00010	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00014	72 02		 jb	 SHORT $LN25@resize
  00016	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN25@resize:
  00018	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1785 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
$LN2@resize:

; 1783 : 		else
; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

  00020	2b c2		 sub	 eax, edx
  00022	89 45 08	 mov	 DWORD PTR __Newsize$[ebp], eax

; 1785 : 		}

  00025	5d		 pop	 ebp

; 1783 : 		else
; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

  00026	e9 00 00 00 00	 jmp	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1775 : 		{	// determine new length, padding with null elements as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1776 : 		resize(_Newsize, _Elem());

  00003	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00009	3b c2		 cmp	 eax, edx
  0000b	77 13		 ja	 SHORT $LN4@resize
  0000d	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00010	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00014	72 02		 jb	 SHORT $LN27@resize
  00016	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN27@resize:
  00018	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1777 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4

; 1776 : 		resize(_Newsize, _Elem());

$LN4@resize:
  00020	6a 00		 push	 0
  00022	2b c2		 sub	 eax, edx
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1777 : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1772 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1765 : 		return (this->_Mysize());

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1766 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1743 : 		return (this->_Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN13@c_str
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1744 : 		}

  00008	c3		 ret	 0

; 1743 : 		return (this->_Myptr());

$LN13@c_str:
  00009	8b c1		 mov	 eax, ecx

; 1744 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1692 : 		{	// subscript nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1693 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1694 : 		if (this->_Mysize() < _Off)	// sic
; 1695 : 			_DEBUG_ERROR("string subscript out of range");
; 1696 : 
; 1697 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1698 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1699 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1700 : 
; 1701 : 		return (this->_Myptr()[_Off]);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	72 02		 jb	 SHORT $LN13@operator
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN13@operator:
  0000e	03 c1		 add	 eax, ecx

; 1702 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1679 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1680 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1681 : 		if (this->_Mysize() < _Off)	// sic
; 1682 : 			_DEBUG_ERROR("string subscript out of range");
; 1683 : 
; 1684 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1685 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1686 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1687 : 
; 1688 : 		return (this->_Myptr()[_Off]);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	72 02		 jb	 SHORT $LN13@operator
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN13@operator:
  0000e	03 c1		 add	 eax, ecx

; 1689 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 1606 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1607 : 		auto _Mydata = &this->_Get_data();
; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	72 10		 jb	 SHORT $LN11@end
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000e	03 c8		 add	 ecx, eax
  00010	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00013	89 08		 mov	 DWORD PTR [eax], ecx

; 1609 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4

; 1607 : 		auto _Mydata = &this->_Get_data();
; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

$LN11@end:
  00019	8b c1		 mov	 eax, ecx
  0001b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0001e	03 c8		 add	 ecx, eax
  00020	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 1609 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 1594 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1595 : 		auto _Mydata = &this->_Get_data();
; 1596 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	72 02		 jb	 SHORT $LN11@begin
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN11@begin:
  0000e	89 08		 mov	 DWORD PTR [eax], ecx

; 1597 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1584 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1585 : 		if (_First2 == _Last2)

  00003	8b 45 10	 mov	 eax, DWORD PTR __First2$[ebp]
  00006	8b 55 14	 mov	 edx, DWORD PTR __Last2$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	3b c2		 cmp	 eax, edx
  0000e	75 36		 jne	 SHORT $LN2@replace

; 1586 : 			erase(_First - begin(), _Last - _First);

  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00013	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00016	2b c8		 sub	 ecx, eax
  00018	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0001c	72 14		 jb	 SHORT $LN24@replace
  0001e	8b 16		 mov	 edx, DWORD PTR [esi]
  00020	2b c2		 sub	 eax, edx
  00022	51		 push	 ecx
  00023	50		 push	 eax
  00024	8b ce		 mov	 ecx, esi
  00026	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  0002b	8b c6		 mov	 eax, esi
  0002d	5e		 pop	 esi

; 1591 : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 10 00	 ret	 16			; 00000010H

; 1586 : 			erase(_First - begin(), _Last - _First);

$LN24@replace:
  00032	8b d6		 mov	 edx, esi
  00034	51		 push	 ecx
  00035	2b c2		 sub	 eax, edx
  00037	8b ce		 mov	 ecx, esi
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  0003f	8b c6		 mov	 eax, esi
  00041	5e		 pop	 esi

; 1591 : 		}

  00042	5d		 pop	 ebp
  00043	c2 10 00	 ret	 16			; 00000010H
$LN2@replace:

; 1587 : 		else
; 1588 : 			replace(_First - begin(), _Last - _First,

  00046	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00049	2b d0		 sub	 edx, eax
  0004b	53		 push	 ebx
  0004c	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0004f	2b d9		 sub	 ebx, ecx
  00051	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00055	57		 push	 edi
  00056	72 04		 jb	 SHORT $LN76@replace
  00058	8b 3e		 mov	 edi, DWORD PTR [esi]
  0005a	eb 02		 jmp	 SHORT $LN77@replace
$LN76@replace:
  0005c	8b fe		 mov	 edi, esi
$LN77@replace:
  0005e	52		 push	 edx
  0005f	50		 push	 eax
  00060	2b cf		 sub	 ecx, edi
  00062	53		 push	 ebx
  00063	51		 push	 ecx
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
  0006b	5f		 pop	 edi
  0006c	5b		 pop	 ebx

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi

; 1591 : 		}

  00070	5d		 pop	 ebp
  00071	c2 10 00	 ret	 16			; 00000010H
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z
_TEXT	SEGMENT
__Nm$1$ = -8						; size = 4
tv890 = -4						; size = 4
tv887 = -4						; size = 4
__Off$ = 8						; size = 4
tv891 = 12						; size = 4
tv888 = 12						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1453 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1454 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1455 : 		if (_Inside(_Ptr))

  00003	8b 55 10	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	85 d2		 test	 edx, edx
  0000f	74 4d		 je	 SHORT $LN2@replace
  00011	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00014	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00017	72 04		 jb	 SHORT $LN24@replace
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	eb 02		 jmp	 SHORT $LN25@replace
$LN24@replace:
  0001d	8b c6		 mov	 eax, esi
$LN25@replace:
  0001f	3b d0		 cmp	 edx, eax
  00021	72 3b		 jb	 SHORT $LN2@replace
  00023	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00026	72 04		 jb	 SHORT $LN38@replace
  00028	8b 3e		 mov	 edi, DWORD PTR [esi]
  0002a	eb 02		 jmp	 SHORT $LN39@replace
$LN38@replace:
  0002c	8b fe		 mov	 edi, esi
$LN39@replace:
  0002e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00031	03 c7		 add	 eax, edi
  00033	3b c2		 cmp	 eax, edx
  00035	76 27		 jbe	 SHORT $LN2@replace

; 1456 : 			return (replace(_Off, _N0, *this,

  00037	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0003a	72 04		 jb	 SHORT $LN61@replace
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	eb 02		 jmp	 SHORT $LN62@replace
$LN61@replace:
  00040	8b c6		 mov	 eax, esi
$LN62@replace:
  00042	ff 75 14	 push	 DWORD PTR __Count$[ebp]
  00045	2b d0		 sub	 edx, eax
  00047	8b ce		 mov	 ecx, esi
  00049	52		 push	 edx
  0004a	56		 push	 esi
  0004b	ff 75 0c	 push	 DWORD PTR __N0$[ebp]
  0004e	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00051	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 1480 : 		}

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 10 00	 ret	 16			; 00000010H
$LN2@replace:

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);

  0005e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00061	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00064	3b c8		 cmp	 ecx, eax
  00066	0f 82 61 01 00
	00		 jb	 $LN312@replace

; 1460 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1461 : 		if (npos - _Count <= this->_Mysize() - _N0)

  0006c	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  0006f	8b f9		 mov	 edi, ecx
  00071	2b f8		 sub	 edi, eax
  00073	8b c2		 mov	 eax, edx
  00075	53		 push	 ebx
  00076	8b 5d 0c	 mov	 ebx, DWORD PTR __N0$[ebp]
  00079	f7 d0		 not	 eax
  0007b	3b df		 cmp	 ebx, edi
  0007d	0f 47 df	 cmova	 ebx, edi
  00080	2b cb		 sub	 ecx, ebx
  00082	3b c1		 cmp	 eax, ecx
  00084	0f 86 4d 01 00
	00		 jbe	 $LN314@replace

; 1463 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;

  0008a	2b fb		 sub	 edi, ebx
  0008c	89 7d f8	 mov	 DWORD PTR __Nm$1$[ebp], edi

; 1464 : 
; 1465 : 		if (_Count < _N0)

  0008f	3b d3		 cmp	 edx, ebx
  00091	73 43		 jae	 SHORT $LN145@replace

; 1466 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00093	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00096	83 f8 10	 cmp	 eax, 16			; 00000010H
  00099	72 07		 jb	 SHORT $LN124@replace
  0009b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0009d	89 4d 0c	 mov	 DWORD PTR tv891[ebp], ecx
  000a0	eb 03		 jmp	 SHORT $LN125@replace
$LN124@replace:
  000a2	89 75 0c	 mov	 DWORD PTR tv891[ebp], esi
$LN125@replace:
  000a5	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a8	72 07		 jb	 SHORT $LN138@replace
  000aa	8b 06		 mov	 eax, DWORD PTR [esi]
  000ac	89 45 fc	 mov	 DWORD PTR tv890[ebp], eax
  000af	eb 03		 jmp	 SHORT $LN139@replace
$LN138@replace:
  000b1	89 75 fc	 mov	 DWORD PTR tv890[ebp], esi
$LN139@replace:
  000b4	85 ff		 test	 edi, edi
  000b6	74 1e		 je	 SHORT $LN145@replace
  000b8	8b 45 0c	 mov	 eax, DWORD PTR tv891[ebp]
  000bb	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  000be	03 c3		 add	 eax, ebx
  000c0	57		 push	 edi
  000c1	50		 push	 eax
  000c2	8b 45 fc	 mov	 eax, DWORD PTR tv890[ebp]
  000c5	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  000c8	03 c2		 add	 eax, edx
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _memmove
  000d0	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN145@replace:

; 1467 : 				this->_Myptr() + _Off + _N0,
; 1468 : 				_Nm);	// smaller hole, move tail up
; 1469 : 		const size_type _Num = this->_Mysize() + _Count - _N0;

  000d6	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000d9	8b f8		 mov	 edi, eax
  000db	2b fb		 sub	 edi, ebx
  000dd	03 fa		 add	 edi, edx

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

  000df	85 d2		 test	 edx, edx
  000e1	75 08		 jne	 SHORT $LN6@replace
  000e3	85 db		 test	 ebx, ebx
  000e5	0f 84 d7 00 00
	00		 je	 $LN306@replace
$LN6@replace:
  000eb	83 ff fe	 cmp	 edi, -2			; fffffffeH
  000ee	0f 87 ed 00 00
	00		 ja	 $LN315@replace
  000f4	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  000f7	73 27		 jae	 SHORT $LN157@replace
  000f9	50		 push	 eax
  000fa	57		 push	 edi
  000fb	8b ce		 mov	 ecx, esi
  000fd	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00102	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  00105	85 ff		 test	 edi, edi
  00107	0f 84 b5 00 00
	00		 je	 $LN306@replace
$LN311@replace:

; 1472 : 			{	// make room and rearrange
; 1473 : 			if (_N0 < _Count)

  0010d	3b da		 cmp	 ebx, edx
  0010f	73 71		 jae	 SHORT $LN272@replace

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

  00111	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00114	83 f8 10	 cmp	 eax, 16			; 00000010H
  00117	72 32		 jb	 SHORT $LN251@replace
  00119	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0011b	89 4d 0c	 mov	 DWORD PTR tv888[ebp], ecx
  0011e	eb 2e		 jmp	 SHORT $LN252@replace

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

$LN157@replace:
  00120	85 ff		 test	 edi, edi
  00122	75 e9		 jne	 SHORT $LN311@replace
  00124	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00127	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0012b	72 10		 jb	 SHORT $LN234@replace
  0012d	8b 06		 mov	 eax, DWORD PTR [esi]
  0012f	5b		 pop	 ebx
  00130	5f		 pop	 edi
  00131	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1478 : 			}
; 1479 : 		return (*this);

  00134	8b c6		 mov	 eax, esi
  00136	5e		 pop	 esi

; 1480 : 		}

  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c2 10 00	 ret	 16			; 00000010H

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

$LN234@replace:
  0013d	8b c6		 mov	 eax, esi
  0013f	5b		 pop	 ebx
  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1480 : 		}

  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c2 10 00	 ret	 16			; 00000010H

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

$LN251@replace:
  0014b	89 75 0c	 mov	 DWORD PTR tv888[ebp], esi
$LN252@replace:
  0014e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00151	72 07		 jb	 SHORT $LN265@replace
  00153	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00155	89 4d fc	 mov	 DWORD PTR tv887[ebp], ecx
  00158	eb 03		 jmp	 SHORT $LN266@replace
$LN265@replace:
  0015a	89 75 fc	 mov	 DWORD PTR tv887[ebp], esi
$LN266@replace:
  0015d	8b 45 f8	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00160	85 c0		 test	 eax, eax
  00162	74 1e		 je	 SHORT $LN272@replace
  00164	50		 push	 eax
  00165	8b 45 0c	 mov	 eax, DWORD PTR tv888[ebp]
  00168	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  0016b	03 c3		 add	 eax, ebx
  0016d	50		 push	 eax
  0016e	8b 45 fc	 mov	 eax, DWORD PTR tv887[ebp]
  00171	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00174	03 c2		 add	 eax, edx
  00176	50		 push	 eax
  00177	e8 00 00 00 00	 call	 _memmove
  0017c	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  0017f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN272@replace:

; 1475 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1476 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

  00182	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00186	72 04		 jb	 SHORT $LN283@replace
  00188	8b 06		 mov	 eax, DWORD PTR [esi]
  0018a	eb 02		 jmp	 SHORT $LN284@replace
$LN283@replace:
  0018c	8b c6		 mov	 eax, esi
$LN284@replace:
  0018e	85 d2		 test	 edx, edx
  00190	74 10		 je	 SHORT $LN290@replace
  00192	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00195	52		 push	 edx
  00196	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00199	50		 push	 eax
  0019a	e8 00 00 00 00	 call	 _memcpy
  0019f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN290@replace:

; 1477 : 			_Eos(_Num);

  001a2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  001a6	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  001a9	72 11		 jb	 SHORT $LN301@replace
  001ab	8b 06		 mov	 eax, DWORD PTR [esi]
  001ad	5b		 pop	 ebx
  001ae	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1478 : 			}
; 1479 : 		return (*this);

  001b2	8b c6		 mov	 eax, esi
  001b4	5f		 pop	 edi
  001b5	5e		 pop	 esi

; 1480 : 		}

  001b6	8b e5		 mov	 esp, ebp
  001b8	5d		 pop	 ebp
  001b9	c2 10 00	 ret	 16			; 00000010H

; 1477 : 			_Eos(_Num);

$LN301@replace:
  001bc	8b c6		 mov	 eax, esi
  001be	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN306@replace:

; 1478 : 			}
; 1479 : 		return (*this);

  001c2	5b		 pop	 ebx
  001c3	5f		 pop	 edi
  001c4	8b c6		 mov	 eax, esi
  001c6	5e		 pop	 esi

; 1480 : 		}

  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	c2 10 00	 ret	 16			; 00000010H
$LN312@replace:

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);

  001cd	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  001d2	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN316@replace:
$LN314@replace:

; 1462 : 			_Xlen();	// result too long

  001d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  001dc	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN317@replace:
$LN315@replace:

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

  001e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  001e6	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN318@replace:
$LN309@replace:
  001eb	cc		 int	 3
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z
_TEXT	SEGMENT
tv1828 = -8						; size = 4
tv1825 = -8						; size = 4
__Max_effective_size$1$ = -8				; size = 4
__Nm$1$ = -4						; size = 4
tv1824 = 8						; size = 4
tv1821 = 8						; size = 4
tv1817 = 8						; size = 4
tv1813 = 8						; size = 4
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
tv1809 = 16						; size = 4
tv1807 = 16						; size = 4
tv1805 = 16						; size = 4
__Right$ = 16						; size = 4
tv1819 = 20						; size = 4
__Roff$ = 20						; size = 4
tv1798 = 24						; size = 4
__Newsize$1$ = 24					; size = 4
__Count$ = 24						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1389 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 1390 : 		_Check_offset(_Off);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00011	3b c3		 cmp	 eax, ebx
  00013	0f 82 95 03 00
	00		 jb	 $LN600@replace

; 1391 : 		_Right._Check_offset(_Roff);

  00019	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001c	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
  0001f	3b 7d 14	 cmp	 edi, DWORD PTR __Roff$[ebp]
  00022	0f 82 90 03 00
	00		 jb	 $LN602@replace

; 1392 : 		_N0 = _Clamp_suffix_size(_Off, _N0);

  00028	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0002b	2b c3		 sub	 eax, ebx
  0002d	3b d0		 cmp	 edx, eax
  0002f	89 45 fc	 mov	 DWORD PTR __Nm$1$[ebp], eax
  00032	0f 47 d0	 cmova	 edx, eax

; 1393 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00035	2b 7d 14	 sub	 edi, DWORD PTR __Roff$[ebp]

; 1394 : 		if (npos - _Count <= this->_Mysize() - _N0)

  00038	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0003b	89 7d f8	 mov	 DWORD PTR __Max_effective_size$1$[ebp], edi
  0003e	8b 7d 18	 mov	 edi, DWORD PTR __Count$[ebp]
  00041	3b 7d f8	 cmp	 edi, DWORD PTR __Max_effective_size$1$[ebp]
  00044	89 55 0c	 mov	 DWORD PTR __N0$[ebp], edx
  00047	0f 47 7d f8	 cmova	 edi, DWORD PTR __Max_effective_size$1$[ebp]
  0004b	2b c2		 sub	 eax, edx
  0004d	89 45 18	 mov	 DWORD PTR tv1798[ebp], eax
  00050	8b c7		 mov	 eax, edi
  00052	f7 d0		 not	 eax
  00054	3b 45 18	 cmp	 eax, DWORD PTR tv1798[ebp]
  00057	0f 86 65 03 00
	00		 jbe	 $LN603@replace

; 1396 : 
; 1397 : 		const size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1398 : 		const size_type _Newsize = this->_Mysize() + _Count - _N0;

  0005d	8b 5d 18	 mov	 ebx, DWORD PTR tv1798[ebp]
  00060	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00063	03 df		 add	 ebx, edi
  00065	2b c2		 sub	 eax, edx
  00067	89 5d 18	 mov	 DWORD PTR __Newsize$1$[ebp], ebx

; 1399 : 		if (this->_Mysize() < _Newsize)

  0006a	39 5e 10	 cmp	 DWORD PTR [esi+16], ebx
  0006d	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  00070	89 45 fc	 mov	 DWORD PTR __Nm$1$[ebp], eax
  00073	73 53		 jae	 SHORT $LN194@replace

; 1400 : 			_Grow(_Newsize);

  00075	83 7d 18 fe	 cmp	 DWORD PTR __Newsize$1$[ebp], -2 ; fffffffeH
  00079	0f 87 4d 03 00
	00		 ja	 $LN604@replace
  0007f	8b 5d 18	 mov	 ebx, DWORD PTR __Newsize$1$[ebp]
  00082	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00085	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  00088	73 18		 jae	 SHORT $LN112@replace
  0008a	ff 76 10	 push	 DWORD PTR [esi+16]
  0008d	8b ce		 mov	 ecx, esi
  0008f	ff 75 18	 push	 DWORD PTR __Newsize$1$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00097	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0009a	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  000a0	eb 26		 jmp	 SHORT $LN194@replace
$LN112@replace:
  000a2	83 7d 18 00	 cmp	 DWORD PTR __Newsize$1$[ebp], 0
  000a6	75 20		 jne	 SHORT $LN194@replace
  000a8	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000af	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b3	72 07		 jb	 SHORT $LN189@replace
  000b5	8b 1e		 mov	 ebx, DWORD PTR [esi]
  000b7	89 5d f8	 mov	 DWORD PTR tv1828[ebp], ebx
  000ba	eb 03		 jmp	 SHORT $LN190@replace
$LN189@replace:
  000bc	89 75 f8	 mov	 DWORD PTR tv1828[ebp], esi
$LN190@replace:
  000bf	8b 5d f8	 mov	 ebx, DWORD PTR tv1828[ebp]
  000c2	c6 03 00	 mov	 BYTE PTR [ebx], 0
  000c5	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
$LN194@replace:

; 1401 : 
; 1402 : 		if (_Count == _N0)

  000c8	3b fa		 cmp	 edi, edx
  000ca	75 2b		 jne	 SHORT $LN4@replace

; 1403 : 			{	// only one movement required, so _Traits::move handles any overlap
; 1404 : 			_Traits::move(this->_Myptr() + _Off,

  000cc	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  000d0	72 02		 jb	 SHORT $LN206@replace
  000d2	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN206@replace:
  000d4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000d8	72 04		 jb	 SHORT $LN220@replace
  000da	8b 16		 mov	 edx, DWORD PTR [esi]
  000dc	eb 02		 jmp	 SHORT $LN221@replace
$LN220@replace:
  000de	8b d6		 mov	 edx, esi
$LN221@replace:
  000e0	85 ff		 test	 edi, edi
  000e2	0f 84 9a 02 00
	00		 je	 $LN579@replace
  000e8	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  000eb	03 c1		 add	 eax, ecx
  000ed	57		 push	 edi
  000ee	50		 push	 eax
  000ef	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  000f2	e9 82 02 00 00	 jmp	 $LN598@replace
$LN4@replace:

; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (this != &_Right)

  000f7	3b f1		 cmp	 esi, ecx
  000f9	74 77		 je	 SHORT $LN6@replace

; 1408 : 			{	// no overlap, just move down and copy in new stuff
; 1409 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  000fb	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000ff	72 0a		 jb	 SHORT $LN238@replace
  00101	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00103	89 5d f8	 mov	 DWORD PTR tv1825[ebp], ebx
  00106	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  00109	eb 03		 jmp	 SHORT $LN239@replace
$LN238@replace:
  0010b	89 75 f8	 mov	 DWORD PTR tv1825[ebp], esi
$LN239@replace:
  0010e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00112	72 0a		 jb	 SHORT $LN252@replace
  00114	8b 16		 mov	 edx, DWORD PTR [esi]
  00116	89 55 08	 mov	 DWORD PTR tv1824[ebp], edx
  00119	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0011c	eb 03		 jmp	 SHORT $LN253@replace
$LN252@replace:
  0011e	89 75 08	 mov	 DWORD PTR tv1824[ebp], esi
$LN253@replace:
  00121	85 c0		 test	 eax, eax
  00123	74 1c		 je	 SHORT $LN259@replace
  00125	50		 push	 eax
  00126	8b 45 f8	 mov	 eax, DWORD PTR tv1825[ebp]
  00129	03 c3		 add	 eax, ebx
  0012b	03 c2		 add	 eax, edx
  0012d	50		 push	 eax
  0012e	8b 45 08	 mov	 eax, DWORD PTR tv1824[ebp]
  00131	03 c3		 add	 eax, ebx
  00133	03 c7		 add	 eax, edi
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 _memmove
  0013b	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0013e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN259@replace:

; 1410 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1411 : 			_Traits::copy(this->_Myptr() + _Off,

  00141	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00145	72 02		 jb	 SHORT $LN270@replace
  00147	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN270@replace:
  00149	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0014d	72 04		 jb	 SHORT $LN284@replace
  0014f	8b 16		 mov	 edx, DWORD PTR [esi]
  00151	eb 02		 jmp	 SHORT $LN285@replace
$LN284@replace:
  00153	8b d6		 mov	 edx, esi
$LN285@replace:
  00155	85 ff		 test	 edi, edi
  00157	0f 84 25 02 00
	00		 je	 $LN579@replace
  0015d	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  00160	03 c1		 add	 eax, ecx
  00162	57		 push	 edi
  00163	50		 push	 eax
  00164	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 _memcpy
  0016d	e9 0d 02 00 00	 jmp	 $LN599@replace
$LN6@replace:

; 1412 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1413 : 			}
; 1414 : 		else if (_Count < _N0)

  00172	3b fa		 cmp	 edi, edx
  00174	73 73		 jae	 SHORT $LN8@replace

; 1415 : 			{	// hole doesn't get larger, just copy in substring
; 1416 : 			_Traits::move(this->_Myptr() + _Off,

  00176	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00179	83 f8 10	 cmp	 eax, 16			; 00000010H
  0017c	72 07		 jb	 SHORT $LN302@replace
  0017e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00180	89 4d 08	 mov	 DWORD PTR tv1821[ebp], ecx
  00183	eb 03		 jmp	 SHORT $LN303@replace
$LN302@replace:
  00185	89 75 08	 mov	 DWORD PTR tv1821[ebp], esi
$LN303@replace:
  00188	83 f8 10	 cmp	 eax, 16			; 00000010H
  0018b	72 04		 jb	 SHORT $LN316@replace
  0018d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0018f	eb 02		 jmp	 SHORT $LN317@replace
$LN316@replace:
  00191	8b ce		 mov	 ecx, esi
$LN317@replace:
  00193	85 ff		 test	 edi, edi
  00195	74 17		 je	 SHORT $LN323@replace
  00197	8b 45 08	 mov	 eax, DWORD PTR tv1821[ebp]
  0019a	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  0019d	57		 push	 edi
  0019e	50		 push	 eax
  0019f	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  001a2	50		 push	 eax
  001a3	e8 00 00 00 00	 call	 _memmove
  001a8	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  001ab	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN323@replace:

; 1417 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1418 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  001ae	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001b1	83 f8 10	 cmp	 eax, 16			; 00000010H
  001b4	72 07		 jb	 SHORT $LN334@replace
  001b6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001b8	89 4d 14	 mov	 DWORD PTR tv1819[ebp], ecx
  001bb	eb 03		 jmp	 SHORT $LN335@replace
$LN334@replace:
  001bd	89 75 14	 mov	 DWORD PTR tv1819[ebp], esi
$LN335@replace:
  001c0	83 f8 10	 cmp	 eax, 16			; 00000010H
  001c3	72 04		 jb	 SHORT $LN348@replace
  001c5	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001c7	eb 02		 jmp	 SHORT $LN349@replace
$LN348@replace:
  001c9	8b ce		 mov	 ecx, esi
$LN349@replace:
  001cb	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  001ce	85 c0		 test	 eax, eax
  001d0	0f 84 ac 01 00
	00		 je	 $LN579@replace
  001d6	50		 push	 eax
  001d7	8b 45 14	 mov	 eax, DWORD PTR tv1819[ebp]
  001da	03 c3		 add	 eax, ebx
  001dc	03 c2		 add	 eax, edx
  001de	50		 push	 eax
  001df	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  001e2	03 c7		 add	 eax, edi
  001e4	e9 90 01 00 00	 jmp	 $LN598@replace
$LN8@replace:

; 1419 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1420 : 			}
; 1421 : 		else if (_Roff <= _Off)

  001e9	8b 4d 14	 mov	 ecx, DWORD PTR __Roff$[ebp]
  001ec	3b cb		 cmp	 ecx, ebx
  001ee	77 6b		 ja	 SHORT $LN10@replace

; 1422 : 			{	// hole gets larger, substring begins before hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  001f0	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  001f3	83 f9 10	 cmp	 ecx, 16			; 00000010H
  001f6	72 0a		 jb	 SHORT $LN366@replace
  001f8	8b 16		 mov	 edx, DWORD PTR [esi]
  001fa	89 55 08	 mov	 DWORD PTR tv1817[ebp], edx
  001fd	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  00200	eb 03		 jmp	 SHORT $LN367@replace
$LN366@replace:
  00202	89 75 08	 mov	 DWORD PTR tv1817[ebp], esi
$LN367@replace:
  00205	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00208	72 04		 jb	 SHORT $LN380@replace
  0020a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0020c	eb 02		 jmp	 SHORT $LN381@replace
$LN380@replace:
  0020e	8b ce		 mov	 ecx, esi
$LN381@replace:
  00210	85 c0		 test	 eax, eax
  00212	74 17		 je	 SHORT $LN387@replace
  00214	50		 push	 eax
  00215	8b 45 08	 mov	 eax, DWORD PTR tv1817[ebp]
  00218	03 c3		 add	 eax, ebx
  0021a	03 c2		 add	 eax, edx
  0021c	50		 push	 eax
  0021d	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00220	03 c7		 add	 eax, edi
  00222	50		 push	 eax
  00223	e8 00 00 00 00	 call	 _memmove
  00228	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN387@replace:

; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,

  0022b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0022e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00231	72 04		 jb	 SHORT $LN398@replace
  00233	8b 16		 mov	 edx, DWORD PTR [esi]
  00235	eb 02		 jmp	 SHORT $LN399@replace
$LN398@replace:
  00237	8b d6		 mov	 edx, esi
$LN399@replace:
  00239	83 f8 10	 cmp	 eax, 16			; 00000010H
  0023c	72 04		 jb	 SHORT $LN412@replace
  0023e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00240	eb 02		 jmp	 SHORT $LN413@replace
$LN412@replace:
  00242	8b ce		 mov	 ecx, esi
$LN413@replace:
  00244	85 ff		 test	 edi, edi
  00246	0f 84 36 01 00
	00		 je	 $LN579@replace
  0024c	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  0024f	03 c2		 add	 eax, edx
  00251	57		 push	 edi
  00252	50		 push	 eax
  00253	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00256	e9 1e 01 00 00	 jmp	 $LN598@replace
$LN10@replace:

; 1426 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1427 : 			}
; 1428 : 		else if (_Off + _N0 <= _Roff)

  0025b	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  0025e	3b c1		 cmp	 eax, ecx

; 1429 : 			{	// hole gets larger, substring begins after hole
; 1430 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00260	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00263	77 6d		 ja	 SHORT $LN12@replace
  00265	83 f8 10	 cmp	 eax, 16			; 00000010H
  00268	72 07		 jb	 SHORT $LN430@replace
  0026a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0026c	89 4d 08	 mov	 DWORD PTR tv1813[ebp], ecx
  0026f	eb 03		 jmp	 SHORT $LN431@replace
$LN430@replace:
  00271	89 75 08	 mov	 DWORD PTR tv1813[ebp], esi
$LN431@replace:
  00274	83 f8 10	 cmp	 eax, 16			; 00000010H
  00277	72 04		 jb	 SHORT $LN444@replace
  00279	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0027b	eb 02		 jmp	 SHORT $LN445@replace
$LN444@replace:
  0027d	8b ce		 mov	 ecx, esi
$LN445@replace:
  0027f	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00282	85 c0		 test	 eax, eax
  00284	74 1a		 je	 SHORT $LN451@replace
  00286	50		 push	 eax
  00287	8b 45 08	 mov	 eax, DWORD PTR tv1813[ebp]
  0028a	03 c3		 add	 eax, ebx
  0028c	03 c2		 add	 eax, edx
  0028e	50		 push	 eax
  0028f	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00292	03 c7		 add	 eax, edi
  00294	50		 push	 eax
  00295	e8 00 00 00 00	 call	 _memmove
  0029a	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0029d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN451@replace:

; 1431 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1432 : 			_Traits::move(this->_Myptr() + _Off,

  002a0	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  002a3	83 f9 10	 cmp	 ecx, 16			; 00000010H
  002a6	72 04		 jb	 SHORT $LN462@replace
  002a8	8b 06		 mov	 eax, DWORD PTR [esi]
  002aa	eb 02		 jmp	 SHORT $LN463@replace
$LN462@replace:
  002ac	8b c6		 mov	 eax, esi
$LN463@replace:
  002ae	83 f9 10	 cmp	 ecx, 16			; 00000010H
  002b1	72 04		 jb	 SHORT $LN476@replace
  002b3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002b5	eb 02		 jmp	 SHORT $LN477@replace
$LN476@replace:
  002b7	8b ce		 mov	 ecx, esi
$LN477@replace:
  002b9	85 ff		 test	 edi, edi
  002bb	0f 84 c1 00 00
	00		 je	 $LN579@replace
  002c1	2b c2		 sub	 eax, edx
  002c3	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  002c6	03 c7		 add	 eax, edi
  002c8	57		 push	 edi
  002c9	50		 push	 eax
  002ca	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]

; 1433 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1434 : 				_Count);	// fill hole
; 1435 : 			}
; 1436 : 		else

  002cd	e9 a7 00 00 00	 jmp	 $LN598@replace
$LN12@replace:

; 1437 : 			{	// hole gets larger, substring begins in hole
; 1438 : 			_Traits::move(this->_Myptr() + _Off,

  002d2	83 f8 10	 cmp	 eax, 16			; 00000010H
  002d5	72 07		 jb	 SHORT $LN494@replace
  002d7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002d9	89 4d 10	 mov	 DWORD PTR tv1809[ebp], ecx
  002dc	eb 03		 jmp	 SHORT $LN495@replace
$LN494@replace:
  002de	89 75 10	 mov	 DWORD PTR tv1809[ebp], esi
$LN495@replace:
  002e1	83 f8 10	 cmp	 eax, 16			; 00000010H
  002e4	72 04		 jb	 SHORT $LN508@replace
  002e6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002e8	eb 02		 jmp	 SHORT $LN509@replace
$LN508@replace:
  002ea	8b ce		 mov	 ecx, esi
$LN509@replace:
  002ec	85 d2		 test	 edx, edx
  002ee	74 17		 je	 SHORT $LN515@replace
  002f0	8b 45 10	 mov	 eax, DWORD PTR tv1809[ebp]
  002f3	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  002f6	52		 push	 edx
  002f7	50		 push	 eax
  002f8	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  002fb	50		 push	 eax
  002fc	e8 00 00 00 00	 call	 _memmove
  00301	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  00304	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN515@replace:

; 1439 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00307	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0030a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0030d	72 07		 jb	 SHORT $LN526@replace
  0030f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00311	89 4d 10	 mov	 DWORD PTR tv1807[ebp], ecx
  00314	eb 03		 jmp	 SHORT $LN527@replace
$LN526@replace:
  00316	89 75 10	 mov	 DWORD PTR tv1807[ebp], esi
$LN527@replace:
  00319	83 f8 10	 cmp	 eax, 16			; 00000010H
  0031c	72 04		 jb	 SHORT $LN540@replace
  0031e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00320	eb 02		 jmp	 SHORT $LN541@replace
$LN540@replace:
  00322	8b ce		 mov	 ecx, esi
$LN541@replace:
  00324	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00327	85 c0		 test	 eax, eax
  00329	74 17		 je	 SHORT $LN547@replace
  0032b	50		 push	 eax
  0032c	8b 45 10	 mov	 eax, DWORD PTR tv1807[ebp]
  0032f	03 c3		 add	 eax, ebx
  00331	03 c2		 add	 eax, edx
  00333	50		 push	 eax
  00334	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00337	03 c7		 add	 eax, edi
  00339	50		 push	 eax
  0033a	e8 00 00 00 00	 call	 _memmove
  0033f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN547@replace:

; 1441 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1442 : 			_Traits::move(this->_Myptr() + _Off + _N0,

  00342	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00345	83 f8 10	 cmp	 eax, 16			; 00000010H
  00348	72 07		 jb	 SHORT $LN558@replace
  0034a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0034c	89 4d 10	 mov	 DWORD PTR tv1805[ebp], ecx
  0034f	eb 03		 jmp	 SHORT $LN559@replace
$LN558@replace:
  00351	89 75 10	 mov	 DWORD PTR tv1805[ebp], esi
$LN559@replace:
  00354	83 f8 10	 cmp	 eax, 16			; 00000010H
  00357	72 04		 jb	 SHORT $LN572@replace
  00359	8b 16		 mov	 edx, DWORD PTR [esi]
  0035b	eb 02		 jmp	 SHORT $LN573@replace
$LN572@replace:
  0035d	8b d6		 mov	 edx, esi
$LN573@replace:
  0035f	8b 4d 0c	 mov	 ecx, DWORD PTR __N0$[ebp]
  00362	8b c7		 mov	 eax, edi
  00364	2b c1		 sub	 eax, ecx
  00366	74 1a		 je	 SHORT $LN579@replace
  00368	50		 push	 eax
  00369	8b 45 10	 mov	 eax, DWORD PTR tv1805[ebp]
  0036c	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  0036f	03 c7		 add	 eax, edi
  00371	50		 push	 eax
  00372	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00375	03 c2		 add	 eax, edx
  00377	03 c1		 add	 eax, ecx
$LN598@replace:
  00379	50		 push	 eax
  0037a	e8 00 00 00 00	 call	 _memmove
$LN599@replace:
  0037f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN579@replace:

; 1443 : 				this->_Myptr() + _Roff + _Count,
; 1444 : 				_Count - _N0);	// fill rest of new hole
; 1445 : 			}
; 1446 : 
; 1447 : 		_Eos(_Newsize);

  00382	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00386	8b 4d 18	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]
  00389	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0038c	72 11		 jb	 SHORT $LN590@replace
  0038e	8b 06		 mov	 eax, DWORD PTR [esi]
  00390	5f		 pop	 edi
  00391	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1448 : 		return (*this);

  00395	8b c6		 mov	 eax, esi
  00397	5e		 pop	 esi
  00398	5b		 pop	 ebx

; 1449 : 		}

  00399	8b e5		 mov	 esp, ebp
  0039b	5d		 pop	 ebp
  0039c	c2 14 00	 ret	 20			; 00000014H

; 1443 : 				this->_Myptr() + _Roff + _Count,
; 1444 : 				_Count - _N0);	// fill rest of new hole
; 1445 : 			}
; 1446 : 
; 1447 : 		_Eos(_Newsize);

$LN590@replace:
  0039f	8b c6		 mov	 eax, esi
  003a1	5f		 pop	 edi
  003a2	5e		 pop	 esi
  003a3	5b		 pop	 ebx
  003a4	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1449 : 		}

  003a8	8b e5		 mov	 esp, ebp
  003aa	5d		 pop	 ebp
  003ab	c2 14 00	 ret	 20			; 00000014H
$LN600@replace:

; 1390 : 		_Check_offset(_Off);

  003ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  003b3	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN605@replace:
$LN602@replace:

; 1391 : 		_Right._Check_offset(_Roff);

  003b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  003bd	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN606@replace:
$LN603@replace:

; 1395 : 			_Xlen();	// result too long

  003c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  003c7	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN607@replace:
$LN604@replace:

; 1400 : 			_Grow(_Newsize);

  003cc	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  003d1	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN608@replace:
$LN597@replace:
  003d6	cc		 int	 3
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear, COMDAT
; _this$ = ecx

; 1378 : 		_Eos(0);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0000b	72 06		 jb	 SHORT $LN13@clear
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1379 : 		}

  00012	c3		 ret	 0

; 1378 : 		_Eos(0);

$LN13@clear:
  00013	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 1379 : 		}

  00016	c3		 ret	 0
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1348 : 		_Check_offset(_Off);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	72 7e		 jb	 SHORT $LN93@erase

; 1349 : 		if (this->_Mysize() - _Off <= _Count)

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00014	8b c7		 mov	 eax, edi
  00016	2b c1		 sub	 eax, ecx
  00018	3b c2		 cmp	 eax, edx
  0001a	77 23		 ja	 SHORT $LN2@erase

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

  0001c	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0001f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00023	72 0e		 jb	 SHORT $LN41@erase
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	5f		 pop	 edi
  00028	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1357 : 			}
; 1358 : 		return (*this);

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi

; 1359 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

$LN41@erase:
  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1359 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN2@erase:

; 1351 : 		else if (0 < _Count)

  0003f	85 d2		 test	 edx, edx
  00041	74 44		 je	 SHORT $LN90@erase

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;

  00043	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00047	72 04		 jb	 SHORT $LN58@erase
  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	eb 02		 jmp	 SHORT $LN59@erase
$LN58@erase:
  0004d	8b c6		 mov	 eax, esi
$LN59@erase:

; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

  0004f	2b fa		 sub	 edi, edx
  00051	53		 push	 ebx
  00052	8d 1c 08	 lea	 ebx, DWORD PTR [eax+ecx]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00055	8b c7		 mov	 eax, edi
  00057	2b c1		 sub	 eax, ecx
  00059	74 0e		 je	 SHORT $LN74@erase
  0005b	50		 push	 eax
  0005c	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  0005f	50		 push	 eax
  00060	53		 push	 ebx
  00061	e8 00 00 00 00	 call	 _memmove
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@erase:

; 1356 : 			_Eos(_Newsize);

  00069	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0006d	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00070	5b		 pop	 ebx
  00071	72 0e		 jb	 SHORT $LN85@erase
  00073	8b 06		 mov	 eax, DWORD PTR [esi]
  00075	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1357 : 			}
; 1358 : 		return (*this);

  00079	8b c6		 mov	 eax, esi
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 1359 : 		}

  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8

; 1356 : 			_Eos(_Newsize);

$LN85@erase:
  00081	8b c6		 mov	 eax, esi
  00083	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN90@erase:

; 1357 : 			}
; 1358 : 		return (*this);

  00087	5f		 pop	 edi
  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi

; 1359 : 		}

  0008b	5d		 pop	 ebp
  0008c	c2 08 00	 ret	 8
$LN93@erase:

; 1348 : 		_Check_offset(_Off);

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00094	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN95@erase:
$LN92@erase:
  00099	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1341 : 		_Check_offset(_Off);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	72 21		 jb	 SHORT $LN37@erase

; 1342 : 		_Eos(_Off);

  0000b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000e	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00012	72 0c		 jb	 SHORT $LN29@erase
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 1343 : 		return (*this);

  0001a	8b c1		 mov	 eax, ecx

; 1344 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4

; 1342 : 		_Eos(_Off);

$LN29@erase:
  00020	8b d1		 mov	 edx, ecx
  00022	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 1343 : 		return (*this);

  00026	8b c1		 mov	 eax, ecx

; 1344 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN37@erase:

; 1341 : 		_Check_offset(_Off);

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00031	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN39@erase:
$LN36@erase:
  00036	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
tv544 = 12						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1278 : 		{	// insert _Count * _Ch at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1279 : 		_Check_offset(_Off);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000e	3b ca		 cmp	 ecx, edx
  00010	0f 82 d2 00 00
	00		 jb	 $LN188@insert

; 1280 : 		if (npos - this->_Mysize() <= _Count)

  00016	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00019	8b c1		 mov	 eax, ecx
  0001b	f7 d0		 not	 eax
  0001d	3b c3		 cmp	 eax, ebx
  0001f	0f 86 cd 00 00
	00		 jbe	 $LN190@insert

; 1282 : 		const size_type _Num = this->_Mysize() + _Count;

  00025	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]

; 1283 : 		if (0 < _Count && _Grow(_Num))

  00028	85 db		 test	 ebx, ebx
  0002a	0f 84 af 00 00
	00		 je	 $LN183@insert
  00030	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00033	0f 87 c3 00 00
	00		 ja	 $LN191@insert
  00039	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0003c	73 23		 jae	 SHORT $LN43@insert
  0003e	51		 push	 ecx
  0003f	57		 push	 edi
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00047	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  0004a	85 ff		 test	 edi, edi
  0004c	0f 84 8d 00 00
	00		 je	 $LN183@insert
$LN187@insert:

; 1284 : 			{	// make room and insert new stuff
; 1285 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00052	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00055	83 f8 10	 cmp	 eax, 16			; 00000010H
  00058	72 2e		 jb	 SHORT $LN146@insert
  0005a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005c	89 4d 0c	 mov	 DWORD PTR tv544[ebp], ecx
  0005f	eb 2a		 jmp	 SHORT $LN147@insert

; 1283 : 		if (0 < _Count && _Grow(_Num))

$LN43@insert:
  00061	85 ff		 test	 edi, edi
  00063	75 ed		 jne	 SHORT $LN187@insert
  00065	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00068	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0006c	72 0e		 jb	 SHORT $LN120@insert
  0006e	8b 06		 mov	 eax, DWORD PTR [esi]
  00070	5f		 pop	 edi
  00071	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1290 : 			}
; 1291 : 		return (*this);

  00074	8b c6		 mov	 eax, esi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx

; 1292 : 		}

  00078	5d		 pop	 ebp
  00079	c2 0c 00	 ret	 12			; 0000000cH

; 1283 : 		if (0 < _Count && _Grow(_Num))

$LN120@insert:
  0007c	8b c6		 mov	 eax, esi
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1292 : 		}

  00084	5d		 pop	 ebp
  00085	c2 0c 00	 ret	 12			; 0000000cH

; 1284 : 			{	// make room and insert new stuff
; 1285 : 			_Traits::move(this->_Myptr() + _Off + _Count,

$LN146@insert:
  00088	89 75 0c	 mov	 DWORD PTR tv544[ebp], esi
$LN147@insert:
  0008b	83 f8 10	 cmp	 eax, 16			; 00000010H
  0008e	72 04		 jb	 SHORT $LN160@insert
  00090	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00092	eb 02		 jmp	 SHORT $LN161@insert
$LN160@insert:
  00094	8b ce		 mov	 ecx, esi
$LN161@insert:
  00096	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00099	2b c2		 sub	 eax, edx
  0009b	74 18		 je	 SHORT $LN167@insert
  0009d	50		 push	 eax
  0009e	8b 45 0c	 mov	 eax, DWORD PTR tv544[ebp]
  000a1	03 c2		 add	 eax, edx
  000a3	50		 push	 eax
  000a4	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  000a7	03 c3		 add	 eax, ebx
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _memmove
  000af	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN167@insert:

; 1286 : 				this->_Myptr() + _Off,
; 1287 : 				this->_Mysize() - _Off);	// empty out hole
; 1288 : 			_Chassign(_Off, _Count, _Ch);	// fill hole

  000b5	ff 75 10	 push	 DWORD PTR __Ch$[ebp]
  000b8	8b ce		 mov	 ecx, esi
  000ba	53		 push	 ebx
  000bb	52		 push	 edx
  000bc	e8 00 00 00 00	 call	 ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 1289 : 			_Eos(_Num);

  000c1	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000c5	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000c8	72 0f		 jb	 SHORT $LN178@insert
  000ca	8b 06		 mov	 eax, DWORD PTR [esi]
  000cc	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1290 : 			}
; 1291 : 		return (*this);

  000d0	8b c6		 mov	 eax, esi
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx

; 1292 : 		}

  000d5	5d		 pop	 ebp
  000d6	c2 0c 00	 ret	 12			; 0000000cH

; 1289 : 			_Eos(_Num);

$LN178@insert:
  000d9	8b c6		 mov	 eax, esi
  000db	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN183@insert:

; 1290 : 			}
; 1291 : 		return (*this);

  000df	5f		 pop	 edi
  000e0	8b c6		 mov	 eax, esi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx

; 1292 : 		}

  000e4	5d		 pop	 ebp
  000e5	c2 0c 00	 ret	 12			; 0000000cH
$LN188@insert:

; 1279 : 		_Check_offset(_Off);

  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000ed	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN192@insert:
$LN190@insert:

; 1281 : 			_Xlen();	// result too long

  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f7	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN193@insert:
$LN191@insert:

; 1283 : 		if (0 < _Count && _Grow(_Num))

  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00101	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN194@insert:
$LN185@insert:
  00106	cc		 int	 3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1271 : 		{	// insert [_Ptr, <null>) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1272 : 		_DEBUG_POINTER(_Ptr);
; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 11		 jne	 SHORT $LN5@insert
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00013	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00018	5e		 pop	 esi

; 1274 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8

; 1272 : 		_DEBUG_POINTER(_Ptr);
; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

$LN5@insert:
  0001d	8b d6		 mov	 edx, esi
  0001f	57		 push	 edi
  00020	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@insert:
  00023	8a 02		 mov	 al, BYTE PTR [edx]
  00025	42		 inc	 edx
  00026	84 c0		 test	 al, al
  00028	75 f9		 jne	 SHORT $LL7@insert
  0002a	2b d7		 sub	 edx, edi
  0002c	5f		 pop	 edi
  0002d	52		 push	 edx
  0002e	56		 push	 esi
  0002f	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00032	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00037	5e		 pop	 esi

; 1274 : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z
_TEXT	SEGMENT
tv774 = -4						; size = 4
__Off$ = 8						; size = 4
tv775 = 12						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1250 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1251 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1252 : 		if (_Inside(_Ptr))

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	85 db		 test	 ebx, ebx
  0000d	74 4a		 je	 SHORT $LN2@insert
  0000f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00012	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00015	72 04		 jb	 SHORT $LN21@insert
  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	eb 02		 jmp	 SHORT $LN22@insert
$LN21@insert:
  0001b	8b c6		 mov	 eax, esi
$LN22@insert:
  0001d	3b d8		 cmp	 ebx, eax
  0001f	72 38		 jb	 SHORT $LN2@insert
  00021	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00024	72 04		 jb	 SHORT $LN35@insert
  00026	8b 16		 mov	 edx, DWORD PTR [esi]
  00028	eb 02		 jmp	 SHORT $LN36@insert
$LN35@insert:
  0002a	8b d6		 mov	 edx, esi
$LN36@insert:
  0002c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002f	03 c2		 add	 eax, edx
  00031	3b c3		 cmp	 eax, ebx
  00033	76 24		 jbe	 SHORT $LN2@insert

; 1253 : 			return (insert(_Off, *this,

  00035	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00038	72 04		 jb	 SHORT $LN58@insert
  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	eb 02		 jmp	 SHORT $LN59@insert
$LN58@insert:
  0003e	8b c6		 mov	 eax, esi
$LN59@insert:
  00040	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00043	2b d8		 sub	 ebx, eax
  00045	8b ce		 mov	 ecx, esi
  00047	53		 push	 ebx
  00048	56		 push	 esi
  00049	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  0004c	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx

; 1268 : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 0c 00	 ret	 12			; 0000000cH
$LN2@insert:

; 1254 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1255 : 		_Check_offset(_Off);

  00059	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0005c	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  0005f	0f 82 f9 00 00
	00		 jb	 $LN264@insert

; 1256 : 		if (npos - this->_Mysize() <= _Count)

  00065	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  00068	8b c1		 mov	 eax, ecx
  0006a	f7 d0		 not	 eax
  0006c	3b c2		 cmp	 eax, edx
  0006e	0f 86 f4 00 00
	00		 jbe	 $LN266@insert

; 1258 : 		const size_type _Num = this->_Mysize() + _Count;

  00074	57		 push	 edi
  00075	8d 3c 11	 lea	 edi, DWORD PTR [ecx+edx]

; 1259 : 		if (0 < _Count && _Grow(_Num))

  00078	85 d2		 test	 edx, edx
  0007a	0f 84 d3 00 00
	00		 je	 $LN258@insert
  00080	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00083	0f 87 e9 00 00
	00		 ja	 $LN267@insert
  00089	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0008c	73 23		 jae	 SHORT $LN100@insert
  0008e	51		 push	 ecx
  0008f	57		 push	 edi
  00090	8b ce		 mov	 ecx, esi
  00092	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00097	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  0009a	85 ff		 test	 edi, edi
  0009c	0f 84 b1 00 00
	00		 je	 $LN258@insert
$LN263@insert:

; 1260 : 			{	// make room and insert new stuff
; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  000a2	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000a5	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a8	72 32		 jb	 SHORT $LN203@insert
  000aa	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000ac	89 4d 0c	 mov	 DWORD PTR tv775[ebp], ecx
  000af	eb 2e		 jmp	 SHORT $LN204@insert

; 1259 : 		if (0 < _Count && _Grow(_Num))

$LN100@insert:
  000b1	85 ff		 test	 edi, edi
  000b3	75 ed		 jne	 SHORT $LN263@insert
  000b5	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000b8	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000bc	72 10		 jb	 SHORT $LN177@insert
  000be	8b 06		 mov	 eax, DWORD PTR [esi]
  000c0	5f		 pop	 edi
  000c1	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1266 : 			}
; 1267 : 		return (*this);

  000c4	8b c6		 mov	 eax, esi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx

; 1268 : 		}

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 0c 00	 ret	 12			; 0000000cH

; 1259 : 		if (0 < _Count && _Grow(_Num))

$LN177@insert:
  000ce	8b c6		 mov	 eax, esi
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1268 : 		}

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 0c 00	 ret	 12			; 0000000cH

; 1260 : 			{	// make room and insert new stuff
; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

$LN203@insert:
  000dc	89 75 0c	 mov	 DWORD PTR tv775[ebp], esi
$LN204@insert:
  000df	83 f8 10	 cmp	 eax, 16			; 00000010H
  000e2	72 07		 jb	 SHORT $LN217@insert
  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	89 45 fc	 mov	 DWORD PTR tv774[ebp], eax
  000e9	eb 03		 jmp	 SHORT $LN218@insert
$LN217@insert:
  000eb	89 75 fc	 mov	 DWORD PTR tv774[ebp], esi
$LN218@insert:
  000ee	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  000f4	2b c1		 sub	 eax, ecx
  000f6	74 1a		 je	 SHORT $LN224@insert
  000f8	50		 push	 eax
  000f9	8b 45 0c	 mov	 eax, DWORD PTR tv775[ebp]
  000fc	03 c1		 add	 eax, ecx
  000fe	50		 push	 eax
  000ff	8b 45 fc	 mov	 eax, DWORD PTR tv774[ebp]
  00102	03 c1		 add	 eax, ecx
  00104	03 c2		 add	 eax, edx
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 _memmove
  0010c	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0010f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN224@insert:

; 1262 : 				this->_Myptr() + _Off,
; 1263 : 				this->_Mysize() - _Off);	// empty out hole
; 1264 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

  00112	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00116	72 04		 jb	 SHORT $LN235@insert
  00118	8b 16		 mov	 edx, DWORD PTR [esi]
  0011a	eb 02		 jmp	 SHORT $LN236@insert
$LN235@insert:
  0011c	8b d6		 mov	 edx, esi
$LN236@insert:
  0011e	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00121	85 c0		 test	 eax, eax
  00123	74 0e		 je	 SHORT $LN242@insert
  00125	50		 push	 eax
  00126	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00129	53		 push	 ebx
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _memcpy
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN242@insert:

; 1265 : 			_Eos(_Num);

  00133	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00137	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0013a	72 11		 jb	 SHORT $LN253@insert
  0013c	8b 06		 mov	 eax, DWORD PTR [esi]
  0013e	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1266 : 			}
; 1267 : 		return (*this);

  00142	8b c6		 mov	 eax, esi
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx

; 1268 : 		}

  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 0c 00	 ret	 12			; 0000000cH

; 1265 : 			_Eos(_Num);

$LN253@insert:
  0014d	8b c6		 mov	 eax, esi
  0014f	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN258@insert:

; 1266 : 			}
; 1267 : 		return (*this);

  00153	5f		 pop	 edi
  00154	8b c6		 mov	 eax, esi
  00156	5e		 pop	 esi
  00157	5b		 pop	 ebx

; 1268 : 		}

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 0c 00	 ret	 12			; 0000000cH
$LN264@insert:

; 1254 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1255 : 		_Check_offset(_Off);

  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00163	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN268@insert:
$LN266@insert:

; 1257 : 			_Xlen();	// result too long

  00168	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0016d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN269@insert:
$LN267@insert:

; 1259 : 		if (0 < _Count && _Grow(_Num))

  00172	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00177	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN270@insert:
$LN261@insert:
  0017c	cc		 int	 3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z
_TEXT	SEGMENT
tv860 = 8						; size = 4
tv857 = 8						; size = 4
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
tv849 = 16						; size = 4
__Roff$ = 16						; size = 4
tv862 = 20						; size = 4
__Count$ = 20						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1223 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 1224 : 		_Check_offset(_Off);

  00008	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000b	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  0000e	0f 82 55 01 00
	00		 jb	 $LN285@insert

; 1225 : 		_Right._Check_offset(_Roff);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00017	8b 55 10	 mov	 edx, DWORD PTR __Roff$[ebp]
  0001a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0001d	3b c2		 cmp	 eax, edx
  0001f	0f 82 4e 01 00
	00		 jb	 $LN287@insert

; 1226 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00025	8b 7d 14	 mov	 edi, DWORD PTR __Count$[ebp]
  00028	2b c2		 sub	 eax, edx
  0002a	3b f8		 cmp	 edi, eax
  0002c	0f 47 f8	 cmova	 edi, eax

; 1227 : 		if (npos - this->_Mysize() <= _Count)

  0002f	8b c1		 mov	 eax, ecx
  00031	f7 d0		 not	 eax
  00033	3b c7		 cmp	 eax, edi
  00035	0f 86 42 01 00
	00		 jbe	 $LN288@insert

; 1229 : 
; 1230 : 		const size_type _Num = this->_Mysize() + _Count;

  0003b	8d 1c 39	 lea	 ebx, DWORD PTR [ecx+edi]

; 1231 : 		if (0 < _Count && _Grow(_Num))

  0003e	85 ff		 test	 edi, edi
  00040	0f 84 1a 01 00
	00		 je	 $LN279@insert
  00046	83 fb fe	 cmp	 ebx, -2			; fffffffeH
  00049	0f 87 38 01 00
	00		 ja	 $LN289@insert
  0004f	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00052	73 20		 jae	 SHORT $LN75@insert
  00054	51		 push	 ecx
  00055	53		 push	 ebx
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0005d	85 db		 test	 ebx, ebx
  0005f	0f 84 fb 00 00
	00		 je	 $LN279@insert
$LN283@insert:

; 1232 : 			{	// make room and insert new stuff
; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00065	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00068	83 f8 10	 cmp	 eax, 16			; 00000010H
  0006b	72 2d		 jb	 SHORT $LN178@insert
  0006d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0006f	89 4d 14	 mov	 DWORD PTR tv862[ebp], ecx
  00072	eb 29		 jmp	 SHORT $LN179@insert

; 1231 : 		if (0 < _Count && _Grow(_Num))

$LN75@insert:
  00074	85 db		 test	 ebx, ebx
  00076	75 ed		 jne	 SHORT $LN283@insert
  00078	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  0007b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0007f	72 0d		 jb	 SHORT $LN152@insert
  00081	8b 06		 mov	 eax, DWORD PTR [esi]
  00083	5f		 pop	 edi
  00084	88 18		 mov	 BYTE PTR [eax], bl

; 1244 : 			}
; 1245 : 		return (*this);

  00086	8b c6		 mov	 eax, esi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx

; 1246 : 		}

  0008a	5d		 pop	 ebp
  0008b	c2 10 00	 ret	 16			; 00000010H

; 1231 : 		if (0 < _Count && _Grow(_Num))

$LN152@insert:
  0008e	8b c6		 mov	 eax, esi
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1246 : 		}

  00096	5d		 pop	 ebp
  00097	c2 10 00	 ret	 16			; 00000010H

; 1232 : 			{	// make room and insert new stuff
; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

$LN178@insert:
  0009a	89 75 14	 mov	 DWORD PTR tv862[ebp], esi
$LN179@insert:
  0009d	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a0	72 04		 jb	 SHORT $LN192@insert
  000a2	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000a4	eb 02		 jmp	 SHORT $LN193@insert
$LN192@insert:
  000a6	8b ce		 mov	 ecx, esi
$LN193@insert:
  000a8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000ab	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000ae	2b c2		 sub	 eax, edx
  000b0	74 18		 je	 SHORT $LN199@insert
  000b2	50		 push	 eax
  000b3	8b 45 14	 mov	 eax, DWORD PTR tv862[ebp]
  000b6	03 c2		 add	 eax, edx
  000b8	50		 push	 eax
  000b9	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  000bc	03 c7		 add	 eax, edi
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _memmove
  000c4	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN199@insert:

; 1234 : 				this->_Myptr() + _Off,
; 1235 : 				this->_Mysize() - _Off);	// empty out hole
; 1236 : 			if (this == &_Right)

  000ca	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  000cd	3b f0		 cmp	 esi, eax
  000cf	75 42		 jne	 SHORT $LN4@insert

; 1237 : 				_Traits::move(this->_Myptr() + _Off,

  000d1	8b 45 10	 mov	 eax, DWORD PTR __Roff$[ebp]
  000d4	3b d0		 cmp	 edx, eax
  000d6	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  000d9	0f 43 c8	 cmovae	 ecx, eax
  000dc	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000df	89 4d 10	 mov	 DWORD PTR tv849[ebp], ecx
  000e2	83 f8 10	 cmp	 eax, 16			; 00000010H
  000e5	72 07		 jb	 SHORT $LN210@insert
  000e7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000e9	89 4d 08	 mov	 DWORD PTR tv860[ebp], ecx
  000ec	eb 03		 jmp	 SHORT $LN211@insert
$LN210@insert:
  000ee	89 75 08	 mov	 DWORD PTR tv860[ebp], esi
$LN211@insert:
  000f1	83 f8 10	 cmp	 eax, 16			; 00000010H
  000f4	72 04		 jb	 SHORT $LN224@insert
  000f6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000f8	eb 02		 jmp	 SHORT $LN225@insert
$LN224@insert:
  000fa	8b ce		 mov	 ecx, esi
$LN225@insert:
  000fc	85 ff		 test	 edi, edi
  000fe	74 42		 je	 SHORT $LN263@insert
  00100	8b 45 10	 mov	 eax, DWORD PTR tv849[ebp]
  00103	03 45 08	 add	 eax, DWORD PTR tv860[ebp]
  00106	57		 push	 edi
  00107	50		 push	 eax
  00108	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 _memmove

; 1238 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1239 : 						_Count);	// substring
; 1240 : 			else

  00111	eb 2c		 jmp	 SHORT $LN284@insert
$LN4@insert:

; 1241 : 				_Traits::copy(this->_Myptr() + _Off,

  00113	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00117	72 02		 jb	 SHORT $LN242@insert
  00119	8b 00		 mov	 eax, DWORD PTR [eax]
$LN242@insert:
  0011b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0011f	72 07		 jb	 SHORT $LN256@insert
  00121	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00123	89 4d 08	 mov	 DWORD PTR tv857[ebp], ecx
  00126	eb 03		 jmp	 SHORT $LN257@insert
$LN256@insert:
  00128	89 75 08	 mov	 DWORD PTR tv857[ebp], esi
$LN257@insert:
  0012b	85 ff		 test	 edi, edi
  0012d	74 13		 je	 SHORT $LN263@insert
  0012f	03 45 10	 add	 eax, DWORD PTR __Roff$[ebp]
  00132	57		 push	 edi
  00133	50		 push	 eax
  00134	8b 45 08	 mov	 eax, DWORD PTR tv857[ebp]
  00137	03 c2		 add	 eax, edx
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 _memcpy
$LN284@insert:
  0013f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN263@insert:

; 1242 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1243 : 			_Eos(_Num);

  00142	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00146	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00149	72 0f		 jb	 SHORT $LN274@insert
  0014b	8b 06		 mov	 eax, DWORD PTR [esi]
  0014d	5f		 pop	 edi
  0014e	c6 04 18 00	 mov	 BYTE PTR [eax+ebx], 0

; 1244 : 			}
; 1245 : 		return (*this);

  00152	8b c6		 mov	 eax, esi
  00154	5e		 pop	 esi
  00155	5b		 pop	 ebx

; 1246 : 		}

  00156	5d		 pop	 ebp
  00157	c2 10 00	 ret	 16			; 00000010H

; 1242 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1243 : 			_Eos(_Num);

$LN274@insert:
  0015a	8b c6		 mov	 eax, esi
  0015c	c6 04 18 00	 mov	 BYTE PTR [eax+ebx], 0
$LN279@insert:

; 1244 : 			}
; 1245 : 		return (*this);

  00160	5f		 pop	 edi
  00161	8b c6		 mov	 eax, esi
  00163	5e		 pop	 esi
  00164	5b		 pop	 ebx

; 1246 : 		}

  00165	5d		 pop	 ebp
  00166	c2 10 00	 ret	 16			; 00000010H
$LN285@insert:

; 1224 : 		_Check_offset(_Off);

  00169	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0016e	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN290@insert:
$LN287@insert:

; 1225 : 		_Right._Check_offset(_Roff);

  00173	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00178	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN291@insert:
$LN288@insert:

; 1228 : 			_Xlen();	// result too long

  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00182	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN292@insert:
$LN289@insert:

; 1231 : 		if (0 < _Count && _Grow(_Num))

  00187	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0018c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN293@insert:
$LN281@insert:
  00191	cc		 int	 3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1186 : 		{	// assign _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1187 : 		if (_Count == npos)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	83 ff ff	 cmp	 edi, -1
  0000d	0f 84 9d 00 00
	00		 je	 $LN151@assign

; 1189 : 
; 1190 : 		if (_Grow(_Count))

  00013	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00016	0f 87 9e 00 00
	00		 ja	 $LN153@assign
  0001c	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0001f	73 21		 jae	 SHORT $LN10@assign
  00021	ff 76 10	 push	 DWORD PTR [esi+16]
  00024	57		 push	 edi
  00025	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0002a	85 ff		 test	 edi, edi
  0002c	74 7a		 je	 SHORT $LN146@assign
$LN150@assign:

; 1191 : 			{	// make room and assign new stuff
; 1192 : 			_Chassign(0, _Count, _Ch);

  0002e	83 ff 01	 cmp	 edi, 1
  00031	75 3d		 jne	 SHORT $LN95@assign
  00033	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00037	72 2e		 jb	 SHORT $LN108@assign
  00039	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003b	8a 45 0c	 mov	 al, BYTE PTR __Ch$[ebp]
  0003e	88 01		 mov	 BYTE PTR [ecx], al
  00040	eb 49		 jmp	 SHORT $LN96@assign

; 1189 : 
; 1190 : 		if (_Grow(_Count))

$LN10@assign:
  00042	85 ff		 test	 edi, edi
  00044	75 e8		 jne	 SHORT $LN150@assign
  00046	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0004a	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0004d	72 0d		 jb	 SHORT $LN87@assign
  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	5f		 pop	 edi
  00052	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1194 : 			}
; 1195 : 		return (*this);

  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi

; 1196 : 		}

  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8

; 1189 : 
; 1190 : 		if (_Grow(_Count))

$LN87@assign:
  0005c	8b c6		 mov	 eax, esi
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1196 : 		}

  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8

; 1191 : 			{	// make room and assign new stuff
; 1192 : 			_Chassign(0, _Count, _Ch);

$LN108@assign:
  00067	8a 45 0c	 mov	 al, BYTE PTR __Ch$[ebp]
  0006a	8b ce		 mov	 ecx, esi
  0006c	88 01		 mov	 BYTE PTR [ecx], al
  0006e	eb 1b		 jmp	 SHORT $LN96@assign
$LN95@assign:
  00070	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00074	72 04		 jb	 SHORT $LN125@assign
  00076	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00078	eb 02		 jmp	 SHORT $LN126@assign
$LN125@assign:
  0007a	8b ce		 mov	 ecx, esi
$LN126@assign:
  0007c	0f be 45 0c	 movsx	 eax, BYTE PTR __Ch$[ebp]
  00080	57		 push	 edi
  00081	50		 push	 eax
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _memset
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN96@assign:

; 1193 : 			_Eos(_Count);

  0008b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0008f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00092	72 0e		 jb	 SHORT $LN141@assign
  00094	8b 06		 mov	 eax, DWORD PTR [esi]
  00096	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1194 : 			}
; 1195 : 		return (*this);

  0009a	8b c6		 mov	 eax, esi
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi

; 1196 : 		}

  0009e	5d		 pop	 ebp
  0009f	c2 08 00	 ret	 8

; 1193 : 			_Eos(_Count);

$LN141@assign:
  000a2	8b c6		 mov	 eax, esi
  000a4	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN146@assign:

; 1194 : 			}
; 1195 : 		return (*this);

  000a8	5f		 pop	 edi
  000a9	8b c6		 mov	 eax, esi
  000ab	5e		 pop	 esi

; 1196 : 		}

  000ac	5d		 pop	 ebp
  000ad	c2 08 00	 ret	 8
$LN151@assign:

; 1188 : 			_Xlen();	// result too long

  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000b5	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN154@assign:
$LN153@assign:

; 1189 : 
; 1190 : 		if (_Grow(_Count))

  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000bf	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN155@assign:
$LN148@assign:
  000c4	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN5@assign
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00015	5e		 pop	 esi

; 1183 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

$LN5@assign:
  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@assign:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL7@assign
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00031	5e		 pop	 esi

; 1183 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1166 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1167 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 57		 je	 SHORT $LN2@assign
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN20@assign
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN21@assign
$LN20@assign:
  0001a	8b c6		 mov	 eax, esi
$LN21@assign:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 45		 jb	 SHORT $LN2@assign
  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN34@assign
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN35@assign
$LN34@assign:
  00029	8b d6		 mov	 edx, esi
$LN35@assign:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	03 c2		 add	 eax, edx
  00030	3b c3		 cmp	 eax, ebx
  00032	76 31		 jbe	 SHORT $LN2@assign

; 1168 : 			return (assign(*this,

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 16		 jb	 SHORT $LN57@assign
  00039	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	8b ce		 mov	 ecx, esi
  00040	2b d8		 sub	 ebx, eax
  00042	53		 push	 ebx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 1177 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8

; 1168 : 			return (assign(*this,

$LN57@assign:
  0004f	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00052	8b c6		 mov	 eax, esi
  00054	8b ce		 mov	 ecx, esi
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 1177 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN2@assign:
  00065	57		 push	 edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  00066	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00069	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0006c	77 7d		 ja	 SHORT $LN187@assign
  0006e	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00071	73 19		 jae	 SHORT $LN63@assign
  00073	ff 76 10	 push	 DWORD PTR [esi+16]
  00076	8b ce		 mov	 ecx, esi
  00078	57		 push	 edi
  00079	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0007e	85 ff		 test	 edi, edi
  00080	74 60		 je	 SHORT $LN181@assign
$LN186@assign:

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  00082	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00086	72 2b		 jb	 SHORT $LN158@assign
  00088	8b 06		 mov	 eax, DWORD PTR [esi]
  0008a	eb 29		 jmp	 SHORT $LN159@assign

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN63@assign:
  0008c	85 ff		 test	 edi, edi
  0008e	75 f2		 jne	 SHORT $LN186@assign
  00090	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00094	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00097	72 0e		 jb	 SHORT $LN140@assign
  00099	8b 06		 mov	 eax, DWORD PTR [esi]
  0009b	5f		 pop	 edi
  0009c	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1175 : 			}
; 1176 : 		return (*this);

  0009f	8b c6		 mov	 eax, esi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx

; 1177 : 		}

  000a3	5d		 pop	 ebp
  000a4	c2 08 00	 ret	 8

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN140@assign:
  000a7	8b c6		 mov	 eax, esi
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1177 : 		}

  000af	5d		 pop	 ebp
  000b0	c2 08 00	 ret	 8

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

$LN158@assign:
  000b3	8b c6		 mov	 eax, esi
$LN159@assign:
  000b5	85 ff		 test	 edi, edi
  000b7	74 0b		 je	 SHORT $LN165@assign
  000b9	57		 push	 edi
  000ba	53		 push	 ebx
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN165@assign:

; 1174 : 			_Eos(_Count);

  000c4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000c8	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000cb	72 0f		 jb	 SHORT $LN176@assign
  000cd	8b 06		 mov	 eax, DWORD PTR [esi]
  000cf	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1175 : 			}
; 1176 : 		return (*this);

  000d3	8b c6		 mov	 eax, esi
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx

; 1177 : 		}

  000d8	5d		 pop	 ebp
  000d9	c2 08 00	 ret	 8

; 1174 : 			_Eos(_Count);

$LN176@assign:
  000dc	8b c6		 mov	 eax, esi
  000de	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN181@assign:

; 1175 : 			}
; 1176 : 		return (*this);

  000e2	5f		 pop	 edi
  000e3	8b c6		 mov	 eax, esi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 1177 : 		}

  000e7	5d		 pop	 ebp
  000e8	c2 08 00	 ret	 8
$LN187@assign:

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f0	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN189@assign:
$LN184@assign:
  000f5	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1150 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 e9 00 00
	00		 jb	 $LN208@assign

; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00019	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
  0001c	2b c1		 sub	 eax, ecx
  0001e	3b f8		 cmp	 edi, eax
  00020	0f 47 f8	 cmova	 edi, eax

; 1152 : 
; 1153 : 		if (this == &_Right)

  00023	3b f3		 cmp	 esi, ebx
  00025	75 47		 jne	 SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  0002d	0f 82 d9 00 00
	00		 jb	 $LN210@assign
  00033	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00036	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0003a	72 19		 jb	 SHORT $LN63@assign
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	51		 push	 ecx
  0003f	6a 00		 push	 0
  00041	8b ce		 mov	 ecx, esi
  00043	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
  00047	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0004c	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  0004d	8b c6		 mov	 eax, esi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx

; 1162 : 		}

  00051	5d		 pop	 ebp
  00052	c2 0c 00	 ret	 12			; 0000000cH

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

$LN63@assign:
  00055	8b d6		 mov	 edx, esi
  00057	51		 push	 ecx
  00058	6a 00		 push	 0
  0005a	8b ce		 mov	 ecx, esi
  0005c	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
  00060	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00065	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  00066	8b c6		 mov	 eax, esi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 1162 : 		}

  0006a	5d		 pop	 ebp
  0006b	c2 0c 00	 ret	 12			; 0000000cH
$LN2@assign:

; 1155 : 		else if (_Grow(_Count))

  0006e	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00071	0f 87 9f 00 00
	00		 ja	 $LN211@assign
  00077	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0007a	73 24		 jae	 SHORT $LN72@assign
  0007c	ff 76 10	 push	 DWORD PTR [esi+16]
  0007f	8b ce		 mov	 ecx, esi
  00081	57		 push	 edi
  00082	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00087	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0008a	85 ff		 test	 edi, edi
  0008c	74 6b		 je	 SHORT $LN203@assign
$LN207@assign:

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

  0008e	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00092	72 02		 jb	 SHORT $LN166@assign
  00094	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN166@assign:
  00096	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0009a	72 2b		 jb	 SHORT $LN180@assign
  0009c	8b 16		 mov	 edx, DWORD PTR [esi]
  0009e	eb 29		 jmp	 SHORT $LN181@assign

; 1155 : 		else if (_Grow(_Count))

$LN72@assign:
  000a0	85 ff		 test	 edi, edi
  000a2	75 ea		 jne	 SHORT $LN207@assign
  000a4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000a8	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ab	72 0e		 jb	 SHORT $LN149@assign
  000ad	8b 06		 mov	 eax, DWORD PTR [esi]
  000af	5f		 pop	 edi
  000b0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1160 : 			}
; 1161 : 		return (*this);

  000b3	8b c6		 mov	 eax, esi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx

; 1162 : 		}

  000b7	5d		 pop	 ebp
  000b8	c2 0c 00	 ret	 12			; 0000000cH

; 1155 : 		else if (_Grow(_Count))

$LN149@assign:
  000bb	8b c6		 mov	 eax, esi
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1162 : 		}

  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

$LN180@assign:
  000c7	8b d6		 mov	 edx, esi
$LN181@assign:
  000c9	85 ff		 test	 edi, edi
  000cb	74 0e		 je	 SHORT $LN187@assign
  000cd	57		 push	 edi
  000ce	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  000d1	50		 push	 eax
  000d2	52		 push	 edx
  000d3	e8 00 00 00 00	 call	 _memcpy
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN187@assign:

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

  000db	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000df	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000e2	72 0f		 jb	 SHORT $LN198@assign
  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1160 : 			}
; 1161 : 		return (*this);

  000ea	8b c6		 mov	 eax, esi
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx

; 1162 : 		}

  000ef	5d		 pop	 ebp
  000f0	c2 0c 00	 ret	 12			; 0000000cH

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

$LN198@assign:
  000f3	8b c6		 mov	 eax, esi
  000f5	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN203@assign:

; 1160 : 			}
; 1161 : 		return (*this);

  000f9	5f		 pop	 edi
  000fa	8b c6		 mov	 eax, esi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx

; 1162 : 		}

  000fe	5d		 pop	 ebp
  000ff	c2 0c 00	 ret	 12			; 0000000cH
$LN208@assign:

; 1150 : 		_Right._Check_offset(_Roff);

  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00107	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN212@assign:
$LN210@assign:

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  0010c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00111	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN213@assign:
$LN211@assign:

; 1155 : 		else if (_Grow(_Count))

  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN214@assign:
$LN205@assign:
  00120	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1143 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1144 : 		return (assign(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1111 : 		{	// append _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1112 : 		if (npos - this->_Mysize() <= _Count)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000e	8b c1		 mov	 eax, ecx
  00010	f7 d0		 not	 eax
  00012	3b c3		 cmp	 eax, ebx
  00014	76 7a		 jbe	 SHORT $LN141@append

; 1114 : 
; 1115 : 		const size_type _Num = this->_Mysize() + _Count;

  00016	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]

; 1116 : 		if (0 < _Count && _Grow(_Num))

  00019	85 db		 test	 ebx, ebx
  0001b	74 6a		 je	 SHORT $LN136@append
  0001d	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00020	77 78		 ja	 SHORT $LN143@append
  00022	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00025	73 33		 jae	 SHORT $LN28@append
  00027	51		 push	 ecx
  00028	57		 push	 edi
  00029	8b ce		 mov	 ecx, esi
  0002b	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00030	85 ff		 test	 edi, edi
  00032	74 53		 je	 SHORT $LN136@append
$LN140@append:

; 1117 : 			{	// make room and append new stuff using assign
; 1118 : 			_Chassign(this->_Mysize(), _Count, _Ch);

  00034	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  00037	8b ce		 mov	 ecx, esi
  00039	53		 push	 ebx
  0003a	ff 76 10	 push	 DWORD PTR [esi+16]
  0003d	e8 00 00 00 00	 call	 ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 1119 : 			_Eos(_Num);

  00042	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00046	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00049	72 36		 jb	 SHORT $LN131@append
  0004b	8b 06		 mov	 eax, DWORD PTR [esi]
  0004d	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1120 : 			}
; 1121 : 		return (*this);

  00051	8b c6		 mov	 eax, esi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx

; 1122 : 		}

  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8

; 1116 : 		if (0 < _Count && _Grow(_Num))

$LN28@append:
  0005a	85 ff		 test	 edi, edi
  0005c	75 d6		 jne	 SHORT $LN140@append
  0005e	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00061	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00065	72 0e		 jb	 SHORT $LN105@append
  00067	8b 06		 mov	 eax, DWORD PTR [esi]
  00069	5f		 pop	 edi
  0006a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1120 : 			}
; 1121 : 		return (*this);

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx

; 1122 : 		}

  00071	5d		 pop	 ebp
  00072	c2 08 00	 ret	 8

; 1116 : 		if (0 < _Count && _Grow(_Num))

$LN105@append:
  00075	8b c6		 mov	 eax, esi
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1122 : 		}

  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8

; 1119 : 			_Eos(_Num);

$LN131@append:
  00081	8b c6		 mov	 eax, esi
  00083	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN136@append:

; 1120 : 			}
; 1121 : 		return (*this);

  00087	5f		 pop	 edi
  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx

; 1122 : 		}

  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
$LN141@append:

; 1113 : 			_Xlen();	// result too long

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00095	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN144@append:
$LN143@append:

; 1116 : 		if (0 < _Count && _Grow(_Num))

  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0009f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN145@append:
$LN138@append:
  000a4	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1105 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN5@append
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00015	5e		 pop	 esi

; 1108 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

$LN5@append:
  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@append:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL7@append
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00031	5e		 pop	 esi

; 1108 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1087 : 		{	// append [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1088 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1089 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 57		 je	 SHORT $LN2@append
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN21@append
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN22@append
$LN21@append:
  0001a	8b c6		 mov	 eax, esi
$LN22@append:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 45		 jb	 SHORT $LN2@append
  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN35@append
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN36@append
$LN35@append:
  00029	8b d6		 mov	 edx, esi
$LN36@append:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	03 c2		 add	 eax, edx
  00030	3b c3		 cmp	 eax, ebx
  00032	76 31		 jbe	 SHORT $LN2@append

; 1090 : 			return (append(*this,

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 16		 jb	 SHORT $LN58@append
  00039	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	8b ce		 mov	 ecx, esi
  00040	2b d8		 sub	 ebx, eax
  00042	53		 push	 ebx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 1102 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8

; 1090 : 			return (append(*this,

$LN58@append:
  0004f	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00052	8b c6		 mov	 eax, esi
  00054	8b ce		 mov	 ecx, esi
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 1102 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN2@append:

; 1091 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1092 : 		if (npos - this->_Mysize() <= _Count)

  00065	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00068	8b c2		 mov	 eax, edx
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0006d	f7 d0		 not	 eax
  0006f	3b c1		 cmp	 eax, ecx
  00071	0f 86 98 00 00
	00		 jbe	 $LN217@append

; 1094 : 
; 1095 : 		const size_type _Num = this->_Mysize() + _Count;

  00077	57		 push	 edi
  00078	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 1096 : 		if (0 < _Count && _Grow(_Num))

  0007b	85 c9		 test	 ecx, ecx
  0007d	0f 84 83 00 00
	00		 je	 $LN211@append
  00083	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00086	0f 87 8d 00 00
	00		 ja	 $LN219@append
  0008c	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0008f	73 1a		 jae	 SHORT $LN85@append
  00091	52		 push	 edx
  00092	57		 push	 edi
  00093	8b ce		 mov	 ecx, esi
  00095	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0009d	85 ff		 test	 edi, edi
  0009f	74 65		 je	 SHORT $LN211@append
$LN216@append:

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

  000a1	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000a5	72 2b		 jb	 SHORT $LN179@append
  000a7	8b 16		 mov	 edx, DWORD PTR [esi]
  000a9	eb 29		 jmp	 SHORT $LN180@append

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN85@append:
  000ab	85 ff		 test	 edi, edi
  000ad	75 f2		 jne	 SHORT $LN216@append
  000af	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000b2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b6	72 0e		 jb	 SHORT $LN162@append
  000b8	8b 06		 mov	 eax, DWORD PTR [esi]
  000ba	5f		 pop	 edi
  000bb	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1100 : 			}
; 1101 : 		return (*this);

  000be	8b c6		 mov	 eax, esi
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx

; 1102 : 		}

  000c2	5d		 pop	 ebp
  000c3	c2 08 00	 ret	 8

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN162@append:
  000c6	8b c6		 mov	 eax, esi
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1102 : 		}

  000ce	5d		 pop	 ebp
  000cf	c2 08 00	 ret	 8

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

$LN179@append:
  000d2	8b d6		 mov	 edx, esi
$LN180@append:
  000d4	85 c9		 test	 ecx, ecx
  000d6	74 10		 je	 SHORT $LN195@append
  000d8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000db	51		 push	 ecx
  000dc	03 c2		 add	 eax, edx
  000de	53		 push	 ebx
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _memcpy
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN195@append:

; 1099 : 			_Eos(_Num);

  000e8	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000ec	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ef	72 0f		 jb	 SHORT $LN206@append
  000f1	8b 06		 mov	 eax, DWORD PTR [esi]
  000f3	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1100 : 			}
; 1101 : 		return (*this);

  000f7	8b c6		 mov	 eax, esi
  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx

; 1102 : 		}

  000fc	5d		 pop	 ebp
  000fd	c2 08 00	 ret	 8

; 1099 : 			_Eos(_Num);

$LN206@append:
  00100	8b c6		 mov	 eax, esi
  00102	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN211@append:

; 1100 : 			}
; 1101 : 		return (*this);

  00106	5f		 pop	 edi
  00107	8b c6		 mov	 eax, esi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx

; 1102 : 		}

  0010b	5d		 pop	 ebp
  0010c	c2 08 00	 ret	 8
$LN217@append:

; 1093 : 			_Xlen();	// result too long

  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00114	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN220@append:
$LN219@append:

; 1096 : 		if (0 < _Count && _Grow(_Num))

  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN221@append:
$LN214@append:
  00123	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1071 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 c0 00 00
	00		 jb	 $LN201@append

; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

  00019	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0001c	2b c1		 sub	 eax, ecx
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00021	3b c8		 cmp	 ecx, eax
  00023	0f 47 c8	 cmova	 ecx, eax
  00026	8b c2		 mov	 eax, edx
  00028	f7 d0		 not	 eax
  0002a	89 4d 10	 mov	 DWORD PTR __Count$[ebp], ecx
  0002d	3b c1		 cmp	 eax, ecx
  0002f	0f 86 ae 00 00
	00		 jbe	 $LN203@append

; 1075 : 
; 1076 : 		const size_type _Num = this->_Mysize() + _Count;

  00035	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 1077 : 		if (0 < _Count && _Grow(_Num))

  00038	85 c9		 test	 ecx, ecx
  0003a	0f 84 90 00 00
	00		 je	 $LN196@append
  00040	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00043	0f 87 a4 00 00
	00		 ja	 $LN204@append
  00049	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0004c	73 22		 jae	 SHORT $LN56@append
  0004e	52		 push	 edx
  0004f	57		 push	 edi
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00057	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005a	85 ff		 test	 edi, edi
  0005c	74 72		 je	 SHORT $LN196@append
$LN200@append:

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

  0005e	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00062	72 02		 jb	 SHORT $LN150@append
  00064	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN150@append:
  00066	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0006a	72 2b		 jb	 SHORT $LN164@append
  0006c	8b 16		 mov	 edx, DWORD PTR [esi]
  0006e	eb 29		 jmp	 SHORT $LN165@append

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN56@append:
  00070	85 ff		 test	 edi, edi
  00072	75 ea		 jne	 SHORT $LN200@append
  00074	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00077	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0007b	72 0e		 jb	 SHORT $LN133@append
  0007d	8b 06		 mov	 eax, DWORD PTR [esi]
  0007f	5f		 pop	 edi
  00080	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1082 : 			}
; 1083 : 		return (*this);

  00083	8b c6		 mov	 eax, esi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx

; 1084 : 		}

  00087	5d		 pop	 ebp
  00088	c2 0c 00	 ret	 12			; 0000000cH

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN133@append:
  0008b	8b c6		 mov	 eax, esi
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1084 : 		}

  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

$LN164@append:
  00097	8b d6		 mov	 edx, esi
$LN165@append:
  00099	85 c9		 test	 ecx, ecx
  0009b	74 15		 je	 SHORT $LN180@append
  0009d	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  000a0	03 c3		 add	 eax, ebx
  000a2	51		 push	 ecx
  000a3	50		 push	 eax
  000a4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000a7	03 c2		 add	 eax, edx
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _memcpy
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN180@append:

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

  000b2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b6	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000b9	72 0f		 jb	 SHORT $LN191@append
  000bb	8b 06		 mov	 eax, DWORD PTR [esi]
  000bd	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1082 : 			}
; 1083 : 		return (*this);

  000c1	8b c6		 mov	 eax, esi
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx

; 1084 : 		}

  000c6	5d		 pop	 ebp
  000c7	c2 0c 00	 ret	 12			; 0000000cH

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

$LN191@append:
  000ca	8b c6		 mov	 eax, esi
  000cc	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN196@append:

; 1082 : 			}
; 1083 : 		return (*this);

  000d0	5f		 pop	 edi
  000d1	8b c6		 mov	 eax, esi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx

; 1084 : 		}

  000d5	5d		 pop	 ebp
  000d6	c2 0c 00	 ret	 12			; 0000000cH
$LN201@append:

; 1071 : 		_Right._Check_offset(_Roff);

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000de	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN205@append:
$LN203@append:

; 1074 : 			_Xlen();	// result too long

  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000e8	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN206@append:
$LN204@append:

; 1077 : 		if (0 < _Count && _Grow(_Num))

  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f2	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN207@append:
$LN198@append:
  000f7	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1064 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1065 : 		return (append(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1066 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1039 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1040 : 		return (assign(_Ptr));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN7@operator
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00015	5e		 pop	 esi

; 1041 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1040 : 		return (assign(_Ptr));

$LN7@operator:
  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL9@operator:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL9@operator
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00031	5e		 pop	 esi

; 1041 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1023 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1024 : 		if (this != &_Right)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b f0		 cmp	 esi, eax
  0000b	74 0a		 je	 SHORT $LN132@operator

; 1025 : 			{	// different, assign it
; 1026 : 			if (this->_Getal() != _Right._Getal()
; 1027 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1028 : 				{	// change allocator before copying
; 1029 : 				_Tidy(true);
; 1030 : 				this->_Copy_alloc(_Right._Getal());
; 1031 : 				}
; 1032 : 
; 1033 : 			assign(_Right);

  0000d	6a ff		 push	 -1
  0000f	6a 00		 push	 0
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN132@operator:

; 1034 : 			}
; 1035 : 		return (*this);

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi

; 1036 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1017 : 		_Tidy(true);

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 10	 cmp	 eax, 16			; 00000010H
  00009	72 09		 jb	 SHORT $LN6@basic_stri
  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN6@basic_stri:
  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	72 07		 jb	 SHORT $LN94@basic_stri
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	5e		 pop	 esi
  0002b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1018 : 		}

  0002e	c3		 ret	 0

; 1017 : 		_Tidy(true);

$LN94@basic_stri:
  0002f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00032	5e		 pop	 esi

; 1018 : 		}

  00033	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 961  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0000e	73 15		 jae	 SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	83 c0 01	 add	 eax, 1
  00016	74 1b		 je	 SHORT $LN3@Assign_rv
  00018	50		 push	 eax
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 964  : 				_Right._Mysize() + 1);
; 965  : 		else

  00023	eb 0e		 jmp	 SHORT $LN3@Assign_rv
$LN2@Assign_rv:

; 966  : 			{	// copy pointer
; 967  : 			this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Right._Bx()._Ptr);

  00025	85 ff		 test	 edi, edi
  00027	74 04		 je	 SHORT $LN84@Assign_rv
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	89 07		 mov	 DWORD PTR [edi], eax
$LN84@Assign_rv:

; 968  : 			_Right._Bx()._Ptr = pointer();

  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

  00039	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0003c	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 972  : 		_Right._Tidy();

  0003f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00046	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0004a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00051	72 0b		 jb	 SHORT $LN227@Assign_rv
  00053	8b 06		 mov	 eax, DWORD PTR [esi]
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	c6 00 00	 mov	 BYTE PTR [eax], 0

; 973  : 		}

  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4

; 972  : 		_Right._Tidy();

$LN227@Assign_rv:
  0005e	5f		 pop	 edi
  0005f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00062	5e		 pop	 esi

; 973  : 		}

  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 946  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 947  : 		if (this == &_Right)

  00025	3b 75 08	 cmp	 esi, DWORD PTR __Right$[ebp]
  00028	74 38		 je	 SHORT $LN275@assign

; 948  : 			;
; 949  : 		else if (get_allocator() != _Right.get_allocator()
; 950  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 951  : 			*this = _Right;
; 952  : 		else
; 953  : 			{	// not same, clear this and steal from _Right
; 954  : 			_Tidy(true);

  0002a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00030	72 09		 jb	 SHORT $LN177@assign
  00032	40		 inc	 eax
  00033	50		 push	 eax
  00034	ff 36		 push	 DWORD PTR [esi]
  00036	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN177@assign:
  0003b	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00042	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00046	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004d	72 04		 jb	 SHORT $LN265@assign
  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	eb 02		 jmp	 SHORT $LN266@assign
$LN265@assign:
  00053	8b c6		 mov	 eax, esi
$LN266@assign:

; 955  : 			_Assign_rv(_STD forward<_Myt>(_Right));

  00055	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00058	8b ce		 mov	 ecx, esi
  0005a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0005d	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN275@assign:

; 956  : 			}
; 957  : 		return (*this);

  00062	8b c6		 mov	 eax, esi

; 958  : 		}

  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5e		 pop	 esi
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 928  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 929  : 		if (this != &_Right)

  00025	3b 75 08	 cmp	 esi, DWORD PTR __Right$[ebp]
  00028	74 38		 je	 SHORT $LN294@operator

; 930  : 			{	// different, assign it
; 931  : 			_Tidy(true);

  0002a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00030	72 09		 jb	 SHORT $LN10@operator
  00032	40		 inc	 eax
  00033	50		 push	 eax
  00034	ff 36		 push	 DWORD PTR [esi]
  00036	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN10@operator:
  0003b	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00042	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00046	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004d	72 04		 jb	 SHORT $LN98@operator
  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	eb 02		 jmp	 SHORT $LN99@operator
$LN98@operator:
  00053	8b c6		 mov	 eax, esi
$LN99@operator:

; 932  : 
; 933  : 			if (_Alty::propagate_on_container_move_assignment::value
; 934  : 				&& this->_Getal() != _Right._Getal())
; 935  : 				this->_Move_alloc(_Right._Getal());
; 936  : 
; 937  : 			if (this->_Getal() != _Right._Getal())
; 938  : 				assign(_Right.begin(), _Right.end());
; 939  : 			else
; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

  00055	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00058	8b ce		 mov	 ecx, esi
  0005a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0005d	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN294@operator:

; 941  : 			}
; 942  : 		return (*this);

  00062	8b c6		 mov	 eax, esi

; 943  : 		}

  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5e		 pop	 esi
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 911  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 912  : 		_Tidy();
; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00004	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00017	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001a	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 914  : 		}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 850  : 		{	// construct from _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 851  : 		_Tidy();
; 852  : 		assign(_Count, _Ch);

  00004	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  0000c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00013	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001a	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 853  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00017	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001a	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0001d	75 12		 jne	 SHORT $LN111@basic_stri
  0001f	33 d2		 xor	 edx, edx
  00021	52		 push	 edx
  00022	51		 push	 ecx
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 839  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

$LN111@basic_stri:
  00031	8b d1		 mov	 edx, ecx
  00033	57		 push	 edi
  00034	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL113@basic_stri:
  00037	8a 02		 mov	 al, BYTE PTR [edx]
  00039	42		 inc	 edx
  0003a	84 c0		 test	 al, al
  0003c	75 f9		 jne	 SHORT $LL113@basic_stri
  0003e	2b d7		 sub	 edx, edi
  00040	5f		 pop	 edi
  00041	52		 push	 edx
  00042	51		 push	 ecx
  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 839  : 		}

  0004a	8b c6		 mov	 eax, esi
  0004c	5e		 pop	 esi
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 822  : 		{	// construct from [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 823  : 		_Tidy();
; 824  : 		assign(_Ptr, _Count);

  00004	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00013	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001a	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 825  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$ = 20						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 815  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 816  : 		_Tidy();
; 817  : 		assign(_Right, _Roff, _Count);

  00004	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 0c	 push	 DWORD PTR __Roff$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00016	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001d	c6 06 00	 mov	 BYTE PTR [esi], 0
  00020	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 818  : 		}

  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 10 00	 ret	 16			; 00000010H
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 795  : 		_Tidy();

  00000	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 796  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00013	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 781  : 		_Tidy();
; 782  : 		assign(_Right, 0, npos);

  00006	6a ff		 push	 -1
  00008	6a 00		 push	 0
  0000a	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00014	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 783  : 		}

  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 735  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 730  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 725  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

  00000	8b c1		 mov	 eax, ecx

; 715  : 		}

  00002	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 708  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 703  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 698  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 693  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc, COMDAT
; _this$ = ecx

; 607  : 		_Pocma(_Getal(), _Al);
; 608  : 		}

  00000	c2 04 00	 ret	 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 602  : 		_Pocca(_Getal(), _Al);
; 603  : 		}

  00000	c2 04 00	 ret	 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 588  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 590  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 583  : 		return (_Get_data()._Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 584  : 		}

  00008	c3		 ret	 0

; 583  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 584  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 578  : 		return (_Get_data()._Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 579  : 		}

  00008	c3		 ret	 0

; 578  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 579  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 534  : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 499  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	83 c8 ff	 or	 eax, -1

; 1009 : 		}

  00003	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000d	72 19		 jb	 SHORT $LN7@deallocate
  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $LN16@deallocate
  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00016	3b c8		 cmp	 ecx, eax
  00018	73 20		 jae	 SHORT $LN18@deallocate
  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 1e		 jb	 SHORT $LN19@deallocate
  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 1e		 ja	 SHORT $LN20@deallocate
  00026	8b c1		 mov	 eax, ecx
$LN7@deallocate:
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 988  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00035	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN18@deallocate:
  0003a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN19@deallocate:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN20@deallocate:
  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN15@deallocate:
  00049	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 976  : 		return (_Mybase::allocate(_Count));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN6@allocate
$LN15@allocate:

; 977  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 976  : 		return (_Mybase::allocate(_Count));

$LN6@allocate:
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 23		 jb	 SHORT $LN8@allocate
  00015	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00018	3b c8		 cmp	 ecx, eax
  0001a	76 2b		 jbe	 SHORT $LN17@allocate
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	8b c8		 mov	 ecx, eax
  00024	83 c4 04	 add	 esp, 4
  00027	85 c9		 test	 ecx, ecx
  00029	74 21		 je	 SHORT $LN19@allocate
  0002b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002e	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00031	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 977  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4

; 976  : 		return (_Mybase::allocate(_Count));

$LN8@allocate:
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 c5		 jne	 SHORT $LN15@allocate
  00045	eb 0a		 jmp	 SHORT $LN20@allocate
$LN17@allocate:
  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN21@allocate:
$LN19@allocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN20@allocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@allocate:
$LN16@allocate:
  00056	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 963  : 		_Mybase::operator=(_STD move(_Right));
; 964  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 965  : 		}

  00002	c2 04 00	 ret	 4
??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::address, COMDAT
; _this$ = ecx

; 925  : 		{	// return address of mutable _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 926  : 		return (pointer_traits<pointer>::pointer_to(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 927  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	83 c8 ff	 or	 eax, -1

; 870  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	83 c8 ff	 or	 eax, -1

; 750  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 23		 jb	 SHORT $LN6@allocate
  00015	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00018	3b c8		 cmp	 ecx, eax
  0001a	76 2b		 jbe	 SHORT $LN14@allocate
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	8b c8		 mov	 ecx, eax
  00024	83 c4 04	 add	 esp, 4
  00027	85 c9		 test	 ecx, ecx
  00029	74 21		 je	 SHORT $LN16@allocate
  0002b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002e	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00031	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 c5		 jne	 SHORT $LN12@allocate
  00045	eb 0a		 jmp	 SHORT $LN17@allocate
$LN14@allocate:
  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN18@allocate:
$LN16@allocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@allocate:
$LN17@allocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@allocate:
$LN13@allocate:
  00056	cc		 int	 3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000d	72 19		 jb	 SHORT $LN5@deallocate
  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $LN13@deallocate
  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00016	3b c8		 cmp	 ecx, eax
  00018	73 20		 jae	 SHORT $LN15@deallocate
  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 1e		 jb	 SHORT $LN16@deallocate
  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 1e		 ja	 SHORT $LN17@deallocate
  00026	8b c1		 mov	 eax, ecx
$LN5@deallocate:
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 721  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00035	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
$LN15@deallocate:
  0003a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN16@deallocate:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN17@deallocate:
  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN12@deallocate:
  00049	cc		 int	 3
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xatomic0.h
;	COMDAT ?_Init_atomic_counter@std@@YAXAAKK@Z
_TEXT	SEGMENT
__Counter$ = 8						; size = 4
__Value$ = 12						; size = 4
?_Init_atomic_counter@std@@YAXAAKK@Z PROC		; std::_Init_atomic_counter, COMDAT

; 62   : 	{	// non-atomically initialize counter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	_Counter = _Value;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Counter$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Value$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 64   : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?_Init_atomic_counter@std@@YAXAAKK@Z ENDP		; std::_Init_atomic_counter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 95   : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 133  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	void *_Ptr = 0;
; 50   : 
; 51   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 56   : 		_Xbad_alloc();	// report no memory
; 57   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 66   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 67   : 			_Xbad_alloc();	// report no memory
; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else
; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ
_TEXT	SEGMENT
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ PROC ; std::_Iterator_base0::_Getcont, COMDAT
; _this$ = ecx

; 59   : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 60   : 		}

  00002	c3		 ret	 0
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ENDP ; std::_Iterator_base0::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z PROC	; std::_Container_base0::_Swap_all, COMDAT
; _this$ = ecx

; 48   : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z ENDP	; std::_Container_base0::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 606  : 		return (EOF);

  00000	83 c8 ff	 or	 eax, -1

; 607  : 		}

  00003	c3		 ret	 0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?not_eof@?$char_traits@D@std@@SAHABH@Z PROC		; std::char_traits<char>::not_eof, COMDAT

; 600  : 		{	// return anything but EOF

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 601  : 		return (_Meta != eof() ? _Meta : !eof());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	33 c0		 xor	 eax, eax
  0000a	83 f9 ff	 cmp	 ecx, -1
  0000d	0f 45 c1	 cmovne	 eax, ecx

; 602  : 		}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?not_eof@?$char_traits@D@std@@SAHABH@Z ENDP		; std::char_traits<char>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 594  : 		{	// test for metacharacter equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000d	0f 94 c0	 sete	 al

; 595  : 		return (_Left == _Right);
; 596  : 		}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT

; 588  : 		{	// convert character to metacharacter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 589  : 		return ((unsigned char)_Ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00006	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 590  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT

; 582  : 		{	// convert metacharacter to character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 583  : 		return ((_Elem)_Meta);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00006	8a 00		 mov	 al, BYTE PTR [eax]

; 584  : 		}

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq@?$char_traits@D@std@@SA_NABD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq@?$char_traits@D@std@@SA_NABD0@Z PROC		; std::char_traits<char>::eq, COMDAT

; 570  : 		{	// test for element equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000b	3a 08		 cmp	 cl, BYTE PTR [eax]
  0000d	0f 94 c0	 sete	 al

; 571  : 		return (_Left == _Right);
; 572  : 		}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?eq@?$char_traits@D@std@@SA_NABD0@Z ENDP		; std::char_traits<char>::eq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 564  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 565  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000b	88 08		 mov	 BYTE PTR [eax], cl

; 566  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 559  : 		{	// assign _Count * _Ch to [_First, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00003	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00006	0f be 45 10	 movsx	 eax, BYTE PTR __Ch$[ebp]
  0000a	50		 push	 eax
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 _memset
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 561  : 		}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 552  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 553  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@move
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@move:

; 553  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  00012	5d		 pop	 ebp

; 553  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?find@?$char_traits@D@std@@SAPBDPBDIABD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 4
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z PROC		; std::char_traits<char>::find, COMDAT

; 545  : 		{	// look for _Ch in [_First, _First + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 546  : 		return (_Count == 0 ? (const _Elem *)0

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN3@find

; 547  : 			: (const _Elem *)_CSTD memchr(_First, _Ch, _Count));
; 548  : 		}

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN3@find:

; 546  : 		return (_Count == 0 ? (const _Elem *)0

  0000c	50		 push	 eax
  0000d	8b 45 10	 mov	 eax, DWORD PTR __Ch$[ebp]
  00010	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00017	e8 00 00 00 00	 call	 _memchr
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 547  : 			: (const _Elem *)_CSTD memchr(_First, _Ch, _Count));
; 548  : 		}

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z ENDP		; std::char_traits<char>::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 530  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 530  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  00012	5d		 pop	 ebp

; 530  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 522  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 523  : 		return (*_First == 0 ? 0

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	80 38 00	 cmp	 BYTE PTR [eax], 0
  00009	75 04		 jne	 SHORT $LN3@length
  0000b	33 c0		 xor	 eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

  0000f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL5@length:
  00012	8a 08		 mov	 cl, BYTE PTR [eax]
  00014	40		 inc	 eax
  00015	84 c9		 test	 cl, cl
  00017	75 f9		 jne	 SHORT $LL5@length
  00019	2b c2		 sub	 eax, edx

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC		; std::char_traits<char>::compare, COMDAT

; 516  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 517  : 		return (_Count == 0 ? 0

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN3@compare
  0000a	33 c0		 xor	 eax, eax

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN3@compare:

; 517  : 		return (_Count == 0 ? 0

  0000e	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00011	56		 push	 esi
  00012	8b 75 0c	 mov	 esi, DWORD PTR __First2$[ebp]
  00015	83 e9 04	 sub	 ecx, 4
  00018	72 17		 jb	 SHORT $LN7@compare
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL8@compare:
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	3b 06		 cmp	 eax, DWORD PTR [esi]
  00024	75 10		 jne	 SHORT $LN6@compare
  00026	83 c2 04	 add	 edx, 4
  00029	83 c6 04	 add	 esi, 4
  0002c	83 e9 04	 sub	 ecx, 4
  0002f	73 ef		 jae	 SHORT $LL8@compare
$LN7@compare:
  00031	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00034	74 35		 je	 SHORT $LN5@compare
$LN6@compare:
  00036	8a 02		 mov	 al, BYTE PTR [edx]
  00038	3a 06		 cmp	 al, BYTE PTR [esi]
  0003a	75 27		 jne	 SHORT $LN9@compare
  0003c	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  0003f	74 2a		 je	 SHORT $LN5@compare
  00041	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00044	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00047	75 1a		 jne	 SHORT $LN9@compare
  00049	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0004c	74 1d		 je	 SHORT $LN5@compare
  0004e	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00051	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00054	75 0d		 jne	 SHORT $LN9@compare
  00056	83 f9 ff	 cmp	 ecx, -1
  00059	74 10		 je	 SHORT $LN5@compare
  0005b	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  0005e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00061	74 08		 je	 SHORT $LN5@compare
$LN9@compare:
  00063	1b c0		 sbb	 eax, eax
  00065	83 c8 01	 or	 eax, 1
  00068	5e		 pop	 esi

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
$LN5@compare:

; 517  : 		return (_Count == 0 ? 0

  0006b	33 c0		 xor	 eax, eax
  0006d	5e		 pop	 esi

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@_W@std@@SAGXZ
_TEXT	SEGMENT
?eof@?$char_traits@_W@std@@SAGXZ PROC			; std::char_traits<wchar_t>::eof, COMDAT

; 386  : 		return (WEOF);

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 387  : 		}

  00005	c3		 ret	 0
?eof@?$char_traits@_W@std@@SAGXZ ENDP			; std::char_traits<wchar_t>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@_W@std@@SAGABG@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?not_eof@?$char_traits@_W@std@@SAGABG@Z PROC		; std::char_traits<wchar_t>::not_eof, COMDAT

; 380  : 		{	// return anything but EOF

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 381  : 		return (_Meta != eof() ? _Meta : !eof());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00006	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0000b	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0000e	66 3b c1	 cmp	 ax, cx
  00011	75 02		 jne	 SHORT $LN4@not_eof
  00013	33 c0		 xor	 eax, eax
$LN4@not_eof:

; 382  : 		}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?not_eof@?$char_traits@_W@std@@SAGABG@Z ENDP		; std::char_traits<wchar_t>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z PROC	; std::char_traits<wchar_t>::eq_int_type, COMDAT

; 374  : 		{	// test for metacharacter equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	66 8b 08	 mov	 cx, WORD PTR [eax]
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	66 3b 08	 cmp	 cx, WORD PTR [eax]
  0000f	0f 94 c0	 sete	 al

; 375  : 		return (_Left == _Right);
; 376  : 		}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z ENDP	; std::char_traits<wchar_t>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z PROC	; std::char_traits<wchar_t>::to_int_type, COMDAT

; 368  : 		{	// convert character to metacharacter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  : 		return (_Ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00006	66 8b 00	 mov	 ax, WORD PTR [eax]

; 370  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z ENDP	; std::char_traits<wchar_t>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@_W@std@@SA_WABG@Z PROC	; std::char_traits<wchar_t>::to_char_type, COMDAT

; 362  : 		{	// convert metacharacter to character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 363  : 		return (_Meta);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00006	66 8b 00	 mov	 ax, WORD PTR [eax]

; 364  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?to_char_type@?$char_traits@_W@std@@SA_WABG@Z ENDP	; std::char_traits<wchar_t>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq@?$char_traits@_W@std@@SA_NAB_W0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq@?$char_traits@_W@std@@SA_NAB_W0@Z PROC		; std::char_traits<wchar_t>::eq, COMDAT

; 350  : 		{	// test for element equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	66 8b 08	 mov	 cx, WORD PTR [eax]
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	66 3b 08	 cmp	 cx, WORD PTR [eax]
  0000f	0f 94 c0	 sete	 al

; 351  : 		return (_Left == _Right);
; 352  : 		}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?eq@?$char_traits@_W@std@@SA_NAB_W0@Z ENDP		; std::char_traits<wchar_t>::eq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 344  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 345  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	66 8b 08	 mov	 cx, WORD PTR [eax]
  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	66 89 08	 mov	 WORD PTR [eax], cx

; 346  : 		}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAPA_WPA_WI_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 2
?assign@?$char_traits@_W@std@@SAPA_WPA_WI_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 339  : 		{	// assign _Count * _Ch to [_First, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 340  : 		return ((_Elem *)_CSTD wmemset(_First, _Ch, _Count));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1b		 je	 SHORT $LN12@assign
  0000a	8b 45 10	 mov	 eax, DWORD PTR __Ch$[ebp]
  0000d	0f b7 d0	 movzx	 edx, ax
  00010	8b c2		 mov	 eax, edx
  00012	c1 e2 10	 shl	 edx, 16			; 00000010H
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00019	0b c2		 or	 eax, edx
  0001b	d1 e9		 shr	 ecx, 1
  0001d	f3 ab		 rep stosd
  0001f	13 c9		 adc	 ecx, ecx
  00021	66 f3 ab	 rep stosw
  00024	5f		 pop	 edi
$LN12@assign:
  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 341  : 		}

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?assign@?$char_traits@_W@std@@SAPA_WPA_WI_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z PROC	; std::char_traits<wchar_t>::move, COMDAT

; 332  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 333  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@move
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 334  : 			: (_Elem *)_CSTD wmemmove(_First1, _First2, _Count));
; 335  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@move:

; 333  : 		return (_Count == 0 ? _First1

  0000f	03 c0		 add	 eax, eax
  00011	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 334  : 			: (_Elem *)_CSTD wmemmove(_First1, _First2, _Count));
; 335  : 		}

  00014	5d		 pop	 ebp

; 333  : 		return (_Count == 0 ? _First1

  00015	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ENDP	; std::char_traits<wchar_t>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?find@?$char_traits@_W@std@@SAPB_WPB_WIAB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 4
?find@?$char_traits@_W@std@@SAPB_WPB_WIAB_W@Z PROC	; std::char_traits<wchar_t>::find, COMDAT

; 325  : 		{	// look for _Ch in [_First, _First + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 326  : 		return (_Count == 0 ? (const _Elem *)0

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 16		 je	 SHORT $LN7@find
  0000a	8b 45 10	 mov	 eax, DWORD PTR __Ch$[ebp]
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	0f b7 00	 movzx	 eax, WORD PTR [eax]
$LL8@find:
  00013	66 39 01	 cmp	 WORD PTR [ecx], ax
  00016	74 0c		 je	 SHORT $LN12@find
  00018	83 c1 02	 add	 ecx, 2
  0001b	83 ea 01	 sub	 edx, 1
  0001e	75 f3		 jne	 SHORT $LL8@find
$LN7@find:
  00020	33 c0		 xor	 eax, eax

; 327  : 			: (const _Elem *)_CSTD wmemchr(_First, _Ch, _Count));
; 328  : 		}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
$LN12@find:

; 326  : 		return (_Count == 0 ? (const _Elem *)0

  00024	8b c1		 mov	 eax, ecx

; 327  : 			: (const _Elem *)_CSTD wmemchr(_First, _Ch, _Count));
; 328  : 		}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?find@?$char_traits@_W@std@@SAPB_WPB_WIAB_W@Z ENDP	; std::char_traits<wchar_t>::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z PROC	; std::char_traits<wchar_t>::copy, COMDAT

; 309  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 310  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 311  : 			: (_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));
; 312  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 310  : 		return (_Count == 0 ? _First1

  0000f	03 c0		 add	 eax, eax
  00011	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 311  : 			: (_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));
; 312  : 		}

  00014	5d		 pop	 ebp

; 310  : 		return (_Count == 0 ? _First1

  00015	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ENDP	; std::char_traits<wchar_t>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@_W@std@@SAIPB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@_W@std@@SAIPB_W@Z PROC		; std::char_traits<wchar_t>::length, COMDAT

; 302  : 		{	// find length of null-terminated sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 303  : 		return (*_First == 0 ? 0

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	66 83 38 00	 cmp	 WORD PTR [eax], 0
  0000a	75 04		 jne	 SHORT $LN3@length
  0000c	33 c0		 xor	 eax, eax

; 304  : 			: _CSTD wcslen(_First));
; 305  : 		}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN3@length:

; 303  : 		return (*_First == 0 ? 0

  00010	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
$LL5@length:
  00013	66 8b 08	 mov	 cx, WORD PTR [eax]
  00016	83 c0 02	 add	 eax, 2
  00019	66 85 c9	 test	 cx, cx
  0001c	75 f5		 jne	 SHORT $LL5@length
  0001e	2b c2		 sub	 eax, edx
  00020	d1 f8		 sar	 eax, 1

; 304  : 			: _CSTD wcslen(_First));
; 305  : 		}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?length@?$char_traits@_W@std@@SAIPB_W@Z ENDP		; std::char_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@_W@std@@SAHPB_W0I@Z PROC		; std::char_traits<wchar_t>::compare, COMDAT

; 296  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 297  : 		return (_Count == 0 ? 0

  00004	8b 75 10	 mov	 esi, DWORD PTR __Count$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 19		 je	 SHORT $LN7@compare
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  0000e	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
$LL8@compare:
  00011	66 8b 02	 mov	 ax, WORD PTR [edx]
  00014	66 3b 01	 cmp	 ax, WORD PTR [ecx]
  00017	75 10		 jne	 SHORT $LN12@compare
  00019	83 c2 02	 add	 edx, 2
  0001c	83 c1 02	 add	 ecx, 2
  0001f	83 ee 01	 sub	 esi, 1
  00022	75 ed		 jne	 SHORT $LL8@compare
$LN7@compare:
  00024	33 c0		 xor	 eax, eax
  00026	5e		 pop	 esi

; 298  : 			: _CSTD wmemcmp(_First1, _First2, _Count));
; 299  : 		}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN12@compare:

; 297  : 		return (_Count == 0 ? 0

  00029	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0002c	66 3b 01	 cmp	 ax, WORD PTR [ecx]
  0002f	5e		 pop	 esi
  00030	1b c0		 sbb	 eax, eax
  00032	83 e0 fe	 and	 eax, -2			; fffffffeH
  00035	40		 inc	 eax

; 298  : 			: _CSTD wmemcmp(_First1, _First2, _Count));
; 299  : 		}

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?compare@?$char_traits@_W@std@@SAHPB_W0I@Z ENDP		; std::char_traits<wchar_t>::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1834 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1835 :         int _Result;
; 1836 :         va_list _ArgList;
; 1837 :         __crt_va_start(_ArgList, _Format);
; 1838 :         _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s
  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1839 :         __crt_va_end(_ArgList);
; 1840 :         return _Result;
; 1841 :     }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsprintf_s_l PROC					; COMDAT

; 1493 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1499 : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 94   :         return;
; 95   :     }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 89   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 90   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 85   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 68   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 60   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 61   :         _Data._What = _Message;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  0000f	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0
  00014	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 62   :     }

  00017	8b c1		 mov	 eax, ecx
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -8					; size = 8
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 53   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 54   :         __std_exception_data _InitData = { _Message, true };

  00006	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	56		 push	 esi
  0000d	8b f1		 mov	 esi, ecx
  0000f	89 45 f8	 mov	 DWORD PTR __InitData$[ebp], eax
  00012	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  00015	c6 45 fc 01	 mov	 BYTE PTR __InitData$[ebp+4], 1

; 55   :         __std_exception_copy(&_InitData, &_Data);

  00019	52		 push	 edx
  0001a	8d 45 f8	 lea	 eax, DWORD PTR __InitData$[ebp]
  0001d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00023	50		 push	 eax
  00024	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00028	e8 00 00 00 00	 call	 ___std_exception_copy
  0002d	83 c4 08	 add	 esp, 8

; 56   :     }

  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemset
_TEXT	SEGMENT
__S$ = 8						; size = 4
__C$ = 12						; size = 2
__N$ = 16						; size = 4
_wmemset PROC						; COMDAT

; 258  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 260  :         for (; 0 < _N; ++_Su, --_N)

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __N$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1b		 je	 SHORT $LN10@wmemset

; 259  :         wchar_t *_Su = _S;

  0000a	8b 45 0c	 mov	 eax, DWORD PTR __C$[ebp]
  0000d	0f b7 d0	 movzx	 edx, ax
  00010	8b c2		 mov	 eax, edx
  00012	c1 e2 10	 shl	 edx, 16			; 00000010H
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR __S$[ebp]
  00019	0b c2		 or	 eax, edx
  0001b	d1 e9		 shr	 ecx, 1
  0001d	f3 ab		 rep stosd
  0001f	13 c9		 adc	 ecx, ecx
  00021	66 f3 ab	 rep stosw
  00024	5f		 pop	 edi
$LN10@wmemset:

; 261  :         {
; 262  :             *_Su = _C;
; 263  :         }
; 264  :         return _S;

  00025	8b 45 08	 mov	 eax, DWORD PTR __S$[ebp]

; 265  :     }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
_wmemset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemmove
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemmove PROC						; COMDAT

; 244  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00006	03 c0		 add	 eax, eax
  00008	89 45 10	 mov	 DWORD PTR __N$[ebp], eax

; 248  :         #pragma warning(pop)
; 249  :     }

  0000b	5d		 pop	 ebp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  0000c	e9 00 00 00 00	 jmp	 _memmove
_wmemmove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 231  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00006	03 c0		 add	 eax, eax
  00008	89 45 10	 mov	 DWORD PTR __N$[ebp], eax

; 235  :         #pragma warning(pop)
; 236  :     }

  0000b	5d		 pop	 ebp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0000c	e9 00 00 00 00	 jmp	 _memcpy
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemcmp
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcmp PROC						; COMDAT

; 215  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

  00004	8b 75 10	 mov	 esi, DWORD PTR __N$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 19		 je	 SHORT $LN3@wmemcmp
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __S2$[ebp]
  0000e	8b 55 08	 mov	 edx, DWORD PTR __S1$[ebp]
$LL4@wmemcmp:

; 217  :             if (*_S1 != *_S2)

  00011	66 8b 02	 mov	 ax, WORD PTR [edx]
  00014	66 3b 01	 cmp	 ax, WORD PTR [ecx]
  00017	75 10		 jne	 SHORT $LN8@wmemcmp

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

  00019	83 c2 02	 add	 edx, 2
  0001c	83 c1 02	 add	 ecx, 2
  0001f	83 ee 01	 sub	 esi, 1
  00022	75 ed		 jne	 SHORT $LL4@wmemcmp
$LN3@wmemcmp:

; 219  : 
; 220  :         return 0;

  00024	33 c0		 xor	 eax, eax
  00026	5e		 pop	 esi

; 221  :     }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN8@wmemcmp:

; 218  :                 return *_S1 < *_S2 ? -1 : 1;

  00029	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0002c	66 3b 01	 cmp	 ax, WORD PTR [ecx]
  0002f	5e		 pop	 esi
  00030	1b c0		 sbb	 eax, eax
  00032	83 e0 fe	 and	 eax, -2			; fffffffeH
  00035	40		 inc	 eax

; 221  :     }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_wmemcmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemchr
_TEXT	SEGMENT
__S$ = 8						; size = 4
__C$ = 12						; size = 2
__N$ = 16						; size = 4
_wmemchr PROC						; COMDAT

; 202  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 203  :         for (; 0 < _N; ++_S, --_N)

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __N$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 14		 je	 SHORT $LN3@wmemchr
  0000a	66 8b 55 0c	 mov	 dx, WORD PTR __C$[ebp]
  0000e	8b 45 08	 mov	 eax, DWORD PTR __S$[ebp]
$LL4@wmemchr:

; 204  :             if (*_S == _C)

  00011	66 39 10	 cmp	 WORD PTR [eax], dx
  00014	74 0a		 je	 SHORT $LN1@wmemchr

; 203  :         for (; 0 < _N; ++_S, --_N)

  00016	83 c0 02	 add	 eax, 2
  00019	83 e9 01	 sub	 ecx, 1
  0001c	75 f3		 jne	 SHORT $LL4@wmemchr
$LN3@wmemchr:

; 205  :                 return (wchar_t _CONST_RETURN*)_S;
; 206  : 
; 207  :         return 0;

  0001e	33 c0		 xor	 eax, eax
$LN1@wmemchr:

; 208  :     }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
_wmemchr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT _swscanf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_swscanf PROC						; COMDAT

; 2044 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2045 :     int _Result;
; 2046 :     va_list _ArgList;
; 2047 :     __crt_va_start(_ArgList, _Format);
; 2048 :     _Result = _vswscanf_l(_Buffer, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00016	ff 70 04	 push	 DWORD PTR [eax+4]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	e8 00 00 00 00	 call	 ___stdio_common_vswscanf
  00020	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2049 :     __crt_va_end(_ArgList);
; 2050 :     return _Result;
; 2051 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_swscanf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT __vswscanf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vswscanf_l PROC					; COMDAT

; 1910 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1911 :     return __stdio_common_vswscanf(

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00016	ff 70 04	 push	 DWORD PTR [eax+4]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	e8 00 00 00 00	 call	 ___stdio_common_vswscanf
  00020	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1912 :         _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 1913 :         _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1914 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
__vswscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<wchar_t const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<wchar_t const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 83   :     static unsigned __int64 _OptionsStorage;
; 84   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 85   : }

  00005	c3		 ret	 0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _frexpl
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 4
_frexpl	PROC						; COMDAT

; 849  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 850  :     return frexp((double)_X, _Y);

  00003	ff 75 10	 push	 DWORD PTR __Y$[ebp]
  00006	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR __X$[ebp]
  0000b	83 ec 08	 sub	 esp, 8
  0000e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00013	e8 00 00 00 00	 call	 _frexp
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 851  : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_frexpl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _fabsl
_TEXT	SEGMENT
tv68 = -8						; size = 8
__X$ = 8						; size = 8
_fabsl	PROC						; COMDAT

; 828  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 829  :     return fabs((double)_X);

  00006	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR __X$[ebp]
  0000b	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00012	f2 0f 11 45 f8	 movsd	 QWORD PTR tv68[ebp], xmm0
  00017	dd 45 f8	 fld	 QWORD PTR tv68[ebp]

; 830  : }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_fabsl	ENDP
_TEXT	ENDS
END
