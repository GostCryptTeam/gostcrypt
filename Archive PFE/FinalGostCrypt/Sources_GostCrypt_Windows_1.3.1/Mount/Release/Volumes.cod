; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Common\Volumes.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ReadVolumeHeaderRecoveryMode
_BSS	SEGMENT
_ReadVolumeHeaderRecoveryMode DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_GetHeaderField16
PUBLIC	_GetHeaderField32
PUBLIC	_GetHeaderField64
PUBLIC	_ReadVolumeHeader
PUBLIC	_CreateVolumeHeaderInMemory
PUBLIC	_ReadEffectiveVolumeHeader
PUBLIC	_WriteEffectiveVolumeHeader
PUBLIC	_WriteRandomDataToReservedHeaderAreas
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__imp__SetFilePointerEx@20:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	__imp__VirtualLock@8:PROC
EXTRN	__imp__VirtualUnlock@8:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_crypto_open:PROC
EXTRN	_crypto_loadkey:PROC
EXTRN	_crypto_close:PROC
EXTRN	_CipherGetBlockSize:PROC
EXTRN	_EAInit:PROC
EXTRN	_EAInitMode:PROC
EXTRN	_EAGetFirst:PROC
EXTRN	_EAGetNext:PROC
EXTRN	_EAGetKeySize:PROC
EXTRN	_EAGetFirstCipher:PROC
EXTRN	_EAIsModeSupported:PROC
EXTRN	_GetMaxPkcs5OutSize:PROC
EXTRN	_EncryptBuffer:PROC
EXTRN	_DecryptBuffer:PROC
EXTRN	_EncryptionThreadPoolBeginKeyDerivation:PROC
EXTRN	_GetEncryptionThreadCount:PROC
EXTRN	_RandgetBytes:PROC
EXTRN	_GetCrc32:PROC
EXTRN	_MirrorBytes16:PROC
EXTRN	_MirrorBytes32:PROC
EXTRN	_MirrorBytes64:PROC
EXTRN	_derive_key_whirlpool:PROC
EXTRN	_derive_key_gosthash:PROC
EXTRN	_derive_key_stribog:PROC
EXTRN	_get_pkcs5_iteration_count:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9 DB 0188H DUP (?) ; `CreateVolumeHeaderInMemory'::`2'::keyInfo
?dk@?1??CreateVolumeHeaderInMemory@@9@9 DB 0100H DUP (?) ; `CreateVolumeHeaderInMemory'::`2'::dk
_BSS	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _WriteRandomDataToReservedHeaderAreas
_TEXT	SEGMENT
_offset$ = -131604					; size = 8
_bytesDone$ = -131596					; size = 4
_dev$GSCopy$1$ = -131592				; size = 4
_buf$ = -131588						; size = 131072
_originalK2$ = -516					; size = 256
_temporaryKey$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_dev$ = 8						; size = 4
_cryptoInfo$ = 12					; size = 4
_dataAreaSize$ = 16					; size = 8
_bPrimaryOnly$ = 24					; size = 4
_bBackupOnly$ = 28					; size = 4
_WriteRandomDataToReservedHeaderAreas PROC		; COMDAT

; 1159 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 14 02 02 00	 mov	 eax, 131604		; 00020214H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1160 : 	char temporaryKey[MASTER_KEYDATA_SIZE];
; 1161 : 	char originalK2[MASTER_KEYDATA_SIZE];
; 1162 : 
; 1163 : 	byte buf[GST_VOLUME_HEADER_GROUP_SIZE];
; 1164 : 
; 1165 : 	LARGE_INTEGER offset;
; 1166 : 	int nStatus = ERR_SUCCESS;
; 1167 : 	DWORD dwError;
; 1168 : 	DWORD bytesDone;
; 1169 : 	BOOL backupHeaders = bBackupOnly;
; 1170 : 
; 1171 : 	if (bPrimaryOnly && bBackupOnly)

  00017	83 7d 18 00	 cmp	 DWORD PTR _bPrimaryOnly$[ebp], 0
  0001b	8b 45 08	 mov	 eax, DWORD PTR _dev$[ebp]
  0001e	53		 push	 ebx
  0001f	8b 5d 0c	 mov	 ebx, DWORD PTR _cryptoInfo$[ebp]
  00022	56		 push	 esi
  00023	89 85 f8 fd fd
	ff		 mov	 DWORD PTR _dev$GSCopy$1$[ebp], eax
  00029	74 0d		 je	 SHORT $LN14@WriteRando
  0002b	83 7d 1c 00	 cmp	 DWORD PTR _bBackupOnly$[ebp], 0
  0002f	74 07		 je	 SHORT $LN14@WriteRando

; 1172 : 		GST_THROW_FATAL_EXCEPTION;

  00031	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN14@WriteRando:
  00038	57		 push	 edi

; 1173 : 
; 1174 : 	memcpy (originalK2, cryptoInfo->k2, sizeof (cryptoInfo->k2));
; 1175 : 
; 1176 : 	while (TRUE)
; 1177 : 	{
; 1178 : 		// Temporary keys
; 1179 : 		if (!RandgetBytes (temporaryKey, EAGetKeySize (cryptoInfo->ea), FALSE)
; 1180 : 			|| !RandgetBytes (cryptoInfo->k2, sizeof (cryptoInfo->k2), FALSE))

  00039	6a 00		 push	 0
  0003b	ff 33		 push	 DWORD PTR [ebx]
  0003d	8d b3 50 1d 00
	00		 lea	 esi, DWORD PTR [ebx+7504]
  00043	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00048	8d bd fc fd ff
	ff		 lea	 edi, DWORD PTR _originalK2$[ebp]
  0004e	f3 a5		 rep movsd
  00050	e8 00 00 00 00	 call	 _EAGetKeySize
  00055	83 c4 04	 add	 esp, 4
  00058	50		 push	 eax
  00059	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _RandgetBytes
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	85 c0		 test	 eax, eax
  0006a	0f 84 6f 01 00
	00		 je	 $LN16@WriteRando
$LL2@WriteRando:
  00070	6a 00		 push	 0
  00072	8d 83 50 1d 00
	00		 lea	 eax, DWORD PTR [ebx+7504]
  00078	68 00 01 00 00	 push	 256			; 00000100H
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _RandgetBytes
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH
  00086	85 c0		 test	 eax, eax
  00088	0f 84 51 01 00
	00		 je	 $LN16@WriteRando

; 1183 : 			goto final_seq;
; 1184 : 		}
; 1185 : 
; 1186 : 		nStatus = EAInit (cryptoInfo->ea, temporaryKey, cryptoInfo->ks);

  0008e	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  00091	50		 push	 eax
  00092	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  00098	50		 push	 eax
  00099	ff 33		 push	 DWORD PTR [ebx]
  0009b	e8 00 00 00 00	 call	 _EAInit
  000a0	8b f0		 mov	 esi, eax
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1187 : 		if (nStatus != ERR_SUCCESS)

  000a5	85 f6		 test	 esi, esi
  000a7	0f 85 37 01 00
	00		 jne	 $final_seq$93

; 1188 : 			goto final_seq;
; 1189 : 
; 1190 : 		if (!EAInitMode (cryptoInfo))

  000ad	53		 push	 ebx
  000ae	e8 00 00 00 00	 call	 _EAInitMode
  000b3	83 c4 04	 add	 esp, 4
  000b6	85 c0		 test	 eax, eax
  000b8	0f 84 ed 01 00
	00		 je	 $LN48@WriteRando

; 1194 : 		}
; 1195 : 
; 1196 : 		offset.QuadPart = backupHeaders ? dataAreaSize + GST_VOLUME_HEADER_GROUP_SIZE : GST_VOLUME_HEADER_OFFSET;

  000be	39 75 1c	 cmp	 DWORD PTR _bBackupOnly$[ebp], esi
  000c1	74 11		 je	 SHORT $LN31@WriteRando
  000c3	8b 75 10	 mov	 esi, DWORD PTR _dataAreaSize$[ebp]
  000c6	8b 7d 14	 mov	 edi, DWORD PTR _dataAreaSize$[ebp+4]
  000c9	81 c6 00 00 02
	00		 add	 esi, 131072		; 00020000H
  000cf	83 d7 00	 adc	 edi, 0
  000d2	eb 17		 jmp	 SHORT $LN32@WriteRando
$LN31@WriteRando:
  000d4	0f 57 c0	 xorps	 xmm0, xmm0
  000d7	66 0f 13 85 ec
	fd fd ff	 movlpd	 QWORD PTR _offset$[ebp], xmm0
  000df	8b bd f0 fd fd
	ff		 mov	 edi, DWORD PTR _offset$[ebp+4]
  000e5	8b b5 ec fd fd
	ff		 mov	 esi, DWORD PTR _offset$[ebp]
$LN32@WriteRando:

; 1197 : 
; 1198 : 		if (!SetFilePointerEx (dev, offset, NULL, FILE_BEGIN))

  000eb	6a 00		 push	 0
  000ed	6a 00		 push	 0
  000ef	57		 push	 edi
  000f0	56		 push	 esi
  000f1	ff b5 f8 fd fd
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  000fd	85 c0		 test	 eax, eax
  000ff	0f 84 b8 01 00
	00		 je	 $LN49@WriteRando

; 1199 : 		{
; 1200 : 			nStatus = ERR_OS_ERROR;
; 1201 : 			goto final_seq;
; 1202 : 		}
; 1203 : 
; 1204 : 		if (!ReadFile (dev, buf, sizeof (buf), &bytesDone, NULL))

  00105	6a 00		 push	 0
  00107	8d 85 f4 fd fd
	ff		 lea	 eax, DWORD PTR _bytesDone$[ebp]
  0010d	50		 push	 eax
  0010e	68 00 00 02 00	 push	 131072			; 00020000H
  00113	8d 85 fc fd fd
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00119	50		 push	 eax
  0011a	ff b5 f8 fd fd
	ff		 push	 DWORD PTR _dev$GSCopy$1$[ebp]
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  00126	85 c0		 test	 eax, eax
  00128	0f 84 8f 01 00
	00		 je	 $LN49@WriteRando

; 1205 : 		{
; 1206 : 			nStatus = ERR_OS_ERROR;
; 1207 : 			goto final_seq;
; 1208 : 		}
; 1209 : 
; 1210 : 		if (bytesDone < GST_VOLUME_HEADER_EFFECTIVE_SIZE)

  0012e	81 bd f4 fd fd
	ff 00 02 00 00	 cmp	 DWORD PTR _bytesDone$[ebp], 512 ; 00000200H
  00138	0f 82 77 01 00
	00		 jb	 $LN51@WriteRando

; 1215 : 		}
; 1216 : 
; 1217 : 		EncryptBuffer (buf + GST_VOLUME_HEADER_EFFECTIVE_SIZE, sizeof (buf) - GST_VOLUME_HEADER_EFFECTIVE_SIZE, cryptoInfo);

  0013e	53		 push	 ebx
  0013f	6a 00		 push	 0
  00141	8d 85 fc ff fd
	ff		 lea	 eax, DWORD PTR _buf$[ebp+512]
  00147	68 00 fe 01 00	 push	 130560			; 0001fe00H
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _EncryptBuffer
  00152	83 c4 10	 add	 esp, 16			; 00000010H

; 1218 : 
; 1219 : 		if (!SetFilePointerEx (dev, offset, NULL, FILE_BEGIN))

  00155	6a 00		 push	 0
  00157	6a 00		 push	 0
  00159	57		 push	 edi
  0015a	56		 push	 esi
  0015b	8b b5 f8 fd fd
	ff		 mov	 esi, DWORD PTR _dev$GSCopy$1$[ebp]
  00161	56		 push	 esi
  00162	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00168	85 c0		 test	 eax, eax
  0016a	0f 84 4d 01 00
	00		 je	 $LN49@WriteRando

; 1220 : 		{
; 1221 : 			nStatus = ERR_OS_ERROR;
; 1222 : 			goto final_seq;
; 1223 : 		}
; 1224 : 
; 1225 : 		if (!WriteFile (dev, buf, sizeof (buf), &bytesDone, NULL))

  00170	6a 00		 push	 0
  00172	8d 85 f4 fd fd
	ff		 lea	 eax, DWORD PTR _bytesDone$[ebp]
  00178	50		 push	 eax
  00179	68 00 00 02 00	 push	 131072			; 00020000H
  0017e	8d 85 fc fd fd
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00184	50		 push	 eax
  00185	56		 push	 esi
  00186	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  0018c	85 c0		 test	 eax, eax
  0018e	0f 84 29 01 00
	00		 je	 $LN49@WriteRando

; 1226 : 		{
; 1227 : 			nStatus = ERR_OS_ERROR;
; 1228 : 			goto final_seq;
; 1229 : 		}
; 1230 : 
; 1231 : 		if (bytesDone != sizeof (buf))

  00194	81 bd f4 fd fd
	ff 00 00 02 00	 cmp	 DWORD PTR _bytesDone$[ebp], 131072 ; 00020000H
  0019e	75 3f		 jne	 SHORT $LN16@WriteRando

; 1232 : 		{
; 1233 : 			nStatus = ERR_PARAMETER_INCORRECT;
; 1234 : 			goto final_seq;
; 1235 : 		}
; 1236 : 
; 1237 : 		if (backupHeaders || bPrimaryOnly)

  001a0	83 7d 1c 00	 cmp	 DWORD PTR _bBackupOnly$[ebp], 0
  001a4	0f 85 be 00 00
	00		 jne	 $LN55@WriteRando
  001aa	83 7d 18 00	 cmp	 DWORD PTR _bPrimaryOnly$[ebp], 0
  001ae	0f 85 b4 00 00
	00		 jne	 $LN55@WriteRando

; 1173 : 
; 1174 : 	memcpy (originalK2, cryptoInfo->k2, sizeof (cryptoInfo->k2));
; 1175 : 
; 1176 : 	while (TRUE)
; 1177 : 	{
; 1178 : 		// Temporary keys
; 1179 : 		if (!RandgetBytes (temporaryKey, EAGetKeySize (cryptoInfo->ea), FALSE)
; 1180 : 			|| !RandgetBytes (cryptoInfo->k2, sizeof (cryptoInfo->k2), FALSE))

  001b4	6a 00		 push	 0
  001b6	ff 33		 push	 DWORD PTR [ebx]

; 1238 : 			break;
; 1239 : 
; 1240 : 		backupHeaders = TRUE;

  001b8	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR _bBackupOnly$[ebp], 1
  001bf	e8 00 00 00 00	 call	 _EAGetKeySize
  001c4	83 c4 04	 add	 esp, 4
  001c7	50		 push	 eax
  001c8	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _temporaryKey$[ebp]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 _RandgetBytes
  001d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d7	85 c0		 test	 eax, eax
  001d9	0f 85 91 fe ff
	ff		 jne	 $LL2@WriteRando
$LN16@WriteRando:

; 1181 : 		{
; 1182 : 			nStatus = ERR_PARAMETER_INCORRECT; 

  001df	be 1e 00 00 00	 mov	 esi, 30			; 0000001eH
$final_seq$93:

; 1250 : 	{
; 1251 : 		nStatus = ERR_MODE_INIT_FAILED;
; 1252 : 		goto final_seq;
; 1253 : 	}
; 1254 : 
; 1255 : final_seq:
; 1256 : 
; 1257 : 	dwError = GetLastError();

  001e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 1258 : 
; 1259 : 	burn (temporaryKey, sizeof (temporaryKey));

  001ea	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _temporaryKey$[ebp]
  001f0	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  001f5	8b d8		 mov	 ebx, eax
  001f7	8b f9		 mov	 edi, ecx
  001f9	8b c2		 mov	 eax, edx
  001fb	0f 1f 44 00 00	 npad	 5
$LL34@WriteRando:
  00200	c6 07 00	 mov	 BYTE PTR [edi], 0
  00203	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00206	83 e8 01	 sub	 eax, 1
  00209	75 f5		 jne	 SHORT $LL34@WriteRando
  0020b	0f 1f 44 00 00	 npad	 5
$LL7@WriteRando:
  00210	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00213	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00216	83 ea 01	 sub	 edx, 1
  00219	75 f5		 jne	 SHORT $LL7@WriteRando

; 1260 : 	burn (originalK2, sizeof (originalK2));

  0021b	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _originalK2$[ebp]
  00221	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00226	8b f9		 mov	 edi, ecx
  00228	8b d0		 mov	 edx, eax
  0022a	66 0f 1f 44 00
	00		 npad	 6
$LL38@WriteRando:
  00230	c6 02 00	 mov	 BYTE PTR [edx], 0
  00233	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00236	83 ef 01	 sub	 edi, 1
  00239	75 f5		 jne	 SHORT $LL38@WriteRando
  0023b	5f		 pop	 edi
  0023c	0f 1f 40 00	 npad	 4
$LL12@WriteRando:
  00240	c6 00 00	 mov	 BYTE PTR [eax], 0
  00243	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00246	83 e9 01	 sub	 ecx, 1
  00249	75 f5		 jne	 SHORT $LL12@WriteRando

; 1261 : 
; 1262 : 	if (nStatus != ERR_SUCCESS)

  0024b	85 f6		 test	 esi, esi
  0024d	74 07		 je	 SHORT $LN85@WriteRando

; 1263 : 		SetLastError (dwError);

  0024f	53		 push	 ebx
  00250	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN85@WriteRando:

; 1264 : 
; 1265 : 	return nStatus;
; 1266 : }

  00256	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00259	8b c6		 mov	 eax, esi
  0025b	5e		 pop	 esi
  0025c	33 cd		 xor	 ecx, ebp
  0025e	5b		 pop	 ebx
  0025f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00264	8b e5		 mov	 esp, ebp
  00266	5d		 pop	 ebp
  00267	c3		 ret	 0
$LN55@WriteRando:

; 1241 : 	}
; 1242 : 
; 1243 : 	memcpy (cryptoInfo->k2, originalK2, sizeof (cryptoInfo->k2));
; 1244 : 
; 1245 : 	nStatus = EAInit (cryptoInfo->ea, cryptoInfo->master_keydata, cryptoInfo->ks);

  00268	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  0026b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00270	50		 push	 eax
  00271	8d 83 50 1c 00
	00		 lea	 eax, DWORD PTR [ebx+7248]
  00277	50		 push	 eax
  00278	ff 33		 push	 DWORD PTR [ebx]
  0027a	8d b5 fc fd ff
	ff		 lea	 esi, DWORD PTR _originalK2$[ebp]
  00280	8d bb 50 1d 00
	00		 lea	 edi, DWORD PTR [ebx+7504]
  00286	f3 a5		 rep movsd
  00288	e8 00 00 00 00	 call	 _EAInit
  0028d	8b f0		 mov	 esi, eax
  0028f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1246 : 	if (nStatus != ERR_SUCCESS)

  00292	85 f6		 test	 esi, esi
  00294	0f 85 4a ff ff
	ff		 jne	 $final_seq$93

; 1247 : 		goto final_seq;
; 1248 : 
; 1249 : 	if (!EAInitMode (cryptoInfo))

  0029a	53		 push	 ebx
  0029b	e8 00 00 00 00	 call	 _EAInitMode
  002a0	83 c4 04	 add	 esp, 4
  002a3	85 c0		 test	 eax, eax
  002a5	0f 85 39 ff ff
	ff		 jne	 $final_seq$93
$LN48@WriteRando:

; 1191 : 		{
; 1192 : 			nStatus = ERR_MODE_INIT_FAILED;

  002ab	be 1b 00 00 00	 mov	 esi, 27			; 0000001bH

; 1193 : 			goto final_seq;

  002b0	e9 2f ff ff ff	 jmp	 $final_seq$93
$LN51@WriteRando:

; 1211 : 		{
; 1212 : 			SetLastError (ERROR_INVALID_PARAMETER);

  002b5	6a 57		 push	 87			; 00000057H
  002b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN49@WriteRando:

; 1213 : 			nStatus = ERR_OS_ERROR;

  002bd	be 01 00 00 00	 mov	 esi, 1

; 1214 : 			goto final_seq;

  002c2	e9 1d ff ff ff	 jmp	 $final_seq$93
_WriteRandomDataToReservedHeaderAreas ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _WriteEffectiveVolumeHeader
_TEXT	SEGMENT
_bytesDone$ = -4128					; size = 4
_geometry$ = -4124					; size = 24
_sectorBuffer$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_device$ = 8						; size = 4
_fileHandle$ = 12					; size = 4
_header$ = 16						; size = 4
_WriteEffectiveVolumeHeader PROC			; COMDAT

; 1070 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 20 10 00 00	 mov	 eax, 4128		; 00001020H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1071 : #if GST_VOLUME_HEADER_EFFECTIVE_SIZE > GST_MAX_VOLUME_SECTOR_SIZE
; 1072 : #error GST_VOLUME_HEADER_EFFECTIVE_SIZE > GST_MAX_VOLUME_SECTOR_SIZE
; 1073 : #endif
; 1074 : 
; 1075 : 	byte sectorBuffer[GST_MAX_VOLUME_SECTOR_SIZE];
; 1076 : 	DWORD bytesDone;
; 1077 : 	DISK_GEOMETRY geometry;
; 1078 : 
; 1079 : 	if (!device)

  00017	83 7d 08 00	 cmp	 DWORD PTR _device$[ebp], 0

; 1080 : 	{
; 1081 : 		if (!WriteFile (fileHandle, header, GST_VOLUME_HEADER_EFFECTIVE_SIZE, &bytesDone, NULL))

  0001b	8d 85 e0 ef ff
	ff		 lea	 eax, DWORD PTR _bytesDone$[ebp]
  00021	53		 push	 ebx
  00022	8b 5d 0c	 mov	 ebx, DWORD PTR _fileHandle$[ebp]
  00025	56		 push	 esi
  00026	8b 75 10	 mov	 esi, DWORD PTR _header$[ebp]
  00029	6a 00		 push	 0
  0002b	50		 push	 eax
  0002c	75 3a		 jne	 SHORT $LN2@WriteEffec
  0002e	68 00 02 00 00	 push	 512			; 00000200H
  00033	56		 push	 esi
  00034	53		 push	 ebx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  0003b	85 c0		 test	 eax, eax
  0003d	0f 84 ff 00 00
	00		 je	 $LN16@WriteEffec

; 1082 : 			return FALSE;
; 1083 : 
; 1084 : 		if (bytesDone != GST_VOLUME_HEADER_EFFECTIVE_SIZE)

  00043	81 bd e0 ef ff
	ff 00 02 00 00	 cmp	 DWORD PTR _bytesDone$[ebp], 512 ; 00000200H
  0004d	0f 85 e7 00 00
	00		 jne	 $LN7@WriteEffec

; 1085 : 		{
; 1086 : 			SetLastError (ERROR_INVALID_PARAMETER);
; 1087 : 			return FALSE;
; 1088 : 		}
; 1089 : 
; 1090 : 		return TRUE;

  00053	5e		 pop	 esi
  00054	b8 01 00 00 00	 mov	 eax, 1
  00059	5b		 pop	 ebx

; 1132 : }

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005d	33 cd		 xor	 ecx, ebp
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
$LN2@WriteEffec:

; 1091 : 	}
; 1092 : 
; 1093 : 	if (!DeviceIoControl (fileHandle, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry), &bytesDone, NULL))

  00068	6a 18		 push	 24			; 00000018H
  0006a	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _geometry$[ebp]
  00070	50		 push	 eax
  00071	6a 00		 push	 0
  00073	6a 00		 push	 0
  00075	68 00 00 07 00	 push	 458752			; 00070000H
  0007a	53		 push	 ebx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00081	85 c0		 test	 eax, eax
  00083	0f 84 b9 00 00
	00		 je	 $LN16@WriteEffec

; 1094 : 		return FALSE;
; 1095 : 
; 1096 : 	if (geometry.BytesPerSector > sizeof (sectorBuffer) || geometry.BytesPerSector < GST_MIN_VOLUME_SECTOR_SIZE)

  00089	8b 95 f8 ef ff
	ff		 mov	 edx, DWORD PTR _geometry$[ebp+20]
  0008f	8d 82 00 fe ff
	ff		 lea	 eax, DWORD PTR [edx-512]
  00095	3d 00 0e 00 00	 cmp	 eax, 3584		; 00000e00H
  0009a	0f 87 9a 00 00
	00		 ja	 $LN7@WriteEffec

; 1099 : 		return FALSE;
; 1100 : 	}
; 1101 : 
; 1102 : 	if (geometry.BytesPerSector != GST_VOLUME_HEADER_EFFECTIVE_SIZE)

  000a0	81 fa 00 02 00
	00		 cmp	 edx, 512		; 00000200H
  000a6	74 44		 je	 SHORT $LN11@WriteEffec

; 1103 : 	{
; 1104 : 		LARGE_INTEGER seekOffset;
; 1105 : 
; 1106 : 		if (!ReadFile (fileHandle, sectorBuffer, geometry.BytesPerSector, &bytesDone, NULL))

  000a8	6a 00		 push	 0
  000aa	8d 85 e0 ef ff
	ff		 lea	 eax, DWORD PTR _bytesDone$[ebp]
  000b0	50		 push	 eax
  000b1	52		 push	 edx
  000b2	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _sectorBuffer$[ebp]
  000b8	50		 push	 eax
  000b9	53		 push	 ebx
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  000c0	85 c0		 test	 eax, eax
  000c2	74 7e		 je	 SHORT $LN16@WriteEffec

; 1107 : 			return FALSE;
; 1108 : 
; 1109 : 		if (bytesDone != geometry.BytesPerSector)

  000c4	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _bytesDone$[ebp]
  000ca	3b 85 f8 ef ff
	ff		 cmp	 eax, DWORD PTR _geometry$[ebp+20]
  000d0	75 68		 jne	 SHORT $LN7@WriteEffec

; 1110 : 		{
; 1111 : 			SetLastError (ERROR_INVALID_PARAMETER);
; 1112 : 			return FALSE;
; 1113 : 		}
; 1114 : 
; 1115 : 		seekOffset.QuadPart = -(int) bytesDone;
; 1116 : 		if (!SetFilePointerEx (fileHandle, seekOffset, NULL, FILE_CURRENT))

  000d2	6a 01		 push	 1
  000d4	f7 d8		 neg	 eax
  000d6	6a 00		 push	 0
  000d8	99		 cdq
  000d9	52		 push	 edx
  000da	50		 push	 eax
  000db	53		 push	 ebx
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  000e2	85 c0		 test	 eax, eax
  000e4	74 5c		 je	 SHORT $LN16@WriteEffec

; 1117 : 			return FALSE;

  000e6	8b 95 f8 ef ff
	ff		 mov	 edx, DWORD PTR _geometry$[ebp+20]
$LN11@WriteEffec:
  000ec	57		 push	 edi

; 1118 : 	}
; 1119 : 
; 1120 : 	memcpy (sectorBuffer, header, GST_VOLUME_HEADER_EFFECTIVE_SIZE);
; 1121 : 
; 1122 : 	if (!WriteFile (fileHandle, sectorBuffer, geometry.BytesPerSector, &bytesDone, NULL))

  000ed	6a 00		 push	 0
  000ef	8d 85 e0 ef ff
	ff		 lea	 eax, DWORD PTR _bytesDone$[ebp]
  000f5	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  000fa	50		 push	 eax
  000fb	52		 push	 edx
  000fc	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _sectorBuffer$[ebp]
  00102	50		 push	 eax
  00103	8d bd fc ef ff
	ff		 lea	 edi, DWORD PTR _sectorBuffer$[ebp]
  00109	f3 a5		 rep movsd
  0010b	53		 push	 ebx
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00112	5f		 pop	 edi
  00113	85 c0		 test	 eax, eax
  00115	74 2b		 je	 SHORT $LN16@WriteEffec

; 1123 : 		return FALSE;
; 1124 : 
; 1125 : 	if (bytesDone != geometry.BytesPerSector)

  00117	8b 85 e0 ef ff
	ff		 mov	 eax, DWORD PTR _bytesDone$[ebp]
  0011d	3b 85 f8 ef ff
	ff		 cmp	 eax, DWORD PTR _geometry$[ebp+20]
  00123	75 15		 jne	 SHORT $LN7@WriteEffec

; 1126 : 	{
; 1127 : 		SetLastError (ERROR_INVALID_PARAMETER);
; 1128 : 		return FALSE;
; 1129 : 	}
; 1130 : 
; 1131 : 	return TRUE;

  00125	5e		 pop	 esi
  00126	b8 01 00 00 00	 mov	 eax, 1
  0012b	5b		 pop	 ebx

; 1132 : }

  0012c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012f	33 cd		 xor	 ecx, ebp
  00131	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c3		 ret	 0
$LN7@WriteEffec:

; 1097 : 	{
; 1098 : 		SetLastError (ERROR_INVALID_PARAMETER);

  0013a	6a 57		 push	 87			; 00000057H
  0013c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN16@WriteEffec:

; 1132 : }

  00142	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00145	33 c0		 xor	 eax, eax
  00147	5e		 pop	 esi
  00148	33 cd		 xor	 ecx, ebp
  0014a	5b		 pop	 ebx
  0014b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
_WriteEffectiveVolumeHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _ReadEffectiveVolumeHeader
_TEXT	SEGMENT
_header$GSCopy$1$ = -4128				; size = 4
_geometry$ = -4124					; size = 24
_sectorBuffer$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_device$ = 8						; size = 4
_fileHandle$ = 12					; size = 4
_header$ = 16						; size = 4
_bytesRead$ = 20					; size = 4
_ReadEffectiveVolumeHeader PROC				; COMDAT

; 1017 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 20 10 00 00	 mov	 eax, 4128		; 00001020H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1018 : #if GST_VOLUME_HEADER_EFFECTIVE_SIZE > GST_MAX_VOLUME_SECTOR_SIZE
; 1019 : #error GST_VOLUME_HEADER_EFFECTIVE_SIZE > GST_MAX_VOLUME_SECTOR_SIZE
; 1020 : #endif
; 1021 : 
; 1022 : 	byte sectorBuffer[GST_MAX_VOLUME_SECTOR_SIZE];
; 1023 : 	DISK_GEOMETRY geometry;
; 1024 : 
; 1025 : 	if (!device)

  00017	83 7d 08 00	 cmp	 DWORD PTR _device$[ebp], 0
  0001b	8b 45 10	 mov	 eax, DWORD PTR _header$[ebp]
  0001e	56		 push	 esi
  0001f	8b 75 14	 mov	 esi, DWORD PTR _bytesRead$[ebp]
  00022	57		 push	 edi
  00023	8b 7d 0c	 mov	 edi, DWORD PTR _fileHandle$[ebp]

; 1026 : 		return ReadFile (fileHandle, header, GST_VOLUME_HEADER_EFFECTIVE_SIZE, bytesRead, NULL);

  00026	6a 00		 push	 0
  00028	89 85 e0 ef ff
	ff		 mov	 DWORD PTR _header$GSCopy$1$[ebp], eax
  0002e	56		 push	 esi
  0002f	75 1d		 jne	 SHORT $LN2@ReadEffect
  00031	68 00 02 00 00	 push	 512			; 00000200H
  00036	50		 push	 eax
  00037	57		 push	 edi
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi

; 1046 : }

  00040	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00043	33 cd		 xor	 ecx, ebp
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN2@ReadEffect:

; 1027 : 
; 1028 : 	if (!DeviceIoControl (fileHandle, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &geometry, sizeof (geometry), bytesRead, NULL))

  0004e	6a 18		 push	 24			; 00000018H
  00050	8d 85 e4 ef ff
	ff		 lea	 eax, DWORD PTR _geometry$[ebp]
  00056	50		 push	 eax
  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	68 00 00 07 00	 push	 458752			; 00070000H
  00060	57		 push	 edi
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00067	85 c0		 test	 eax, eax
  00069	0f 84 8c 00 00
	00		 je	 $LN12@ReadEffect

; 1029 : 		return FALSE;
; 1030 : 
; 1031 : 	if (geometry.BytesPerSector > sizeof (sectorBuffer) || geometry.BytesPerSector < GST_MIN_VOLUME_SECTOR_SIZE)

  0006f	8b 8d f8 ef ff
	ff		 mov	 ecx, DWORD PTR _geometry$[ebp+20]
  00075	8d 81 00 fe ff
	ff		 lea	 eax, DWORD PTR [ecx-512]
  0007b	3d 00 0e 00 00	 cmp	 eax, 3584		; 00000e00H
  00080	77 71		 ja	 SHORT $LN5@ReadEffect

; 1034 : 		return FALSE;
; 1035 : 	}
; 1036 : 
; 1037 : 	if (!ReadFile (fileHandle, sectorBuffer, max (GST_VOLUME_HEADER_EFFECTIVE_SIZE, geometry.BytesPerSector), bytesRead, NULL))

  00082	53		 push	 ebx
  00083	6a 00		 push	 0
  00085	bb 00 02 00 00	 mov	 ebx, 512		; 00000200H
  0008a	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _sectorBuffer$[ebp]
  00090	3b cb		 cmp	 ecx, ebx
  00092	56		 push	 esi
  00093	0f 42 cb	 cmovb	 ecx, ebx
  00096	51		 push	 ecx
  00097	50		 push	 eax
  00098	57		 push	 edi
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  0009f	85 c0		 test	 eax, eax
  000a1	75 11		 jne	 SHORT $LN6@ReadEffect
  000a3	5b		 pop	 ebx
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi

; 1046 : }

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a9	33 cd		 xor	 ecx, ebp
  000ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
$LN6@ReadEffect:

; 1038 : 		return FALSE;
; 1039 : 
; 1040 : 	memcpy (header, sectorBuffer, min (*bytesRead, GST_VOLUME_HEADER_EFFECTIVE_SIZE));

  000b4	39 1e		 cmp	 DWORD PTR [esi], ebx
  000b6	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _sectorBuffer$[ebp]
  000bc	0f 42 1e	 cmovb	 ebx, DWORD PTR [esi]
  000bf	53		 push	 ebx
  000c0	50		 push	 eax
  000c1	ff b5 e0 ef ff
	ff		 push	 DWORD PTR _header$GSCopy$1$[ebp]
  000c7	e8 00 00 00 00	 call	 _memcpy
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1041 : 	
; 1042 : 	if (*bytesRead > GST_VOLUME_HEADER_EFFECTIVE_SIZE)

  000cf	81 3e 00 02 00
	00		 cmp	 DWORD PTR [esi], 512	; 00000200H
  000d5	76 06		 jbe	 SHORT $LN7@ReadEffect

; 1043 : 		*bytesRead = GST_VOLUME_HEADER_EFFECTIVE_SIZE;

  000d7	c7 06 00 02 00
	00		 mov	 DWORD PTR [esi], 512	; 00000200H
$LN7@ReadEffect:
  000dd	5b		 pop	 ebx
  000de	5f		 pop	 edi

; 1044 : 
; 1045 : 	return TRUE;

  000df	b8 01 00 00 00	 mov	 eax, 1
  000e4	5e		 pop	 esi

; 1046 : }

  000e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e8	33 cd		 xor	 ecx, ebp
  000ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c3		 ret	 0
$LN5@ReadEffect:

; 1032 : 	{
; 1033 : 		SetLastError (ERROR_INVALID_PARAMETER);

  000f3	6a 57		 push	 87			; 00000057H
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN12@ReadEffect:

; 1046 : }

  000fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fe	33 c0		 xor	 eax, eax
  00100	5f		 pop	 edi
  00101	33 cd		 xor	 ecx, ebp
  00103	5e		 pop	 esi
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
_ReadEffectiveVolumeHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _CreateVolumeHeaderInMemory
_TEXT	SEGMENT
_nUserKeyLen$1$ = -8					; size = 4
_cryptoInfo$1$ = -4					; size = 4
_bBoot$ = 8						; size = 4
_header$ = 12						; size = 4
_ea$ = 16						; size = 4
_mode$ = 20						; size = 4
tv698 = 24						; size = 4
_password$ = 24						; size = 4
_pkcs5_prf$ = 28					; size = 4
_masterKeydata$ = 32					; size = 4
_retInfo$ = 36						; size = 4
_volumeSize$ = 40					; size = 8
_hiddenVolumeSize$ = 48					; size = 8
_encryptedAreaStart$ = 56				; size = 8
_encryptedAreaLength$ = 64				; size = 8
_requiredProgramVersion$ = 72				; size = 2
_headerFlags$ = 76					; size = 4
_sectorSize$ = 80					; size = 4
_bWipeMode$ = 84					; size = 4
_CreateVolumeHeaderInMemory PROC			; COMDAT

; 761  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 762  : 	unsigned char *p = (unsigned char *) header;
; 763  : 	static KEY_INFO keyInfo;
; 764  : 
; 765  : 	int nUserKeyLen = password->Length;

  00006	8b 45 18	 mov	 eax, DWORD PTR _password$[ebp]
  00009	57		 push	 edi
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 45 f8	 mov	 DWORD PTR _nUserKeyLen$1$[ebp], eax

; 766  : 	PCRYPTO_INFO cryptoInfo = crypto_open ();

  0000f	e8 00 00 00 00	 call	 _crypto_open
  00014	8b f8		 mov	 edi, eax
  00016	89 7d fc	 mov	 DWORD PTR _cryptoInfo$1$[ebp], edi

; 767  : 	static char dk[MASTER_KEYDATA_SIZE];
; 768  : 	int x;
; 769  : 	int retVal = 0;
; 770  : 	int primaryKeyOffset;
; 771  : 
; 772  : 	if (cryptoInfo == NULL)

  00019	85 ff		 test	 edi, edi
  0001b	75 08		 jne	 SHORT $LN22@CreateVolu

; 773  : 		return ERR_OUTOFMEMORY;

  0001d	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  00020	5f		 pop	 edi

; 999  : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
$LN22@CreateVolu:
  00025	53		 push	 ebx

; 774  : 
; 775  : 	memset (header, 0, GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  00026	8b 5d 0c	 mov	 ebx, DWORD PTR _header$[ebp]
  00029	56		 push	 esi
  0002a	68 00 02 00 00	 push	 512			; 00000200H
  0002f	6a 00		 push	 0
  00031	53		 push	 ebx
  00032	e8 00 00 00 00	 call	 _memset

; 776  : 
; 777  : 	VirtualLock (&keyInfo, sizeof (keyInfo));

  00037	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualLock@8
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	68 88 01 00 00	 push	 392			; 00000188H
  00045	68 00 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9
  0004a	ff d6		 call	 esi

; 778  : 	VirtualLock (&dk, sizeof (dk));

  0004c	68 00 01 00 00	 push	 256			; 00000100H
  00051	68 00 00 00 00	 push	 OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  00056	ff d6		 call	 esi

; 779  : 
; 780  : 	/* Encryption setup */
; 781  : 
; 782  : 	if (masterKeydata == NULL)

  00058	8b 75 20	 mov	 esi, DWORD PTR _masterKeydata$[ebp]
  0005b	85 f6		 test	 esi, esi
  0005d	75 2a		 jne	 SHORT $LN23@CreateVolu

; 783  : 	{
; 784  : 		// We have no master key data (creating a new volume) so we'll use the GostCrypt RNG to generate them
; 785  : 
; 786  : 		int bytesNeeded;
; 787  : 
; 788  : 		switch (mode)
; 789  : 		{
; 790  : 		default:
; 791  : 			bytesNeeded = EAGetKeySize (ea) * 2;	// Size of primary + secondary key(s)

  0005f	ff 75 10	 push	 DWORD PTR _ea$[ebp]
  00062	e8 00 00 00 00	 call	 _EAGetKeySize
  00067	03 c0		 add	 eax, eax

; 792  : 		}
; 793  : 
; 794  : 		if (!RandgetBytes (keyInfo.master_keydata, bytesNeeded, TRUE))

  00069	6a 01		 push	 1
  0006b	50		 push	 eax
  0006c	68 88 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  00071	e8 00 00 00 00	 call	 _RandgetBytes
  00076	83 c4 10	 add	 esp, 16			; 00000010H
  00079	85 c0		 test	 eax, eax
  0007b	75 1b		 jne	 SHORT $LN24@CreateVolu
$LN96@CreateVolu:
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx

; 795  : 			return ERR_CIPHER_INIT_WEAK_KEY;

  0007f	b8 12 00 00 00	 mov	 eax, 18			; 00000012H
  00084	5f		 pop	 edi

; 999  : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
$LN23@CreateVolu:

; 796  : 	}
; 797  : 	else
; 798  : 	{
; 799  : 		// We already have existing master key data (the header is being re-encrypted)
; 800  : 		memcpy (keyInfo.master_keydata, masterKeydata, MASTER_KEYDATA_SIZE);

  00089	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0008e	bf 88 00 00 00	 mov	 edi, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  00093	f3 a5		 rep movsd
  00095	8b 7d fc	 mov	 edi, DWORD PTR _cryptoInfo$1$[ebp]
$LN24@CreateVolu:

; 801  : 	}
; 802  : 
; 803  : 	// User key 
; 804  : 	memcpy (keyInfo.userKey, password->Text, nUserKeyLen);

  00098	8b 45 18	 mov	 eax, DWORD PTR _password$[ebp]
  0009b	8b 75 f8	 mov	 esi, DWORD PTR _nUserKeyLen$1$[ebp]
  0009e	83 c0 04	 add	 eax, 4
  000a1	56		 push	 esi
  000a2	50		 push	 eax
  000a3	68 08 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+8
  000a8	e8 00 00 00 00	 call	 _memcpy

; 805  : 	keyInfo.keyLength = nUserKeyLen;
; 806  : 	keyInfo.noIterations = get_pkcs5_iteration_count (pkcs5_prf, bBoot);

  000ad	ff 75 08	 push	 DWORD PTR _bBoot$[ebp]
  000b0	89 35 04 00 00
	00		 mov	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+4, esi
  000b6	8b 75 1c	 mov	 esi, DWORD PTR _pkcs5_prf$[ebp]
  000b9	56		 push	 esi
  000ba	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count
  000bf	a3 00 00 00 00	 mov	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9, eax

; 807  : 
; 808  : 	// User selected encryption algorithm
; 809  : 	cryptoInfo->ea = ea;

  000c4	8b 45 10	 mov	 eax, DWORD PTR _ea$[ebp]
  000c7	89 07		 mov	 DWORD PTR [edi], eax

; 810  : 
; 811  : 	// Mode of operation
; 812  : 	cryptoInfo->mode = mode;

  000c9	8b 45 14	 mov	 eax, DWORD PTR _mode$[ebp]
  000cc	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 813  : 
; 814  : 	// Salt for header key derivation
; 815  : 	if (!RandgetBytes (keyInfo.salt, PKCS5_SALT_SIZE, !bWipeMode))

  000cf	33 c0		 xor	 eax, eax
  000d1	39 45 54	 cmp	 DWORD PTR _bWipeMode$[ebp], eax
  000d4	0f 94 c0	 sete	 al
  000d7	50		 push	 eax
  000d8	6a 40		 push	 64			; 00000040H
  000da	68 48 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+72
  000df	e8 00 00 00 00	 call	 _RandgetBytes
  000e4	83 c4 20	 add	 esp, 32			; 00000020H
  000e7	85 c0		 test	 eax, eax
  000e9	74 92		 je	 SHORT $LN96@CreateVolu

; 816  : 		return ERR_CIPHER_INIT_WEAK_KEY; 
; 817  : 
; 818  : 	// PBKDF2 (PKCS5) is used to derive primary header key(s) and secondary header key(s) (XTS) from the password/keyfiles
; 819  : 	switch (pkcs5_prf)

  000eb	83 ee 01	 sub	 esi, 1
  000ee	74 67		 je	 SHORT $LN29@CreateVolu
  000f0	83 ee 01	 sub	 esi, 1
  000f3	74 38		 je	 SHORT $LN30@CreateVolu
  000f5	83 ee 01	 sub	 esi, 1
  000f8	74 09		 je	 SHORT $LN28@CreateVolu

; 833  : 	default:		
; 834  : 		// Unknown/wrong ID
; 835  : 		GST_THROW_FATAL_EXCEPTION;

  000fa	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  00101	eb 7f		 jmp	 SHORT $LN4@CreateVolu
$LN28@CreateVolu:

; 820  : 	{
; 821  : 	case WHIRLPOOL:
; 822  : 		derive_key_whirlpool (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,

  00103	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00108	50		 push	 eax
  00109	68 00 00 00 00	 push	 OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  0010e	ff 35 00 00 00
	00		 push	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9
  00114	6a 40		 push	 64			; 00000040H
  00116	68 48 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+72
  0011b	ff 35 04 00 00
	00		 push	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+4
  00121	68 08 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+8
  00126	e8 00 00 00 00	 call	 _derive_key_whirlpool

; 823  : 			PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
; 824  : 		break;

  0012b	eb 52		 jmp	 SHORT $LN94@CreateVolu
$LN30@CreateVolu:

; 827  : 			PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
; 828  : 		break;
; 829  : 	case GOSTHASH:
; 830  : 		derive_key_gosthash (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,

  0012d	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00132	50		 push	 eax
  00133	68 00 00 00 00	 push	 OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  00138	ff 35 00 00 00
	00		 push	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9
  0013e	6a 40		 push	 64			; 00000040H
  00140	68 48 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+72
  00145	ff 35 04 00 00
	00		 push	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+4
  0014b	68 08 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+8
  00150	e8 00 00 00 00	 call	 _derive_key_gosthash

; 831  : 			PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
; 832  : 		break;

  00155	eb 28		 jmp	 SHORT $LN94@CreateVolu
$LN29@CreateVolu:

; 825  : 	case STRIBOG:
; 826  : 		derive_key_stribog (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,

  00157	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  0015c	50		 push	 eax
  0015d	68 00 00 00 00	 push	 OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  00162	ff 35 00 00 00
	00		 push	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9
  00168	6a 40		 push	 64			; 00000040H
  0016a	68 48 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+72
  0016f	ff 35 04 00 00
	00		 push	 DWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+4
  00175	68 08 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+8
  0017a	e8 00 00 00 00	 call	 _derive_key_stribog
$LN94@CreateVolu:
  0017f	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN4@CreateVolu:

; 836  : 	} 
; 837  : 
; 838  : 	/* Header setup */
; 839  : 
; 840  : 	// Salt
; 841  : 	mputBytes (p, keyInfo.salt, PKCS5_SALT_SIZE);	

  00182	0f 10 05 48 00
	00 00		 movups	 xmm0, XMMWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+72

; 842  : 
; 843  : 	// Magic
; 844  : 	mputLong (p, 0x54525545);
; 845  : 
; 846  : 	// Header version
; 847  : 	mputWord (p, VOLUME_HEADER_VERSION);
; 848  : 	cryptoInfo->HeaderVersion = VOLUME_HEADER_VERSION;
; 849  : 
; 850  : 	// Required program version to handle this volume
; 851  : 	switch (mode)
; 852  : 	{
; 853  : 	default:
; 854  : 		mputWord (p, requiredProgramVersion != 0 ? requiredProgramVersion : GST_VOLUME_MIN_REQUIRED_PROGRAM_VERSION);

  00189	66 8b 4d 48	 mov	 cx, WORD PTR _requiredProgramVersion$[ebp]
  0018d	8d 43 40	 lea	 eax, DWORD PTR [ebx+64]
  00190	89 45 18	 mov	 DWORD PTR tv698[ebp], eax
  00193	8b f0		 mov	 esi, eax
  00195	b8 00 13 00 00	 mov	 eax, 4864		; 00001300H
  0019a	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0
  0019d	0f 10 05 58 00
	00 00		 movups	 xmm0, XMMWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+88
  001a4	0f 11 43 10	 movups	 XMMWORD PTR [ebx+16], xmm0
  001a8	0f 10 05 68 00
	00 00		 movups	 xmm0, XMMWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+104
  001af	0f 11 43 20	 movups	 XMMWORD PTR [ebx+32], xmm0
  001b3	0f 10 05 78 00
	00 00		 movups	 xmm0, XMMWORD PTR ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+120
  001ba	0f 11 43 30	 movups	 XMMWORD PTR [ebx+48], xmm0
  001be	c7 06 54 52 55
	45		 mov	 DWORD PTR [esi], 1163219540 ; 45555254H
  001c4	66 c7 46 04 13
	00		 mov	 WORD PTR [esi+4], 19	; 00000013H
  001ca	66 89 87 4c 04
	00 00		 mov	 WORD PTR [edi+1100], ax
  001d1	66 85 c9	 test	 cx, cx
  001d4	74 03		 je	 SHORT $LN43@CreateVolu
  001d6	0f b7 c1	 movzx	 eax, cx
$LN43@CreateVolu:
  001d9	c1 e8 08	 shr	 eax, 8
  001dc	88 46 06	 mov	 BYTE PTR [esi+6], al
  001df	0f b7 c1	 movzx	 eax, cx
  001e2	66 85 c9	 test	 cx, cx
  001e5	75 05		 jne	 SHORT $LN45@CreateVolu
  001e7	b8 00 13 00 00	 mov	 eax, 4864		; 00001300H
$LN45@CreateVolu:

; 855  : 	}
; 856  : 
; 857  : 	// CRC of the master key data
; 858  : 	x = GetCrc32(keyInfo.master_keydata, MASTER_KEYDATA_SIZE);

  001ec	68 00 01 00 00	 push	 256			; 00000100H
  001f1	68 88 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  001f6	88 46 07	 mov	 BYTE PTR [esi+7], al
  001f9	e8 00 00 00 00	 call	 _GetCrc32

; 859  : 	mputLong (p, x);

  001fe	8b c8		 mov	 ecx, eax
  00200	83 c4 08	 add	 esp, 8
  00203	c1 f9 18	 sar	 ecx, 24			; 00000018H
  00206	88 4e 08	 mov	 BYTE PTR [esi+8], cl
  00209	8b c8		 mov	 ecx, eax
  0020b	c1 f9 10	 sar	 ecx, 16			; 00000010H
  0020e	88 4e 09	 mov	 BYTE PTR [esi+9], cl
  00211	8b c8		 mov	 ecx, eax
  00213	c1 f9 08	 sar	 ecx, 8
  00216	88 4e 0a	 mov	 BYTE PTR [esi+10], cl
  00219	88 46 0b	 mov	 BYTE PTR [esi+11], al

; 860  : 
; 861  : 	// Reserved fields
; 862  : 	p += 2 * 8;
; 863  : 
; 864  : 	// Size of hidden volume (if any)
; 865  : 	cryptoInfo->hiddenVolumeSize = hiddenVolumeSize;

  0021c	8b 45 30	 mov	 eax, DWORD PTR _hiddenVolumeSize$[ebp]
  0021f	89 87 b8 1e 00
	00		 mov	 DWORD PTR [edi+7864], eax
  00225	8b 45 34	 mov	 eax, DWORD PTR _hiddenVolumeSize$[ebp+4]
  00228	89 87 bc 1e 00
	00		 mov	 DWORD PTR [edi+7868], eax

; 866  : 	mputInt64 (p, cryptoInfo->hiddenVolumeSize);

  0022e	0f b6 87 bf 1e
	00 00		 movzx	 eax, BYTE PTR [edi+7871]
  00235	88 46 1c	 mov	 BYTE PTR [esi+28], al
  00238	0f b6 87 be 1e
	00 00		 movzx	 eax, BYTE PTR [edi+7870]
  0023f	88 46 1d	 mov	 BYTE PTR [esi+29], al
  00242	0f b6 87 bd 1e
	00 00		 movzx	 eax, BYTE PTR [edi+7869]
  00249	88 46 1e	 mov	 BYTE PTR [esi+30], al
  0024c	0f b6 87 bc 1e
	00 00		 movzx	 eax, BYTE PTR [edi+7868]
  00253	88 46 1f	 mov	 BYTE PTR [esi+31], al
  00256	0f b6 87 bb 1e
	00 00		 movzx	 eax, BYTE PTR [edi+7867]
  0025d	88 46 20	 mov	 BYTE PTR [esi+32], al
  00260	0f b6 87 ba 1e
	00 00		 movzx	 eax, BYTE PTR [edi+7866]
  00267	88 46 21	 mov	 BYTE PTR [esi+33], al
  0026a	0f b6 87 b9 1e
	00 00		 movzx	 eax, BYTE PTR [edi+7865]
  00271	88 46 22	 mov	 BYTE PTR [esi+34], al
  00274	0f b6 87 b8 1e
	00 00		 movzx	 eax, BYTE PTR [edi+7864]
  0027b	88 46 23	 mov	 BYTE PTR [esi+35], al

; 867  : 
; 868  : 	cryptoInfo->hiddenVolume = cryptoInfo->hiddenVolumeSize != 0;

  0027e	8b 87 b8 1e 00
	00		 mov	 eax, DWORD PTR [edi+7864]
  00284	0b 87 bc 1e 00
	00		 or	 eax, DWORD PTR [edi+7868]
  0028a	74 07		 je	 SHORT $LN46@CreateVolu
  0028c	b8 01 00 00 00	 mov	 eax, 1
  00291	eb 02		 jmp	 SHORT $LN47@CreateVolu
$LN46@CreateVolu:
  00293	33 c0		 xor	 eax, eax
$LN47@CreateVolu:
  00295	89 87 48 04 00
	00		 mov	 DWORD PTR [edi+1096], eax

; 869  : 
; 870  : 	// Volume size
; 871  : 	cryptoInfo->VolumeSize.Value = volumeSize;

  0029b	8b 55 2c	 mov	 edx, DWORD PTR _volumeSize$[ebp+4]

; 872  : 	mputInt64 (p, volumeSize);

  0029e	8b c2		 mov	 eax, edx
  002a0	8b 5d 28	 mov	 ebx, DWORD PTR _volumeSize$[ebp]
  002a3	8b cb		 mov	 ecx, ebx
  002a5	c1 e8 18	 shr	 eax, 24			; 00000018H
  002a8	89 97 f4 1e 00
	00		 mov	 DWORD PTR [edi+7924], edx
  002ae	89 9f f0 1e 00
	00		 mov	 DWORD PTR [edi+7920], ebx
  002b4	88 46 24	 mov	 BYTE PTR [esi+36], al
  002b7	8b c2		 mov	 eax, edx
  002b9	c1 e8 10	 shr	 eax, 16			; 00000010H
  002bc	88 46 25	 mov	 BYTE PTR [esi+37], al
  002bf	8b c2		 mov	 eax, edx
  002c1	c1 e8 08	 shr	 eax, 8
  002c4	88 46 26	 mov	 BYTE PTR [esi+38], al
  002c7	8b c2		 mov	 eax, edx
  002c9	0f ac c1 18	 shrd	 ecx, eax, 24
  002cd	88 56 27	 mov	 BYTE PTR [esi+39], dl
  002d0	c1 e8 18	 shr	 eax, 24			; 00000018H
  002d3	88 4e 28	 mov	 BYTE PTR [esi+40], cl
  002d6	8b c2		 mov	 eax, edx
  002d8	8b cb		 mov	 ecx, ebx
  002da	0f ac c1 10	 shrd	 ecx, eax, 16
  002de	c1 e8 10	 shr	 eax, 16			; 00000010H
  002e1	88 4e 29	 mov	 BYTE PTR [esi+41], cl
  002e4	8b c3		 mov	 eax, ebx
  002e6	0f ac d0 08	 shrd	 eax, edx, 8
  002ea	88 46 2a	 mov	 BYTE PTR [esi+42], al
  002ed	88 5e 2b	 mov	 BYTE PTR [esi+43], bl

; 873  : 
; 874  : 	// Encrypted area start
; 875  : 	cryptoInfo->EncryptedAreaStart.Value = encryptedAreaStart;

  002f0	8b 5d 38	 mov	 ebx, DWORD PTR _encryptedAreaStart$[ebp]

; 876  : 	mputInt64 (p, encryptedAreaStart);

  002f3	8b cb		 mov	 ecx, ebx
  002f5	89 9f f8 1e 00
	00		 mov	 DWORD PTR [edi+7928], ebx
  002fb	c1 ea 08	 shr	 edx, 8
  002fe	8b 55 3c	 mov	 edx, DWORD PTR _encryptedAreaStart$[ebp+4]
  00301	8b c2		 mov	 eax, edx
  00303	c1 e8 18	 shr	 eax, 24			; 00000018H
  00306	89 97 fc 1e 00
	00		 mov	 DWORD PTR [edi+7932], edx
  0030c	88 46 2c	 mov	 BYTE PTR [esi+44], al
  0030f	8b c2		 mov	 eax, edx
  00311	c1 e8 10	 shr	 eax, 16			; 00000010H
  00314	88 46 2d	 mov	 BYTE PTR [esi+45], al
  00317	8b c2		 mov	 eax, edx
  00319	c1 e8 08	 shr	 eax, 8
  0031c	88 46 2e	 mov	 BYTE PTR [esi+46], al
  0031f	8b c2		 mov	 eax, edx
  00321	0f ac c1 18	 shrd	 ecx, eax, 24
  00325	88 56 2f	 mov	 BYTE PTR [esi+47], dl
  00328	c1 e8 18	 shr	 eax, 24			; 00000018H
  0032b	88 4e 30	 mov	 BYTE PTR [esi+48], cl
  0032e	8b c2		 mov	 eax, edx
  00330	8b cb		 mov	 ecx, ebx
  00332	0f ac c1 10	 shrd	 ecx, eax, 16
  00336	c1 e8 10	 shr	 eax, 16			; 00000010H
  00339	88 4e 31	 mov	 BYTE PTR [esi+49], cl
  0033c	8b c3		 mov	 eax, ebx
  0033e	0f ac d0 08	 shrd	 eax, edx, 8
  00342	88 46 32	 mov	 BYTE PTR [esi+50], al
  00345	88 5e 33	 mov	 BYTE PTR [esi+51], bl

; 877  : 
; 878  : 	// Encrypted area size
; 879  : 	cryptoInfo->EncryptedAreaLength.Value = encryptedAreaLength;

  00348	8b 5d 40	 mov	 ebx, DWORD PTR _encryptedAreaLength$[ebp]

; 880  : 	mputInt64 (p, encryptedAreaLength);

  0034b	8b cb		 mov	 ecx, ebx
  0034d	c1 ea 08	 shr	 edx, 8
  00350	8b 55 44	 mov	 edx, DWORD PTR _encryptedAreaLength$[ebp+4]
  00353	8b c2		 mov	 eax, edx
  00355	c1 e8 18	 shr	 eax, 24			; 00000018H
  00358	89 9f 00 1f 00
	00		 mov	 DWORD PTR [edi+7936], ebx
  0035e	89 97 04 1f 00
	00		 mov	 DWORD PTR [edi+7940], edx
  00364	88 46 34	 mov	 BYTE PTR [esi+52], al
  00367	8b c2		 mov	 eax, edx
  00369	c1 e8 10	 shr	 eax, 16			; 00000010H
  0036c	88 46 35	 mov	 BYTE PTR [esi+53], al
  0036f	8b c2		 mov	 eax, edx
  00371	c1 e8 08	 shr	 eax, 8
  00374	88 46 36	 mov	 BYTE PTR [esi+54], al
  00377	8b c2		 mov	 eax, edx
  00379	0f ac c1 18	 shrd	 ecx, eax, 24
  0037d	88 56 37	 mov	 BYTE PTR [esi+55], dl
  00380	c1 e8 18	 shr	 eax, 24			; 00000018H
  00383	88 4e 38	 mov	 BYTE PTR [esi+56], cl
  00386	8b c2		 mov	 eax, edx
  00388	8b cb		 mov	 ecx, ebx
  0038a	0f ac c1 10	 shrd	 ecx, eax, 16
  0038e	c1 e8 10	 shr	 eax, 16			; 00000010H
  00391	88 4e 39	 mov	 BYTE PTR [esi+57], cl
  00394	8b c3		 mov	 eax, ebx

; 881  : 
; 882  : 	// Flags
; 883  : 	cryptoInfo->HeaderFlags = headerFlags;

  00396	8b 4d 4c	 mov	 ecx, DWORD PTR _headerFlags$[ebp]
  00399	0f ac d0 08	 shrd	 eax, edx, 8
  0039d	88 46 3a	 mov	 BYTE PTR [esi+58], al

; 884  : 	mputLong (p, headerFlags);

  003a0	8b c1		 mov	 eax, ecx
  003a2	c1 e8 18	 shr	 eax, 24			; 00000018H
  003a5	88 5e 3b	 mov	 BYTE PTR [esi+59], bl
  003a8	89 8f 08 1f 00
	00		 mov	 DWORD PTR [edi+7944], ecx
  003ae	88 46 3c	 mov	 BYTE PTR [esi+60], al
  003b1	8b c1		 mov	 eax, ecx
  003b3	c1 e8 10	 shr	 eax, 16			; 00000010H
  003b6	88 46 3d	 mov	 BYTE PTR [esi+61], al
  003b9	8b c1		 mov	 eax, ecx
  003bb	c1 e8 08	 shr	 eax, 8
  003be	88 46 3e	 mov	 BYTE PTR [esi+62], al
  003c1	88 4e 3f	 mov	 BYTE PTR [esi+63], cl

; 885  : 
; 886  : 	// Sector size
; 887  : 	if (sectorSize < GST_MIN_VOLUME_SECTOR_SIZE
; 888  : 		|| sectorSize > GST_MAX_VOLUME_SECTOR_SIZE
; 889  : 		|| sectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  003c4	8b 4d 50	 mov	 ecx, DWORD PTR _sectorSize$[ebp]
  003c7	c1 ea 08	 shr	 edx, 8
  003ca	8d 81 00 fe ff
	ff		 lea	 eax, DWORD PTR [ecx-512]
  003d0	3d 00 0e 00 00	 cmp	 eax, 3584		; 00000e00H
  003d5	77 08		 ja	 SHORT $LN34@CreateVolu
  003d7	f7 c1 ff 01 00
	00		 test	 ecx, 511		; 000001ffH
  003dd	74 07		 je	 SHORT $LN33@CreateVolu
$LN34@CreateVolu:

; 890  : 	{
; 891  : 		GST_THROW_FATAL_EXCEPTION;

  003df	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN33@CreateVolu:

; 892  : 	}
; 893  : 
; 894  : 	cryptoInfo->SectorSize = sectorSize;

  003e6	89 8f e8 1e 00
	00		 mov	 DWORD PTR [edi+7912], ecx

; 895  : 	mputLong (p, sectorSize);

  003ec	8b c1		 mov	 eax, ecx
  003ee	c1 e8 18	 shr	 eax, 24			; 00000018H
  003f1	88 46 40	 mov	 BYTE PTR [esi+64], al
  003f4	8b c1		 mov	 eax, ecx
  003f6	c1 e8 10	 shr	 eax, 16			; 00000010H
  003f9	88 46 41	 mov	 BYTE PTR [esi+65], al
  003fc	8b c1		 mov	 eax, ecx
  003fe	c1 e8 08	 shr	 eax, 8

; 896  : 
; 897  : 	// CRC of the header fields
; 898  : 	x = GetCrc32 (header + GST_HEADER_OFFSET_MAGIC, GST_HEADER_OFFSET_HEADER_CRC - GST_HEADER_OFFSET_MAGIC);

  00401	68 bc 00 00 00	 push	 188			; 000000bcH
  00406	88 46 42	 mov	 BYTE PTR [esi+66], al
  00409	56		 push	 esi
  0040a	88 4e 43	 mov	 BYTE PTR [esi+67], cl
  0040d	e8 00 00 00 00	 call	 _GetCrc32

; 899  : 	p = header + GST_HEADER_OFFSET_HEADER_CRC;

  00412	8b 7d 0c	 mov	 edi, DWORD PTR _header$[ebp]
  00415	8b d8		 mov	 ebx, eax

; 900  : 	mputLong (p, x);

  00417	8b cb		 mov	 ecx, ebx
  00419	c1 f8 08	 sar	 eax, 8
  0041c	c1 f9 18	 sar	 ecx, 24			; 00000018H

; 901  : 
; 902  : 	// The master key data
; 903  : 	memcpy (header + HEADER_MASTER_KEYDATA_OFFSET, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);

  0041f	be 88 00 00 00	 mov	 esi, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  00424	88 8f fc 00 00
	00		 mov	 BYTE PTR [edi+252], cl
  0042a	8b cb		 mov	 ecx, ebx
  0042c	c1 f9 10	 sar	 ecx, 16			; 00000010H
  0042f	88 8f fd 00 00
	00		 mov	 BYTE PTR [edi+253], cl
  00435	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0043a	88 87 fe 00 00
	00		 mov	 BYTE PTR [edi+254], al
  00440	88 9f ff 00 00
	00		 mov	 BYTE PTR [edi+255], bl
  00446	81 c7 00 01 00
	00		 add	 edi, 256		; 00000100H

; 904  : 
; 905  : 
; 906  : 	/* Header encryption */
; 907  : 
; 908  : 	switch (mode)
; 909  : 	{
; 910  : 	default:
; 911  : 		// The secondary key (if cascade, multiple concatenated)
; 912  : 		memcpy (cryptoInfo->k2, dk + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  0044c	8b 5d fc	 mov	 ebx, DWORD PTR _cryptoInfo$1$[ebp]
  0044f	f3 a5		 rep movsd
  00451	ff 33		 push	 DWORD PTR [ebx]
  00453	8d b3 50 1d 00
	00		 lea	 esi, DWORD PTR [ebx+7504]
  00459	e8 00 00 00 00	 call	 _EAGetKeySize
  0045e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00461	50		 push	 eax
  00462	ff 33		 push	 DWORD PTR [ebx]
  00464	e8 00 00 00 00	 call	 _EAGetKeySize
  00469	83 c4 04	 add	 esp, 4
  0046c	05 00 00 00 00	 add	 eax, OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  00471	50		 push	 eax
  00472	56		 push	 esi
  00473	e8 00 00 00 00	 call	 _memcpy

; 913  : 		primaryKeyOffset = 0;
; 914  : 	}
; 915  : 
; 916  : 	retVal = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);

  00478	8d 73 08	 lea	 esi, DWORD PTR [ebx+8]
  0047b	56		 push	 esi
  0047c	68 00 00 00 00	 push	 OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  00481	ff 33		 push	 DWORD PTR [ebx]
  00483	e8 00 00 00 00	 call	 _EAInit
  00488	83 c4 18	 add	 esp, 24			; 00000018H

; 917  : 	if (retVal != ERR_SUCCESS)

  0048b	85 c0		 test	 eax, eax
  0048d	0f 85 ef 00 00
	00		 jne	 $LN92@CreateVolu

; 918  : 		return retVal;
; 919  : 
; 920  : 	// Mode of operation
; 921  : 	if (!EAInitMode (cryptoInfo))

  00493	53		 push	 ebx
  00494	e8 00 00 00 00	 call	 _EAInitMode
  00499	83 c4 04	 add	 esp, 4
  0049c	85 c0		 test	 eax, eax
  0049e	74 6e		 je	 SHORT $LN95@CreateVolu

; 922  : 		return ERR_OUTOFMEMORY;
; 923  : 
; 924  : 
; 925  : 	// Encrypt the entire header (except the salt)
; 926  : 	EncryptBuffer (header + HEADER_ENCRYPTED_DATA_OFFSET,

  004a0	53		 push	 ebx
  004a1	6a 00		 push	 0
  004a3	68 c0 01 00 00	 push	 448			; 000001c0H
  004a8	ff 75 18	 push	 DWORD PTR tv698[ebp]
  004ab	e8 00 00 00 00	 call	 _EncryptBuffer

; 927  : 		HEADER_ENCRYPTED_DATA_SIZE,
; 928  : 		cryptoInfo);
; 929  : 
; 930  : 
; 931  : 	/* cryptoInfo setup for further use (disk format) */
; 932  : 
; 933  : 	// Init with the master key(s) 
; 934  : 	retVal = EAInit (cryptoInfo->ea, keyInfo.master_keydata + primaryKeyOffset, cryptoInfo->ks);

  004b0	56		 push	 esi
  004b1	68 88 00 00 00	 push	 OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  004b6	ff 33		 push	 DWORD PTR [ebx]
  004b8	e8 00 00 00 00	 call	 _EAInit
  004bd	83 c4 1c	 add	 esp, 28			; 0000001cH

; 935  : 	if (retVal != ERR_SUCCESS)

  004c0	85 c0		 test	 eax, eax
  004c2	0f 85 ba 00 00
	00		 jne	 $LN92@CreateVolu

; 936  : 		return retVal;
; 937  : 
; 938  : 	memcpy (cryptoInfo->master_keydata, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);
; 939  : 
; 940  : 	switch (cryptoInfo->mode)
; 941  : 	{
; 942  : 	default:
; 943  : 		// The secondary master key (if cascade, multiple concatenated)
; 944  : 		memcpy (cryptoInfo->k2, keyInfo.master_keydata + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  004c8	ff 33		 push	 DWORD PTR [ebx]
  004ca	8d bb 50 1c 00
	00		 lea	 edi, DWORD PTR [ebx+7248]
  004d0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  004d5	be 88 00 00 00	 mov	 esi, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  004da	f3 a5		 rep movsd
  004dc	e8 00 00 00 00	 call	 _EAGetKeySize
  004e1	83 c4 04	 add	 esp, 4
  004e4	50		 push	 eax
  004e5	ff 33		 push	 DWORD PTR [ebx]
  004e7	e8 00 00 00 00	 call	 _EAGetKeySize
  004ec	83 c4 04	 add	 esp, 4
  004ef	05 88 00 00 00	 add	 eax, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9+136
  004f4	50		 push	 eax
  004f5	8d 83 50 1d 00
	00		 lea	 eax, DWORD PTR [ebx+7504]
  004fb	50		 push	 eax
  004fc	e8 00 00 00 00	 call	 _memcpy

; 945  : 	}
; 946  : 
; 947  : 	// Mode of operation
; 948  : 	if (!EAInitMode (cryptoInfo))

  00501	53		 push	 ebx
  00502	e8 00 00 00 00	 call	 _EAInitMode
  00507	83 c4 10	 add	 esp, 16			; 00000010H
  0050a	85 c0		 test	 eax, eax
  0050c	75 0c		 jne	 SHORT $LN14@CreateVolu
$LN95@CreateVolu:
  0050e	5e		 pop	 esi
  0050f	5b		 pop	 ebx

; 949  : 		return ERR_OUTOFMEMORY;

  00510	b8 02 00 00 00	 mov	 eax, 2
  00515	5f		 pop	 edi

; 999  : }

  00516	8b e5		 mov	 esp, ebp
  00518	5d		 pop	 ebp
  00519	c3		 ret	 0
$LN14@CreateVolu:

; 950  : 
; 951  : 
; 952  : #ifdef VOLFORMAT
; 953  : 	if (showKeys && !bInPlaceEncNonSys)
; 954  : 	{
; 955  : 		BOOL dots3 = FALSE;
; 956  : 		int i, j;
; 957  : 
; 958  : 		j = EAGetKeySize (ea);
; 959  : 
; 960  : 		if (j > NBR_KEY_BYTES_TO_DISPLAY)
; 961  : 		{
; 962  : 			dots3 = TRUE;
; 963  : 			j = NBR_KEY_BYTES_TO_DISPLAY;
; 964  : 		}
; 965  : 
; 966  : 		MasterKeyGUIView[0] = 0;
; 967  : 		for (i = 0; i < j; i++)
; 968  : 		{
; 969  : 			char tmp2[8] = {0};
; 970  : 			sprintf (tmp2, "%02X", (int) (unsigned char) keyInfo.master_keydata[i + primaryKeyOffset]);
; 971  : 			strcat (MasterKeyGUIView, tmp2);
; 972  : 		}
; 973  : 
; 974  : 		HeaderKeyGUIView[0] = 0;
; 975  : 		for (i = 0; i < NBR_KEY_BYTES_TO_DISPLAY; i++)
; 976  : 		{
; 977  : 			char tmp2[8];
; 978  : 			sprintf (tmp2, "%02X", (int) (unsigned char) dk[primaryKeyOffset + i]);
; 979  : 			strcat (HeaderKeyGUIView, tmp2);
; 980  : 		}
; 981  : 
; 982  : 		if (dots3)
; 983  : 		{
; 984  : 			DisplayPortionsOfKeys (hHeaderKey, hMasterKey, HeaderKeyGUIView, MasterKeyGUIView, !showKeys);
; 985  : 		}
; 986  : 		else
; 987  : 		{
; 988  : 			SendMessage (hMasterKey, WM_SETTEXT, 0, (LPARAM) MasterKeyGUIView);
; 989  : 			SendMessage (hHeaderKey, WM_SETTEXT, 0, (LPARAM) HeaderKeyGUIView);
; 990  : 		}
; 991  : 	}
; 992  : #endif	// #ifdef VOLFORMAT
; 993  : 
; 994  : 	burn (dk, sizeof(dk));

  0051a	b8 00 00 00 00	 mov	 eax, OFFSET ?dk@?1??CreateVolumeHeaderInMemory@@9@9
  0051f	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00524	8b f1		 mov	 esi, ecx
  00526	8b d0		 mov	 edx, eax
  00528	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL49@CreateVolu:
  00530	c6 02 00	 mov	 BYTE PTR [edx], 0
  00533	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00536	83 ee 01	 sub	 esi, 1
  00539	75 f5		 jne	 SHORT $LL49@CreateVolu
  0053b	0f 1f 44 00 00	 npad	 5
$LL15@CreateVolu:
  00540	c6 00 00	 mov	 BYTE PTR [eax], 0
  00543	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00546	83 e9 01	 sub	 ecx, 1
  00549	75 f5		 jne	 SHORT $LL15@CreateVolu

; 995  : 	burn (&keyInfo, sizeof (keyInfo));

  0054b	b8 00 00 00 00	 mov	 eax, OFFSET ?keyInfo@?1??CreateVolumeHeaderInMemory@@9@9
  00550	b9 88 01 00 00	 mov	 ecx, 392		; 00000188H
  00555	8b f1		 mov	 esi, ecx
  00557	8b d0		 mov	 edx, eax
  00559	0f 1f 80 00 00
	00 00		 npad	 7
$LL53@CreateVolu:
  00560	c6 02 00	 mov	 BYTE PTR [edx], 0
  00563	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00566	83 ee 01	 sub	 esi, 1
  00569	75 f5		 jne	 SHORT $LL53@CreateVolu
  0056b	0f 1f 44 00 00	 npad	 5
$LL20@CreateVolu:
  00570	c6 00 00	 mov	 BYTE PTR [eax], 0
  00573	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00576	83 e9 01	 sub	 ecx, 1
  00579	75 f5		 jne	 SHORT $LL20@CreateVolu

; 996  : 
; 997  : 	*retInfo = cryptoInfo;

  0057b	8b 45 24	 mov	 eax, DWORD PTR _retInfo$[ebp]
  0057e	89 18		 mov	 DWORD PTR [eax], ebx

; 998  : 	return 0;

  00580	33 c0		 xor	 eax, eax
$LN92@CreateVolu:
  00582	5e		 pop	 esi
  00583	5b		 pop	 ebx
  00584	5f		 pop	 edi

; 999  : }

  00585	8b e5		 mov	 esp, ebp
  00587	5d		 pop	 ebp
  00588	c3		 ret	 0
_CreateVolumeHeaderInMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _ReadVolumeHeader
_TEXT	SEGMENT
_keyDerivationWorkItems$ = -1212			; size = 4
_outstandingWorkItemCount$ = -1212			; size = 4
_encryptionThreadCount$1$ = -1208			; size = 4
_retHeaderCryptoInfo$GSCopy$1$ = -1204			; size = 4
_noOutstandingWorkItemEvent$ = -1200			; size = 4
_pkcs5_prf$1$ = -1196					; size = 4
_enqPkcs5Prf$1$ = -1192					; size = 4
_item$1$ = -1188					; size = 4
_status$1$ = -1188					; size = 4
_keyDerivationCompletedEvent$ = -1184			; size = 4
_encryptedHeader$GSCopy$1$ = -1180			; size = 4
_keyDerivationWorkItems$1$ = -1176			; size = 4
_queuedWorkItems$1$ = -1172				; size = 4
_retInfo$GSCopy$1$ = -1168				; size = 4
_keyInfo$ = -1164					; size = 392
_dk$ = -772						; size = 256
_header$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_bBoot$ = 8						; size = 4
_encryptedHeader$ = 12					; size = 4
_password$ = 16						; size = 4
_retInfo$ = 20						; size = 4
_retHeaderCryptoInfo$ = 24				; size = 4
_ReadVolumeHeader PROC					; COMDAT

; 227  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec bc 04 00
	00		 sub	 esp, 1212		; 000004bcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _encryptedHeader$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 18	 mov	 ebx, DWORD PTR _retHeaderCryptoInfo$[ebp]
  0001a	56		 push	 esi
  0001b	89 85 64 fb ff
	ff		 mov	 DWORD PTR _encryptedHeader$GSCopy$1$[ebp], eax
  00021	8b 45 14	 mov	 eax, DWORD PTR _retInfo$[ebp]
  00024	57		 push	 edi
  00025	8b 7d 10	 mov	 edi, DWORD PTR _password$[ebp]
  00028	89 85 70 fb ff
	ff		 mov	 DWORD PTR _retInfo$GSCopy$1$[ebp], eax
  0002e	89 9d 4c fb ff
	ff		 mov	 DWORD PTR _retHeaderCryptoInfo$GSCopy$1$[ebp], ebx

; 228  : 	char header[GST_VOLUME_HEADER_EFFECTIVE_SIZE];
; 229  : 	KEY_INFO keyInfo;
; 230  : 	PCRYPTO_INFO cryptoInfo;
; 231  : 	char dk[MASTER_KEYDATA_SIZE];
; 232  : 	int enqPkcs5Prf, pkcs5_prf;
; 233  : 	uint16 headerVersion;
; 234  : 	int status = ERR_PARAMETER_INCORRECT;
; 235  : 	int primaryKeyOffset;
; 236  : 
; 237  : 	GST_EVENT keyDerivationCompletedEvent;
; 238  : 	GST_EVENT noOutstandingWorkItemEvent;
; 239  : 	KeyDerivationWorkItem *keyDerivationWorkItems;
; 240  : 	KeyDerivationWorkItem *item;
; 241  : 	int pkcs5PrfCount = LAST_PRF_ID - FIRST_PRF_ID + 1;
; 242  : 	size_t encryptionThreadCount = GetEncryptionThreadCount();

  00034	e8 00 00 00 00	 call	 _GetEncryptionThreadCount

; 243  : 	size_t queuedWorkItems = 0;

  00039	33 c9		 xor	 ecx, ecx
  0003b	8b f0		 mov	 esi, eax
  0003d	89 b5 48 fb ff
	ff		 mov	 DWORD PTR _encryptionThreadCount$1$[ebp], esi
  00043	89 8d 6c fb ff
	ff		 mov	 DWORD PTR _queuedWorkItems$1$[ebp], ecx

; 244  : 	LONG outstandingWorkItemCount = 0;

  00049	89 8d 44 fb ff
	ff		 mov	 DWORD PTR _outstandingWorkItemCount$[ebp], ecx

; 245  : 	int i;
; 246  : 
; 247  : 	if (retHeaderCryptoInfo != NULL)

  0004f	85 db		 test	 ebx, ebx
  00051	75 17		 jne	 SHORT $LN45@ReadVolume

; 248  : 	{
; 249  : 		cryptoInfo = retHeaderCryptoInfo;
; 250  : 	}
; 251  : 	else
; 252  : 	{
; 253  : 		cryptoInfo = *retInfo = crypto_open ();

  00053	e8 00 00 00 00	 call	 _crypto_open
  00058	8b d8		 mov	 ebx, eax
  0005a	8b 85 70 fb ff
	ff		 mov	 eax, DWORD PTR _retInfo$GSCopy$1$[ebp]
  00060	89 18		 mov	 DWORD PTR [eax], ebx

; 254  : 		if (cryptoInfo == NULL)

  00062	85 db		 test	 ebx, ebx
  00064	0f 84 86 00 00
	00		 je	 $LN233@ReadVolume
$LN45@ReadVolume:

; 255  : 			return ERR_OUTOFMEMORY;
; 256  : 	}
; 257  : 
; 258  : 	if (encryptionThreadCount > 1)

  0006a	83 fe 01	 cmp	 esi, 1
  0006d	0f 86 93 00 00
	00		 jbe	 $LN216@ReadVolume

; 259  : 	{
; 260  : 		keyDerivationWorkItems = GSTalloc (sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  00073	68 24 03 00 00	 push	 804			; 00000324H
  00078	e8 00 00 00 00	 call	 _malloc
  0007d	83 c4 04	 add	 esp, 4
  00080	89 85 68 fb ff
	ff		 mov	 DWORD PTR _keyDerivationWorkItems$1$[ebp], eax

; 261  : 		if (!keyDerivationWorkItems)

  00086	85 c0		 test	 eax, eax
  00088	74 66		 je	 SHORT $LN233@ReadVolume

; 262  : 			return ERR_OUTOFMEMORY;
; 263  : 
; 264  : 		for (i = 0; i < pkcs5PrfCount; ++i)
; 265  : 			keyDerivationWorkItems[i].Free = TRUE;
; 266  : 
; 267  : #ifdef DEVICE_DRIVER
; 268  : 		KeInitializeEvent (&keyDerivationCompletedEvent, SynchronizationEvent, FALSE);
; 269  : 		KeInitializeEvent (&noOutstandingWorkItemEvent, SynchronizationEvent, TRUE);
; 270  : #else
; 271  : 		keyDerivationCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);

  0008a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CreateEventA@16
  00090	6a 00		 push	 0
  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	6a 00		 push	 0
  00098	c7 80 00 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+256], 1
  000a2	c7 80 0c 02 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+524], 1
  000ac	c7 80 18 03 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+792], 1
  000b6	ff d6		 call	 esi
  000b8	89 85 60 fb ff
	ff		 mov	 DWORD PTR _keyDerivationCompletedEvent$[ebp], eax

; 272  : 		if (!keyDerivationCompletedEvent)

  000be	85 c0		 test	 eax, eax
  000c0	74 20		 je	 SHORT $LN234@ReadVolume

; 273  : 		{
; 274  : 			GSTfree (keyDerivationWorkItems);
; 275  : 			return ERR_OUTOFMEMORY;
; 276  : 		}
; 277  : 
; 278  : 		noOutstandingWorkItemEvent = CreateEvent (NULL, FALSE, TRUE, NULL);

  000c2	6a 00		 push	 0
  000c4	6a 01		 push	 1
  000c6	6a 00		 push	 0
  000c8	6a 00		 push	 0
  000ca	ff d6		 call	 esi
  000cc	89 85 50 fb ff
	ff		 mov	 DWORD PTR _noOutstandingWorkItemEvent$[ebp], eax

; 279  : 		if (!noOutstandingWorkItemEvent)

  000d2	85 c0		 test	 eax, eax
  000d4	75 3c		 jne	 SHORT $LN49@ReadVolume

; 280  : 		{
; 281  : 			CloseHandle (keyDerivationCompletedEvent);

  000d6	ff b5 60 fb ff
	ff		 push	 DWORD PTR _keyDerivationCompletedEvent$[ebp]
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN234@ReadVolume:

; 282  : 			GSTfree (keyDerivationWorkItems);

  000e2	ff b5 68 fb ff
	ff		 push	 DWORD PTR _keyDerivationWorkItems$1$[ebp]
  000e8	e8 00 00 00 00	 call	 _free
  000ed	83 c4 04	 add	 esp, 4
$LN233@ReadVolume:

; 283  : 			return ERR_OUTOFMEMORY;

  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	b8 02 00 00 00	 mov	 eax, 2
  000f7	5b		 pop	 ebx

; 586  : #endif
; 587  : 	}
; 588  : 
; 589  : 	return status;
; 590  : }

  000f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fb	33 cd		 xor	 ecx, ebp
  000fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
$LN216@ReadVolume:

; 283  : 			return ERR_OUTOFMEMORY;

  00106	8b 85 44 fb ff
	ff		 mov	 eax, DWORD PTR _keyDerivationWorkItems$[ebp]
  0010c	89 85 68 fb ff
	ff		 mov	 DWORD PTR _keyDerivationWorkItems$1$[ebp], eax
$LN49@ReadVolume:

; 284  : 		}
; 285  : #endif
; 286  : 	}
; 287  : 		
; 288  : #ifndef DEVICE_DRIVER
; 289  : 	VirtualLock (&keyInfo, sizeof (keyInfo));

  00112	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualLock@8
  00118	8d 85 74 fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp]
  0011e	68 88 01 00 00	 push	 392			; 00000188H
  00123	50		 push	 eax
  00124	ff d6		 call	 esi

; 290  : 	VirtualLock (&dk, sizeof (dk));

  00126	68 00 01 00 00	 push	 256			; 00000100H
  0012b	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  00131	50		 push	 eax
  00132	ff d6		 call	 esi

; 291  : #endif
; 292  : 
; 293  : 	crypto_loadkey (&keyInfo, password->Text, (int) password->Length);

  00134	ff 37		 push	 DWORD PTR [edi]
  00136	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00139	50		 push	 eax
  0013a	8d 85 74 fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp]
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 _crypto_loadkey

; 294  : 
; 295  : 	// PKCS5 is used to derive the primary header key(s) and secondary header key(s) (XTS mode) from the password
; 296  : 	memcpy (keyInfo.salt, encryptedHeader + HEADER_SALT_OFFSET, PKCS5_SALT_SIZE);

  00146	8b b5 64 fb ff
	ff		 mov	 esi, DWORD PTR _encryptedHeader$GSCopy$1$[ebp]
  0014c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 297  : 
; 298  : 	// Test all available PKCS5 PRFs
; 299  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  0014f	bf 01 00 00 00	 mov	 edi, 1
  00154	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  00157	0f 11 85 bc fb
	ff ff		 movups	 XMMWORD PTR _keyInfo$[ebp+72], xmm0
  0015e	0f 10 46 10	 movups	 xmm0, XMMWORD PTR [esi+16]
  00162	0f 11 85 cc fb
	ff ff		 movups	 XMMWORD PTR _keyInfo$[ebp+88], xmm0
  00169	0f 10 46 20	 movups	 xmm0, XMMWORD PTR [esi+32]
  0016d	0f 11 85 dc fb
	ff ff		 movups	 XMMWORD PTR _keyInfo$[ebp+104], xmm0
  00174	0f 10 46 30	 movups	 xmm0, XMMWORD PTR [esi+48]
  00178	0f 11 85 ec fb
	ff ff		 movups	 XMMWORD PTR _keyInfo$[ebp+120], xmm0
$LN232@ReadVolume:
  0017f	8b 95 6c fb ff
	ff		 mov	 edx, DWORD PTR _queuedWorkItems$1$[ebp]
  00185	89 bd 58 fb ff
	ff		 mov	 DWORD PTR _enqPkcs5Prf$1$[ebp], edi
  0018b	83 ff 03	 cmp	 edi, 3
  0018e	7e 08		 jle	 SHORT $LN50@ReadVolume
  00190	85 d2		 test	 edx, edx
  00192	0f 84 fb 03 00
	00		 je	 $LN6@ReadVolume
$LN50@ReadVolume:

; 300  : 	{
; 301  : 
; 302  : 		if (encryptionThreadCount > 1)

  00198	8b 85 48 fb ff
	ff		 mov	 eax, DWORD PTR _encryptionThreadCount$1$[ebp]
  0019e	83 f8 01	 cmp	 eax, 1
  001a1	0f 86 4e 01 00
	00		 jbe	 $LN51@ReadVolume

; 303  : 		{
; 304  : 			// Enqueue key derivation on thread pool
; 305  : 			if (queuedWorkItems < encryptionThreadCount && enqPkcs5Prf <= LAST_PRF_ID)

  001a7	3b d0		 cmp	 edx, eax
  001a9	0f 83 9c 00 00
	00		 jae	 $LN53@ReadVolume
  001af	83 ff 03	 cmp	 edi, 3
  001b2	0f 8f 93 00 00
	00		 jg	 $LN53@ReadVolume

; 306  : 			{
; 307  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  001b8	8b 85 68 fb ff
	ff		 mov	 eax, DWORD PTR _keyDerivationWorkItems$1$[ebp]
  001be	33 c9		 xor	 ecx, ecx
$LL10@ReadVolume:

; 308  : 				{
; 309  : 					item = &keyDerivationWorkItems[i];
; 310  : 					if (item->Free)

  001c0	83 b8 00 01 00
	00 00		 cmp	 DWORD PTR [eax+256], 0
  001c7	75 0d		 jne	 SHORT $LN143@ReadVolume

; 306  : 			{
; 307  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  001c9	41		 inc	 ecx
  001ca	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  001cf	83 f9 03	 cmp	 ecx, 3
  001d2	7c ec		 jl	 SHORT $LL10@ReadVolume

; 435  : 				
; 436  : 				if (headerVersion > VOLUME_HEADER_VERSION)

  001d4	eb 6a		 jmp	 SHORT $LN9@ReadVolume
$LN143@ReadVolume:

; 311  : 					{
; 312  : 						item->Free = FALSE;
; 313  : 						item->KeyReady = FALSE;
; 314  : 						item->Pkcs5Prf = enqPkcs5Prf;
; 315  : 
; 316  : 						EncryptionThreadPoolBeginKeyDerivation (&keyDerivationCompletedEvent, &noOutstandingWorkItemEvent,

  001d6	50		 push	 eax
  001d7	ff 75 08	 push	 DWORD PTR _bBoot$[ebp]
  001da	8d b0 04 01 00
	00		 lea	 esi, DWORD PTR [eax+260]
  001e0	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0
  001ea	57		 push	 edi
  001eb	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  001f1	89 b8 08 01 00
	00		 mov	 DWORD PTR [eax+264], edi
  001f7	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count
  001fc	83 c4 08	 add	 esp, 8
  001ff	50		 push	 eax
  00200	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  00206	50		 push	 eax
  00207	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  0020d	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  00213	50		 push	 eax
  00214	57		 push	 edi
  00215	8d 85 44 fb ff
	ff		 lea	 eax, DWORD PTR _outstandingWorkItemCount$[ebp]
  0021b	50		 push	 eax
  0021c	56		 push	 esi
  0021d	8d 85 50 fb ff
	ff		 lea	 eax, DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  00223	50		 push	 eax
  00224	8d 85 60 fb ff
	ff		 lea	 eax, DWORD PTR _keyDerivationCompletedEvent$[ebp]
  0022a	50		 push	 eax
  0022b	e8 00 00 00 00	 call	 _EncryptionThreadPoolBeginKeyDerivation

; 317  : 							&item->KeyReady, &outstandingWorkItemCount, enqPkcs5Prf, keyInfo.userKey,
; 318  : 							keyInfo.keyLength, keyInfo.salt, get_pkcs5_iteration_count (enqPkcs5Prf, bBoot), item->DerivedKey);
; 319  : 						
; 320  : 						++queuedWorkItems;

  00230	8b 95 6c fb ff
	ff		 mov	 edx, DWORD PTR _queuedWorkItems$1$[ebp]
  00236	83 c4 28	 add	 esp, 40			; 00000028H
  00239	42		 inc	 edx
  0023a	89 95 6c fb ff
	ff		 mov	 DWORD PTR _queuedWorkItems$1$[ebp], edx
$LN9@ReadVolume:

; 321  : 						break;
; 322  : 					}
; 323  : 				}
; 324  : 
; 325  : 				if (enqPkcs5Prf < LAST_PRF_ID)

  00240	83 ff 03	 cmp	 edi, 3
  00243	0f 8c 3e 03 00
	00		 jl	 $LN5@ReadVolume

; 326  : 					continue;
; 327  : 			}

  00249	eb 07		 jmp	 SHORT $LN133@ReadVolume
$LN53@ReadVolume:

; 328  : 			else
; 329  : 				--enqPkcs5Prf;

  0024b	4f		 dec	 edi
  0024c	89 bd 58 fb ff
	ff		 mov	 DWORD PTR _enqPkcs5Prf$1$[ebp], edi
$LN133@ReadVolume:

; 330  : 
; 331  : 			// Wait for completion of a key derivation
; 332  : 			while (queuedWorkItems > 0)

  00252	85 d2		 test	 edx, edx
  00254	0f 84 2d 03 00
	00		 je	 $LN5@ReadVolume
  0025a	8b bd 68 fb ff
	ff		 mov	 edi, DWORD PTR _keyDerivationWorkItems$1$[ebp]
$LL11@ReadVolume:

; 333  : 			{
; 334  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  00260	33 d2		 xor	 edx, edx
  00262	8d 8f 04 01 00
	00		 lea	 ecx, DWORD PTR [edi+260]
  00268	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL15@ReadVolume:

; 335  : 				{
; 336  : 					item = &keyDerivationWorkItems[i];
; 337  : 					if (!item->Free && InterlockedExchangeAdd (&item->KeyReady, 0) == TRUE)

  00270	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  00274	8d b1 fc fe ff
	ff		 lea	 esi, DWORD PTR [ecx-260]
  0027a	89 b5 5c fb ff
	ff		 mov	 DWORD PTR _item$1$[ebp], esi
  00280	75 0b		 jne	 SHORT $LN13@ReadVolume
  00282	33 c0		 xor	 eax, eax
  00284	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  00288	83 f8 01	 cmp	 eax, 1
  0028b	74 1c		 je	 SHORT $LN144@ReadVolume
$LN13@ReadVolume:

; 333  : 			{
; 334  : 				for (i = 0; i < pkcs5PrfCount; ++i)

  0028d	42		 inc	 edx
  0028e	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  00294	83 fa 03	 cmp	 edx, 3
  00297	7c d7		 jl	 SHORT $LL15@ReadVolume

; 345  : 						goto KeyReady;
; 346  : 					}
; 347  : 				}
; 348  : 
; 349  : 				if (queuedWorkItems > 0)
; 350  : 					GST_WAIT_EVENT (keyDerivationCompletedEvent);

  00299	6a ff		 push	 -1
  0029b	ff b5 60 fb ff
	ff		 push	 DWORD PTR _keyDerivationCompletedEvent$[ebp]
  002a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  002a7	eb b7		 jmp	 SHORT $LL11@ReadVolume
$LN144@ReadVolume:

; 338  : 					{
; 339  : 						pkcs5_prf = item->Pkcs5Prf;

  002a9	8b 86 08 01 00
	00		 mov	 eax, DWORD PTR [esi+264]

; 340  : 						keyInfo.noIterations = get_pkcs5_iteration_count (pkcs5_prf, bBoot);

  002af	ff 75 08	 push	 DWORD PTR _bBoot$[ebp]
  002b2	89 85 54 fb ff
	ff		 mov	 DWORD PTR _pkcs5_prf$1$[ebp], eax
  002b8	50		 push	 eax
  002b9	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count
  002be	89 85 74 fb ff
	ff		 mov	 DWORD PTR _keyInfo$[ebp], eax

; 341  : 						memcpy (dk, item->DerivedKey, sizeof (dk));

  002c4	8d bd fc fc ff
	ff		 lea	 edi, DWORD PTR _dk$[ebp]

; 342  : 
; 343  : 						item->Free = TRUE;

  002ca	8b 85 5c fb ff
	ff		 mov	 eax, DWORD PTR _item$1$[ebp]
  002d0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002d5	83 c4 08	 add	 esp, 8

; 344  : 						--queuedWorkItems;

  002d8	ff 8d 6c fb ff
	ff		 dec	 DWORD PTR _queuedWorkItems$1$[ebp]
  002de	f3 a5		 rep movsd
  002e0	c7 80 00 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+256], 1
$KeyReady$236:

; 351  : 			}
; 352  : 			continue;
; 353  : KeyReady:	;
; 354  : 		}

  002ea	8b b5 64 fb ff
	ff		 mov	 esi, DWORD PTR _encryptedHeader$GSCopy$1$[ebp]
  002f0	e9 ca 00 00 00	 jmp	 $LN16@ReadVolume
$LN51@ReadVolume:

; 355  : 		else
; 356  : 		{
; 357  : 			pkcs5_prf = enqPkcs5Prf;
; 358  : 			keyInfo.noIterations = get_pkcs5_iteration_count (enqPkcs5Prf, bBoot);

  002f5	ff 75 08	 push	 DWORD PTR _bBoot$[ebp]
  002f8	89 bd 54 fb ff
	ff		 mov	 DWORD PTR _pkcs5_prf$1$[ebp], edi
  002fe	57		 push	 edi
  002ff	e8 00 00 00 00	 call	 _get_pkcs5_iteration_count
  00304	89 85 74 fb ff
	ff		 mov	 DWORD PTR _keyInfo$[ebp], eax
  0030a	83 c4 08	 add	 esp, 8

; 359  : 
; 360  : 			switch (pkcs5_prf)

  0030d	8b c7		 mov	 eax, edi
  0030f	83 e8 01	 sub	 eax, 1
  00312	0f 84 76 00 00
	00		 je	 $LN60@ReadVolume
  00318	83 e8 01	 sub	 eax, 1
  0031b	74 41		 je	 SHORT $LN61@ReadVolume
  0031d	83 e8 01	 sub	 eax, 1
  00320	74 0c		 je	 SHORT $LN59@ReadVolume

; 374  : 			default:		
; 375  : 				// Unknown/wrong ID
; 376  : 				GST_THROW_FATAL_EXCEPTION;

  00322	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  00329	e9 91 00 00 00	 jmp	 $LN16@ReadVolume
$LN59@ReadVolume:

; 361  : 			{
; 362  : 			case WHIRLPOOL:
; 363  : 				derive_key_whirlpool (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,

  0032e	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00333	50		 push	 eax
  00334	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  0033a	50		 push	 eax
  0033b	ff b5 74 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp]
  00341	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  00347	6a 40		 push	 64			; 00000040H
  00349	50		 push	 eax
  0034a	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  00350	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  00356	50		 push	 eax
  00357	e8 00 00 00 00	 call	 _derive_key_whirlpool

; 364  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
; 365  : 				break;

  0035c	eb 5e		 jmp	 SHORT $LN231@ReadVolume
$LN61@ReadVolume:

; 368  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
; 369  : 				break;
; 370  : 			case GOSTHASH:
; 371  : 				derive_key_gosthash (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,

  0035e	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00363	50		 push	 eax
  00364	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  0036a	50		 push	 eax
  0036b	ff b5 74 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp]
  00371	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  00377	6a 40		 push	 64			; 00000040H
  00379	50		 push	 eax
  0037a	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  00380	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  00386	50		 push	 eax
  00387	e8 00 00 00 00	 call	 _derive_key_gosthash

; 372  : 					PKCS5_SALT_SIZE, keyInfo.noIterations, dk, GetMaxPkcs5OutSize());
; 373  : 				break;

  0038c	eb 2e		 jmp	 SHORT $LN231@ReadVolume
$LN60@ReadVolume:

; 366  : 			case STRIBOG:
; 367  : 				derive_key_stribog (keyInfo.userKey, keyInfo.keyLength, keyInfo.salt,

  0038e	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00393	50		 push	 eax
  00394	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  0039a	50		 push	 eax
  0039b	ff b5 74 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp]
  003a1	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+72]
  003a7	6a 40		 push	 64			; 00000040H
  003a9	50		 push	 eax
  003aa	ff b5 78 fb ff
	ff		 push	 DWORD PTR _keyInfo$[ebp+4]
  003b0	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+8]
  003b6	50		 push	 eax
  003b7	e8 00 00 00 00	 call	 _derive_key_stribog
$LN231@ReadVolume:
  003bc	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN16@ReadVolume:

; 377  : 			} 
; 378  : 		}
; 379  : 
; 380  : 		// Test all available modes of operation
; 381  : 		for (cryptoInfo->mode = FIRST_MODE_OF_OPERATION_ID;

  003bf	c7 43 04 01 00
	00 00		 mov	 DWORD PTR [ebx+4], 1
$LL20@ReadVolume:

; 384  : 		{
; 385  : 			switch (cryptoInfo->mode)
; 386  : 			{
; 387  : 			default:
; 388  : 				primaryKeyOffset = 0;
; 389  : 			}
; 390  : 
; 391  : 			// Test all available encryption algorithms
; 392  : 			for (cryptoInfo->ea = EAGetFirst ();

  003c6	e8 00 00 00 00	 call	 _EAGetFirst
  003cb	89 03		 mov	 DWORD PTR [ebx], eax

; 393  : 				cryptoInfo->ea != 0;

  003cd	85 c0		 test	 eax, eax
  003cf	0f 84 99 01 00
	00		 je	 $LN18@ReadVolume
$LL25@ReadVolume:

; 395  : 			{
; 396  : 				int blockSize;
; 397  : 
; 398  : 				if (!EAIsModeSupported (cryptoInfo->ea, cryptoInfo->mode))

  003d5	ff 73 04	 push	 DWORD PTR [ebx+4]
  003d8	ff 33		 push	 DWORD PTR [ebx]
  003da	e8 00 00 00 00	 call	 _EAIsModeSupported
  003df	83 c4 08	 add	 esp, 8
  003e2	85 c0		 test	 eax, eax
  003e4	0f 84 6a 01 00
	00		 je	 $LN23@ReadVolume

; 399  : 					continue;	// This encryption algorithm has never been available with this mode of operation
; 400  : 
; 401  : 				blockSize = CipherGetBlockSize (EAGetFirstCipher (cryptoInfo->ea));

  003ea	ff 33		 push	 DWORD PTR [ebx]
  003ec	e8 00 00 00 00	 call	 _EAGetFirstCipher
  003f1	50		 push	 eax
  003f2	e8 00 00 00 00	 call	 _CipherGetBlockSize

; 402  : 
; 403  : 				status = EAInit (cryptoInfo->ea, dk + primaryKeyOffset, cryptoInfo->ks);

  003f7	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  003fa	50		 push	 eax
  003fb	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  00401	50		 push	 eax
  00402	ff 33		 push	 DWORD PTR [ebx]
  00404	e8 00 00 00 00	 call	 _EAInit
  00409	83 c4 14	 add	 esp, 20			; 00000014H
  0040c	89 85 5c fb ff
	ff		 mov	 DWORD PTR _status$1$[ebp], eax

; 404  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  00412	83 f8 11	 cmp	 eax, 17			; 00000011H
  00415	0f 84 fb 03 00
	00		 je	 $LN223@ReadVolume

; 405  : 					goto err;
; 406  : 
; 407  : 				// Init objects related to the mode of operation
; 408  : 
; 409  : 				if (cryptoInfo->mode == XTS || cryptoInfo->mode == XTS8)

  0041b	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0041e	83 f9 01	 cmp	 ecx, 1
  00421	74 05		 je	 SHORT $LN67@ReadVolume
  00423	83 f9 02	 cmp	 ecx, 2
  00426	75 3b		 jne	 SHORT $LN68@ReadVolume
$LN67@ReadVolume:

; 410  : 				{
; 411  : 					// Copy the secondary key (if cascade, multiple concatenated)
; 412  : 					memcpy (cryptoInfo->k2, dk + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  00428	ff 33		 push	 DWORD PTR [ebx]
  0042a	e8 00 00 00 00	 call	 _EAGetKeySize
  0042f	83 c4 04	 add	 esp, 4
  00432	50		 push	 eax
  00433	ff 33		 push	 DWORD PTR [ebx]
  00435	e8 00 00 00 00	 call	 _EAGetKeySize
  0043a	83 c4 04	 add	 esp, 4
  0043d	8d 8d fc fc ff
	ff		 lea	 ecx, DWORD PTR _dk$[ebp]
  00443	03 c1		 add	 eax, ecx
  00445	50		 push	 eax
  00446	8d 83 50 1d 00
	00		 lea	 eax, DWORD PTR [ebx+7504]
  0044c	50		 push	 eax
  0044d	e8 00 00 00 00	 call	 _memcpy

; 413  : 
; 414  : 					// Secondary key schedule
; 415  : 					if (!EAInitMode (cryptoInfo))

  00452	53		 push	 ebx
  00453	e8 00 00 00 00	 call	 _EAInitMode
  00458	83 c4 10	 add	 esp, 16			; 00000010H
  0045b	85 c0		 test	 eax, eax
  0045d	0f 84 a1 03 00
	00		 je	 $LN146@ReadVolume
$LN68@ReadVolume:

; 416  : 					{
; 417  : 						status = ERR_MODE_INIT_FAILED;
; 418  : 						goto err;
; 419  : 					}
; 420  : 				}
; 421  : 
; 422  : 				// Copy the header for decryption
; 423  : 				memcpy (header, encryptedHeader, sizeof (header));

  00463	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00468	8d bd fc fd ff
	ff		 lea	 edi, DWORD PTR _header$[ebp]
  0046e	f3 a5		 rep movsd

; 424  : 
; 425  : 				// Try to decrypt header 
; 426  : 				if (cryptoInfo->mode == XTS || cryptoInfo->mode == XTS8)

  00470	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00473	83 f8 01	 cmp	 eax, 1
  00476	74 05		 je	 SHORT $LN70@ReadVolume
  00478	83 f8 02	 cmp	 eax, 2
  0047b	75 17		 jne	 SHORT $LN69@ReadVolume
$LN70@ReadVolume:

; 427  : 					DecryptBuffer(header + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);

  0047d	53		 push	 ebx
  0047e	6a 00		 push	 0
  00480	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR _header$[ebp+64]
  00486	68 c0 01 00 00	 push	 448			; 000001c0H
  0048b	50		 push	 eax
  0048c	e8 00 00 00 00	 call	 _DecryptBuffer
  00491	83 c4 10	 add	 esp, 16			; 00000010H
$LN69@ReadVolume:

; 428  : 
; 429  : 				// Magic 'TRUE'
; 430  : 				if (GetHeaderField32 (header, GST_HEADER_OFFSET_MAGIC) != 0x54525545)

  00494	ff b5 3c fe ff
	ff		 push	 DWORD PTR _header$[ebp+64]
  0049a	e8 00 00 00 00	 call	 _MirrorBytes32
  0049f	83 c4 04	 add	 esp, 4
  004a2	3d 45 55 52 54	 cmp	 eax, 1414681925		; 54525545H
  004a7	0f 85 a7 00 00
	00		 jne	 $LN23@ReadVolume

; 431  : 					continue;
; 432  : 
; 433  : 				// Header version
; 434  : 				headerVersion = GetHeaderField16 (header, GST_HEADER_OFFSET_VERSION);

  004ad	ff b5 40 fe ff
	ff		 push	 DWORD PTR _header$[ebp+68]
  004b3	e8 00 00 00 00	 call	 _MirrorBytes16
  004b8	0f b7 f8	 movzx	 edi, ax
  004bb	83 c4 04	 add	 esp, 4

; 435  : 				
; 436  : 				if (headerVersion > VOLUME_HEADER_VERSION)

  004be	b8 00 13 00 00	 mov	 eax, 4864		; 00001300H
  004c3	66 3b f8	 cmp	 di, ax
  004c6	0f 87 df 00 00
	00		 ja	 $LN147@ReadVolume

; 437  : 				{
; 438  : 					status = ERR_NEW_VERSION_REQUIRED;
; 439  : 					goto err;
; 440  : 				}
; 441  : 
; 442  : 				// Check CRC of the header fields
; 443  : 				if (!ReadVolumeHeaderRecoveryMode
; 444  : 					&& headerVersion >= 4
; 445  : 					&& GetHeaderField32 (header, GST_HEADER_OFFSET_HEADER_CRC) != GetCrc32 (header + GST_HEADER_OFFSET_MAGIC, GST_HEADER_OFFSET_HEADER_CRC - GST_HEADER_OFFSET_MAGIC))

  004cc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ReadVolumeHeaderRecoveryMode, 0
  004d3	75 2a		 jne	 SHORT $LN73@ReadVolume
  004d5	83 ff 04	 cmp	 edi, 4
  004d8	72 25		 jb	 SHORT $LN73@ReadVolume
  004da	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _header$[ebp+252]
  004e0	e8 00 00 00 00	 call	 _MirrorBytes32
  004e5	8b f0		 mov	 esi, eax
  004e7	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR _header$[ebp+64]
  004ed	68 bc 00 00 00	 push	 188			; 000000bcH
  004f2	50		 push	 eax
  004f3	e8 00 00 00 00	 call	 _GetCrc32
  004f8	83 c4 0c	 add	 esp, 12			; 0000000cH
  004fb	3b f0		 cmp	 esi, eax
  004fd	75 55		 jne	 SHORT $LN23@ReadVolume
$LN73@ReadVolume:

; 446  : 					continue;
; 447  : 
; 448  : 				// Required program version
; 449  : 				cryptoInfo->RequiredProgramVersion = GetHeaderField16 (header, GST_HEADER_OFFSET_REQUIRED_VERSION);

  004ff	ff b5 42 fe ff
	ff		 push	 DWORD PTR _header$[ebp+70]
  00505	e8 00 00 00 00	 call	 _MirrorBytes16
  0050a	83 c4 04	 add	 esp, 4
  0050d	66 89 83 e0 1e
	00 00		 mov	 WORD PTR [ebx+7904], ax

; 450  : 				cryptoInfo->LegacyVolume = cryptoInfo->RequiredProgramVersion < 0x600;

  00514	b9 00 06 00 00	 mov	 ecx, 1536		; 00000600H
  00519	66 3b c1	 cmp	 ax, cx
  0051c	1b c0		 sbb	 eax, eax
  0051e	f7 d8		 neg	 eax
  00520	89 83 e4 1e 00
	00		 mov	 DWORD PTR [ebx+7908], eax

; 451  : 
; 452  : 				// Check CRC of the key set
; 453  : 				if (!ReadVolumeHeaderRecoveryMode
; 454  : 					&& GetHeaderField32 (header, GST_HEADER_OFFSET_KEY_AREA_CRC) != GetCrc32 (header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE))

  00526	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ReadVolumeHeaderRecoveryMode, 0
  0052d	75 6e		 jne	 SHORT $LN74@ReadVolume
  0052f	ff b5 44 fe ff
	ff		 push	 DWORD PTR _header$[ebp+72]
  00535	e8 00 00 00 00	 call	 _MirrorBytes32
  0053a	8b f0		 mov	 esi, eax
  0053c	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _header$[ebp+256]
  00542	68 00 01 00 00	 push	 256			; 00000100H
  00547	50		 push	 eax
  00548	e8 00 00 00 00	 call	 _GetCrc32
  0054d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00550	3b f0		 cmp	 esi, eax
  00552	74 49		 je	 SHORT $LN74@ReadVolume
$LN23@ReadVolume:

; 394  : 				cryptoInfo->ea = EAGetNext (cryptoInfo->ea))

  00554	ff 33		 push	 DWORD PTR [ebx]
  00556	e8 00 00 00 00	 call	 _EAGetNext
  0055b	8b b5 64 fb ff
	ff		 mov	 esi, DWORD PTR _encryptedHeader$GSCopy$1$[ebp]
  00561	83 c4 04	 add	 esp, 4
  00564	89 03		 mov	 DWORD PTR [ebx], eax
  00566	85 c0		 test	 eax, eax
  00568	0f 85 67 fe ff
	ff		 jne	 $LL25@ReadVolume
$LN18@ReadVolume:

; 382  : 			cryptoInfo->mode <= LAST_MODE_OF_OPERATION;
; 383  : 			cryptoInfo->mode++)

  0056e	ff 43 04	 inc	 DWORD PTR [ebx+4]
  00571	83 7b 04 02	 cmp	 DWORD PTR [ebx+4], 2
  00575	8b b5 64 fb ff
	ff		 mov	 esi, DWORD PTR _encryptedHeader$GSCopy$1$[ebp]
  0057b	0f 8e 45 fe ff
	ff		 jle	 $LL20@ReadVolume
  00581	8b bd 58 fb ff
	ff		 mov	 edi, DWORD PTR _enqPkcs5Prf$1$[ebp]
$LN5@ReadVolume:

; 297  : 
; 298  : 	// Test all available PKCS5 PRFs
; 299  : 	for (enqPkcs5Prf = FIRST_PRF_ID; enqPkcs5Prf <= LAST_PRF_ID || queuedWorkItems > 0; ++enqPkcs5Prf)

  00587	8b b5 64 fb ff
	ff		 mov	 esi, DWORD PTR _encryptedHeader$GSCopy$1$[ebp]
  0058d	47		 inc	 edi
  0058e	e9 ec fb ff ff	 jmp	 $LN232@ReadVolume
$LN6@ReadVolume:

; 555  : 			}
; 556  : 		}
; 557  : 	}
; 558  : 	status = ERR_PASSWORD_WRONG;

  00593	bf 03 00 00 00	 mov	 edi, 3
  00598	e9 7f 02 00 00	 jmp	 $LN225@ReadVolume
$LN74@ReadVolume:

; 455  : 					continue;
; 456  : 
; 457  : 				// Now we have the correct password, cipher, hash algorithm, and volume type
; 458  : 
; 459  : 				// Check the version required to handle this volume
; 460  : 				if (cryptoInfo->RequiredProgramVersion > VERSION_NUM)

  0059d	b8 00 13 00 00	 mov	 eax, 4864		; 00001300H
  005a2	66 39 83 e0 1e
	00 00		 cmp	 WORD PTR [ebx+7904], ax
  005a9	76 0a		 jbe	 SHORT $LN75@ReadVolume
$LN147@ReadVolume:

; 461  : 				{
; 462  : 					status = ERR_NEW_VERSION_REQUIRED;

  005ab	bf 10 00 00 00	 mov	 edi, 16			; 00000010H

; 463  : 					goto err;

  005b0	e9 67 02 00 00	 jmp	 $LN225@ReadVolume
$LN75@ReadVolume:

; 464  : 				}
; 465  : 
; 466  : 				// Header version
; 467  : 				cryptoInfo->HeaderVersion = headerVersion;

  005b5	66 89 bb 4c 04
	00 00		 mov	 WORD PTR [ebx+1100], di

; 468  : 
; 469  : 				// Volume creation time (legacy)
; 470  : 				cryptoInfo->volume_creation_time = GetHeaderField64 (header, GST_HEADER_OFFSET_VOLUME_CREATION_TIME).Value;

  005bc	ff b5 4c fe ff
	ff		 push	 DWORD PTR _header$[ebp+80]
  005c2	ff b5 48 fe ff
	ff		 push	 DWORD PTR _header$[ebp+76]
  005c8	e8 00 00 00 00	 call	 _MirrorBytes64
  005cd	89 83 98 1e 00
	00		 mov	 DWORD PTR [ebx+7832], eax
  005d3	89 93 9c 1e 00
	00		 mov	 DWORD PTR [ebx+7836], edx

; 471  : 
; 472  : 				// Header creation time (legacy)
; 473  : 				cryptoInfo->header_creation_time = GetHeaderField64 (header, GST_HEADER_OFFSET_MODIFICATION_TIME).Value;

  005d9	ff b5 54 fe ff
	ff		 push	 DWORD PTR _header$[ebp+88]
  005df	ff b5 50 fe ff
	ff		 push	 DWORD PTR _header$[ebp+84]
  005e5	e8 00 00 00 00	 call	 _MirrorBytes64
  005ea	89 83 a0 1e 00
	00		 mov	 DWORD PTR [ebx+7840], eax
  005f0	89 93 a4 1e 00
	00		 mov	 DWORD PTR [ebx+7844], edx

; 474  : 
; 475  : 				// Hidden volume size (if any)
; 476  : 				cryptoInfo->hiddenVolumeSize = GetHeaderField64 (header, GST_HEADER_OFFSET_HIDDEN_VOLUME_SIZE).Value;

  005f6	ff b5 5c fe ff
	ff		 push	 DWORD PTR _header$[ebp+96]
  005fc	ff b5 58 fe ff
	ff		 push	 DWORD PTR _header$[ebp+92]
  00602	e8 00 00 00 00	 call	 _MirrorBytes64
  00607	83 c4 18	 add	 esp, 24			; 00000018H
  0060a	89 83 b8 1e 00
	00		 mov	 DWORD PTR [ebx+7864], eax

; 477  : 
; 478  : 				// Hidden volume status
; 479  : 				cryptoInfo->hiddenVolume = (cryptoInfo->hiddenVolumeSize != 0);

  00610	0b c2		 or	 eax, edx
  00612	89 93 bc 1e 00
	00		 mov	 DWORD PTR [ebx+7868], edx
  00618	74 07		 je	 SHORT $LN89@ReadVolume
  0061a	b8 01 00 00 00	 mov	 eax, 1
  0061f	eb 02		 jmp	 SHORT $LN90@ReadVolume
$LN89@ReadVolume:
  00621	33 c0		 xor	 eax, eax
$LN90@ReadVolume:
  00623	89 83 48 04 00
	00		 mov	 DWORD PTR [ebx+1096], eax

; 480  : 
; 481  : 				// Volume size
; 482  : 				cryptoInfo->VolumeSize = GetHeaderField64 (header, GST_HEADER_OFFSET_VOLUME_SIZE);

  00629	ff b5 64 fe ff
	ff		 push	 DWORD PTR _header$[ebp+104]
  0062f	ff b5 60 fe ff
	ff		 push	 DWORD PTR _header$[ebp+100]
  00635	e8 00 00 00 00	 call	 _MirrorBytes64
  0063a	89 83 f0 1e 00
	00		 mov	 DWORD PTR [ebx+7920], eax
  00640	89 93 f4 1e 00
	00		 mov	 DWORD PTR [ebx+7924], edx

; 483  : 				
; 484  : 				// Encrypted area size and length
; 485  : 				cryptoInfo->EncryptedAreaStart = GetHeaderField64 (header, GST_HEADER_OFFSET_ENCRYPTED_AREA_START);

  00646	ff b5 6c fe ff
	ff		 push	 DWORD PTR _header$[ebp+112]
  0064c	ff b5 68 fe ff
	ff		 push	 DWORD PTR _header$[ebp+108]
  00652	e8 00 00 00 00	 call	 _MirrorBytes64
  00657	89 83 f8 1e 00
	00		 mov	 DWORD PTR [ebx+7928], eax
  0065d	89 93 fc 1e 00
	00		 mov	 DWORD PTR [ebx+7932], edx

; 486  : 				cryptoInfo->EncryptedAreaLength = GetHeaderField64 (header, GST_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH);

  00663	ff b5 74 fe ff
	ff		 push	 DWORD PTR _header$[ebp+120]
  00669	ff b5 70 fe ff
	ff		 push	 DWORD PTR _header$[ebp+116]
  0066f	e8 00 00 00 00	 call	 _MirrorBytes64
  00674	89 83 00 1f 00
	00		 mov	 DWORD PTR [ebx+7936], eax
  0067a	89 93 04 1f 00
	00		 mov	 DWORD PTR [ebx+7940], edx

; 487  : 
; 488  : 				// Flags
; 489  : 				cryptoInfo->HeaderFlags = GetHeaderField32 (header, GST_HEADER_OFFSET_FLAGS);

  00680	ff b5 78 fe ff
	ff		 push	 DWORD PTR _header$[ebp+124]
  00686	e8 00 00 00 00	 call	 _MirrorBytes32
  0068b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0068e	89 83 08 1f 00
	00		 mov	 DWORD PTR [ebx+7944], eax

; 490  : 
; 491  : 				// Sector size
; 492  : 				if (headerVersion >= 5)

  00694	83 ff 05	 cmp	 edi, 5
  00697	72 16		 jb	 SHORT $LN76@ReadVolume

; 493  : 					cryptoInfo->SectorSize = GetHeaderField32 (header, GST_HEADER_OFFSET_SECTOR_SIZE);

  00699	ff b5 7c fe ff
	ff		 push	 DWORD PTR _header$[ebp+128]
  0069f	e8 00 00 00 00	 call	 _MirrorBytes32
  006a4	83 c4 04	 add	 esp, 4
  006a7	89 83 e8 1e 00
	00		 mov	 DWORD PTR [ebx+7912], eax
  006ad	eb 0a		 jmp	 SHORT $LN77@ReadVolume
$LN76@ReadVolume:

; 494  : 				else
; 495  : 					cryptoInfo->SectorSize = GST_SECTOR_SIZE_LEGACY;

  006af	c7 83 e8 1e 00
	00 00 02 00 00	 mov	 DWORD PTR [ebx+7912], 512 ; 00000200H
$LN77@ReadVolume:

; 496  : 
; 497  : 				if (cryptoInfo->SectorSize < GST_MIN_VOLUME_SECTOR_SIZE
; 498  : 					|| cryptoInfo->SectorSize > GST_MAX_VOLUME_SECTOR_SIZE
; 499  : 					|| cryptoInfo->SectorSize % ENCRYPTION_DATA_UNIT_SIZE != 0)

  006b9	8b 83 e8 1e 00
	00		 mov	 eax, DWORD PTR [ebx+7912]
  006bf	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  006c4	0f 82 45 01 00
	00		 jb	 $LN79@ReadVolume
  006ca	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  006cf	0f 87 3a 01 00
	00		 ja	 $LN79@ReadVolume
  006d5	a9 ff 01 00 00	 test	 eax, 511		; 000001ffH
  006da	0f 85 2f 01 00
	00		 jne	 $LN79@ReadVolume

; 502  : 					goto err;
; 503  : 				}
; 504  : 
; 505  : 				// Preserve scheduled header keys if requested			
; 506  : 				if (retHeaderCryptoInfo)

  006e0	8b bd 4c fb ff
	ff		 mov	 edi, DWORD PTR _retHeaderCryptoInfo$GSCopy$1$[ebp]
  006e6	85 ff		 test	 edi, edi
  006e8	74 51		 je	 SHORT $LN80@ReadVolume

; 507  : 				{
; 508  : 					if (retInfo == NULL)

  006ea	8b b5 70 fb ff
	ff		 mov	 esi, DWORD PTR _retInfo$GSCopy$1$[ebp]
  006f0	85 f6		 test	 esi, esi
  006f2	75 23		 jne	 SHORT $LN81@ReadVolume

; 509  : 					{
; 510  : 						cryptoInfo->pkcs5 = pkcs5_prf;

  006f4	8b 85 54 fb ff
	ff		 mov	 eax, DWORD PTR _pkcs5_prf$1$[ebp]

; 511  : 						cryptoInfo->noIterations = keyInfo.noIterations;
; 512  : 						goto ret;

  006fa	8b bd 5c fb ff
	ff		 mov	 edi, DWORD PTR _status$1$[ebp]
  00700	89 83 94 1e 00
	00		 mov	 DWORD PTR [ebx+7828], eax
  00706	8b 85 74 fb ff
	ff		 mov	 eax, DWORD PTR _keyInfo$[ebp]
  0070c	89 83 90 1e 00
	00		 mov	 DWORD PTR [ebx+7824], eax
  00712	e9 22 01 00 00	 jmp	 $ret$237
$LN81@ReadVolume:

; 513  : 					}
; 514  : 
; 515  : 					cryptoInfo = *retInfo = crypto_open ();

  00717	e8 00 00 00 00	 call	 _crypto_open
  0071c	8b d8		 mov	 ebx, eax
  0071e	89 1e		 mov	 DWORD PTR [esi], ebx

; 516  : 					if (cryptoInfo == NULL)

  00720	85 db		 test	 ebx, ebx
  00722	75 08		 jne	 SHORT $LN82@ReadVolume

; 517  : 					{
; 518  : 						status = ERR_OUTOFMEMORY;

  00724	8d 78 02	 lea	 edi, DWORD PTR [eax+2]

; 519  : 						goto err;

  00727	e9 f6 00 00 00	 jmp	 $err$238
$LN82@ReadVolume:

; 520  : 					}
; 521  : 
; 522  : 					memcpy (cryptoInfo, retHeaderCryptoInfo, sizeof (*cryptoInfo));

  0072c	68 10 1f 00 00	 push	 7952			; 00001f10H
  00731	57		 push	 edi
  00732	53		 push	 ebx
  00733	e8 00 00 00 00	 call	 _memcpy
  00738	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN80@ReadVolume:

; 523  : 				}
; 524  : 
; 525  : 				// Master key data
; 526  : 				memcpy (keyInfo.master_keydata, header + HEADER_MASTER_KEYDATA_OFFSET, MASTER_KEYDATA_SIZE);
; 527  : 				memcpy (cryptoInfo->master_keydata, keyInfo.master_keydata, MASTER_KEYDATA_SIZE);
; 528  : 
; 529  : 				// PKCS #5
; 530  : 				memcpy (cryptoInfo->salt, keyInfo.salt, PKCS5_SALT_SIZE);
; 531  : 				cryptoInfo->pkcs5 = pkcs5_prf;

  0073b	8b 85 54 fb ff
	ff		 mov	 eax, DWORD PTR _pkcs5_prf$1$[ebp]
  00741	8d b5 fc fe ff
	ff		 lea	 esi, DWORD PTR _header$[ebp+256]
  00747	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0074c	8d bd fc fb ff
	ff		 lea	 edi, DWORD PTR _keyInfo$[ebp+136]
  00752	f3 a5		 rep movsd
  00754	8d bb 50 1c 00
	00		 lea	 edi, DWORD PTR [ebx+7248]
  0075a	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0075f	8d b5 fc fb ff
	ff		 lea	 esi, DWORD PTR _keyInfo$[ebp+136]
  00765	f3 a5		 rep movsd
  00767	0f 10 85 bc fb
	ff ff		 movups	 xmm0, XMMWORD PTR _keyInfo$[ebp+72]
  0076e	0f 11 83 50 1e
	00 00		 movups	 XMMWORD PTR [ebx+7760], xmm0
  00775	0f 10 85 cc fb
	ff ff		 movups	 xmm0, XMMWORD PTR _keyInfo$[ebp+88]
  0077c	0f 11 83 60 1e
	00 00		 movups	 XMMWORD PTR [ebx+7776], xmm0
  00783	0f 10 85 dc fb
	ff ff		 movups	 xmm0, XMMWORD PTR _keyInfo$[ebp+104]
  0078a	0f 11 83 70 1e
	00 00		 movups	 XMMWORD PTR [ebx+7792], xmm0
  00791	0f 10 85 ec fb
	ff ff		 movups	 xmm0, XMMWORD PTR _keyInfo$[ebp+120]
  00798	89 83 94 1e 00
	00		 mov	 DWORD PTR [ebx+7828], eax
  0079e	0f 11 83 80 1e
	00 00		 movups	 XMMWORD PTR [ebx+7808], xmm0

; 532  : 				cryptoInfo->noIterations = keyInfo.noIterations;

  007a5	8b 85 74 fb ff
	ff		 mov	 eax, DWORD PTR _keyInfo$[ebp]
  007ab	89 83 90 1e 00
	00		 mov	 DWORD PTR [ebx+7824], eax

; 533  : 
; 534  : 				// Init the cipher with the decrypted master key
; 535  : 				status = EAInit (cryptoInfo->ea, keyInfo.master_keydata + primaryKeyOffset, cryptoInfo->ks);

  007b1	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  007b4	50		 push	 eax
  007b5	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp+136]
  007bb	50		 push	 eax
  007bc	ff 33		 push	 DWORD PTR [ebx]
  007be	e8 00 00 00 00	 call	 _EAInit
  007c3	8b f8		 mov	 edi, eax
  007c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 536  : 				if (status == ERR_CIPHER_INIT_FAILURE)

  007c8	83 ff 11	 cmp	 edi, 17			; 00000011H
  007cb	74 4f		 je	 SHORT $LN225@ReadVolume

; 537  : 					goto err;
; 538  : 
; 539  : 				switch (cryptoInfo->mode)
; 540  : 				{
; 541  : 				default:
; 542  : 					// The secondary master key (if cascade, multiple concatenated)
; 543  : 					memcpy (cryptoInfo->k2, keyInfo.master_keydata + EAGetKeySize (cryptoInfo->ea), EAGetKeySize (cryptoInfo->ea));

  007cd	ff 33		 push	 DWORD PTR [ebx]
  007cf	e8 00 00 00 00	 call	 _EAGetKeySize
  007d4	83 c4 04	 add	 esp, 4
  007d7	50		 push	 eax
  007d8	ff 33		 push	 DWORD PTR [ebx]
  007da	e8 00 00 00 00	 call	 _EAGetKeySize
  007df	83 c4 04	 add	 esp, 4
  007e2	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _keyInfo$[ebp+136]
  007e8	03 c1		 add	 eax, ecx
  007ea	50		 push	 eax
  007eb	8d 83 50 1d 00
	00		 lea	 eax, DWORD PTR [ebx+7504]
  007f1	50		 push	 eax
  007f2	e8 00 00 00 00	 call	 _memcpy

; 544  : 
; 545  : 				}
; 546  : 
; 547  : 				if (!EAInitMode (cryptoInfo))

  007f7	53		 push	 ebx
  007f8	e8 00 00 00 00	 call	 _EAInitMode
  007fd	83 c4 10	 add	 esp, 16			; 00000010H
  00800	85 c0		 test	 eax, eax
  00802	75 07		 jne	 SHORT $LN85@ReadVolume
$LN146@ReadVolume:

; 548  : 				{
; 549  : 					status = ERR_MODE_INIT_FAILED;

  00804	bf 1b 00 00 00	 mov	 edi, 27			; 0000001bH

; 550  : 					goto err;

  00809	eb 11		 jmp	 SHORT $LN225@ReadVolume
$LN85@ReadVolume:

; 551  : 				}
; 552  : 
; 553  : 				status = ERR_SUCCESS;

  0080b	33 ff		 xor	 edi, edi

; 554  : 				goto ret;

  0080d	eb 2a		 jmp	 SHORT $ret$237
$LN79@ReadVolume:

; 500  : 				{
; 501  : 					status = ERR_PARAMETER_INCORRECT;

  0080f	bf 1e 00 00 00	 mov	 edi, 30			; 0000001eH
  00814	eb 06		 jmp	 SHORT $LN225@ReadVolume
$LN223@ReadVolume:
  00816	8b bd 5c fb ff
	ff		 mov	 edi, DWORD PTR _status$1$[ebp]
$LN225@ReadVolume:
  0081c	8b b5 70 fb ff
	ff		 mov	 esi, DWORD PTR _retInfo$GSCopy$1$[ebp]
$err$238:

; 559  : 
; 560  : err:
; 561  : 	if (cryptoInfo != retHeaderCryptoInfo)

  00822	3b 9d 4c fb ff
	ff		 cmp	 ebx, DWORD PTR _retHeaderCryptoInfo$GSCopy$1$[ebp]
  00828	74 0f		 je	 SHORT $ret$237

; 562  : 	{
; 563  : 		crypto_close(cryptoInfo);

  0082a	53		 push	 ebx
  0082b	e8 00 00 00 00	 call	 _crypto_close
  00830	83 c4 04	 add	 esp, 4

; 564  : 		*retInfo = NULL; 

  00833	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$ret$237:

; 565  : 	}
; 566  : 
; 567  : ret:
; 568  : 	burn (&keyInfo, sizeof (keyInfo));

  00839	8d 85 74 fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp]
  0083f	b9 88 01 00 00	 mov	 ecx, 392		; 00000188H
  00844	8b f1		 mov	 esi, ecx
  00846	8b d0		 mov	 edx, eax
  00848	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL118@ReadVolume:
  00850	c6 02 00	 mov	 BYTE PTR [edx], 0
  00853	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00856	83 ee 01	 sub	 esi, 1
  00859	75 f5		 jne	 SHORT $LL118@ReadVolume
  0085b	0f 1f 44 00 00	 npad	 5
$LL31@ReadVolume:
  00860	c6 00 00	 mov	 BYTE PTR [eax], 0
  00863	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00866	83 e9 01	 sub	 ecx, 1
  00869	75 f5		 jne	 SHORT $LL31@ReadVolume

; 569  : 	burn (dk, sizeof(dk));

  0086b	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  00871	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00876	8b f1		 mov	 esi, ecx
  00878	8b d0		 mov	 edx, eax
  0087a	66 0f 1f 44 00
	00		 npad	 6
$LL122@ReadVolume:
  00880	c6 02 00	 mov	 BYTE PTR [edx], 0
  00883	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00886	83 ee 01	 sub	 esi, 1
  00889	75 f5		 jne	 SHORT $LL122@ReadVolume
  0088b	0f 1f 44 00 00	 npad	 5
$LL36@ReadVolume:
  00890	c6 00 00	 mov	 BYTE PTR [eax], 0
  00893	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00896	83 e9 01	 sub	 ecx, 1
  00899	75 f5		 jne	 SHORT $LL36@ReadVolume

; 570  : 
; 571  : #ifndef DEVICE_DRIVER
; 572  : 	VirtualUnlock (&keyInfo, sizeof (keyInfo));

  0089b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__VirtualUnlock@8
  008a1	8d 85 74 fb ff
	ff		 lea	 eax, DWORD PTR _keyInfo$[ebp]
  008a7	68 88 01 00 00	 push	 392			; 00000188H
  008ac	50		 push	 eax
  008ad	ff d6		 call	 esi

; 573  : 	VirtualUnlock (&dk, sizeof (dk));

  008af	68 00 01 00 00	 push	 256			; 00000100H
  008b4	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _dk$[ebp]
  008ba	50		 push	 eax
  008bb	ff d6		 call	 esi

; 574  : #endif
; 575  : 
; 576  : 	if (encryptionThreadCount > 1)

  008bd	83 bd 48 fb ff
	ff 01		 cmp	 DWORD PTR _encryptionThreadCount$1$[ebp], 1
  008c4	76 54		 jbe	 SHORT $LN87@ReadVolume

; 577  : 	{
; 578  : 		GST_WAIT_EVENT (noOutstandingWorkItemEvent);

  008c6	6a ff		 push	 -1
  008c8	ff b5 50 fb ff
	ff		 push	 DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  008ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 579  : 
; 580  : 		burn (keyDerivationWorkItems, sizeof (KeyDerivationWorkItem) * pkcs5PrfCount);

  008d4	8b 9d 68 fb ff
	ff		 mov	 ebx, DWORD PTR _keyDerivationWorkItems$1$[ebp]
  008da	b9 24 03 00 00	 mov	 ecx, 804		; 00000324H
  008df	8b c3		 mov	 eax, ebx
  008e1	8b f1		 mov	 esi, ecx
  008e3	8b d3		 mov	 edx, ebx
$LL126@ReadVolume:
  008e5	c6 02 00	 mov	 BYTE PTR [edx], 0
  008e8	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  008eb	83 ee 01	 sub	 esi, 1
  008ee	75 f5		 jne	 SHORT $LL126@ReadVolume
$LL41@ReadVolume:
  008f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  008f3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  008f6	83 e9 01	 sub	 ecx, 1
  008f9	75 f5		 jne	 SHORT $LL41@ReadVolume

; 581  : 		GSTfree (keyDerivationWorkItems);

  008fb	53		 push	 ebx
  008fc	e8 00 00 00 00	 call	 _free

; 582  : 
; 583  : #ifndef DEVICE_DRIVER
; 584  : 		CloseHandle (keyDerivationCompletedEvent);

  00901	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  00907	83 c4 04	 add	 esp, 4
  0090a	ff b5 60 fb ff
	ff		 push	 DWORD PTR _keyDerivationCompletedEvent$[ebp]
  00910	ff d6		 call	 esi

; 585  : 		CloseHandle (noOutstandingWorkItemEvent);

  00912	ff b5 50 fb ff
	ff		 push	 DWORD PTR _noOutstandingWorkItemEvent$[ebp]
  00918	ff d6		 call	 esi
$LN87@ReadVolume:

; 586  : #endif
; 587  : 	}
; 588  : 
; 589  : 	return status;
; 590  : }

  0091a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0091d	8b c7		 mov	 eax, edi
  0091f	5f		 pop	 edi
  00920	5e		 pop	 esi
  00921	33 cd		 xor	 ecx, ebp
  00923	5b		 pop	 ebx
  00924	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00929	8b e5		 mov	 esp, ebp
  0092b	5d		 pop	 ebp
  0092c	c3		 ret	 0
_ReadVolumeHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _GetHeaderField64
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField64 PROC					; COMDAT

; 178  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 179  : 	UINT64_STRUCT uint64Struct;
; 180  : 
; 181  : #ifndef GST_NO_COMPILER_INT64
; 182  : 	uint64Struct.Value = BE64 (*(uint64 *) (header + offset));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _header$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  00009	ff 74 01 04	 push	 DWORD PTR [ecx+eax+4]
  0000d	ff 34 01	 push	 DWORD PTR [ecx+eax]
  00010	e8 00 00 00 00	 call	 _MirrorBytes64
  00015	83 c4 08	 add	 esp, 8

; 183  : #else
; 184  : 	uint64Struct.HighPart = BE32 (*(uint32 *) (header + offset));
; 185  : 	uint64Struct.LowPart = BE32 (*(uint32 *) (header + offset + 4));
; 186  : #endif
; 187  : 	return uint64Struct;
; 188  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_GetHeaderField64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _GetHeaderField32
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField32 PROC					; COMDAT

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 164  : 	return BE32 (*(uint32 *) (header + offset));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _header$[ebp]
  00009	ff 34 08	 push	 DWORD PTR [eax+ecx]
  0000c	e8 00 00 00 00	 call	 _MirrorBytes32
  00011	83 c4 04	 add	 esp, 4

; 165  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
_GetHeaderField32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\volumes.c
;	COMDAT _GetHeaderField16
_TEXT	SEGMENT
_header$ = 8						; size = 4
_offset$ = 12						; size = 4
_GetHeaderField16 PROC					; COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 149  : 	return BE16 (*(uint16 *) (header + offset));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _header$[ebp]
  00009	0f b7 04 08	 movzx	 eax, WORD PTR [eax+ecx]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _MirrorBytes16
  00013	83 c4 04	 add	 esp, 4

; 150  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_GetHeaderField16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 17787: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17788:     volatile char *vptr = (volatile char *)ptr;
; 17789: 
; 17790: #if defined(_M_AMD64)
; 17791: 
; 17792:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 17793: 
; 17794: #else
; 17795: 
; 17796:     while (cnt) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR _cnt$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	8b c8		 mov	 ecx, eax
  0000b	85 d2		 test	 edx, edx
  0000d	74 0c		 je	 SHORT $LN3@RtlSecureZ
  0000f	90		 npad	 1
$LL2@RtlSecureZ:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

  00013	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 17809:         cnt--;

  00016	83 ea 01	 sub	 edx, 1
  00019	75 f5		 jne	 SHORT $LL2@RtlSecureZ
$LN3@RtlSecureZ:

; 17810:     }
; 17811: 
; 17812: #endif // _M_AMD64
; 17813: 
; 17814:     return ptr;
; 17815: }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
END
