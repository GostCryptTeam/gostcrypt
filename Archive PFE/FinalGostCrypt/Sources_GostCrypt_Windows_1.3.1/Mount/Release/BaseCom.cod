; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Common\BaseCom.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BB@BEBMGMDO@atlTraceDBClient?$AA@	; `string'
PUBLIC	??_C@_0BD@KOADKDIA@atlTraceDBProvider?$AA@	; `string'
PUBLIC	??_C@_0P@LNEGBOLO@atlTraceSnapin?$AA@		; `string'
PUBLIC	??_C@_0BA@MCBFIDIC@atlTraceNotImpl?$AA@		; `string'
PUBLIC	??_C@_0BD@PJPCCAKP@atlTraceAllocation?$AA@	; `string'
PUBLIC	??_C@_0BC@PGMFNIFA@atlTraceException?$AA@	; `string'
PUBLIC	??_C@_0N@BNNILHBE@atlTraceTime?$AA@		; `string'
PUBLIC	??_C@_0O@MEOJAOKK@atlTraceCache?$AA@		; `string'
PUBLIC	??_C@_0BA@IDBKCKK@atlTraceStencil?$AA@		; `string'
PUBLIC	??_C@_0P@MBNHGHMI@atlTraceString?$AA@		; `string'
PUBLIC	??_C@_0M@IOBBMAHG@atlTraceMap?$AA@		; `string'
PUBLIC	??_C@_0N@FEAAACHD@atlTraceUtil?$AA@		; `string'
PUBLIC	??_C@_0BB@DNJDADMG@atlTraceSecurity?$AA@	; `string'
PUBLIC	??_C@_0N@KLPNCFEE@atlTraceSync?$AA@		; `string'
PUBLIC	??_C@_0O@KHOBHOBJ@atlTraceISAPI?$AA@		; `string'
PUBLIC	??_C@_0BA@MKMIKKJB@atlTraceGeneral?$AA@		; `string'
PUBLIC	??_C@_0M@DGPFJEBB@atlTraceCOM?$AA@		; `string'
PUBLIC	??_C@_0L@LHELAKBP@atlTraceQI?$AA@		; `string'
PUBLIC	??_C@_0BC@MALHFBAO@atlTraceRegistrar?$AA@	; `string'
PUBLIC	??_C@_0BB@ILPPDKFL@atlTraceRefcount?$AA@	; `string'
PUBLIC	??_C@_0BC@DGHHNKDC@atlTraceWindowing?$AA@	; `string'
PUBLIC	??_C@_0BB@GHKJKKIE@atlTraceControls?$AA@	; `string'
PUBLIC	??_C@_0BA@DKOAAGGM@atlTraceHosting?$AA@		; `string'
;	COMDAT ??_C@_0BA@DKOAAGGM@atlTraceHosting?$AA@
CONST	SEGMENT
??_C@_0BA@DKOAAGGM@atlTraceHosting?$AA@ DB 'atlTraceHosting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GHKJKKIE@atlTraceControls?$AA@
CONST	SEGMENT
??_C@_0BB@GHKJKKIE@atlTraceControls?$AA@ DB 'atlTraceControls', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DGHHNKDC@atlTraceWindowing?$AA@
CONST	SEGMENT
??_C@_0BC@DGHHNKDC@atlTraceWindowing?$AA@ DB 'atlTraceWindowing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ILPPDKFL@atlTraceRefcount?$AA@
CONST	SEGMENT
??_C@_0BB@ILPPDKFL@atlTraceRefcount?$AA@ DB 'atlTraceRefcount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MALHFBAO@atlTraceRegistrar?$AA@
CONST	SEGMENT
??_C@_0BC@MALHFBAO@atlTraceRegistrar?$AA@ DB 'atlTraceRegistrar', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LHELAKBP@atlTraceQI?$AA@
CONST	SEGMENT
??_C@_0L@LHELAKBP@atlTraceQI?$AA@ DB 'atlTraceQI', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DGPFJEBB@atlTraceCOM?$AA@
CONST	SEGMENT
??_C@_0M@DGPFJEBB@atlTraceCOM?$AA@ DB 'atlTraceCOM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MKMIKKJB@atlTraceGeneral?$AA@
CONST	SEGMENT
??_C@_0BA@MKMIKKJB@atlTraceGeneral?$AA@ DB 'atlTraceGeneral', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KHOBHOBJ@atlTraceISAPI?$AA@
CONST	SEGMENT
??_C@_0O@KHOBHOBJ@atlTraceISAPI?$AA@ DB 'atlTraceISAPI', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KLPNCFEE@atlTraceSync?$AA@
CONST	SEGMENT
??_C@_0N@KLPNCFEE@atlTraceSync?$AA@ DB 'atlTraceSync', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DNJDADMG@atlTraceSecurity?$AA@
CONST	SEGMENT
??_C@_0BB@DNJDADMG@atlTraceSecurity?$AA@ DB 'atlTraceSecurity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FEAAACHD@atlTraceUtil?$AA@
CONST	SEGMENT
??_C@_0N@FEAAACHD@atlTraceUtil?$AA@ DB 'atlTraceUtil', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IOBBMAHG@atlTraceMap?$AA@
CONST	SEGMENT
??_C@_0M@IOBBMAHG@atlTraceMap?$AA@ DB 'atlTraceMap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MBNHGHMI@atlTraceString?$AA@
CONST	SEGMENT
??_C@_0P@MBNHGHMI@atlTraceString?$AA@ DB 'atlTraceString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IDBKCKK@atlTraceStencil?$AA@
CONST	SEGMENT
??_C@_0BA@IDBKCKK@atlTraceStencil?$AA@ DB 'atlTraceStencil', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MEOJAOKK@atlTraceCache?$AA@
CONST	SEGMENT
??_C@_0O@MEOJAOKK@atlTraceCache?$AA@ DB 'atlTraceCache', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BNNILHBE@atlTraceTime?$AA@
CONST	SEGMENT
??_C@_0N@BNNILHBE@atlTraceTime?$AA@ DB 'atlTraceTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PGMFNIFA@atlTraceException?$AA@
CONST	SEGMENT
??_C@_0BC@PGMFNIFA@atlTraceException?$AA@ DB 'atlTraceException', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJPCCAKP@atlTraceAllocation?$AA@
CONST	SEGMENT
??_C@_0BD@PJPCCAKP@atlTraceAllocation?$AA@ DB 'atlTraceAllocation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MCBFIDIC@atlTraceNotImpl?$AA@
CONST	SEGMENT
??_C@_0BA@MCBFIDIC@atlTraceNotImpl?$AA@ DB 'atlTraceNotImpl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LNEGBOLO@atlTraceSnapin?$AA@
CONST	SEGMENT
??_C@_0P@LNEGBOLO@atlTraceSnapin?$AA@ DB 'atlTraceSnapin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KOADKDIA@atlTraceDBProvider?$AA@
CONST	SEGMENT
??_C@_0BD@KOADKDIA@atlTraceDBProvider?$AA@ DB 'atlTraceDBProvider', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BEBMGMDO@atlTraceDBClient?$AA@
CONST	SEGMENT
??_C@_0BB@BEBMGMDO@atlTraceDBClient?$AA@ DB 'atlTraceDBClient', 00H ; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ ; __vcrt_va_start_verify_argument_type<wchar_t const * const>
PUBLIC	_swprintf_s
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
PUBLIC	?AtlThrowLastWin32@ATL@@YGXXZ			; ATL::AtlThrowLastWin32
PUBLIC	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
PUBLIC	?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z		; BaseCom::CallDriver
PUBLIC	?CopyFileA@BaseCom@@SAKPA_W0@Z			; BaseCom::CopyFileA
PUBLIC	?DeleteFileA@BaseCom@@SAKPA_W@Z			; BaseCom::DeleteFileA
PUBLIC	?IsPagingFileActive@BaseCom@@SAHH@Z		; BaseCom::IsPagingFileActive
PUBLIC	?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z	; BaseCom::ReadWriteFile
PUBLIC	?RegisterFilterDriver@BaseCom@@SAKHH@Z		; BaseCom::RegisterFilterDriver
PUBLIC	?RegisterSystemFavoritesService@BaseCom@@SAKH@Z	; BaseCom::RegisterSystemFavoritesService
PUBLIC	?SetDriverServiceStartType@BaseCom@@SAKK@Z	; BaseCom::SetDriverServiceStartType
PUBLIC	?WriteLocalMachineRegistryDwordValue@BaseCom@@SAKPA_W0K@Z ; BaseCom::WriteLocalMachineRegistryDwordValue
PUBLIC	?ComGetInstanceBase@@YAHPAUHWND__@@ABU_GUID@@1PAPAX@Z ; ComGetInstanceBase
PUBLIC	?CreateElevatedComObject@@YAJPAUHWND__@@ABU_GUID@@1PAPAX@Z ; CreateElevatedComObject
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ			; ATL::CW2AEX<128>::~CW2AEX<128>
PUBLIC	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z		; ATL::CW2AEX<128>::Init
PUBLIC	??1?$auto_ptr@VFile@GostCrypt@@@std@@QAE@XZ	; std::auto_ptr<GostCrypt::File>::~auto_ptr<GostCrypt::File>
PUBLIC	??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z	; ATL::AtlConvAllocMemory<char>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
PUBLIC	?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
PUBLIC	?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
PUBLIC	?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
PUBLIC	?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
PUBLIC	?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
PUBLIC	?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
PUBLIC	?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
PUBLIC	?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
PUBLIC	?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
PUBLIC	?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
PUBLIC	?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
PUBLIC	?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
PUBLIC	?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
PUBLIC	?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
PUBLIC	?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
PUBLIC	?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
PUBLIC	?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
PUBLIC	__TI1?AVCAtlException@ATL@@
PUBLIC	__CTA1?AVCAtlException@ATL@@
PUBLIC	??_R0?AVCAtlException@ATL@@@8			; ATL::CAtlException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVCAtlException@ATL@@@84
PUBLIC	??_C@_1DO@BMONIIMG@?$AAE?$AAl?$AAe?$AAv?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?3?$AAA?$AAd?$AAm?$AAi?$AAn?$AAi?$AAs?$AAt?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$CB?$AAn?$AAe?$AAw?$AA?3?$AA?$CF?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_0P@NDJDHMAP@UAC_INIT_ERROR?$AA@		; `string'
PUBLIC	??_R0?AUSystemException@GostCrypt@@@8		; GostCrypt::SystemException `RTTI Type Descriptor'
PUBLIC	??_R0?AUException@GostCrypt@@@8			; GostCrypt::Exception `RTTI Type Descriptor'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	__recalloc:PROC
EXTRN	_memmove:PROC
EXTRN	__imp__DeleteFileA@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__InitializeCriticalSectionEx@12:PROC
EXTRN	__imp__CopyFileA@12:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	__imp__CoCreateInstance@20:PROC
EXTRN	__imp__StringFromGUID2@12:PROC
EXTRN	__imp__CoGetObject@16:PROC
EXTRN	___stdio_common_vswprintf_s:PROC
EXTRN	_ProcessPaintMessages:PROC
EXTRN	_IsUacSupported:PROC
EXTRN	_Error:PROC
EXTRN	_IsPagingFileActive:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z:PROC ; GostCrypt::File::File
EXTRN	?Close@File@GostCrypt@@QAEXXZ:PROC		; GostCrypt::File::Close
EXTRN	?Read@File@GostCrypt@@QAEKPAEK@Z:PROC		; GostCrypt::File::Read
EXTRN	?Write@File@GostCrypt@@QAEXPAEK@Z:PROC		; GostCrypt::File::Write
EXTRN	?SeekAt@File@GostCrypt@@QAEX_J@Z:PROC		; GostCrypt::File::SeekAt
EXTRN	??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:PROC ; GostCrypt::Device::Device
EXTRN	??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z:PROC ; GostCrypt::BootEncryption::BootEncryption
EXTRN	??1BootEncryption@GostCrypt@@QAE@XZ:PROC	; GostCrypt::BootEncryption::~BootEncryption
EXTRN	?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z:PROC ; GostCrypt::BootEncryption::CallDriver
EXTRN	?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z:PROC ; GostCrypt::BootEncryption::RegisterFilterDriver
EXTRN	?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z:PROC ; GostCrypt::BootEncryption::RegisterSystemFavoritesService
EXTRN	?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z:PROC ; GostCrypt::BootEncryption::SetDriverServiceStartType
EXTRN	_WriteLocalMachineRegistryDword:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A
_BSS	SEGMENT
?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCOM
_BSS	ENDS
;	COMDAT ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A
_BSS	SEGMENT
?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceQI
_BSS	ENDS
;	COMDAT ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A
_BSS	SEGMENT
?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRegistrar
_BSS	ENDS
;	COMDAT ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A
_BSS	SEGMENT
?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRefcount
_BSS	ENDS
;	COMDAT ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A
_BSS	SEGMENT
?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceWindowing
_BSS	ENDS
;	COMDAT ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A
_BSS	SEGMENT
?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceControls
_BSS	ENDS
;	COMDAT ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A
_BSS	SEGMENT
?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceHosting
_BSS	ENDS
;	COMDAT ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBClient
_BSS	ENDS
;	COMDAT ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBProvider
_BSS	ENDS
;	COMDAT ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSnapin
_BSS	ENDS
;	COMDAT ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceNotImpl
_BSS	ENDS
;	COMDAT ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceAllocation
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceTime
_BSS	ENDS
;	COMDAT ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCache
_BSS	ENDS
;	COMDAT ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceStencil
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceMap
_BSS	ENDS
;	COMDAT ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceUtil
_BSS	ENDS
;	COMDAT ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSecurity
_BSS	ENDS
;	COMDAT ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSync
_BSS	ENDS
;	COMDAT ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceISAPI
_BSS	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R0?AUException@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUException@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::Exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUException@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AUSystemException@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUSystemException@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::SystemException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUSystemException@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0P@NDJDHMAP@UAC_INIT_ERROR?$AA@
CONST	SEGMENT
??_C@_0P@NDJDHMAP@UAC_INIT_ERROR?$AA@ DB 'UAC_INIT_ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@BMONIIMG@?$AAE?$AAl?$AAe?$AAv?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?3?$AAA?$AAd?$AAm?$AAi?$AAn?$AAi?$AAs?$AAt?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$CB?$AAn?$AAe?$AAw?$AA?3?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@BMONIIMG@?$AAE?$AAl?$AAe?$AAv?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?3?$AAA?$AAd?$AAm?$AAi?$AAn?$AAi?$AAs?$AAt?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$CB?$AAn?$AAe?$AAw?$AA?3?$AA?$CF?$AAs?$AA?$AA@ DB 'E'
	DB	00H, 'l', 00H, 'e', 00H, 'v', 00H, 'a', 00H, 't', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, ':', 00H, 'A', 00H, 'd', 00H, 'm', 00H, 'i'
	DB	00H, 'n', 00H, 'i', 00H, 's', 00H, 't', 00H, 'r', 00H, 'a', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, '!', 00H, 'n', 00H, 'e', 00H, 'w'
	DB	00H, ':', 00H, '%', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT
__CT??_R0?AVCAtlException@ATL@@@84 DD 00H
	DD	FLAT:??_R0?AVCAtlException@ATL@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
data$r	SEGMENT
??_R0?AVCAtlException@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlException@ATL@@', 00H
data$r	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__CTA1?AVCAtlException@ATL@@ DD 01H
	DD	FLAT:__CT??_R0?AVCAtlException@ATL@@@84
xdata$x	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__TI1?AVCAtlException@ATL@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCAtlException@ATL@@
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$auto_ptr@VFile@GostCrypt@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$auto_ptr@VFile@GostCrypt@@@std@@QAE@XZ$1
__ehfuncinfo$??1?$auto_ptr@VFile@GostCrypt@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$auto_ptr@VFile@GostCrypt@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_GFile@GostCrypt@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_GFile@GostCrypt@@QAEPAXI@Z$0
__ehfuncinfo$??_GFile@GostCrypt@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_GFile@GostCrypt@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1File@GostCrypt@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?WriteLocalMachineRegistryDwordValue@BaseCom@@SAKPA_W0K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?WriteLocalMachineRegistryDwordValue@BaseCom@@SAKPA_W0K@Z$0
__ehfuncinfo$?WriteLocalMachineRegistryDwordValue@BaseCom@@SAKPA_W0K@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?WriteLocalMachineRegistryDwordValue@BaseCom@@SAKPA_W0K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SetDriverServiceStartType@BaseCom@@SAKK@Z DD 00H
	DD	01H
	DD	02H
	DD	03H
	DD	FLAT:__catchsym$?SetDriverServiceStartType@BaseCom@@SAKK@Z$5
__unwindtable$?SetDriverServiceStartType@BaseCom@@SAKK@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?SetDriverServiceStartType@BaseCom@@SAKK@Z$4
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?SetDriverServiceStartType@BaseCom@@SAKK@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SetDriverServiceStartType@BaseCom@@SAKK@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetDriverServiceStartType@BaseCom@@SAKK@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__catchsym$?SetDriverServiceStartType@BaseCom@@SAKK@Z$5 DD 08H
	DD	FLAT:??_R0?AUSystemException@GostCrypt@@@8
	DD	00H
	DD	FLAT:__catch$?SetDriverServiceStartType@BaseCom@@SAKK@Z$0
	DD	08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffa1cH
	DD	FLAT:__catch$?SetDriverServiceStartType@BaseCom@@SAKK@Z$1
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetDriverServiceStartType@BaseCom@@SAKK@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z DD 00H
	DD	01H
	DD	02H
	DD	03H
	DD	FLAT:__catchsym$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z$5
__unwindtable$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z$4
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__catchsym$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z$5 DD 08H
	DD	FLAT:??_R0?AUSystemException@GostCrypt@@@8
	DD	00H
	DD	FLAT:__catch$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z$0
	DD	08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffa1cH
	DD	FLAT:__catch$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z$1
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?RegisterFilterDriver@BaseCom@@SAKHH@Z DD 00H
	DD	01H
	DD	02H
	DD	03H
	DD	FLAT:__catchsym$?RegisterFilterDriver@BaseCom@@SAKHH@Z$5
__unwindtable$?RegisterFilterDriver@BaseCom@@SAKHH@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?RegisterFilterDriver@BaseCom@@SAKHH@Z$4
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?RegisterFilterDriver@BaseCom@@SAKHH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?RegisterFilterDriver@BaseCom@@SAKHH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?RegisterFilterDriver@BaseCom@@SAKHH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__catchsym$?RegisterFilterDriver@BaseCom@@SAKHH@Z$5 DD 08H
	DD	FLAT:??_R0?AUSystemException@GostCrypt@@@8
	DD	00H
	DD	FLAT:__catch$?RegisterFilterDriver@BaseCom@@SAKHH@Z$0
	DD	08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffa1cH
	DD	FLAT:__catch$?RegisterFilterDriver@BaseCom@@SAKHH@Z$1
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?RegisterFilterDriver@BaseCom@@SAKHH@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z DD 00H
	DD	0aH
	DD	0bH
	DD	03H
	DD	FLAT:__catchsym$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$48
__ehfuncinfo$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z
	DD	01H
	DD	FLAT:__tryblocktable$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__catchsym$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$48 DD 08H
	DD	FLAT:??_R0?AUSystemException@GostCrypt@@@8
	DD	00H
	DD	FLAT:__catch$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$0
	DD	08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffec8H
	DD	FLAT:__catch$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$1
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$2
__unwindtable$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$7
	DD	04H
	DD	FLAT:__unwindfunclet$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$8
	DD	03H
	DD	FLAT:__unwindfunclet$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$10
	DD	03H
	DD	FLAT:__unwindfunclet$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$20
	DD	0ffffffffH
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CopyFileA@BaseCom@@SAKPA_W0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CopyFileA@BaseCom@@SAKPA_W0@Z$0
__ehfuncinfo$?CopyFileA@BaseCom@@SAKPA_W0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CopyFileA@BaseCom@@SAKPA_W0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z DD 00H
	DD	01H
	DD	02H
	DD	03H
	DD	FLAT:__catchsym$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z$5
__unwindtable$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z$4
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z
	DD	01H
	DD	FLAT:__tryblocktable$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__catchsym$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z$5 DD 08H
	DD	FLAT:??_R0?AUSystemException@GostCrypt@@@8
	DD	00H
	DD	FLAT:__catch$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z$0
	DD	08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffa1cH
	DD	FLAT:__catch$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z$1
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z$2
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z
_TEXT	SEGMENT
_ppBuff$ = 8						; size = 4
_nLength$ = 12						; size = 4
_pszFixedBuffer$ = 16					; size = 4
_nFixedBufferLength$ = 20				; size = 4
??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z PROC	; ATL::AtlConvAllocMemory<char>, COMDAT

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 120  : 	ATLENSURE_THROW(ppBuff != NULL, E_INVALIDARG);

  00004	8b 75 08	 mov	 esi, DWORD PTR _ppBuff$[ebp]
  00007	57		 push	 edi
  00008	85 f6		 test	 esi, esi
  0000a	74 55		 je	 SHORT $LN33@AtlConvAll

; 121  : 	ATLENSURE_THROW(nLength >= 0, E_INVALIDARG);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _nLength$[ebp]
  0000f	85 c0		 test	 eax, eax
  00011	78 58		 js	 SHORT $LN35@AtlConvAll

; 122  : 	ATLENSURE_THROW(pszFixedBuffer != NULL, E_INVALIDARG);

  00013	8b 7d 10	 mov	 edi, DWORD PTR _pszFixedBuffer$[ebp]
  00016	85 ff		 test	 edi, edi
  00018	74 5b		 je	 SHORT $LN36@AtlConvAll

; 123  : 
; 124  : 	//if buffer malloced, try to realloc.
; 125  : 	if (*ppBuff != pszFixedBuffer)

  0001a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001c	3b cf		 cmp	 ecx, edi
  0001e	74 2b		 je	 SHORT $LN23@AtlConvAll

; 126  : 	{
; 127  : 		if( nLength > nFixedBufferLength )

  00020	3b 45 14	 cmp	 eax, DWORD PTR _nFixedBufferLength$[ebp]
  00023	7e 12		 jle	 SHORT $LN25@AtlConvAll

; 128  : 		{
; 129  : 			_CharType* ppReallocBuf = static_cast< _CharType* >( _recalloc(*ppBuff, nLength,sizeof( _CharType ) ) );

  00025	6a 01		 push	 1
  00027	50		 push	 eax
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 __recalloc
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 130  : 			if (ppReallocBuf == NULL) 

  00031	85 c0		 test	 eax, eax
  00033	75 26		 jne	 SHORT $LN27@AtlConvAll
  00035	eb 48		 jmp	 SHORT $LN37@AtlConvAll
$LN25@AtlConvAll:

; 133  : 			}
; 134  : 			*ppBuff = ppReallocBuf;
; 135  : 		} else
; 136  : 		{
; 137  : 			free(*ppBuff);

  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 _free
  0003d	83 c4 04	 add	 esp, 4
$LN28@AtlConvAll:

; 147  : 		{			
; 148  : 			*ppBuff=pszFixedBuffer;

  00040	89 3e		 mov	 DWORD PTR [esi], edi
$LN29@AtlConvAll:

; 149  : 		}
; 150  : 	}
; 151  : 
; 152  : 	if (*ppBuff == NULL)

  00042	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	75 16		 jne	 SHORT $LN30@AtlConvAll
  00049	eb 3e		 jmp	 SHORT $LN38@AtlConvAll
$LN23@AtlConvAll:

; 138  : 			*ppBuff=pszFixedBuffer;
; 139  : 		}
; 140  : 
; 141  : 	} else //Buffer is not currently malloced.
; 142  : 	{
; 143  : 		if( nLength > nFixedBufferLength )

  0004b	3b 45 14	 cmp	 eax, DWORD PTR _nFixedBufferLength$[ebp]
  0004e	7e f0		 jle	 SHORT $LN28@AtlConvAll

; 144  : 		{
; 145  : 			*ppBuff = static_cast< _CharType* >( calloc(nLength,sizeof( _CharType ) ) );

  00050	6a 01		 push	 1
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 _calloc
  00058	83 c4 08	 add	 esp, 8
$LN27@AtlConvAll:
  0005b	89 06		 mov	 DWORD PTR [esi], eax

; 146  : 		} else

  0005d	eb e3		 jmp	 SHORT $LN29@AtlConvAll
$LN30@AtlConvAll:

; 155  : 	}
; 156  : }

  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
$LN33@AtlConvAll:

; 120  : 	ATLENSURE_THROW(ppBuff != NULL, E_INVALIDARG);

  00061	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00066	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN39@AtlConvAll:
$LN35@AtlConvAll:

; 121  : 	ATLENSURE_THROW(nLength >= 0, E_INVALIDARG);

  0006b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00070	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN40@AtlConvAll:
$LN36@AtlConvAll:

; 122  : 	ATLENSURE_THROW(pszFixedBuffer != NULL, E_INVALIDARG);

  00075	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0007a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN41@AtlConvAll:
$LN37@AtlConvAll:

; 131  : 			{
; 132  : 				AtlThrow( E_OUTOFMEMORY );

  0007f	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00084	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN42@AtlConvAll:
$LN38@AtlConvAll:

; 153  : 	{
; 154  : 		AtlThrow( E_OUTOFMEMORY );

  00089	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0008e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN43@AtlConvAll:
$LN32@AtlConvAll:
  00093	cc		 int	 3
??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z ENDP	; ATL::AtlConvAllocMemory<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 281  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??$AtlConvFreeMemory@D@ATL@@YAXPAD0H@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
_pszFixedBuffer$ = 12					; size = 4
_nFixedBufferLength$ = 16				; size = 4
??$AtlConvFreeMemory@D@ATL@@YAXPAD0H@Z PROC		; ATL::AtlConvFreeMemory<char>, COMDAT

; 163  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 164  : 	(nFixedBufferLength);
; 165  : 	if( pBuff != pszFixedBuffer )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	3b 45 0c	 cmp	 eax, DWORD PTR _pszFixedBuffer$[ebp]
  00009	74 09		 je	 SHORT $LN2@AtlConvFre

; 166  : 	{
; 167  : 		free( pBuff );

  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _free
  00011	83 c4 04	 add	 esp, 4
$LN2@AtlConvFre:

; 168  : 	} 	
; 169  : #ifdef _DEBUG
; 170  : 	else
; 171  : 	{		
; 172  : 		memset(pszFixedBuffer,ATLCONV_DEADLAND_FILL,nFixedBufferLength*sizeof(_CharType));
; 173  : 	}
; 174  : #endif
; 175  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$AtlConvFreeMemory@D@ATL@@YAXPAD0H@Z ENDP		; ATL::AtlConvFreeMemory<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ?get@?$auto_ptr@VFile@GostCrypt@@@std@@QBEPAVFile@GostCrypt@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VFile@GostCrypt@@@std@@QBEPAVFile@GostCrypt@@XZ PROC ; std::auto_ptr<GostCrypt::File>::get, COMDAT
; _this$ = ecx

; 782  : 		return (_Myptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 783  : 		}

  00002	c3		 ret	 0
?get@?$auto_ptr@VFile@GostCrypt@@@std@@QBEPAVFile@GostCrypt@@XZ ENDP ; std::auto_ptr<GostCrypt::File>::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??C?$auto_ptr@VFile@GostCrypt@@@std@@QBEPAVFile@GostCrypt@@XZ
_TEXT	SEGMENT
??C?$auto_ptr@VFile@GostCrypt@@@std@@QBEPAVFile@GostCrypt@@XZ PROC ; std::auto_ptr<GostCrypt::File>::operator->, COMDAT
; _this$ = ecx

; 772  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 773  : 		if (_Myptr == 0)
; 774  : 			_DEBUG_ERROR("auto_ptr not dereferencable");
; 775  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 776  : 
; 777  : 		return (get());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 778  : 		}

  00002	c3		 ret	 0
??C?$auto_ptr@VFile@GostCrypt@@@std@@QBEPAVFile@GostCrypt@@XZ ENDP ; std::auto_ptr<GostCrypt::File>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??1?$auto_ptr@VFile@GostCrypt@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$auto_ptr@VFile@GostCrypt@@@std@@QAE@XZ PROC	; std::auto_ptr<GostCrypt::File>::~auto_ptr<GostCrypt::File>, COMDAT
; _this$ = ecx

; 756  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$auto_ptr@VFile@GostCrypt@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 757  : 		delete _Myptr;

  00024	8b 39		 mov	 edi, DWORD PTR [ecx]
  00026	85 ff		 test	 edi, edi
  00028	74 48		 je	 SHORT $LN6@auto_ptr
  0002a	8b cf		 mov	 ecx, edi
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	e8 00 00 00 00	 call	 ?Close@File@GostCrypt@@QAEXXZ ; GostCrypt::File::Close
  00038	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0003b	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  0003e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00041	72 0b		 jb	 SHORT $LN18@auto_ptr
  00043	40		 inc	 eax
  00044	8b ce		 mov	 ecx, esi
  00046	50		 push	 eax
  00047	ff 36		 push	 DWORD PTR [esi]
  00049	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN18@auto_ptr:
  0004e	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00055	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00059	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00060	72 02		 jb	 SHORT $LN107@auto_ptr
  00062	8b 36		 mov	 esi, DWORD PTR [esi]
$LN107@auto_ptr:
  00064	6a 30		 push	 48			; 00000030H
  00066	57		 push	 edi
  00067	c6 06 00	 mov	 BYTE PTR [esi], 0
  0006a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006f	83 c4 08	 add	 esp, 8
$LN6@auto_ptr:

; 758  : 		}

  00072	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00075	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007c	59		 pop	 ecx
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$auto_ptr@VFile@GostCrypt@@@std@@QAE@XZ$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$auto_ptr@VFile@GostCrypt@@@std@@QAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$auto_ptr@VFile@GostCrypt@@@std@@QAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$auto_ptr@VFile@GostCrypt@@@std@@QAE@XZ ENDP	; std::auto_ptr<GostCrypt::File>::~auto_ptr<GostCrypt::File>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??0?$auto_ptr@VFile@GostCrypt@@@std@@QAE@PAVFile@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VFile@GostCrypt@@@std@@QAE@PAVFile@GostCrypt@@@Z PROC ; std::auto_ptr<GostCrypt::File>::auto_ptr<GostCrypt::File>, COMDAT
; _this$ = ecx

; 698  : 		{	// construct from object pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 		: _Myptr(_Ptr)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 699  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0?$auto_ptr@VFile@GostCrypt@@@std@@QAE@PAVFile@GostCrypt@@@Z ENDP ; std::auto_ptr<GostCrypt::File>::auto_ptr<GostCrypt::File>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlconv.h
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z
_TEXT	SEGMENT
_nLengthW$1$ = 8					; size = 4
_psz$ = 8						; size = 4
_nConvertCodePage$ = 12					; size = 4
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z PROC		; ATL::CW2AEX<128>::Init, COMDAT
; _this$ = ecx

; 446  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 447  : 		if (psz == NULL)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _psz$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	75 08		 jne	 SHORT $LN2@Init

; 448  : 		{
; 449  : 			m_psz = NULL;

  0000e	89 1f		 mov	 DWORD PTR [edi], ebx
$LN5@Init:
  00010	5f		 pop	 edi
  00011	5b		 pop	 ebx

; 473  : 		}
; 474  : 	}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
$LN2@Init:

; 450  : 			return;
; 451  : 		}
; 452  : 		int nLengthW = static_cast<int>(wcslen( psz ))+1;

  00016	8b cb		 mov	 ecx, ebx
  00018	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  0001b	0f 1f 44 00 00	 npad	 5
$LL10@Init:
  00020	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00023	83 c1 02	 add	 ecx, 2
  00026	66 85 c0	 test	 ax, ax
  00029	75 f5		 jne	 SHORT $LL10@Init
  0002b	2b ca		 sub	 ecx, edx
  0002d	d1 f9		 sar	 ecx, 1
  0002f	56		 push	 esi

; 453  : 		int nLengthA = nLengthW*4;
; 454  : 		
; 455  : 		AtlConvAllocMemory(&m_psz,nLengthA,m_szBuffer,t_nBufferLength);

  00030	68 80 00 00 00	 push	 128			; 00000080H
  00035	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00038	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  0003f	89 45 08	 mov	 DWORD PTR _nLengthW$1$[ebp], eax
  00042	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00045	50		 push	 eax
  00046	56		 push	 esi
  00047	57		 push	 edi
  00048	e8 00 00 00 00	 call	 ??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z ; ATL::AtlConvAllocMemory<char>
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 456  : 
; 457  : 		BOOL bFailed=(0 == ::WideCharToMultiByte( nConvertCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ));

  00050	6a 00		 push	 0
  00052	6a 00		 push	 0
  00054	56		 push	 esi
  00055	ff 37		 push	 DWORD PTR [edi]
  00057	ff 75 08	 push	 DWORD PTR _nLengthW$1$[ebp]
  0005a	53		 push	 ebx
  0005b	6a 00		 push	 0
  0005d	ff 75 0c	 push	 DWORD PTR _nConvertCodePage$[ebp]
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00066	8b f0		 mov	 esi, eax
  00068	f7 de		 neg	 esi
  0006a	1b f6		 sbb	 esi, esi
  0006c	83 c6 01	 add	 esi, 1

; 458  : 		if (bFailed)

  0006f	74 54		 je	 SHORT $LN4@Init

; 459  : 		{
; 460  : 			if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00077	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  0007a	75 49		 jne	 SHORT $LN4@Init

; 461  : 			{
; 462  : 				nLengthA = ::WideCharToMultiByte( nConvertCodePage, 0, psz, nLengthW, NULL, 0, NULL, NULL );

  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	6a 00		 push	 0
  00082	6a 00		 push	 0
  00084	ff 75 08	 push	 DWORD PTR _nLengthW$1$[ebp]
  00087	53		 push	 ebx
  00088	6a 00		 push	 0
  0008a	ff 75 0c	 push	 DWORD PTR _nConvertCodePage$[ebp]
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00093	8b f0		 mov	 esi, eax

; 463  : ATLPREFAST_SUPPRESS(6102)
; 464  :                 AtlConvAllocMemory(&m_psz,nLengthA,m_szBuffer,t_nBufferLength);

  00095	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00098	68 80 00 00 00	 push	 128			; 00000080H
  0009d	50		 push	 eax
  0009e	56		 push	 esi
  0009f	57		 push	 edi
  000a0	e8 00 00 00 00	 call	 ??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z ; ATL::AtlConvAllocMemory<char>
  000a5	83 c4 10	 add	 esp, 16			; 00000010H

; 465  : ATLPREFAST_UNSUPPRESS()
; 466  : 				bFailed=(0 == ::WideCharToMultiByte( nConvertCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ));

  000a8	6a 00		 push	 0
  000aa	6a 00		 push	 0
  000ac	56		 push	 esi
  000ad	ff 37		 push	 DWORD PTR [edi]
  000af	ff 75 08	 push	 DWORD PTR _nLengthW$1$[ebp]
  000b2	53		 push	 ebx
  000b3	6a 00		 push	 0
  000b5	ff 75 0c	 push	 DWORD PTR _nConvertCodePage$[ebp]
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  000be	8b f0		 mov	 esi, eax
  000c0	f7 de		 neg	 esi
  000c2	1b f6		 sbb	 esi, esi
  000c4	46		 inc	 esi
$LN4@Init:

; 467  : 			}			
; 468  : 		}
; 469  : 		if (bFailed)

  000c5	85 f6		 test	 esi, esi
  000c7	5e		 pop	 esi
  000c8	0f 84 42 ff ff
	ff		 je	 $LN5@Init

; 470  : 		{
; 471  : 			AtlConvFreeMemory(m_psz, m_szBuffer, t_nBufferLength);

  000ce	8b 07		 mov	 eax, DWORD PTR [edi]
  000d0	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000d3	3b c1		 cmp	 eax, ecx
  000d5	74 09		 je	 SHORT $LN8@Init
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 _free
  000dd	83 c4 04	 add	 esp, 4
$LN8@Init:

; 472  : 			AtlThrowLastWin32();

  000e0	e8 00 00 00 00	 call	 ?AtlThrowLastWin32@ATL@@YGXXZ ; ATL::AtlThrowLastWin32
$LN14@Init:
$LN11@Init:
  000e5	cc		 int	 3
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ENDP		; ATL::CW2AEX<128>::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ PROC			; ATL::CW2AEX<128>::operator char *, COMDAT
; _this$ = ecx

; 439  : 		return( m_psz );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 440  : 	}

  00002	c3		 ret	 0
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ENDP			; ATL::CW2AEX<128>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ PROC			; ATL::CW2AEX<128>::~CW2AEX<128>, COMDAT
; _this$ = ecx

; 434  : 		AtlConvFreeMemory(m_psz,m_szBuffer,t_nBufferLength);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00005	3b d0		 cmp	 edx, eax
  00007	74 07		 je	 SHORT $LN4@CW2AEX
  00009	52		 push	 edx
  0000a	e8 00 00 00 00	 call	 _free
  0000f	59		 pop	 ecx
$LN4@CW2AEX:

; 435  : 	}

  00010	c3		 ret	 0
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ENDP			; ATL::CW2AEX<128>::~CW2AEX<128>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z PROC			; ATL::CW2AEX<128>::CW2AEX<128>, COMDAT
; _this$ = ecx

; 422  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 423  : 		Init( psz, _AtlGetConversionACP() );

  00006	6a 03		 push	 3
  00008	ff 75 08	 push	 DWORD PTR _psz$[ebp]
  0000b	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0000e	89 06		 mov	 DWORD PTR [esi], eax
  00010	e8 00 00 00 00	 call	 ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ; ATL::CW2AEX<128>::Init

; 424  : 	}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z ENDP			; ATL::CW2AEX<128>::CW2AEX<128>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GFile@GostCrypt@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_GFile@GostCrypt@@QAEPAXI@Z PROC			; GostCrypt::File::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_GFile@GostCrypt@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002d	e8 00 00 00 00	 call	 ?Close@File@GostCrypt@@QAEXXZ ; GostCrypt::File::Close
  00032	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00035	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  00038	83 f8 10	 cmp	 eax, 16			; 00000010H
  0003b	72 0b		 jb	 SHORT $LN13@scalar
  0003d	40		 inc	 eax
  0003e	8b ce		 mov	 ecx, esi
  00040	50		 push	 eax
  00041	ff 36		 push	 DWORD PTR [esi]
  00043	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN13@scalar:
  00048	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0004f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00053	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0005a	72 02		 jb	 SHORT $LN102@scalar
  0005c	8b 36		 mov	 esi, DWORD PTR [esi]
$LN102@scalar:
  0005e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00062	c6 06 00	 mov	 BYTE PTR [esi], 0
  00065	74 0b		 je	 SHORT $LN108@scalar
  00067	6a 30		 push	 48			; 00000030H
  00069	57		 push	 edi
  0006a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006f	83 c4 08	 add	 esp, 8
$LN108@scalar:
  00072	8b c7		 mov	 eax, edi
  00074	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00077	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007e	59		 pop	 ecx
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_GFile@GostCrypt@@QAEPAXI@Z$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_GFile@GostCrypt@@QAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_GFile@GostCrypt@@QAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_GFile@GostCrypt@@QAEPAXI@Z ENDP			; GostCrypt::File::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.h
;	COMDAT ??1File@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1File@GostCrypt@@QAE@XZ PROC				; GostCrypt::File::~File, COMDAT
; _this$ = ecx

; 27   : 		~File () { Close(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1File@GostCrypt@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	e8 00 00 00 00	 call	 ?Close@File@GostCrypt@@QAEXXZ ; GostCrypt::File::Close
  0002a	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0002d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00030	72 0d		 jb	 SHORT $LN9@File
  00032	40		 inc	 eax
  00033	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00036	50		 push	 eax
  00037	ff 76 18	 push	 DWORD PTR [esi+24]
  0003a	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN9@File:
  0003f	c7 46 2c 0f 00
	00 00		 mov	 DWORD PTR [esi+44], 15	; 0000000fH
  00046	83 7e 2c 10	 cmp	 DWORD PTR [esi+44], 16	; 00000010H
  0004a	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00051	72 16		 jb	 SHORT $LN97@File
  00053	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00056	c6 00 00	 mov	 BYTE PTR [eax], 0
  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	5e		 pop	 esi
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN97@File:
  00069	c6 46 18 00	 mov	 BYTE PTR [esi+24], 0
  0006d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00077	59		 pop	 ecx
  00078	5e		 pop	 esi
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1File@GostCrypt@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1File@GostCrypt@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1File@GostCrypt@@QAE@XZ ENDP				; GostCrypt::File::~File
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	72 04		 jb	 SHORT $LN17@Check_offs

; 2273 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN17@Check_offs:

; 2272 : 			_Xran();

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN19@Check_offs:
$LN16@Check_offs:
  00019	cc		 int	 3
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2266 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2249 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 26		 je	 SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 20		 jb	 SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN57@Tidy

; 2256 : 				_Traits::copy(this->_Bx()._Buf,

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@Tidy:

; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00028	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002b	8b ce		 mov	 ecx, esi
  0002d	40		 inc	 eax
  0002e	50		 push	 eax
  0002f	53		 push	 ebx
  00030	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  00035	5b		 pop	 ebx
$LN4@Tidy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00036	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2261 : 		_Eos(_Newsize);

  0003d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00041	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00044	72 0c		 jb	 SHORT $LN92@Tidy
  00046	8b 06		 mov	 eax, DWORD PTR [esi]
  00048	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi

; 2262 : 		}

  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8

; 2261 : 		_Eos(_Newsize);

$LN92@Tidy:
  00052	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 2262 : 		}

  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	74 2d		 je	 SHORT $LN4@Inside
  0000b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00011	72 04		 jb	 SHORT $LN16@Inside
  00013	8b 31		 mov	 esi, DWORD PTR [ecx]
  00015	eb 02		 jmp	 SHORT $LN17@Inside
$LN16@Inside:
  00017	8b f1		 mov	 esi, ecx
$LN17@Inside:
  00019	3b d6		 cmp	 edx, esi
  0001b	72 1b		 jb	 SHORT $LN4@Inside
  0001d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00020	72 04		 jb	 SHORT $LN30@Inside
  00022	8b 31		 mov	 esi, DWORD PTR [ecx]
  00024	eb 02		 jmp	 SHORT $LN31@Inside
$LN30@Inside:
  00026	8b f1		 mov	 esi, ecx
$LN31@Inside:
  00028	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002b	03 c6		 add	 eax, esi
  0002d	3b c2		 cmp	 eax, edx
  0002f	76 07		 jbe	 SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

  00031	b0 01		 mov	 al, 1
  00033	5e		 pop	 esi

; 2244 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 2244 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2225 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0000a	77 59		 ja	 SHORT $LN89@Grow

; 2227 : 		if (this->_Myres() < _Newsize)

  0000c	39 71 14	 cmp	 DWORD PTR [ecx+20], esi
  0000f	73 13		 jae	 SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00011	ff 71 10	 push	 DWORD PTR [ecx+16]
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0001a	85 f6		 test	 esi, esi
  0001c	5e		 pop	 esi
  0001d	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00024	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  00028	74 1f		 je	 SHORT $LN5@Grow
  0002a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0002d	73 1a		 jae	 SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  0002f	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00032	3b f0		 cmp	 esi, eax
  00034	0f 42 c6	 cmovb	 eax, esi
  00037	50		 push	 eax
  00038	6a 01		 push	 1
  0003a	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  0003f	85 f6		 test	 esi, esi
  00041	5e		 pop	 esi
  00042	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

  00049	85 f6		 test	 esi, esi
  0004b	75 10		 jne	 SHORT $LN88@Grow

; 2233 : 			_Eos(0);	// new size is zero, just null terminate

  0004d	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00051	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  00054	72 02		 jb	 SHORT $LN80@Grow
  00056	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN80@Grow:
  00058	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0005b	85 f6		 test	 esi, esi
$LN88@Grow:
  0005d	0f 95 c0	 setne	 al
  00060	5e		 pop	 esi

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN89@Grow:

; 2226 : 			_Xlen();	// result too long

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0006a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN91@Grow:
$LN87@Grow:
  0006f	cc		 int	 3
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0000a	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000d	72 0a		 jb	 SHORT $LN11@Eos
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0

; 2220 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

$LN11@Eos:
  00019	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0

; 2220 : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f8		 mov	 edi, eax
  00035	83 cf 0f	 or	 edi, 15			; 0000000fH

; 2184 : 		if (max_size() < _Newres)

  00038	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0003b	76 04		 jbe	 SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

  0003d	8b f8		 mov	 edi, eax
  0003f	eb 27		 jmp	 SHORT $LN108@Copy
$LN2@Copy:

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  00041	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00044	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00049	f7 e7		 mul	 edi
  0004b	8b cb		 mov	 ecx, ebx
  0004d	d1 e9		 shr	 ecx, 1
  0004f	d1 ea		 shr	 edx, 1
  00051	3b ca		 cmp	 ecx, edx
  00053	76 13		 jbe	 SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 2189 : 			_Newres = this->_Myres()

  0005a	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]
  0005d	2b c1		 sub	 eax, ecx
  0005f	3b d8		 cmp	 ebx, eax
  00061	76 05		 jbe	 SHORT $LN108@Copy

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()

  00063	bf fe ff ff ff	 mov	 edi, -2			; fffffffeH
$LN108@Copy:

; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  00068	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0006b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00072	85 c0		 test	 eax, eax
  00074	75 04		 jne	 SHORT $LN136@Copy
  00076	33 db		 xor	 ebx, ebx
  00078	eb 6d		 jmp	 SHORT $LN19@Copy
$LN136@Copy:
  0007a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0007f	72 29		 jb	 SHORT $LN138@Copy
  00081	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00084	3b c8		 cmp	 ecx, eax
  00086	77 05		 ja	 SHORT $LN140@Copy
  00088	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN435@Copy:
$LN140@Copy:
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00093	83 c4 04	 add	 esp, 4
  00096	85 c0		 test	 eax, eax
  00098	75 05		 jne	 SHORT $LN141@Copy
  0009a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN436@Copy:
$LN141@Copy:
  0009f	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  000a2	83 e3 e0	 and	 ebx, -32		; ffffffe0H
  000a5	89 43 fc	 mov	 DWORD PTR [ebx-4], eax
  000a8	eb 3d		 jmp	 SHORT $LN19@Copy
$LN138@Copy:
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b0	8b d8		 mov	 ebx, eax
  000b2	83 c4 04	 add	 esp, 4
  000b5	85 db		 test	 ebx, ebx
  000b7	75 2e		 jne	 SHORT $LN19@Copy
  000b9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN437@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000be	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  000c1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax
  000c7	40		 inc	 eax
  000c8	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  000cb	50		 push	 eax
  000cc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000d0	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  000d5	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

  000d8	b8 00 00 00 00	 mov	 eax, $LN432@Copy
  000dd	c3		 ret	 0
$LN432@Copy:
  000de	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000e1	8b 7d 08	 mov	 edi, DWORD PTR __Newres$[ebp]
  000e4	8b 5d e8	 mov	 ebx, DWORD PTR __Ptr$[ebp]
$LN19@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

  000e7	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  000ea	85 c0		 test	 eax, eax
  000ec	74 1b		 je	 SHORT $LN270@Copy

; 2208 : 			_Traits::copy(_Unfancy(_Ptr), this->_Myptr(),

  000ee	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000f2	72 04		 jb	 SHORT $LN261@Copy
  000f4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000f6	eb 02		 jmp	 SHORT $LN262@Copy
$LN261@Copy:
  000f8	8b ce		 mov	 ecx, esi
$LN262@Copy:
  000fa	85 c0		 test	 eax, eax
  000fc	74 0b		 je	 SHORT $LN270@Copy
  000fe	50		 push	 eax
  000ff	51		 push	 ecx
  00100	53		 push	 ebx
  00101	e8 00 00 00 00	 call	 _memcpy
  00106	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN270@Copy:

; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);

  00109	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0010c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0010f	72 0b		 jb	 SHORT $LN274@Copy
  00111	40		 inc	 eax
  00112	8b ce		 mov	 ecx, esi
  00114	50		 push	 eax
  00115	ff 36		 push	 DWORD PTR [esi]
  00117	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN274@Copy:
  0011c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00123	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00127	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0012e	72 04		 jb	 SHORT $LN362@Copy
  00130	8b 06		 mov	 eax, DWORD PTR [esi]
  00132	eb 02		 jmp	 SHORT $LN363@Copy
$LN362@Copy:
  00134	8b c6		 mov	 eax, esi
$LN363@Copy:
  00136	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2211 : 		this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Ptr);
; 2212 : 		this->_Myres() = _Newres;
; 2213 : 		_Eos(_Oldlen);

  00139	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  0013c	89 1e		 mov	 DWORD PTR [esi], ebx
  0013e	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00141	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00145	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00148	72 02		 jb	 SHORT $LN426@Copy
  0014a	8b f3		 mov	 esi, ebx
$LN426@Copy:
  0014c	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0

; 2214 : 		}

  00150	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00153	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015a	59		 pop	 ecx
  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

  00164	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00167	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0016a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0016d	72 0b		 jb	 SHORT $LN156@Copy
  0016f	40		 inc	 eax
  00170	8b ce		 mov	 ecx, esi
  00172	50		 push	 eax
  00173	ff 36		 push	 DWORD PTR [esi]
  00175	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN156@Copy:
  0017a	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00181	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00185	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0018c	72 02		 jb	 SHORT $LN245@Copy
  0018e	8b 36		 mov	 esi, DWORD PTR [esi]
$LN245@Copy:

; 2203 : 			_RERAISE;

  00190	6a 00		 push	 0
  00192	6a 00		 push	 0
  00194	c6 06 00	 mov	 BYTE PTR [esi], 0
  00197	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN438@Copy:
$LN434@Copy:
  0019c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

  00009	39 45 0c	 cmp	 DWORD PTR __Size$[ebp], eax
  0000c	0f 46 45 0c	 cmovbe	 eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1772 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1348 : 		_Check_offset(_Off);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	72 7e		 jb	 SHORT $LN93@erase

; 1349 : 		if (this->_Mysize() - _Off <= _Count)

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00014	8b c7		 mov	 eax, edi
  00016	2b c1		 sub	 eax, ecx
  00018	3b c2		 cmp	 eax, edx
  0001a	77 23		 ja	 SHORT $LN2@erase

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

  0001c	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0001f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00023	72 0e		 jb	 SHORT $LN41@erase
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	5f		 pop	 edi
  00028	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1357 : 			}
; 1358 : 		return (*this);

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi

; 1359 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

$LN41@erase:
  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1359 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN2@erase:

; 1351 : 		else if (0 < _Count)

  0003f	85 d2		 test	 edx, edx
  00041	74 44		 je	 SHORT $LN90@erase

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;

  00043	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00047	72 04		 jb	 SHORT $LN58@erase
  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	eb 02		 jmp	 SHORT $LN59@erase
$LN58@erase:
  0004d	8b c6		 mov	 eax, esi
$LN59@erase:

; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

  0004f	2b fa		 sub	 edi, edx
  00051	53		 push	 ebx
  00052	8d 1c 08	 lea	 ebx, DWORD PTR [eax+ecx]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00055	8b c7		 mov	 eax, edi
  00057	2b c1		 sub	 eax, ecx
  00059	74 0e		 je	 SHORT $LN74@erase
  0005b	50		 push	 eax
  0005c	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  0005f	50		 push	 eax
  00060	53		 push	 ebx
  00061	e8 00 00 00 00	 call	 _memmove
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@erase:

; 1356 : 			_Eos(_Newsize);

  00069	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0006d	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00070	5b		 pop	 ebx
  00071	72 0e		 jb	 SHORT $LN85@erase
  00073	8b 06		 mov	 eax, DWORD PTR [esi]
  00075	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1357 : 			}
; 1358 : 		return (*this);

  00079	8b c6		 mov	 eax, esi
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 1359 : 		}

  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8

; 1356 : 			_Eos(_Newsize);

$LN85@erase:
  00081	8b c6		 mov	 eax, esi
  00083	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN90@erase:

; 1357 : 			}
; 1358 : 		return (*this);

  00087	5f		 pop	 edi
  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi

; 1359 : 		}

  0008b	5d		 pop	 ebp
  0008c	c2 08 00	 ret	 8
$LN93@erase:

; 1348 : 		_Check_offset(_Off);

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00094	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN95@erase:
$LN92@erase:
  00099	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1341 : 		_Check_offset(_Off);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	72 21		 jb	 SHORT $LN37@erase

; 1342 : 		_Eos(_Off);

  0000b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000e	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00012	72 0c		 jb	 SHORT $LN29@erase
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 1343 : 		return (*this);

  0001a	8b c1		 mov	 eax, ecx

; 1344 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4

; 1342 : 		_Eos(_Off);

$LN29@erase:
  00020	8b d1		 mov	 edx, ecx
  00022	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 1343 : 		return (*this);

  00026	8b c1		 mov	 eax, ecx

; 1344 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN37@erase:

; 1341 : 		_Check_offset(_Off);

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00031	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN39@erase:
$LN36@erase:
  00036	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN5@assign
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00015	5e		 pop	 esi

; 1183 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

$LN5@assign:
  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@assign:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL7@assign
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00031	5e		 pop	 esi

; 1183 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1166 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1167 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 57		 je	 SHORT $LN2@assign
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN20@assign
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN21@assign
$LN20@assign:
  0001a	8b c6		 mov	 eax, esi
$LN21@assign:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 45		 jb	 SHORT $LN2@assign
  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN34@assign
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN35@assign
$LN34@assign:
  00029	8b d6		 mov	 edx, esi
$LN35@assign:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	03 c2		 add	 eax, edx
  00030	3b c3		 cmp	 eax, ebx
  00032	76 31		 jbe	 SHORT $LN2@assign

; 1168 : 			return (assign(*this,

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 16		 jb	 SHORT $LN57@assign
  00039	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	8b ce		 mov	 ecx, esi
  00040	2b d8		 sub	 ebx, eax
  00042	53		 push	 ebx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 1177 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8

; 1168 : 			return (assign(*this,

$LN57@assign:
  0004f	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00052	8b c6		 mov	 eax, esi
  00054	8b ce		 mov	 ecx, esi
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 1177 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN2@assign:
  00065	57		 push	 edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  00066	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00069	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0006c	77 7d		 ja	 SHORT $LN187@assign
  0006e	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00071	73 19		 jae	 SHORT $LN63@assign
  00073	ff 76 10	 push	 DWORD PTR [esi+16]
  00076	8b ce		 mov	 ecx, esi
  00078	57		 push	 edi
  00079	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0007e	85 ff		 test	 edi, edi
  00080	74 60		 je	 SHORT $LN181@assign
$LN186@assign:

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  00082	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00086	72 2b		 jb	 SHORT $LN158@assign
  00088	8b 06		 mov	 eax, DWORD PTR [esi]
  0008a	eb 29		 jmp	 SHORT $LN159@assign

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN63@assign:
  0008c	85 ff		 test	 edi, edi
  0008e	75 f2		 jne	 SHORT $LN186@assign
  00090	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00094	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00097	72 0e		 jb	 SHORT $LN140@assign
  00099	8b 06		 mov	 eax, DWORD PTR [esi]
  0009b	5f		 pop	 edi
  0009c	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1175 : 			}
; 1176 : 		return (*this);

  0009f	8b c6		 mov	 eax, esi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx

; 1177 : 		}

  000a3	5d		 pop	 ebp
  000a4	c2 08 00	 ret	 8

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN140@assign:
  000a7	8b c6		 mov	 eax, esi
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1177 : 		}

  000af	5d		 pop	 ebp
  000b0	c2 08 00	 ret	 8

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

$LN158@assign:
  000b3	8b c6		 mov	 eax, esi
$LN159@assign:
  000b5	85 ff		 test	 edi, edi
  000b7	74 0b		 je	 SHORT $LN165@assign
  000b9	57		 push	 edi
  000ba	53		 push	 ebx
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN165@assign:

; 1174 : 			_Eos(_Count);

  000c4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000c8	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000cb	72 0f		 jb	 SHORT $LN176@assign
  000cd	8b 06		 mov	 eax, DWORD PTR [esi]
  000cf	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1175 : 			}
; 1176 : 		return (*this);

  000d3	8b c6		 mov	 eax, esi
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx

; 1177 : 		}

  000d8	5d		 pop	 ebp
  000d9	c2 08 00	 ret	 8

; 1174 : 			_Eos(_Count);

$LN176@assign:
  000dc	8b c6		 mov	 eax, esi
  000de	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN181@assign:

; 1175 : 			}
; 1176 : 		return (*this);

  000e2	5f		 pop	 edi
  000e3	8b c6		 mov	 eax, esi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 1177 : 		}

  000e7	5d		 pop	 ebp
  000e8	c2 08 00	 ret	 8
$LN187@assign:

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f0	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN189@assign:
$LN184@assign:
  000f5	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1150 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 e9 00 00
	00		 jb	 $LN208@assign

; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00019	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
  0001c	2b c1		 sub	 eax, ecx
  0001e	3b f8		 cmp	 edi, eax
  00020	0f 47 f8	 cmova	 edi, eax

; 1152 : 
; 1153 : 		if (this == &_Right)

  00023	3b f3		 cmp	 esi, ebx
  00025	75 47		 jne	 SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  0002d	0f 82 d9 00 00
	00		 jb	 $LN210@assign
  00033	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00036	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0003a	72 19		 jb	 SHORT $LN63@assign
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	51		 push	 ecx
  0003f	6a 00		 push	 0
  00041	8b ce		 mov	 ecx, esi
  00043	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
  00047	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0004c	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  0004d	8b c6		 mov	 eax, esi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx

; 1162 : 		}

  00051	5d		 pop	 ebp
  00052	c2 0c 00	 ret	 12			; 0000000cH

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

$LN63@assign:
  00055	8b d6		 mov	 edx, esi
  00057	51		 push	 ecx
  00058	6a 00		 push	 0
  0005a	8b ce		 mov	 ecx, esi
  0005c	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
  00060	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00065	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  00066	8b c6		 mov	 eax, esi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 1162 : 		}

  0006a	5d		 pop	 ebp
  0006b	c2 0c 00	 ret	 12			; 0000000cH
$LN2@assign:

; 1155 : 		else if (_Grow(_Count))

  0006e	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00071	0f 87 9f 00 00
	00		 ja	 $LN211@assign
  00077	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0007a	73 24		 jae	 SHORT $LN72@assign
  0007c	ff 76 10	 push	 DWORD PTR [esi+16]
  0007f	8b ce		 mov	 ecx, esi
  00081	57		 push	 edi
  00082	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00087	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0008a	85 ff		 test	 edi, edi
  0008c	74 6b		 je	 SHORT $LN203@assign
$LN207@assign:

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

  0008e	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00092	72 02		 jb	 SHORT $LN166@assign
  00094	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN166@assign:
  00096	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0009a	72 2b		 jb	 SHORT $LN180@assign
  0009c	8b 16		 mov	 edx, DWORD PTR [esi]
  0009e	eb 29		 jmp	 SHORT $LN181@assign

; 1155 : 		else if (_Grow(_Count))

$LN72@assign:
  000a0	85 ff		 test	 edi, edi
  000a2	75 ea		 jne	 SHORT $LN207@assign
  000a4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000a8	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ab	72 0e		 jb	 SHORT $LN149@assign
  000ad	8b 06		 mov	 eax, DWORD PTR [esi]
  000af	5f		 pop	 edi
  000b0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1160 : 			}
; 1161 : 		return (*this);

  000b3	8b c6		 mov	 eax, esi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx

; 1162 : 		}

  000b7	5d		 pop	 ebp
  000b8	c2 0c 00	 ret	 12			; 0000000cH

; 1155 : 		else if (_Grow(_Count))

$LN149@assign:
  000bb	8b c6		 mov	 eax, esi
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1162 : 		}

  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

$LN180@assign:
  000c7	8b d6		 mov	 edx, esi
$LN181@assign:
  000c9	85 ff		 test	 edi, edi
  000cb	74 0e		 je	 SHORT $LN187@assign
  000cd	57		 push	 edi
  000ce	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  000d1	50		 push	 eax
  000d2	52		 push	 edx
  000d3	e8 00 00 00 00	 call	 _memcpy
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN187@assign:

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

  000db	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000df	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000e2	72 0f		 jb	 SHORT $LN198@assign
  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1160 : 			}
; 1161 : 		return (*this);

  000ea	8b c6		 mov	 eax, esi
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx

; 1162 : 		}

  000ef	5d		 pop	 ebp
  000f0	c2 0c 00	 ret	 12			; 0000000cH

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

$LN198@assign:
  000f3	8b c6		 mov	 eax, esi
  000f5	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN203@assign:

; 1160 : 			}
; 1161 : 		return (*this);

  000f9	5f		 pop	 edi
  000fa	8b c6		 mov	 eax, esi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx

; 1162 : 		}

  000fe	5d		 pop	 ebp
  000ff	c2 0c 00	 ret	 12			; 0000000cH
$LN208@assign:

; 1150 : 		_Right._Check_offset(_Roff);

  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00107	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN212@assign:
$LN210@assign:

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  0010c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00111	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN213@assign:
$LN211@assign:

; 1155 : 		else if (_Grow(_Count))

  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN214@assign:
$LN205@assign:
  00120	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1017 : 		_Tidy(true);

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 10	 cmp	 eax, 16			; 00000010H
  00009	72 09		 jb	 SHORT $LN6@basic_stri
  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN6@basic_stri:
  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	72 07		 jb	 SHORT $LN94@basic_stri
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	5e		 pop	 esi
  0002b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1018 : 		}

  0002e	c3		 ret	 0

; 1017 : 		_Tidy(true);

$LN94@basic_stri:
  0002f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00032	5e		 pop	 esi

; 1018 : 		}

  00033	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00017	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001a	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0001d	75 12		 jne	 SHORT $LN111@basic_stri
  0001f	33 d2		 xor	 edx, edx
  00021	52		 push	 edx
  00022	51		 push	 ecx
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 839  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

$LN111@basic_stri:
  00031	8b d1		 mov	 edx, ecx
  00033	57		 push	 edi
  00034	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL113@basic_stri:
  00037	8a 02		 mov	 al, BYTE PTR [edx]
  00039	42		 inc	 edx
  0003a	84 c0		 test	 al, al
  0003c	75 f9		 jne	 SHORT $LL113@basic_stri
  0003e	2b d7		 sub	 edx, edi
  00040	5f		 pop	 edi
  00041	52		 push	 edx
  00042	51		 push	 ecx
  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 839  : 		}

  0004a	8b c6		 mov	 eax, esi
  0004c	5e		 pop	 esi
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 735  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 730  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 725  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

  00000	8b c1		 mov	 eax, ecx

; 715  : 		}

  00002	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 708  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 703  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 698  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 693  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 588  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 590  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 583  : 		return (_Get_data()._Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 584  : 		}

  00008	c3		 ret	 0

; 583  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 584  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 578  : 		return (_Get_data()._Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 579  : 		}

  00008	c3		 ret	 0

; 578  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 579  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 534  : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 499  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	83 c8 ff	 or	 eax, -1

; 1009 : 		}

  00003	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000d	72 19		 jb	 SHORT $LN7@deallocate
  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $LN16@deallocate
  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00016	3b c8		 cmp	 ecx, eax
  00018	73 20		 jae	 SHORT $LN18@deallocate
  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 1e		 jb	 SHORT $LN19@deallocate
  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 1e		 ja	 SHORT $LN20@deallocate
  00026	8b c1		 mov	 eax, ecx
$LN7@deallocate:
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 988  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00035	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN18@deallocate:
  0003a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN19@deallocate:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN20@deallocate:
  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN15@deallocate:
  00049	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 976  : 		return (_Mybase::allocate(_Count));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN6@allocate
$LN15@allocate:

; 977  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 976  : 		return (_Mybase::allocate(_Count));

$LN6@allocate:
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 23		 jb	 SHORT $LN8@allocate
  00015	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00018	3b c8		 cmp	 ecx, eax
  0001a	76 2b		 jbe	 SHORT $LN17@allocate
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	8b c8		 mov	 ecx, eax
  00024	83 c4 04	 add	 esp, 4
  00027	85 c9		 test	 ecx, ecx
  00029	74 21		 je	 SHORT $LN19@allocate
  0002b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002e	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00031	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 977  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4

; 976  : 		return (_Mybase::allocate(_Count));

$LN8@allocate:
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 c5		 jne	 SHORT $LN15@allocate
  00045	eb 0a		 jmp	 SHORT $LN20@allocate
$LN17@allocate:
  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN21@allocate:
$LN19@allocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN20@allocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@allocate:
$LN16@allocate:
  00056	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	83 c8 ff	 or	 eax, -1

; 870  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	83 c8 ff	 or	 eax, -1

; 750  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 23		 jb	 SHORT $LN6@allocate
  00015	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00018	3b c8		 cmp	 ecx, eax
  0001a	76 2b		 jbe	 SHORT $LN14@allocate
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	8b c8		 mov	 ecx, eax
  00024	83 c4 04	 add	 esp, 4
  00027	85 c9		 test	 ecx, ecx
  00029	74 21		 je	 SHORT $LN16@allocate
  0002b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002e	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00031	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 c5		 jne	 SHORT $LN12@allocate
  00045	eb 0a		 jmp	 SHORT $LN17@allocate
$LN14@allocate:
  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN18@allocate:
$LN16@allocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@allocate:
$LN17@allocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@allocate:
$LN13@allocate:
  00056	cc		 int	 3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000d	72 19		 jb	 SHORT $LN5@deallocate
  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $LN13@deallocate
  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00016	3b c8		 cmp	 ecx, eax
  00018	73 20		 jae	 SHORT $LN15@deallocate
  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 1e		 jb	 SHORT $LN16@deallocate
  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 1e		 ja	 SHORT $LN17@deallocate
  00026	8b c1		 mov	 eax, ecx
$LN5@deallocate:
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 721  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00035	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
$LN15@deallocate:
  0003a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN16@deallocate:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN17@deallocate:
  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN12@deallocate:
  00049	cc		 int	 3
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 95   : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 133  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	void *_Ptr = 0;
; 50   : 
; 51   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 56   : 		_Xbad_alloc();	// report no memory
; 57   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 66   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 67   : 			_Xbad_alloc();	// report no memory
; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else
; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 564  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 565  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000b	88 08		 mov	 BYTE PTR [eax], cl

; 566  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 552  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 553  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@move
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@move:

; 553  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  00012	5d		 pop	 ebp

; 553  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 530  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 530  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  00012	5d		 pop	 ebp

; 530  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 522  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 523  : 		return (*_First == 0 ? 0

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	80 38 00	 cmp	 BYTE PTR [eax], 0
  00009	75 04		 jne	 SHORT $LN3@length
  0000b	33 c0		 xor	 eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

  0000f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL5@length:
  00012	8a 08		 mov	 cl, BYTE PTR [eax]
  00014	40		 inc	 eax
  00015	84 c9		 test	 cl, cl
  00017	75 f9		 jne	 SHORT $LL5@length
  00019	2b c2		 sub	 eax, edx

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\basecom.cpp
;	COMDAT ?CreateElevatedComObject@@YAJPAUHWND__@@ABU_GUID@@1PAPAX@Z
_TEXT	SEGMENT
_bo$ = -4136						; size = 36
_monikerName$ = -4100					; size = 2048
_clsid$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_hwnd$ = 8						; size = 4
_guid$ = 12						; size = 4
_iid$ = 16						; size = 4
_ppv$ = 20						; size = 4
?CreateElevatedComObject@@YAJPAUHWND__@@ABU_GUID@@1PAPAX@Z PROC ; CreateElevatedComObject, COMDAT

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 28 10 00 00	 mov	 eax, 4136		; 00001028H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 0c	 mov	 eax, DWORD PTR _guid$[ebp]

; 44   :     WCHAR monikerName[1024];
; 45   :     WCHAR clsid[1024];
; 46   :     BIND_OPTS3 bo;
; 47   : 
; 48   :     StringFromGUID2 (guid, clsid, sizeof (clsid) / 2);

  0001a	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _clsid$[ebp]
  00020	53		 push	 ebx
  00021	8b 5d 10	 mov	 ebx, DWORD PTR _iid$[ebp]
  00024	56		 push	 esi
  00025	8b 75 08	 mov	 esi, DWORD PTR _hwnd$[ebp]
  00028	57		 push	 edi
  00029	8b 7d 14	 mov	 edi, DWORD PTR _ppv$[ebp]
  0002c	68 00 04 00 00	 push	 1024			; 00000400H
  00031	51		 push	 ecx
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StringFromGUID2@12

; 49   : 	swprintf_s (monikerName, sizeof (monikerName) / 2, L"Elevation:Administrator!new:%s", clsid);

  00039	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _clsid$[ebp]
  0003f	50		 push	 eax
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_1DO@BMONIIMG@?$AAE?$AAl?$AAe?$AAv?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?3?$AAA?$AAd?$AAm?$AAi?$AAn?$AAi?$AAs?$AAt?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$CB?$AAn?$AAe?$AAw?$AA?3?$AA?$CF?$AAs?$AA?$AA@
  00045	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _monikerName$[ebp]
  0004b	68 00 04 00 00	 push	 1024			; 00000400H
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _swprintf_s
  00056	0f 57 c0	 xorps	 xmm0, xmm0

; 50   : 
; 51   :     memset (&bo, 0, sizeof (bo));

  00059	c7 85 f8 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR _bo$[ebp+32], 0

; 52   :     bo.cbStruct = sizeof (bo);
; 53   :     bo.hwnd = hwnd;
; 54   :     bo.dwClassContext = CLSCTX_LOCAL_SERVER;
; 55   : 
; 56   : 	// Prevent the GUI from being half-rendered when the UAC prompt "freezes" it
; 57   : 	ProcessPaintMessages (hwnd, 5000);

  00063	68 88 13 00 00	 push	 5000			; 00001388H
  00068	0f 11 85 d8 ef
	ff ff		 movups	 XMMWORD PTR _bo$[ebp], xmm0
  0006f	56		 push	 esi
  00070	0f 11 85 e8 ef
	ff ff		 movups	 XMMWORD PTR _bo$[ebp+16], xmm0
  00077	c7 85 d8 ef ff
	ff 24 00 00 00	 mov	 DWORD PTR _bo$[ebp], 36	; 00000024H
  00081	89 b5 f8 ef ff
	ff		 mov	 DWORD PTR _bo$[ebp+32], esi
  00087	c7 85 ec ef ff
	ff 04 00 00 00	 mov	 DWORD PTR _bo$[ebp+20], 4
  00091	e8 00 00 00 00	 call	 _ProcessPaintMessages
  00096	83 c4 18	 add	 esp, 24			; 00000018H

; 58   : 
; 59   :     return CoGetObject (monikerName, &bo, iid, ppv);

  00099	8d 85 d8 ef ff
	ff		 lea	 eax, DWORD PTR _bo$[ebp]
  0009f	57		 push	 edi
  000a0	53		 push	 ebx
  000a1	50		 push	 eax
  000a2	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _monikerName$[ebp]
  000a8	50		 push	 eax
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoGetObject@16

; 60   : }

  000af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	33 cd		 xor	 ecx, ebp
  000b6	5b		 pop	 ebx
  000b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
?CreateElevatedComObject@@YAJPAUHWND__@@ABU_GUID@@1PAPAX@Z ENDP ; CreateElevatedComObject
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\basecom.cpp
;	COMDAT ?ComGetInstanceBase@@YAHPAUHWND__@@ABU_GUID@@1PAPAX@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
_clsid$ = 12						; size = 4
_iid$ = 16						; size = 4
_gstServer$ = 20					; size = 4
?ComGetInstanceBase@@YAHPAUHWND__@@ABU_GUID@@1PAPAX@Z PROC ; ComGetInstanceBase, COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 76   : 	BOOL r;
; 77   : 
; 78   : 	if (IsUacSupported ())

  00004	e8 00 00 00 00	 call	 _IsUacSupported

; 79   : 		r = CreateElevatedComObject (hWnd, clsid, iid, gstServer) == S_OK;

  00009	ff 75 14	 push	 DWORD PTR _gstServer$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR _iid$[ebp]
  0000f	85 c0		 test	 eax, eax
  00011	74 10		 je	 SHORT $LN2@ComGetInst
  00013	ff 75 0c	 push	 DWORD PTR _clsid$[ebp]
  00016	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  00019	e8 00 00 00 00	 call	 ?CreateElevatedComObject@@YAJPAUHWND__@@ABU_GUID@@1PAPAX@Z ; CreateElevatedComObject
  0001e	83 c4 10	 add	 esp, 16			; 00000010H

; 80   : 	else

  00021	eb 0d		 jmp	 SHORT $LN7@ComGetInst
$LN2@ComGetInst:

; 81   : 		r = CoCreateInstance (clsid, NULL, CLSCTX_LOCAL_SERVER, iid, gstServer) == S_OK;

  00023	6a 04		 push	 4
  00025	6a 00		 push	 0
  00027	ff 75 0c	 push	 DWORD PTR _clsid$[ebp]
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20
$LN7@ComGetInst:
  00030	8b f0		 mov	 esi, eax
  00032	f7 de		 neg	 esi
  00034	1b f6		 sbb	 esi, esi
  00036	46		 inc	 esi
  00037	85 f6		 test	 esi, esi

; 82   : 
; 83   : 	if (!r)

  00039	75 0d		 jne	 SHORT $LN6@ComGetInst

; 84   : 		Error ("UAC_INIT_ERROR");

  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0P@NDJDHMAP@UAC_INIT_ERROR?$AA@
  00040	e8 00 00 00 00	 call	 _Error
  00045	83 c4 04	 add	 esp, 4
$LN6@ComGetInst:

; 85   : 
; 86   : 	return r;

  00048	8b c6		 mov	 eax, esi
  0004a	5e		 pop	 esi

; 87   : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?ComGetInstanceBase@@YAHPAUHWND__@@ABU_GUID@@1PAPAX@Z ENDP ; ComGetInstanceBase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\basecom.cpp
;	COMDAT ?WriteLocalMachineRegistryDwordValue@BaseCom@@SAKPA_W0K@Z
_TEXT	SEGMENT
$T2 = -280						; size = 132
$T3 = -148						; size = 132
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_keyPath$ = 8						; size = 4
_valueName$ = 12					; size = 4
_value$ = 16						; size = 4
?WriteLocalMachineRegistryDwordValue@BaseCom@@SAKPA_W0K@Z PROC ; BaseCom::WriteLocalMachineRegistryDwordValue, COMDAT

; 360  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?WriteLocalMachineRegistryDwordValue@BaseCom@@SAKPA_W0K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _valueName$[ebp]

; 361  : 	USES_CONVERSION;
; 362  : 	if (!::WriteLocalMachineRegistryDword (CW2A (keyPath), CW2A (valueName), value))

  00030	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp+4]
  00036	8b 75 08	 mov	 esi, DWORD PTR _keyPath$[ebp]
  00039	6a 03		 push	 3
  0003b	89 8d e8 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00041	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ; ATL::CW2AEX<128>::Init
  0004d	6a 03		 push	 3
  0004f	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp+4]
  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005c	56		 push	 esi
  0005d	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00063	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00069	e8 00 00 00 00	 call	 ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ; ATL::CW2AEX<128>::Init
  0006e	ff 75 10	 push	 DWORD PTR _value$[ebp]
  00071	ff b5 e8 fe ff
	ff		 push	 DWORD PTR $T2[ebp]
  00077	ff b5 6c ff ff
	ff		 push	 DWORD PTR $T3[ebp]
  0007d	e8 00 00 00 00	 call	 _WriteLocalMachineRegistryDword
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+4]
  0008b	85 c0		 test	 eax, eax
  0008d	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00093	0f 94 c3	 sete	 bl
  00096	3b c1		 cmp	 eax, ecx
  00098	74 09		 je	 SHORT $LN23@WriteLocal
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _free
  000a0	83 c4 04	 add	 esp, 4
$LN23@WriteLocal:
  000a3	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  000a9	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp+4]
  000af	3b c1		 cmp	 eax, ecx
  000b1	74 09		 je	 SHORT $LN28@WriteLocal
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _free
  000b9	83 c4 04	 add	 esp, 4
$LN28@WriteLocal:
  000bc	84 db		 test	 bl, bl
  000be	74 08		 je	 SHORT $LN2@WriteLocal

; 363  : 		return GetLastError();

  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000c6	eb 02		 jmp	 SHORT $LN1@WriteLocal
$LN2@WriteLocal:

; 364  : 
; 365  : 	return ERROR_SUCCESS;

  000c8	33 c0		 xor	 eax, eax
$LN1@WriteLocal:

; 366  : }

  000ca	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d4	59		 pop	 ecx
  000d5	5e		 pop	 esi
  000d6	5b		 pop	 ebx
  000d7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000da	33 cd		 xor	 ecx, ebp
  000dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?WriteLocalMachineRegistryDwordValue@BaseCom@@SAKPA_W0K@Z$0:
  00000	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
__ehhandler$?WriteLocalMachineRegistryDwordValue@BaseCom@@SAKPA_W0K@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a e8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-280]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?WriteLocalMachineRegistryDwordValue@BaseCom@@SAKPA_W0K@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?WriteLocalMachineRegistryDwordValue@BaseCom@@SAKPA_W0K@Z ENDP ; BaseCom::WriteLocalMachineRegistryDwordValue
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\basecom.cpp
;	COMDAT ?SetDriverServiceStartType@BaseCom@@SAKK@Z
_TEXT	SEGMENT
_e$2 = -1508						; size = 4
$T3 = -1504						; size = 4
_bootEnc$4 = -1500					; size = 1480
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_startType$ = 8						; size = 4
?SetDriverServiceStartType@BaseCom@@SAKK@Z PROC		; BaseCom::SetDriverServiceStartType, COMDAT

; 324  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetDriverServiceStartType@BaseCom@@SAKK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 05 00
	00		 sub	 esp, 1496		; 000005d8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 325  : 	try
; 326  : 	{
; 327  : 		BootEncryption bootEnc (NULL);

  00031	6a 00		 push	 0
  00033	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$4[ebp]
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00040	e8 00 00 00 00	 call	 ??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z ; GostCrypt::BootEncryption::BootEncryption

; 328  : 		bootEnc.SetDriverServiceStartType (startType);

  00045	ff 75 08	 push	 DWORD PTR _startType$[ebp]
  00048	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$4[ebp]
  0004e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00052	e8 00 00 00 00	 call	 ?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z ; GostCrypt::BootEncryption::SetDriverServiceStartType

; 329  : 	}

  00057	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$4[ebp]
  0005d	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption

; 342  : 	}
; 343  : 
; 344  : 	return ERROR_SUCCESS;

  00062	33 c0		 xor	 eax, eax
  00064	eb 31		 jmp	 SHORT $LN1@SetDriverS
__catch$?SetDriverServiceStartType@BaseCom@@SAKK@Z$0:

; 330  : 	catch (SystemException &)
; 331  : 	{
; 332  : 		return GetLastError();

  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0006c	89 85 20 fa ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00072	b8 00 00 00 00	 mov	 eax, $LN10@SetDriverS
  00077	c3		 ret	 0
$LN10@SetDriverS:
  00078	8b 85 20 fa ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0007e	eb 17		 jmp	 SHORT $LN1@SetDriverS
__catch$?SetDriverServiceStartType@BaseCom@@SAKK@Z$1:

; 333  : 	}
; 334  : 	catch (Exception &e)
; 335  : 	{
; 336  : 		e.Show (NULL);

  00080	8b 8d 1c fa ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  00086	6a 00		 push	 0
  00088	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008a	ff 10		 call	 DWORD PTR [eax]

; 337  : 		return ERROR_EXCEPTION_IN_SERVICE;

  0008c	b8 00 00 00 00	 mov	 eax, $LN14@SetDriverS
  00091	c3		 ret	 0
$LN14@SetDriverS:

; 338  : 	}
; 339  : 	catch (...)
; 340  : 	{
; 341  : 		return ERROR_EXCEPTION_IN_SERVICE;

  00092	b8 28 04 00 00	 mov	 eax, 1064		; 00000428H
$LN1@SetDriverS:

; 345  : }

  00097	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0009a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a1	59		 pop	 ecx
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a8	33 cd		 xor	 ecx, ebp
  000aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
__catch$?SetDriverServiceStartType@BaseCom@@SAKK@Z$2:

; 338  : 	}
; 339  : 	catch (...)
; 340  : 	{
; 341  : 		return ERROR_EXCEPTION_IN_SERVICE;

  000b3	b8 00 00 00 00	 mov	 eax, $LN14@SetDriverS
  000b8	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetDriverServiceStartType@BaseCom@@SAKK@Z$4:
  00000	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$4[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
__ehhandler$?SetDriverServiceStartType@BaseCom@@SAKK@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 18 fa ff
	ff		 mov	 ecx, DWORD PTR [edx-1512]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetDriverServiceStartType@BaseCom@@SAKK@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetDriverServiceStartType@BaseCom@@SAKK@Z ENDP		; BaseCom::SetDriverServiceStartType
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\basecom.cpp
;	COMDAT ?RegisterSystemFavoritesService@BaseCom@@SAKH@Z
_TEXT	SEGMENT
_e$2 = -1508						; size = 4
$T3 = -1504						; size = 4
_bootEnc$4 = -1500					; size = 1480
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_registerService$ = 8					; size = 4
?RegisterSystemFavoritesService@BaseCom@@SAKH@Z PROC	; BaseCom::RegisterSystemFavoritesService, COMDAT

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 05 00
	00		 sub	 esp, 1496		; 000005d8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 289  : 	try
; 290  : 	{
; 291  : 		BootEncryption bootEnc (NULL);

  00031	6a 00		 push	 0
  00033	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$4[ebp]
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00040	e8 00 00 00 00	 call	 ??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z ; GostCrypt::BootEncryption::BootEncryption

; 292  : 		bootEnc.RegisterSystemFavoritesService (registerService);

  00045	ff 75 08	 push	 DWORD PTR _registerService$[ebp]
  00048	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$4[ebp]
  0004e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00052	e8 00 00 00 00	 call	 ?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z ; GostCrypt::BootEncryption::RegisterSystemFavoritesService

; 293  : 	}

  00057	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$4[ebp]
  0005d	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption

; 306  : 	}
; 307  : 
; 308  : 	return ERROR_SUCCESS;

  00062	33 c0		 xor	 eax, eax
  00064	eb 31		 jmp	 SHORT $LN1@RegisterSy
__catch$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z$0:

; 294  : 	catch (SystemException &)
; 295  : 	{
; 296  : 		return GetLastError();

  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0006c	89 85 20 fa ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00072	b8 00 00 00 00	 mov	 eax, $LN10@RegisterSy
  00077	c3		 ret	 0
$LN10@RegisterSy:
  00078	8b 85 20 fa ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0007e	eb 17		 jmp	 SHORT $LN1@RegisterSy
__catch$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z$1:

; 297  : 	}
; 298  : 	catch (Exception &e)
; 299  : 	{
; 300  : 		e.Show (NULL);

  00080	8b 8d 1c fa ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  00086	6a 00		 push	 0
  00088	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008a	ff 10		 call	 DWORD PTR [eax]

; 301  : 		return ERROR_EXCEPTION_IN_SERVICE;

  0008c	b8 00 00 00 00	 mov	 eax, $LN14@RegisterSy
  00091	c3		 ret	 0
$LN14@RegisterSy:

; 302  : 	}
; 303  : 	catch (...)
; 304  : 	{
; 305  : 		return ERROR_EXCEPTION_IN_SERVICE;

  00092	b8 28 04 00 00	 mov	 eax, 1064		; 00000428H
$LN1@RegisterSy:

; 309  : }

  00097	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0009a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a1	59		 pop	 ecx
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a8	33 cd		 xor	 ecx, ebp
  000aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
__catch$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z$2:

; 302  : 	}
; 303  : 	catch (...)
; 304  : 	{
; 305  : 		return ERROR_EXCEPTION_IN_SERVICE;

  000b3	b8 00 00 00 00	 mov	 eax, $LN14@RegisterSy
  000b8	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z$4:
  00000	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$4[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
__ehhandler$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 18 fa ff
	ff		 mov	 ecx, DWORD PTR [edx-1512]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RegisterSystemFavoritesService@BaseCom@@SAKH@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RegisterSystemFavoritesService@BaseCom@@SAKH@Z ENDP	; BaseCom::RegisterSystemFavoritesService
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\basecom.cpp
;	COMDAT ?RegisterFilterDriver@BaseCom@@SAKHH@Z
_TEXT	SEGMENT
_e$2 = -1508						; size = 4
$T3 = -1504						; size = 4
_bootEnc$4 = -1500					; size = 1480
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_registerDriver$ = 8					; size = 4
_filterType$ = 12					; size = 4
?RegisterFilterDriver@BaseCom@@SAKHH@Z PROC		; BaseCom::RegisterFilterDriver, COMDAT

; 252  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RegisterFilterDriver@BaseCom@@SAKHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 05 00
	00		 sub	 esp, 1496		; 000005d8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 253  : 	try
; 254  : 	{
; 255  : 		BootEncryption bootEnc (NULL);

  00031	6a 00		 push	 0
  00033	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$4[ebp]
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00040	e8 00 00 00 00	 call	 ??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z ; GostCrypt::BootEncryption::BootEncryption

; 256  : 		bootEnc.RegisterFilterDriver (registerDriver ? true : false, (BootEncryption::FilterType) filterType);

  00045	83 7d 08 00	 cmp	 DWORD PTR _registerDriver$[ebp], 0
  00049	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$4[ebp]
  0004f	ff 75 0c	 push	 DWORD PTR _filterType$[ebp]
  00052	0f 95 c0	 setne	 al
  00055	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00059	0f b6 c0	 movzx	 eax, al
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z ; GostCrypt::BootEncryption::RegisterFilterDriver

; 257  : 	}

  00062	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$4[ebp]
  00068	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption

; 270  : 	}
; 271  : 
; 272  : 	return ERROR_SUCCESS;

  0006d	33 c0		 xor	 eax, eax
  0006f	eb 31		 jmp	 SHORT $LN1@RegisterFi
__catch$?RegisterFilterDriver@BaseCom@@SAKHH@Z$0:

; 258  : 	catch (SystemException &)
; 259  : 	{
; 260  : 		return GetLastError();

  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00077	89 85 20 fa ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  0007d	b8 00 00 00 00	 mov	 eax, $LN10@RegisterFi
  00082	c3		 ret	 0
$LN10@RegisterFi:
  00083	8b 85 20 fa ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00089	eb 17		 jmp	 SHORT $LN1@RegisterFi
__catch$?RegisterFilterDriver@BaseCom@@SAKHH@Z$1:

; 261  : 	}
; 262  : 	catch (Exception &e)
; 263  : 	{
; 264  : 		e.Show (NULL);

  0008b	8b 8d 1c fa ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  00091	6a 00		 push	 0
  00093	8b 01		 mov	 eax, DWORD PTR [ecx]
  00095	ff 10		 call	 DWORD PTR [eax]

; 265  : 		return ERROR_EXCEPTION_IN_SERVICE;

  00097	b8 00 00 00 00	 mov	 eax, $LN14@RegisterFi
  0009c	c3		 ret	 0
$LN14@RegisterFi:

; 266  : 	}
; 267  : 	catch (...)
; 268  : 	{
; 269  : 		return ERROR_EXCEPTION_IN_SERVICE;

  0009d	b8 28 04 00 00	 mov	 eax, 1064		; 00000428H
$LN1@RegisterFi:

; 273  : }

  000a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ac	59		 pop	 ecx
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b3	33 cd		 xor	 ecx, ebp
  000b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
__catch$?RegisterFilterDriver@BaseCom@@SAKHH@Z$2:

; 266  : 	}
; 267  : 	catch (...)
; 268  : 	{
; 269  : 		return ERROR_EXCEPTION_IN_SERVICE;

  000be	b8 00 00 00 00	 mov	 eax, $LN14@RegisterFi
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RegisterFilterDriver@BaseCom@@SAKHH@Z$4:
  00000	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$4[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
__ehhandler$?RegisterFilterDriver@BaseCom@@SAKHH@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 18 fa ff
	ff		 mov	 ecx, DWORD PTR [edx-1512]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RegisterFilterDriver@BaseCom@@SAKHH@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RegisterFilterDriver@BaseCom@@SAKHH@Z ENDP		; BaseCom::RegisterFilterDriver
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\basecom.cpp
;	COMDAT ?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z
_TEXT	SEGMENT
_e$2 = -312						; size = 4
$T3 = -308						; size = 4
$T4 = -304						; size = 4
_file$5 = -304						; size = 4
_bufferBstr$GSCopy$1$ = -300				; size = 4
$T6 = -296						; size = 4
_write$GSCopy$1$ = -292					; size = 4
_sizeDone$GSCopy$1$ = -288				; size = 4
$T7 = -288						; size = 4
$T8 = -284						; size = 132
$T9 = -152						; size = 132
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_write$ = 8						; size = 4
_device$ = 12						; size = 4
_filePath$ = 16						; size = 4
_bufferBstr$ = 20					; size = 4
_offset$ = 24						; size = 8
_size$ = 32						; size = 4
_sizeDone$ = 36						; size = 4
?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z PROC	; BaseCom::ReadWriteFile, COMDAT

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 45 08	 mov	 eax, DWORD PTR _write$[ebp]
  00034	33 db		 xor	 ebx, ebx
  00036	8b 7d 10	 mov	 edi, DWORD PTR _filePath$[ebp]
  00039	89 85 dc fe ff
	ff		 mov	 DWORD PTR _write$GSCopy$1$[ebp], eax
  0003f	8b 45 14	 mov	 eax, DWORD PTR _bufferBstr$[ebp]
  00042	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _bufferBstr$GSCopy$1$[ebp], eax
  00048	8b 45 24	 mov	 eax, DWORD PTR _sizeDone$[ebp]
  0004b	89 9d d8 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], ebx

; 204  : 	USES_CONVERSION;
; 205  : 
; 206  : 	try
; 207  : 	{
; 208  : 		auto_ptr <File> file (device ? new Device (string (CW2A (filePath)), !write) : new File (string (CW2A (filePath)), !write));

  00051	6a 30		 push	 48			; 00000030H
  00053	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _sizeDone$GSCopy$1$[ebp], eax
  00059	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
  0005c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00061	83 c4 04	 add	 esp, 4
  00064	8b f0		 mov	 esi, eax
  00066	39 5d 0c	 cmp	 DWORD PTR _device$[ebp], ebx
  00069	74 63		 je	 SHORT $LN10@ReadWriteF
  0006b	89 b5 cc fe ff
	ff		 mov	 DWORD PTR $T3[ebp], esi
  00071	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00075	85 f6		 test	 esi, esi
  00077	74 51		 je	 SHORT $LN6@ReadWriteF
  00079	39 9d dc fe ff
	ff		 cmp	 DWORD PTR _write$GSCopy$1$[ebp], ebx
  0007f	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00085	0f 94 c0	 sete	 al
  00088	0f b6 c0	 movzx	 eax, al
  0008b	50		 push	 eax
  0008c	6a 03		 push	 3
  0008e	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T8[ebp+4]
  00094	57		 push	 edi
  00095	89 85 e4 fe ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
  0009b	e8 00 00 00 00	 call	 ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ; ATL::CW2AEX<128>::Init
  000a0	83 ec 18	 sub	 esp, 24			; 00000018H
  000a3	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000a7	8b cc		 mov	 ecx, esp
  000a9	bb 01 00 00 00	 mov	 ebx, 1
  000ae	89 9d d8 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], ebx
  000b4	ff b5 e4 fe ff
	ff		 push	 DWORD PTR $T8[ebp]
  000ba	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000bf	8b ce		 mov	 ecx, esi
  000c1	e8 00 00 00 00	 call	 ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device
  000c6	8b f8		 mov	 edi, eax
  000c8	eb 02		 jmp	 SHORT $LN7@ReadWriteF
$LN6@ReadWriteF:
  000ca	33 ff		 xor	 edi, edi
$LN7@ReadWriteF:
  000cc	eb 67		 jmp	 SHORT $LN11@ReadWriteF
$LN10@ReadWriteF:
  000ce	89 b5 d0 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], esi
  000d4	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  000db	85 f6		 test	 esi, esi
  000dd	74 54		 je	 SHORT $LN8@ReadWriteF
  000df	83 bd dc fe ff
	ff 00		 cmp	 DWORD PTR _write$GSCopy$1$[ebp], 0
  000e6	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  000ec	6a 00		 push	 0
  000ee	0f 94 c0	 sete	 al
  000f1	0f b6 c0	 movzx	 eax, al
  000f4	50		 push	 eax
  000f5	6a 03		 push	 3
  000f7	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR $T9[ebp+4]
  000fd	57		 push	 edi
  000fe	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
  00104	e8 00 00 00 00	 call	 ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ; ATL::CW2AEX<128>::Init
  00109	83 ec 18	 sub	 esp, 24			; 00000018H
  0010c	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  00110	8b cc		 mov	 ecx, esp
  00112	bb 02 00 00 00	 mov	 ebx, 2
  00117	89 9d d8 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], ebx
  0011d	ff b5 68 ff ff
	ff		 push	 DWORD PTR $T9[ebp]
  00123	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00128	8b ce		 mov	 ecx, esi
  0012a	e8 00 00 00 00	 call	 ??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z ; GostCrypt::File::File
  0012f	8b f8		 mov	 edi, eax
  00131	eb 02		 jmp	 SHORT $LN9@ReadWriteF
$LN8@ReadWriteF:
  00133	33 ff		 xor	 edi, edi
$LN9@ReadWriteF:
$LN11@ReadWriteF:
  00135	89 bd d0 fe ff
	ff		 mov	 DWORD PTR _file$5[ebp], edi
  0013b	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 7
  00142	f6 c3 02	 test	 bl, 2
  00145	74 1c		 je	 SHORT $LN53@ReadWriteF
  00147	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  0014d	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp+4]
  00153	83 e3 fd	 and	 ebx, -3			; fffffffdH
  00156	3b c1		 cmp	 eax, ecx
  00158	74 09		 je	 SHORT $LN53@ReadWriteF
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 _free
  00160	83 c4 04	 add	 esp, 4
$LN53@ReadWriteF:
  00163	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+12], 9
  00167	f6 c3 01	 test	 bl, 1
  0016a	74 19		 je	 SHORT $LN58@ReadWriteF
  0016c	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]
  00172	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp+4]
  00178	3b c1		 cmp	 eax, ecx
  0017a	74 09		 je	 SHORT $LN58@ReadWriteF
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 _free
  00182	83 c4 04	 add	 esp, 4
$LN58@ReadWriteF:

; 209  : 		file->SeekAt (offset);

  00185	ff 75 1c	 push	 DWORD PTR _offset$[ebp+4]
  00188	8b cf		 mov	 ecx, edi
  0018a	ff 75 18	 push	 DWORD PTR _offset$[ebp]
  0018d	e8 00 00 00 00	 call	 ?SeekAt@File@GostCrypt@@QAEX_J@Z ; GostCrypt::File::SeekAt

; 210  : 
; 211  : 		if (write)

  00192	83 bd dc fe ff
	ff 00		 cmp	 DWORD PTR _write$GSCopy$1$[ebp], 0

; 212  : 		{
; 213  : 			file->Write ((BYTE *) *bufferBstr, size);

  00199	8b cf		 mov	 ecx, edi
  0019b	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _bufferBstr$GSCopy$1$[ebp]
  001a1	74 15		 je	 SHORT $LN3@ReadWriteF
  001a3	8b 75 20	 mov	 esi, DWORD PTR _size$[ebp]
  001a6	56		 push	 esi
  001a7	ff 30		 push	 DWORD PTR [eax]
  001a9	e8 00 00 00 00	 call	 ?Write@File@GostCrypt@@QAEXPAEK@Z ; GostCrypt::File::Write

; 214  : 			*sizeDone = size;

  001ae	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _sizeDone$GSCopy$1$[ebp]
  001b4	89 31		 mov	 DWORD PTR [ecx], esi

; 215  : 		}
; 216  : 		else

  001b6	eb 12		 jmp	 SHORT $LN4@ReadWriteF
$LN3@ReadWriteF:

; 217  : 		{
; 218  : 			*sizeDone = file->Read ((BYTE *) *bufferBstr, size);

  001b8	ff 75 20	 push	 DWORD PTR _size$[ebp]
  001bb	ff 30		 push	 DWORD PTR [eax]
  001bd	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read
  001c2	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _sizeDone$GSCopy$1$[ebp]
  001c8	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@ReadWriteF:

; 219  : 		}
; 220  : 	}

  001ca	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  001ce	85 ff		 test	 edi, edi
  001d0	74 45		 je	 SHORT $LN84@ReadWriteF
  001d2	8b cf		 mov	 ecx, edi
  001d4	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  001d8	e8 00 00 00 00	 call	 ?Close@File@GostCrypt@@QAEXXZ ; GostCrypt::File::Close
  001dd	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  001e0	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  001e3	83 f8 10	 cmp	 eax, 16			; 00000010H
  001e6	72 0b		 jb	 SHORT $LN96@ReadWriteF
  001e8	40		 inc	 eax
  001e9	8b ce		 mov	 ecx, esi
  001eb	50		 push	 eax
  001ec	ff 36		 push	 DWORD PTR [esi]
  001ee	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN96@ReadWriteF:
  001f3	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  001fa	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  001fe	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00205	72 02		 jb	 SHORT $LN185@ReadWriteF
  00207	8b 36		 mov	 esi, DWORD PTR [esi]
$LN185@ReadWriteF:
  00209	6a 30		 push	 48			; 00000030H
  0020b	57		 push	 edi
  0020c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0020f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00214	83 c4 08	 add	 esp, 8
$LN84@ReadWriteF:

; 233  : 	}
; 234  : 
; 235  : 	return ERROR_SUCCESS;

  00217	33 c0		 xor	 eax, eax
  00219	eb 31		 jmp	 SHORT $LN1@ReadWriteF
__catch$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$0:

; 221  : 	catch (SystemException &)
; 222  : 	{
; 223  : 		return GetLastError();

  0021b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00221	89 85 e0 fe ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
  00227	b8 00 00 00 00	 mov	 eax, $LN28@ReadWriteF
  0022c	c3		 ret	 0
$LN28@ReadWriteF:
  0022d	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  00233	eb 17		 jmp	 SHORT $LN1@ReadWriteF
__catch$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$1:

; 224  : 	}
; 225  : 	catch (Exception &e)
; 226  : 	{
; 227  : 		e.Show (NULL);

  00235	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  0023b	6a 00		 push	 0
  0023d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0023f	ff 10		 call	 DWORD PTR [eax]

; 228  : 		return ERROR_EXCEPTION_IN_SERVICE;

  00241	b8 00 00 00 00	 mov	 eax, $LN32@ReadWriteF
  00246	c3		 ret	 0
$LN32@ReadWriteF:

; 229  : 	}
; 230  : 	catch (...)
; 231  : 	{
; 232  : 		return ERROR_EXCEPTION_IN_SERVICE;

  00247	b8 28 04 00 00	 mov	 eax, 1064		; 00000428H
$LN1@ReadWriteF:

; 236  : }

  0024c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0024f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00256	59		 pop	 ecx
  00257	5f		 pop	 edi
  00258	5e		 pop	 esi
  00259	5b		 pop	 ebx
  0025a	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0025d	33 cd		 xor	 ecx, ebp
  0025f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00264	8b e5		 mov	 esp, ebp
  00266	5d		 pop	 ebp
  00267	c3		 ret	 0
__catch$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$2:

; 229  : 	}
; 230  : 	catch (...)
; 231  : 	{
; 232  : 		return ERROR_EXCEPTION_IN_SERVICE;

  00268	b8 00 00 00 00	 mov	 eax, $LN32@ReadWriteF
  0026d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$4:
  00000	6a 30		 push	 48			; 00000030H
  00002	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__unwindfunclet$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$5:
  00012	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  00018	83 e0 01	 and	 eax, 1
  0001b	0f 84 12 00 00
	00		 je	 $LN18@ReadWriteF
  00021	83 a5 d8 fe ff
	ff fe		 and	 DWORD PTR $T6[ebp], -2	; fffffffeH
  00028	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0002e	e9 00 00 00 00	 jmp	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
$LN18@ReadWriteF:
  00033	c3		 ret	 0
__unwindfunclet$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$7:
  00034	6a 30		 push	 48			; 00000030H
  00036	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00042	83 c4 08	 add	 esp, 8
  00045	c3		 ret	 0
__unwindfunclet$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$8:
  00046	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  0004c	83 e0 02	 and	 eax, 2
  0004f	0f 84 12 00 00
	00		 je	 $LN22@ReadWriteF
  00055	83 a5 d8 fe ff
	ff fd		 and	 DWORD PTR $T6[ebp], -3	; fffffffdH
  0005c	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00062	e9 00 00 00 00	 jmp	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
$LN22@ReadWriteF:
  00067	c3		 ret	 0
__unwindfunclet$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$10:
  00068	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _file$5[ebp]
  0006e	e9 00 00 00 00	 jmp	 ??1?$auto_ptr@VFile@GostCrypt@@@std@@QAE@XZ ; std::auto_ptr<GostCrypt::File>::~auto_ptr<GostCrypt::File>
__unwindfunclet$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z$20:
  00073	e8 00 00 00 00	 call	 ___std_terminate
  00078	c3		 ret	 0
__ehhandler$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z:
  00079	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0007d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00080	8b 8a c4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-316]
  00086	33 c8		 xor	 ecx, eax
  00088	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00090	33 c8		 xor	 ecx, eax
  00092	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00097	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z
  0009c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ReadWriteFile@BaseCom@@SAKHHPA_WPAPA_W_KIPAK@Z ENDP	; BaseCom::ReadWriteFile
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\basecom.cpp
;	COMDAT ?IsPagingFileActive@BaseCom@@SAHH@Z
_TEXT	SEGMENT
_checkNonWindowsPartitionsOnly$ = 8			; size = 4
?IsPagingFileActive@BaseCom@@SAHH@Z PROC		; BaseCom::IsPagingFileActive, COMDAT

; 180  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : }

  00003	5d		 pop	 ebp

; 181  : 	return ::IsPagingFileActive (checkNonWindowsPartitionsOnly);

  00004	e9 00 00 00 00	 jmp	 _IsPagingFileActive
?IsPagingFileActive@BaseCom@@SAHH@Z ENDP		; BaseCom::IsPagingFileActive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\basecom.cpp
;	COMDAT ?DeleteFileA@BaseCom@@SAKPA_W@Z
_TEXT	SEGMENT
$T1 = -136						; size = 132
__$ArrayPad$ = -4					; size = 4
_file$ = 8						; size = 4
?DeleteFileA@BaseCom@@SAKPA_W@Z PROC			; BaseCom::DeleteFileA, COMDAT

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]

; 162  : 	USES_CONVERSION;
; 163  : 
; 164  : 	if (!::DeleteFile (CW2A (file)))

  00016	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp+4]
  0001c	53		 push	 ebx
  0001d	6a 03		 push	 3
  0001f	89 8d 78 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00025	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ; ATL::CW2AEX<128>::Init
  00031	ff b5 78 ff ff
	ff		 push	 DWORD PTR $T1[ebp]
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4
  0003d	85 c0		 test	 eax, eax
  0003f	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp+4]
  00045	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  0004b	0f 94 c3	 sete	 bl
  0004e	3b c1		 cmp	 eax, ecx
  00050	74 09		 je	 SHORT $LN16@DeleteFile
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 _free
  00058	83 c4 04	 add	 esp, 4
$LN16@DeleteFile:
  0005b	84 db		 test	 bl, bl
  0005d	5b		 pop	 ebx
  0005e	74 14		 je	 SHORT $LN2@DeleteFile

; 165  : 		return GetLastError();

  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 166  : 
; 167  : 	return ERROR_SUCCESS;
; 168  : }

  00066	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00069	33 cd		 xor	 ecx, ebp
  0006b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
$LN2@DeleteFile:
  00074	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00077	33 c0		 xor	 eax, eax
  00079	33 cd		 xor	 ecx, ebp
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
?DeleteFileA@BaseCom@@SAKPA_W@Z ENDP			; BaseCom::DeleteFileA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\basecom.cpp
;	COMDAT ?CopyFileA@BaseCom@@SAKPA_W0@Z
_TEXT	SEGMENT
$T2 = -280						; size = 132
$T3 = -148						; size = 132
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_sourceFile$ = 8					; size = 4
_destinationFile$ = 12					; size = 4
?CopyFileA@BaseCom@@SAKPA_W0@Z PROC			; BaseCom::CopyFileA, COMDAT

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CopyFileA@BaseCom@@SAKPA_W0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _destinationFile$[ebp]

; 142  : 	USES_CONVERSION;
; 143  : 
; 144  : 	if (!::CopyFile (CW2A (sourceFile), CW2A (destinationFile), FALSE))

  00030	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp+4]
  00036	8b 75 08	 mov	 esi, DWORD PTR _sourceFile$[ebp]
  00039	6a 03		 push	 3
  0003b	89 8d e8 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00041	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ; ATL::CW2AEX<128>::Init
  0004d	6a 03		 push	 3
  0004f	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp+4]
  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005c	56		 push	 esi
  0005d	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00063	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00069	e8 00 00 00 00	 call	 ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ; ATL::CW2AEX<128>::Init
  0006e	6a 00		 push	 0
  00070	ff b5 e8 fe ff
	ff		 push	 DWORD PTR $T2[ebp]
  00076	ff b5 6c ff ff
	ff		 push	 DWORD PTR $T3[ebp]
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CopyFileA@12
  00082	85 c0		 test	 eax, eax
  00084	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+4]
  0008a	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00090	0f 94 c3	 sete	 bl
  00093	3b c1		 cmp	 eax, ecx
  00095	74 09		 je	 SHORT $LN23@CopyFileA
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _free
  0009d	83 c4 04	 add	 esp, 4
$LN23@CopyFileA:
  000a0	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  000a6	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp+4]
  000ac	3b c1		 cmp	 eax, ecx
  000ae	74 09		 je	 SHORT $LN28@CopyFileA
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 _free
  000b6	83 c4 04	 add	 esp, 4
$LN28@CopyFileA:
  000b9	84 db		 test	 bl, bl
  000bb	74 08		 je	 SHORT $LN2@CopyFileA

; 145  : 		return GetLastError();

  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000c3	eb 02		 jmp	 SHORT $LN1@CopyFileA
$LN2@CopyFileA:

; 146  : 
; 147  : 	return ERROR_SUCCESS;

  000c5	33 c0		 xor	 eax, eax
$LN1@CopyFileA:

; 148  : }

  000c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d1	59		 pop	 ecx
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx
  000d4	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d7	33 cd		 xor	 ecx, ebp
  000d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CopyFileA@BaseCom@@SAKPA_W0@Z$0:
  00000	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
__ehhandler$?CopyFileA@BaseCom@@SAKPA_W0@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a e8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-280]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CopyFileA@BaseCom@@SAKPA_W0@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CopyFileA@BaseCom@@SAKPA_W0@Z ENDP			; BaseCom::CopyFileA
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\basecom.cpp
;	COMDAT ?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z
_TEXT	SEGMENT
_e$2 = -1508						; size = 4
$T3 = -1504						; size = 4
_bootEnc$4 = -1500					; size = 1480
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_ioctl$ = 8						; size = 4
_input$ = 12						; size = 4
_output$ = 16						; size = 4
?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z PROC		; BaseCom::CallDriver, COMDAT

; 104  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 05 00
	00		 sub	 esp, 1496		; 000005d8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 75 0c	 mov	 esi, DWORD PTR _input$[ebp]

; 105  : 	try
; 106  : 	{
; 107  : 		BootEncryption bootEnc (NULL);

  00034	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$4[ebp]
  0003a	8b 7d 10	 mov	 edi, DWORD PTR _output$[ebp]
  0003d	6a 00		 push	 0
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00046	e8 00 00 00 00	 call	 ??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z ; GostCrypt::BootEncryption::BootEncryption

; 108  : 		bootEnc.CallDriver (ioctl,

  0004b	8b 07		 mov	 eax, DWORD PTR [edi]
  0004d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00051	85 c0		 test	 eax, eax
  00053	75 04		 jne	 SHORT $LN4@CallDriver
  00055	33 c9		 xor	 ecx, ecx
  00057	eb 03		 jmp	 SHORT $LN5@CallDriver
$LN4@CallDriver:
  00059	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
$LN5@CallDriver:
  0005c	85 f6		 test	 esi, esi
  0005e	75 04		 jne	 SHORT $LN6@CallDriver
  00060	33 d2		 xor	 edx, edx
  00062	eb 03		 jmp	 SHORT $LN7@CallDriver
$LN6@CallDriver:
  00064	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
$LN7@CallDriver:
  00067	51		 push	 ecx
  00068	50		 push	 eax
  00069	52		 push	 edx
  0006a	56		 push	 esi
  0006b	ff 75 08	 push	 DWORD PTR _ioctl$[ebp]
  0006e	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$4[ebp]
  00074	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 109  : 			(BYTE *) input, !(BYTE *) input ? 0 : ((DWORD *) ((BYTE *) input))[-1],
; 110  : 			(BYTE *) *output, !(BYTE *) *output ? 0 : ((DWORD *) ((BYTE *) *output))[-1]);
; 111  : 	}

  00079	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$4[ebp]
  0007f	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption

; 124  : 	}
; 125  : 
; 126  : 	return ERROR_SUCCESS;

  00084	33 c0		 xor	 eax, eax
  00086	eb 31		 jmp	 SHORT $LN1@CallDriver
__catch$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z$0:

; 112  : 	catch (SystemException &)
; 113  : 	{
; 114  : 		return GetLastError();

  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0008e	89 85 20 fa ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00094	b8 00 00 00 00	 mov	 eax, $LN14@CallDriver
  00099	c3		 ret	 0
$LN14@CallDriver:
  0009a	8b 85 20 fa ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  000a0	eb 17		 jmp	 SHORT $LN1@CallDriver
__catch$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z$1:

; 115  : 	}
; 116  : 	catch (Exception &e)
; 117  : 	{
; 118  : 		e.Show (NULL);

  000a2	8b 8d 1c fa ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  000a8	6a 00		 push	 0
  000aa	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ac	ff 10		 call	 DWORD PTR [eax]

; 119  : 		return ERROR_EXCEPTION_IN_SERVICE;

  000ae	b8 00 00 00 00	 mov	 eax, $LN18@CallDriver
  000b3	c3		 ret	 0
$LN18@CallDriver:

; 120  : 	}
; 121  : 	catch (...)
; 122  : 	{
; 123  : 		return ERROR_EXCEPTION_IN_SERVICE;

  000b4	b8 28 04 00 00	 mov	 eax, 1064		; 00000428H
$LN1@CallDriver:

; 127  : }

  000b9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000bc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c3	59		 pop	 ecx
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx
  000c7	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ca	33 cd		 xor	 ecx, ebp
  000cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
__catch$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z$2:

; 120  : 	}
; 121  : 	catch (...)
; 122  : 	{
; 123  : 		return ERROR_EXCEPTION_IN_SERVICE;

  000d5	b8 00 00 00 00	 mov	 eax, $LN18@CallDriver
  000da	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z$4:
  00000	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$4[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
__ehhandler$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 18 fa ff
	ff		 mov	 ecx, DWORD PTR [edx-1512]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CallDriver@BaseCom@@SAKKPA_WPAPA_W@Z ENDP		; BaseCom::CallDriver
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlwinverapi.h
;	COMDAT ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z
_TEXT	SEGMENT
_lpCriticalSection$ = 8					; size = 4
_dwSpinCount$ = 12					; size = 4
_Flags$ = 16						; size = 4
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z PROC ; ATL::_AtlInitializeCriticalSectionEx, COMDAT

; 727  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 728  : #if (NTDDI_VERSION >= NTDDI_VISTA) && !defined(_USING_V110_SDK71_) && !defined(_ATL_XP_TARGETING)
; 729  : 	// InitializeCriticalSectionEx is available in Vista or later, desktop or store apps
; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  00003	ff 75 10	 push	 DWORD PTR _Flags$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _dwSpinCount$[ebp]
  00009	ff 75 08	 push	 DWORD PTR _lpCriticalSection$[ebp]
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12

; 731  : #else
; 732  : 	UNREFERENCED_PARAMETER(Flags);
; 733  : 
; 734  : 	// ...otherwise fall back to using InitializeCriticalSectionAndSpinCount.
; 735  : 	return ::InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
; 736  : #endif
; 737  : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ENDP ; ATL::_AtlInitializeCriticalSectionEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT
?AtlThrowLastWin32@ATL@@YGXXZ PROC			; ATL::AtlThrowLastWin32, COMDAT

; 85   : 	DWORD dwError = ::GetLastError();

  00000	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 86   : 	AtlThrow( HRESULT_FROM_WIN32( dwError ) );

  00006	85 c0		 test	 eax, eax
  00008	7e 08		 jle	 SHORT $LN6@AtlThrowLa
  0000a	0f b7 c0	 movzx	 eax, ax
  0000d	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
$LN6@AtlThrowLa:
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN8@AtlThrowLa:
$LN7@AtlThrowLa:
  00018	cc		 int	 3
?AtlThrowLastWin32@ATL@@YGXXZ ENDP			; ATL::AtlThrowLastWin32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 66   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 67   : #ifdef _AFX
; 68   : 	if( hr == E_OUTOFMEMORY )
; 69   : 	{
; 70   : 		AfxThrowMemoryException();
; 71   : 	}
; 72   : 	else
; 73   : 	{
; 74   : 		AfxThrowOleException( hr );
; 75   : 	}
; 76   : #else
; 77   : 	throw CAtlException( hr );

  00003	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00006	89 45 08	 mov	 DWORD PTR $T1[ebp], eax
  00009	8d 45 08	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	68 00 00 00 00	 push	 OFFSET __TI1?AVCAtlException@ATL@@
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN6@AtlThrowIm:
$LN5@AtlThrowIm:
  00017	cc		 int	 3
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
??0CAtlException@ATL@@QAE@J@Z PROC			; ATL::CAtlException::CAtlException, COMDAT
; _this$ = ecx

; 44   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		m_hr( hr )

  00003	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 	}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0CAtlException@ATL@@QAE@J@Z ENDP			; ATL::CAtlException::CAtlException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT _swprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_swprintf_s PROC					; COMDAT

; 1536 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1537 :         int _Result;
; 1538 :         va_list _ArgList;
; 1539 :         __crt_va_start(_ArgList, _Format);
; 1540 :         _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vswprintf_s
  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1541 :         __crt_va_end(_ArgList);
; 1542 :         return _Result;
; 1543 :     }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_swprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT __vswprintf_s_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vswprintf_s_l PROC					; COMDAT

; 1262 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1263 :     int const _Result = __stdio_common_vswprintf_s(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vswprintf_s

; 1264 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1265 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1266 : 
; 1267 :     return _Result < 0 ? -1 : _Result;

  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1268 : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
__vswprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<wchar_t const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<wchar_t const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC			; ATL::_AtlGetConversionACP, COMDAT

; 106  : #ifdef _CONVERSION_DONT_USE_THREAD_LOCALE
; 107  : 	return CP_ACP;
; 108  : #else
; 109  : 	return CP_THREAD_ACP;

  00000	b8 03 00 00 00	 mov	 eax, 3

; 110  : #endif
; 111  : }

  00005	c3		 ret	 0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	7e 08		 jle	 SHORT $LN4@HRESULT_FR
  0000a	0f b7 c0	 movzx	 eax, ax
  0000d	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
$LN4@HRESULT_FR:
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
END
