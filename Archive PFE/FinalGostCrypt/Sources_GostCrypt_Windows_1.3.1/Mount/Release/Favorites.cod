; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Mount\Favorites.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?FavoriteVolumesMenu@GostCrypt@@3PAUHMENU__@@A	; GostCrypt::FavoriteVolumesMenu
_BSS	SEGMENT
?FavoriteVolumesMenu@GostCrypt@@3PAUHMENU__@@A DD 01H DUP (?) ; GostCrypt::FavoriteVolumesMenu
_BSS	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fwprintf
PUBLIC	??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ ; __vcrt_va_start_verify_argument_type<wchar_t const * const>
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?allocate@?$allocator@_W@std@@QAEPA_WI@Z	; std::allocator<wchar_t>::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
PUBLIC	?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
PUBLIC	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
PUBLIC	?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
PUBLIC	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
PUBLIC	??1Container@ForEach@GostCrypt@@UAE@XZ		; GostCrypt::ForEach::Container::~Container
PUBLIC	??_GContainer@ForEach@GostCrypt@@UAEPAXI@Z	; GostCrypt::ForEach::Container::`scalar deleting destructor'
PUBLIC	??0Exception@GostCrypt@@QAE@ABU01@@Z		; GostCrypt::Exception::Exception
PUBLIC	?Show@ErrorException@GostCrypt@@UBEXPAUHWND__@@@Z ; GostCrypt::ErrorException::Show
PUBLIC	??1ErrorException@GostCrypt@@QAE@XZ		; GostCrypt::ErrorException::~ErrorException
PUBLIC	??0ErrorException@GostCrypt@@QAE@ABU01@@Z	; GostCrypt::ErrorException::ErrorException
PUBLIC	??1FavoriteVolume@GostCrypt@@QAE@XZ		; GostCrypt::FavoriteVolume::~FavoriteVolume
PUBLIC	??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z	; GostCrypt::FavoriteVolume::FavoriteVolume
PUBLIC	??0FavoriteVolume@GostCrypt@@QAE@$$QAU01@@Z	; GostCrypt::FavoriteVolume::FavoriteVolume
PUBLIC	??4FavoriteVolume@GostCrypt@@QAEAAU01@ABU01@@Z	; GostCrypt::FavoriteVolume::operator=
PUBLIC	??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z ; GostCrypt::FavoriteVolume::operator=
PUBLIC	??1FavoriteVolumesDlgProcArguments@GostCrypt@@QAE@XZ ; GostCrypt::FavoriteVolumesDlgProcArguments::~FavoriteVolumesDlgProcArguments
PUBLIC	?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z ; GostCrypt::AddMountedVolumeToFavorites
PUBLIC	?GetFavoriteVolumeLabel@GostCrypt@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ; GostCrypt::GetFavoriteVolumeLabel
PUBLIC	?LoadFavoriteVolumes@GostCrypt@@YAXXZ		; GostCrypt::LoadFavoriteVolumes
PUBLIC	?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z ; GostCrypt::LoadFavoriteVolumes
PUBLIC	?OrganizeFavoriteVolumes@GostCrypt@@YAHPAUHWND__@@_NABUFavoriteVolume@1@@Z ; GostCrypt::OrganizeFavoriteVolumes
PUBLIC	?UpdateDeviceHostedFavoriteVolumes@GostCrypt@@YAXXZ ; GostCrypt::UpdateDeviceHostedFavoriteVolumes
PUBLIC	?allocate@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEPAUFavoriteVolume@GostCrypt@@I@Z ; std::allocator<GostCrypt::FavoriteVolume>::allocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@I@Z ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::deallocate
PUBLIC	??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >
PUBLIC	??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::operator=
PUBLIC	?push_back@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::push_back
PUBLIC	?erase@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::erase
PUBLIC	?clear@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::clear
PUBLIC	?_Buy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAE_NI@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Buy
PUBLIC	?_Destroy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXPAUFavoriteVolume@GostCrypt@@0@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Destroy
PUBLIC	?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Reallocate
PUBLIC	?_Reserve@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Reserve
PUBLIC	?_Tidy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Tidy
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >
PUBLIC	?_Buynode0@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Buynode0
PUBLIC	??1?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::~_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >
PUBLIC	??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >
PUBLIC	?_Unchecked_erase@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Unchecked_erase
PUBLIC	?clear@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::clear
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
PUBLIC	?IsNotEnd@?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::IsNotEnd
PUBLIC	?Next@?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::Next
PUBLIC	??1?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::~ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
PUBLIC	??_G?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`scalar deleting destructor'
PUBLIC	??$swap@UFavoriteVolume@GostCrypt@@X@std@@YAXAAUFavoriteVolume@GostCrypt@@0@Z ; std::swap<GostCrypt::FavoriteVolume,void>
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@ABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$GetContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
PUBLIC	?IsNotEnd@?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::IsNotEnd
PUBLIC	?Next@?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::Next
PUBLIC	??1?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::~ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
PUBLIC	??_G?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`scalar deleting destructor'
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W$$QAV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$_Ucopy@PAUFavoriteVolume@GostCrypt@@@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEPAUFavoriteVolume@GostCrypt@@PAU23@00@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Ucopy<GostCrypt::FavoriteVolume *>
PUBLIC	??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<std::_List_node<GostCrypt::FavoriteVolume,void *> *>
PUBLIC	??$_Destroy_range@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@PAUFavoriteVolume@GostCrypt@@@std@@YAXPAUFavoriteVolume@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<GostCrypt::FavoriteVolume>,GostCrypt::FavoriteVolume *>
PUBLIC	??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Buynode<GostCrypt::FavoriteVolume const &>
PUBLIC	??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>
PUBLIC	??$_Copy_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>
PUBLIC	??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > > >
PUBLIC	??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
PUBLIC	??$_Uninitialized_move_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
PUBLIC	??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::FavoriteVolume const *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	??_7Container@ForEach@GostCrypt@@6B@		; GostCrypt::ForEach::Container::`vftable'
PUBLIC	??_7Exception@GostCrypt@@6B@			; GostCrypt::Exception::`vftable'
PUBLIC	??_7ErrorException@GostCrypt@@6B@		; GostCrypt::ErrorException::`vftable'
PUBLIC	?FavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoriteVolumes
PUBLIC	?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesOnArrivalMountRequired
PUBLIC	?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesMountedOnArrivalStillConnected
PUBLIC	?SystemFavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::SystemFavoriteVolumes
PUBLIC	??_C@_03OPPAHFLA@X?3?2?$AA@			; `string'
PUBLIC	??_C@_04FFEPHCCK@?2?$DP?$DP?2?$AA@		; `string'
PUBLIC	??_C@_0M@CJEJOKNC@?2?2?$DP?2Volume?$HL?$AA@	; `string'
PUBLIC	??_C@_0M@OJHKIMBP@?2Partition0?$AA@		; `string'
PUBLIC	??_C@_0CE@GJAIEOAP@FAVORITE_ADD_PARTITION_TYPE_WARN@ ; `string'
PUBLIC	??_C@_0BP@BOKIMCAM@FAVORITE_ADD_DRIVE_DEV_WARNING?$AA@ ; `string'
PUBLIC	??_7?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`vftable'
PUBLIC	??_C@_0BL@JDDKFBO@SYSTEM_FAVORITES_DLG_TITLE?$AA@ ; `string'
PUBLIC	??_C@_0BF@HCOFEODH@IDD_FAVORITE_VOLUMES?$AA@	; `string'
PUBLIC	__TI2?AUErrorException@GostCrypt@@
PUBLIC	__CTA2?AUErrorException@GostCrypt@@
PUBLIC	??_R0?AUErrorException@GostCrypt@@@8		; GostCrypt::ErrorException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUErrorException@GostCrypt@@@8??0ErrorException@GostCrypt@@QAE@ABU01@@Z32
PUBLIC	??_R0?AUException@GostCrypt@@@8			; GostCrypt::Exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
PUBLIC	??_C@_0BK@ELJEKFFN@SYS_FAVORITES_REQUIRE_PBA?$AA@ ; `string'
PUBLIC	??_C@_0BP@EKHONFKP@MOUNT_SYSTEM_FAVORITES_ON_BOOT?$AA@ ; `string'
PUBLIC	??_C@_0CG@OLJJJKLA@DISABLE_NONADMIN_SYS_FAVORITES_A@ ; `string'
PUBLIC	??_C@_05JLAEHEHI@DRIVE?$AA@			; `string'
PUBLIC	??_C@_05EILEDKCG@LABEL?$AA@			; `string'
PUBLIC	??_C@_06EIAEKLLO@VOLUME?$AA@			; `string'
PUBLIC	??_C@_0BI@CHIEPLIO@SYS_FAVORITES_HELP_LINK?$AA@	; `string'
PUBLIC	??_C@_0CL@LJFCINAI@FAVORITE_ARRIVAL_MOUNT_BACKGROUN@ ; `string'
PUBLIC	??_C@_0CF@JLONOHPL@BOOT_PASSWORD_CACHE_KEYBOARD_WAR@ ; `string'
PUBLIC	??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@		; `string'
PUBLIC	??_C@_0BP@EBHLJFH@SYS_FAVORITES_KEYBOARD_WARNING?$AA@ ; `string'
PUBLIC	??_C@_0BO@EPEDCGFA@SYS_FAVORITES_ADMIN_ONLY_INFO?$AA@ ; `string'
PUBLIC	??_C@_0BI@BHGNKFED@SETTING_REQUIRES_REBOOT?$AA@	; `string'
PUBLIC	??_C@_0CB@FJMJOJID@SYS_FAVORITES_ADMIN_ONLY_WARNING@ ; `string'
PUBLIC	??_C@_0N@NFCNMOKI@sysfavorites?$AA@		; `string'
PUBLIC	??_C@_09OAMOHPIB@favorites?$AA@			; `string'
PUBLIC	??_C@_13DIBMAFH@?$AA?$CJ?$AA?$AA@		; `string'
PUBLIC	??_C@_0BK@OGKIEBOP@FAVORITE_DISCONNECTED_DEV?$AA@ ; `string'
PUBLIC	??_C@_13LLDNKHDC@?$AA?$CI?$AA?$AA@		; `string'
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@		; `string'
PUBLIC	??_C@_13KDLDGPGJ@?$AA?7?$AA?$AA@		; `string'
PUBLIC	??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@ ; `string'
PUBLIC	??_C@_0BF@EGBOIEGJ@Favorite?5Volumes?4xml?$AA@	; `string'
PUBLIC	??_R0?AUSystemException@GostCrypt@@@8		; GostCrypt::SystemException `RTTI Type Descriptor'
PUBLIC	??_C@_06EMCPHFGM@volume?$AA@			; `string'
PUBLIC	??_C@_0L@BHNCAFPG@mountpoint?$AA@		; `string'
PUBLIC	??_C@_05IDCCNNGI@label?$AA@			; `string'
PUBLIC	??_C@_08JOKHDEJH@readonly?$AA@			; `string'
PUBLIC	??_C@_09HPGMKNKO@removable?$AA@			; `string'
PUBLIC	??_C@_0O@KADIAEN@noHotKeyMount?$AA@		; `string'
PUBLIC	??_C@_0BD@FMMJHNKO@openExplorerWindow?$AA@	; `string'
PUBLIC	??_C@_0P@BNAHGHLI@mountOnArrival?$AA@		; `string'
PUBLIC	??_C@_0N@GAADCGJD@mountOnLogOn?$AA@		; `string'
PUBLIC	??_C@_02EKJJMPLG@?$HN?2?$AA@			; `string'
PUBLIC	??_7?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`vftable'
PUBLIC	??_C@_0M@OEIOICOO@w?0ccs?$DNUTF?98?$AA@		; `string'
PUBLIC	??_C@_1BM@LHCEIKFH@?$AA?6?$AA?7?$AA?$DM?$AAf?$AAa?$AAv?$AAo?$AAr?$AAi?$AAt?$AAe?$AAs?$AA?$DO?$AA?$AA@ ; `string'
PUBLIC	??_C@_02HDBGODGB@?2?2?$AA@			; `string'
PUBLIC	??_C@_07HBPFMAGN@Volume?$HL?$AA@		; `string'
PUBLIC	??_C@_0CB@FDMOEEOH@SYSTEM_FAVORITE_NETWORK_PATH_ERR@ ; `string'
PUBLIC	??_C@_13NEIAEHFG@?$AA?$CC?$AA?$AA@		; `string'
PUBLIC	??_C@_1DA@FKMFKHK@?$AA?6?$AA?7?$AA?7?$AA?$DM?$AAv?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAm?$AAo?$AAu?$AAn?$AAt?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?$DN?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@IMCPEDAD@?$AA?5?$AAl?$AAa?$AAb?$AAe?$AAl?$AA?$DN?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@ENOBLAGP@?$AA?5?$AAr?$AAe?$AAa?$AAd?$AAo?$AAn?$AAl?$AAy?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@KPDNDBGI@?$AA?5?$AAr?$AAe?$AAm?$AAo?$AAv?$AAa?$AAb?$AAl?$AAe?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@DCLBMOGE@?$AA?5?$AAs?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@PFJKIIJG@?$AA?5?$AAm?$AAo?$AAu?$AAn?$AAt?$AAO?$AAn?$AAA?$AAr?$AAr?$AAi?$AAv?$AAa?$AAl?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@JKNJFOGE@?$AA?5?$AAm?$AAo?$AAu?$AAn?$AAt?$AAO?$AAn?$AAL?$AAo?$AAg?$AAO?$AAn?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@JPOBGFJC@?$AA?5?$AAn?$AAo?$AAH?$AAo?$AAt?$AAK?$AAe?$AAy?$AAM?$AAo?$AAu?$AAn?$AAt?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@CGPNJOBH@?$AA?5?$AAo?$AAp?$AAe?$AAn?$AAE?$AAx?$AAp?$AAl?$AAo?$AAr?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@BKLKJEIJ@?$AA?$DM?$AA?1?$AAv?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$DO?$AA?$AA@ ; `string'
PUBLIC	??_C@_13MOEPKPHB@?$AA?$DO?$AA?$AA@		; `string'
PUBLIC	??_C@_17EEOGHOKP@?$AA?$CF?$AAw?$AAs?$AA?$AA@	; `string'
PUBLIC	??_C@_1BO@LKECBBKI@?$AA?6?$AA?7?$AA?$DM?$AA?1?$AAf?$AAa?$AAv?$AAo?$AAr?$AAi?$AAt?$AAe?$AAs?$AA?$DO?$AA?$AA@ ; `string'
PUBLIC	??_R0?AUUserAbort@GostCrypt@@@8			; GostCrypt::UserAbort `RTTI Type Descriptor'
PUBLIC	??_C@_0BL@JLAFANLF@SYS_FAVORITE_VOLUMES_SAVED?$AA@ ; `string'
PUBLIC	??_C@_0CC@GPNGJACE@FAVORITE_LABEL_PARTITION_TYPE_ER@ ; `string'
PUBLIC	??_C@_0BP@JDCKOJKF@FAVORITE_LABEL_DEVICE_PATH_ERR?$AA@ ; `string'
PUBLIC	??_C@_0CK@BMBODKOP@FAVORITE_ARRIVAL_MOUNT_PARTITION@ ; `string'
PUBLIC	??_C@_0CH@DKBAOJFF@FAVORITE_ARRIVAL_MOUNT_DEVICE_PA@ ; `string'
PUBLIC	??_C@_0CI@HPPIJBMN@FAVORITE_ARRIVAL_MOUNT_NETWORK_P@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4Container@ForEach@GostCrypt@@6B@		; GostCrypt::ForEach::Container::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUContainer@ForEach@GostCrypt@@@8		; GostCrypt::ForEach::Container `RTTI Type Descriptor'
PUBLIC	??_R3Container@ForEach@GostCrypt@@8		; GostCrypt::ForEach::Container::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Container@ForEach@GostCrypt@@8		; GostCrypt::ForEach::Container::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8	; GostCrypt::ForEach::Container::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Exception@GostCrypt@@6B@			; GostCrypt::Exception::`RTTI Complete Object Locator'
PUBLIC	??_R3Exception@GostCrypt@@8			; GostCrypt::Exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Exception@GostCrypt@@8			; GostCrypt::Exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Exception@GostCrypt@@8		; GostCrypt::Exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ErrorException@GostCrypt@@6B@		; GostCrypt::ErrorException::`RTTI Complete Object Locator'
PUBLIC	??_R3ErrorException@GostCrypt@@8		; GostCrypt::ErrorException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ErrorException@GostCrypt@@8		; GostCrypt::ErrorException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ErrorException@GostCrypt@@8	; GostCrypt::ErrorException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memchr:PROC
EXTRN	_memmove:PROC
EXTRN	__imp__DeleteFileA@4:PROC
EXTRN	__imp__FindVolumeClose@4:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__QueryDosDeviceA@12:PROC
EXTRN	__imp__FindFirstVolumeA@8:PROC
EXTRN	__imp__FindNextVolumeA@12:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__SendMessageW@16:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__SetWindowPos@28:PROC
EXTRN	__imp__DialogBoxParamW@20:PROC
EXTRN	__imp__EndDialog@8:PROC
EXTRN	__imp__GetDlgItem@8:PROC
EXTRN	__imp__SetDlgItemTextW@12:PROC
EXTRN	__imp__GetDlgItemTextW@16:PROC
EXTRN	__imp__CheckDlgButton@12:PROC
EXTRN	__imp__IsDlgButtonChecked@8:PROC
EXTRN	__imp__EnableWindow@8:PROC
EXTRN	__imp__AppendMenuA@16:PROC
EXTRN	__imp__AppendMenuW@16:PROC
EXTRN	__imp__DeleteMenu@12:PROC
EXTRN	__imp__InvalidateRect@12:PROC
EXTRN	__imp__SetWindowTextW@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	_free:PROC
EXTRN	_fputws:PROC
EXTRN	___stdio_common_vfwprintf:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_remove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_EContainer@ForEach@GostCrypt@@UAEPAXI@Z:PROC	; GostCrypt::ForEach::Container::`vector deleting destructor'
EXTRN	_handleWin32Error:PROC
EXTRN	_ReadDriverConfigurationFlags:PROC
EXTRN	_CheckFileStreamWriteErrors:PROC
EXTRN	_LocalizeDialog:PROC
EXTRN	_IsMountedVolume:PROC
EXTRN	_IsAdmin:PROC
EXTRN	_ResolveSymbolicLink:PROC
EXTRN	_IsNonInstallMode:PROC
EXTRN	_SetCheckBox:PROC
EXTRN	_ManageStartupSeq:PROC
EXTRN	_ListItemAdd:PROC
EXTRN	_ListSubItemSet:PROC
EXTRN	_ListSubItemSetW:PROC
EXTRN	_LoadFile:PROC
EXTRN	_GetConfigPath:PROC
EXTRN	_Info:PROC
EXTRN	_Warning:PROC
EXTRN	_WarningDirect:PROC
EXTRN	_Error:PROC
EXTRN	_ErrorDirect:PROC
EXTRN	_IsServerOS:PROC
EXTRN	_Applink:PROC
EXTRN	_IsVolumeDeviceHosted:PROC
EXTRN	_CompensateXDPI:PROC
EXTRN	_CompensateYDPI:PROC
EXTRN	_ToHyperlink:PROC
EXTRN	?SingleStringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:PROC ; SingleStringToWide
EXTRN	?Utf8StringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:PROC ; Utf8StringToWide
EXTRN	?WideToSingleString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z:PROC ; WideToSingleString
EXTRN	?GetServiceConfigPath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; GetServiceConfigPath
EXTRN	?VolumeGuidPathToDevicePath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z:PROC ; VolumeGuidPathToDevicePath
EXTRN	??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z:PROC ; GostCrypt::BootEncryption::BootEncryption
EXTRN	??1BootEncryption@GostCrypt@@QAE@XZ:PROC	; GostCrypt::BootEncryption::~BootEncryption
EXTRN	?CopyFileAdmin@BootEncryption@GostCrypt@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z:PROC ; GostCrypt::BootEncryption::CopyFileAdmin
EXTRN	?DeleteFileAdmin@BootEncryption@GostCrypt@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; GostCrypt::BootEncryption::DeleteFileAdmin
EXTRN	?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ:PROC ; GostCrypt::BootEncryption::GetStatus
EXTRN	?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z:PROC ; GostCrypt::BootEncryption::RegisterSystemFavoritesService
EXTRN	_GetString:PROC
EXTRN	_SaveSettings:PROC
EXTRN	_LoadDriveLetters:PROC
EXTRN	?SetDriverConfigurationFlag@@YAXIH@Z:PROC	; SetDriverConfigurationFlag
EXTRN	_XmlFindElement:PROC
EXTRN	_XmlGetAttributeText:PROC
EXTRN	_XmlGetNodeText:PROC
EXTRN	_XmlWriteHeaderW:PROC
EXTRN	_XmlWriteFooterW:PROC
EXTRN	_XmlQuoteText:PROC
EXTRN	??_E?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z:PROC ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`vector deleting destructor'
EXTRN	??_E?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z:PROC ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	_MainDlg:DWORD
EXTRN	_bMountFavoritesOnLogon:DWORD
EXTRN	_hDriver:DWORD
EXTRN	_hInst:DWORD
EXTRN	_bEnableBkgTask:DWORD
EXTRN	_bCloseBkgTaskWhenNoVolumes:DWORD
EXTRN	_bExplore:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?FavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A DB 0cH DUP (?) ; GostCrypt::FavoriteVolumes
?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A DQ 01H DUP (?) ; GostCrypt::FavoritesOnArrivalMountRequired
?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A DQ 01H DUP (?) ; GostCrypt::FavoritesMountedOnArrivalStillConnected
?SystemFavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A DB 0cH DUP (?) ; GostCrypt::SystemFavoriteVolumes
_BSS	ENDS
;	COMDAT ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA
_BSS	SEGMENT
?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA DB 01H DUP (?) ; `GostCrypt::FavoriteVolumesDlgProc'::`2'::SystemFavoritesMode
_BSS	ENDS
;	COMDAT ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
_BSS	SEGMENT
?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A DB 0cH DUP (?) ; `GostCrypt::FavoriteVolumesDlgProc'::`2'::Favorites
_BSS	ENDS
;	COMDAT ?$TSS0@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',GostCrypt::voriteVolumesDlgProc,GHPAUHWND__,unsigned int,unsigned int,long>
_BSS	ENDS
;	COMDAT ?SelectedItem@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA
_BSS	SEGMENT
?SelectedItem@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA DD 01H DUP (?) ; `GostCrypt::FavoriteVolumesDlgProc'::`2'::SelectedItem
_BSS	ENDS
;	COMDAT ?FavoriteListControl@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4PAU3@A
_BSS	SEGMENT
?FavoriteListControl@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4PAU3@A DD 01H DUP (?) ; `GostCrypt::FavoriteVolumesDlgProc'::`2'::FavoriteListControl
_BSS	ENDS
;	COMDAT ?reentry@?FJ@??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA
_BSS	SEGMENT
?reentry@?FJ@??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA DB 01H DUP (?) ; `GostCrypt::FavoriteVolumesDlgProc'::`89'::reentry
_BSS	ENDS
CRT$XCU	SEGMENT
?FavoriteVolumes$initializer$@GostCrypt@@3P6AXXZA DD FLAT:??__EFavoriteVolumes@GostCrypt@@YAXXZ ; GostCrypt::FavoriteVolumes$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 DD FLAT:??_R0?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R2?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R3?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 DD 00H ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8
data$r	SEGMENT
??_R0?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt'
	DB	'@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEac'
	DB	'h@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ DD 00H ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8
	DD	FLAT:??_R3?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 DD FLAT:??_R0?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R2?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R3?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 DD 00H ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8
data$r	SEGMENT
??_R0?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCry'
	DB	'pt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForE'
	DB	'ach@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ DD 00H ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8
	DD	FLAT:??_R3?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ErrorException@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ErrorException@GostCrypt@@8 DD FLAT:??_R0?AUErrorException@GostCrypt@@@8 ; GostCrypt::ErrorException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ErrorException@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2ErrorException@GostCrypt@@8
rdata$r	SEGMENT
??_R2ErrorException@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@ErrorException@GostCrypt@@8 ; GostCrypt::ErrorException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3ErrorException@GostCrypt@@8
rdata$r	SEGMENT
??_R3ErrorException@GostCrypt@@8 DD 00H			; GostCrypt::ErrorException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ErrorException@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R4ErrorException@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4ErrorException@GostCrypt@@6B@ DD 00H		; GostCrypt::ErrorException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUErrorException@GostCrypt@@@8
	DD	FLAT:??_R3ErrorException@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Exception@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Exception@GostCrypt@@8 DD FLAT:??_R0?AUException@GostCrypt@@@8 ; GostCrypt::Exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2Exception@GostCrypt@@8
rdata$r	SEGMENT
??_R2Exception@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@Exception@GostCrypt@@8 ; GostCrypt::Exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Exception@GostCrypt@@8
rdata$r	SEGMENT
??_R3Exception@GostCrypt@@8 DD 00H			; GostCrypt::Exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R4Exception@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4Exception@GostCrypt@@6B@ DD 00H			; GostCrypt::Exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	FLAT:??_R3Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8 DD FLAT:??_R0?AUContainer@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::Container::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2Container@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R2Container@ForEach@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::Container::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Container@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R3Container@ForEach@GostCrypt@@8 DD 00H		; GostCrypt::ForEach::Container::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUContainer@ForEach@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUContainer@ForEach@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::ForEach::Container `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUContainer@ForEach@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_R4Container@ForEach@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4Container@ForEach@GostCrypt@@6B@ DD 00H		; GostCrypt::ForEach::Container::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUContainer@ForEach@GostCrypt@@@8
	DD	FLAT:??_R3Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HPPIJBMN@FAVORITE_ARRIVAL_MOUNT_NETWORK_P@
CONST	SEGMENT
??_C@_0CI@HPPIJBMN@FAVORITE_ARRIVAL_MOUNT_NETWORK_P@ DB 'FAVORITE_ARRIVAL'
	DB	'_MOUNT_NETWORK_PATH_ERR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DKBAOJFF@FAVORITE_ARRIVAL_MOUNT_DEVICE_PA@
CONST	SEGMENT
??_C@_0CH@DKBAOJFF@FAVORITE_ARRIVAL_MOUNT_DEVICE_PA@ DB 'FAVORITE_ARRIVAL'
	DB	'_MOUNT_DEVICE_PATH_ERR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BMBODKOP@FAVORITE_ARRIVAL_MOUNT_PARTITION@
CONST	SEGMENT
??_C@_0CK@BMBODKOP@FAVORITE_ARRIVAL_MOUNT_PARTITION@ DB 'FAVORITE_ARRIVAL'
	DB	'_MOUNT_PARTITION_TYPE_ERR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JDCKOJKF@FAVORITE_LABEL_DEVICE_PATH_ERR?$AA@
CONST	SEGMENT
??_C@_0BP@JDCKOJKF@FAVORITE_LABEL_DEVICE_PATH_ERR?$AA@ DB 'FAVORITE_LABEL'
	DB	'_DEVICE_PATH_ERR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GPNGJACE@FAVORITE_LABEL_PARTITION_TYPE_ER@
CONST	SEGMENT
??_C@_0CC@GPNGJACE@FAVORITE_LABEL_PARTITION_TYPE_ER@ DB 'FAVORITE_LABEL_P'
	DB	'ARTITION_TYPE_ERR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JLAFANLF@SYS_FAVORITE_VOLUMES_SAVED?$AA@
CONST	SEGMENT
??_C@_0BL@JLAFANLF@SYS_FAVORITE_VOLUMES_SAVED?$AA@ DB 'SYS_FAVORITE_VOLUM'
	DB	'ES_SAVED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_R0?AUUserAbort@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUUserAbort@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::UserAbort `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUUserAbort@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_C@_1BO@LKECBBKI@?$AA?6?$AA?7?$AA?$DM?$AA?1?$AAf?$AAa?$AAv?$AAo?$AAr?$AAi?$AAt?$AAe?$AAs?$AA?$DO?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@LKECBBKI@?$AA?6?$AA?7?$AA?$DM?$AA?1?$AAf?$AAa?$AAv?$AAo?$AAr?$AAi?$AAt?$AAe?$AAs?$AA?$DO?$AA?$AA@ DB 0aH
	DB	00H, 09H, 00H, '<', 00H, '/', 00H, 'f', 00H, 'a', 00H, 'v', 00H
	DB	'o', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'e', 00H, 's', 00H, '>'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_17EEOGHOKP@?$AA?$CF?$AAw?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_17EEOGHOKP@?$AA?$CF?$AAw?$AAs?$AA?$AA@ DB '%', 00H, 'w', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_13MOEPKPHB@?$AA?$DO?$AA?$AA@
CONST	SEGMENT
??_C@_13MOEPKPHB@?$AA?$DO?$AA?$AA@ DB '>', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@BKLKJEIJ@?$AA?$DM?$AA?1?$AAv?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$DO?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@BKLKJEIJ@?$AA?$DM?$AA?1?$AAv?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$DO?$AA?$AA@ DB '<'
	DB	00H, '/', 00H, 'v', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H
	DB	'e', 00H, '>', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@CGPNJOBH@?$AA?5?$AAo?$AAp?$AAe?$AAn?$AAE?$AAx?$AAp?$AAl?$AAo?$AAr?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@CGPNJOBH@?$AA?5?$AAo?$AAp?$AAe?$AAn?$AAE?$AAx?$AAp?$AAl?$AAo?$AAr?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@ DB ' '
	DB	00H, 'o', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'E', 00H, 'x', 00H
	DB	'p', 00H, 'l', 00H, 'o', 00H, 'r', 00H, 'e', 00H, 'r', 00H, 'W'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '=', 00H
	DB	'"', 00H, '1', 00H, '"', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JPOBGFJC@?$AA?5?$AAn?$AAo?$AAH?$AAo?$AAt?$AAK?$AAe?$AAy?$AAM?$AAo?$AAu?$AAn?$AAt?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@JPOBGFJC@?$AA?5?$AAn?$AAo?$AAH?$AAo?$AAt?$AAK?$AAe?$AAy?$AAM?$AAo?$AAu?$AAn?$AAt?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@ DB ' '
	DB	00H, 'n', 00H, 'o', 00H, 'H', 00H, 'o', 00H, 't', 00H, 'K', 00H
	DB	'e', 00H, 'y', 00H, 'M', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't'
	DB	00H, '=', 00H, '"', 00H, '1', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@JKNJFOGE@?$AA?5?$AAm?$AAo?$AAu?$AAn?$AAt?$AAO?$AAn?$AAL?$AAo?$AAg?$AAO?$AAn?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@JKNJFOGE@?$AA?5?$AAm?$AAo?$AAu?$AAn?$AAt?$AAO?$AAn?$AAL?$AAo?$AAg?$AAO?$AAn?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@ DB ' '
	DB	00H, 'm', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 'O', 00H
	DB	'n', 00H, 'L', 00H, 'o', 00H, 'g', 00H, 'O', 00H, 'n', 00H, '='
	DB	00H, '"', 00H, '1', 00H, '"', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@PFJKIIJG@?$AA?5?$AAm?$AAo?$AAu?$AAn?$AAt?$AAO?$AAn?$AAA?$AAr?$AAr?$AAi?$AAv?$AAa?$AAl?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@PFJKIIJG@?$AA?5?$AAm?$AAo?$AAu?$AAn?$AAt?$AAO?$AAn?$AAA?$AAr?$AAr?$AAi?$AAv?$AAa?$AAl?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@ DB ' '
	DB	00H, 'm', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 'O', 00H
	DB	'n', 00H, 'A', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'a'
	DB	00H, 'l', 00H, '=', 00H, '"', 00H, '1', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@DCLBMOGE@?$AA?5?$AAs?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@DCLBMOGE@?$AA?5?$AAs?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@ DB ' '
	DB	00H, 's', 00H, 'y', 00H, 's', 00H, 't', 00H, 'e', 00H, 'm', 00H
	DB	'=', 00H, '"', 00H, '1', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@KPDNDBGI@?$AA?5?$AAr?$AAe?$AAm?$AAo?$AAv?$AAa?$AAb?$AAl?$AAe?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@KPDNDBGI@?$AA?5?$AAr?$AAe?$AAm?$AAo?$AAv?$AAa?$AAb?$AAl?$AAe?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@ DB ' '
	DB	00H, 'r', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H, 'a', 00H
	DB	'b', 00H, 'l', 00H, 'e', 00H, '=', 00H, '"', 00H, '1', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@ENOBLAGP@?$AA?5?$AAr?$AAe?$AAa?$AAd?$AAo?$AAn?$AAl?$AAy?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@ENOBLAGP@?$AA?5?$AAr?$AAe?$AAa?$AAd?$AAo?$AAn?$AAl?$AAy?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@ DB ' '
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'o', 00H, 'n', 00H
	DB	'l', 00H, 'y', 00H, '=', 00H, '"', 00H, '1', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@IMCPEDAD@?$AA?5?$AAl?$AAa?$AAb?$AAe?$AAl?$AA?$DN?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@IMCPEDAD@?$AA?5?$AAl?$AAa?$AAb?$AAe?$AAl?$AA?$DN?$AA?$CC?$AA?$AA@ DB ' '
	DB	00H, 'l', 00H, 'a', 00H, 'b', 00H, 'e', 00H, 'l', 00H, '=', 00H
	DB	'"', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@FKMFKHK@?$AA?6?$AA?7?$AA?7?$AA?$DM?$AAv?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAm?$AAo?$AAu?$AAn?$AAt?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?$DN?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@FKMFKHK@?$AA?6?$AA?7?$AA?7?$AA?$DM?$AAv?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAm?$AAo?$AAu?$AAn?$AAt?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?$DN?$AA?$CC?$AA?$AA@ DB 0aH
	DB	00H, 09H, 00H, 09H, 00H, '<', 00H, 'v', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 'm', 00H, 'o', 00H, 'u'
	DB	00H, 'n', 00H, 't', 00H, 'p', 00H, 'o', 00H, 'i', 00H, 'n', 00H
	DB	't', 00H, '=', 00H, '"', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13NEIAEHFG@?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_13NEIAEHFG@?$AA?$CC?$AA?$AA@ DB '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FDMOEEOH@SYSTEM_FAVORITE_NETWORK_PATH_ERR@
CONST	SEGMENT
??_C@_0CB@FDMOEEOH@SYSTEM_FAVORITE_NETWORK_PATH_ERR@ DB 'SYSTEM_FAVORITE_'
	DB	'NETWORK_PATH_ERR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07HBPFMAGN@Volume?$HL?$AA@
CONST	SEGMENT
??_C@_07HBPFMAGN@Volume?$HL?$AA@ DB 'Volume{', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02HDBGODGB@?2?2?$AA@
CONST	SEGMENT
??_C@_02HDBGODGB@?2?2?$AA@ DB '\\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@LHCEIKFH@?$AA?6?$AA?7?$AA?$DM?$AAf?$AAa?$AAv?$AAo?$AAr?$AAi?$AAt?$AAe?$AAs?$AA?$DO?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@LHCEIKFH@?$AA?6?$AA?7?$AA?$DM?$AAf?$AAa?$AAv?$AAo?$AAr?$AAi?$AAt?$AAe?$AAs?$AA?$DO?$AA?$AA@ DB 0aH
	DB	00H, 09H, 00H, '<', 00H, 'f', 00H, 'a', 00H, 'v', 00H, 'o', 00H
	DB	'r', 00H, 'i', 00H, 't', 00H, 'e', 00H, 's', 00H, '>', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OEIOICOO@w?0ccs?$DNUTF?98?$AA@
CONST	SEGMENT
??_C@_0M@OEIOICOO@w?0ccs?$DNUTF?98?$AA@ DB 'w,ccs=UTF-8', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@
CONST	SEGMENT
??_7?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ DD FLAT:??_R4?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`vftable'
	DD	FLAT:??_E?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z
	DD	FLAT:?IsNotEnd@?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ
	DD	FLAT:?Next@?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ
CONST	ENDS
;	COMDAT ??_C@_02EKJJMPLG@?$HN?2?$AA@
CONST	SEGMENT
??_C@_02EKJJMPLG@?$HN?2?$AA@ DB '}\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GAADCGJD@mountOnLogOn?$AA@
CONST	SEGMENT
??_C@_0N@GAADCGJD@mountOnLogOn?$AA@ DB 'mountOnLogOn', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BNAHGHLI@mountOnArrival?$AA@
CONST	SEGMENT
??_C@_0P@BNAHGHLI@mountOnArrival?$AA@ DB 'mountOnArrival', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FMMJHNKO@openExplorerWindow?$AA@
CONST	SEGMENT
??_C@_0BD@FMMJHNKO@openExplorerWindow?$AA@ DB 'openExplorerWindow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KADIAEN@noHotKeyMount?$AA@
CONST	SEGMENT
??_C@_0O@KADIAEN@noHotKeyMount?$AA@ DB 'noHotKeyMount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HPGMKNKO@removable?$AA@
CONST	SEGMENT
??_C@_09HPGMKNKO@removable?$AA@ DB 'removable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JOKHDEJH@readonly?$AA@
CONST	SEGMENT
??_C@_08JOKHDEJH@readonly?$AA@ DB 'readonly', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05IDCCNNGI@label?$AA@
CONST	SEGMENT
??_C@_05IDCCNNGI@label?$AA@ DB 'label', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BHNCAFPG@mountpoint?$AA@
CONST	SEGMENT
??_C@_0L@BHNCAFPG@mountpoint?$AA@ DB 'mountpoint', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EMCPHFGM@volume?$AA@
CONST	SEGMENT
??_C@_06EMCPHFGM@volume?$AA@ DB 'volume', 00H		; `string'
CONST	ENDS
;	COMDAT ??_R0?AUSystemException@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUSystemException@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::SystemException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUSystemException@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@EGBOIEGJ@Favorite?5Volumes?4xml?$AA@
CONST	SEGMENT
??_C@_0BF@EGBOIEGJ@Favorite?5Volumes?4xml?$AA@ DB 'Favorite Volumes.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@
CONST	SEGMENT
??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@ DB 'GostCrypt Sys'
	DB	'tem Favorite Volumes.xml', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13KDLDGPGJ@?$AA?7?$AA?$AA@
CONST	SEGMENT
??_C@_13KDLDGPGJ@?$AA?7?$AA?$AA@ DB 09H, 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@ DB ' ', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_13LLDNKHDC@?$AA?$CI?$AA?$AA@
CONST	SEGMENT
??_C@_13LLDNKHDC@?$AA?$CI?$AA?$AA@ DB '(', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OGKIEBOP@FAVORITE_DISCONNECTED_DEV?$AA@
CONST	SEGMENT
??_C@_0BK@OGKIEBOP@FAVORITE_DISCONNECTED_DEV?$AA@ DB 'FAVORITE_DISCONNECT'
	DB	'ED_DEV', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_13DIBMAFH@?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_13DIBMAFH@?$AA?$CJ?$AA?$AA@ DB ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OAMOHPIB@favorites?$AA@
CONST	SEGMENT
??_C@_09OAMOHPIB@favorites?$AA@ DB 'favorites', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NFCNMOKI@sysfavorites?$AA@
CONST	SEGMENT
??_C@_0N@NFCNMOKI@sysfavorites?$AA@ DB 'sysfavorites', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FJMJOJID@SYS_FAVORITES_ADMIN_ONLY_WARNING@
CONST	SEGMENT
??_C@_0CB@FJMJOJID@SYS_FAVORITES_ADMIN_ONLY_WARNING@ DB 'SYS_FAVORITES_AD'
	DB	'MIN_ONLY_WARNING', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BHGNKFED@SETTING_REQUIRES_REBOOT?$AA@
CONST	SEGMENT
??_C@_0BI@BHGNKFED@SETTING_REQUIRES_REBOOT?$AA@ DB 'SETTING_REQUIRES_REBO'
	DB	'OT', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EPEDCGFA@SYS_FAVORITES_ADMIN_ONLY_INFO?$AA@
CONST	SEGMENT
??_C@_0BO@EPEDCGFA@SYS_FAVORITES_ADMIN_ONLY_INFO?$AA@ DB 'SYS_FAVORITES_A'
	DB	'DMIN_ONLY_INFO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EBHLJFH@SYS_FAVORITES_KEYBOARD_WARNING?$AA@
CONST	SEGMENT
??_C@_0BP@EBHLJFH@SYS_FAVORITES_KEYBOARD_WARNING?$AA@ DB 'SYS_FAVORITES_K'
	DB	'EYBOARD_WARNING', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@ DB 0aH, 00H, 0aH, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JLONOHPL@BOOT_PASSWORD_CACHE_KEYBOARD_WAR@
CONST	SEGMENT
??_C@_0CF@JLONOHPL@BOOT_PASSWORD_CACHE_KEYBOARD_WAR@ DB 'BOOT_PASSWORD_CA'
	DB	'CHE_KEYBOARD_WARNING', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LJFCINAI@FAVORITE_ARRIVAL_MOUNT_BACKGROUN@
CONST	SEGMENT
??_C@_0CL@LJFCINAI@FAVORITE_ARRIVAL_MOUNT_BACKGROUN@ DB 'FAVORITE_ARRIVAL'
	DB	'_MOUNT_BACKGROUND_TASK_ERR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CHIEPLIO@SYS_FAVORITES_HELP_LINK?$AA@
CONST	SEGMENT
??_C@_0BI@CHIEPLIO@SYS_FAVORITES_HELP_LINK?$AA@ DB 'SYS_FAVORITES_HELP_LI'
	DB	'NK', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06EIAEKLLO@VOLUME?$AA@
CONST	SEGMENT
??_C@_06EIAEKLLO@VOLUME?$AA@ DB 'VOLUME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EILEDKCG@LABEL?$AA@
CONST	SEGMENT
??_C@_05EILEDKCG@LABEL?$AA@ DB 'LABEL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JLAEHEHI@DRIVE?$AA@
CONST	SEGMENT
??_C@_05JLAEHEHI@DRIVE?$AA@ DB 'DRIVE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OLJJJKLA@DISABLE_NONADMIN_SYS_FAVORITES_A@
CONST	SEGMENT
??_C@_0CG@OLJJJKLA@DISABLE_NONADMIN_SYS_FAVORITES_A@ DB 'DISABLE_NONADMIN'
	DB	'_SYS_FAVORITES_ACCESS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EKHONFKP@MOUNT_SYSTEM_FAVORITES_ON_BOOT?$AA@
CONST	SEGMENT
??_C@_0BP@EKHONFKP@MOUNT_SYSTEM_FAVORITES_ON_BOOT?$AA@ DB 'MOUNT_SYSTEM_F'
	DB	'AVORITES_ON_BOOT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ELJEKFFN@SYS_FAVORITES_REQUIRE_PBA?$AA@
CONST	SEGMENT
??_C@_0BK@ELJEKFFN@SYS_FAVORITES_REQUIRE_PBA?$AA@ DB 'SYS_FAVORITES_REQUI'
	DB	'RE_PBA', 00H				; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
xdata$x	SEGMENT
__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4 DD 00H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	FLAT:??0Exception@GostCrypt@@QAE@ABU01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUException@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUException@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::Exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUException@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AUErrorException@GostCrypt@@@8??0ErrorException@GostCrypt@@QAE@ABU01@@Z32
xdata$x	SEGMENT
__CT??_R0?AUErrorException@GostCrypt@@@8??0ErrorException@GostCrypt@@QAE@ABU01@@Z32 DD 00H
	DD	FLAT:??_R0?AUErrorException@GostCrypt@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	020H
	DD	FLAT:??0ErrorException@GostCrypt@@QAE@ABU01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUErrorException@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUErrorException@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::ErrorException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUErrorException@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AUErrorException@GostCrypt@@
xdata$x	SEGMENT
__CTA2?AUErrorException@GostCrypt@@ DD 02H
	DD	FLAT:__CT??_R0?AUErrorException@GostCrypt@@@8??0ErrorException@GostCrypt@@QAE@ABU01@@Z32
	DD	FLAT:__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
xdata$x	ENDS
;	COMDAT __TI2?AUErrorException@GostCrypt@@
xdata$x	SEGMENT
__TI2?AUErrorException@GostCrypt@@ DD 00H
	DD	FLAT:??1ErrorException@GostCrypt@@QAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AUErrorException@GostCrypt@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@HCOFEODH@IDD_FAVORITE_VOLUMES?$AA@
CONST	SEGMENT
??_C@_0BF@HCOFEODH@IDD_FAVORITE_VOLUMES?$AA@ DB 'IDD_FAVORITE_VOLUMES', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JDDKFBO@SYSTEM_FAVORITES_DLG_TITLE?$AA@
CONST	SEGMENT
??_C@_0BL@JDDKFBO@SYSTEM_FAVORITES_DLG_TITLE?$AA@ DB 'SYSTEM_FAVORITES_DL'
	DB	'G_TITLE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_7?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@
CONST	SEGMENT
??_7?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ DD FLAT:??_R4?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`vftable'
	DD	FLAT:??_E?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z
	DD	FLAT:?IsNotEnd@?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ
	DD	FLAT:?Next@?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ
CONST	ENDS
;	COMDAT ??_C@_0BP@BOKIMCAM@FAVORITE_ADD_DRIVE_DEV_WARNING?$AA@
CONST	SEGMENT
??_C@_0BP@BOKIMCAM@FAVORITE_ADD_DRIVE_DEV_WARNING?$AA@ DB 'FAVORITE_ADD_D'
	DB	'RIVE_DEV_WARNING', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GJAIEOAP@FAVORITE_ADD_PARTITION_TYPE_WARN@
CONST	SEGMENT
??_C@_0CE@GJAIEOAP@FAVORITE_ADD_PARTITION_TYPE_WARN@ DB 'FAVORITE_ADD_PAR'
	DB	'TITION_TYPE_WARNING', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OJHKIMBP@?2Partition0?$AA@
CONST	SEGMENT
??_C@_0M@OJHKIMBP@?2Partition0?$AA@ DB '\Partition0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CJEJOKNC@?2?2?$DP?2Volume?$HL?$AA@
CONST	SEGMENT
??_C@_0M@CJEJOKNC@?2?2?$DP?2Volume?$HL?$AA@ DB '\\?\Volume{', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FFEPHCCK@?2?$DP?$DP?2?$AA@
CONST	SEGMENT
??_C@_04FFEPHCCK@?2?$DP?$DP?2?$AA@ DB '\??\', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03OPPAHFLA@X?3?2?$AA@
CONST	SEGMENT
??_C@_03OPPAHFLA@X?3?2?$AA@ DB 'X:\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7ErrorException@GostCrypt@@6B@
CONST	SEGMENT
??_7ErrorException@GostCrypt@@6B@ DD FLAT:??_R4ErrorException@GostCrypt@@6B@ ; GostCrypt::ErrorException::`vftable'
	DD	FLAT:?Show@ErrorException@GostCrypt@@UBEXPAUHWND__@@@Z
CONST	ENDS
;	COMDAT ??_7Exception@GostCrypt@@6B@
CONST	SEGMENT
??_7Exception@GostCrypt@@6B@ DD FLAT:??_R4Exception@GostCrypt@@6B@ ; GostCrypt::Exception::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7Container@ForEach@GostCrypt@@6B@
CONST	SEGMENT
??_7Container@ForEach@GostCrypt@@6B@ DD FLAT:??_R4Container@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::Container::`vftable'
	DD	FLAT:??_EContainer@ForEach@GostCrypt@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0
__tryblocktable$??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$6
__unwindtable$??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$4
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z$0
__ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0
__tryblocktable$??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$6
__unwindtable$??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$4
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z$1
__ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$15 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$0
__unwindtable$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$15
__ehfuncinfo$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z$0
__ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z$0
__ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z$2
__ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z$1
__ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@AAU34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@AAU34@@Z$1
__ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@AAU34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@AAU34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z$135
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z$268
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z$401
__ehfuncinfo$??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z$12 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z$0
__tryblocktable$??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z$12
__unwindtable$??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z$8
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z$2
__ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z$2
__ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z$0
__ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z$0
__ehfuncinfo$??0?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$GetContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z$1
__ehfuncinfo$??$GetContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$GetContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z$0
__ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z$0
__ehfuncinfo$??0?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z$1
__ehfuncinfo$??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$46 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$46
__unwindtable$??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z$54 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z$54
__ehfuncinfo$?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?push_back@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z$33
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z$57
__ehfuncinfo$?push_back@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?push_back@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z$141 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z$0
__unwindtable$??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z$141
__ehfuncinfo$??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$67 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$67
__ehfuncinfo$??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?UpdateDeviceHostedFavoriteVolumes@GostCrypt@@YAXXZ$2 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffffecH
	DD	FLAT:__catch$?UpdateDeviceHostedFavoriteVolumes@GostCrypt@@YAXXZ$0
__unwindtable$?UpdateDeviceHostedFavoriteVolumes@GostCrypt@@YAXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?UpdateDeviceHostedFavoriteVolumes@GostCrypt@@YAXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?UpdateDeviceHostedFavoriteVolumes@GostCrypt@@YAXXZ$2
__ehfuncinfo$?UpdateDeviceHostedFavoriteVolumes@GostCrypt@@YAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?UpdateDeviceHostedFavoriteVolumes@GostCrypt@@YAXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?UpdateDeviceHostedFavoriteVolumes@GostCrypt@@YAXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$412 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$5
__catchsym$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$411 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffff148H
	DD	FLAT:__catch$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$3
__catchsym$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$410 DD 08H
	DD	FLAT:??_R0?AUUserAbort@GostCrypt@@@8
	DD	00H
	DD	FLAT:__catch$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$1
__ehfuncinfo$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z DD 019930522H
	DD	01bH
	DD	FLAT:__unwindtable$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z
	DD	03H
	DD	FLAT:__tryblocktable$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z DD 0eH
	DD	010H
	DD	011H
	DD	02H
	DD	FLAT:__catchsym$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$410
	DD	012H
	DD	015H
	DD	016H
	DD	01H
	DD	FLAT:__catchsym$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$411
	DD	017H
	DD	019H
	DD	01aH
	DD	01H
	DD	FLAT:__catchsym$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$412
__unwindtable$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$8
	DD	01H
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$9
	DD	02H
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$10
	DD	01H
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$10
	DD	05H
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$11
	DD	06H
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$12
	DD	05H
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$13
	DD	08H
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$14
	DD	09H
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$15
	DD	0aH
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$17
	DD	0cH
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$18
	DD	0dH
	DD	00H
	DD	0eH
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$19
	DD	0fH
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$20
	DD	0dH
	DD	00H
	DD	0dH
	DD	00H
	DD	012H
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$21
	DD	013H
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$22
	DD	014H
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$23
	DD	0dH
	DD	00H
	DD	0cH
	DD	00H
	DD	017H
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$24
	DD	018H
	DD	FLAT:__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$25
	DD	0cH
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OrganizeFavoriteVolumes@GostCrypt@@YAHPAUHWND__@@_NABUFavoriteVolume@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OrganizeFavoriteVolumes@GostCrypt@@YAHPAUHWND__@@_NABUFavoriteVolume@1@@Z$0
__ehfuncinfo$?OrganizeFavoriteVolumes@GostCrypt@@YAHPAUHWND__@@_NABUFavoriteVolume@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OrganizeFavoriteVolumes@GostCrypt@@YAHPAUHWND__@@_NABUFavoriteVolume@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ$2
__ehfuncinfo$?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$697 DD 08H
	DD	FLAT:??_R0?AUSystemException@GostCrypt@@@8
	DD	0fffff700H
	DD	FLAT:__catch$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$0
__tryblocktable$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z DD 03H
	DD	07H
	DD	08H
	DD	01H
	DD	FLAT:__catchsym$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$697
__ehfuncinfo$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z
	DD	01H
	DD	FLAT:__tryblocktable$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$4
	DD	02H
	DD	00H
	DD	03H
	DD	FLAT:__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$8
	DD	02H
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$381
	DD	09H
	DD	FLAT:__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$13
	DD	0dH
	DD	FLAT:__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$530
	DD	09H
	DD	FLAT:__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?LoadFavoriteVolumes@GostCrypt@@YAXXZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?LoadFavoriteVolumes@GostCrypt@@YAXXZ$0
__unwindtable$?LoadFavoriteVolumes@GostCrypt@@YAXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?LoadFavoriteVolumes@GostCrypt@@YAXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?LoadFavoriteVolumes@GostCrypt@@YAXXZ$2
__ehfuncinfo$?LoadFavoriteVolumes@GostCrypt@@YAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LoadFavoriteVolumes@GostCrypt@@YAXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?LoadFavoriteVolumes@GostCrypt@@YAXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetFavoriteVolumeLabel@GostCrypt@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFavoriteVolumeLabel@GostCrypt@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFavoriteVolumeLabel@GostCrypt@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z$2
__ehfuncinfo$?GetFavoriteVolumeLabel@GostCrypt@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetFavoriteVolumeLabel@GostCrypt@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?FillListControlSubItems@GostCrypt@@YAXPAUHWND__@@HABUFavoriteVolume@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FillListControlSubItems@GostCrypt@@YAXPAUHWND__@@HABUFavoriteVolume@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FillListControlSubItems@GostCrypt@@YAXPAUHWND__@@HABUFavoriteVolume@1@@Z$1
__ehfuncinfo$?FillListControlSubItems@GostCrypt@@YAXPAUHWND__@@HABUFavoriteVolume@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?FillListControlSubItems@GostCrypt@@YAXPAUHWND__@@HABUFavoriteVolume@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z$1
__ehfuncinfo$?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$75
	DD	01H
	DD	FLAT:__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$320
	DD	01H
	DD	FLAT:__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$10
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$442 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffff8dcH
	DD	FLAT:__catch$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$2
__catchsym$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$441 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffff8e0H
	DD	FLAT:__catch$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$0
__ehfuncinfo$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z
	DD	02H
	DD	FLAT:__tryblocktable$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$441
	DD	04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$442
__unwindtable$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$4
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$6
	DD	03H
	DD	00H
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$11
	DD	08H
	DD	FLAT:__unwindfunclet$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$14
	DD	0aH
	DD	FLAT:__unwindfunclet$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$15
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z$146
	DD	00H
	DD	FLAT:__unwindfunclet$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z$268
	DD	00H
	DD	FLAT:__unwindfunclet$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z$8
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z$68
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z$136
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z$204
__ehfuncinfo$??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z$2
__ehfuncinfo$??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$111
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
?SystemFavoriteVolumes$initializer$@GostCrypt@@3P6AXXZA DD FLAT:??__ESystemFavoriteVolumes@GostCrypt@@YAXXZ ; GostCrypt::SystemFavoriteVolumes$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?FavoritesOnArrivalMountRequired$initializer$@GostCrypt@@3P6AXXZA DD FLAT:??__EFavoritesOnArrivalMountRequired@GostCrypt@@YAXXZ ; GostCrypt::FavoritesOnArrivalMountRequired$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?FavoritesMountedOnArrivalStillConnected$initializer$@GostCrypt@@3P6AXXZA DD FLAT:??__EFavoritesMountedOnArrivalStillConnected@GostCrypt@@YAXXZ ; GostCrypt::FavoritesMountedOnArrivalStillConnected$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UFavoriteVolume@GostCrypt@@U12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@$$QAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UFavoriteVolume@GostCrypt@@U12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@$$QAU23@@Z PROC ; std::allocator<GostCrypt::FavoriteVolume>::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 08		 je	 SHORT $LN3@construct
  0000a	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@$$QAU01@@Z
$LN3@construct:

; 738  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??$construct@UFavoriteVolume@GostCrypt@@U12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@$$QAU23@@Z ENDP ; std::allocator<GostCrypt::FavoriteVolume>::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UFavoriteVolume@GostCrypt@@U12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@$$QAU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UFavoriteVolume@GostCrypt@@U12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@$$QAU34@@Z PROC ; std::allocator_traits<std::allocator<GostCrypt::FavoriteVolume> >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 08		 je	 SHORT $LN8@construct
  0000a	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@$$QAU01@@Z
$LN8@construct:

; 858  : 		}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$construct@UFavoriteVolume@GostCrypt@@U12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@$$QAU34@@Z ENDP ; std::allocator_traits<std::allocator<GostCrypt::FavoriteVolume> >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@UFavoriteVolume@GostCrypt@@@std@@YA$$QAUFavoriteVolume@GostCrypt@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UFavoriteVolume@GostCrypt@@@std@@YA$$QAUFavoriteVolume@GostCrypt@@AAU12@@Z PROC ; std::forward<GostCrypt::FavoriteVolume>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UFavoriteVolume@GostCrypt@@@std@@YA$$QAUFavoriteVolume@GostCrypt@@AAU12@@Z ENDP ; std::forward<GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
$T2 = 12						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::FavoriteVolume const *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT

; 220  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, no special optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 221  : 	_FwdIt _Next = _Dest;

  0002b	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]

; 222  : 
; 223  : 	_TRY_BEGIN

  0002e	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00031	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00034	89 75 ec	 mov	 DWORD PTR __Next$[ebp], esi
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003e	66 90		 npad	 2
$LL4@Uninitiali:

; 224  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00040	3b fb		 cmp	 edi, ebx
  00042	74 3c		 je	 SHORT $LN3@Uninitiali

; 225  : 		_Al.construct(_Unfancy(_Dest), *_First);

  00044	89 75 0c	 mov	 DWORD PTR $T2[ebp], esi
  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0004b	85 f6		 test	 esi, esi
  0004d	74 08		 je	 SHORT $LN25@Uninitiali
  0004f	57		 push	 edi
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
$LN25@Uninitiali:
  00057	83 c6 68	 add	 esi, 104		; 00000068H
  0005a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0005e	89 75 10	 mov	 DWORD PTR __Dest$[ebp], esi
  00061	83 c7 68	 add	 edi, 104		; 00000068H
  00064	eb da		 jmp	 SHORT $LL4@Uninitiali
__catch$??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0:

; 226  : 	_CATCH_ALL
; 227  : 	_Destroy_range(_Next, _Dest, _Al);

  00066	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00069	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0006c	ff 75 ec	 push	 DWORD PTR __Next$[ebp]
  0006f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@PAUFavoriteVolume@GostCrypt@@@std@@YAXPAUFavoriteVolume@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<GostCrypt::FavoriteVolume>,GostCrypt::FavoriteVolume *>
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 228  : 	_RERAISE;

  00077	6a 00		 push	 0
  00079	6a 00		 push	 0
  0007b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN38@Uninitiali:
$LN3@Uninitiali:

; 229  : 	_CATCH_END
; 230  : 
; 231  : 	return (_Dest);

  00080	8b c6		 mov	 eax, esi

; 232  : 	}

  00082	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00085	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008c	59		 pop	 ecx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN37@Uninitiali:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$4:
  00000	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00003	50		 push	 eax
  00004	8b 45 0c	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::FavoriteVolume const *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_copy_cat@$$CBUFavoriteVolume@GostCrypt@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBUFavoriteVolume@GostCrypt@@ABQAU23@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_copy_cat@$$CBUFavoriteVolume@GostCrypt@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBUFavoriteVolume@GostCrypt@@ABQAU23@@Z PROC ; std::_Ptr_copy_cat<GostCrypt::FavoriteVolume const ,GostCrypt::FavoriteVolume>, COMDAT

; 793  : 	return {};

  00000	32 c0		 xor	 al, al

; 794  : 	}

  00002	c3		 ret	 0
??$_Ptr_copy_cat@$$CBUFavoriteVolume@GostCrypt@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBUFavoriteVolume@GostCrypt@@ABQAU23@@Z ENDP ; std::_Ptr_copy_cat<GostCrypt::FavoriteVolume const ,GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UFavoriteVolume@GostCrypt@@U12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@$$QAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UFavoriteVolume@GostCrypt@@U12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@$$QAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 08		 je	 SHORT $LN13@construct
  0000a	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@$$QAU01@@Z
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??$construct@UFavoriteVolume@GostCrypt@@U12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@$$QAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UFavoriteVolume@GostCrypt@@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UFavoriteVolume@GostCrypt@@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@@Z PROC ; std::allocator<GostCrypt::FavoriteVolume>::destroy<GostCrypt::FavoriteVolume>, COMDAT
; _this$ = ecx

; 743  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 744  : 		_Ptr->~_Uty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ

; 745  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??$destroy@UFavoriteVolume@GostCrypt@@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@@Z ENDP ; std::allocator<GostCrypt::FavoriteVolume>::destroy<GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z PROC ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume const &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN3@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
$LN3@construct:

; 738  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy_al_unchecked@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<GostCrypt::FavoriteVolume const *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT

; 248  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 249  : 	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00017	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::FavoriteVolume const *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 250  : 		_Ptr_copy_cat(_First, _Dest),
; 251  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), decltype(*_First)>()));
; 252  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_copy_al_unchecked@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<GostCrypt::FavoriteVolume const *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@YAPBUFavoriteVolume@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@YAPBUFavoriteVolume@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >, COMDAT

; 271  : 	{	// convert to unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 272  : 	return (_Iter._Unchecked());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Iter$[ebp]

; 273  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@YAPBUFavoriteVolume@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,1><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 290  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,1><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT

; 273  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 274  : 	_FwdIt _Next = _Dest;
; 275  : 
; 276  : 	_TRY_BEGIN
; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 21		 je	 SHORT $LN39@Uninitiali
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL4@Uninitiali:

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));

  00013	85 ff		 test	 edi, edi
  00015	74 08		 je	 SHORT $LN2@Uninitiali
  00017	56		 push	 esi
  00018	8b cf		 mov	 ecx, edi
  0001a	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@$$QAU01@@Z
$LN2@Uninitiali:

; 274  : 	_FwdIt _Next = _Dest;
; 275  : 
; 276  : 	_TRY_BEGIN
; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  0001f	83 c6 68	 add	 esi, 104		; 00000068H
  00022	83 c7 68	 add	 edi, 104		; 00000068H
  00025	3b f3		 cmp	 esi, ebx
  00027	75 ea		 jne	 SHORT $LL4@Uninitiali

; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);
; 281  : 	_RERAISE;
; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);

  00029	8b c7		 mov	 eax, edi
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx

; 285  : 	}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN39@Uninitiali:

; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);
; 281  : 	_RERAISE;
; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);

  00030	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx

; 285  : 	}

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_move_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UFavoriteVolume@GostCrypt@@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UFavoriteVolume@GostCrypt@@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@@Z PROC ; std::allocator_traits<std::allocator<GostCrypt::FavoriteVolume> >::destroy<GostCrypt::FavoriteVolume>, COMDAT

; 863  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 864  : 		_Al.destroy(_Ptr);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 865  : 		}

  00006	5d		 pop	 ebp

; 864  : 		_Al.destroy(_Ptr);

  00007	e9 00 00 00 00	 jmp	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
??$destroy@UFavoriteVolume@GostCrypt@@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@@Z ENDP ; std::allocator_traits<std::allocator<GostCrypt::FavoriteVolume> >::destroy<GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z PROC ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >, COMDAT
; _this$ = ecx

; 554  : 		constexpr _Any_tag(_Ty&&) _NOEXCEPT {}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ENDP ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
$T2 = 12						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT

; 220  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, no special optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 221  : 	_FwdIt _Next = _Dest;

  0002b	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]

; 222  : 
; 223  : 	_TRY_BEGIN

  0002e	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00031	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00034	89 75 ec	 mov	 DWORD PTR __Next$[ebp], esi
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003e	66 90		 npad	 2
$LL4@Uninitiali:

; 224  : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00040	3b fb		 cmp	 edi, ebx
  00042	74 3c		 je	 SHORT $LN3@Uninitiali

; 225  : 		_Al.construct(_Unfancy(_Dest), *_First);

  00044	89 75 0c	 mov	 DWORD PTR $T2[ebp], esi
  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0004b	85 f6		 test	 esi, esi
  0004d	74 08		 je	 SHORT $LN25@Uninitiali
  0004f	57		 push	 edi
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
$LN25@Uninitiali:
  00057	83 c6 68	 add	 esi, 104		; 00000068H
  0005a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0005e	89 75 10	 mov	 DWORD PTR __Dest$[ebp], esi
  00061	83 c7 68	 add	 edi, 104		; 00000068H
  00064	eb da		 jmp	 SHORT $LL4@Uninitiali
__catch$??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0:

; 226  : 	_CATCH_ALL
; 227  : 	_Destroy_range(_Next, _Dest, _Al);

  00066	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00069	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0006c	ff 75 ec	 push	 DWORD PTR __Next$[ebp]
  0006f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@PAUFavoriteVolume@GostCrypt@@@std@@YAXPAUFavoriteVolume@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<GostCrypt::FavoriteVolume>,GostCrypt::FavoriteVolume *>
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 228  : 	_RERAISE;

  00077	6a 00		 push	 0
  00079	6a 00		 push	 0
  0007b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN38@Uninitiali:
$LN3@Uninitiali:

; 229  : 	_CATCH_END
; 230  : 
; 231  : 	return (_Dest);

  00080	8b c6		 mov	 eax, esi

; 232  : 	}

  00082	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00085	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008c	59		 pop	 ecx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN37@Uninitiali:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$4:
  00000	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00003	50		 push	 eax
  00004	8b 45 0c	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume const &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN8@construct
  00034	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
$LN8@construct:

; 858  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z$1:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YA$$QAV?$allocator@UFavoriteVolume@GostCrypt@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YA$$QAV?$allocator@UFavoriteVolume@GostCrypt@@@0@AAV10@@Z PROC ; std::forward<std::allocator<GostCrypt::FavoriteVolume> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YA$$QAV?$allocator@UFavoriteVolume@GostCrypt@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@0@AAV10@@Z PROC ; std::forward<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@PAUFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@2@@std@@YAPAUFavoriteVolume@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@0@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@PAUFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@2@@std@@YAPAUFavoriteVolume@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@0@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT

; 259  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 260  : 		// note: only called internally from elsewhere in the STL, debug checks
; 261  : 		// and deprecation warnings omitted
; 262  : 	return (_Rechecked(_Dest,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00017	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::FavoriteVolume const *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 263  : 		_Uninitialized_copy_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 264  : 			_Unchecked(_Dest), _Al)));
; 265  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@PAUFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@2@@std@@YAPAUFavoriteVolume@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@0@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >,1><std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 290  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >,1><std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > > >, COMDAT
; _this$ = ecx

; 1426 : 		{	// insert [_First, _Last) at _Where, forward iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d e8	 mov	 DWORD PTR _this$[ebp], edi

; 1427 : 		_DEBUG_RANGE(_First, _Last);
; 1428 : 		_Iter _Next = _First;

  00030	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00033	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 1429 : 
; 1430 : 		_TRY_BEGIN

  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003d	0f 1f 00	 npad	 3
$LL4@Insert_ran:

; 1431 : 		for (; _First != _Last; ++_First)

  00040	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  00043	74 6b		 je	 SHORT $LN3@Insert_ran

; 1432 : 			_Insert(_Where, *_First);

  00045	8b 75 08	 mov	 esi, DWORD PTR __Where$[ebp]
  00048	83 c0 08	 add	 eax, 8
  0004b	50		 push	 eax
  0004c	8b cf		 mov	 ecx, edi
  0004e	ff 76 04	 push	 DWORD PTR [esi+4]
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Buynode<GostCrypt::FavoriteVolume const &>
  00057	8b d0		 mov	 edx, eax
  00059	b9 91 24 49 02	 mov	 ecx, 38347921		; 02492491H
  0005e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00061	2b c8		 sub	 ecx, eax
  00063	83 f9 01	 cmp	 ecx, 1
  00066	73 0a		 jae	 SHORT $LN38@Insert_ran
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN111@Insert_ran:
$LN38@Insert_ran:
  00072	40		 inc	 eax
  00073	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00076	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00079	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007c	89 10		 mov	 DWORD PTR [eax], edx
  0007e	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00081	8b 00		 mov	 eax, DWORD PTR [eax]
  00083	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
  00086	eb b8		 jmp	 SHORT $LL4@Insert_ran
__catch$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$0:

; 1433 : 		_CATCH_ALL
; 1434 : 		for (; _Next != _First; ++_Next)

  00088	8b 75 ec	 mov	 esi, DWORD PTR __Next$[ebp]
  0008b	3b 75 0c	 cmp	 esi, DWORD PTR __First$[ebp]
  0008e	74 17		 je	 SHORT $LN6@Insert_ran
  00090	8b 7d e8	 mov	 edi, DWORD PTR _this$[ebp]
$LL7@Insert_ran:

; 1435 : 			{	// undo inserts
; 1436 : 			_Unchecked_const_iterator _Before = _Where;
; 1437 : 			_Unchecked_erase(--_Before);

  00093	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00096	8b cf		 mov	 ecx, edi
  00098	ff 70 04	 push	 DWORD PTR [eax+4]
  0009b	e8 00 00 00 00	 call	 ?_Unchecked_erase@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Unchecked_erase
  000a0	8b 36		 mov	 esi, DWORD PTR [esi]
  000a2	3b 75 0c	 cmp	 esi, DWORD PTR __First$[ebp]
  000a5	75 ec		 jne	 SHORT $LL7@Insert_ran
$LN6@Insert_ran:

; 1438 : 			}
; 1439 : 		_RERAISE;

  000a7	6a 00		 push	 0
  000a9	6a 00		 push	 0
  000ab	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN112@Insert_ran:
$LN3@Insert_ran:

; 1440 : 		_CATCH_END
; 1441 : 		}

  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 10 00	 ret	 16			; 00000010H
$LN110@Insert_ran:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@1@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > ><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,void>, COMDAT
; _this$ = ecx

; 611  : 		{	// construct head node, allocator from _Al

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 612  : 		_Myhead() = _Buyheadnode();

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Buynode0
  00019	89 06		 mov	 DWORD PTR [esi], eax

; 613  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@1@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > ><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::construct<std::_List_node<GostCrypt::FavoriteVolume,void *> *,std::_List_node<GostCrypt::FavoriteVolume,void *> * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::construct<std::_List_node<GostCrypt::FavoriteVolume,void *> *,std::_List_node<GostCrypt::FavoriteVolume,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move_al_unchecked@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 302  : 	typedef decltype(_STD move(*_First)) _Src_type; // TRANSITION MODULES VSO#222794
; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00017	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Uninitialized_move_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABV?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> const &>, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0ABV?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z PROC	; std::allocator<wchar_t>::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ENDP	; std::allocator<wchar_t>::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UFavoriteVolume@GostCrypt@@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UFavoriteVolume@GostCrypt@@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::destroy<GostCrypt::FavoriteVolume>, COMDAT
; _this$ = ecx

; 1002 : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1003 : 		_Mytraits::destroy(*this, _Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ

; 1004 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??$destroy@UFavoriteVolume@GostCrypt@@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::destroy<GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UFavoriteVolume@GostCrypt@@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UFavoriteVolume@GostCrypt@@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@@Z PROC ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::destroy<GostCrypt::FavoriteVolume>, COMDAT
; _this$ = ecx

; 743  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 744  : 		_Ptr->~_Uty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ

; 745  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??$destroy@UFavoriteVolume@GostCrypt@@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::destroy<GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z PROC ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::destroy<std::_List_node<GostCrypt::FavoriteVolume,void *> *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::destroy<std::_List_node<GostCrypt::FavoriteVolume,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAAAPAUFavoriteVolume@GostCrypt@@AAPAU12@PAU12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAAAPAUFavoriteVolume@GostCrypt@@AAPAU12@PAU12@@Z PROC ; std::_Rechecked<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>, COMDAT

; 457  : 	{	// reset checked from unchecked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 458  : 	_Dest = _Src;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Src$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 459  : 	return (_Dest);
; 460  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Rechecked@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAAAPAUFavoriteVolume@GostCrypt@@AAPAU12@PAU12@@Z ENDP ; std::_Rechecked<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy_al_unchecked@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT

; 248  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 249  : 	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00017	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 250  : 		_Ptr_copy_cat(_First, _Dest),
; 251  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), decltype(*_First)>()));
; 252  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_copy_al_unchecked@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUFavoriteVolume@GostCrypt@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUFavoriteVolume@GostCrypt@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@@Z PROC ; std::_Unchecked<GostCrypt::FavoriteVolume *>, COMDAT

; 427  : 	{	// construct unchecked from checked, generic

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 429  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unchecked@PAUFavoriteVolume@GostCrypt@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@@Z ENDP ; std::_Unchecked<GostCrypt::FavoriteVolume *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z PROC ; std::allocator<GostCrypt::FavoriteVolume>::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume const &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN3@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
$LN3@construct:

; 738  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z ENDP ; std::allocator<GostCrypt::FavoriteVolume>::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z PROC ; std::allocator<GostCrypt::FavoriteVolume>::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN3@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
$LN3@construct:

; 738  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z ENDP ; std::allocator<GostCrypt::FavoriteVolume>::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume const &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN13@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z$2:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@$$QAV?$allocator@UFavoriteVolume@GostCrypt@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@$$QAV?$allocator@UFavoriteVolume@GostCrypt@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> ><std::allocator<GostCrypt::FavoriteVolume> >, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@$$QAV?$allocator@UFavoriteVolume@GostCrypt@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> ><std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAE@$$QAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAE@$$QAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > ><std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAE@$$QAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > ><std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEPAUFavoriteVolume@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@0PAU23@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEPAUFavoriteVolume@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@0PAU23@@Z PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > > >, COMDAT
; _this$ = ecx

; 1651 : 		{	// copy initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1652 : 		return (_Uninitialized_copy(_First, _Last,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	51		 push	 ecx
  0000f	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00012	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00015	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00018	e8 00 00 00 00	 call	 ??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::FavoriteVolume const *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
  0001d	83 c4 18	 add	 esp, 24			; 00000018H

; 1653 : 			_Ptr, this->_Getal()));
; 1654 : 		}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEPAUFavoriteVolume@GostCrypt@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@0PAU23@@Z ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > ><std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,void>, COMDAT
; _this$ = ecx

; 526  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 529  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > ><std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$insert@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
$T2 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
??$insert@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@00@Z PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::insert<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > > >, COMDAT
; _this$ = ecx

; 1382 : 		{	// insert [_First, _Last) at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1383 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1384 : 		if (_Where._Getcont() != &this->_Get_data())
; 1385 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1386 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1387 : 
; 1388 : 		iterator _Prev = _Make_iter(_Where);
; 1389 : 		if (_Prev == begin())

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 1390 : 			{	// insert sequence at beginning
; 1391 : 			_Insert_range(_Where._Unchecked(), _First, _Last,

  0000a	c6 45 fc 00	 mov	 BYTE PTR $T2[ebp], 0
  0000e	8b 17		 mov	 edx, DWORD PTR [edi]
  00010	3b 02		 cmp	 eax, DWORD PTR [edx]
  00012	75 1f		 jne	 SHORT $LN2@insert
  00014	ff 75 fc	 push	 DWORD PTR $T2[ebp]
  00017	ff 75 14	 push	 DWORD PTR __Last$[ebp]
  0001a	ff 75 10	 push	 DWORD PTR __First$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > > >

; 1392 : 				_Iter_cat_t<_Iter>());
; 1393 : 			return (begin());

  00023	8b 07		 mov	 eax, DWORD PTR [edi]
  00025	5f		 pop	 edi
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1399 : 				_Iter_cat_t<_Iter>());
; 1400 : 			return (++_Prev);

  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 1401 : 			}
; 1402 : 		}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 10 00	 ret	 16			; 00000010H
$LN2@insert:
  00033	56		 push	 esi

; 1394 : 			}
; 1395 : 		else
; 1396 : 			{	// insert sequence not at beginning
; 1397 : 			--_Prev;
; 1398 : 			_Insert_range(_Where._Unchecked(), _First, _Last,

  00034	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00037	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0003a	ff 75 14	 push	 DWORD PTR __Last$[ebp]
  0003d	ff 75 10	 push	 DWORD PTR __First$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > > >

; 1399 : 				_Iter_cat_t<_Iter>());
; 1400 : 			return (++_Prev);

  00046	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00049	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0004b	5e		 pop	 esi
  0004c	5f		 pop	 edi
  0004d	89 08		 mov	 DWORD PTR [eax], ecx

; 1401 : 			}
; 1402 : 		}

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 10 00	 ret	 16			; 00000010H
??$insert@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@00@Z ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::insert<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??F?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::operator--, COMDAT
; _this$ = ecx

; 389  : 		--(*(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00005	89 01		 mov	 DWORD PTR [ecx], eax

; 390  : 		return (*this);

  00007	8b c1		 mov	 eax, ecx

; 391  : 		}

  00009	c3		 ret	 0
??F?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::operator++, COMDAT
; _this$ = ecx

; 376  : 		++(*(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 377  : 		return (*this);

  00006	8b c1		 mov	 eax, ecx

; 378  : 		}

  00008	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >, COMDAT
; _this$ = ecx

; 348  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 347  : 		: _Mybase(_Pnode, _Plist)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 349  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@1@@Z PROC ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> ><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,void>, COMDAT
; _this$ = ecx

; 825  : 		{	// construct from allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Buynode0
  00020	89 06		 mov	 DWORD PTR [esi], eax

; 826  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@1@@Z ENDP ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> ><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::construct<std::_List_node<GostCrypt::FavoriteVolume,void *> *,std::_List_node<GostCrypt::FavoriteVolume,void *> * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::construct<std::_List_node<GostCrypt::FavoriteVolume,void *> *,std::_List_node<GostCrypt::FavoriteVolume,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@YAAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@YAAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<GostCrypt::FavoriteVolume,void *> * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@YAAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<GostCrypt::FavoriteVolume,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z PROC ; std::_Uninitialized_move<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00017	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Uninitialized_move_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z PROC ; std::forward<std::allocator<wchar_t> const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z ENDP ; std::forward<std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z PROC		; std::forward<wchar_t * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ENDP		; std::forward<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1039 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1052 : 	_Left = _STD move(_Right);
; 1053 : 	}

  00000	c3		 ret	 0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1039 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1052 : 	_Left = _STD move(_Right);
; 1053 : 	}

  00000	c3		 ret	 0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z PROC ; std::forward<std::allocator<wchar_t> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ENDP ; std::forward<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@PAUFavoriteVolume@GostCrypt@@@std@@YAXPAUFavoriteVolume@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@PAUFavoriteVolume@GostCrypt@@@std@@YAXPAUFavoriteVolume@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<std::allocator<GostCrypt::FavoriteVolume>,GostCrypt::FavoriteVolume *>, COMDAT

; 1099 : 	{	// destroy [_First, _Last), no special optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1100 : 	for (; _First != _Last; ++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 0f		 je	 SHORT $LN3@Destroy_ra
  0000f	90		 npad	 1
$LL4@Destroy_ra:

; 1101 : 		_Al.destroy(_Unfancy(_First));

  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  00017	83 c6 68	 add	 esi, 104		; 00000068H
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $LL4@Destroy_ra
$LN3@Destroy_ra:
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 1102 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Destroy_range1@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@PAUFavoriteVolume@GostCrypt@@@std@@YAXPAUFavoriteVolume@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<std::allocator<GostCrypt::FavoriteVolume>,GostCrypt::FavoriteVolume *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT

; 1039 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UFavoriteVolume@GostCrypt@@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAUFavoriteVolume@GostCrypt@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UFavoriteVolume@GostCrypt@@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAUFavoriteVolume@GostCrypt@@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<GostCrypt::FavoriteVolume>, COMDAT

; 863  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 864  : 		_Al.destroy(_Ptr);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 865  : 		}

  00006	5d		 pop	 ebp

; 864  : 		_Al.destroy(_Ptr);

  00007	e9 00 00 00 00	 jmp	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
??$destroy@UFavoriteVolume@GostCrypt@@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAUFavoriteVolume@GostCrypt@@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<std::_List_node<GostCrypt::FavoriteVolume,void *> *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<std::_List_node<GostCrypt::FavoriteVolume,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator==<char,char>, COMDAT

; 796  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 797  : 	}

  00002	c3		 ret	 0
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator==<char,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator==<std::allocator<char>,std::allocator<char> >, COMDAT

; 1017 : 	return (static_cast<const _Ty&>(_Left)

  00000	b0 01		 mov	 al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator==<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z PROC		; std::operator==<wchar_t,wchar_t>, COMDAT

; 796  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 797  : 	}

  00002	c3		 ret	 0
??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z ENDP		; std::operator==<wchar_t,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 1017 : 	return (static_cast<const _Ty&>(_Left)

  00000	b0 01		 mov	 al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT

; 259  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 260  : 		// note: only called internally from elsewhere in the STL, debug checks
; 261  : 		// and deprecation warnings omitted
; 262  : 	return (_Rechecked(_Dest,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00017	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 263  : 		_Uninitialized_copy_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 264  : 			_Unchecked(_Dest), _Al)));
; 265  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_copy@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z PROC ; std::_Copy_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>, COMDAT

; 2314 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2315 : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0000a	0f 84 b7 00 00
	00		 je	 $LN538@Copy_unche
  00010	53		 push	 ebx
  00011	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00014	83 c6 30	 add	 esi, 48			; 00000030H
  00017	57		 push	 edi
  00018	8d 7b 30	 lea	 edi, DWORD PTR [ebx+48]
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@Copy_unche:

; 2316 : 		*_Dest = *_First;

  00020	8d 46 d0	 lea	 eax, DWORD PTR [esi-48]
  00023	3b d8		 cmp	 ebx, eax
  00025	74 0f		 je	 SHORT $LN9@Copy_unche
  00027	6a ff		 push	 -1
  00029	6a 00		 push	 0
  0002b	8d 46 d0	 lea	 eax, DWORD PTR [esi-48]
  0002e	8b cb		 mov	 ecx, ebx
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN9@Copy_unche:
  00036	8d 4e e8	 lea	 ecx, DWORD PTR [esi-24]
  00039	8d 47 e8	 lea	 eax, DWORD PTR [edi-24]
  0003c	3b c1		 cmp	 eax, ecx
  0003e	74 10		 je	 SHORT $LN140@Copy_unche
  00040	6a ff		 push	 -1
  00042	6a 00		 push	 0
  00044	8d 46 e8	 lea	 eax, DWORD PTR [esi-24]
  00047	50		 push	 eax
  00048	8d 4f e8	 lea	 ecx, DWORD PTR [edi-24]
  0004b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN140@Copy_unche:
  00050	3b fe		 cmp	 edi, esi
  00052	74 0c		 je	 SHORT $LN271@Copy_unche
  00054	6a ff		 push	 -1
  00056	6a 00		 push	 0
  00058	56		 push	 esi
  00059	8b cf		 mov	 ecx, edi
  0005b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN271@Copy_unche:
  00060	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  00063	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  00066	3b c8		 cmp	 ecx, eax
  00068	74 0a		 je	 SHORT $LN402@Copy_unche
  0006a	6a ff		 push	 -1
  0006c	6a 00		 push	 0
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN402@Copy_unche:
  00074	0f b6 46 30	 movzx	 eax, BYTE PTR [esi+48]
  00078	83 c3 68	 add	 ebx, 104		; 00000068H
  0007b	88 47 30	 mov	 BYTE PTR [edi+48], al
  0007e	0f b6 46 31	 movzx	 eax, BYTE PTR [esi+49]
  00082	88 47 31	 mov	 BYTE PTR [edi+49], al
  00085	0f b6 46 32	 movzx	 eax, BYTE PTR [esi+50]
  00089	88 47 32	 mov	 BYTE PTR [edi+50], al
  0008c	0f b6 46 33	 movzx	 eax, BYTE PTR [esi+51]
  00090	88 47 33	 mov	 BYTE PTR [edi+51], al
  00093	0f b6 46 34	 movzx	 eax, BYTE PTR [esi+52]
  00097	88 47 34	 mov	 BYTE PTR [edi+52], al
  0009a	0f b6 46 35	 movzx	 eax, BYTE PTR [esi+53]
  0009e	88 47 35	 mov	 BYTE PTR [edi+53], al
  000a1	0f b6 46 36	 movzx	 eax, BYTE PTR [esi+54]
  000a5	88 47 36	 mov	 BYTE PTR [edi+54], al
  000a8	8a 4e 37	 mov	 cl, BYTE PTR [esi+55]
  000ab	83 c6 68	 add	 esi, 104		; 00000068H
  000ae	88 4f 37	 mov	 BYTE PTR [edi+55], cl
  000b1	83 c7 68	 add	 edi, 104		; 00000068H
  000b4	8d 4e d0	 lea	 ecx, DWORD PTR [esi-48]
  000b7	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  000ba	0f 85 60 ff ff
	ff		 jne	 $LL4@Copy_unche

; 2317 : 	return (_Dest);

  000c0	5f		 pop	 edi
  000c1	8b c3		 mov	 eax, ebx
  000c3	5b		 pop	 ebx
  000c4	5e		 pop	 esi

; 2318 : 	}

  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
$LN538@Copy_unche:

; 2317 : 	return (_Dest);

  000c7	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  000ca	5e		 pop	 esi

; 2318 : 	}

  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
??$_Copy_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_copy_cat@UFavoriteVolume@GostCrypt@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUFavoriteVolume@GostCrypt@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_copy_cat@UFavoriteVolume@GostCrypt@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUFavoriteVolume@GostCrypt@@0@Z PROC ; std::_Ptr_copy_cat<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume>, COMDAT

; 793  : 	return {};

  00000	32 c0		 xor	 al, al

; 794  : 	}

  00002	c3		 ret	 0
??$_Ptr_copy_cat@UFavoriteVolume@GostCrypt@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUFavoriteVolume@GostCrypt@@0@Z ENDP ; std::_Ptr_copy_cat<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8UFavoriteVolume@GostCrypt@@U01@@std@@YA_NABV?$allocator@UFavoriteVolume@GostCrypt@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8UFavoriteVolume@GostCrypt@@U01@@std@@YA_NABV?$allocator@UFavoriteVolume@GostCrypt@@@0@0@Z PROC ; std::operator==<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume>, COMDAT

; 796  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 797  : 	}

  00002	c3		 ret	 0
??$?8UFavoriteVolume@GostCrypt@@U01@@std@@YA_NABV?$allocator@UFavoriteVolume@GostCrypt@@@0@0@Z ENDP ; std::operator==<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@UFavoriteVolume@GostCrypt@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@UFavoriteVolume@GostCrypt@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@0@Z PROC ; std::operator==<std::allocator<GostCrypt::FavoriteVolume>,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT

; 1017 : 	return (static_cast<const _Ty&>(_Left)

  00000	b0 01		 mov	 al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@UFavoriteVolume@GostCrypt@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@0@Z ENDP ; std::operator==<std::allocator<GostCrypt::FavoriteVolume>,std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z PROC ; std::allocator_traits<std::allocator<GostCrypt::FavoriteVolume> >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume const &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN8@construct
  00034	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
$LN8@construct:

; 858  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z$1:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@ABU34@@Z ENDP ; std::allocator_traits<std::allocator<GostCrypt::FavoriteVolume> >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@AAU34@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@AAU34@@Z PROC ; std::allocator_traits<std::allocator<GostCrypt::FavoriteVolume> >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@AAU34@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN8@construct
  00034	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
$LN8@construct:

; 858  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@AAU34@@Z$1:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@AAU34@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@AAU34@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAXAAV?$allocator@UFavoriteVolume@GostCrypt@@@1@PAUFavoriteVolume@GostCrypt@@AAU34@@Z ENDP ; std::allocator_traits<std::allocator<GostCrypt::FavoriteVolume> >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAUFavoriteVolume@GostCrypt@@@std@@YAAAUFavoriteVolume@GostCrypt@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUFavoriteVolume@GostCrypt@@@std@@YAAAUFavoriteVolume@GostCrypt@@AAU12@@Z PROC ; std::forward<GostCrypt::FavoriteVolume &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAUFavoriteVolume@GostCrypt@@@std@@YAAAUFavoriteVolume@GostCrypt@@AAU12@@Z ENDP ; std::forward<GostCrypt::FavoriteVolume &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
tv5245 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Dest$1$ = 8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z PROC ; std::_Move_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>, COMDAT

; 2579 : 	{	// move [_First, _Last) to [_Dest, ...), no special optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2580 : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00026	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00029	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0002c	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0002f	0f 84 f8 02 00
	00		 je	 $LN1958@Move_unche
  00035	8d 78 2c	 lea	 edi, DWORD PTR [eax+44]
  00038	89 4d 08	 mov	 DWORD PTR __Dest$1$[ebp], ecx
  0003b	2b c1		 sub	 eax, ecx
  0003d	8d 71 2c	 lea	 esi, DWORD PTR [ecx+44]
  00040	83 c0 d4	 add	 eax, -44		; ffffffd4H
  00043	89 45 f0	 mov	 DWORD PTR tv5245[ebp], eax
  00046	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@Move_unche:

; 2581 : 		*_Dest = _STD move(*_First);

  00050	8d 1c 30	 lea	 ebx, DWORD PTR [eax+esi]
  00053	3b cb		 cmp	 ecx, ebx
  00055	0f 84 af 00 00
	00		 je	 $LN553@Move_unche
  0005b	8b 46 e8	 mov	 eax, DWORD PTR [esi-24]
  0005e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00061	72 40		 jb	 SHORT $LN102@Move_unche
  00063	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00065	40		 inc	 eax
  00066	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0006b	72 2a		 jb	 SHORT $LN97@Move_unche
  0006d	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00070	0f 85 b2 02 00
	00		 jne	 $LN1944@Move_unche
  00076	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00079	3b c1		 cmp	 eax, ecx
  0007b	0f 83 a7 02 00
	00		 jae	 $LN1944@Move_unche
  00081	2b c8		 sub	 ecx, eax
  00083	83 f9 04	 cmp	 ecx, 4
  00086	0f 82 9c 02 00
	00		 jb	 $LN1944@Move_unche
  0008c	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0008f	0f 87 93 02 00
	00		 ja	 $LN1944@Move_unche
  00095	8b c8		 mov	 ecx, eax
$LN97@Move_unche:
  00097	51		 push	 ecx
  00098	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$1$[ebp]
  000a0	83 c4 04	 add	 esp, 4
$LN102@Move_unche:
  000a3	c7 46 e8 0f 00
	00 00		 mov	 DWORD PTR [esi-24], 15	; 0000000fH
  000aa	83 7e e8 10	 cmp	 DWORD PTR [esi-24], 16	; 00000010H
  000ae	c7 46 e4 00 00
	00 00		 mov	 DWORD PTR [esi-28], 0
  000b5	72 04		 jb	 SHORT $LN125@Move_unche
  000b7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b9	eb 02		 jmp	 SHORT $LN126@Move_unche
$LN125@Move_unche:
  000bb	8b c1		 mov	 eax, ecx
$LN126@Move_unche:
  000bd	c6 00 00	 mov	 BYTE PTR [eax], 0
  000c0	83 7f e8 10	 cmp	 DWORD PTR [edi-24], 16	; 00000010H
  000c4	73 15		 jae	 SHORT $LN323@Move_unche
  000c6	8b 47 e4	 mov	 eax, DWORD PTR [edi-28]
  000c9	83 c0 01	 add	 eax, 1
  000cc	74 17		 je	 SHORT $LN324@Move_unche
  000ce	50		 push	 eax
  000cf	53		 push	 ebx
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 _memmove
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d9	eb 0a		 jmp	 SHORT $LN324@Move_unche
$LN323@Move_unche:
  000db	8b 03		 mov	 eax, DWORD PTR [ebx]
  000dd	89 01		 mov	 DWORD PTR [ecx], eax
  000df	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN324@Move_unche:
  000e5	8b 47 e4	 mov	 eax, DWORD PTR [edi-28]
  000e8	89 46 e4	 mov	 DWORD PTR [esi-28], eax
  000eb	8b 47 e8	 mov	 eax, DWORD PTR [edi-24]
  000ee	89 46 e8	 mov	 DWORD PTR [esi-24], eax
  000f1	c7 47 e8 0f 00
	00 00		 mov	 DWORD PTR [edi-24], 15	; 0000000fH
  000f8	83 7f e8 10	 cmp	 DWORD PTR [edi-24], 16	; 00000010H
  000fc	c7 47 e4 00 00
	00 00		 mov	 DWORD PTR [edi-28], 0
  00103	72 02		 jb	 SHORT $LN549@Move_unche
  00105	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN549@Move_unche:
  00107	c6 03 00	 mov	 BYTE PTR [ebx], 0
$LN553@Move_unche:
  0010a	8d 4e ec	 lea	 ecx, DWORD PTR [esi-20]
  0010d	8d 47 ec	 lea	 eax, DWORD PTR [edi-20]
  00110	3b c8		 cmp	 ecx, eax
  00112	0f 84 b3 00 00
	00		 je	 $LN1097@Move_unche
  00118	8b 06		 mov	 eax, DWORD PTR [esi]
  0011a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0011d	72 3e		 jb	 SHORT $LN646@Move_unche
  0011f	8b 4e ec	 mov	 ecx, DWORD PTR [esi-20]
  00122	40		 inc	 eax
  00123	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00128	72 2a		 jb	 SHORT $LN641@Move_unche
  0012a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0012d	0f 85 f5 01 00
	00		 jne	 $LN1944@Move_unche
  00133	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00136	3b c1		 cmp	 eax, ecx
  00138	0f 83 ea 01 00
	00		 jae	 $LN1944@Move_unche
  0013e	2b c8		 sub	 ecx, eax
  00140	83 f9 04	 cmp	 ecx, 4
  00143	0f 82 df 01 00
	00		 jb	 $LN1944@Move_unche
  00149	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0014c	0f 87 d6 01 00
	00		 ja	 $LN1944@Move_unche
  00152	8b c8		 mov	 ecx, eax
$LN641@Move_unche:
  00154	51		 push	 ecx
  00155	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0015a	83 c4 04	 add	 esp, 4
$LN646@Move_unche:
  0015d	c7 06 0f 00 00
	00		 mov	 DWORD PTR [esi], 15	; 0000000fH
  00163	8d 4e ec	 lea	 ecx, DWORD PTR [esi-20]
  00166	83 3e 10	 cmp	 DWORD PTR [esi], 16	; 00000010H
  00169	c7 46 fc 00 00
	00 00		 mov	 DWORD PTR [esi-4], 0
  00170	72 04		 jb	 SHORT $LN669@Move_unche
  00172	8b 01		 mov	 eax, DWORD PTR [ecx]
  00174	eb 02		 jmp	 SHORT $LN670@Move_unche
$LN669@Move_unche:
  00176	8b c1		 mov	 eax, ecx
$LN670@Move_unche:
  00178	c6 00 00	 mov	 BYTE PTR [eax], 0
  0017b	83 3f 10	 cmp	 DWORD PTR [edi], 16	; 00000010H
  0017e	73 18		 jae	 SHORT $LN867@Move_unche
  00180	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  00183	83 c0 01	 add	 eax, 1
  00186	74 1c		 je	 SHORT $LN868@Move_unche
  00188	50		 push	 eax
  00189	8d 47 ec	 lea	 eax, DWORD PTR [edi-20]
  0018c	50		 push	 eax
  0018d	51		 push	 ecx
  0018e	e8 00 00 00 00	 call	 _memmove
  00193	83 c4 0c	 add	 esp, 12			; 0000000cH
  00196	eb 0c		 jmp	 SHORT $LN868@Move_unche
$LN867@Move_unche:
  00198	8b 47 ec	 mov	 eax, DWORD PTR [edi-20]
  0019b	89 01		 mov	 DWORD PTR [ecx], eax
  0019d	c7 47 ec 00 00
	00 00		 mov	 DWORD PTR [edi-20], 0
$LN868@Move_unche:
  001a4	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  001a7	89 46 fc	 mov	 DWORD PTR [esi-4], eax
  001aa	8b 07		 mov	 eax, DWORD PTR [edi]
  001ac	89 06		 mov	 DWORD PTR [esi], eax
  001ae	c7 07 0f 00 00
	00		 mov	 DWORD PTR [edi], 15	; 0000000fH
  001b4	83 3f 10	 cmp	 DWORD PTR [edi], 16	; 00000010H
  001b7	c7 47 fc 00 00
	00 00		 mov	 DWORD PTR [edi-4], 0
  001be	72 05		 jb	 SHORT $LN1092@Move_unche
  001c0	8b 47 ec	 mov	 eax, DWORD PTR [edi-20]
  001c3	eb 03		 jmp	 SHORT $LN1093@Move_unche
$LN1092@Move_unche:
  001c5	8d 47 ec	 lea	 eax, DWORD PTR [edi-20]
$LN1093@Move_unche:
  001c8	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN1097@Move_unche:
  001cb	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  001ce	8d 5f 04	 lea	 ebx, DWORD PTR [edi+4]
  001d1	3b cb		 cmp	 ecx, ebx
  001d3	0f 84 af 00 00
	00		 je	 $LN1640@Move_unche
  001d9	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  001dc	83 f8 10	 cmp	 eax, 16			; 00000010H
  001df	72 40		 jb	 SHORT $LN1189@Move_unche
  001e1	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001e3	40		 inc	 eax
  001e4	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  001e9	72 2a		 jb	 SHORT $LN1184@Move_unche
  001eb	f6 c1 1f	 test	 cl, 31			; 0000001fH
  001ee	0f 85 34 01 00
	00		 jne	 $LN1944@Move_unche
  001f4	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  001f7	3b c1		 cmp	 eax, ecx
  001f9	0f 83 29 01 00
	00		 jae	 $LN1944@Move_unche
  001ff	2b c8		 sub	 ecx, eax
  00201	83 f9 04	 cmp	 ecx, 4
  00204	0f 82 1e 01 00
	00		 jb	 $LN1944@Move_unche
  0020a	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0020d	0f 87 15 01 00
	00		 ja	 $LN1944@Move_unche
  00213	8b c8		 mov	 ecx, eax
$LN1184@Move_unche:
  00215	51		 push	 ecx
  00216	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0021b	83 c4 04	 add	 esp, 4
  0021e	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
$LN1189@Move_unche:
  00221	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00228	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H
  0022c	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00233	72 04		 jb	 SHORT $LN1212@Move_unche
  00235	8b 01		 mov	 eax, DWORD PTR [ecx]
  00237	eb 02		 jmp	 SHORT $LN1213@Move_unche
$LN1212@Move_unche:
  00239	8b c1		 mov	 eax, ecx
$LN1213@Move_unche:
  0023b	c6 00 00	 mov	 BYTE PTR [eax], 0
  0023e	83 7f 18 10	 cmp	 DWORD PTR [edi+24], 16	; 00000010H
  00242	73 15		 jae	 SHORT $LN1410@Move_unche
  00244	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00247	83 c0 01	 add	 eax, 1
  0024a	74 17		 je	 SHORT $LN1411@Move_unche
  0024c	50		 push	 eax
  0024d	53		 push	 ebx
  0024e	51		 push	 ecx
  0024f	e8 00 00 00 00	 call	 _memmove
  00254	83 c4 0c	 add	 esp, 12			; 0000000cH
  00257	eb 0a		 jmp	 SHORT $LN1411@Move_unche
$LN1410@Move_unche:
  00259	8b 03		 mov	 eax, DWORD PTR [ebx]
  0025b	89 01		 mov	 DWORD PTR [ecx], eax
  0025d	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN1411@Move_unche:
  00263	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00266	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00269	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0026c	89 46 18	 mov	 DWORD PTR [esi+24], eax
  0026f	c7 47 18 0f 00
	00 00		 mov	 DWORD PTR [edi+24], 15	; 0000000fH
  00276	83 7f 18 10	 cmp	 DWORD PTR [edi+24], 16	; 00000010H
  0027a	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
  00281	72 02		 jb	 SHORT $LN1636@Move_unche
  00283	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN1636@Move_unche:
  00285	c6 03 00	 mov	 BYTE PTR [ebx], 0
$LN1640@Move_unche:
  00288	8d 5e 1c	 lea	 ebx, DWORD PTR [esi+28]
  0028b	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
  0028e	3b d9		 cmp	 ebx, ecx
  00290	74 3d		 je	 SHORT $LN1646@Move_unche
  00292	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00295	83 f8 08	 cmp	 eax, 8
  00298	72 0e		 jb	 SHORT $LN1652@Move_unche
  0029a	40		 inc	 eax
  0029b	8b cb		 mov	 ecx, ebx
  0029d	50		 push	 eax
  0029e	ff 33		 push	 DWORD PTR [ebx]
  002a0	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
  002a5	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
$LN1652@Move_unche:
  002a8	c7 46 30 07 00
	00 00		 mov	 DWORD PTR [esi+48], 7
  002af	83 7e 30 08	 cmp	 DWORD PTR [esi+48], 8
  002b3	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
  002ba	72 04		 jb	 SHORT $LN1742@Move_unche
  002bc	8b 03		 mov	 eax, DWORD PTR [ebx]
  002be	eb 02		 jmp	 SHORT $LN1743@Move_unche
$LN1742@Move_unche:
  002c0	8b c3		 mov	 eax, ebx
$LN1743@Move_unche:
  002c2	33 d2		 xor	 edx, edx
  002c4	51		 push	 ecx
  002c5	8b cb		 mov	 ecx, ebx
  002c7	66 89 10	 mov	 WORD PTR [eax], dx
  002ca	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN1646@Move_unche:
  002cf	0f b6 47 34	 movzx	 eax, BYTE PTR [edi+52]
  002d3	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$1$[ebp]
  002d6	88 46 34	 mov	 BYTE PTR [esi+52], al
  002d9	83 c1 68	 add	 ecx, 104		; 00000068H
  002dc	0f b6 47 35	 movzx	 eax, BYTE PTR [edi+53]
  002e0	88 46 35	 mov	 BYTE PTR [esi+53], al
  002e3	0f b6 47 36	 movzx	 eax, BYTE PTR [edi+54]
  002e7	88 46 36	 mov	 BYTE PTR [esi+54], al
  002ea	0f b6 47 37	 movzx	 eax, BYTE PTR [edi+55]
  002ee	88 46 37	 mov	 BYTE PTR [esi+55], al
  002f1	0f b6 47 38	 movzx	 eax, BYTE PTR [edi+56]
  002f5	88 46 38	 mov	 BYTE PTR [esi+56], al
  002f8	0f b6 47 39	 movzx	 eax, BYTE PTR [edi+57]
  002fc	88 46 39	 mov	 BYTE PTR [esi+57], al
  002ff	0f b6 47 3a	 movzx	 eax, BYTE PTR [edi+58]
  00303	88 46 3a	 mov	 BYTE PTR [esi+58], al
  00306	0f b6 47 3b	 movzx	 eax, BYTE PTR [edi+59]
  0030a	83 c7 68	 add	 edi, 104		; 00000068H
  0030d	88 46 3b	 mov	 BYTE PTR [esi+59], al
  00310	83 c6 68	 add	 esi, 104		; 00000068H
  00313	8b 45 f0	 mov	 eax, DWORD PTR tv5245[ebp]
  00316	03 c6		 add	 eax, esi
  00318	89 4d 08	 mov	 DWORD PTR __Dest$1$[ebp], ecx
  0031b	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0031e	74 0d		 je	 SHORT $LN1958@Move_unche

; 2580 : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00320	8b 45 f0	 mov	 eax, DWORD PTR tv5245[ebp]
  00323	e9 28 fd ff ff	 jmp	 $LL4@Move_unche
$LN1944@Move_unche:

; 2581 : 		*_Dest = _STD move(*_First);

  00328	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1962@Move_unche:
$LN1958@Move_unche:

; 2582 : 	return (_Dest);

  0032d	8b c1		 mov	 eax, ecx

; 2583 : 	}

  0032f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00332	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00339	59		 pop	 ecx
  0033a	5f		 pop	 edi
  0033b	5e		 pop	 esi
  0033c	5b		 pop	 ebx
  0033d	8b e5		 mov	 esp, ebp
  0033f	5d		 pop	 ebp
  00340	c3		 ret	 0
$LN1961@Move_unche:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__unwindfunclet$??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z$135:
  00006	e8 00 00 00 00	 call	 ___std_terminate
  0000b	c3		 ret	 0
__unwindfunclet$??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z$268:
  0000c	e8 00 00 00 00	 call	 ___std_terminate
  00011	c3		 ret	 0
__unwindfunclet$??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z$401:
  00012	e8 00 00 00 00	 call	 ___std_terminate
  00017	c3		 ret	 0
__ehhandler$??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z ENDP ; std::_Move_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@UFavoriteVolume@GostCrypt@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUFavoriteVolume@GostCrypt@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_move_cat@UFavoriteVolume@GostCrypt@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUFavoriteVolume@GostCrypt@@0@Z PROC ; std::_Ptr_move_cat<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume>, COMDAT

; 810  : 	return {};

  00000	32 c0		 xor	 al, al

; 811  : 	}

  00002	c3		 ret	 0
??$_Ptr_move_cat@UFavoriteVolume@GostCrypt@@U12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAUFavoriteVolume@GostCrypt@@0@Z ENDP ; std::_Ptr_move_cat<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z
_TEXT	SEGMENT
$T2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T3 = 8							; size = 4
__Next$ = 8						; size = 4
__Pnode$ = 12						; size = 4
__Prev$ = 12						; size = 4
_<_Val_0>$ = 16						; size = 4
??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z PROC ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Buynode<GostCrypt::FavoriteVolume const &>, COMDAT
; _this$ = ecx

; 831  : 		{	// allocate a node and set links and value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 832  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);

  0002b	ff 75 0c	 push	 DWORD PTR __Prev$[ebp]
  0002e	ff 75 08	 push	 DWORD PTR __Next$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Buynode0
  00036	8b f0		 mov	 esi, eax

; 833  : 
; 834  : 		_TRY_BEGIN

  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003f	89 75 0c	 mov	 DWORD PTR __Pnode$[ebp], esi

; 835  : 		this->_Getal().construct(

  00042	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00045	89 4d 08	 mov	 DWORD PTR $T3[ebp], ecx
  00048	89 4d ec	 mov	 DWORD PTR $T2[ebp], ecx
  0004b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0004f	85 c9		 test	 ecx, ecx
  00051	74 08		 je	 SHORT $LN36@Buynode
  00053	ff 75 10	 push	 DWORD PTR _<_Val_0>$[ebp]
  00056	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
$LN36@Buynode:

; 841  : 		_CATCH_END
; 842  : 
; 843  : 		return (_Pnode);

  0005b	8b c6		 mov	 eax, esi

; 844  : 		}

  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00060	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00067	59		 pop	 ecx
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 0c 00	 ret	 12			; 0000000cH
__catch$??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z$0:

; 836  : 			_STD addressof(this->_Myval(_Pnode)),
; 837  : 				_STD forward<_Valty>(_Val)...);
; 838  : 		_CATCH_ALL
; 839  : 		this->_Getal().deallocate(_Pnode, 1);

  00071	ff 75 0c	 push	 DWORD PTR __Pnode$[ebp]
  00074	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00079	83 c4 04	 add	 esp, 4

; 840  : 		_RERAISE;

  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN67@Buynode:
$LN66@Buynode:
  00085	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z$8:
  00000	8b 45 08	 mov	 eax, DWORD PTR $T3[ebp]
  00003	50		 push	 eax
  00004	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z ENDP ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Buynode<GostCrypt::FavoriteVolume const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABUFavoriteVolume@GostCrypt@@@std@@YAABUFavoriteVolume@GostCrypt@@ABU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUFavoriteVolume@GostCrypt@@@std@@YAABUFavoriteVolume@GostCrypt@@ABU12@@Z PROC ; std::forward<GostCrypt::FavoriteVolume const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUFavoriteVolume@GostCrypt@@@std@@YAABUFavoriteVolume@GostCrypt@@ABU12@@Z ENDP ; std::forward<GostCrypt::FavoriteVolume const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAUFavoriteVolume@GostCrypt@@@std@@YA$$QAUFavoriteVolume@GostCrypt@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUFavoriteVolume@GostCrypt@@@std@@YA$$QAUFavoriteVolume@GostCrypt@@AAU12@@Z PROC ; std::move<GostCrypt::FavoriteVolume &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUFavoriteVolume@GostCrypt@@@std@@YA$$QAUFavoriteVolume@GostCrypt@@AAU12@@Z ENDP ; std::move<GostCrypt::FavoriteVolume &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::construct<std::_List_node<GostCrypt::FavoriteVolume,void *> *,std::_List_node<GostCrypt::FavoriteVolume,void *> * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::construct<std::_List_node<GostCrypt::FavoriteVolume,void *> *,std::_List_node<GostCrypt::FavoriteVolume,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@_W@std@@YAPA_WAA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@_W@std@@YAPA_WAA_W@Z PROC			; std::addressof<wchar_t>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@_W@std@@YAPA_WAA_W@Z ENDP			; std::addressof<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z PROC	; std::pointer_traits<char *>::pointer_to, COMDAT

; 279  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ENDP	; std::pointer_traits<char *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PA_W@std@@SAPA_WAA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PA_W@std@@SAPA_WAA_W@Z PROC ; std::pointer_traits<wchar_t *>::pointer_to, COMDAT

; 279  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PA_W@std@@SAPA_WAA_W@Z ENDP ; std::pointer_traits<wchar_t *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAUFavoriteVolume@GostCrypt@@@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEPAUFavoriteVolume@GostCrypt@@PAU23@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUFavoriteVolume@GostCrypt@@@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEPAUFavoriteVolume@GostCrypt@@PAU23@00@Z PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Umove<GostCrypt::FavoriteVolume *>, COMDAT
; _this$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1659 : 		return (_Uninitialized_move(_First, _Last,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	51		 push	 ecx
  0000f	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00012	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00015	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00018	e8 00 00 00 00	 call	 ??$_Uninitialized_move_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
  0001d	83 c4 18	 add	 esp, 24			; 00000018H

; 1660 : 			_Ptr, this->_Getal()));
; 1661 : 		}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUFavoriteVolume@GostCrypt@@@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEPAUFavoriteVolume@GostCrypt@@PAU23@00@Z ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Umove<GostCrypt::FavoriteVolume *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 281  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0ABV?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0ABV?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::allocator<wchar_t> const &,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0ABV?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::allocator<wchar_t> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@_W@std@@YAPA_WPA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@_W@std@@YAPA_WPA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z PROC		; std::addressof<wchar_t *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z ENDP		; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 281  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1044 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1045 : 	_Pocca(_Left, _Right, _Tag);
; 1046 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1063 : 	typename _Alty::propagate_on_container_move_assignment _Tag;
; 1064 : 	_Pocma(_Left, _Right, _Tag);
; 1065 : 	}

  00000	c3		 ret	 0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 281  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1044 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1045 : 	_Pocca(_Left, _Right, _Tag);
; 1046 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1063 : 	typename _Alty::propagate_on_container_move_assignment _Tag;
; 1064 : 	_Pocma(_Left, _Right, _Tag);
; 1065 : 	}

  00000	c3		 ret	 0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAV?$allocator@_W@1@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAV?$allocator@_W@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@PAUFavoriteVolume@GostCrypt@@@std@@YAXPAUFavoriteVolume@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@PAUFavoriteVolume@GostCrypt@@@std@@YAXPAUFavoriteVolume@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<GostCrypt::FavoriteVolume>,GostCrypt::FavoriteVolume *>, COMDAT

; 1114 : 	{	// destroy [_First, _Last), choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 0f		 je	 SHORT $LN5@Destroy_ra
  0000f	90		 npad	 1
$LL6@Destroy_ra:
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  00017	83 c6 68	 add	 esi, 104		; 00000068H
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $LL6@Destroy_ra
$LN5@Destroy_ra:
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Destroy_range@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@PAUFavoriteVolume@GostCrypt@@@std@@YAXPAUFavoriteVolume@GostCrypt@@0AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<GostCrypt::FavoriteVolume>,GostCrypt::FavoriteVolume *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 281  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT

; 1044 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1045 : 	_Pocca(_Left, _Right, _Tag);
; 1046 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UFavoriteVolume@GostCrypt@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UFavoriteVolume@GostCrypt@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<GostCrypt::FavoriteVolume>, COMDAT
; _this$ = ecx

; 1002 : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1003 : 		_Mytraits::destroy(*this, _Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ

; 1004 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??$destroy@UFavoriteVolume@GostCrypt@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@UFavoriteVolume@GostCrypt@@@std@@YAPAUFavoriteVolume@GostCrypt@@AAU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UFavoriteVolume@GostCrypt@@@std@@YAPAUFavoriteVolume@GostCrypt@@AAU12@@Z PROC ; std::addressof<GostCrypt::FavoriteVolume>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UFavoriteVolume@GostCrypt@@@std@@YAPAUFavoriteVolume@GostCrypt@@AAU12@@Z ENDP ; std::addressof<GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<std::_List_node<GostCrypt::FavoriteVolume,void *> *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<std::_List_node<GostCrypt::FavoriteVolume,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@YAPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@YAPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<GostCrypt::FavoriteVolume,void *> *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@YAPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<GostCrypt::FavoriteVolume,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >, COMDAT
; _this$ = ecx

; 1202 : 		{	// assign [_First, _Last), input iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1203 : 		return (replace(begin(), end(), _First, _Last));

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	72 04		 jb	 SHORT $LN14@assign
  00009	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000b	eb 02		 jmp	 SHORT $LN15@assign
$LN14@assign:
  0000d	8b d1		 mov	 edx, ecx
$LN15@assign:
  0000f	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00012	03 c2		 add	 eax, edx
  00014	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00018	72 13		 jb	 SHORT $LN48@assign
  0001a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00022	50		 push	 eax
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace

; 1204 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8

; 1203 : 		return (replace(begin(), end(), _First, _Last));

$LN48@assign:
  0002d	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00030	8b d1		 mov	 edx, ecx
  00032	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace

; 1204 : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 398  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 399  : 		return (*(_Mybase *)this - _Right);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]

; 400  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ
_TEXT	SEGMENT
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 340  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 341  : 		}

  00002	c3		 ret	 0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 322  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 321  : 		: _Mybase(_Parg, _Pstring)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 323  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator!=<std::allocator<char>,std::allocator<char> >, COMDAT

; 1026 : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 1027 : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat, COMDAT
; _this$ = ecx

; 270  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==, COMDAT
; _this$ = ecx

; 220  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 221  : 		_Compat(_Right);
; 222  : 		return (_Ptr == _Right._Ptr);
; 223  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 209  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 210  : 		_Compat(_Right);
; 211  : 		return (_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]

; 212  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 68   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 69   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 70   : 		const auto _Contptr = _Mycont ? _Mycont->_Myptr() : 0;
; 71   : 		if (_Mycont == 0
; 72   : 			|| _Ptr == nullptr_t{}
; 73   : 			|| _Unfancy(_Ptr) < _Contptr
; 74   : 			|| _Contptr + _Mycont->_Mysize <= _Unfancy(_Ptr))
; 75   : 			{	// report error
; 76   : 			_DEBUG_ERROR("string iterator not dereferencable");
; 77   : 			_SCL_SECURE_OUT_OF_RANGE;
; 78   : 			}
; 79   : 
; 80   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 81   : 		_SCL_SECURE_VALIDATE(_Ptr != nullptr_t{});
; 82   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 83   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 84   : 		const auto _Contptr = _Mycont->_Myptr();
; 85   : 		_SCL_SECURE_VALIDATE_RANGE(_Contptr <= _Unfancy(_Ptr) && _Unfancy(_Ptr) < _Contptr + _Mycont->_Mysize);
; 86   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 87   : 
; 88   : 		_Analysis_assume_(_Ptr != nullptr_t{});
; 89   : 
; 90   : 		return (*_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 91   : 		}

  00002	c3		 ret	 0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 49   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 48   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 50   : 		this->_Adopt(_Pstring);
; 51   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >, COMDAT
; _this$ = ecx

; 1202 : 		{	// assign [_First, _Last), input iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1203 : 		return (replace(begin(), end(), _First, _Last));

  00003	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00007	72 04		 jb	 SHORT $LN14@assign
  00009	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000b	eb 02		 jmp	 SHORT $LN15@assign
$LN14@assign:
  0000d	8b d1		 mov	 edx, ecx
$LN15@assign:
  0000f	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00013	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00016	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00019	72 13		 jb	 SHORT $LN48@assign
  0001b	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00023	50		 push	 eax
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace

; 1204 : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8

; 1203 : 		return (replace(begin(), end(), _First, _Last));

$LN48@assign:
  0002e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00031	8b d1		 mov	 edx, ecx
  00033	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00036	50		 push	 eax
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace

; 1204 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator-, COMDAT
; _this$ = ecx

; 398  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 399  : 		return (*(_Mybase *)this - _Right);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	d1 f8		 sar	 eax, 1

; 400  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ
_TEXT	SEGMENT
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator*, COMDAT
; _this$ = ecx

; 340  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 341  : 		}

  00002	c3		 ret	 0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT
; _this$ = ecx

; 322  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 321  : 		: _Mybase(_Parg, _Pstring)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 323  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Compat, COMDAT
; _this$ = ecx

; 270  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator==, COMDAT
; _this$ = ecx

; 220  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 221  : 		_Compat(_Right);
; 222  : 		return (_Ptr == _Right._Ptr);
; 223  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator-, COMDAT
; _this$ = ecx

; 209  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 210  : 		_Compat(_Right);
; 211  : 		return (_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000a	d1 f8		 sar	 eax, 1

; 212  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator*, COMDAT
; _this$ = ecx

; 68   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 69   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 70   : 		const auto _Contptr = _Mycont ? _Mycont->_Myptr() : 0;
; 71   : 		if (_Mycont == 0
; 72   : 			|| _Ptr == nullptr_t{}
; 73   : 			|| _Unfancy(_Ptr) < _Contptr
; 74   : 			|| _Contptr + _Mycont->_Mysize <= _Unfancy(_Ptr))
; 75   : 			{	// report error
; 76   : 			_DEBUG_ERROR("string iterator not dereferencable");
; 77   : 			_SCL_SECURE_OUT_OF_RANGE;
; 78   : 			}
; 79   : 
; 80   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 81   : 		_SCL_SECURE_VALIDATE(_Ptr != nullptr_t{});
; 82   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 83   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 84   : 		const auto _Contptr = _Mycont->_Myptr();
; 85   : 		_SCL_SECURE_VALIDATE_RANGE(_Contptr <= _Unfancy(_Ptr) && _Unfancy(_Ptr) < _Contptr + _Mycont->_Mysize);
; 86   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 87   : 
; 88   : 		_Analysis_assume_(_Ptr != nullptr_t{});
; 89   : 
; 90   : 		return (*_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 91   : 		}

  00002	c3		 ret	 0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT
; _this$ = ecx

; 49   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 48   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 50   : 		this->_Adopt(_Pstring);
; 51   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 1026 : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 1027 : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUFavoriteVolume@GostCrypt@@@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEPAUFavoriteVolume@GostCrypt@@PAU23@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUFavoriteVolume@GostCrypt@@@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEPAUFavoriteVolume@GostCrypt@@PAU23@00@Z PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Ucopy<GostCrypt::FavoriteVolume *>, COMDAT
; _this$ = ecx

; 1651 : 		{	// copy initializing [_First, _Last), using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1652 : 		return (_Uninitialized_copy(_First, _Last,

  00006	51		 push	 ecx
  00007	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  0000b	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000e	51		 push	 ecx
  0000f	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00012	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00015	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00018	e8 00 00 00 00	 call	 ??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
  0001d	83 c4 18	 add	 esp, 24			; 00000018H

; 1653 : 			_Ptr, this->_Getal()));
; 1654 : 		}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAUFavoriteVolume@GostCrypt@@@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEPAUFavoriteVolume@GostCrypt@@PAU23@00@Z ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Ucopy<GostCrypt::FavoriteVolume *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_unchecked@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_unchecked@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00@Z PROC ; std::_Copy_unchecked<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>, COMDAT

; 2332 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2333 : 		// note: _Copy_unchecked is called directly elsewhere in the STL
; 2334 : 	return (_Copy_unchecked1(_First, _Last,

  00004	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  00008	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Copy_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>
  00019	83 c4 10	 add	 esp, 16			; 00000010H

; 2335 : 		_Dest, _Ptr_copy_cat(_First, _Dest)));
; 2336 : 	}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_unchecked@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00@Z ENDP ; std::_Copy_unchecked<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@UFavoriteVolume@GostCrypt@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@UFavoriteVolume@GostCrypt@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@0@Z PROC ; std::operator!=<std::allocator<GostCrypt::FavoriteVolume>,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT

; 1026 : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 1027 : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@UFavoriteVolume@GostCrypt@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<GostCrypt::FavoriteVolume>,std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume const &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN13@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z$2:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UFavoriteVolume@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@ABU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN13@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z$2:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UFavoriteVolume@GostCrypt@@AAU12@@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@AAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::construct<GostCrypt::FavoriteVolume,GostCrypt::FavoriteVolume &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@UFavoriteVolume@GostCrypt@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@UFavoriteVolume@GostCrypt@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@@Z PROC ; std::_Unfancy<GostCrypt::FavoriteVolume>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@UFavoriteVolume@GostCrypt@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@@Z ENDP ; std::_Unfancy<GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUFavoriteVolume@GostCrypt@@@std@@YAPBUFavoriteVolume@GostCrypt@@ABU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUFavoriteVolume@GostCrypt@@@std@@YAPBUFavoriteVolume@GostCrypt@@ABU12@@Z PROC ; std::addressof<GostCrypt::FavoriteVolume const >, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBUFavoriteVolume@GostCrypt@@@std@@YAPBUFavoriteVolume@GostCrypt@@ABU12@@Z ENDP ; std::addressof<GostCrypt::FavoriteVolume const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_unchecked@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_unchecked@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00@Z PROC ; std::_Move_unchecked<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>, COMDAT

; 2597 : 	{	// move [_First, _Last) to [_Dest, ...), choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2598 : 	return (_Move_unchecked1(_First, _Last,

  00004	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  00008	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>
  00019	83 c4 10	 add	 esp, 16			; 00000010H

; 2599 : 		_Dest, _Ptr_move_cat(_First, _Dest)));
; 2600 : 	}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Move_unchecked@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00@Z ENDP ; std::_Move_unchecked<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$_Insert@ABUFavoriteVolume@GostCrypt@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@ABUFavoriteVolume@GostCrypt@@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Insert@ABUFavoriteVolume@GostCrypt@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@ABUFavoriteVolume@GostCrypt@@@Z PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Insert<GostCrypt::FavoriteVolume const &>, COMDAT
; _this$ = ecx

; 1061 : 		{	// insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1062 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1063 : 		_Nodeptr _Newnode =
; 1064 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

  00004	8b 75 08	 mov	 esi, DWORD PTR __Where$[ebp]
  00007	57		 push	 edi
  00008	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
  0000b	8b f9		 mov	 edi, ecx
  0000d	ff 76 04	 push	 DWORD PTR [esi+4]
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Buynode<GostCrypt::FavoriteVolume const &>
  00016	8b d0		 mov	 edx, eax

; 1065 : 				_STD forward<_Valty>(_Val)...);
; 1066 : 		_Incsize(1);

  00018	b9 91 24 49 02	 mov	 ecx, 38347921		; 02492491H
  0001d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00020	2b c8		 sub	 ecx, eax
  00022	83 f9 01	 cmp	 ecx, 1
  00025	72 12		 jb	 SHORT $LN65@Insert
  00027	40		 inc	 eax
  00028	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1067 : 		this->_Prevnode(_Pnode) = _Newnode;

  0002b	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1068 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  0002e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	89 10		 mov	 DWORD PTR [eax], edx

; 1069 : 		}

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
$LN65@Insert:

; 1065 : 				_STD forward<_Valty>(_Val)...);
; 1066 : 		_Incsize(1);

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0003e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN67@Insert:
$LN64@Insert:
  00043	cc		 int	 3
??$_Insert@ABUFavoriteVolume@GostCrypt@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@ABUFavoriteVolume@GostCrypt@@@Z ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Insert<GostCrypt::FavoriteVolume const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >, COMDAT
; _this$ = ecx

; 124  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 123  : 		: _Mybase(_Pnode, _Plist)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 125  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ??1Finally831@?CA@??SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z@QAE@XZ
_TEXT	SEGMENT
??1Finally831@?CA@??SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z@QAE@XZ PROC ; `GostCrypt::SaveFavoriteVolumes'::`32'::Finally831::~Finally831, COMDAT
; _this$ = ecx

; 831  : 			finally_do ({ remove (GetConfigPath (GST_APPD_FILENAME_SYSTEM_FAVORITE_VOLUMES)); });

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@
  00005	e8 00 00 00 00	 call	 _GetConfigPath
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _remove
  00010	83 c4 08	 add	 esp, 8
  00013	c3		 ret	 0
??1Finally831@?CA@??SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z@QAE@XZ ENDP ; `GostCrypt::SaveFavoriteVolumes'::`32'::Finally831::~Finally831
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2327 : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 2328 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;

  0002d	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00030	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00037	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0003e	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00045	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00049	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00050	72 04		 jb	 SHORT $LN107@operator
  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	eb 02		 jmp	 SHORT $LN108@operator
$LN107@operator:
  00056	8b c6		 mov	 eax, esi
$LN108@operator:
  00058	33 c9		 xor	 ecx, ecx
  0005a	66 89 08	 mov	 WORD PTR [eax], cx

; 2332 : 	return (_Ans);

  0005d	8b 7d 0c	 mov	 edi, DWORD PTR __Left$[ebp]
  00060	89 4d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ecx
  00063	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  0006a	66 39 0f	 cmp	 WORD PTR [edi], cx
  0006d	74 14		 je	 SHORT $LN117@operator

; 2329 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());

$LN116@operator:
  0006f	8b cf		 mov	 ecx, edi
  00071	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
$LL190@operator:
  00074	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00077	83 c1 02	 add	 ecx, 2
  0007a	66 85 c0	 test	 ax, ax
  0007d	75 f5		 jne	 SHORT $LL190@operator
  0007f	2b ca		 sub	 ecx, edx
  00081	d1 f9		 sar	 ecx, 1
$LN117@operator:
  00083	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  00086	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  00089	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0008c	03 c1		 add	 eax, ecx
  0008e	3b d8		 cmp	 ebx, eax
  00090	77 28		 ja	 SHORT $LN176@operator
  00092	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  00095	74 23		 je	 SHORT $LN176@operator
  00097	6a 01		 push	 1
  00099	50		 push	 eax
  0009a	8b ce		 mov	 ecx, esi
  0009c	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
  000a1	84 c0		 test	 al, al
  000a3	74 15		 je	 SHORT $LN176@operator
  000a5	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000a9	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000ac	72 04		 jb	 SHORT $LN171@operator
  000ae	8b 06		 mov	 eax, DWORD PTR [esi]
  000b0	eb 02		 jmp	 SHORT $LN172@operator
$LN171@operator:
  000b2	8b c6		 mov	 eax, esi
$LN172@operator:
  000b4	33 c9		 xor	 ecx, ecx
  000b6	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx
$LN176@operator:

; 2330 : 	_Ans += _Left;

  000ba	66 83 3f 00	 cmp	 WORD PTR [edi], 0
  000be	75 04		 jne	 SHORT $LN184@operator
  000c0	33 c9		 xor	 ecx, ecx
  000c2	eb 1b		 jmp	 SHORT $LN185@operator
$LN184@operator:
  000c4	8b cf		 mov	 ecx, edi
  000c6	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  000c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL191@operator:
  000d0	66 8b 01	 mov	 ax, WORD PTR [ecx]
  000d3	83 c1 02	 add	 ecx, 2
  000d6	66 85 c0	 test	 ax, ax
  000d9	75 f5		 jne	 SHORT $LL191@operator
  000db	2b ca		 sub	 ecx, edx
  000dd	d1 f9		 sar	 ecx, 1
$LN185@operator:
  000df	51		 push	 ecx
  000e0	57		 push	 edi
  000e1	8b ce		 mov	 ecx, esi
  000e3	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 2331 : 	_Ans += _Right;

  000e8	6a ff		 push	 -1
  000ea	6a 00		 push	 0
  000ec	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  000ef	8b ce		 mov	 ecx, esi
  000f1	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 2332 : 	return (_Ans);

  000f6	8b c6		 mov	 eax, esi

; 2333 : 	}

  000f8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000fb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00102	59		 pop	 ecx
  00103	5f		 pop	 edi
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx
  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN4@operator:
  00018	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W$$QAV10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W$$QAV10@@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2417 : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2418 : 	return (_STD move(_Right.insert(0, _Left)));

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Left$[ebp]
  00007	56		 push	 esi
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000f	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  00013	75 04		 jne	 SHORT $LN9@operator
  00015	33 c0		 xor	 eax, eax
  00017	eb 16		 jmp	 SHORT $LN10@operator
$LN9@operator:
  00019	8b c2		 mov	 eax, edx
  0001b	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  0001e	66 90		 npad	 2
$LL141@operator:
  00020	66 8b 08	 mov	 cx, WORD PTR [eax]
  00023	83 c0 02	 add	 eax, 2
  00026	66 85 c9	 test	 cx, cx
  00029	75 f5		 jne	 SHORT $LL141@operator
  0002b	2b c6		 sub	 eax, esi
  0002d	d1 f8		 sar	 eax, 1
$LN10@operator:
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  00032	50		 push	 eax
  00033	52		 push	 edx
  00034	6a 00		 push	 0
  00036	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
  0003b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0003e	33 c9		 xor	 ecx, ecx
  00040	50		 push	 eax
  00041	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00048	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004f	66 89 0e	 mov	 WORD PTR [esi], cx
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi

; 2419 : 	}

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W$$QAV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$GetContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@@Z
_TEXT	SEGMENT
_forEachContainer$ = 8					; size = 4
___formal$ = 12						; size = 4
??$GetContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@@Z PROC ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT

; 95   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 96   : 			return static_cast <const ContainerForward <T> &> (forEachContainer);

  00003	8b 45 08	 mov	 eax, DWORD PTR _forEachContainer$[ebp]

; 97   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$GetContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@@Z ENDP ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$?BV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@12@XZ PROC ; GostCrypt::ForEach::TypeWrapperDummy::operator<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > > GostCrypt::ForEach::TypeWrapper<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT
; _this$ = ecx

; 90   : 			operator TypeWrapper <T> () const { return TypeWrapper <T> (); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
??$?BV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@12@XZ ENDP ; GostCrypt::ForEach::TypeWrapperDummy::operator<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > > GostCrypt::ForEach::TypeWrapper<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$ToTypeWrapper@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
_x$ = 8							; size = 4
??$ToTypeWrapper@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z PROC ; GostCrypt::ForEach::ToTypeWrapper<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT

; 85   : 		static TypeWrapper <T> ToTypeWrapper (const T &x) { return TypeWrapper <T> (); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8a 45 ff	 mov	 al, BYTE PTR $T1[ebp]
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$ToTypeWrapper@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ENDP ; GostCrypt::ForEach::ToTypeWrapper<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z PROC ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx
  00007	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0000a	e8 00 00 00 00	 call	 ?clear@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::clear
  0000f	ff 77 08	 push	 DWORD PTR [edi+8]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
  0001a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00020	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00024	74 0b		 je	 SHORT $LN84@scalar
  00026	6a 18		 push	 24			; 00000018H
  00028	57		 push	 edi
  00029	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002e	83 c4 08	 add	 esp, 8
$LN84@scalar:
  00031	8b c7		 mov	 eax, edi
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??_G?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z ENDP ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
_TEXT	SEGMENT
??1?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ PROC ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::~ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
  00004	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00007	e8 00 00 00 00	 call	 ?clear@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::clear
  0000c	ff 77 08	 push	 DWORD PTR [edi+8]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	83 c4 04	 add	 esp, 4
  00017	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	c3		 ret	 0
??1?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ ENDP ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::~ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::operator!=, COMDAT
; _this$ = ecx

; 305  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 95 c0	 setne	 al

; 306  : 		return (!(*this == _Right));
; 307  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::operator==, COMDAT
; _this$ = ecx

; 289  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 290  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 291  : 		if (this->_Getcont() != _Right._Getcont())
; 292  : 			{	// report error
; 293  : 			_DEBUG_ERROR("list iterators incompatible");
; 294  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 295  : 			}
; 296  : 
; 297  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 298  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 299  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 300  : 
; 301  : 		return (this->_Ptr == _Right._Ptr);
; 302  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??F?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::operator--, COMDAT
; _this$ = ecx

; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 259  : 		if (_Mycont == 0
; 260  : 			|| this->_Ptr == nullptr_t{}
; 261  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr)) == _Mycont->_Myhead)
; 262  : 			{	// report error
; 263  : 			_DEBUG_ERROR("list iterator not decrementable");
; 264  : 			_SCL_SECURE_OUT_OF_RANGE;
; 265  : 			}
; 266  : 
; 267  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 268  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 269  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 270  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 271  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 272  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 273  : 
; 274  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 275  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00005	89 01		 mov	 DWORD PTR [ecx], eax

; 276  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 277  : 
; 278  : 		return (*this);

  00007	8b c1		 mov	 eax, ecx

; 279  : 		}

  00009	c3		 ret	 0
??F?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::operator++, COMDAT
; _this$ = ecx

; 227  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 228  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 229  : 		if (_Mycont == 0
; 230  : 			|| this->_Ptr == nullptr_t{}
; 231  : 			|| this->_Ptr == _Mycont->_Myhead)
; 232  : 			{	// report error
; 233  : 			_DEBUG_ERROR("list iterator not incrementable");
; 234  : 			_SCL_SECURE_OUT_OF_RANGE;
; 235  : 			}
; 236  : 
; 237  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 238  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 239  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 240  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 241  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 242  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 243  : 
; 244  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 245  : 		return (*this);

  00006	8b c1		 mov	 eax, ecx

; 246  : 		}

  00008	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABUFavoriteVolume@GostCrypt@@XZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABUFavoriteVolume@GostCrypt@@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::operator*, COMDAT
; _this$ = ecx

; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 207  : 		if (_Mycont == 0
; 208  : 			|| this->_Ptr == nullptr_t{}
; 209  : 			|| this->_Ptr == _Mycont->_Myhead)
; 210  : 			{	// report error
; 211  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 212  : 			_SCL_SECURE_OUT_OF_RANGE;
; 213  : 			}
; 214  : 
; 215  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 216  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 217  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 218  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 219  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 220  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 221  : 
; 222  : 		return (_Mylist::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 223  : 		}

  00005	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABUFavoriteVolume@GostCrypt@@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Unchecked@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::_Unchecked, COMDAT
; _this$ = ecx

; 199  : 		{	// make an unchecked iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 200  : 		return (_Unchecked_type(this->_Ptr, static_cast<const _Mylist *>(this->_Getcont())));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Unchecked@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >, COMDAT
; _this$ = ecx

; 187  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 186  : 		: _Mybase(_Pnode, _Plist)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 188  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 96   : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 97   : 		}

  00002	c3		 ret	 0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00005	89 01		 mov	 DWORD PTR [ecx], eax

; 74   : 		return (*this);

  00007	8b c1		 mov	 eax, ecx

; 75   : 		}

  00009	c3		 ret	 0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		: _Ptr(_Pnode)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?Next@?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ
_TEXT	SEGMENT
?Next@?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ PROC ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::Next, COMDAT
; _this$ = ecx

; 39   : 			virtual void Next () const { ++Iterator; }

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]
  00005	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00008	c3		 ret	 0
?Next@?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ ENDP ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::Next
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?IsNotEnd@?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ
_TEXT	SEGMENT
?IsNotEnd@?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ PROC ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::IsNotEnd, COMDAT
; _this$ = ecx

; 38   : 			virtual bool IsNotEnd () const { bool r = InnerContinue && Iterator != EndIterator; InnerContinue = false; return r; }

  00000	80 79 04 00	 cmp	 BYTE PTR [ecx+4], 0
  00004	74 0f		 je	 SHORT $LN3@IsNotEnd
  00006	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00009	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  0000c	74 07		 je	 SHORT $LN3@IsNotEnd
  0000e	b0 01		 mov	 al, 1
  00010	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00014	c3		 ret	 0
$LN3@IsNotEnd:
  00015	32 c0		 xor	 al, al
  00017	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0001a	c3		 ret	 0
?IsNotEnd@?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ ENDP ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::IsNotEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??0?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_container$ = 8						; size = 4
??0?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z PROC ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT
; _this$ = ecx

; 36   : 				: ContainerCopy (container), EndIterator (ContainerCopy.end()), Iterator (ContainerCopy.begin()) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002a	66 c7 47 04 01
	00		 mov	 WORD PTR [edi+4], 1
  00030	ff 75 08	 push	 DWORD PTR _container$[ebp]
  00033	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@
  00043	e8 00 00 00 00	 call	 ??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >
  00048	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0004b	89 47 10	 mov	 DWORD PTR [edi+16], eax
  0004e	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 47 14	 mov	 DWORD PTR [edi+20], eax
  00056	8b c7		 mov	 eax, edi
  00058	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00062	59		 pop	 ecx
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Container@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::Container::~Container
__ehhandler$??0?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ENDP ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::ContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$GetContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_container$ = 12					; size = 4
??$GetContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z PROC ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT

; 69   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$GetContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 70   : 			return ContainerForward <T> (container);

  00025	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00028	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0002f	66 c7 47 04 01
	00		 mov	 WORD PTR [edi+4], 1
  00035	ff 75 0c	 push	 DWORD PTR _container$[ebp]
  00038	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@
  00048	e8 00 00 00 00	 call	 ??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >
  0004d	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00050	8b c7		 mov	 eax, edi
  00052	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  00055	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00058	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0005a	89 4f 14	 mov	 DWORD PTR [edi+20], ecx

; 71   : 		}

  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00060	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00067	59		 pop	 ecx
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z$1:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Container@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::Container::~Container
__ehhandler$??$GetContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$GetContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$GetContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ENDP ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2459 : 	{	// test for string equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2460 : 	return (_Left.compare(_Right) == 0);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0000c	8d 71 10	 lea	 esi, DWORD PTR [ecx+16]
  0000f	72 02		 jb	 SHORT $LN25@operator
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN25@operator:
  00013	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  00016	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  0001a	8d 7a 10	 lea	 edi, DWORD PTR [edx+16]
  0001d	72 02		 jb	 SHORT $LN48@operator
  0001f	8b 12		 mov	 edx, DWORD PTR [edx]
$LN48@operator:
  00021	8b 36		 mov	 esi, DWORD PTR [esi]
  00023	8b c6		 mov	 eax, esi
  00025	8b 3f		 mov	 edi, DWORD PTR [edi]
  00027	3b fe		 cmp	 edi, esi
  00029	0f 42 c7	 cmovb	 eax, edi
  0002c	50		 push	 eax
  0002d	51		 push	 ecx
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	85 c0		 test	 eax, eax
  00039	75 16		 jne	 SHORT $LN57@operator
  0003b	3b f7		 cmp	 esi, edi
  0003d	76 0c		 jbe	 SHORT $LN58@operator
  0003f	83 c8 ff	 or	 eax, -1
  00042	85 c0		 test	 eax, eax
  00044	5f		 pop	 edi
  00045	0f 94 c0	 sete	 al
  00048	5e		 pop	 esi

; 2461 : 	}

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN58@operator:

; 2460 : 	return (_Left.compare(_Right) == 0);

  0004b	1b c0		 sbb	 eax, eax
  0004d	f7 d8		 neg	 eax
  0004f	85 c0		 test	 eax, eax
$LN57@operator:
  00051	5f		 pop	 edi
  00052	0f 94 c0	 sete	 al
  00055	5e		 pop	 esi

; 2461 : 	}

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@ABV10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@ABV10@@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2393 : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2394 : 	return (_STD move(_Left.append(_Right)));

  00004	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00007	56		 push	 esi
  00008	6a ff		 push	 -1
  0000a	6a 00		 push	 0
  0000c	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00016	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  0001b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	33 c9		 xor	 ecx, ecx
  00020	50		 push	 eax
  00021	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00028	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002f	66 89 0e	 mov	 WORD PTR [esi], cx
  00032	8b ce		 mov	 ecx, esi
  00034	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  00039	8b c6		 mov	 eax, esi
  0003b	5e		 pop	 esi

; 2395 : 	}

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@ABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@0@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2403 : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2404 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2405 : 		|| _Right.capacity() - _Right.size() < _Left.size())

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Left$[ebp]
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	56		 push	 esi
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00015	8b 72 10	 mov	 esi, DWORD PTR [edx+16]
  00018	2b c6		 sub	 eax, esi
  0001a	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  0001d	76 18		 jbe	 SHORT $LN4@operator
  0001f	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00022	2b 41 10	 sub	 eax, DWORD PTR [ecx+16]
  00025	3b c6		 cmp	 eax, esi
  00027	72 0e		 jb	 SHORT $LN4@operator

; 2407 : 	else
; 2408 : 		return (_STD move(_Right.insert(0, _Left)));

  00029	6a ff		 push	 -1
  0002b	6a 00		 push	 0
  0002d	52		 push	 edx
  0002e	6a 00		 push	 0
  00030	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
  00035	eb 0c		 jmp	 SHORT $LN344@operator
$LN4@operator:

; 2406 : 		return (_STD move(_Left.append(_Right)));

  00037	6a ff		 push	 -1
  00039	6a 00		 push	 0
  0003b	51		 push	 ecx
  0003c	8b ca		 mov	 ecx, edx
  0003e	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN344@operator:
  00043	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00046	33 c9		 xor	 ecx, ecx
  00048	50		 push	 eax
  00049	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00050	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00057	66 89 0e	 mov	 WORD PTR [esi], cx
  0005a	8b ce		 mov	 ecx, esi
  0005c	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  00061	8b c6		 mov	 eax, esi
  00063	5e		 pop	 esi

; 2409 : 	}

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@0@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2355 : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 2356 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;

  0002d	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00030	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00037	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0003e	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00045	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00049	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00050	72 04		 jb	 SHORT $LN107@operator
  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	eb 02		 jmp	 SHORT $LN108@operator
$LN107@operator:
  00056	8b c6		 mov	 eax, esi
$LN108@operator:
  00058	33 c9		 xor	 ecx, ecx
  0005a	66 89 08	 mov	 WORD PTR [eax], cx

; 2360 : 	return (_Ans);

  0005d	8b 7d 10	 mov	 edi, DWORD PTR __Right$[ebp]
  00060	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00063	89 4d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ecx
  00066	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  0006d	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  00070	66 39 0f	 cmp	 WORD PTR [edi], cx
  00073	74 1a		 je	 SHORT $LN129@operator

; 2357 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));

$LN128@operator:
  00075	8b cf		 mov	 ecx, edi
  00077	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL190@operator:
  00080	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00083	83 c1 02	 add	 ecx, 2
  00086	66 85 c0	 test	 ax, ax
  00089	75 f5		 jne	 SHORT $LL190@operator
  0008b	2b ca		 sub	 ecx, edx
  0008d	d1 f9		 sar	 ecx, 1
$LN129@operator:
  0008f	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00092	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  00095	3b d8		 cmp	 ebx, eax
  00097	77 28		 ja	 SHORT $LN176@operator
  00099	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  0009c	74 23		 je	 SHORT $LN176@operator
  0009e	6a 01		 push	 1
  000a0	50		 push	 eax
  000a1	8b ce		 mov	 ecx, esi
  000a3	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
  000a8	84 c0		 test	 al, al
  000aa	74 15		 je	 SHORT $LN176@operator
  000ac	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000b0	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000b3	72 04		 jb	 SHORT $LN171@operator
  000b5	8b 06		 mov	 eax, DWORD PTR [esi]
  000b7	eb 02		 jmp	 SHORT $LN172@operator
$LN171@operator:
  000b9	8b c6		 mov	 eax, esi
$LN172@operator:
  000bb	33 c9		 xor	 ecx, ecx
  000bd	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx
$LN176@operator:

; 2358 : 	_Ans += _Left;

  000c1	6a ff		 push	 -1
  000c3	6a 00		 push	 0
  000c5	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  000c8	8b ce		 mov	 ecx, esi
  000ca	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 2359 : 	_Ans += _Right;

  000cf	66 83 3f 00	 cmp	 WORD PTR [edi], 0
  000d3	75 04		 jne	 SHORT $LN188@operator
  000d5	33 c9		 xor	 ecx, ecx
  000d7	eb 16		 jmp	 SHORT $LN189@operator
$LN188@operator:
  000d9	8b cf		 mov	 ecx, edi
  000db	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  000de	66 90		 npad	 2
$LL191@operator:
  000e0	66 8b 01	 mov	 ax, WORD PTR [ecx]
  000e3	83 c1 02	 add	 ecx, 2
  000e6	66 85 c0	 test	 ax, ax
  000e9	75 f5		 jne	 SHORT $LL191@operator
  000eb	2b ca		 sub	 ecx, edx
  000ed	d1 f9		 sar	 ecx, 1
$LN189@operator:
  000ef	51		 push	 ecx
  000f0	57		 push	 edi
  000f1	8b ce		 mov	 ecx, esi
  000f3	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 2360 : 	return (_Ans);

  000f8	8b c6		 mov	 eax, esi

; 2361 : 	}

  000fa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00104	59		 pop	 ecx
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN4@operator:
  00018	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2439 : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2440 : 	return (_STD move(_Left.append(_Right)));

  00004	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000f	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  00013	75 04		 jne	 SHORT $LN9@operator
  00015	33 c0		 xor	 eax, eax
  00017	eb 16		 jmp	 SHORT $LN10@operator
$LN9@operator:
  00019	8b c2		 mov	 eax, edx
  0001b	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  0001e	66 90		 npad	 2
$LL141@operator:
  00020	66 8b 08	 mov	 cx, WORD PTR [eax]
  00023	83 c0 02	 add	 eax, 2
  00026	66 85 c9	 test	 cx, cx
  00029	75 f5		 jne	 SHORT $LL141@operator
  0002b	2b c6		 sub	 eax, esi
  0002d	d1 f8		 sar	 eax, 1
$LN10@operator:
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00032	50		 push	 eax
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00039	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0003c	33 c9		 xor	 ecx, ecx
  0003e	50		 push	 eax
  0003f	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00046	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004d	66 89 0e	 mov	 WORD PTR [esi], cx
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi

; 2441 : 	}

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::operator+, COMDAT
; _this$ = ecx

; 372  : 		{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 373  : 		_Myiter _Tmp = *this;
; 374  : 		return (_Tmp += _Off);

  00003	6b 55 0c 68	 imul	 edx, DWORD PTR __Off$[ebp], 104
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	03 11		 add	 edx, DWORD PTR [ecx]
  0000c	89 10		 mov	 DWORD PTR [eax], edx

; 375  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::operator+=, COMDAT
; _this$ = ecx

; 366  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 367  : 		*(_Mybase *)this += _Off;

  00003	6b 45 08 68	 imul	 eax, DWORD PTR __Off$[ebp], 104
  00007	01 01		 add	 DWORD PTR [ecx], eax

; 368  : 		return (*this);

  00009	8b c1		 mov	 eax, ecx

; 369  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@PAUFavoriteVolume@GostCrypt@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@PAUFavoriteVolume@GostCrypt@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >, COMDAT
; _this$ = ecx

; 313  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 312  : 		: _Mybase(_Parg, _Pvector)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 314  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@PAUFavoriteVolume@GostCrypt@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$swap@UFavoriteVolume@GostCrypt@@X@std@@YAXAAUFavoriteVolume@GostCrypt@@0@Z
_TEXT	SEGMENT
__Tmp$ = -108						; size = 104
__$ArrayPad$ = -4					; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UFavoriteVolume@GostCrypt@@X@std@@YAXAAUFavoriteVolume@GostCrypt@@0@Z PROC ; std::swap<GostCrypt::FavoriteVolume,void>, COMDAT

; 48   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR __Left$[ebp]

; 49   : 	_Ty _Tmp = _STD move(_Left);

  00014	8d 4d 94	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR __Right$[ebp]
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@$$QAU01@@Z

; 50   : 	_Left = _STD move(_Right);

  00021	57		 push	 edi
  00022	8b ce		 mov	 ecx, esi
  00024	e8 00 00 00 00	 call	 ??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z

; 51   : 	_Right = _STD move(_Tmp);

  00029	8d 45 94	 lea	 eax, DWORD PTR __Tmp$[ebp]
  0002c	8b cf		 mov	 ecx, edi
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z

; 52   : 	}

  00034	8d 4d 94	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00037	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003f	5f		 pop	 edi
  00040	33 cd		 xor	 ecx, ebp
  00042	5e		 pop	 esi
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
??$swap@UFavoriteVolume@GostCrypt@@X@std@@YAXAAUFavoriteVolume@GostCrypt@@0@Z ENDP ; std::swap<GostCrypt::FavoriteVolume,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@@Z
_TEXT	SEGMENT
_forEachContainer$ = 8					; size = 4
___formal$ = 12						; size = 4
??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@@Z PROC ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT

; 95   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 96   : 			return static_cast <const ContainerForward <T> &> (forEachContainer);

  00003	8b 45 08	 mov	 eax, DWORD PTR _forEachContainer$[ebp]

; 97   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@@Z ENDP ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$?BV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@12@XZ PROC ; GostCrypt::ForEach::TypeWrapperDummy::operator<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > > GostCrypt::ForEach::TypeWrapper<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT
; _this$ = ecx

; 90   : 			operator TypeWrapper <T> () const { return TypeWrapper <T> (); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
??$?BV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@12@XZ ENDP ; GostCrypt::ForEach::TypeWrapperDummy::operator<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > > GostCrypt::ForEach::TypeWrapper<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$ToTypeWrapper@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
_x$ = 8							; size = 4
??$ToTypeWrapper@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z PROC ; GostCrypt::ForEach::ToTypeWrapper<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT

; 85   : 		static TypeWrapper <T> ToTypeWrapper (const T &x) { return TypeWrapper <T> (); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8a 45 ff	 mov	 al, BYTE PTR $T1[ebp]
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$ToTypeWrapper@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ENDP ; GostCrypt::ForEach::ToTypeWrapper<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z PROC ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00009	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Tidy
  0000e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00018	74 0b		 je	 SHORT $LN13@scalar
  0001a	6a 1c		 push	 28			; 0000001cH
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??_G?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
_TEXT	SEGMENT
??1?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ PROC ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::~ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00006	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Tidy
  0000b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00011	5e		 pop	 esi
  00012	c3		 ret	 0
??1?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::~ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::_Compat, COMDAT
; _this$ = ecx

; 262  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::operator!=, COMDAT
; _this$ = ecx

; 218  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 95 c0	 setne	 al

; 219  : 		return (!(*this == _Right));
; 220  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::operator==, COMDAT
; _this$ = ecx

; 212  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 213  : 		_Compat(_Right);
; 214  : 		return (_Ptr == _Right._Ptr);
; 215  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::operator+=, COMDAT
; _this$ = ecx

; 155  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 156  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 157  : 		if (_Off != 0)
; 158  : 			{
; 159  : 			const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 160  : 			if (_Mycont == 0
; 161  : 				|| _Ptr + _Off < _Mycont->_Myfirst
; 162  : 				|| _Mycont->_Mylast < _Ptr + _Off)
; 163  : 				{
; 164  : 				_DEBUG_ERROR("vector iterator + offset out of range");
; 165  : 				_SCL_SECURE_OUT_OF_RANGE;
; 166  : 				}
; 167  : 			}
; 168  : 
; 169  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 170  : 		if (_Off != 0)
; 171  : 			{
; 172  : 			const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 173  : 			_SCL_SECURE_VALIDATE(_Mycont != 0);
; 174  : 			_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr + _Off
; 175  : 				&& _Ptr + _Off <= _Mycont->_Mylast);
; 176  : 			}
; 177  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 178  : 
; 179  : 		_Ptr += _Off;

  00003	6b 45 08 68	 imul	 eax, DWORD PTR __Off$[ebp], 104
  00007	01 01		 add	 DWORD PTR [ecx], eax

; 180  : 		return (*this);

  00009	8b c1		 mov	 eax, ecx

; 181  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 98   : 		if (_Mycont == 0
; 99   : 			|| _Ptr == nullptr_t{}
; 100  : 			|| _Mycont->_Mylast <= _Ptr)
; 101  : 			{	// report error
; 102  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 103  : 			_SCL_SECURE_OUT_OF_RANGE;
; 104  : 			}
; 105  : 
; 106  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 107  : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 108  : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 109  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 110  : 		_SCL_SECURE_VALIDATE_RANGE(_Ptr < _Mycont->_Mylast);
; 111  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 112  : 
; 113  : 		++_Ptr;

  00000	83 01 68	 add	 DWORD PTR [ecx], 104	; 00000068H

; 114  : 		return (*this);

  00003	8b c1		 mov	 eax, ecx

; 115  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABUFavoriteVolume@GostCrypt@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABUFavoriteVolume@GostCrypt@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 68   : 		if (_Mycont == 0
; 69   : 			|| _Ptr == _Tptr()
; 70   : 			|| _Ptr < _Mycont->_Myfirst
; 71   : 			|| _Mycont->_Mylast <= _Ptr)
; 72   : 			{	// report error
; 73   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 74   : 			_SCL_SECURE_OUT_OF_RANGE;
; 75   : 			}
; 76   : 
; 77   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 78   : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 79   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 80   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 81   : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 87   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABUFavoriteVolume@GostCrypt@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEPBUFavoriteVolume@GostCrypt@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEPBUFavoriteVolume@GostCrypt@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::_Unchecked, COMDAT
; _this$ = ecx

; 61   : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 62   : 		}

  00002	c3		 ret	 0
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEPBUFavoriteVolume@GostCrypt@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@PAUFavoriteVolume@GostCrypt@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@PAUFavoriteVolume@GostCrypt@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 46   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@PAUFavoriteVolume@GostCrypt@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?Next@?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ
_TEXT	SEGMENT
?Next@?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ PROC ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::Next, COMDAT
; _this$ = ecx

; 39   : 			virtual void Next () const { ++Iterator; }

  00000	83 41 18 68	 add	 DWORD PTR [ecx+24], 104	; 00000068H
  00004	c3		 ret	 0
?Next@?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::Next
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?IsNotEnd@?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ
_TEXT	SEGMENT
?IsNotEnd@?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ PROC ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::IsNotEnd, COMDAT
; _this$ = ecx

; 38   : 			virtual bool IsNotEnd () const { bool r = InnerContinue && Iterator != EndIterator; InnerContinue = false; return r; }

  00000	80 79 04 00	 cmp	 BYTE PTR [ecx+4], 0
  00004	74 0f		 je	 SHORT $LN3@IsNotEnd
  00006	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00009	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  0000c	74 07		 je	 SHORT $LN3@IsNotEnd
  0000e	b0 01		 mov	 al, 1
  00010	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00014	c3		 ret	 0
$LN3@IsNotEnd:
  00015	32 c0		 xor	 al, al
  00017	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0001a	c3		 ret	 0
?IsNotEnd@?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::IsNotEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??0?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_container$ = 8						; size = 4
??0?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z PROC ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT
; _this$ = ecx

; 36   : 				: ContainerCopy (container), EndIterator (ContainerCopy.end()), Iterator (ContainerCopy.begin()) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002a	66 c7 47 04 01
	00		 mov	 WORD PTR [edi+4], 1
  00030	ff 75 08	 push	 DWORD PTR _container$[ebp]
  00033	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@
  00043	e8 00 00 00 00	 call	 ??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >
  00048	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0004b	89 47 14	 mov	 DWORD PTR [edi+20], eax
  0004e	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00051	89 47 18	 mov	 DWORD PTR [edi+24], eax
  00054	8b c7		 mov	 eax, edi
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00060	59		 pop	 ecx
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Container@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::Container::~Container
__ehhandler$??0?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ENDP ; GostCrypt::ForEach::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::ContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_container$ = 12					; size = 4
??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z PROC ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT

; 69   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 70   : 			return ContainerForward <T> (container);

  00025	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00028	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0002f	66 c7 47 04 01
	00		 mov	 WORD PTR [edi+4], 1
  00035	ff 75 0c	 push	 DWORD PTR _container$[ebp]
  00038	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@
  00048	e8 00 00 00 00	 call	 ??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >
  0004d	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00050	8b c7		 mov	 eax, edi
  00052	89 4f 14	 mov	 DWORD PTR [edi+20], ecx
  00055	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00058	89 4f 18	 mov	 DWORD PTR [edi+24], ecx

; 71   : 		}

  0005b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00065	59		 pop	 ecx
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z$1:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Container@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::Container::~Container
__ehhandler$??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ENDP ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
; Function compile flags: /Ogtp
;	COMDAT ??__FFavorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@YAXXZ
text$yd	SEGMENT
??__FFavorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@YAXXZ PROC ; `GostCrypt::FavoriteVolumesDlgProc'::`2'::`dynamic atexit destructor for 'Favorites'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00005	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Tidy
??__FFavorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@YAXXZ ENDP ; `GostCrypt::FavoriteVolumesDlgProc'::`2'::`dynamic atexit destructor for 'Favorites''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2479 : 	{	// test for string vs. NTCS equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2480 : 	return (_Left.compare(_Right) == 0);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	80 3a 00	 cmp	 BYTE PTR [edx], 0
  0000b	75 04		 jne	 SHORT $LN7@operator
  0000d	33 f6		 xor	 esi, esi
  0000f	eb 0e		 jmp	 SHORT $LN8@operator
$LN7@operator:
  00011	8b f2		 mov	 esi, edx
  00013	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
$LL37@operator:
  00016	8a 06		 mov	 al, BYTE PTR [esi]
  00018	46		 inc	 esi
  00019	84 c0		 test	 al, al
  0001b	75 f9		 jne	 SHORT $LL37@operator
  0001d	2b f1		 sub	 esi, ecx
$LN8@operator:
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00022	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00026	8d 79 10	 lea	 edi, DWORD PTR [ecx+16]
  00029	72 02		 jb	 SHORT $LN28@operator
  0002b	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN28@operator:
  0002d	8b 3f		 mov	 edi, DWORD PTR [edi]
  0002f	8b c6		 mov	 eax, esi
  00031	3b fe		 cmp	 edi, esi
  00033	0f 42 c7	 cmovb	 eax, edi
  00036	50		 push	 eax
  00037	52		 push	 edx
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00041	85 c0		 test	 eax, eax
  00043	75 16		 jne	 SHORT $LN38@operator
  00045	3b f7		 cmp	 esi, edi
  00047	76 0c		 jbe	 SHORT $LN39@operator
  00049	83 c8 ff	 or	 eax, -1
  0004c	85 c0		 test	 eax, eax
  0004e	5f		 pop	 edi
  0004f	0f 94 c0	 sete	 al
  00052	5e		 pop	 esi

; 2481 : 	}

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN39@operator:

; 2480 : 	return (_Left.compare(_Right) == 0);

  00055	1b c0		 sbb	 eax, eax
  00057	f7 d8		 neg	 eax
  00059	85 c0		 test	 eax, eax
$LN38@operator:
  0005b	5f		 pop	 edi
  0005c	0f 94 c0	 sete	 al
  0005f	5e		 pop	 esi

; 2481 : 	}

  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FFavoritesMountedOnArrivalStillConnected@GostCrypt@@YAXXZ
text$yd	SEGMENT
??__FFavoritesMountedOnArrivalStillConnected@GostCrypt@@YAXXZ PROC ; GostCrypt::`dynamic atexit destructor for 'FavoritesMountedOnArrivalStillConnected'', COMDAT
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	8b 30		 mov	 esi, DWORD PTR [eax]
  00009	89 00		 mov	 DWORD PTR [eax], eax
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00010	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00013	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00019	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+4, 0
  00023	3b f3		 cmp	 esi, ebx
  00025	74 3a		 je	 SHORT $LN10@dynamic
  00027	57		 push	 edi
$LL11@dynamic:
  00028	8b 3e		 mov	 edi, DWORD PTR [esi]
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesMountedOnArrivalStillConnected
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<std::_List_node<GostCrypt::FavoriteVolume,void *> *>
  00035	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00038	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesMountedOnArrivalStillConnected
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<std::_List_node<GostCrypt::FavoriteVolume,void *> *>
  00043	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00046	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00051	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00057	83 c4 04	 add	 esp, 4
  0005a	8b f7		 mov	 esi, edi
  0005c	3b fb		 cmp	 edi, ebx
  0005e	75 c8		 jne	 SHORT $LL11@dynamic
  00060	5f		 pop	 edi
$LN10@dynamic:
  00061	53		 push	 ebx
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesMountedOnArrivalStillConnected
  00067	e8 00 00 00 00	 call	 ??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<std::_List_node<GostCrypt::FavoriteVolume,void *> *>
  0006c	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0006f	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesMountedOnArrivalStillConnected
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<std::_List_node<GostCrypt::FavoriteVolume,void *> *>
  0007a	53		 push	 ebx
  0007b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00080	83 c4 04	 add	 esp, 4
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	c3		 ret	 0
??__FFavoritesMountedOnArrivalStillConnected@GostCrypt@@YAXXZ ENDP ; GostCrypt::`dynamic atexit destructor for 'FavoritesMountedOnArrivalStillConnected''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ??__EFavoritesMountedOnArrivalStillConnected@GostCrypt@@YAXXZ
text$di	SEGMENT
??__EFavoritesMountedOnArrivalStillConnected@GostCrypt@@YAXXZ PROC ; GostCrypt::`dynamic initializer for 'FavoritesMountedOnArrivalStillConnected'', COMDAT

; 36   : 	list <FavoriteVolume> FavoritesMountedOnArrivalStillConnected;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesMountedOnArrivalStillConnected
  00005	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >
  0000a	6a 00		 push	 0
  0000c	6a 00		 push	 0
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesMountedOnArrivalStillConnected
  00013	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A, 0
  0001d	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+4, 0
  00027	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Buynode0
  0002c	68 00 00 00 00	 push	 OFFSET ??__FFavoritesMountedOnArrivalStillConnected@GostCrypt@@YAXXZ ; GostCrypt::`dynamic atexit destructor for 'FavoritesMountedOnArrivalStillConnected''
  00031	a3 00 00 00 00	 mov	 DWORD PTR ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A, eax
  00036	e8 00 00 00 00	 call	 _atexit
  0003b	59		 pop	 ecx
  0003c	c3		 ret	 0
??__EFavoritesMountedOnArrivalStillConnected@GostCrypt@@YAXXZ ENDP ; GostCrypt::`dynamic initializer for 'FavoritesMountedOnArrivalStillConnected''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FFavoritesOnArrivalMountRequired@GostCrypt@@YAXXZ
text$yd	SEGMENT
??__FFavoritesOnArrivalMountRequired@GostCrypt@@YAXXZ PROC ; GostCrypt::`dynamic atexit destructor for 'FavoritesOnArrivalMountRequired'', COMDAT
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	8b 30		 mov	 esi, DWORD PTR [eax]
  00009	89 00		 mov	 DWORD PTR [eax], eax
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00010	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00013	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00019	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+4, 0
  00023	3b f3		 cmp	 esi, ebx
  00025	74 3a		 je	 SHORT $LN10@dynamic
  00027	57		 push	 edi
$LL11@dynamic:
  00028	8b 3e		 mov	 edi, DWORD PTR [esi]
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesOnArrivalMountRequired
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 ??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<std::_List_node<GostCrypt::FavoriteVolume,void *> *>
  00035	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00038	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesOnArrivalMountRequired
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<std::_List_node<GostCrypt::FavoriteVolume,void *> *>
  00043	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00046	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00051	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00057	83 c4 04	 add	 esp, 4
  0005a	8b f7		 mov	 esi, edi
  0005c	3b fb		 cmp	 edi, ebx
  0005e	75 c8		 jne	 SHORT $LL11@dynamic
  00060	5f		 pop	 edi
$LN10@dynamic:
  00061	53		 push	 ebx
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesOnArrivalMountRequired
  00067	e8 00 00 00 00	 call	 ??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<std::_List_node<GostCrypt::FavoriteVolume,void *> *>
  0006c	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0006f	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesOnArrivalMountRequired
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ??$destroy@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::destroy<std::_List_node<GostCrypt::FavoriteVolume,void *> *>
  0007a	53		 push	 ebx
  0007b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00080	83 c4 04	 add	 esp, 4
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	c3		 ret	 0
??__FFavoritesOnArrivalMountRequired@GostCrypt@@YAXXZ ENDP ; GostCrypt::`dynamic atexit destructor for 'FavoritesOnArrivalMountRequired''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ??__EFavoritesOnArrivalMountRequired@GostCrypt@@YAXXZ
text$di	SEGMENT
??__EFavoritesOnArrivalMountRequired@GostCrypt@@YAXXZ PROC ; GostCrypt::`dynamic initializer for 'FavoritesOnArrivalMountRequired'', COMDAT

; 35   : 	list <FavoriteVolume> FavoritesOnArrivalMountRequired;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesOnArrivalMountRequired
  00005	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >
  0000a	6a 00		 push	 0
  0000c	6a 00		 push	 0
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesOnArrivalMountRequired
  00013	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A, 0
  0001d	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+4, 0
  00027	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Buynode0
  0002c	68 00 00 00 00	 push	 OFFSET ??__FFavoritesOnArrivalMountRequired@GostCrypt@@YAXXZ ; GostCrypt::`dynamic atexit destructor for 'FavoritesOnArrivalMountRequired''
  00031	a3 00 00 00 00	 mov	 DWORD PTR ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A, eax
  00036	e8 00 00 00 00	 call	 _atexit
  0003b	59		 pop	 ecx
  0003c	c3		 ret	 0
??__EFavoritesOnArrivalMountRequired@GostCrypt@@YAXXZ ENDP ; GostCrypt::`dynamic initializer for 'FavoritesOnArrivalMountRequired''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Incsize@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Incsize@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXI@Z PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Incsize, COMDAT
; _this$ = ecx

; 1906 : 		{	// alter element count, with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1907 : 		if (max_size() - this->_Mysize() - 1 < _Count)

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	b8 91 24 49 02	 mov	 eax, 38347921		; 02492491H
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  0000f	2b c2		 sub	 eax, edx
  00011	3b c6		 cmp	 eax, esi
  00013	72 0b		 jb	 SHORT $LN41@Incsize

; 1909 : 		this->_Mysize() += _Count;

  00015	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  00018	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0001b	5e		 pop	 esi

; 1910 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
$LN41@Incsize:

; 1908 : 			_Xlength_error("list<T> too long");

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00025	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN43@Incsize:
$LN40@Incsize:
  0002a	cc		 int	 3
?_Incsize@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXI@Z ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Incsize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Tidy@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Tidy, COMDAT
; _this$ = ecx

; 1884 : 		clear();

  00000	e9 00 00 00 00	 jmp	 ?clear@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::clear
?_Tidy@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?clear@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::clear, COMDAT
; _this$ = ecx

; 1500 : 		{	// erase all

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi

; 1501 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1502 : 
; 1503 : 		this->_Orphan_ptr(nullptr);
; 1504 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1505 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

  00004	8b 03		 mov	 eax, DWORD PTR [ebx]
  00006	8b 30		 mov	 esi, DWORD PTR [eax]

; 1506 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

  00008	89 00		 mov	 DWORD PTR [eax], eax

; 1507 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

  0000a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0000c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1508 : 		this->_Mysize() = 0;

  0000f	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1509 : 
; 1510 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

  00016	3b 33		 cmp	 esi, DWORD PTR [ebx]
  00018	74 20		 je	 SHORT $LN3@clear
  0001a	57		 push	 edi
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@clear:

; 1511 : 			{	// delete an element
; 1512 : 			_Pnext = this->_Nextnode(_Pnode);

  00020	8b 3e		 mov	 edi, DWORD PTR [esi]

; 1513 : 			this->_Freenode(_Pnode);

  00022	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00025	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00030	83 c4 04	 add	 esp, 4
  00033	8b f7		 mov	 esi, edi
  00035	3b 3b		 cmp	 edi, DWORD PTR [ebx]
  00037	75 e7		 jne	 SHORT $LL4@clear
  00039	5f		 pop	 edi
$LN3@clear:
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx

; 1514 : 			}
; 1515 : 		}

  0003c	c3		 ret	 0
?clear@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Unchecked_erase@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Unchecked_erase@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Unchecked_erase, COMDAT
; _this$ = ecx

; 1473 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1474 : 		_Nodeptr _Pnode = _Where._Mynode();

  00004	8b 75 08	 mov	 esi, DWORD PTR __Where$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 1475 : 
; 1476 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =

  0000a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]

; 1477 : 			this->_Nextnode(_Pnode);
; 1478 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1479 : 			this->_Prevnode(_Pnode);
; 1480 : 		this->_Freenode(_Pnode);

  0000d	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	89 02		 mov	 DWORD PTR [edx], eax
  00014	8b 16		 mov	 edx, DWORD PTR [esi]
  00016	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00019	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0001c	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00027	83 c4 04	 add	 esp, 4

; 1481 : 		--this->_Mysize();

  0002a	ff 4f 04	 dec	 DWORD PTR [edi+4]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi

; 1482 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?_Unchecked_erase@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?push_back@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::push_back, COMDAT
; _this$ = ecx

; 1292 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1293 : 		_Insert(_Unchecked_end(), _Val);

  00007	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0000a	8b 3e		 mov	 edi, DWORD PTR [esi]
  0000c	ff 77 04	 push	 DWORD PTR [edi+4]
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 ??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Buynode<GostCrypt::FavoriteVolume const &>
  00015	8b d0		 mov	 edx, eax
  00017	b9 91 24 49 02	 mov	 ecx, 38347921		; 02492491H
  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	2b c8		 sub	 ecx, eax
  00021	83 f9 01	 cmp	 ecx, 1
  00024	72 12		 jb	 SHORT $LN91@push_back
  00026	40		 inc	 eax
  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0002a	89 57 04	 mov	 DWORD PTR [edi+4], edx
  0002d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	89 10		 mov	 DWORD PTR [eax], edx

; 1294 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN91@push_back:

; 1293 : 		_Insert(_Unchecked_end(), _Val);

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0003d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN93@push_back:
$LN90@push_back:
  00042	cc		 int	 3
?push_back@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?max_size@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIXZ PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::max_size, COMDAT
; _this$ = ecx

; 1247 : 		return (this->_Getal().max_size());

  00000	b8 92 24 49 02	 mov	 eax, 38347922		; 02492492H

; 1248 : 		}

  00005	c3		 ret	 0
?max_size@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIXZ ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Make_iter@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@@Z PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Make_iter, COMDAT
; _this$ = ecx

; 1163 : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1164 : 		return (iterator(_Where._Ptr, &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1165 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@@Z ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Unchecked_end@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1152 : 		{	// return unchecked iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1153 : 		return (_Unchecked_iterator(this->_Myhead(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1154 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Unchecked_end@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?end@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::end, COMDAT
; _this$ = ecx

; 1135 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1136 : 		return (const_iterator(this->_Myhead(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1137 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?begin@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::begin, COMDAT
; _this$ = ecx

; 1124 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1125 : 		return (const_iterator(this->_Nextnode(this->_Myhead()),

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1126 : 			&this->_Get_data()));
; 1127 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?begin@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::begin, COMDAT
; _this$ = ecx

; 1118 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1119 : 		return (iterator(this->_Nextnode(this->_Myhead()),

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1120 : 			&this->_Get_data()));
; 1121 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??1?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::~list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT
; _this$ = ecx

; 1097 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1098 : 		_Tidy();

  00003	e8 00 00 00 00	 call	 ?clear@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::clear

; 1099 : 		}

  00008	ff 36		 push	 DWORD PTR [esi]
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
  00012	5e		 pop	 esi
  00013	c3		 ret	 0
??1?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::~list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 1
__Right$ = 8						; size = 4
??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT
; _this$ = ecx

; 924  : 		{	// construct list by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 921  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0003a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00041	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Buynode0
  00046	89 06		 mov	 DWORD PTR [esi], eax

; 925  : 		_TRY_BEGIN
; 926  : 		insert(begin(), _Right.begin(), _Right.end());

  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	c6 45 08 00	 mov	 BYTE PTR $T2[ebp], 0
  00051	ff 75 08	 push	 DWORD PTR $T2[ebp]
  00054	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00056	51		 push	 ecx
  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0005e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00062	8b 11		 mov	 edx, DWORD PTR [ecx]
  00064	8b ce		 mov	 ecx, esi
  00066	52		 push	 edx
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> > > >

; 930  : 		_CATCH_END
; 931  : 		}

  0006d	8b c6		 mov	 eax, esi
  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00079	59		 pop	 ecx
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
__catch$??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$0:

; 927  : 		_CATCH_ALL
; 928  : 		_Tidy();

  00083	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?clear@?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::clear

; 929  : 		_RERAISE;

  0008b	6a 00		 push	 0
  0008d	6a 00		 push	 0
  0008f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN248@list:
$LN247@list:
  00094	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$2:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ
__ehhandler$??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT
; _this$ = ecx

; 893  : 		{	// construct empty list

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Buynode0
  00020	89 06		 mov	 DWORD PTR [esi], eax

; 894  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::~_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT
; _this$ = ecx
  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::~_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Freenode@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@@Z PROC ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Freenode, COMDAT
; _this$ = ecx

; 848  : 		{	// give node back

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 849  : 		this->_Getal().destroy(
; 850  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 851  : 		this->_Getal().destroy(
; 852  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 853  : 		this->_Getal().destroy(

  00004	8b 75 08	 mov	 esi, DWORD PTR __Pnode$[ebp]
  00007	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0000a	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ

; 854  : 			_STD addressof(this->_Myval(_Pnode)));
; 855  : 		this->_Getal().deallocate(_Pnode, 1);

  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
  00018	5e		 pop	 esi

; 856  : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?_Freenode@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@@Z ENDP ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Freenode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT
; _this$ = ecx

; 818  : 		{	// default construct

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Buynode0
  00020	89 06		 mov	 DWORD PTR [esi], eax

; 819  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myval@?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@SAAAUFavoriteVolume@GostCrypt@@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@SAAAUFavoriteVolume@GostCrypt@@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >::_Myval, COMDAT

; 545  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 546  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 547  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@SAAAUFavoriteVolume@GostCrypt@@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Prevnode@?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >::_Prevnode, COMDAT

; 540  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 541  : 		return ((_Nodepref)_Pnode->_Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 542  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >::_Nextnode, COMDAT

; 535  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 536  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 537  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >, COMDAT
; _this$ = ecx

; 529  : 		: _Myhead(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 532  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >::_List_val<std::_List_simple_types<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Mysize@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Mysize, COMDAT
; _this$ = ecx

; 792  : 		return (_Get_data()._Mysize);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 793  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myhead@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABQAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABQAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Myhead, COMDAT
; _this$ = ecx

; 787  : 		return (_Get_data()._Myhead);

  00000	8b c1		 mov	 eax, ecx

; 788  : 		}

  00002	c3		 ret	 0
?_Myhead@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABQAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myhead@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Myhead, COMDAT
; _this$ = ecx

; 782  : 		return (_Get_data()._Myhead);

  00000	8b c1		 mov	 eax, ecx

; 783  : 		}

  00002	c3		 ret	 0
?_Myhead@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Get_data@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Get_data, COMDAT
; _this$ = ecx

; 777  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 778  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Get_data@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Get_data, COMDAT
; _this$ = ecx

; 772  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 773  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Getal@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Getal, COMDAT
; _this$ = ecx

; 767  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 768  : 		}

  00002	c3		 ret	 0
?_Getal@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Getal@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Getal, COMDAT
; _this$ = ecx

; 762  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 763  : 		}

  00002	c3		 ret	 0
?_Getal@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Buynode0@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@0@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
?_Buynode0@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@0@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Buynode0, COMDAT
; _this$ = ecx

; 729  : 		{	// allocate a node and set links

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 730  : 		_Nodeptr _Pnode = _Getal().allocate(1);

  00003	6a 70		 push	 112			; 00000070H
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4
  0000d	85 c0		 test	 eax, eax
  0000f	74 1f		 je	 SHORT $LN117@Buynode0

; 731  : 
; 732  : 		if (_Next == _Nodeptr())

  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Next$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	75 06		 jne	 SHORT $LN115@Buynode0

; 733  : 			{	// point at self
; 734  : 			_Next = _Pnode;

  00018	8b c8		 mov	 ecx, eax

; 735  : 			_Prev = _Pnode;

  0001a	8b d0		 mov	 edx, eax
  0001c	eb 03		 jmp	 SHORT $LN2@Buynode0
$LN115@Buynode0:
  0001e	8b 55 0c	 mov	 edx, DWORD PTR __Prev$[ebp]
$LN2@Buynode0:

; 736  : 			}
; 737  : 		_TRY_BEGIN
; 738  : 		_Getal().construct(

  00021	89 08		 mov	 DWORD PTR [eax], ecx

; 739  : 			_STD addressof(_Nextnode(_Pnode)), _Next);
; 740  : 		_Getal().construct(

  00023	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00026	85 c9		 test	 ecx, ecx
  00028	74 02		 je	 SHORT $LN4@Buynode0
  0002a	89 11		 mov	 DWORD PTR [ecx], edx
$LN4@Buynode0:

; 741  : 			_STD addressof(_Prevnode(_Pnode)), _Prev);
; 742  : 		_CATCH_ALL
; 743  : 		_Getal().deallocate(_Pnode, 1);
; 744  : 		_RERAISE;
; 745  : 		_CATCH_END
; 746  : 
; 747  : 		return (_Pnode);
; 748  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
$LN117@Buynode0:

; 730  : 		_Nodeptr _Pnode = _Getal().allocate(1);

  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN119@Buynode0:
$LN116@Buynode0:
  00035	cc		 int	 3
?_Buynode0@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@0@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Freeheadnode@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEXPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEXPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Freeheadnode, COMDAT
; _this$ = ecx

; 719  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Getal().destroy(
; 721  : 			_STD addressof(_Nextnode(_Pnode)));
; 722  : 		_Getal().destroy(
; 723  : 			_STD addressof(_Prevnode(_Pnode)));
; 724  : 		_Getal().deallocate(_Pnode, 1);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 725  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freeheadnode@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEXPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Buyheadnode@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Buyheadnode, COMDAT
; _this$ = ecx

; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Buynode0

; 716  : 		}

  00009	c3		 ret	 0
?_Buyheadnode@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??1?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::~_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT
; _this$ = ecx

; 617  : 		_Freeheadnode(_Myhead());

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx

; 618  : 		}

  00008	c3		 ret	 0
??1?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::~_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT
; _this$ = ecx

; 602  : 		{	// default construct head node

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 603  : 		_Myhead() = _Buyheadnode();

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Buynode0
  00019	89 06		 mov	 DWORD PTR [esi], eax

; 604  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c3		 ret	 0
??0?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myval@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@SAAAUFavoriteVolume@GostCrypt@@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@SAAAUFavoriteVolume@GostCrypt@@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Myval, COMDAT

; 595  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 596  : 		return (_List_val<_Val_types>::_Myval(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 597  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@SAAAUFavoriteVolume@GostCrypt@@PAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Prevnode@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Prevnode, COMDAT

; 590  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 591  : 		return (_List_val<_Val_types>::_Prevnode(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 592  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Nextnode, COMDAT

; 585  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 586  : 		return (_List_val<_Val_types>::_Nextnode(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 587  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_alloc@U?$_List_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@PAU32@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	b8 92 24 49 02	 mov	 eax, 38347922		; 02492492H

; 1009 : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d 92 24 49 02	 cmp	 eax, 38347922		; 02492492H
  0000e	77 31		 ja	 SHORT $LN16@deallocate
  00010	6b c0 70	 imul	 eax, eax, 112
  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN7@deallocate
  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN18@deallocate
  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN19@deallocate
  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN20@deallocate
  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN21@deallocate
  00032	8b c8		 mov	 ecx, eax
$LN7@deallocate:
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 988  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:
  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:
  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:
  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  0005a	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 977  : 		}

  00003	5d		 pop	 ebp

; 976  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@I@Z ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	b8 92 24 49 02	 mov	 eax, 38347922		; 02492492H

; 870  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 92 24 49 02	 mov	 eax, 38347922		; 02492492H

; 750  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d 92 24 49 02	 cmp	 eax, 38347922		; 02492492H
  00013	77 3c		 ja	 SHORT $LN14@allocate
  00015	6b c0 70	 imul	 eax, eax, 112
  00018	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001d	72 23		 jb	 SHORT $LN6@allocate
  0001f	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00022	3b c8		 cmp	 ecx, eax
  00024	76 30		 jbe	 SHORT $LN16@allocate
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002c	8b c8		 mov	 ecx, eax
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c9		 test	 ecx, ecx
  00033	74 26		 je	 SHORT $LN17@allocate
  00035	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00038	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0003b	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00048	83 c4 04	 add	 esp, 4
  0004b	85 c0		 test	 eax, eax
  0004d	75 bb		 jne	 SHORT $LN12@allocate
  0004f	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:
  00051	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:
  00056	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:
  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:
  00060	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00065	cc		 int	 3
?allocate@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d 92 24 49 02	 cmp	 eax, 38347922		; 02492492H
  0000e	77 31		 ja	 SHORT $LN13@deallocate
  00010	6b c0 70	 imul	 eax, eax, 112
  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN5@deallocate
  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN15@deallocate
  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN16@deallocate
  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN17@deallocate
  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN18@deallocate
  00032	8b c8		 mov	 ecx, eax
$LN5@deallocate:
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 721  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:
  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:
  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:
  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005a	cc		 int	 3
?deallocate@?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_List_node@UFavoriteVolume@GostCrypt@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >::allocator<std::_List_node<GostCrypt::FavoriteVolume,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FSystemFavoriteVolumes@GostCrypt@@YAXXZ
text$yd	SEGMENT
??__FSystemFavoriteVolumes@GostCrypt@@YAXXZ PROC	; GostCrypt::`dynamic atexit destructor for 'SystemFavoriteVolumes'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?SystemFavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::SystemFavoriteVolumes
  00005	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Tidy
??__FSystemFavoriteVolumes@GostCrypt@@YAXXZ ENDP	; GostCrypt::`dynamic atexit destructor for 'SystemFavoriteVolumes''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ??__ESystemFavoriteVolumes@GostCrypt@@YAXXZ
text$di	SEGMENT
??__ESystemFavoriteVolumes@GostCrypt@@YAXXZ PROC	; GostCrypt::`dynamic initializer for 'SystemFavoriteVolumes'', COMDAT

; 34   : 	vector <FavoriteVolume> SystemFavoriteVolumes;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?SystemFavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::SystemFavoriteVolumes
  00005	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >
  0000a	68 00 00 00 00	 push	 OFFSET ??__FSystemFavoriteVolumes@GostCrypt@@YAXXZ ; GostCrypt::`dynamic atexit destructor for 'SystemFavoriteVolumes''
  0000f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SystemFavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A, 0
  00019	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SystemFavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+4, 0
  00023	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?SystemFavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+8, 0
  0002d	e8 00 00 00 00	 call	 _atexit
  00032	59		 pop	 ecx
  00033	c3		 ret	 0
??__ESystemFavoriteVolumes@GostCrypt@@YAXXZ ENDP	; GostCrypt::`dynamic initializer for 'SystemFavoriteVolumes''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FFavoriteVolumes@GostCrypt@@YAXXZ
text$yd	SEGMENT
??__FFavoriteVolumes@GostCrypt@@YAXXZ PROC		; GostCrypt::`dynamic atexit destructor for 'FavoriteVolumes'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoriteVolumes
  00005	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Tidy
??__FFavoriteVolumes@GostCrypt@@YAXXZ ENDP		; GostCrypt::`dynamic atexit destructor for 'FavoriteVolumes''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ??__EFavoriteVolumes@GostCrypt@@YAXXZ
text$di	SEGMENT
??__EFavoriteVolumes@GostCrypt@@YAXXZ PROC		; GostCrypt::`dynamic initializer for 'FavoriteVolumes'', COMDAT

; 33   : 	vector <FavoriteVolume> FavoriteVolumes;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoriteVolumes
  00005	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >
  0000a	68 00 00 00 00	 push	 OFFSET ??__FFavoriteVolumes@GostCrypt@@YAXXZ ; GostCrypt::`dynamic atexit destructor for 'FavoriteVolumes''
  0000f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?FavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A, 0
  00019	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?FavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+4, 0
  00023	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?FavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+8, 0
  0002d	e8 00 00 00 00	 call	 _atexit
  00032	59		 pop	 ecx
  00033	c3		 ret	 0
??__EFavoriteVolumes@GostCrypt@@YAXXZ ENDP		; GostCrypt::`dynamic initializer for 'FavoriteVolumes''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IBEXPAUFavoriteVolume@GostCrypt@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IBEXPAUFavoriteVolume@GostCrypt@@0@Z PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1794 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IBEXPAUFavoriteVolume@GostCrypt@@0@Z ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IBEXXZ PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Xlen, COMDAT
; _this$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IBEXXZ ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXXZ PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi

; 1637 : 		if (this->_Myfirst() != pointer())

  00004	8b 33		 mov	 esi, DWORD PTR [ebx]
  00006	85 f6		 test	 esi, esi
  00008	74 4c		 je	 SHORT $LN2@Tidy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  0000a	57		 push	 edi
  0000b	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  0000e	3b f7		 cmp	 esi, edi
  00010	74 0e		 je	 SHORT $LN43@Tidy
$LL44@Tidy:
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  00019	83 c6 68	 add	 esi, 104		; 00000068H
  0001c	3b f7		 cmp	 esi, edi
  0001e	75 f2		 jne	 SHORT $LL44@Tidy
$LN43@Tidy:

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

  00020	8b 33		 mov	 esi, DWORD PTR [ebx]
  00022	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00027	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0002a	2b ce		 sub	 ecx, esi
  0002c	f7 e9		 imul	 ecx
  0002e	8b cb		 mov	 ecx, ebx
  00030	c1 fa 05	 sar	 edx, 5
  00033	8b c2		 mov	 eax, edx
  00035	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00038	03 c2		 add	 eax, edx
  0003a	50		 push	 eax
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@I@Z ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::deallocate

; 1642 : 				this->_Myend() - this->_Myfirst());
; 1643 : 			this->_Myfirst() = pointer();

  00041	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0

; 1644 : 			this->_Mylast() = pointer();

  00047	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1645 : 			this->_Myend() = pointer();

  0004e	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
  00055	5f		 pop	 edi
$LN2@Tidy:

; 1646 : 			}
; 1647 : 		}

  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	c3		 ret	 0
?_Tidy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXXZ ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv289 = 8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 1627 : 		if (_Unused_capacity() < _Count)

  00006	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00010	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00013	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00016	2b d6		 sub	 edx, esi
  00018	f7 ea		 imul	 edx
  0001a	c1 fa 05	 sar	 edx, 5
  0001d	8b c2		 mov	 eax, edx
  0001f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00022	03 c2		 add	 eax, edx
  00024	3b c7		 cmp	 eax, edi
  00026	73 5d		 jae	 SHORT $LN2@Reserve

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

  00028	8b 03		 mov	 eax, DWORD PTR [ebx]
  0002a	2b f0		 sub	 esi, eax
  0002c	89 45 08	 mov	 DWORD PTR tv289[ebp], eax
  0002f	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00034	f7 ee		 imul	 esi
  00036	b8 62 27 76 02	 mov	 eax, 41297762		; 02762762H
  0003b	c1 fa 05	 sar	 edx, 5
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00043	03 ca		 add	 ecx, edx
  00045	2b c1		 sub	 eax, ecx
  00047	3b c7		 cmp	 eax, edi
  00049	72 41		 jb	 SHORT $LN134@Reserve

; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

  0004b	03 f9		 add	 edi, ecx
  0004d	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00052	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00055	2b 4d 08	 sub	 ecx, DWORD PTR tv289[ebp]
  00058	f7 e9		 imul	 ecx
  0005a	33 c9		 xor	 ecx, ecx
  0005c	c1 fa 05	 sar	 edx, 5
  0005f	8b f2		 mov	 esi, edx
  00061	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00064	03 f2		 add	 esi, edx
  00066	ba 62 27 76 02	 mov	 edx, 41297762		; 02762762H
  0006b	8b c6		 mov	 eax, esi
  0006d	d1 e8		 shr	 eax, 1
  0006f	2b d0		 sub	 edx, eax
  00071	03 c6		 add	 eax, esi
  00073	3b d6		 cmp	 edx, esi
  00075	0f 43 c8	 cmovae	 ecx, eax
  00078	3b cf		 cmp	 ecx, edi
  0007a	0f 43 f9	 cmovae	 edi, ecx
  0007d	8b cb		 mov	 ecx, ebx
  0007f	57		 push	 edi
  00080	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Reallocate
$LN2@Reserve:
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx

; 1632 : 			}
; 1633 : 		}

  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
$LN134@Reserve:

; 1630 : 				_Xlen();

  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00091	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN136@Reserve:
$LN133@Reserve:
  00096	cc		 int	 3
?_Reserve@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
__Size$1$ = -24						; size = 4
__Ptr$ = -24						; size = 4
__Last$1$ = -20						; size = 4
$T2 = -20						; size = 1
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d e4	 mov	 DWORD PTR _this$[ebp], edi

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

  00030	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEPAUFavoriteVolume@GostCrypt@@I@Z ; std::allocator<GostCrypt::FavoriteVolume>::allocate

; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);

  00038	51		 push	 ecx
  00039	c6 45 ec 00	 mov	 BYTE PTR $T2[ebp], 0
  0003d	8b d8		 mov	 ebx, eax
  0003f	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00042	89 5d e8	 mov	 DWORD PTR __Ptr$[ebp], ebx
  00045	57		 push	 edi
  00046	53		 push	 ebx
  00047	ff 77 04	 push	 DWORD PTR [edi+4]
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00051	ff 37		 push	 DWORD PTR [edi]
  00053	e8 00 00 00 00	 call	 ??$_Uninitialized_move_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >

; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();

  00058	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0005b	83 c4 18	 add	 esp, 24			; 00000018H
  0005e	8b 37		 mov	 esi, DWORD PTR [edi]
  00060	8b c8		 mov	 ecx, eax
  00062	89 45 ec	 mov	 DWORD PTR __Last$1$[ebp], eax
  00065	2b ce		 sub	 ecx, esi
  00067	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  0006c	f7 e9		 imul	 ecx
  0006e	c1 fa 05	 sar	 edx, 5
  00071	8b c2		 mov	 eax, edx
  00073	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00076	03 c2		 add	 eax, edx
  00078	89 45 e8	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1612 : 		if (this->_Myfirst() != pointer())

  0007b	85 f6		 test	 esi, esi
  0007d	74 35		 je	 SHORT $LN3@Reallocate

; 1613 : 			{	// destroy and deallocate old array
; 1614 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  0007f	3b 75 ec	 cmp	 esi, DWORD PTR __Last$1$[ebp]
  00082	74 0f		 je	 SHORT $LN126@Reallocate
$LL127@Reallocate:
  00084	8b ce		 mov	 ecx, esi
  00086	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  0008b	83 c6 68	 add	 esi, 104		; 00000068H
  0008e	3b 75 ec	 cmp	 esi, DWORD PTR __Last$1$[ebp]
  00091	75 f1		 jne	 SHORT $LL127@Reallocate
$LN126@Reallocate:

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

  00093	8b 37		 mov	 esi, DWORD PTR [edi]
  00095	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  0009a	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0009d	2b ce		 sub	 ecx, esi
  0009f	f7 e9		 imul	 ecx
  000a1	8b cf		 mov	 ecx, edi
  000a3	c1 fa 05	 sar	 edx, 5
  000a6	8b c2		 mov	 eax, edx
  000a8	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ab	03 c2		 add	 eax, edx
  000ad	50		 push	 eax
  000ae	56		 push	 esi
  000af	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@I@Z ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::deallocate
$LN3@Reallocate:

; 1616 : 				this->_Myend() - this->_Myfirst());
; 1617 : 			}
; 1618 : 
; 1619 : 		this->_Orphan_all();
; 1620 : 		this->_Myend() = _Ptr + _Count;

  000b4	6b 45 08 68	 imul	 eax, DWORD PTR __Count$[ebp], 104
  000b8	03 c3		 add	 eax, ebx
  000ba	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1621 : 		this->_Mylast() = _Ptr + _Size;

  000bd	6b 45 e8 68	 imul	 eax, DWORD PTR __Size$1$[ebp], 104
  000c1	03 c3		 add	 eax, ebx
  000c3	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1622 : 		this->_Myfirst() = _Ptr;

  000c6	89 1f		 mov	 DWORD PTR [edi], ebx

; 1623 : 		}

  000c8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000cb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d2	59		 pop	 ecx
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 04 00	 ret	 4
__catch$?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z$0:

; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);

  000dc	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  000df	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	ff 75 e8	 push	 DWORD PTR __Ptr$[ebp]
  000e5	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@I@Z ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::deallocate

; 1608 : 		_RERAISE;

  000ea	6a 00		 push	 0
  000ec	6a 00		 push	 0
  000ee	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN207@Reallocate:
$LN206@Reallocate:
  000f3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Reallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IBE_NPBUFavoriteVolume@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IBE_NPBUFavoriteVolume@GostCrypt@@@Z PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Inside, COMDAT
; _this$ = ecx

; 1596 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0a		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 06		 ja	 SHORT $LN3@Inside
  0000f	b0 01		 mov	 al, 1

; 1598 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
$LN3@Inside:

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

  00015	32 c0		 xor	 al, al

; 1598 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?_Inside@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IBE_NPBUFavoriteVolume@GostCrypt@@@Z ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IBEII@Z PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1586 : 		size_type _Capacity = capacity();

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	f7 ea		 imul	 edx
  0000f	56		 push	 esi
  00010	c1 fa 05	 sar	 edx, 5
  00013	8b f2		 mov	 esi, edx
  00015	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00018	03 f2		 add	 esi, edx

; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

  0001a	ba 62 27 76 02	 mov	 edx, 41297762		; 02762762H
  0001f	8b c6		 mov	 eax, esi
  00021	d1 e8		 shr	 eax, 1
  00023	2b d0		 sub	 edx, eax
  00025	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  00028	33 c0		 xor	 eax, eax
  0002a	3b d6		 cmp	 edx, esi
  0002c	5e		 pop	 esi
  0002d	0f 43 c1	 cmovae	 eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

  00030	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00033	0f 42 45 08	 cmovb	 eax, DWORD PTR __Count$[ebp]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_Grow_to@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IBEII@Z ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXPAUFavoriteVolume@GostCrypt@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXPAUFavoriteVolume@GostCrypt@@0@Z PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Destroy, COMDAT
; _this$ = ecx

; 1580 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 0f		 je	 SHORT $LN13@Destroy
  0000f	90		 npad	 1
$LL14@Destroy:
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  00017	83 c6 68	 add	 esi, 104		; 00000068H
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $LL14@Destroy
$LN13@Destroy:
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 1582 : 		}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?_Destroy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXPAUFavoriteVolume@GostCrypt@@0@Z ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAE_NI@Z PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Buy, COMDAT
; _this$ = ecx

; 1561 : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1562 : 		this->_Myfirst() = pointer();
; 1563 : 		this->_Mylast() = pointer();
; 1564 : 		this->_Myend() = pointer();
; 1565 : 
; 1566 : 		if (_Capacity == 0)

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Capacity$[ebp]
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00010	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00017	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001e	85 ff		 test	 edi, edi
  00020	75 08		 jne	 SHORT $LN2@Buy

; 1567 : 			return (false);

  00022	5f		 pop	 edi
  00023	32 c0		 xor	 al, al
  00025	5e		 pop	 esi

; 1577 : 		}

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN2@Buy:

; 1568 : 		else if (max_size() < _Capacity)

  0002a	81 ff 62 27 76
	02		 cmp	 edi, 41297762		; 02762762H
  00030	77 1b		 ja	 SHORT $LN109@Buy

; 1570 : 		else
; 1571 : 			{	// nonempty array, allocate storage
; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ?allocate@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEPAUFavoriteVolume@GostCrypt@@I@Z ; std::allocator<GostCrypt::FavoriteVolume>::allocate
  00038	89 06		 mov	 DWORD PTR [esi], eax

; 1573 : 			this->_Mylast() = this->_Myfirst();

  0003a	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

  0003d	6b c7 68	 imul	 eax, edi, 104
  00040	5f		 pop	 edi
  00041	03 06		 add	 eax, DWORD PTR [esi]
  00043	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1575 : 			}
; 1576 : 		return (true);

  00046	b0 01		 mov	 al, 1
  00048	5e		 pop	 esi

; 1577 : 		}

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
$LN109@Buy:

; 1569 : 			_Xlen();	// result too long

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00052	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN111@Buy:
$LN108@Buy:
  00057	cc		 int	 3
?_Buy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::clear, COMDAT
; _this$ = ecx

; 1539 : 		{	// erase all

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());

  00005	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00008	8b 37		 mov	 esi, DWORD PTR [edi]
  0000a	3b f3		 cmp	 esi, ebx
  0000c	74 19		 je	 SHORT $LN70@clear
  0000e	66 90		 npad	 2
$LL34@clear:
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  00017	83 c6 68	 add	 esi, 104		; 00000068H
  0001a	3b f3		 cmp	 esi, ebx
  0001c	75 f2		 jne	 SHORT $LL34@clear

; 1542 : 		this->_Mylast() = this->_Myfirst();

  0001e	8b 07		 mov	 eax, DWORD PTR [edi]
  00020	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx

; 1543 : 		}

  00026	c3		 ret	 0
$LN70@clear:

; 1542 : 		this->_Mylast() = this->_Myfirst();

  00027	8b c6		 mov	 eax, esi
  00029	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 1543 : 		}

  0002f	c3		 ret	 0
?clear@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?erase@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@@Z PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::erase, COMDAT
; _this$ = ecx

; 1484 : 		{	// erase element at where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1485 : 		_Move_unchecked(_VIPTR(_Where) + 1, this->_Mylast(),

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b d9		 mov	 ebx, ecx
  0000c	c6 45 fc 00	 mov	 BYTE PTR $T1[ebp], 0
  00010	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00013	50		 push	 eax
  00014	ff 73 04	 push	 DWORD PTR [ebx+4]
  00017	83 c0 68	 add	 eax, 104		; 00000068H
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Move_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>

; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());

  00020	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00023	83 c4 10	 add	 esp, 16			; 00000010H
  00026	8d 77 98	 lea	 esi, DWORD PTR [edi-104]
  00029	3b f7		 cmp	 esi, edi
  0002b	74 11		 je	 SHORT $LN46@erase
  0002d	0f 1f 00	 npad	 3
$LL47@erase:
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  00037	83 c6 68	 add	 esi, 104		; 00000068H
  0003a	3b f7		 cmp	 esi, edi
  0003c	75 f2		 jne	 SHORT $LL47@erase
$LN46@erase:

; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));

  0003e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00041	83 43 04 98	 add	 DWORD PTR [ebx+4], -104	; ffffff98H
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	89 08		 mov	 DWORD PTR [eax], ecx
  0004c	5b		 pop	 ebx

; 1490 : 		}

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
?erase@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@@Z ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
$T5 = 8							; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::push_back, COMDAT
; _this$ = ecx

; 1276 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?push_back@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx

; 1277 : 		if (_Inside(_STD addressof(_Val)))

  00027	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0002d	3b f9		 cmp	 edi, ecx
  0002f	73 43		 jae	 SHORT $LN2@push_back
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	3b c7		 cmp	 eax, edi
  00035	77 3d		 ja	 SHORT $LN2@push_back

; 1278 : 			{	// push back an element
; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

  00037	2b f8		 sub	 edi, eax
  00039	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  0003e	f7 ef		 imul	 edi
  00040	c1 fa 05	 sar	 edx, 5
  00043	8b fa		 mov	 edi, edx
  00045	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00048	03 fa		 add	 edi, edx

; 1280 : 			if (this->_Mylast() == this->_Myend())

  0004a	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0004d	75 09		 jne	 SHORT $LN4@push_back

; 1281 : 				_Reserve(1);

  0004f	6a 01		 push	 1
  00051	8b ce		 mov	 ecx, esi
  00053	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Reserve
$LN4@push_back:

; 1282 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

  00058	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005b	6b c7 68	 imul	 eax, edi, 104
  0005e	89 4d 08	 mov	 DWORD PTR $T5[ebp], ecx
  00061	89 4d f0	 mov	 DWORD PTR $T3[ebp], ecx
  00064	03 06		 add	 eax, DWORD PTR [esi]
  00066	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006d	85 c9		 test	 ecx, ecx
  0006f	74 2b		 je	 SHORT $LN210@push_back
  00071	50		 push	 eax

; 1284 : 				this->_Myfirst()[_Idx]);
; 1285 : 			++this->_Mylast();
; 1286 : 			}
; 1287 : 		else

  00072	eb 23		 jmp	 SHORT $LN229@push_back
$LN2@push_back:

; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

  00074	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00077	75 09		 jne	 SHORT $LN5@push_back

; 1290 : 				_Reserve(1);

  00079	6a 01		 push	 1
  0007b	8b ce		 mov	 ecx, esi
  0007d	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXI@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Reserve
$LN5@push_back:

; 1291 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1292 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

  00082	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00085	89 4d 08	 mov	 DWORD PTR $T4[ebp], ecx
  00088	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  0008b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00092	85 c9		 test	 ecx, ecx
  00094	74 06		 je	 SHORT $LN210@push_back
  00096	57		 push	 edi
$LN229@push_back:
  00097	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
$LN210@push_back:

; 1293 : 				_Val);
; 1294 : 			++this->_Mylast();

  0009c	83 46 04 68	 add	 DWORD PTR [esi+4], 104	; 00000068H

; 1295 : 			}
; 1296 : 		}

  000a0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000aa	59		 pop	 ecx
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z$33:
  00000	8b 45 08	 mov	 eax, DWORD PTR $T5[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__unwindfunclet$?push_back@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z$57:
  00011	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  00014	50		 push	 eax
  00015	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0001e	83 c4 08	 add	 esp, 8
  00021	c3		 ret	 0
__ehhandler$?push_back@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z:
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?push_back@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?push_back@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::push_back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAUFavoriteVolume@GostCrypt@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAUFavoriteVolume@GostCrypt@@I@Z PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::operator[], COMDAT
; _this$ = ecx

; 1230 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

  00003	6b 45 08 68	 imul	 eax, DWORD PTR __Pos$[ebp], 104
  00007	03 01		 add	 eax, DWORD PTR [ecx]

; 1243 : 		}

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
??A?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAUFavoriteVolume@GostCrypt@@I@Z ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?empty@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE_NXZ PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::empty, COMDAT
; _this$ = ecx

; 1189 : 		{	// test if sequence is empty

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00005	0f 94 c0	 sete	 al

; 1190 : 		return (this->_Myfirst() == this->_Mylast());
; 1191 : 		}

  00008	c3		 ret	 0
?empty@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE_NXZ ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIXZ PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::max_size, COMDAT
; _this$ = ecx

; 1185 : 		return (this->_Getal().max_size());

  00000	b8 62 27 76 02	 mov	 eax, 41297762		; 02762762H

; 1186 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIXZ ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIXZ PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 05	 sar	 edx, 5
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1181 : 		}

  00016	c3		 ret	 0
?size@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIXZ ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@@Z PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Make_iter, COMDAT
; _this$ = ecx

; 1077 : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1078 : 		return (iterator(_Where._Ptr, &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1079 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@@Z ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::end, COMDAT
; _this$ = ecx

; 1072 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1073 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1074 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::begin, COMDAT
; _this$ = ecx

; 1062 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1063 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1064 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::begin, COMDAT
; _this$ = ecx

; 1057 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1058 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1059 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIXZ PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00008	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  0000b	f7 ea		 imul	 edx
  0000d	c1 fa 05	 sar	 edx, 5
  00010	8b c2		 mov	 eax, edx
  00012	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00015	03 c2		 add	 eax, edx

; 1049 : 		}

  00017	c3		 ret	 0
?_Unused_capacity@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIXZ ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIXZ PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::capacity, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 05	 sar	 edx, 5
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1044 : 		}

  00016	c3		 ret	 0
?capacity@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIXZ ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -20						; size = 1
__$EHRec$ = -16						; size = 16
$T5 = 8							; size = 1
$T6 = 8							; size = 1
__Right$ = 8						; size = 4
??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::operator=, COMDAT
; _this$ = ecx

; 980  : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d e4	 mov	 DWORD PTR _this$[ebp], edi

; 981  : 		if (this != &_Right)

  00030	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00033	3b fb		 cmp	 edi, ebx
  00035	0f 84 99 00 00
	00		 je	 $LN16@operator

; 982  : 			{	// different, assign it
; 983  : 			if (this->_Getal() != _Right._Getal()
; 984  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 985  : 				{	// change allocator before copying
; 986  : 				_Tidy();
; 987  : 				this->_Copy_alloc(_Right._Getal());
; 988  : 				}
; 989  : 
; 990  : 			this->_Orphan_all();
; 991  : 
; 992  : 			if (_Right.empty())

  0003b	8b 33		 mov	 esi, DWORD PTR [ebx]
  0003d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00040	3b f0		 cmp	 esi, eax
  00042	75 0a		 jne	 SHORT $LN4@operator

; 993  : 				clear();	// new sequence empty, erase existing sequence

  00044	e8 00 00 00 00	 call	 ?clear@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::clear
  00049	e9 86 00 00 00	 jmp	 $LN16@operator
$LN4@operator:

; 994  : 			else if (_Right.size() <= size())

  0004e	8b c8		 mov	 ecx, eax
  00050	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00055	2b ce		 sub	 ecx, esi
  00057	f7 e9		 imul	 ecx
  00059	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0005c	2b 0f		 sub	 ecx, DWORD PTR [edi]
  0005e	c1 fa 05	 sar	 edx, 5
  00061	8b c2		 mov	 eax, edx
  00063	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00066	03 c2		 add	 eax, edx
  00068	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  0006b	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00070	f7 e9		 imul	 ecx
  00072	c1 fa 05	 sar	 edx, 5
  00075	8b c2		 mov	 eax, edx
  00077	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0007a	03 c2		 add	 eax, edx
  0007c	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
  0007f	39 45 ec	 cmp	 DWORD PTR $T3[ebp], eax
  00082	77 66		 ja	 SHORT $LN6@operator

; 995  : 				{	// enough elements, copy new and destroy old
; 996  : 				pointer _Ptr = _Copy_unchecked(_Right._Myfirst(),

  00084	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00086	c6 45 ec 00	 mov	 BYTE PTR $T4[ebp], 0
  0008a	ff 75 ec	 push	 DWORD PTR $T4[ebp]
  0008d	51		 push	 ecx
  0008e	ff 73 04	 push	 DWORD PTR [ebx+4]
  00091	56		 push	 esi
  00092	e8 00 00 00 00	 call	 ??$_Copy_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>
  00097	8b f0		 mov	 esi, eax
  00099	83 c4 10	 add	 esp, 16			; 00000010H

; 997  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 998  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old

  0009c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0009f	3b f0		 cmp	 esi, eax
  000a1	74 13		 je	 SHORT $LN160@operator
  000a3	8b d8		 mov	 ebx, eax
$LL161@operator:
  000a5	8b ce		 mov	 ecx, esi
  000a7	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  000ac	83 c6 68	 add	 esi, 104		; 00000068H
  000af	3b f3		 cmp	 esi, ebx
  000b1	75 f2		 jne	 SHORT $LL161@operator
  000b3	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
$LN160@operator:

; 999  : 				this->_Mylast() = this->_Myfirst() + _Right.size();

  000b6	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000b9	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  000be	2b 0b		 sub	 ecx, DWORD PTR [ebx]
  000c0	f7 e9		 imul	 ecx
  000c2	c1 fa 05	 sar	 edx, 5
  000c5	8b c2		 mov	 eax, edx
  000c7	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ca	03 c2		 add	 eax, edx
  000cc	6b c0 68	 imul	 eax, eax, 104
  000cf	03 07		 add	 eax, DWORD PTR [edi]
$LN483@operator:

; 1005 : 					_Ptr, this->_Myfirst());
; 1006 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),

  000d1	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN16@operator:

; 1025 : 					_CATCH_END
; 1026 : 				}
; 1027 : 			}
; 1028 : 		return (*this);

  000d4	8b c7		 mov	 eax, edi

; 1029 : 		}

  000d6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000d9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e0	59		 pop	 ecx
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 04 00	 ret	 4
$LN6@operator:

; 1000 : 				}
; 1001 : 			else if (_Right.size() <= capacity())

  000ea	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000ed	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  000f2	8b 37		 mov	 esi, DWORD PTR [edi]
  000f4	2b ce		 sub	 ecx, esi
  000f6	f7 e9		 imul	 ecx
  000f8	c1 fa 05	 sar	 edx, 5
  000fb	8b c2		 mov	 eax, edx
  000fd	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00100	03 c2		 add	 eax, edx
  00102	39 45 ec	 cmp	 DWORD PTR $T3[ebp], eax
  00105	77 35		 ja	 SHORT $LN8@operator

; 1002 : 				{	// enough room, copy and construct new
; 1003 : 				pointer _Ptr = _Right._Myfirst() + size();

  00107	6b 75 e8 68	 imul	 esi, DWORD PTR $T2[ebp], 104
  0010b	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1004 : 				_Copy_unchecked(_Right._Myfirst(),

  0010d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0010f	c6 45 08 00	 mov	 BYTE PTR $T6[ebp], 0
  00113	ff 75 08	 push	 DWORD PTR $T6[ebp]
  00116	03 f0		 add	 esi, eax
  00118	51		 push	 ecx
  00119	56		 push	 esi
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 ??$_Copy_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *>

; 1005 : 					_Ptr, this->_Myfirst());
; 1006 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),

  00120	83 c4 0c	 add	 esp, 12			; 0000000cH
  00123	c6 45 08 00	 mov	 BYTE PTR $T5[ebp], 0
  00127	ff 75 08	 push	 DWORD PTR $T5[ebp]
  0012a	57		 push	 edi
  0012b	ff 77 04	 push	 DWORD PTR [edi+4]
  0012e	ff 73 04	 push	 DWORD PTR [ebx+4]
  00131	56		 push	 esi
  00132	e8 00 00 00 00	 call	 ??$_Uninitialized_copy_al_unchecked1@PAUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PAU12@00AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::FavoriteVolume *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
  00137	83 c4 18	 add	 esp, 24			; 00000018H

; 1007 : 					this->_Mylast());
; 1008 : 				}
; 1009 : 			else

  0013a	eb 95		 jmp	 SHORT $LN483@operator
$LN8@operator:

; 1010 : 				{	// not enough room, allocate new array and construct new
; 1011 : 				if (this->_Myfirst() != pointer())

  0013c	85 f6		 test	 esi, esi
  0013e	74 2c		 je	 SHORT $LN10@operator

; 1012 : 					{	// discard old array
; 1013 : 					_Destroy(this->_Myfirst(), this->_Mylast());

  00140	ff 77 04	 push	 DWORD PTR [edi+4]
  00143	8b cf		 mov	 ecx, edi
  00145	56		 push	 esi
  00146	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXPAUFavoriteVolume@GostCrypt@@0@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Destroy

; 1014 : 					this->_Getal().deallocate(this->_Myfirst(),

  0014b	8b 37		 mov	 esi, DWORD PTR [edi]
  0014d	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00152	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00155	2b ce		 sub	 ecx, esi
  00157	f7 e9		 imul	 ecx
  00159	8b cf		 mov	 ecx, edi
  0015b	c1 fa 05	 sar	 edx, 5
  0015e	8b c2		 mov	 eax, edx
  00160	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00163	03 c2		 add	 eax, edx
  00165	50		 push	 eax
  00166	56		 push	 esi
  00167	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@I@Z ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::deallocate
$LN10@operator:

; 1015 : 						this->_Myend() - this->_Myfirst());
; 1016 : 					}
; 1017 : 				if (_Buy(_Right.size()))

  0016c	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0016f	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00174	2b 0b		 sub	 ecx, DWORD PTR [ebx]
  00176	f7 e9		 imul	 ecx
  00178	8b cf		 mov	 ecx, edi
  0017a	c1 fa 05	 sar	 edx, 5
  0017d	8b c2		 mov	 eax, edx
  0017f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00182	03 c2		 add	 eax, edx
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 ?_Buy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAE_NI@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Buy
  0018a	84 c0		 test	 al, al
  0018c	0f 84 42 ff ff
	ff		 je	 $LN16@operator

; 1018 : 					_TRY_BEGIN
; 1019 : 					this->_Mylast() =

  00192	ff 37		 push	 DWORD PTR [edi]
  00194	8b cf		 mov	 ecx, edi
  00196	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0019d	ff 73 04	 push	 DWORD PTR [ebx+4]
  001a0	ff 33		 push	 DWORD PTR [ebx]
  001a2	e8 00 00 00 00	 call	 ??$_Ucopy@PAUFavoriteVolume@GostCrypt@@@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEPAUFavoriteVolume@GostCrypt@@PAU23@00@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Ucopy<GostCrypt::FavoriteVolume *>
  001a7	e9 25 ff ff ff	 jmp	 $LN483@operator
__catch$??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z$0:

; 1020 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1021 : 						this->_Myfirst());
; 1022 : 					_CATCH_ALL
; 1023 : 					_Tidy();

  001ac	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001af	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Tidy

; 1024 : 					_RERAISE;

  001b4	6a 00		 push	 0
  001b6	6a 00		 push	 0
  001b8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN484@operator:
$LN482@operator:
  001bd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::~vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT
; _this$ = ecx

; 976  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Tidy
??1?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::~vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 1
__Right$ = 8						; size = 4
??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT
; _this$ = ecx

; 748  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 749  : 		if (_Buy(_Right.size()))

  00030	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00033	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0003e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00045	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0004c	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0004f	2b 0b		 sub	 ecx, DWORD PTR [ebx]
  00051	f7 e9		 imul	 ecx
  00053	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00059	c1 fa 05	 sar	 edx, 5
  0005c	8b fa		 mov	 edi, edx
  0005e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00065	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00068	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0006f	03 fa		 add	 edi, edx
  00071	74 49		 je	 SHORT $LN7@vector
  00073	81 ff 62 27 76
	02		 cmp	 edi, 41297762		; 02762762H
  00079	76 0a		 jbe	 SHORT $LN58@vector
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00080	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN257@vector:
$LN58@vector:
  00085	57		 push	 edi
  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 ?allocate@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEPAUFavoriteVolume@GostCrypt@@I@Z ; std::allocator<GostCrypt::FavoriteVolume>::allocate
  0008d	89 06		 mov	 DWORD PTR [esi], eax
  0008f	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 750  : 			_TRY_BEGIN
; 751  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),

  00092	51		 push	 ecx
  00093	6b c7 68	 imul	 eax, edi, 104
  00096	c6 45 08 00	 mov	 BYTE PTR $T2[ebp], 0
  0009a	ff 75 08	 push	 DWORD PTR $T2[ebp]
  0009d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000a4	56		 push	 esi
  000a5	03 06		 add	 eax, DWORD PTR [esi]
  000a7	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000aa	ff 36		 push	 DWORD PTR [esi]
  000ac	ff 73 04	 push	 DWORD PTR [ebx+4]
  000af	ff 33		 push	 DWORD PTR [ebx]
  000b1	e8 00 00 00 00	 call	 ??$_Uninitialized_copy_al_unchecked1@PBUFavoriteVolume@GostCrypt@@PAU12@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@YAPAUFavoriteVolume@GostCrypt@@PBU12@0PAU12@AAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<GostCrypt::FavoriteVolume const *,GostCrypt::FavoriteVolume *,std::allocator<GostCrypt::FavoriteVolume> >
  000b6	83 c4 18	 add	 esp, 24			; 00000018H
  000b9	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN7@vector:

; 756  : 			_CATCH_END
; 757  : 		}

  000bc	8b c6		 mov	 eax, esi
  000be	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000c1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c8	59		 pop	 ecx
  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c2 04 00	 ret	 4
__catch$??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$0:

; 752  : 				this->_Myfirst());
; 753  : 			_CATCH_ALL
; 754  : 			_Tidy();

  000d2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Tidy

; 755  : 			_RERAISE;

  000da	6a 00		 push	 0
  000dc	6a 00		 push	 0
  000de	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN258@vector:
$LN256@vector:
  000e3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >, COMDAT
; _this$ = ecx

; 706  : 		: _Mybase()

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 708  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >,std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 489  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >::_Vector_val<std::_Simple_types<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABQAUFavoriteVolume@GostCrypt@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABQAUFavoriteVolume@GostCrypt@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 669  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABQAUFavoriteVolume@GostCrypt@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAPAUFavoriteVolume@GostCrypt@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAPAUFavoriteVolume@GostCrypt@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 664  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAPAUFavoriteVolume@GostCrypt@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABQAUFavoriteVolume@GostCrypt@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABQAUFavoriteVolume@GostCrypt@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 659  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABQAUFavoriteVolume@GostCrypt@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAPAUFavoriteVolume@GostCrypt@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAPAUFavoriteVolume@GostCrypt@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 654  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAPAUFavoriteVolume@GostCrypt@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABQAUFavoriteVolume@GostCrypt@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABQAUFavoriteVolume@GostCrypt@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 649  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABQAUFavoriteVolume@GostCrypt@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAPAUFavoriteVolume@GostCrypt@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAPAUFavoriteVolume@GostCrypt@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 644  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAPAUFavoriteVolume@GostCrypt@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 639  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 634  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 629  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 624  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@2@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 533  : 		_Pocca(_Getal(), _Al);
; 534  : 		}

  00000	c2 04 00	 ret	 4
?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@2@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >, COMDAT
; _this$ = ecx

; 519  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 521  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >::_Vector_alloc<std::_Vec_base_types<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	b8 62 27 76 02	 mov	 eax, 41297762		; 02762762H

; 1009 : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@I@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d 62 27 76 02	 cmp	 eax, 41297762		; 02762762H
  0000e	77 31		 ja	 SHORT $LN16@deallocate
  00010	6b c0 68	 imul	 eax, eax, 104
  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN7@deallocate
  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN18@deallocate
  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN19@deallocate
  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN20@deallocate
  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN21@deallocate
  00032	8b c8		 mov	 ecx, eax
$LN7@deallocate:
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 988  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:
  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:
  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:
  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  0005a	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAUFavoriteVolume@GostCrypt@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAUFavoriteVolume@GostCrypt@@I@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 977  : 		}

  00003	5d		 pop	 ebp

; 976  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEPAUFavoriteVolume@GostCrypt@@I@Z ; std::allocator<GostCrypt::FavoriteVolume>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAUFavoriteVolume@GostCrypt@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SA?AV?$allocator@UFavoriteVolume@GostCrypt@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SA?AV?$allocator@UFavoriteVolume@GostCrypt@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<GostCrypt::FavoriteVolume> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SA?AV?$allocator@UFavoriteVolume@GostCrypt@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<GostCrypt::FavoriteVolume> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAIABV?$allocator@UFavoriteVolume@GostCrypt@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAIABV?$allocator@UFavoriteVolume@GostCrypt@@@2@@Z PROC ; std::allocator_traits<std::allocator<GostCrypt::FavoriteVolume> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	b8 62 27 76 02	 mov	 eax, 41297762		; 02762762H

; 870  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@SAIABV?$allocator@UFavoriteVolume@GostCrypt@@@2@@Z ENDP ; std::allocator_traits<std::allocator<GostCrypt::FavoriteVolume> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QBEIXZ PROC ; std::allocator<GostCrypt::FavoriteVolume>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 62 27 76 02	 mov	 eax, 41297762		; 02762762H

; 750  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QBEIXZ ENDP ; std::allocator<GostCrypt::FavoriteVolume>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEPAUFavoriteVolume@GostCrypt@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEPAUFavoriteVolume@GostCrypt@@I@Z PROC ; std::allocator<GostCrypt::FavoriteVolume>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d 62 27 76 02	 cmp	 eax, 41297762		; 02762762H
  00013	77 3c		 ja	 SHORT $LN14@allocate
  00015	6b c0 68	 imul	 eax, eax, 104
  00018	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001d	72 23		 jb	 SHORT $LN6@allocate
  0001f	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00022	3b c8		 cmp	 ecx, eax
  00024	76 30		 jbe	 SHORT $LN16@allocate
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002c	8b c8		 mov	 ecx, eax
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c9		 test	 ecx, ecx
  00033	74 26		 je	 SHORT $LN17@allocate
  00035	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00038	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0003b	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00048	83 c4 04	 add	 esp, 4
  0004b	85 c0		 test	 eax, eax
  0004d	75 bb		 jne	 SHORT $LN12@allocate
  0004f	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:
  00051	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:
  00056	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:
  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:
  00060	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00065	cc		 int	 3
?allocate@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEPAUFavoriteVolume@GostCrypt@@I@Z ENDP ; std::allocator<GostCrypt::FavoriteVolume>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@I@Z PROC ; std::allocator<GostCrypt::FavoriteVolume>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d 62 27 76 02	 cmp	 eax, 41297762		; 02762762H
  0000e	77 31		 ja	 SHORT $LN13@deallocate
  00010	6b c0 68	 imul	 eax, eax, 104
  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN5@deallocate
  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN15@deallocate
  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN16@deallocate
  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN17@deallocate
  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN18@deallocate
  00032	8b c8		 mov	 ecx, eax
$LN5@deallocate:
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 721  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:
  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:
  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:
  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005a	cc		 int	 3
?deallocate@?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@I@Z ENDP ; std::allocator<GostCrypt::FavoriteVolume>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAE@ABV01@@Z PROC ; std::allocator<GostCrypt::FavoriteVolume>::allocator<GostCrypt::FavoriteVolume>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<GostCrypt::FavoriteVolume>::allocator<GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAE@XZ PROC ; std::allocator<GostCrypt::FavoriteVolume>::allocator<GostCrypt::FavoriteVolume>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@UFavoriteVolume@GostCrypt@@@std@@QAE@XZ ENDP ; std::allocator<GostCrypt::FavoriteVolume>::allocator<GostCrypt::FavoriteVolume>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ?UpdateDeviceHostedFavoriteVolumes@GostCrypt@@YAXXZ
_TEXT	SEGMENT
_e$2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
?UpdateDeviceHostedFavoriteVolumes@GostCrypt@@YAXXZ PROC ; GostCrypt::UpdateDeviceHostedFavoriteVolumes, COMDAT

; 995  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?UpdateDeviceHostedFavoriteVolumes@GostCrypt@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 996  : 		try

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 997  : 		{
; 998  : 			LoadFavoriteVolumes();

  00032	e8 00 00 00 00	 call	 ?LoadFavoriteVolumes@GostCrypt@@YAXXZ ; GostCrypt::LoadFavoriteVolumes
$LN7@UpdateDevi:

; 1004 : 	}

  00037	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0003a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00041	59		 pop	 ecx
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
__catch$?UpdateDeviceHostedFavoriteVolumes@GostCrypt@@YAXXZ$0:

; 999  : 		}
; 1000 : 		catch (Exception &e)
; 1001 : 		{
; 1002 : 			e.Show (MainDlg);

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _e$2[ebp]
  0004c	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00052	8b 01		 mov	 eax, DWORD PTR [ecx]
  00054	ff 10		 call	 DWORD PTR [eax]

; 1003 : 		}

  00056	b8 00 00 00 00	 mov	 eax, $LN7@UpdateDevi
  0005b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?UpdateDeviceHostedFavoriteVolumes@GostCrypt@@YAXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?UpdateDeviceHostedFavoriteVolumes@GostCrypt@@YAXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?UpdateDeviceHostedFavoriteVolumes@GostCrypt@@YAXXZ ENDP ; GostCrypt::UpdateDeviceHostedFavoriteVolumes
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z
_TEXT	SEGMENT
_hwndDlg$GSCopy$1$ = -2264				; size = 4
_partition$1$ = -2257					; size = 1
$T2 = -2256						; size = 24
$T3 = -2232						; size = 24
$T4 = -2208						; size = 24
$T5 = -2184						; size = 24
$T6 = -2160						; size = 24
$T7 = -2136						; size = 24
$T8 = -2112						; size = 24
$T9 = -2088						; size = 24
_label$ = -2064						; size = 2048
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_hwndDlg$ = 8						; size = 4
_favorite$ = 12						; size = 4
_systemFavoritesMode$ = 16				; size = 1
?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z PROC ; GostCrypt::SetFavoriteVolume, COMDAT

; 934  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 08 00
	00		 sub	 esp, 2252		; 000008ccH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 75 08	 mov	 esi, DWORD PTR _hwndDlg$[ebp]

; 935  : 		wchar_t label[1024];
; 936  : 		if (GetDlgItemTextW (hwndDlg, IDC_FAVORITE_LABEL, label, ARRAYSIZE (label)) != 0)

  00031	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _label$[ebp]
  00037	8b 5d 0c	 mov	 ebx, DWORD PTR _favorite$[ebp]
  0003a	68 00 04 00 00	 push	 1024			; 00000400H
  0003f	50		 push	 eax
  00040	68 60 04 00 00	 push	 1120			; 00000460H
  00045	56		 push	 esi
  00046	89 b5 28 f7 ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$1$[ebp], esi
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItemTextW@16
  00052	85 c0		 test	 eax, eax
  00054	0f 84 80 00 00
	00		 je	 $LN5@SetFavorit

; 937  : 		{
; 938  : 			favorite.Label = label;

  0005a	66 83 bd f0 f7
	ff ff 00	 cmp	 WORD PTR _label$[ebp], 0
  00062	75 04		 jne	 SHORT $LN28@SetFavorit
  00064	33 c9		 xor	 ecx, ecx
  00066	eb 18		 jmp	 SHORT $LN29@SetFavorit
$LN28@SetFavorit:
  00068	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR _label$[ebp]
  0006e	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
$LL1060@SetFavorit:
  00071	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00074	83 c1 02	 add	 ecx, 2
  00077	66 85 c0	 test	 ax, ax
  0007a	75 f5		 jne	 SHORT $LL1060@SetFavorit
  0007c	2b ca		 sub	 ecx, edx
  0007e	d1 f9		 sar	 ecx, 1
$LN29@SetFavorit:
  00080	51		 push	 ecx
  00081	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _label$[ebp]
  00087	8d 7b 48	 lea	 edi, DWORD PTR [ebx+72]
  0008a	50		 push	 eax
  0008b	8b cf		 mov	 ecx, edi
  0008d	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 939  : 
; 940  : 			for (size_t i = 0; i < favorite.Label.size(); ++i)

  00092	33 c0		 xor	 eax, eax
  00094	39 43 58	 cmp	 DWORD PTR [ebx+88], eax
  00097	76 5c		 jbe	 SHORT $LN109@SetFavorit
  00099	8d 50 27	 lea	 edx, DWORD PTR [eax+39]
  0009c	0f 1f 40 00	 npad	 4
$LL4@SetFavorit:

; 941  : 			{
; 942  : 				if (favorite.Label[i] == L'"')

  000a0	83 7f 14 08	 cmp	 DWORD PTR [edi+20], 8
  000a4	72 04		 jb	 SHORT $LN54@SetFavorit
  000a6	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000a8	eb 02		 jmp	 SHORT $LN55@SetFavorit
$LN54@SetFavorit:
  000aa	8b cf		 mov	 ecx, edi
$LN55@SetFavorit:
  000ac	66 83 3c 41 22	 cmp	 WORD PTR [ecx+eax*2], 34 ; 00000022H
  000b1	75 15		 jne	 SHORT $LN2@SetFavorit

; 943  : 					favorite.Label.at (i) = L'\'';

  000b3	39 47 10	 cmp	 DWORD PTR [edi+16], eax
  000b6	76 18		 jbe	 SHORT $LN1055@SetFavorit
  000b8	83 7f 14 08	 cmp	 DWORD PTR [edi+20], 8
  000bc	72 04		 jb	 SHORT $LN86@SetFavorit
  000be	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000c0	eb 02		 jmp	 SHORT $LN87@SetFavorit
$LN86@SetFavorit:
  000c2	8b cf		 mov	 ecx, edi
$LN87@SetFavorit:
  000c4	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN2@SetFavorit:

; 939  : 
; 940  : 			for (size_t i = 0; i < favorite.Label.size(); ++i)

  000c8	40		 inc	 eax
  000c9	3b 43 58	 cmp	 eax, DWORD PTR [ebx+88]
  000cc	72 d2		 jb	 SHORT $LL4@SetFavorit
  000ce	eb 25		 jmp	 SHORT $LN109@SetFavorit
$LN1055@SetFavorit:

; 943  : 					favorite.Label.at (i) = L'\'';

  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000d5	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN1064@SetFavorit:
$LN5@SetFavorit:

; 944  : 			}
; 945  : 		}
; 946  : 		else
; 947  : 			favorite.Label.clear();

  000da	83 7b 5c 08	 cmp	 DWORD PTR [ebx+92], 8
  000de	8d 7b 48	 lea	 edi, DWORD PTR [ebx+72]
  000e1	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  000e8	72 04		 jb	 SHORT $LN104@SetFavorit
  000ea	8b 07		 mov	 eax, DWORD PTR [edi]
  000ec	eb 02		 jmp	 SHORT $LN105@SetFavorit
$LN104@SetFavorit:
  000ee	8b c7		 mov	 eax, edi
$LN105@SetFavorit:
  000f0	33 c9		 xor	 ecx, ecx
  000f2	66 89 08	 mov	 WORD PTR [eax], cx
$LN109@SetFavorit:

; 948  : 
; 949  : 		favorite.ReadOnly = (IsDlgButtonChecked (hwndDlg, IDC_FAVORITE_MOUNT_READONLY) != 0);

  000f5	68 5d 04 00 00	 push	 1117			; 0000045dH
  000fa	56		 push	 esi
  000fb	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__IsDlgButtonChecked@8
  00101	ff d6		 call	 esi
  00103	85 c0		 test	 eax, eax

; 950  : 		favorite.Removable = (IsDlgButtonChecked (hwndDlg, IDC_FAVORITE_MOUNT_REMOVABLE) != 0);

  00105	68 5e 04 00 00	 push	 1118			; 0000045eH
  0010a	ff b5 28 f7 ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00110	0f 95 c0	 setne	 al
  00113	88 43 65	 mov	 BYTE PTR [ebx+101], al
  00116	ff d6		 call	 esi
  00118	85 c0		 test	 eax, eax
  0011a	0f 95 c0	 setne	 al

; 951  : 
; 952  : 		if (!systemFavoritesMode)

  0011d	80 7d 10 00	 cmp	 BYTE PTR _systemFavoritesMode$[ebp], 0
  00121	88 43 66	 mov	 BYTE PTR [ebx+102], al
  00124	75 54		 jne	 SHORT $LN8@SetFavorit

; 953  : 		{
; 954  : 			favorite.MountOnLogOn = (IsDlgButtonChecked (hwndDlg, IDC_FAVORITE_MOUNT_ON_LOGON) != 0);

  00126	68 62 04 00 00	 push	 1122			; 00000462H
  0012b	ff b5 28 f7 ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00131	ff d6		 call	 esi
  00133	85 c0		 test	 eax, eax

; 955  : 			favorite.MountOnArrival = (IsDlgButtonChecked (hwndDlg, IDC_FAVORITE_MOUNT_ON_ARRIVAL) != 0);

  00135	68 5f 04 00 00	 push	 1119			; 0000045fH
  0013a	ff b5 28 f7 ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00140	0f 95 c0	 setne	 al
  00143	88 43 62	 mov	 BYTE PTR [ebx+98], al
  00146	ff d6		 call	 esi
  00148	85 c0		 test	 eax, eax

; 956  : 			favorite.DisableHotkeyMount = (IsDlgButtonChecked (hwndDlg, IDC_FAVORITE_DISABLE_HOTKEY) != 0);

  0014a	68 63 04 00 00	 push	 1123			; 00000463H
  0014f	ff b5 28 f7 ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  00155	0f 95 c0	 setne	 al
  00158	88 43 63	 mov	 BYTE PTR [ebx+99], al
  0015b	ff d6		 call	 esi
  0015d	85 c0		 test	 eax, eax

; 957  : 			favorite.OpenExplorerWindow = (IsDlgButtonChecked (hwndDlg, IDC_FAVORITE_OPEN_EXPLORER_WIN_ON_MOUNT) != 0);

  0015f	68 68 04 00 00	 push	 1128			; 00000468H
  00164	ff b5 28 f7 ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  0016a	0f 95 c0	 setne	 al
  0016d	88 43 60	 mov	 BYTE PTR [ebx+96], al
  00170	ff d6		 call	 esi
  00172	85 c0		 test	 eax, eax
  00174	0f 95 c0	 setne	 al
  00177	88 43 64	 mov	 BYTE PTR [ebx+100], al
$LN8@SetFavorit:
  0017a	83 7b 40 00	 cmp	 DWORD PTR [ebx+64], 0

; 958  : 		}
; 959  : 
; 960  : 		if (favorite.VolumePathId.empty()
; 961  : 			&& IsVolumeDeviceHosted (favorite.Path.c_str())
; 962  : 			&& favorite.Path.find ("\\\\?\\Volume{") != 0)

  0017e	0f 85 1c 03 00
	00		 jne	 $LN11@SetFavorit
  00184	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00188	72 04		 jb	 SHORT $LN136@SetFavorit
  0018a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0018c	eb 02		 jmp	 SHORT $LN137@SetFavorit
$LN136@SetFavorit:
  0018e	8b c3		 mov	 eax, ebx
$LN137@SetFavorit:
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 _IsVolumeDeviceHosted
  00196	83 c4 04	 add	 esp, 4
  00199	85 c0		 test	 eax, eax
  0019b	0f 84 ff 02 00
	00		 je	 $LN11@SetFavorit
  001a1	6a 0b		 push	 11			; 0000000bH
  001a3	6a 00		 push	 0
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CJEJOKNC@?2?2?$DP?2Volume?$HL?$AA@
  001aa	8b cb		 mov	 ecx, ebx
  001ac	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  001b1	85 c0		 test	 eax, eax
  001b3	0f 84 e7 02 00
	00		 je	 $LN11@SetFavorit

; 963  : 		{
; 964  : 			bool partition = (favorite.Path.find ("\\Partition0") == string::npos);

  001b9	6a 0b		 push	 11			; 0000000bH
  001bb	6a 00		 push	 0
  001bd	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OJHKIMBP@?2Partition0?$AA@
  001c2	8b cb		 mov	 ecx, ebx
  001c4	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  001c9	83 f8 ff	 cmp	 eax, -1
  001cc	0f 94 85 2f f7
	ff ff		 sete	 BYTE PTR _partition$1$[ebp]
  001d3	83 7b 58 00	 cmp	 DWORD PTR [ebx+88], 0

; 965  : 
; 966  : 			if (!favorite.Label.empty())

  001d7	0f 84 68 01 00
	00		 je	 $LN611@SetFavorit

; 967  : 			{
; 968  : 				ErrorDirect ((GetString (partition ? "FAVORITE_LABEL_PARTITION_TYPE_ERR" : "FAVORITE_LABEL_DEVICE_PATH_ERR") + wstring (L"\n\n") + SingleStringToWide (favorite.Path)).c_str());

  001dd	8d 85 48 f7 ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  001e3	53		 push	 ebx
  001e4	50		 push	 eax
  001e5	e8 00 00 00 00	 call	 ?SingleStringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; SingleStringToWide
  001ea	83 c4 08	 add	 esp, 8
  001ed	8b f0		 mov	 esi, eax
  001ef	68 00 00 00 00	 push	 OFFSET ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  001f4	8d 8d a8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  001fa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00201	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00206	80 bd 2f f7 ff
	ff 00		 cmp	 BYTE PTR _partition$1$[ebp], 0
  0020d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BP@JDCKOJKF@FAVORITE_LABEL_DEVICE_PATH_ERR?$AA@
  00212	50		 push	 eax
  00213	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CC@GPNGJACE@FAVORITE_LABEL_PARTITION_TYPE_ER@
  00218	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0021c	0f 44 c1	 cmove	 eax, ecx
  0021f	50		 push	 eax
  00220	e8 00 00 00 00	 call	 _GetString
  00225	83 c4 04	 add	 esp, 4
  00228	50		 push	 eax
  00229	8d 85 c0 f7 ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  0022f	50		 push	 eax
  00230	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W$$QAV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00235	56		 push	 esi
  00236	50		 push	 eax
  00237	8d 85 d8 f7 ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  0023d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00241	50		 push	 eax
  00242	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00247	83 c4 18	 add	 esp, 24			; 00000018H
  0024a	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  0024e	72 02		 jb	 SHORT $LN178@SetFavorit
  00250	8b 00		 mov	 eax, DWORD PTR [eax]
$LN178@SetFavorit:
  00252	50		 push	 eax
  00253	e8 00 00 00 00	 call	 _ErrorDirect
  00258	8b 85 ec f7 ff
	ff		 mov	 eax, DWORD PTR $T9[ebp+20]
  0025e	83 c4 04	 add	 esp, 4
  00261	83 f8 08	 cmp	 eax, 8
  00264	72 13		 jb	 SHORT $LN187@SetFavorit
  00266	40		 inc	 eax
  00267	8d 8d d8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  0026d	50		 push	 eax
  0026e	ff b5 d8 f7 ff
	ff		 push	 DWORD PTR $T9[ebp]
  00274	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN187@SetFavorit:
  00279	33 c0		 xor	 eax, eax
  0027b	c7 85 ec f7 ff
	ff 07 00 00 00	 mov	 DWORD PTR $T9[ebp+20], 7
  00285	66 89 85 d8 f7
	ff ff		 mov	 WORD PTR $T9[ebp], ax
  0028c	8b 85 d4 f7 ff
	ff		 mov	 eax, DWORD PTR $T8[ebp+20]
  00292	c7 85 e8 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+16], 0
  0029c	83 f8 08	 cmp	 eax, 8
  0029f	72 13		 jb	 SHORT $LN290@SetFavorit
  002a1	40		 inc	 eax
  002a2	8d 8d c0 f7 ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  002a8	50		 push	 eax
  002a9	ff b5 c0 f7 ff
	ff		 push	 DWORD PTR $T8[ebp]
  002af	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN290@SetFavorit:
  002b4	33 c0		 xor	 eax, eax
  002b6	c7 85 d4 f7 ff
	ff 07 00 00 00	 mov	 DWORD PTR $T8[ebp+20], 7
  002c0	66 89 85 c0 f7
	ff ff		 mov	 WORD PTR $T8[ebp], ax
  002c7	8b 85 bc f7 ff
	ff		 mov	 eax, DWORD PTR $T7[ebp+20]
  002cd	c7 85 d0 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+16], 0
  002d7	83 f8 08	 cmp	 eax, 8
  002da	72 13		 jb	 SHORT $LN393@SetFavorit
  002dc	40		 inc	 eax
  002dd	8d 8d a8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  002e3	50		 push	 eax
  002e4	ff b5 a8 f7 ff
	ff		 push	 DWORD PTR $T7[ebp]
  002ea	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN393@SetFavorit:
  002ef	33 c0		 xor	 eax, eax
  002f1	c7 85 bc f7 ff
	ff 07 00 00 00	 mov	 DWORD PTR $T7[ebp+20], 7
  002fb	66 89 85 a8 f7
	ff ff		 mov	 WORD PTR $T7[ebp], ax
  00302	8b 85 5c f7 ff
	ff		 mov	 eax, DWORD PTR $T3[ebp+20]
  00308	c7 85 b8 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+16], 0
  00312	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00319	83 f8 08	 cmp	 eax, 8
  0031c	72 13		 jb	 SHORT $LN496@SetFavorit
  0031e	40		 inc	 eax
  0031f	8d 8d 48 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00325	50		 push	 eax
  00326	ff b5 48 f7 ff
	ff		 push	 DWORD PTR $T3[ebp]
  0032c	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN496@SetFavorit:

; 969  : 				favorite.Label.clear();

  00331	83 7f 14 08	 cmp	 DWORD PTR [edi+20], 8
  00335	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  0033c	72 02		 jb	 SHORT $LN607@SetFavorit
  0033e	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN607@SetFavorit:
  00340	33 c0		 xor	 eax, eax
  00342	66 89 07	 mov	 WORD PTR [edi], ax
$LN611@SetFavorit:

; 970  : 			}
; 971  : 
; 972  : 			if (favorite.MountOnArrival)

  00345	80 7b 63 00	 cmp	 BYTE PTR [ebx+99], 0
  00349	0f 84 90 01 00
	00		 je	 $LN12@SetFavorit

; 973  : 			{
; 974  : 				ErrorDirect ((GetString (partition ? "FAVORITE_ARRIVAL_MOUNT_PARTITION_TYPE_ERR" : "FAVORITE_ARRIVAL_MOUNT_DEVICE_PATH_ERR") + wstring (L"\n\n") + SingleStringToWide (favorite.Path)).c_str());

  0034f	8d 85 30 f7 ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00355	53		 push	 ebx
  00356	50		 push	 eax
  00357	e8 00 00 00 00	 call	 ?SingleStringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; SingleStringToWide
  0035c	83 c4 08	 add	 esp, 8
  0035f	8b f0		 mov	 esi, eax
  00361	68 00 00 00 00	 push	 OFFSET ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  00366	8d 8d 60 f7 ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0036c	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00373	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00378	80 bd 2f f7 ff
	ff 00		 cmp	 BYTE PTR _partition$1$[ebp], 0
  0037f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CH@DKBAOJFF@FAVORITE_ARRIVAL_MOUNT_DEVICE_PA@
  00384	50		 push	 eax
  00385	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CK@BMBODKOP@FAVORITE_ARRIVAL_MOUNT_PARTITION@
  0038a	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0038e	0f 44 c1	 cmove	 eax, ecx
  00391	50		 push	 eax
  00392	e8 00 00 00 00	 call	 _GetString
  00397	83 c4 04	 add	 esp, 4
  0039a	50		 push	 eax
  0039b	8d 85 78 f7 ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  003a1	50		 push	 eax
  003a2	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W$$QAV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  003a7	56		 push	 esi
  003a8	50		 push	 eax
  003a9	8d 85 90 f7 ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  003af	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  003b3	50		 push	 eax
  003b4	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  003b9	83 c4 18	 add	 esp, 24			; 00000018H
  003bc	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  003c0	72 02		 jb	 SHORT $LN627@SetFavorit
  003c2	8b 00		 mov	 eax, DWORD PTR [eax]
$LN627@SetFavorit:
  003c4	50		 push	 eax
  003c5	e8 00 00 00 00	 call	 _ErrorDirect
  003ca	8b 85 a4 f7 ff
	ff		 mov	 eax, DWORD PTR $T6[ebp+20]
  003d0	83 c4 04	 add	 esp, 4
  003d3	83 f8 08	 cmp	 eax, 8
  003d6	72 13		 jb	 SHORT $LN636@SetFavorit
  003d8	40		 inc	 eax
  003d9	8d 8d 90 f7 ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  003df	50		 push	 eax
  003e0	ff b5 90 f7 ff
	ff		 push	 DWORD PTR $T6[ebp]
  003e6	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN636@SetFavorit:
  003eb	33 c0		 xor	 eax, eax
  003ed	c7 85 a4 f7 ff
	ff 07 00 00 00	 mov	 DWORD PTR $T6[ebp+20], 7
  003f7	66 89 85 90 f7
	ff ff		 mov	 WORD PTR $T6[ebp], ax
  003fe	8b 85 8c f7 ff
	ff		 mov	 eax, DWORD PTR $T5[ebp+20]
  00404	c7 85 a0 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+16], 0
  0040e	83 f8 08	 cmp	 eax, 8
  00411	72 13		 jb	 SHORT $LN739@SetFavorit
  00413	40		 inc	 eax
  00414	8d 8d 78 f7 ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0041a	50		 push	 eax
  0041b	ff b5 78 f7 ff
	ff		 push	 DWORD PTR $T5[ebp]
  00421	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN739@SetFavorit:
  00426	33 c0		 xor	 eax, eax
  00428	c7 85 8c f7 ff
	ff 07 00 00 00	 mov	 DWORD PTR $T5[ebp+20], 7
  00432	66 89 85 78 f7
	ff ff		 mov	 WORD PTR $T5[ebp], ax
  00439	8b 85 74 f7 ff
	ff		 mov	 eax, DWORD PTR $T4[ebp+20]
  0043f	c7 85 88 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+16], 0
  00449	83 f8 08	 cmp	 eax, 8
  0044c	72 13		 jb	 SHORT $LN842@SetFavorit
  0044e	40		 inc	 eax
  0044f	8d 8d 60 f7 ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00455	50		 push	 eax
  00456	ff b5 60 f7 ff
	ff		 push	 DWORD PTR $T4[ebp]
  0045c	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN842@SetFavorit:
  00461	33 c0		 xor	 eax, eax
  00463	c7 85 74 f7 ff
	ff 07 00 00 00	 mov	 DWORD PTR $T4[ebp+20], 7
  0046d	66 89 85 60 f7
	ff ff		 mov	 WORD PTR $T4[ebp], ax
  00474	8b 85 44 f7 ff
	ff		 mov	 eax, DWORD PTR $T2[ebp+20]
  0047a	c7 85 70 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+16], 0
  00484	83 f8 08	 cmp	 eax, 8
  00487	72 13		 jb	 SHORT $LN945@SetFavorit
  00489	40		 inc	 eax
  0048a	8d 8d 30 f7 ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00490	50		 push	 eax
  00491	ff b5 30 f7 ff
	ff		 push	 DWORD PTR $T2[ebp]
  00497	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN945@SetFavorit:

; 975  : 				favorite.MountOnArrival = false;

  0049c	c6 43 63 00	 mov	 BYTE PTR [ebx+99], 0
$LN11@SetFavorit:

; 976  : 			}
; 977  : 		}
; 978  : 
; 979  : 		if (favorite.MountOnArrival && favorite.Path.find ("\\\\") == 0 && favorite.Path.find ("Volume{") == string::npos)

  004a0	80 7b 63 00	 cmp	 BYTE PTR [ebx+99], 0
  004a4	74 39		 je	 SHORT $LN12@SetFavorit
  004a6	6a 02		 push	 2
  004a8	6a 00		 push	 0
  004aa	68 00 00 00 00	 push	 OFFSET ??_C@_02HDBGODGB@?2?2?$AA@
  004af	8b cb		 mov	 ecx, ebx
  004b1	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  004b6	85 c0		 test	 eax, eax
  004b8	75 25		 jne	 SHORT $LN12@SetFavorit
  004ba	6a 07		 push	 7
  004bc	50		 push	 eax
  004bd	68 00 00 00 00	 push	 OFFSET ??_C@_07HBPFMAGN@Volume?$HL?$AA@
  004c2	8b cb		 mov	 ecx, ebx
  004c4	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  004c9	83 f8 ff	 cmp	 eax, -1
  004cc	75 11		 jne	 SHORT $LN12@SetFavorit

; 980  : 		{
; 981  : 			Error ("FAVORITE_ARRIVAL_MOUNT_NETWORK_PATH_ERR");

  004ce	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HPPIJBMN@FAVORITE_ARRIVAL_MOUNT_NETWORK_P@
  004d3	e8 00 00 00 00	 call	 _Error
  004d8	83 c4 04	 add	 esp, 4

; 982  : 			favorite.MountOnArrival = false;

  004db	c6 43 63 00	 mov	 BYTE PTR [ebx+99], 0
$LN12@SetFavorit:

; 983  : 		}
; 984  : 	}

  004df	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004e2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004e9	59		 pop	 ecx
  004ea	5f		 pop	 edi
  004eb	5e		 pop	 esi
  004ec	5b		 pop	 ebx
  004ed	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004f0	33 cd		 xor	 ecx, ebp
  004f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004f7	8b e5		 mov	 esp, ebp
  004f9	5d		 pop	 ebp
  004fa	c3		 ret	 0
$LN1062@SetFavorit:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z$0:
  00000	8d 8d 48 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z$1:
  0000b	8d 8d a8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z$2:
  00016	8d 8d c0 f7 ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z$4:
  00021	8d 8d 30 f7 ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z$5:
  0002c	8d 8d 60 f7 ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z$6:
  00037	8d 8d 78 f7 ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z:
  00042	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00046	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00049	8b 8a 24 f7 ff
	ff		 mov	 ecx, DWORD PTR [edx-2268]
  0004f	33 c8		 xor	 ecx, eax
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00059	33 c8		 xor	 ecx, eax
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z
  00065	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z ENDP ; GostCrypt::SetFavoriteVolume
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ?SetControls@GostCrypt@@YAXPAUHWND__@@ABUFavoriteVolume@1@_N2@Z
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
tv337 = 12						; size = 4
_favorite$ = 12						; size = 4
_systemFavoritesMode$ = 16				; size = 1
_enable$ = 20						; size = 1
?SetControls@GostCrypt@@YAXPAUHWND__@@ABUFavoriteVolume@1@_N2@Z PROC ; GostCrypt::SetControls, COMDAT

; 886  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 887  : 		SetDlgItemTextW (hwndDlg, IDC_FAVORITE_LABEL, favorite.Label.c_str());

  00005	8b 75 0c	 mov	 esi, DWORD PTR _favorite$[ebp]
  00008	83 7e 5c 08	 cmp	 DWORD PTR [esi+92], 8
  0000c	8d 46 48	 lea	 eax, DWORD PTR [esi+72]
  0000f	57		 push	 edi
  00010	72 02		 jb	 SHORT $LN26@SetControl
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
$LN26@SetControl:
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _hwndDlg$[ebp]
  00017	50		 push	 eax
  00018	68 60 04 00 00	 push	 1120			; 00000460H
  0001d	53		 push	 ebx
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemTextW@12

; 888  : 		SetCheckBox (hwndDlg, IDC_FAVORITE_MOUNT_ON_LOGON, favorite.MountOnLogOn);

  00024	0f b6 46 62	 movzx	 eax, BYTE PTR [esi+98]
  00028	50		 push	 eax
  00029	68 62 04 00 00	 push	 1122			; 00000462H
  0002e	53		 push	 ebx
  0002f	e8 00 00 00 00	 call	 _SetCheckBox

; 889  : 		SetCheckBox (hwndDlg, IDC_FAVORITE_MOUNT_ON_ARRIVAL, favorite.MountOnArrival);

  00034	0f b6 46 63	 movzx	 eax, BYTE PTR [esi+99]
  00038	50		 push	 eax
  00039	68 5f 04 00 00	 push	 1119			; 0000045fH
  0003e	53		 push	 ebx
  0003f	e8 00 00 00 00	 call	 _SetCheckBox

; 890  : 		SetCheckBox (hwndDlg, IDC_FAVORITE_MOUNT_READONLY, favorite.ReadOnly);

  00044	0f b6 46 65	 movzx	 eax, BYTE PTR [esi+101]
  00048	50		 push	 eax
  00049	68 5d 04 00 00	 push	 1117			; 0000045dH
  0004e	53		 push	 ebx
  0004f	e8 00 00 00 00	 call	 _SetCheckBox

; 891  : 		SetCheckBox (hwndDlg, IDC_FAVORITE_MOUNT_REMOVABLE, favorite.Removable);

  00054	0f b6 46 66	 movzx	 eax, BYTE PTR [esi+102]
  00058	50		 push	 eax
  00059	68 5e 04 00 00	 push	 1118			; 0000045eH
  0005e	53		 push	 ebx
  0005f	e8 00 00 00 00	 call	 _SetCheckBox
  00064	83 c4 30	 add	 esp, 48			; 00000030H

; 892  : 
; 893  : 		if (systemFavoritesMode)

  00067	80 7d 10 00	 cmp	 BYTE PTR _systemFavoritesMode$[ebp], 0
  0006b	74 2e		 je	 SHORT $LN2@SetControl

; 894  : 		{
; 895  : 			uint32 driverConfig = ReadDriverConfigurationFlags();

  0006d	e8 00 00 00 00	 call	 _ReadDriverConfigurationFlags

; 896  : 
; 897  : 			// MOUNT_SYSTEM_FAVORITES_ON_BOOT
; 898  : 			CheckDlgButton (hwndDlg, IDC_FAVORITE_OPEN_EXPLORER_WIN_ON_MOUNT, (driverConfig & GST_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES) ? BST_CHECKED : BST_UNCHECKED);

  00072	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CheckDlgButton@12
  00078	8b f8		 mov	 edi, eax
  0007a	8b cf		 mov	 ecx, edi
  0007c	d1 e9		 shr	 ecx, 1
  0007e	83 e1 01	 and	 ecx, 1
  00081	51		 push	 ecx
  00082	68 68 04 00 00	 push	 1128			; 00000468H
  00087	53		 push	 ebx
  00088	ff d6		 call	 esi

; 899  : 
; 900  : 			// DISABLE_NONADMIN_SYS_FAVORITES_ACCESS
; 901  : 			CheckDlgButton (hwndDlg, IDC_FAVORITE_DISABLE_HOTKEY, (driverConfig & GST_DRIVER_CONFIG_DISABLE_NONADMIN_SYS_FAVORITES_ACCESS) ? BST_CHECKED : BST_UNCHECKED);

  0008a	c1 ef 02	 shr	 edi, 2
  0008d	83 e7 01	 and	 edi, 1
  00090	57		 push	 edi
  00091	68 63 04 00 00	 push	 1123			; 00000463H
  00096	53		 push	 ebx
  00097	ff d6		 call	 esi

; 902  : 		}
; 903  : 		else

  00099	eb 23		 jmp	 SHORT $LN3@SetControl
$LN2@SetControl:

; 904  : 		{
; 905  : 			SetCheckBox (hwndDlg, IDC_FAVORITE_OPEN_EXPLORER_WIN_ON_MOUNT, favorite.OpenExplorerWindow);

  0009b	0f b6 46 64	 movzx	 eax, BYTE PTR [esi+100]
  0009f	50		 push	 eax
  000a0	68 68 04 00 00	 push	 1128			; 00000468H
  000a5	53		 push	 ebx
  000a6	e8 00 00 00 00	 call	 _SetCheckBox

; 906  : 			SetCheckBox (hwndDlg, IDC_FAVORITE_DISABLE_HOTKEY, favorite.DisableHotkeyMount);

  000ab	0f b6 46 60	 movzx	 eax, BYTE PTR [esi+96]
  000af	50		 push	 eax
  000b0	68 63 04 00 00	 push	 1123			; 00000463H
  000b5	53		 push	 ebx
  000b6	e8 00 00 00 00	 call	 _SetCheckBox
  000bb	83 c4 18	 add	 esp, 24			; 00000018H
$LN3@SetControl:

; 907  : 		}
; 908  : 
; 909  : 		EnableWindow (GetDlgItem (hwndDlg, IDC_FAVORITE_MOVE_UP), enable);

  000be	0f b6 45 14	 movzx	 eax, BYTE PTR _enable$[ebp]
  000c2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  000c8	50		 push	 eax
  000c9	68 64 04 00 00	 push	 1124			; 00000464H
  000ce	53		 push	 ebx
  000cf	89 45 0c	 mov	 DWORD PTR tv337[ebp], eax
  000d2	ff d6		 call	 esi
  000d4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__EnableWindow@8
  000da	50		 push	 eax
  000db	ff d7		 call	 edi

; 910  : 		EnableWindow (GetDlgItem (hwndDlg, IDC_FAVORITE_MOVE_DOWN), enable);

  000dd	ff 75 0c	 push	 DWORD PTR tv337[ebp]
  000e0	68 65 04 00 00	 push	 1125			; 00000465H
  000e5	53		 push	 ebx
  000e6	ff d6		 call	 esi
  000e8	50		 push	 eax
  000e9	ff d7		 call	 edi

; 911  : 		EnableWindow (GetDlgItem (hwndDlg, IDC_FAVORITE_REMOVE), enable);

  000eb	ff 75 0c	 push	 DWORD PTR tv337[ebp]
  000ee	68 66 04 00 00	 push	 1126			; 00000466H
  000f3	53		 push	 ebx
  000f4	ff d6		 call	 esi
  000f6	50		 push	 eax
  000f7	ff d7		 call	 edi

; 912  : 		EnableWindow (GetDlgItem (hwndDlg, IDT_FAVORITE_LABEL), enable);

  000f9	ff 75 0c	 push	 DWORD PTR tv337[ebp]
  000fc	68 61 04 00 00	 push	 1121			; 00000461H
  00101	53		 push	 ebx
  00102	ff d6		 call	 esi
  00104	50		 push	 eax
  00105	ff d7		 call	 edi

; 913  : 		EnableWindow (GetDlgItem (hwndDlg, IDC_FAVORITE_LABEL), enable);

  00107	ff 75 0c	 push	 DWORD PTR tv337[ebp]
  0010a	68 60 04 00 00	 push	 1120			; 00000460H
  0010f	53		 push	 ebx
  00110	ff d6		 call	 esi
  00112	50		 push	 eax
  00113	ff d7		 call	 edi

; 914  : 		EnableWindow (GetDlgItem (hwndDlg, IDC_FAVORITE_MOUNT_ON_LOGON), enable && !systemFavoritesMode);

  00115	80 7d 14 00	 cmp	 BYTE PTR _enable$[ebp], 0
  00119	74 0d		 je	 SHORT $LN5@SetControl
  0011b	80 7d 10 00	 cmp	 BYTE PTR _systemFavoritesMode$[ebp], 0
  0011f	75 07		 jne	 SHORT $LN5@SetControl
  00121	b8 01 00 00 00	 mov	 eax, 1
  00126	eb 02		 jmp	 SHORT $LN6@SetControl
$LN5@SetControl:
  00128	33 c0		 xor	 eax, eax
$LN6@SetControl:
  0012a	50		 push	 eax
  0012b	68 62 04 00 00	 push	 1122			; 00000462H
  00130	53		 push	 ebx
  00131	ff d6		 call	 esi
  00133	50		 push	 eax
  00134	ff d7		 call	 edi

; 915  : 		EnableWindow (GetDlgItem (hwndDlg, IDC_FAVORITE_MOUNT_ON_ARRIVAL), enable && !systemFavoritesMode);

  00136	80 7d 14 00	 cmp	 BYTE PTR _enable$[ebp], 0
  0013a	74 0d		 je	 SHORT $LN7@SetControl
  0013c	80 7d 10 00	 cmp	 BYTE PTR _systemFavoritesMode$[ebp], 0
  00140	75 07		 jne	 SHORT $LN7@SetControl
  00142	b8 01 00 00 00	 mov	 eax, 1
  00147	eb 02		 jmp	 SHORT $LN8@SetControl
$LN7@SetControl:
  00149	33 c0		 xor	 eax, eax
$LN8@SetControl:
  0014b	50		 push	 eax
  0014c	68 5f 04 00 00	 push	 1119			; 0000045fH
  00151	53		 push	 ebx
  00152	ff d6		 call	 esi
  00154	50		 push	 eax
  00155	ff d7		 call	 edi

; 916  : 		EnableWindow (GetDlgItem (hwndDlg, IDC_FAVORITE_MOUNT_READONLY), enable);

  00157	ff 75 0c	 push	 DWORD PTR tv337[ebp]
  0015a	68 5d 04 00 00	 push	 1117			; 0000045dH
  0015f	53		 push	 ebx
  00160	ff d6		 call	 esi
  00162	50		 push	 eax
  00163	ff d7		 call	 edi

; 917  : 		EnableWindow (GetDlgItem (hwndDlg, IDC_FAVORITE_MOUNT_REMOVABLE), enable);

  00165	ff 75 0c	 push	 DWORD PTR tv337[ebp]
  00168	68 5e 04 00 00	 push	 1118			; 0000045eH
  0016d	53		 push	 ebx
  0016e	ff d6		 call	 esi
  00170	50		 push	 eax
  00171	ff d7		 call	 edi

; 918  : 		EnableWindow (GetDlgItem (hwndDlg, IDC_FAVORITE_OPEN_EXPLORER_WIN_ON_MOUNT), enable || systemFavoritesMode);

  00173	80 7d 14 00	 cmp	 BYTE PTR _enable$[ebp], 0
  00177	75 0a		 jne	 SHORT $LN9@SetControl
  00179	80 7d 10 00	 cmp	 BYTE PTR _systemFavoritesMode$[ebp], 0
  0017d	75 04		 jne	 SHORT $LN9@SetControl
  0017f	33 c0		 xor	 eax, eax
  00181	eb 05		 jmp	 SHORT $LN10@SetControl
$LN9@SetControl:
  00183	b8 01 00 00 00	 mov	 eax, 1
$LN10@SetControl:
  00188	50		 push	 eax
  00189	68 68 04 00 00	 push	 1128			; 00000468H
  0018e	53		 push	 ebx
  0018f	ff d6		 call	 esi
  00191	50		 push	 eax
  00192	ff d7		 call	 edi

; 919  : 		EnableWindow (GetDlgItem (hwndDlg, IDC_FAVORITE_DISABLE_HOTKEY), enable || systemFavoritesMode);

  00194	80 7d 14 00	 cmp	 BYTE PTR _enable$[ebp], 0
  00198	75 19		 jne	 SHORT $LN11@SetControl
  0019a	80 7d 10 00	 cmp	 BYTE PTR _systemFavoritesMode$[ebp], 0
  0019e	75 13		 jne	 SHORT $LN11@SetControl
  001a0	33 c0		 xor	 eax, eax
  001a2	50		 push	 eax
  001a3	68 63 04 00 00	 push	 1123			; 00000463H
  001a8	53		 push	 ebx
  001a9	ff d6		 call	 esi
  001ab	50		 push	 eax
  001ac	ff d7		 call	 edi
  001ae	5f		 pop	 edi
  001af	5e		 pop	 esi
  001b0	5b		 pop	 ebx

; 920  : 	}

  001b1	5d		 pop	 ebp
  001b2	c3		 ret	 0
$LN11@SetControl:

; 919  : 		EnableWindow (GetDlgItem (hwndDlg, IDC_FAVORITE_DISABLE_HOTKEY), enable || systemFavoritesMode);

  001b3	b8 01 00 00 00	 mov	 eax, 1
  001b8	50		 push	 eax
  001b9	68 63 04 00 00	 push	 1123			; 00000463H
  001be	53		 push	 ebx
  001bf	ff d6		 call	 esi
  001c1	50		 push	 eax
  001c2	ff d7		 call	 edi
  001c4	5f		 pop	 edi
  001c5	5e		 pop	 esi
  001c6	5b		 pop	 ebx

; 920  : 	}

  001c7	5d		 pop	 ebp
  001c8	c3		 ret	 0
?SetControls@GostCrypt@@YAXPAUHWND__@@ABUFavoriteVolume@1@_N2@Z ENDP ; GostCrypt::SetControls
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z
_TEXT	SEGMENT
_e$2 = -3768						; size = 4
tv4254 = -3764						; size = 4
_f$1$ = -3760						; size = 4
_$S9$3 = -3756						; size = 28
_cnt$ = -3728						; size = 4
_finally831$4 = -3721					; size = 1
_systemFavorites$GSCopy$ = -3720			; size = 1
_bootEnc$ = -3716					; size = 1480
$T5 = -2236						; size = 24
$T6 = -2212						; size = 24
$T7 = -2188						; size = 24
$T8 = -2188						; size = 24
$T9 = -2164						; size = 24
$T10 = -2164						; size = 24
$T11 = -2164						; size = 24
_s$12 = -2140						; size = 24
$T13 = -2116						; size = 24
$T14 = -2116						; size = 24
$T15 = -2116						; size = 24
$T16 = -2116						; size = 24
$T17 = -2116						; size = 24
$T18 = -2092						; size = 24
$T19 = -2092						; size = 24
$T20 = -2092						; size = 24
_tq$21 = -2068						; size = 2048
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_favorites$ = 8						; size = 4
_systemFavorites$ = 12					; size = 1
?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z PROC ; GostCrypt::SaveFavoriteVolumes, COMDAT

; 761  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec ac 0e 00
	00		 sub	 esp, 3756		; 00000eacH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8a 45 0c	 mov	 al, BYTE PTR _systemFavorites$[ebp]

; 762  : 		FILE *f;
; 763  : 		int cnt = 0;

  00034	33 db		 xor	 ebx, ebx
  00036	8b 75 08	 mov	 esi, DWORD PTR _favorites$[ebp]

; 764  : 
; 765  : 		f = fopen (GetConfigPath (systemFavorites ? GST_APPD_FILENAME_SYSTEM_FAVORITE_VOLUMES : GST_APPD_FILENAME_FAVORITE_VOLUMES), "w,ccs=UTF-8");

  00039	84 c0		 test	 al, al
  0003b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BF@EGBOIEGJ@Favorite?5Volumes?4xml?$AA@
  00040	88 85 78 f1 ff
	ff		 mov	 BYTE PTR _systemFavorites$GSCopy$[ebp], al
  00046	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@
  0004b	89 9d 70 f1 ff
	ff		 mov	 DWORD PTR _cnt$[ebp], ebx
  00051	0f 44 ca	 cmove	 ecx, edx
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OEIOICOO@w?0ccs?$DNUTF?98?$AA@
  00059	51		 push	 ecx
  0005a	89 8d 4c f1 ff
	ff		 mov	 DWORD PTR tv4254[ebp], ecx
  00060	e8 00 00 00 00	 call	 _GetConfigPath
  00065	83 c4 04	 add	 esp, 4
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _fopen
  0006e	8b f8		 mov	 edi, eax
  00070	83 c4 08	 add	 esp, 8
  00073	89 bd 50 f1 ff
	ff		 mov	 DWORD PTR _f$1$[ebp], edi

; 766  : 		if (f == NULL)

  00079	85 ff		 test	 edi, edi
  0007b	75 15		 jne	 SHORT $LN8@SaveFavori

; 767  : 		{
; 768  : 			handleWin32Error (MainDlg);

  0007d	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00083	e8 00 00 00 00	 call	 _handleWin32Error
  00088	83 c4 04	 add	 esp, 4

; 769  : 			return false;

  0008b	32 c0		 xor	 al, al
  0008d	e9 21 0a 00 00	 jmp	 $LN1@SaveFavori
$LN8@SaveFavori:

; 770  : 		}
; 771  : 
; 772  : 		XmlWriteHeaderW (f);

  00092	57		 push	 edi
  00093	e8 00 00 00 00	 call	 _XmlWriteHeaderW

; 773  : 		fputws (L"\n\t<favorites>", f);

  00098	57		 push	 edi
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@LHCEIKFH@?$AA?6?$AA?7?$AA?$DM?$AAf?$AAa?$AAv?$AAo?$AAr?$AAi?$AAt?$AAe?$AAs?$AA?$DO?$AA?$AA@
  0009e	e8 00 00 00 00	 call	 _fputws

; 774  : 
; 775  : 		foreach (const FavoriteVolume &favorite, favorites)

  000a3	8d 85 54 f1 ff
	ff		 lea	 eax, DWORD PTR _$S9$3[ebp]
  000a9	56		 push	 esi
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
  000b0	83 c4 14	 add	 esp, 20			; 00000014H
  000b3	8b 85 54 f1 ff
	ff		 mov	 eax, DWORD PTR _$S9$3[ebp]
  000b9	8d 8d 54 f1 ff
	ff		 lea	 ecx, DWORD PTR _$S9$3[ebp]
  000bf	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000c6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c9	ff d0		 call	 eax
  000cb	84 c0		 test	 al, al
  000cd	0f 84 d0 06 00
	00		 je	 $LN1869@SaveFavori
  000d3	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL4@SaveFavori:
  000e0	8b b5 6c f1 ff
	ff		 mov	 esi, DWORD PTR _$S9$3[ebp+24]
  000e6	33 c0		 xor	 eax, eax
  000e8	38 85 59 f1 ff
	ff		 cmp	 BYTE PTR _$S9$3[ebp+5], al
  000ee	0f 94 c0	 sete	 al
  000f1	88 85 59 f1 ff
	ff		 mov	 BYTE PTR _$S9$3[ebp+5], al
  000f7	84 c0		 test	 al, al
  000f9	0f 84 7c 06 00
	00		 je	 $LN2@SaveFavori
  000ff	90		 npad	 1
$LL7@SaveFavori:

; 776  : 		{
; 777  : 			char tq[2048];
; 778  : 
; 779  : 			if (systemFavorites && favorite.Path.find ("\\\\") == 0 && favorite.Path.find ("Volume{") == string::npos)

  00100	80 bd 78 f1 ff
	ff 00		 cmp	 BYTE PTR _systemFavorites$GSCopy$[ebp], 0
  00107	74 35		 je	 SHORT $LN9@SaveFavori
  00109	6a 02		 push	 2
  0010b	6a 00		 push	 0
  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_02HDBGODGB@?2?2?$AA@
  00112	8b ce		 mov	 ecx, esi
  00114	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00119	85 c0		 test	 eax, eax
  0011b	75 21		 jne	 SHORT $LN9@SaveFavori
  0011d	6a 07		 push	 7
  0011f	50		 push	 eax
  00120	68 00 00 00 00	 push	 OFFSET ??_C@_07HBPFMAGN@Volume?$HL?$AA@
  00125	8b ce		 mov	 ecx, esi
  00127	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0012c	83 f8 ff	 cmp	 eax, -1
  0012f	75 0d		 jne	 SHORT $LN9@SaveFavori

; 780  : 				Warning ("SYSTEM_FAVORITE_NETWORK_PATH_ERR");

  00131	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@FDMOEEOH@SYSTEM_FAVORITE_NETWORK_PATH_ERR@
  00136	e8 00 00 00 00	 call	 _Warning
  0013b	83 c4 04	 add	 esp, 4
$LN9@SaveFavori:
  0013e	83 7e 40 00	 cmp	 DWORD PTR [esi+64], 0

; 781  : 
; 782  : 			XmlQuoteText (!favorite.VolumePathId.empty() ? favorite.VolumePathId.c_str() : favorite.Path.c_str(), tq, sizeof (tq));

  00142	74 0d		 je	 SHORT $LN31@SaveFavori
  00144	83 7e 44 10	 cmp	 DWORD PTR [esi+68], 16	; 00000010H
  00148	8d 46 30	 lea	 eax, DWORD PTR [esi+48]
  0014b	72 10		 jb	 SHORT $LN121@SaveFavori
  0014d	8b 00		 mov	 eax, DWORD PTR [eax]
  0014f	eb 0c		 jmp	 SHORT $LN121@SaveFavori
$LN31@SaveFavori:
  00151	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00155	72 04		 jb	 SHORT $LN133@SaveFavori
  00157	8b 06		 mov	 eax, DWORD PTR [esi]
  00159	eb 02		 jmp	 SHORT $LN121@SaveFavori
$LN133@SaveFavori:
  0015b	8b c6		 mov	 eax, esi
$LN121@SaveFavori:
  0015d	68 00 08 00 00	 push	 2048			; 00000800H
  00162	8d 8d ec f7 ff
	ff		 lea	 ecx, DWORD PTR _tq$21[ebp]
  00168	51		 push	 ecx
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 _XmlQuoteText

; 783  : 
; 784  : 			wstring s = L"\n\t\t<volume mountpoint=\"" + SingleStringToWide (favorite.MountPoint) + L"\"";

  0016f	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  00172	50		 push	 eax
  00173	8d 85 44 f7 ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00179	50		 push	 eax
  0017a	e8 00 00 00 00	 call	 ?SingleStringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; SingleStringToWide
  0017f	50		 push	 eax
  00180	8d 85 5c f7 ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00186	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_1DA@FKMFKHK@?$AA?6?$AA?7?$AA?7?$AA?$DM?$AAv?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAm?$AAo?$AAu?$AAn?$AAt?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?$DN?$AA?$CC?$AA?$AA@
  0018f	50		 push	 eax
  00190	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W$$QAV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_13NEIAEHFG@?$AA?$CC?$AA?$AA@
  0019a	50		 push	 eax
  0019b	8d 85 a4 f7 ff
	ff		 lea	 eax, DWORD PTR _s$12[ebp]
  001a1	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  001a5	50		 push	 eax
  001a6	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  001ab	83 c4 2c	 add	 esp, 44			; 0000002cH
  001ae	8b 85 70 f7 ff
	ff		 mov	 eax, DWORD PTR $T6[ebp+20]
  001b4	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  001b8	83 f8 08	 cmp	 eax, 8
  001bb	72 4e		 jb	 SHORT $LN225@SaveFavori
  001bd	8b 8d 5c f7 ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
  001c3	40		 inc	 eax
  001c4	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  001c9	0f 87 65 06 00
	00		 ja	 $LN1814@SaveFavori
  001cf	03 c0		 add	 eax, eax
  001d1	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  001d6	72 2a		 jb	 SHORT $LN220@SaveFavori
  001d8	f6 c1 1f	 test	 cl, 31			; 0000001fH
  001db	0f 85 53 06 00
	00		 jne	 $LN1814@SaveFavori
  001e1	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  001e4	3b c1		 cmp	 eax, ecx
  001e6	0f 83 48 06 00
	00		 jae	 $LN1814@SaveFavori
  001ec	2b c8		 sub	 ecx, eax
  001ee	83 f9 04	 cmp	 ecx, 4
  001f1	0f 82 3d 06 00
	00		 jb	 $LN1814@SaveFavori
  001f7	83 f9 23	 cmp	 ecx, 35			; 00000023H
  001fa	0f 87 34 06 00
	00		 ja	 $LN1814@SaveFavori
  00200	8b c8		 mov	 ecx, eax
$LN220@SaveFavori:
  00202	51		 push	 ecx
  00203	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00208	83 c4 04	 add	 esp, 4
$LN225@SaveFavori:
  0020b	33 c0		 xor	 eax, eax
  0020d	c7 85 70 f7 ff
	ff 07 00 00 00	 mov	 DWORD PTR $T6[ebp+20], 7
  00217	c7 85 6c f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+16], 0
  00221	66 89 85 5c f7
	ff ff		 mov	 WORD PTR $T6[ebp], ax
  00228	8b 85 58 f7 ff
	ff		 mov	 eax, DWORD PTR $T5[ebp+20]
  0022e	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  00232	83 f8 08	 cmp	 eax, 8
  00235	72 4e		 jb	 SHORT $LN345@SaveFavori
  00237	8b 8d 44 f7 ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  0023d	40		 inc	 eax
  0023e	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00243	0f 87 eb 05 00
	00		 ja	 $LN1814@SaveFavori
  00249	03 c0		 add	 eax, eax
  0024b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00250	72 2a		 jb	 SHORT $LN340@SaveFavori
  00252	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00255	0f 85 d9 05 00
	00		 jne	 $LN1814@SaveFavori
  0025b	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0025e	3b c1		 cmp	 eax, ecx
  00260	0f 83 ce 05 00
	00		 jae	 $LN1814@SaveFavori
  00266	2b c8		 sub	 ecx, eax
  00268	83 f9 04	 cmp	 ecx, 4
  0026b	0f 82 c3 05 00
	00		 jb	 $LN1814@SaveFavori
  00271	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00274	0f 87 ba 05 00
	00		 ja	 $LN1814@SaveFavori
  0027a	8b c8		 mov	 ecx, eax
$LN340@SaveFavori:
  0027c	51		 push	 ecx
  0027d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00282	83 c4 04	 add	 esp, 4
$LN345@SaveFavori:
  00285	33 c0		 xor	 eax, eax
  00287	c7 85 58 f7 ff
	ff 07 00 00 00	 mov	 DWORD PTR $T5[ebp+20], 7
  00291	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  00295	66 89 85 44 f7
	ff ff		 mov	 WORD PTR $T5[ebp], ax

; 785  : 
; 786  : 			if (!favorite.Label.empty())

  0029c	8d 46 48	 lea	 eax, DWORD PTR [esi+72]
  0029f	c7 85 54 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+16], 0
  002a9	0f 84 16 01 00
	00		 je	 $LN599@SaveFavori

; 787  : 				s += L" label=\"" + favorite.Label + L"\"";

  002af	50		 push	 eax
  002b0	8d 85 bc f7 ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  002b6	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@IMCPEDAD@?$AA?5?$AAl?$AAa?$AAb?$AAe?$AAl?$AA?$DN?$AA?$CC?$AA?$AA@
  002bb	50		 push	 eax
  002bc	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  002c1	68 00 00 00 00	 push	 OFFSET ??_C@_13NEIAEHFG@?$AA?$CC?$AA?$AA@
  002c6	50		 push	 eax
  002c7	8d 85 d4 f7 ff
	ff		 lea	 eax, DWORD PTR $T20[ebp]
  002cd	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  002d1	50		 push	 eax
  002d2	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  002d7	83 c4 18	 add	 esp, 24			; 00000018H
  002da	6a ff		 push	 -1
  002dc	6a 00		 push	 0
  002de	50		 push	 eax
  002df	8d 8d a4 f7 ff
	ff		 lea	 ecx, DWORD PTR _s$12[ebp]
  002e5	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+12], 7
  002e9	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  002ee	8b 85 e8 f7 ff
	ff		 mov	 eax, DWORD PTR $T20[ebp+20]
  002f4	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  002f8	83 f8 08	 cmp	 eax, 8
  002fb	72 4e		 jb	 SHORT $LN480@SaveFavori
  002fd	8b 8d d4 f7 ff
	ff		 mov	 ecx, DWORD PTR $T20[ebp]
  00303	40		 inc	 eax
  00304	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00309	0f 87 25 05 00
	00		 ja	 $LN1814@SaveFavori
  0030f	03 c0		 add	 eax, eax
  00311	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00316	72 2a		 jb	 SHORT $LN475@SaveFavori
  00318	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0031b	0f 85 13 05 00
	00		 jne	 $LN1814@SaveFavori
  00321	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00324	3b c1		 cmp	 eax, ecx
  00326	0f 83 08 05 00
	00		 jae	 $LN1814@SaveFavori
  0032c	2b c8		 sub	 ecx, eax
  0032e	83 f9 04	 cmp	 ecx, 4
  00331	0f 82 fd 04 00
	00		 jb	 $LN1814@SaveFavori
  00337	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0033a	0f 87 f4 04 00
	00		 ja	 $LN1814@SaveFavori
  00340	8b c8		 mov	 ecx, eax
$LN475@SaveFavori:
  00342	51		 push	 ecx
  00343	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00348	83 c4 04	 add	 esp, 4
$LN480@SaveFavori:
  0034b	33 c0		 xor	 eax, eax
  0034d	c7 85 e8 f7 ff
	ff 07 00 00 00	 mov	 DWORD PTR $T20[ebp+20], 7
  00357	66 89 85 d4 f7
	ff ff		 mov	 WORD PTR $T20[ebp], ax
  0035e	8b 85 d0 f7 ff
	ff		 mov	 eax, DWORD PTR $T17[ebp+20]
  00364	c7 85 e4 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+16], 0
  0036e	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  00372	83 f8 08	 cmp	 eax, 8
  00375	72 4e		 jb	 SHORT $LN599@SaveFavori
  00377	8b 8d bc f7 ff
	ff		 mov	 ecx, DWORD PTR $T17[ebp]
  0037d	40		 inc	 eax
  0037e	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00383	0f 87 ab 04 00
	00		 ja	 $LN1814@SaveFavori
  00389	03 c0		 add	 eax, eax
  0038b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00390	72 2a		 jb	 SHORT $LN594@SaveFavori
  00392	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00395	0f 85 99 04 00
	00		 jne	 $LN1814@SaveFavori
  0039b	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0039e	3b c1		 cmp	 eax, ecx
  003a0	0f 83 8e 04 00
	00		 jae	 $LN1814@SaveFavori
  003a6	2b c8		 sub	 ecx, eax
  003a8	83 f9 04	 cmp	 ecx, 4
  003ab	0f 82 83 04 00
	00		 jb	 $LN1814@SaveFavori
  003b1	83 f9 23	 cmp	 ecx, 35			; 00000023H
  003b4	0f 87 7a 04 00
	00		 ja	 $LN1814@SaveFavori
  003ba	8b c8		 mov	 ecx, eax
$LN594@SaveFavori:
  003bc	51		 push	 ecx
  003bd	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  003c2	83 c4 04	 add	 esp, 4
$LN599@SaveFavori:

; 788  : 
; 789  : 			if (favorite.ReadOnly)

  003c5	80 7e 65 00	 cmp	 BYTE PTR [esi+101], 0
  003c9	74 12		 je	 SHORT $LN11@SaveFavori

; 790  : 				s += L" readonly=\"1\"";

  003cb	6a 0d		 push	 13			; 0000000dH
  003cd	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@ENOBLAGP@?$AA?5?$AAr?$AAe?$AAa?$AAd?$AAo?$AAn?$AAl?$AAy?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@
  003d2	8d 8d a4 f7 ff
	ff		 lea	 ecx, DWORD PTR _s$12[ebp]
  003d8	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN11@SaveFavori:

; 791  : 			
; 792  : 			if (favorite.Removable)

  003dd	80 7e 66 00	 cmp	 BYTE PTR [esi+102], 0
  003e1	74 12		 je	 SHORT $LN12@SaveFavori

; 793  : 				s += L" removable=\"1\"";

  003e3	6a 0e		 push	 14			; 0000000eH
  003e5	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@KPDNDBGI@?$AA?5?$AAr?$AAe?$AAm?$AAo?$AAv?$AAa?$AAb?$AAl?$AAe?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@
  003ea	8d 8d a4 f7 ff
	ff		 lea	 ecx, DWORD PTR _s$12[ebp]
  003f0	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN12@SaveFavori:

; 794  : 
; 795  : 			if (favorite.SystemEncryption)

  003f5	80 7e 67 00	 cmp	 BYTE PTR [esi+103], 0
  003f9	74 12		 je	 SHORT $LN13@SaveFavori

; 796  : 				s += L" system=\"1\"";

  003fb	6a 0b		 push	 11			; 0000000bH
  003fd	68 00 00 00 00	 push	 OFFSET ??_C@_1BI@DCLBMOGE@?$AA?5?$AAs?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@
  00402	8d 8d a4 f7 ff
	ff		 lea	 ecx, DWORD PTR _s$12[ebp]
  00408	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN13@SaveFavori:

; 797  : 
; 798  : 			if (favorite.MountOnArrival)

  0040d	80 7e 63 00	 cmp	 BYTE PTR [esi+99], 0
  00411	74 12		 je	 SHORT $LN14@SaveFavori

; 799  : 				s += L" mountOnArrival=\"1\"";

  00413	6a 13		 push	 19			; 00000013H
  00415	68 00 00 00 00	 push	 OFFSET ??_C@_1CI@PFJKIIJG@?$AA?5?$AAm?$AAo?$AAu?$AAn?$AAt?$AAO?$AAn?$AAA?$AAr?$AAr?$AAi?$AAv?$AAa?$AAl?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@
  0041a	8d 8d a4 f7 ff
	ff		 lea	 ecx, DWORD PTR _s$12[ebp]
  00420	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN14@SaveFavori:

; 800  : 
; 801  : 			if (favorite.MountOnLogOn)

  00425	80 7e 62 00	 cmp	 BYTE PTR [esi+98], 0
  00429	74 12		 je	 SHORT $LN15@SaveFavori

; 802  : 				s += L" mountOnLogOn=\"1\"";

  0042b	6a 11		 push	 17			; 00000011H
  0042d	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@JKNJFOGE@?$AA?5?$AAm?$AAo?$AAu?$AAn?$AAt?$AAO?$AAn?$AAL?$AAo?$AAg?$AAO?$AAn?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@
  00432	8d 8d a4 f7 ff
	ff		 lea	 ecx, DWORD PTR _s$12[ebp]
  00438	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN15@SaveFavori:

; 803  : 			
; 804  : 			if (favorite.DisableHotkeyMount)

  0043d	80 7e 60 00	 cmp	 BYTE PTR [esi+96], 0
  00441	74 12		 je	 SHORT $LN16@SaveFavori

; 805  : 				s += L" noHotKeyMount=\"1\"";

  00443	6a 12		 push	 18			; 00000012H
  00445	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JPOBGFJC@?$AA?5?$AAn?$AAo?$AAH?$AAo?$AAt?$AAK?$AAe?$AAy?$AAM?$AAo?$AAu?$AAn?$AAt?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@
  0044a	8d 8d a4 f7 ff
	ff		 lea	 ecx, DWORD PTR _s$12[ebp]
  00450	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN16@SaveFavori:

; 806  : 
; 807  : 			if (favorite.OpenExplorerWindow)

  00455	80 7e 64 00	 cmp	 BYTE PTR [esi+100], 0
  00459	74 12		 je	 SHORT $LN17@SaveFavori

; 808  : 				s += L" openExplorerWindow=\"1\"";

  0045b	6a 17		 push	 23			; 00000017H
  0045d	68 00 00 00 00	 push	 OFFSET ??_C@_1DA@CGPNJOBH@?$AA?5?$AAo?$AAp?$AAe?$AAn?$AAE?$AAx?$AAp?$AAl?$AAo?$AAr?$AAe?$AAr?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AA?$DN?$AA?$CC?$AA1?$AA?$CC?$AA?$AA@
  00462	8d 8d a4 f7 ff
	ff		 lea	 ecx, DWORD PTR _s$12[ebp]
  00468	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN17@SaveFavori:

; 809  : 
; 810  : 			s += L">" + SingleStringToWide (tq) + L"</volume>";

  0046d	80 bd ec f7 ff
	ff 00		 cmp	 BYTE PTR _tq$21[ebp], 0
  00474	c7 85 e8 f7 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T19[ebp+20], 15 ; 0000000fH
  0047e	c7 85 e4 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+16], 0
  00488	c6 85 d4 f7 ff
	ff 00		 mov	 BYTE PTR $T19[ebp], 0
  0048f	75 04		 jne	 SHORT $LN812@SaveFavori
  00491	33 c0		 xor	 eax, eax
  00493	eb 14		 jmp	 SHORT $LN813@SaveFavori
$LN812@SaveFavori:
  00495	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR _tq$21[ebp]
  0049b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0049e	66 90		 npad	 2
$LL1870@SaveFavori:
  004a0	8a 08		 mov	 cl, BYTE PTR [eax]
  004a2	40		 inc	 eax
  004a3	84 c9		 test	 cl, cl
  004a5	75 f9		 jne	 SHORT $LL1870@SaveFavori
  004a7	2b c2		 sub	 eax, edx
$LN813@SaveFavori:
  004a9	50		 push	 eax
  004aa	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR _tq$21[ebp]
  004b0	50		 push	 eax
  004b1	8d 8d d4 f7 ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  004b7	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  004bc	8d 85 d4 f7 ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  004c2	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+12], 8
  004c6	50		 push	 eax
  004c7	8d 85 bc f7 ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  004cd	50		 push	 eax
  004ce	e8 00 00 00 00	 call	 ?SingleStringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; SingleStringToWide
  004d3	50		 push	 eax
  004d4	8d 85 8c f7 ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  004da	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+12], 9
  004de	68 00 00 00 00	 push	 OFFSET ??_C@_13MOEPKPHB@?$AA?$DO?$AA?$AA@
  004e3	50		 push	 eax
  004e4	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W$$QAV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  004e9	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@BKLKJEIJ@?$AA?$DM?$AA?1?$AAv?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?$DO?$AA?$AA@
  004ee	50		 push	 eax
  004ef	8d 85 74 f7 ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  004f5	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  004f9	50		 push	 eax
  004fa	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  004ff	83 c4 20	 add	 esp, 32			; 00000020H
  00502	6a ff		 push	 -1
  00504	6a 00		 push	 0
  00506	50		 push	 eax
  00507	8d 8d a4 f7 ff
	ff		 lea	 ecx, DWORD PTR _s$12[ebp]
  0050d	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+12], 11 ; 0000000bH
  00511	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00516	8b 85 88 f7 ff
	ff		 mov	 eax, DWORD PTR $T8[ebp+20]
  0051c	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  00520	83 f8 08	 cmp	 eax, 8
  00523	72 4e		 jb	 SHORT $LN906@SaveFavori
  00525	8b 8d 74 f7 ff
	ff		 mov	 ecx, DWORD PTR $T8[ebp]
  0052b	40		 inc	 eax
  0052c	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00531	0f 87 fd 02 00
	00		 ja	 $LN1814@SaveFavori
  00537	03 c0		 add	 eax, eax
  00539	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0053e	72 2a		 jb	 SHORT $LN901@SaveFavori
  00540	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00543	0f 85 eb 02 00
	00		 jne	 $LN1814@SaveFavori
  00549	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0054c	3b c1		 cmp	 eax, ecx
  0054e	0f 83 e0 02 00
	00		 jae	 $LN1814@SaveFavori
  00554	2b c8		 sub	 ecx, eax
  00556	83 f9 04	 cmp	 ecx, 4
  00559	0f 82 d5 02 00
	00		 jb	 $LN1814@SaveFavori
  0055f	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00562	0f 87 cc 02 00
	00		 ja	 $LN1814@SaveFavori
  00568	8b c8		 mov	 ecx, eax
$LN901@SaveFavori:
  0056a	51		 push	 ecx
  0056b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00570	83 c4 04	 add	 esp, 4
$LN906@SaveFavori:
  00573	33 c0		 xor	 eax, eax
  00575	c7 85 88 f7 ff
	ff 07 00 00 00	 mov	 DWORD PTR $T8[ebp+20], 7
  0057f	66 89 85 74 f7
	ff ff		 mov	 WORD PTR $T8[ebp], ax
  00586	8b 85 a0 f7 ff
	ff		 mov	 eax, DWORD PTR $T11[ebp+20]
  0058c	c7 85 84 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+16], 0
  00596	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+12], 9
  0059a	83 f8 08	 cmp	 eax, 8
  0059d	72 4e		 jb	 SHORT $LN1025@SaveFavori
  0059f	8b 8d 8c f7 ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  005a5	40		 inc	 eax
  005a6	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  005ab	0f 87 83 02 00
	00		 ja	 $LN1814@SaveFavori
  005b1	03 c0		 add	 eax, eax
  005b3	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  005b8	72 2a		 jb	 SHORT $LN1020@SaveFavori
  005ba	f6 c1 1f	 test	 cl, 31			; 0000001fH
  005bd	0f 85 71 02 00
	00		 jne	 $LN1814@SaveFavori
  005c3	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  005c6	3b c1		 cmp	 eax, ecx
  005c8	0f 83 66 02 00
	00		 jae	 $LN1814@SaveFavori
  005ce	2b c8		 sub	 ecx, eax
  005d0	83 f9 04	 cmp	 ecx, 4
  005d3	0f 82 5b 02 00
	00		 jb	 $LN1814@SaveFavori
  005d9	83 f9 23	 cmp	 ecx, 35			; 00000023H
  005dc	0f 87 52 02 00
	00		 ja	 $LN1814@SaveFavori
  005e2	8b c8		 mov	 ecx, eax
$LN1020@SaveFavori:
  005e4	51		 push	 ecx
  005e5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  005ea	83 c4 04	 add	 esp, 4
$LN1025@SaveFavori:
  005ed	33 c0		 xor	 eax, eax
  005ef	c7 85 a0 f7 ff
	ff 07 00 00 00	 mov	 DWORD PTR $T11[ebp+20], 7
  005f9	66 89 85 8c f7
	ff ff		 mov	 WORD PTR $T11[ebp], ax
  00600	8b 85 d0 f7 ff
	ff		 mov	 eax, DWORD PTR $T16[ebp+20]
  00606	c7 85 9c f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+16], 0
  00610	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+12], 8
  00614	83 f8 08	 cmp	 eax, 8
  00617	72 4e		 jb	 SHORT $LN1144@SaveFavori
  00619	8b 8d bc f7 ff
	ff		 mov	 ecx, DWORD PTR $T16[ebp]
  0061f	40		 inc	 eax
  00620	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00625	0f 87 09 02 00
	00		 ja	 $LN1814@SaveFavori
  0062b	03 c0		 add	 eax, eax
  0062d	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00632	72 2a		 jb	 SHORT $LN1139@SaveFavori
  00634	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00637	0f 85 f7 01 00
	00		 jne	 $LN1814@SaveFavori
  0063d	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00640	3b c1		 cmp	 eax, ecx
  00642	0f 83 ec 01 00
	00		 jae	 $LN1814@SaveFavori
  00648	2b c8		 sub	 ecx, eax
  0064a	83 f9 04	 cmp	 ecx, 4
  0064d	0f 82 e1 01 00
	00		 jb	 $LN1814@SaveFavori
  00653	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00656	0f 87 d8 01 00
	00		 ja	 $LN1814@SaveFavori
  0065c	8b c8		 mov	 ecx, eax
$LN1139@SaveFavori:
  0065e	51		 push	 ecx
  0065f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00664	83 c4 04	 add	 esp, 4
$LN1144@SaveFavori:
  00667	33 c0		 xor	 eax, eax
  00669	c7 85 d0 f7 ff
	ff 07 00 00 00	 mov	 DWORD PTR $T16[ebp+20], 7
  00673	66 89 85 bc f7
	ff ff		 mov	 WORD PTR $T16[ebp], ax
  0067a	8b 85 e8 f7 ff
	ff		 mov	 eax, DWORD PTR $T19[ebp+20]
  00680	c7 85 cc f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp+16], 0
  0068a	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  0068e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00691	72 41		 jb	 SHORT $LN1261@SaveFavori
  00693	8b 8d d4 f7 ff
	ff		 mov	 ecx, DWORD PTR $T19[ebp]
  00699	40		 inc	 eax
  0069a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0069f	72 2a		 jb	 SHORT $LN1256@SaveFavori
  006a1	f6 c1 1f	 test	 cl, 31			; 0000001fH
  006a4	0f 85 8a 01 00
	00		 jne	 $LN1814@SaveFavori
  006aa	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  006ad	3b c1		 cmp	 eax, ecx
  006af	0f 83 7f 01 00
	00		 jae	 $LN1814@SaveFavori
  006b5	2b c8		 sub	 ecx, eax
  006b7	83 f9 04	 cmp	 ecx, 4
  006ba	0f 82 74 01 00
	00		 jb	 $LN1814@SaveFavori
  006c0	83 f9 23	 cmp	 ecx, 35			; 00000023H
  006c3	0f 87 6b 01 00
	00		 ja	 $LN1814@SaveFavori
  006c9	8b c8		 mov	 ecx, eax
$LN1256@SaveFavori:
  006cb	51		 push	 ecx
  006cc	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  006d1	83 c4 04	 add	 esp, 4
$LN1261@SaveFavori:

; 811  : 
; 812  : 			fwprintf (f, L"%ws", s.c_str());

  006d4	83 bd b8 f7 ff
	ff 08		 cmp	 DWORD PTR _s$12[ebp+20], 8
  006db	8d 85 a4 f7 ff
	ff		 lea	 eax, DWORD PTR _s$12[ebp]
  006e1	0f 43 85 a4 f7
	ff ff		 cmovae	 eax, DWORD PTR _s$12[ebp]
  006e8	50		 push	 eax
  006e9	68 00 00 00 00	 push	 OFFSET ??_C@_17EEOGHOKP@?$AA?$CF?$AAw?$AAs?$AA?$AA@
  006ee	57		 push	 edi
  006ef	e8 00 00 00 00	 call	 _fwprintf

; 813  : 			cnt++;
; 814  : 		}

  006f4	8b 85 b8 f7 ff
	ff		 mov	 eax, DWORD PTR _s$12[ebp+20]
  006fa	43		 inc	 ebx
  006fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  006fe	89 9d 70 f1 ff
	ff		 mov	 DWORD PTR _cnt$[ebp], ebx
  00704	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00708	83 f8 08	 cmp	 eax, 8
  0070b	72 4e		 jb	 SHORT $LN1397@SaveFavori
  0070d	8b 8d a4 f7 ff
	ff		 mov	 ecx, DWORD PTR _s$12[ebp]
  00713	40		 inc	 eax
  00714	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00719	0f 87 15 01 00
	00		 ja	 $LN1814@SaveFavori
  0071f	03 c0		 add	 eax, eax
  00721	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00726	72 2a		 jb	 SHORT $LN1392@SaveFavori
  00728	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0072b	0f 85 03 01 00
	00		 jne	 $LN1814@SaveFavori
  00731	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00734	3b c1		 cmp	 eax, ecx
  00736	0f 83 f8 00 00
	00		 jae	 $LN1814@SaveFavori
  0073c	2b c8		 sub	 ecx, eax
  0073e	83 f9 04	 cmp	 ecx, 4
  00741	0f 82 ed 00 00
	00		 jb	 $LN1814@SaveFavori
  00747	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0074a	0f 87 e4 00 00
	00		 ja	 $LN1814@SaveFavori
  00750	8b c8		 mov	 ecx, eax
$LN1392@SaveFavori:
  00752	51		 push	 ecx
  00753	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00758	83 c4 04	 add	 esp, 4
$LN1397@SaveFavori:

; 774  : 
; 775  : 		foreach (const FavoriteVolume &favorite, favorites)

  0075b	33 c0		 xor	 eax, eax
  0075d	c6 85 58 f1 ff
	ff 01		 mov	 BYTE PTR _$S9$3[ebp+4], 1
  00764	38 85 59 f1 ff
	ff		 cmp	 BYTE PTR _$S9$3[ebp+5], al
  0076a	0f 94 c0	 sete	 al
  0076d	88 85 59 f1 ff
	ff		 mov	 BYTE PTR _$S9$3[ebp+5], al
  00773	84 c0		 test	 al, al
  00775	0f 85 85 f9 ff
	ff		 jne	 $LL7@SaveFavori
$LN2@SaveFavori:
  0077b	8b 85 54 f1 ff
	ff		 mov	 eax, DWORD PTR _$S9$3[ebp]
  00781	8d 8d 54 f1 ff
	ff		 lea	 ecx, DWORD PTR _$S9$3[ebp]
  00787	ff 50 08	 call	 DWORD PTR [eax+8]
  0078a	8b 85 54 f1 ff
	ff		 mov	 eax, DWORD PTR _$S9$3[ebp]
  00790	8d 8d 54 f1 ff
	ff		 lea	 ecx, DWORD PTR _$S9$3[ebp]
  00796	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00799	ff d0		 call	 eax
  0079b	84 c0		 test	 al, al
  0079d	0f 85 3d f9 ff
	ff		 jne	 $LL4@SaveFavori
$LN1869@SaveFavori:

; 813  : 			cnt++;
; 814  : 		}

  007a3	8b b5 5c f1 ff
	ff		 mov	 esi, DWORD PTR _$S9$3[ebp+8]
  007a9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  007b0	85 f6		 test	 esi, esi
  007b2	74 4c		 je	 SHORT $LN1435@SaveFavori
  007b4	8b bd 60 f1 ff
	ff		 mov	 edi, DWORD PTR _$S9$3[ebp+12]
  007ba	3b f7		 cmp	 esi, edi
  007bc	74 16		 je	 SHORT $LN1476@SaveFavori
  007be	66 90		 npad	 2
$LL1477@SaveFavori:
  007c0	8b ce		 mov	 ecx, esi
  007c2	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  007c7	83 c6 68	 add	 esi, 104		; 00000068H
  007ca	3b f7		 cmp	 esi, edi
  007cc	75 f2		 jne	 SHORT $LL1477@SaveFavori
  007ce	8b b5 5c f1 ff
	ff		 mov	 esi, DWORD PTR _$S9$3[ebp+8]
$LN1476@SaveFavori:
  007d4	8b 8d 64 f1 ff
	ff		 mov	 ecx, DWORD PTR _$S9$3[ebp+16]
  007da	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  007df	2b ce		 sub	 ecx, esi
  007e1	f7 e9		 imul	 ecx
  007e3	8d 8d 5c f1 ff
	ff		 lea	 ecx, DWORD PTR _$S9$3[ebp+8]
  007e9	c1 fa 05	 sar	 edx, 5
  007ec	8b c2		 mov	 eax, edx
  007ee	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  007f1	03 c2		 add	 eax, edx
  007f3	50		 push	 eax
  007f4	56		 push	 esi
  007f5	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXPAUFavoriteVolume@GostCrypt@@I@Z ; std::_Wrap_alloc<std::allocator<GostCrypt::FavoriteVolume> >::deallocate
  007fa	8b bd 50 f1 ff
	ff		 mov	 edi, DWORD PTR _f$1$[ebp]
$LN1435@SaveFavori:

; 815  : 
; 816  : 		fputws (L"\n\t</favorites>", f);

  00800	57		 push	 edi
  00801	68 00 00 00 00	 push	 OFFSET ??_C@_1BO@LKECBBKI@?$AA?6?$AA?7?$AA?$DM?$AA?1?$AAf?$AAa?$AAv?$AAo?$AAr?$AAi?$AAt?$AAe?$AAs?$AA?$DO?$AA?$AA@
  00806	e8 00 00 00 00	 call	 _fputws

; 817  : 		XmlWriteFooterW (f);

  0080b	57		 push	 edi
  0080c	e8 00 00 00 00	 call	 _XmlWriteFooterW

; 818  : 
; 819  : 		if (!CheckFileStreamWriteErrors (f, systemFavorites ? GST_APPD_FILENAME_SYSTEM_FAVORITE_VOLUMES : GST_APPD_FILENAME_FAVORITE_VOLUMES))

  00811	ff b5 4c f1 ff
	ff		 push	 DWORD PTR tv4254[ebp]
  00817	57		 push	 edi
  00818	e8 00 00 00 00	 call	 _CheckFileStreamWriteErrors
  0081d	83 c4 14	 add	 esp, 20			; 00000014H

; 820  : 		{
; 821  : 			fclose (f);

  00820	57		 push	 edi
  00821	85 c0		 test	 eax, eax
  00823	75 14		 jne	 SHORT $LN18@SaveFavori
  00825	e8 00 00 00 00	 call	 _fclose
  0082a	83 c4 04	 add	 esp, 4

; 822  : 			return false;

  0082d	32 c0		 xor	 al, al
  0082f	e9 7f 02 00 00	 jmp	 $LN1@SaveFavori
$LN1814@SaveFavori:

; 783  : 
; 784  : 			wstring s = L"\n\t\t<volume mountpoint=\"" + SingleStringToWide (favorite.MountPoint) + L"\"";

  00834	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1873@SaveFavori:
$LN18@SaveFavori:

; 823  : 		}
; 824  : 
; 825  : 		fclose (f);

  00839	e8 00 00 00 00	 call	 _fclose
  0083e	83 c4 04	 add	 esp, 4

; 826  : 
; 827  : 		BootEncryption bootEnc (MainDlg);

  00841	8d 8d 7c f1 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  00847	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0084d	e8 00 00 00 00	 call	 ??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z ; GostCrypt::BootEncryption::BootEncryption

; 828  : 
; 829  : 		if (systemFavorites)

  00852	8a 85 78 f1 ff
	ff		 mov	 al, BYTE PTR _systemFavorites$GSCopy$[ebp]
  00858	c7 45 fc 0c 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 12 ; 0000000cH
  0085f	84 c0		 test	 al, al
  00861	0f 84 c0 01 00
	00		 je	 $LN19@SaveFavori

; 830  : 		{
; 831  : 			finally_do ({ remove (GetConfigPath (GST_APPD_FILENAME_SYSTEM_FAVORITE_VOLUMES)); });
; 832  : 
; 833  : 			try
; 834  : 			{
; 835  : 				bootEnc.DeleteFileAdmin (GetServiceConfigPath (GST_APPD_FILENAME_SYSTEM_FAVORITE_VOLUMES).c_str());

  00867	8d 85 bc f7 ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  0086d	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+12], 14 ; 0000000eH
  00871	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@
  00876	50		 push	 eax
  00877	e8 00 00 00 00	 call	 ?GetServiceConfigPath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; GetServiceConfigPath
  0087c	83 c4 08	 add	 esp, 8
  0087f	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00883	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+12], 15 ; 0000000fH
  00887	72 02		 jb	 SHORT $LN1568@SaveFavori
  00889	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1568@SaveFavori:
  0088b	50		 push	 eax
  0088c	8d 8d d4 f7 ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  00892	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00897	8d 85 d4 f7 ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  0089d	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+12], 16 ; 00000010H
  008a1	50		 push	 eax
  008a2	8d 8d 7c f1 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  008a8	e8 00 00 00 00	 call	 ?DeleteFileAdmin@BootEncryption@GostCrypt@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GostCrypt::BootEncryption::DeleteFileAdmin
  008ad	8b 85 e8 f7 ff
	ff		 mov	 eax, DWORD PTR $T18[ebp+20]
  008b3	83 f8 10	 cmp	 eax, 16			; 00000010H
  008b6	72 13		 jb	 SHORT $LN1577@SaveFavori
  008b8	40		 inc	 eax
  008b9	8d 8d d4 f7 ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  008bf	50		 push	 eax
  008c0	ff b5 d4 f7 ff
	ff		 push	 DWORD PTR $T18[ebp]
  008c6	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN1577@SaveFavori:
  008cb	8b 85 d0 f7 ff
	ff		 mov	 eax, DWORD PTR $T15[ebp+20]
  008d1	c7 85 e8 f7 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T18[ebp+20], 15 ; 0000000fH
  008db	c7 85 e4 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+16], 0
  008e5	c6 85 d4 f7 ff
	ff 00		 mov	 BYTE PTR $T18[ebp], 0
  008ec	83 f8 10	 cmp	 eax, 16			; 00000010H
  008ef	72 4a		 jb	 SHORT $LN1678@SaveFavori
  008f1	40		 inc	 eax
  008f2	8d 8d bc f7 ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  008f8	50		 push	 eax
  008f9	ff b5 bc f7 ff
	ff		 push	 DWORD PTR $T15[ebp]
  008ff	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  00904	eb 35		 jmp	 SHORT $LN1678@SaveFavori
__catch$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$0:

; 836  : 			}
; 837  : 			catch (UserAbort&) { return false; }

  00906	b8 00 00 00 00	 mov	 eax, $LN60@SaveFavori
  0090b	c3		 ret	 0
$LN60@SaveFavori:
  0090c	8d 8d 77 f1 ff
	ff		 lea	 ecx, DWORD PTR _finally831$4[ebp]
  00912	e8 00 00 00 00	 call	 ??1Finally831@?CA@??SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z@QAE@XZ ; `GostCrypt::SaveFavoriteVolumes'::`32'::Finally831::~Finally831
  00917	8d 8d 7c f1 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  0091d	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
  00922	32 c0		 xor	 al, al
  00924	e9 8a 01 00 00	 jmp	 $LN1@SaveFavori
__catch$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$1:

; 838  : 			catch (...) { }

  00929	b8 00 00 00 00	 mov	 eax, $LN62@SaveFavori
  0092e	c3		 ret	 0
$LN62@SaveFavori:
  0092f	8b 9d 70 f1 ff
	ff		 mov	 ebx, DWORD PTR _cnt$[ebp]
  00935	8a 85 78 f1 ff
	ff		 mov	 al, BYTE PTR _systemFavorites$GSCopy$[ebp]

; 830  : 		{
; 831  : 			finally_do ({ remove (GetConfigPath (GST_APPD_FILENAME_SYSTEM_FAVORITE_VOLUMES)); });
; 832  : 
; 833  : 			try
; 834  : 			{
; 835  : 				bootEnc.DeleteFileAdmin (GetServiceConfigPath (GST_APPD_FILENAME_SYSTEM_FAVORITE_VOLUMES).c_str());

$LN1678@SaveFavori:
  0093b	c7 45 fc 0d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 13 ; 0000000dH

; 839  : 
; 840  : 			try
; 841  : 			{
; 842  : 				if (cnt != 0)

  00942	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+12], 18 ; 00000012H
  00946	85 db		 test	 ebx, ebx
  00948	0f 84 bd 00 00
	00		 je	 $LN23@SaveFavori

; 843  : 				{
; 844  : 					bootEnc.CopyFileAdmin (GetConfigPath (GST_APPD_FILENAME_SYSTEM_FAVORITE_VOLUMES), GetServiceConfigPath (GST_APPD_FILENAME_SYSTEM_FAVORITE_VOLUMES).c_str());

  0094e	8d 85 74 f7 ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00954	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@
  00959	50		 push	 eax
  0095a	e8 00 00 00 00	 call	 ?GetServiceConfigPath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; GetServiceConfigPath
  0095f	83 c4 08	 add	 esp, 8
  00962	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00966	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+12], 19 ; 00000013H
  0096a	72 02		 jb	 SHORT $LN1787@SaveFavori
  0096c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1787@SaveFavori:
  0096e	50		 push	 eax
  0096f	8d 8d 8c f7 ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  00975	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0097a	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@
  0097f	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+12], 20 ; 00000014H
  00983	e8 00 00 00 00	 call	 _GetConfigPath
  00988	83 c4 04	 add	 esp, 4
  0098b	8d 8d bc f7 ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  00991	50		 push	 eax
  00992	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00997	8d 85 8c f7 ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  0099d	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+12], 21 ; 00000015H
  009a1	50		 push	 eax
  009a2	8d 85 bc f7 ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  009a8	50		 push	 eax
  009a9	8d 8d 7c f1 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  009af	e8 00 00 00 00	 call	 ?CopyFileAdmin@BootEncryption@GostCrypt@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; GostCrypt::BootEncryption::CopyFileAdmin
  009b4	8d 8d bc f7 ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  009ba	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  009bf	8d 8d 8c f7 ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  009c5	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  009ca	8d 8d 74 f7 ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  009d0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 845  : 
; 846  : 					if (!(ReadDriverConfigurationFlags() & GST_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES))

  009d5	e8 00 00 00 00	 call	 _ReadDriverConfigurationFlags
  009da	a8 02		 test	 al, 2
  009dc	75 2d		 jne	 SHORT $LN23@SaveFavori

; 847  : 						Info ("SYS_FAVORITE_VOLUMES_SAVED");

  009de	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@JLAFANLF@SYS_FAVORITE_VOLUMES_SAVED?$AA@
  009e3	e8 00 00 00 00	 call	 _Info
  009e8	83 c4 04	 add	 esp, 4
  009eb	eb 1e		 jmp	 SHORT $LN23@SaveFavori
__catch$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$3:

; 848  : 				}
; 849  : 			}
; 850  : 			catch (Exception &e)
; 851  : 			{
; 852  : 				e.Show (NULL);

  009ed	8b 8d 48 f1 ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  009f3	6a 00		 push	 0
  009f5	8b 01		 mov	 eax, DWORD PTR [ecx]
  009f7	ff 10		 call	 DWORD PTR [eax]

; 853  : 			}

  009f9	b8 00 00 00 00	 mov	 eax, $LN64@SaveFavori
  009fe	c3		 ret	 0
$LN64@SaveFavori:
  009ff	8b 9d 70 f1 ff
	ff		 mov	 ebx, DWORD PTR _cnt$[ebp]
  00a05	8a 85 78 f1 ff
	ff		 mov	 al, BYTE PTR _systemFavorites$GSCopy$[ebp]
$LN23@SaveFavori:
  00a0b	c7 45 fc 0d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 13 ; 0000000dH

; 854  : 		}

  00a12	8d 8d 77 f1 ff
	ff		 lea	 ecx, DWORD PTR _finally831$4[ebp]
  00a18	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+12], 12 ; 0000000cH
  00a1c	e8 00 00 00 00	 call	 ??1Finally831@?CA@??SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z@QAE@XZ ; `GostCrypt::SaveFavoriteVolumes'::`32'::Finally831::~Finally831
  00a21	8a 85 78 f1 ff
	ff		 mov	 al, BYTE PTR _systemFavorites$GSCopy$[ebp]
$LN19@SaveFavori:

; 855  : 
; 856  : 		if (cnt == 0)

  00a27	85 db		 test	 ebx, ebx
  00a29	75 7b		 jne	 SHORT $LN26@SaveFavori

; 857  : 		{
; 858  : 			if (systemFavorites)

  00a2b	84 c0		 test	 al, al
  00a2d	74 64		 je	 SHORT $LN25@SaveFavori

; 859  : 			{
; 860  : 				try
; 861  : 				{
; 862  : 					bootEnc.DeleteFileAdmin (GetServiceConfigPath (GST_APPD_FILENAME_SYSTEM_FAVORITE_VOLUMES).c_str());

  00a2f	8d 85 8c f7 ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  00a35	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+12], 23 ; 00000017H
  00a39	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@
  00a3e	50		 push	 eax
  00a3f	e8 00 00 00 00	 call	 ?GetServiceConfigPath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; GetServiceConfigPath
  00a44	83 c4 08	 add	 esp, 8
  00a47	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00a4b	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+12], 24 ; 00000018H
  00a4f	72 02		 jb	 SHORT $LN1804@SaveFavori
  00a51	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1804@SaveFavori:
  00a53	50		 push	 eax
  00a54	8d 8d bc f7 ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00a5a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a5f	8d 85 bc f7 ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  00a65	c6 45 fc 19	 mov	 BYTE PTR __$EHRec$[ebp+12], 25 ; 00000019H
  00a69	50		 push	 eax
  00a6a	8d 8d 7c f1 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  00a70	e8 00 00 00 00	 call	 ?DeleteFileAdmin@BootEncryption@GostCrypt@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GostCrypt::BootEncryption::DeleteFileAdmin
  00a75	8d 8d bc f7 ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00a7b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a80	8d 8d 8c f7 ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00a86	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN66@SaveFavori:

; 865  : 			}
; 866  : 			else

  00a8b	eb 19		 jmp	 SHORT $LN26@SaveFavori
__catch$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$5:

; 863  : 				}
; 864  : 				catch (...) { }

  00a8d	b8 00 00 00 00	 mov	 eax, $LN66@SaveFavori
  00a92	c3		 ret	 0
$LN25@SaveFavori:

; 867  : 				remove (GetConfigPath (GST_APPD_FILENAME_FAVORITE_VOLUMES));

  00a93	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EGBOIEGJ@Favorite?5Volumes?4xml?$AA@
  00a98	e8 00 00 00 00	 call	 _GetConfigPath
  00a9d	50		 push	 eax
  00a9e	e8 00 00 00 00	 call	 _remove
  00aa3	83 c4 08	 add	 esp, 8
$LN26@SaveFavori:

; 868  : 		}
; 869  : 
; 870  : 		return true;

  00aa6	8d 8d 7c f1 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  00aac	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
  00ab1	b0 01		 mov	 al, 1
$LN1@SaveFavori:

; 871  : 	}

  00ab3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00ab6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00abd	59		 pop	 ecx
  00abe	5f		 pop	 edi
  00abf	5e		 pop	 esi
  00ac0	5b		 pop	 ebx
  00ac1	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ac4	33 cd		 xor	 ecx, ebp
  00ac6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00acb	8b e5		 mov	 esp, ebp
  00acd	5d		 pop	 ebp
  00ace	c3		 ret	 0
$LN1872@SaveFavori:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$7:
  00000	8d 8d 54 f1 ff
	ff		 lea	 ecx, DWORD PTR _$S9$3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$8:
  0000b	8d 8d 44 f7 ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$9:
  00016	8d 8d 5c f7 ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$10:
  00021	8d 8d a4 f7 ff
	ff		 lea	 ecx, DWORD PTR _s$12[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$11:
  0002c	8d 8d bc f7 ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$12:
  00037	8d 8d d4 f7 ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$13:
  00042	8d 8d d4 f7 ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$14:
  0004d	8d 8d bc f7 ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$15:
  00058	8d 8d 8c f7 ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  0005e	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$16:
  00063	8d 8d 74 f7 ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00069	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$17:
  0006e	8d 8d 7c f1 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$[ebp]
  00074	e9 00 00 00 00	 jmp	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$18:
  00079	8d 8d 77 f1 ff
	ff		 lea	 ecx, DWORD PTR _finally831$4[ebp]
  0007f	e9 00 00 00 00	 jmp	 ??1Finally831@?CA@??SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z@QAE@XZ ; `GostCrypt::SaveFavoriteVolumes'::`32'::Finally831::~Finally831
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$19:
  00084	8d 8d bc f7 ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  0008a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$20:
  0008f	8d 8d d4 f7 ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  00095	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$21:
  0009a	8d 8d 74 f7 ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  000a0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$22:
  000a5	8d 8d 8c f7 ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  000ab	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$23:
  000b0	8d 8d bc f7 ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  000b6	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$24:
  000bb	8d 8d 8c f7 ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  000c1	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z$25:
  000c6	8d 8d bc f7 ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  000cc	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z:
  000d1	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000d5	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000d8	8b 8a 44 f1 ff
	ff		 mov	 ecx, DWORD PTR [edx-3772]
  000de	33 c8		 xor	 ecx, eax
  000e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e5	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  000e8	33 c8		 xor	 ecx, eax
  000ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ef	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z
  000f4	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z ENDP ; GostCrypt::SaveFavoriteVolumes
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ?OrganizeFavoriteVolumes@GostCrypt@@YAHPAUHWND__@@_NABUFavoriteVolume@1@@Z
_TEXT	SEGMENT
_args$ = -128						; size = 108
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_hwndDlg$ = 8						; size = 4
_systemFavorites$ = 12					; size = 1
_newFavorite$ = 16					; size = 4
?OrganizeFavoriteVolumes@GostCrypt@@YAHPAUHWND__@@_NABUFavoriteVolume@1@@Z PROC ; GostCrypt::OrganizeFavoriteVolumes, COMDAT

; 734  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OrganizeFavoriteVolumes@GostCrypt@@YAHPAUHWND__@@_NABUFavoriteVolume@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 74	 sub	 esp, 116		; 00000074H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	8b 75 08	 mov	 esi, DWORD PTR _hwndDlg$[ebp]

; 735  : 		FavoriteVolumesDlgProcArguments args;

  0002c	33 c0		 xor	 eax, eax
  0002e	8b 4d 10	 mov	 ecx, DWORD PTR _newFavorite$[ebp]
  00031	c7 45 98 0f 00
	00 00		 mov	 DWORD PTR _args$[ebp+24], 15 ; 0000000fH
  00038	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _args$[ebp+20], 0
  0003f	c6 45 84 00	 mov	 BYTE PTR _args$[ebp+4], 0
  00043	c7 45 b0 0f 00
	00 00		 mov	 DWORD PTR _args$[ebp+48], 15 ; 0000000fH
  0004a	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _args$[ebp+44], 0
  00051	c6 45 9c 00	 mov	 BYTE PTR _args$[ebp+28], 0
  00055	c7 45 c8 0f 00
	00 00		 mov	 DWORD PTR _args$[ebp+72], 15 ; 0000000fH
  0005c	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _args$[ebp+68], 0
  00063	c6 45 b4 00	 mov	 BYTE PTR _args$[ebp+52], 0
  00067	c7 45 e0 07 00
	00 00		 mov	 DWORD PTR _args$[ebp+96], 7
  0006e	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _args$[ebp+92], 0
  00075	66 89 45 cc	 mov	 WORD PTR _args$[ebp+76], ax
  00079	89 45 e4	 mov	 DWORD PTR _args$[ebp+100], eax
  0007c	89 45 e8	 mov	 DWORD PTR _args$[ebp+104], eax

; 736  : 		args.SystemFavorites = systemFavorites;
; 737  : 
; 738  : 		if (!newFavorite.Path.empty())

  0007f	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00083	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  00086	8a 45 0c	 mov	 al, BYTE PTR _systemFavorites$[ebp]
  00089	88 45 80	 mov	 BYTE PTR _args$[ebp], al
  0008c	74 0f		 je	 SHORT $LN2@OrganizeFa

; 739  : 		{
; 740  : 			args.AddFavoriteVolume = true;
; 741  : 			args.NewFavoriteVolume = newFavorite;

  0008e	51		 push	 ecx
  0008f	8d 4d 84	 lea	 ecx, DWORD PTR _args$[ebp+4]
  00092	c6 45 81 01	 mov	 BYTE PTR _args$[ebp+1], 1
  00096	e8 00 00 00 00	 call	 ??4FavoriteVolume@GostCrypt@@QAEAAU01@ABU01@@Z

; 742  : 		}
; 743  : 		else

  0009b	eb 04		 jmp	 SHORT $LN3@OrganizeFa
$LN2@OrganizeFa:

; 744  : 			args.AddFavoriteVolume = false;

  0009d	c6 45 81 00	 mov	 BYTE PTR _args$[ebp+1], 0
$LN3@OrganizeFa:

; 745  : 
; 746  : 		return DialogBoxParamW (hInst, MAKEINTRESOURCEW (IDD_FAVORITE_VOLUMES), hwndDlg, (DLGPROC) FavoriteVolumesDlgProc, (LPARAM) &args) == IDOK;

  000a1	8d 45 80	 lea	 eax, DWORD PTR _args$[ebp]
  000a4	50		 push	 eax
  000a5	68 00 00 00 00	 push	 OFFSET ?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z ; GostCrypt::FavoriteVolumesDlgProc
  000aa	56		 push	 esi
  000ab	6a 75		 push	 117			; 00000075H
  000ad	ff 35 00 00 00
	00		 push	 DWORD PTR _hInst
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DialogBoxParamW@20
  000b9	8d 4d 84	 lea	 ecx, DWORD PTR _args$[ebp+4]
  000bc	8d 70 ff	 lea	 esi, DWORD PTR [eax-1]
  000bf	f7 de		 neg	 esi
  000c1	1b f6		 sbb	 esi, esi
  000c3	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  000c8	8d 46 01	 lea	 eax, DWORD PTR [esi+1]

; 747  : 	}

  000cb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ce	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d5	59		 pop	 ecx
  000d6	5e		 pop	 esi
  000d7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000da	33 cd		 xor	 ecx, ebp
  000dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OrganizeFavoriteVolumes@GostCrypt@@YAHPAUHWND__@@_NABUFavoriteVolume@1@@Z$0:
  00000	8d 4d 80	 lea	 ecx, DWORD PTR _args$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1FavoriteVolumesDlgProcArguments@GostCrypt@@QAE@XZ
__ehhandler$?OrganizeFavoriteVolumes@GostCrypt@@YAHPAUHWND__@@_NABUFavoriteVolume@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a 84	 mov	 ecx, DWORD PTR [edx-124]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OrganizeFavoriteVolumes@GostCrypt@@YAHPAUHWND__@@_NABUFavoriteVolume@1@@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OrganizeFavoriteVolumes@GostCrypt@@YAHPAUHWND__@@_NABUFavoriteVolume@1@@Z ENDP ; GostCrypt::OrganizeFavoriteVolumes
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ
_TEXT	SEGMENT
_$S7$2 = -280						; size = 28
_$S8$3 = -252						; size = 24
_present$1$ = -225					; size = 1
_favoriteConnected$4 = -224				; size = 104
_favorite$5 = -120					; size = 104
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ PROC		; GostCrypt::OnFavoriteVolumesUpdated, COMDAT

; 691  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 692  : 		FillFavoriteVolumesMenu();

  0002e	e8 00 00 00 00	 call	 ?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ ; GostCrypt::FillFavoriteVolumesMenu

; 693  : 
; 694  : 		FavoritesOnArrivalMountRequired.clear();

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00038	8b 38		 mov	 edi, DWORD PTR [eax]
  0003a	89 00		 mov	 DWORD PTR [eax], eax
  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00041	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00044	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+4, 0
  0004e	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00054	74 1d		 je	 SHORT $LN29@OnFavorite
$LL30@OnFavorite:
  00056	8b 37		 mov	 esi, DWORD PTR [edi]
  00058	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0005b	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  00060	57		 push	 edi
  00061	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00066	83 c4 04	 add	 esp, 4
  00069	8b fe		 mov	 edi, esi
  0006b	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00071	75 e3		 jne	 SHORT $LL30@OnFavorite
$LN29@OnFavorite:

; 695  : 
; 696  : 		foreach (const FavoriteVolume favorite, FavoriteVolumes)

  00073	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _$S7$2[ebp]
  00079	68 00 00 00 00	 push	 OFFSET ?FavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoriteVolumes
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
  00084	83 c4 08	 add	 esp, 8
  00087	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _$S7$2[ebp]
  0008d	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _$S7$2[ebp]
  00093	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0009a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0009d	ff d0		 call	 eax
  0009f	84 c0		 test	 al, al
  000a1	0f 84 68 02 00
	00		 je	 $LN834@OnFavorite
  000a7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@OnFavorite:
  000b0	ff b5 00 ff ff
	ff		 push	 DWORD PTR _$S7$2[ebp+24]
  000b6	8d 4d 88	 lea	 ecx, DWORD PTR _favorite$5[ebp]
  000b9	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
  000be	33 c0		 xor	 eax, eax
  000c0	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000c4	38 85 ed fe ff
	ff		 cmp	 BYTE PTR _$S7$2[ebp+5], al
  000ca	0f 94 c0	 sete	 al
  000cd	88 85 ed fe ff
	ff		 mov	 BYTE PTR _$S7$2[ebp+5], al
  000d3	84 c0		 test	 al, al
  000d5	0f 84 00 02 00
	00		 je	 $LN6@OnFavorite
  000db	0f 1f 44 00 00	 npad	 5
$LL7@OnFavorite:

; 697  : 		{
; 698  : 			if (favorite.MountOnArrival)

  000e0	80 7d eb 00	 cmp	 BYTE PTR _favorite$5[ebp+99], 0
  000e4	0f 84 d1 01 00
	00		 je	 $LN5@OnFavorite

; 699  : 			{
; 700  : 				FavoritesOnArrivalMountRequired.push_back (favorite);

  000ea	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  000f0	8d 45 88	 lea	 eax, DWORD PTR _favorite$5[ebp]
  000f3	50		 push	 eax
  000f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesOnArrivalMountRequired
  000f9	ff 77 04	 push	 DWORD PTR [edi+4]
  000fc	57		 push	 edi
  000fd	e8 00 00 00 00	 call	 ??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Buynode<GostCrypt::FavoriteVolume const &>
  00102	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+4
  00108	b9 91 24 49 02	 mov	 ecx, 38347921		; 02492491H
  0010d	2b ca		 sub	 ecx, edx
  0010f	8b f0		 mov	 esi, eax
  00111	83 f9 01	 cmp	 ecx, 1
  00114	0f 82 53 02 00
	00		 jb	 $LN812@OnFavorite
  0011a	42		 inc	 edx
  0011b	89 15 04 00 00
	00		 mov	 DWORD PTR ?FavoritesOnArrivalMountRequired@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+4, edx
  00121	89 77 04	 mov	 DWORD PTR [edi+4], esi
  00124	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00127	89 30		 mov	 DWORD PTR [eax], esi

; 701  : 
; 702  : 				if (IsMountedVolume (favorite.Path.c_str()))

  00129	8d 45 88	 lea	 eax, DWORD PTR _favorite$5[ebp]
  0012c	83 7d 9c 10	 cmp	 DWORD PTR _favorite$5[ebp+20], 16 ; 00000010H
  00130	0f 43 45 88	 cmovae	 eax, DWORD PTR _favorite$5[ebp]
  00134	50		 push	 eax
  00135	e8 00 00 00 00	 call	 _IsMountedVolume
  0013a	83 c4 04	 add	 esp, 4
  0013d	85 c0		 test	 eax, eax
  0013f	0f 84 76 01 00
	00		 je	 $LN5@OnFavorite

; 703  : 				{
; 704  : 					bool present = false;
; 705  : 
; 706  : 					foreach (const FavoriteVolume favoriteConnected, FavoritesMountedOnArrivalStillConnected)

  00145	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR _$S8$3[ebp]
  0014b	32 db		 xor	 bl, bl
  0014d	68 00 00 00 00	 push	 OFFSET ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesMountedOnArrivalStillConnected
  00152	50		 push	 eax
  00153	88 9d 1f ff ff
	ff		 mov	 BYTE PTR _present$1$[ebp], bl
  00159	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
  0015e	83 c4 08	 add	 esp, 8
  00161	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _$S8$3[ebp]
  00167	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR _$S8$3[ebp]
  0016d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00171	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00174	ff d0		 call	 eax
  00176	84 c0		 test	 al, al
  00178	0f 84 a0 00 00
	00		 je	 $LN9@OnFavorite
  0017e	66 90		 npad	 2
$LL10@OnFavorite:
  00180	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _$S8$3[ebp+20]
  00186	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _favoriteConnected$4[ebp]
  0018c	83 c0 08	 add	 eax, 8
  0018f	50		 push	 eax
  00190	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
  00195	33 db		 xor	 ebx, ebx
  00197	38 9d 09 ff ff
	ff		 cmp	 BYTE PTR _$S8$3[ebp+5], bl
  0019d	0f 94 c3	 sete	 bl
  001a0	88 9d 09 ff ff
	ff		 mov	 BYTE PTR _$S8$3[ebp+5], bl
  001a6	84 db		 test	 bl, bl
  001a8	74 3b		 je	 SHORT $LN836@OnFavorite
  001aa	66 0f 1f 44 00
	00		 npad	 6
$LL13@OnFavorite:

; 707  : 					{
; 708  : 						if (favorite.Path == favoriteConnected.Path)

  001b0	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _favoriteConnected$4[ebp]
  001b6	50		 push	 eax
  001b7	8d 45 88	 lea	 eax, DWORD PTR _favorite$5[ebp]
  001ba	50		 push	 eax
  001bb	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  001c0	83 c4 08	 add	 esp, 8
  001c3	84 c0		 test	 al, al
  001c5	0f 85 95 01 00
	00		 jne	 $LN800@OnFavorite

; 703  : 				{
; 704  : 					bool present = false;
; 705  : 
; 706  : 					foreach (const FavoriteVolume favoriteConnected, FavoritesMountedOnArrivalStillConnected)

  001cb	33 c0		 xor	 eax, eax
  001cd	c6 85 08 ff ff
	ff 01		 mov	 BYTE PTR _$S8$3[ebp+4], 1
  001d4	84 db		 test	 bl, bl
  001d6	0f 94 c0	 sete	 al
  001d9	8a d8		 mov	 bl, al
  001db	88 9d 09 ff ff
	ff		 mov	 BYTE PTR _$S8$3[ebp+5], bl
  001e1	84 c0		 test	 al, al
  001e3	75 cb		 jne	 SHORT $LL13@OnFavorite
$LN836@OnFavorite:
  001e5	8a 9d 1f ff ff
	ff		 mov	 bl, BYTE PTR _present$1$[ebp]
$LN12@OnFavorite:

; 711  : 							break;
; 712  : 						}
; 713  : 					}

  001eb	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _favoriteConnected$4[ebp]
  001f1	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  001f6	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _$S8$3[ebp]
  001fc	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR _$S8$3[ebp]
  00202	ff 50 08	 call	 DWORD PTR [eax+8]
  00205	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _$S8$3[ebp]
  0020b	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR _$S8$3[ebp]
  00211	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00214	ff d0		 call	 eax
  00216	84 c0		 test	 al, al
  00218	0f 85 62 ff ff
	ff		 jne	 $LL10@OnFavorite
$LN9@OnFavorite:
  0021e	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _$S8$3[ebp+8]
  00224	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00228	8b 38		 mov	 edi, DWORD PTR [eax]
  0022a	89 00		 mov	 DWORD PTR [eax], eax
  0022c	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _$S8$3[ebp+8]
  00232	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00235	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _$S8$3[ebp+8]
  0023b	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S8$3[ebp+12], 0
  00245	3b f8		 cmp	 edi, eax
  00247	74 26		 je	 SHORT $LN328@OnFavorite
  00249	0f 1f 80 00 00
	00 00		 npad	 7
$LL329@OnFavorite:
  00250	8b 37		 mov	 esi, DWORD PTR [edi]
  00252	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00255	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  0025a	57		 push	 edi
  0025b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00260	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _$S8$3[ebp+8]
  00266	83 c4 04	 add	 esp, 4
  00269	8b fe		 mov	 edi, esi
  0026b	3b f0		 cmp	 esi, eax
  0026d	75 e1		 jne	 SHORT $LL329@OnFavorite
$LN328@OnFavorite:
  0026f	50		 push	 eax
  00270	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00275	83 c4 04	 add	 esp, 4

; 714  : 
; 715  : 					if (!present)

  00278	84 db		 test	 bl, bl
  0027a	75 3f		 jne	 SHORT $LN5@OnFavorite

; 716  : 						FavoritesMountedOnArrivalStillConnected.push_back (favorite);

  0027c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00282	8d 45 88	 lea	 eax, DWORD PTR _favorite$5[ebp]
  00285	50		 push	 eax
  00286	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoritesMountedOnArrivalStillConnected
  0028b	ff 77 04	 push	 DWORD PTR [edi+4]
  0028e	57		 push	 edi
  0028f	e8 00 00 00 00	 call	 ??$_Buynode@ABUFavoriteVolume@GostCrypt@@@?$_List_buy@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UFavoriteVolume@GostCrypt@@PAX@1@PAU21@0ABUFavoriteVolume@GostCrypt@@@Z ; std::_List_buy<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Buynode<GostCrypt::FavoriteVolume const &>
  00294	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+4
  0029a	b9 91 24 49 02	 mov	 ecx, 38347921		; 02492491H
  0029f	2b ca		 sub	 ecx, edx
  002a1	8b f0		 mov	 esi, eax
  002a3	83 f9 01	 cmp	 ecx, 1
  002a6	0f 82 c1 00 00
	00		 jb	 $LN812@OnFavorite
  002ac	42		 inc	 edx
  002ad	89 15 04 00 00
	00		 mov	 DWORD PTR ?FavoritesMountedOnArrivalStillConnected@GostCrypt@@3V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+4, edx
  002b3	89 77 04	 mov	 DWORD PTR [edi+4], esi
  002b6	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  002b9	89 30		 mov	 DWORD PTR [eax], esi
$LN5@OnFavorite:

; 695  : 
; 696  : 		foreach (const FavoriteVolume favorite, FavoriteVolumes)

  002bb	33 c0		 xor	 eax, eax
  002bd	c6 85 ec fe ff
	ff 01		 mov	 BYTE PTR _$S7$2[ebp+4], 1
  002c4	38 85 ed fe ff
	ff		 cmp	 BYTE PTR _$S7$2[ebp+5], al
  002ca	0f 94 c0	 sete	 al
  002cd	88 85 ed fe ff
	ff		 mov	 BYTE PTR _$S7$2[ebp+5], al
  002d3	84 c0		 test	 al, al
  002d5	0f 85 05 fe ff
	ff		 jne	 $LL7@OnFavorite
$LN6@OnFavorite:

; 717  : 				}
; 718  : 			}
; 719  : 		}

  002db	8d 4d 88	 lea	 ecx, DWORD PTR _favorite$5[ebp]
  002de	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002e2	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  002e7	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _$S7$2[ebp]
  002ed	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _$S7$2[ebp]
  002f3	ff 50 08	 call	 DWORD PTR [eax+8]
  002f6	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _$S7$2[ebp]
  002fc	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _$S7$2[ebp]
  00302	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00305	ff d0		 call	 eax
  00307	84 c0		 test	 al, al
  00309	0f 85 a1 fd ff
	ff		 jne	 $LL4@OnFavorite
$LN834@OnFavorite:
  0030f	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _$S7$2[ebp+8]
  00315	85 f6		 test	 esi, esi
  00317	0f 84 9f 00 00
	00		 je	 $LN652@OnFavorite
  0031d	8b bd f4 fe ff
	ff		 mov	 edi, DWORD PTR _$S7$2[ebp+12]
  00323	3b f7		 cmp	 esi, edi
  00325	74 14		 je	 SHORT $LN693@OnFavorite
$LL694@OnFavorite:
  00327	8b ce		 mov	 ecx, esi
  00329	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  0032e	83 c6 68	 add	 esi, 104		; 00000068H
  00331	3b f7		 cmp	 esi, edi
  00333	75 f2		 jne	 SHORT $LL694@OnFavorite
  00335	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _$S7$2[ebp+8]
$LN693@OnFavorite:
  0033b	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _$S7$2[ebp+16]
  00341	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00346	2b ce		 sub	 ecx, esi
  00348	f7 e9		 imul	 ecx
  0034a	c1 fa 05	 sar	 edx, 5
  0034d	8b c2		 mov	 eax, edx
  0034f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00352	03 c2		 add	 eax, edx
  00354	3d 62 27 76 02	 cmp	 eax, 41297762		; 02762762H
  00359	76 1c		 jbe	 SHORT $LN746@OnFavorite
  0035b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN839@OnFavorite:
$LN800@OnFavorite:

; 709  : 						{
; 710  : 							present = true;

  00360	b3 01		 mov	 bl, 1
  00362	88 9d 1f ff ff
	ff		 mov	 BYTE PTR _present$1$[ebp], bl
  00368	e9 7e fe ff ff	 jmp	 $LN12@OnFavorite
$LN812@OnFavorite:

; 716  : 						FavoritesMountedOnArrivalStillConnected.push_back (favorite);

  0036d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00372	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN840@OnFavorite:

; 717  : 				}
; 718  : 			}
; 719  : 		}

$LN746@OnFavorite:
  00377	6b c0 68	 imul	 eax, eax, 104
  0037a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0037f	72 32		 jb	 SHORT $LN747@OnFavorite
  00381	f6 85 f0 fe ff
	ff 1f		 test	 BYTE PTR _$S7$2[ebp+8], 31 ; 0000001fH
  00388	74 05		 je	 SHORT $LN748@OnFavorite
  0038a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN841@OnFavorite:
$LN748@OnFavorite:
  0038f	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00392	3b c6		 cmp	 eax, esi
  00394	72 05		 jb	 SHORT $LN749@OnFavorite
  00396	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN842@OnFavorite:
$LN749@OnFavorite:
  0039b	2b f0		 sub	 esi, eax
  0039d	83 fe 04	 cmp	 esi, 4
  003a0	73 05		 jae	 SHORT $LN750@OnFavorite
  003a2	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN843@OnFavorite:
$LN750@OnFavorite:
  003a7	83 fe 23	 cmp	 esi, 35			; 00000023H
  003aa	76 05		 jbe	 SHORT $LN751@OnFavorite
  003ac	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN844@OnFavorite:
$LN751@OnFavorite:
  003b1	8b f0		 mov	 esi, eax
$LN747@OnFavorite:
  003b3	56		 push	 esi
  003b4	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  003b9	83 c4 04	 add	 esp, 4
$LN652@OnFavorite:

; 720  : 	}

  003bc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003bf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003c6	59		 pop	 ecx
  003c7	5f		 pop	 edi
  003c8	5e		 pop	 esi
  003c9	5b		 pop	 ebx
  003ca	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003cd	33 cd		 xor	 ecx, ebp
  003cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003d4	8b e5		 mov	 esp, ebp
  003d6	5d		 pop	 ebp
  003d7	c3		 ret	 0
$LN838@OnFavorite:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ$0:
  00000	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _$S7$2[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ$1:
  0000b	8d 4d 88	 lea	 ecx, DWORD PTR _favorite$5[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
__unwindfunclet$?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ$2:
  00013	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR _$S8$3[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$list@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__ehhandler$?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ:
  0001e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00022	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00025	8b 8a e4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-284]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ
  00041	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ ENDP		; GostCrypt::OnFavoriteVolumesUpdated
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z
_TEXT	SEGMENT
_size$ = -2308						; size = 4
_e$2 = -2304						; size = 4
_favoritesXml$1$ = -2300				; size = 4
$T3 = -2300						; size = 4
_favorites$GSCopy$1$ = -2296				; size = 4
_boolVal$4 = -2296					; size = 2
_bootEnc$5 = -2292					; size = 1480
_label$6 = -1836					; size = 1024
$T7 = -812						; size = 24
$T8 = -788						; size = 24
_resolvedPath$9 = -764					; size = 24
_favorite$10 = -740					; size = 104
$T11 = -636						; size = 24
$T12 = -636						; size = 24
$T13 = -636						; size = 24
$T14 = -612						; size = 24
$T15 = -612						; size = 24
$T16 = -612						; size = 24
$T17 = -588						; size = 24
$T18 = -588						; size = 24
_favoritesFilePath$ = -564				; size = 24
_volume$ = -540						; size = 260
_mountPoint$ = -280					; size = 260
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_favorites$ = 8						; size = 4
_systemFavorites$ = 12					; size = 1
_noUacElevation$ = 16					; size = 1
?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z PROC ; GostCrypt::LoadFavoriteVolumes, COMDAT

; 585  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec fc 08 00
	00		 sub	 esp, 2300		; 000008fcH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 5d 08	 mov	 ebx, DWORD PTR _favorites$[ebp]
  00034	c7 85 04 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], 0
  0003e	89 9d 08 f7 ff
	ff		 mov	 DWORD PTR _favorites$GSCopy$1$[ebp], ebx

; 586  : 		favorites.clear();

  00044	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00047	8b 33		 mov	 esi, DWORD PTR [ebx]
  00049	3b f7		 cmp	 esi, edi
  0004b	74 11		 je	 SHORT $LN80@LoadFavori
  0004d	0f 1f 00	 npad	 3
$LL81@LoadFavori:
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  00057	83 c6 68	 add	 esi, 104		; 00000068H
  0005a	3b f7		 cmp	 esi, edi
  0005c	75 f2		 jne	 SHORT $LL81@LoadFavori
$LN80@LoadFavori:

; 587  : 		string favoritesFilePath = systemFavorites ? GetServiceConfigPath (GST_APPD_FILENAME_SYSTEM_FAVORITE_VOLUMES) : GetConfigPath (GST_APPD_FILENAME_FAVORITE_VOLUMES);

  0005e	80 7d 0c 00	 cmp	 BYTE PTR _systemFavorites$[ebp], 0
  00062	8b 03		 mov	 eax, DWORD PTR [ebx]
  00064	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00067	74 1d		 je	 SHORT $LN20@LoadFavori
  00069	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ?GetServiceConfigPath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; GetServiceConfigPath
  0007a	83 c4 08	 add	 esp, 8
  0007d	8b f0		 mov	 esi, eax
  0007f	bb 01 00 00 00	 mov	 ebx, 1
  00084	eb 5b		 jmp	 SHORT $LN21@LoadFavori
$LN20@LoadFavori:
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EGBOIEGJ@Favorite?5Volumes?4xml?$AA@
  0008b	e8 00 00 00 00	 call	 _GetConfigPath
  00090	8b d0		 mov	 edx, eax
  00092	c7 85 c8 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T18[ebp+20], 15 ; 0000000fH
  0009c	83 c4 04	 add	 esp, 4
  0009f	c7 85 c4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+16], 0
  000a9	c6 85 b4 fd ff
	ff 00		 mov	 BYTE PTR $T18[ebp], 0
  000b0	80 3a 00	 cmp	 BYTE PTR [edx], 0
  000b3	75 04		 jne	 SHORT $LN223@LoadFavori
  000b5	33 c9		 xor	 ecx, ecx
  000b7	eb 10		 jmp	 SHORT $LN224@LoadFavori
$LN223@LoadFavori:
  000b9	8b ca		 mov	 ecx, edx
  000bb	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  000be	66 90		 npad	 2
$LL2847@LoadFavori:
  000c0	8a 01		 mov	 al, BYTE PTR [ecx]
  000c2	41		 inc	 ecx
  000c3	84 c0		 test	 al, al
  000c5	75 f9		 jne	 SHORT $LL2847@LoadFavori
  000c7	2b ce		 sub	 ecx, esi
$LN224@LoadFavori:
  000c9	51		 push	 ecx
  000ca	52		 push	 edx
  000cb	8d 8d b4 fd ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  000d1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000d6	8d b5 b4 fd ff
	ff		 lea	 esi, DWORD PTR $T18[ebp]
  000dc	bb 02 00 00 00	 mov	 ebx, 2
$LN21@LoadFavori:
  000e1	c7 85 e0 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR _favoritesFilePath$[ebp+20], 15 ; 0000000fH
  000eb	c7 85 dc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _favoritesFilePath$[ebp+16], 0
  000f5	c6 85 cc fd ff
	ff 00		 mov	 BYTE PTR _favoritesFilePath$[ebp], 0
  000fc	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00100	73 1b		 jae	 SHORT $LN351@LoadFavori
  00102	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00105	83 c0 01	 add	 eax, 1
  00108	74 21		 je	 SHORT $LN352@LoadFavori
  0010a	50		 push	 eax
  0010b	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _favoritesFilePath$[ebp]
  00111	56		 push	 esi
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 _memmove
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011b	eb 0e		 jmp	 SHORT $LN352@LoadFavori
$LN351@LoadFavori:
  0011d	8b 06		 mov	 eax, DWORD PTR [esi]
  0011f	89 85 cc fd ff
	ff		 mov	 DWORD PTR _favoritesFilePath$[ebp], eax
  00125	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN352@LoadFavori:
  0012b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0012e	89 85 dc fd ff
	ff		 mov	 DWORD PTR _favoritesFilePath$[ebp+16], eax
  00134	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00137	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _favoritesFilePath$[ebp+20], eax
  0013d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00144	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00148	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0014f	72 02		 jb	 SHORT $LN577@LoadFavori
  00151	8b 36		 mov	 esi, DWORD PTR [esi]
$LN577@LoadFavori:
  00153	c6 06 00	 mov	 BYTE PTR [esi], 0
  00156	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  0015d	f6 c3 02	 test	 bl, 2
  00160	74 3c		 je	 SHORT $LN584@LoadFavori
  00162	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR $T18[ebp+20]
  00168	83 e3 fd	 and	 ebx, -3			; fffffffdH
  0016b	83 f8 10	 cmp	 eax, 16			; 00000010H
  0016e	72 13		 jb	 SHORT $LN589@LoadFavori
  00170	40		 inc	 eax
  00171	8d 8d b4 fd ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  00177	50		 push	 eax
  00178	ff b5 b4 fd ff
	ff		 push	 DWORD PTR $T18[ebp]
  0017e	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN589@LoadFavori:
  00183	c7 85 c8 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T18[ebp+20], 15 ; 0000000fH
  0018d	c7 85 c4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+16], 0
  00197	c6 85 b4 fd ff
	ff 00		 mov	 BYTE PTR $T18[ebp], 0
$LN584@LoadFavori:
  0019e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  001a2	f6 c3 01	 test	 bl, 1
  001a5	74 39		 je	 SHORT $LN685@LoadFavori
  001a7	8b 85 b0 fd ff
	ff		 mov	 eax, DWORD PTR $T16[ebp+20]
  001ad	83 f8 10	 cmp	 eax, 16			; 00000010H
  001b0	72 13		 jb	 SHORT $LN690@LoadFavori
  001b2	40		 inc	 eax
  001b3	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  001b9	50		 push	 eax
  001ba	ff b5 9c fd ff
	ff		 push	 DWORD PTR $T16[ebp]
  001c0	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN690@LoadFavori:
  001c5	c7 85 b0 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+20], 15 ; 0000000fH
  001cf	c7 85 ac fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp+16], 0
  001d9	c6 85 9c fd ff
	ff 00		 mov	 BYTE PTR $T16[ebp], 0
$LN685@LoadFavori:

; 588  : 
; 589  : 		if (systemFavorites && !IsAdmin() && !noUacElevation)

  001e0	8a 7d 0c	 mov	 bh, BYTE PTR _systemFavorites$[ebp]
  001e3	84 ff		 test	 bh, bh
  001e5	0f 84 21 01 00
	00		 je	 $LN2851@LoadFavori
  001eb	e8 00 00 00 00	 call	 _IsAdmin
  001f0	85 c0		 test	 eax, eax
  001f2	0f 85 14 01 00
	00		 jne	 $LN2851@LoadFavori
  001f8	8a 5d 10	 mov	 bl, BYTE PTR _noUacElevation$[ebp]
  001fb	84 db		 test	 bl, bl
  001fd	0f 85 0c 01 00
	00		 jne	 $LN45@LoadFavori

; 590  : 		{
; 591  : 			favoritesFilePath = GetConfigPath (GST_APPD_FILENAME_SYSTEM_FAVORITE_VOLUMES);

  00203	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@
  00208	e8 00 00 00 00	 call	 _GetConfigPath
  0020d	8b d0		 mov	 edx, eax
  0020f	83 c4 04	 add	 esp, 4
  00212	38 1a		 cmp	 BYTE PTR [edx], bl
  00214	75 04		 jne	 SHORT $LN791@LoadFavori
  00216	33 c9		 xor	 ecx, ecx
  00218	eb 0f		 jmp	 SHORT $LN792@LoadFavori
$LN791@LoadFavori:
  0021a	8b ca		 mov	 ecx, edx
  0021c	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0021f	90		 npad	 1
$LL2848@LoadFavori:
  00220	8a 01		 mov	 al, BYTE PTR [ecx]
  00222	41		 inc	 ecx
  00223	84 c0		 test	 al, al
  00225	75 f9		 jne	 SHORT $LL2848@LoadFavori
  00227	2b ce		 sub	 ecx, esi
$LN792@LoadFavori:
  00229	51		 push	 ecx
  0022a	52		 push	 edx
  0022b	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _favoritesFilePath$[ebp]
  00231	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 592  : 
; 593  : 			try
; 594  : 			{
; 595  : 				BootEncryption bootEnc (MainDlg);

  00236	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  0023c	8d 8d 0c f7 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$5[ebp]
  00242	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  00246	e8 00 00 00 00	 call	 ??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z ; GostCrypt::BootEncryption::BootEncryption

; 596  : 				bootEnc.CopyFileAdmin (GetServiceConfigPath (GST_APPD_FILENAME_SYSTEM_FAVORITE_VOLUMES).c_str(), favoritesFilePath.c_str());

  0024b	83 bd e0 fd ff
	ff 10		 cmp	 DWORD PTR _favoritesFilePath$[ebp+20], 16 ; 00000010H
  00252	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _favoritesFilePath$[ebp]
  00258	8d 8d ec fc ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0025e	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  00262	0f 43 85 cc fd
	ff ff		 cmovae	 eax, DWORD PTR _favoritesFilePath$[ebp]
  00269	50		 push	 eax
  0026a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0026f	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00275	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  00279	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@
  0027e	50		 push	 eax
  0027f	e8 00 00 00 00	 call	 ?GetServiceConfigPath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; GetServiceConfigPath
  00284	83 c4 08	 add	 esp, 8
  00287	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0028b	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  0028f	72 02		 jb	 SHORT $LN824@LoadFavori
  00291	8b 00		 mov	 eax, DWORD PTR [eax]
$LN824@LoadFavori:
  00293	50		 push	 eax
  00294	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  0029a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0029f	8d 85 ec fc ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  002a5	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+12], 7
  002a9	50		 push	 eax
  002aa	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  002b0	50		 push	 eax
  002b1	8d 8d 0c f7 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$5[ebp]
  002b7	e8 00 00 00 00	 call	 ?CopyFileAdmin@BootEncryption@GostCrypt@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; GostCrypt::BootEncryption::CopyFileAdmin
  002bc	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  002c2	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  002c7	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  002cd	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  002d2	8d 8d ec fc ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  002d8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 597  : 			}

  002dd	8d 8d 0c f7 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$5[ebp]
  002e3	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
  002e8	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  002ef	eb 1e		 jmp	 SHORT $LN45@LoadFavori
__catch$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$0:

; 598  : 			catch (SystemException &e)
; 599  : 			{
; 600  : 				if (e.ErrorCode == ERROR_FILE_NOT_FOUND)

  002f1	8b 85 00 f7 ff
	ff		 mov	 eax, DWORD PTR _e$2[ebp]
  002f7	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  002fb	75 06		 jne	 SHORT $LN6@LoadFavori

; 601  : 					return;

  002fd	b8 00 00 00 00	 mov	 eax, $LN44@LoadFavori
  00302	c3		 ret	 0
$LN6@LoadFavori:

; 602  : 
; 603  : 				throw;

  00303	6a 00		 push	 0
  00305	6a 00		 push	 0
  00307	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2854@LoadFavori:
$LN2851@LoadFavori:
  0030c	8a 5d 10	 mov	 bl, BYTE PTR _noUacElevation$[ebp]
$LN45@LoadFavori:

; 604  : 			}
; 605  : 		}
; 606  : 
; 607  : 		DWORD size;
; 608  : 		char *favoritesXml = LoadFile (favoritesFilePath.c_str(), &size);

  0030f	83 bd e0 fd ff
	ff 10		 cmp	 DWORD PTR _favoritesFilePath$[ebp+20], 16 ; 00000010H
  00316	8d 8d fc f6 ff
	ff		 lea	 ecx, DWORD PTR _size$[ebp]
  0031c	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR _favoritesFilePath$[ebp]
  00322	0f 43 85 cc fd
	ff ff		 cmovae	 eax, DWORD PTR _favoritesFilePath$[ebp]
  00329	51		 push	 ecx
  0032a	50		 push	 eax
  0032b	e8 00 00 00 00	 call	 _LoadFile
  00330	83 c4 08	 add	 esp, 8
  00333	8b f0		 mov	 esi, eax
  00335	89 b5 04 f7 ff
	ff		 mov	 DWORD PTR _favoritesXml$1$[ebp], esi

; 609  : 
; 610  : 		if (systemFavorites && !IsAdmin() && !noUacElevation)

  0033b	84 ff		 test	 bh, bh
  0033d	74 21		 je	 SHORT $LN7@LoadFavori
  0033f	e8 00 00 00 00	 call	 _IsAdmin
  00344	85 c0		 test	 eax, eax
  00346	75 18		 jne	 SHORT $LN7@LoadFavori
  00348	84 db		 test	 bl, bl
  0034a	75 14		 jne	 SHORT $LN7@LoadFavori

; 611  : 			DeleteFile (GetConfigPath (GST_APPD_FILENAME_SYSTEM_FAVORITE_VOLUMES));

  0034c	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KHDBJKEN@GostCrypt?5System?5Favorite?5Volume@
  00351	e8 00 00 00 00	 call	 _GetConfigPath
  00356	83 c4 04	 add	 esp, 4
  00359	50		 push	 eax
  0035a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4
$LN7@LoadFavori:

; 612  : 
; 613  : 		char *xml = favoritesXml;
; 614  : 		char mountPoint[MAX_PATH], volume[MAX_PATH];
; 615  : 
; 616  : 		if (xml == NULL)

  00360	85 f6		 test	 esi, esi
  00362	75 27		 jne	 SHORT $LN2820@LoadFavori

; 617  : 			return;

  00364	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR _favoritesFilePath$[ebp+20]
  0036a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0036d	0f 82 c9 05 00
	00		 jb	 $LN1@LoadFavori
  00373	40		 inc	 eax
  00374	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _favoritesFilePath$[ebp]
  0037a	50		 push	 eax
  0037b	ff b5 cc fd ff
	ff		 push	 DWORD PTR _favoritesFilePath$[ebp]
  00381	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  00386	e9 b1 05 00 00	 jmp	 $LN1@LoadFavori
$LN2820@LoadFavori:

; 618  : 
; 619  : 		while (xml = XmlFindElement (xml, "volume"))

  0038b	68 00 00 00 00	 push	 OFFSET ??_C@_06EMCPHFGM@volume?$AA@
  00390	56		 push	 esi
  00391	e8 00 00 00 00	 call	 _XmlFindElement
  00396	8b f0		 mov	 esi, eax
  00398	83 c4 08	 add	 esp, 8
  0039b	85 f6		 test	 esi, esi
  0039d	0f 84 80 05 00
	00		 je	 $LN3@LoadFavori
  003a3	8b 9d 08 f7 ff
	ff		 mov	 ebx, DWORD PTR _favorites$GSCopy$1$[ebp]
  003a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@LoadFavori:

; 620  : 		{
; 621  : 			FavoriteVolume favorite;

  003b0	33 c0		 xor	 eax, eax
  003b2	c7 85 30 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR _favorite$10[ebp+20], 15 ; 0000000fH
  003bc	c7 85 2c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _favorite$10[ebp+16], 0
  003c6	c6 85 1c fd ff
	ff 00		 mov	 BYTE PTR _favorite$10[ebp], 0
  003cd	c7 85 48 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR _favorite$10[ebp+44], 15 ; 0000000fH
  003d7	c7 85 44 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _favorite$10[ebp+40], 0
  003e1	c6 85 34 fd ff
	ff 00		 mov	 BYTE PTR _favorite$10[ebp+24], 0
  003e8	c7 85 60 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR _favorite$10[ebp+68], 15 ; 0000000fH
  003f2	c7 85 5c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _favorite$10[ebp+64], 0
  003fc	c6 85 4c fd ff
	ff 00		 mov	 BYTE PTR _favorite$10[ebp+48], 0
  00403	c7 85 78 fd ff
	ff 07 00 00 00	 mov	 DWORD PTR _favorite$10[ebp+92], 7
  0040d	c7 85 74 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _favorite$10[ebp+88], 0
  00417	66 89 85 64 fd
	ff ff		 mov	 WORD PTR _favorite$10[ebp+72], ax
  0041e	89 85 7c fd ff
	ff		 mov	 DWORD PTR _favorite$10[ebp+96], eax
  00424	89 85 80 fd ff
	ff		 mov	 DWORD PTR _favorite$10[ebp+100], eax

; 622  : 
; 623  : 			XmlGetAttributeText (xml, "mountpoint", mountPoint, sizeof (mountPoint));

  0042a	68 04 01 00 00	 push	 260			; 00000104H
  0042f	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _mountPoint$[ebp]
  00435	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+12], 9
  00439	50		 push	 eax
  0043a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BHNCAFPG@mountpoint?$AA@
  0043f	56		 push	 esi
  00440	e8 00 00 00 00	 call	 _XmlGetAttributeText
  00445	83 c4 10	 add	 esp, 16			; 00000010H

; 624  : 			favorite.MountPoint = mountPoint;

  00448	80 bd e8 fe ff
	ff 00		 cmp	 BYTE PTR _mountPoint$[ebp], 0
  0044f	75 04		 jne	 SHORT $LN1449@LoadFavori
  00451	33 c9		 xor	 ecx, ecx
  00453	eb 14		 jmp	 SHORT $LN1450@LoadFavori
$LN1449@LoadFavori:
  00455	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _mountPoint$[ebp]
  0045b	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0045e	66 90		 npad	 2
$LL2849@LoadFavori:
  00460	8a 01		 mov	 al, BYTE PTR [ecx]
  00462	41		 inc	 ecx
  00463	84 c0		 test	 al, al
  00465	75 f9		 jne	 SHORT $LL2849@LoadFavori
  00467	2b ca		 sub	 ecx, edx
$LN1450@LoadFavori:
  00469	51		 push	 ecx
  0046a	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _mountPoint$[ebp]
  00470	50		 push	 eax
  00471	8d 8d 34 fd ff
	ff		 lea	 ecx, DWORD PTR _favorite$10[ebp+24]
  00477	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 625  : 
; 626  : 			XmlGetNodeText (xml, volume, sizeof (volume));

  0047c	68 04 01 00 00	 push	 260			; 00000104H
  00481	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _volume$[ebp]
  00487	50		 push	 eax
  00488	56		 push	 esi
  00489	e8 00 00 00 00	 call	 _XmlGetNodeText
  0048e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 627  : 			favorite.Path = WideToSingleString (Utf8StringToWide (volume));

  00491	c7 85 c8 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+20], 15 ; 0000000fH
  0049b	80 bd e4 fd ff
	ff 00		 cmp	 BYTE PTR _volume$[ebp], 0
  004a2	c7 85 c4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+16], 0
  004ac	c6 85 b4 fd ff
	ff 00		 mov	 BYTE PTR $T17[ebp], 0
  004b3	75 04		 jne	 SHORT $LN1561@LoadFavori
  004b5	33 c9		 xor	 ecx, ecx
  004b7	eb 12		 jmp	 SHORT $LN1562@LoadFavori
$LN1561@LoadFavori:
  004b9	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _volume$[ebp]
  004bf	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2850@LoadFavori:
  004c2	8a 01		 mov	 al, BYTE PTR [ecx]
  004c4	41		 inc	 ecx
  004c5	84 c0		 test	 al, al
  004c7	75 f9		 jne	 SHORT $LL2850@LoadFavori
  004c9	2b ca		 sub	 ecx, edx
$LN1562@LoadFavori:
  004cb	51		 push	 ecx
  004cc	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _volume$[ebp]
  004d2	50		 push	 eax
  004d3	8d 8d b4 fd ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  004d9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  004de	8d 85 b4 fd ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  004e4	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  004e8	50		 push	 eax
  004e9	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  004ef	50		 push	 eax
  004f0	e8 00 00 00 00	 call	 ?Utf8StringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; Utf8StringToWide
  004f5	50		 push	 eax
  004f6	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  004fc	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+12], 11 ; 0000000bH
  00500	50		 push	 eax
  00501	e8 00 00 00 00	 call	 ?WideToSingleString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; WideToSingleString
  00506	83 c4 10	 add	 esp, 16			; 00000010H
  00509	8b f8		 mov	 edi, eax
  0050b	8d 85 1c fd ff
	ff		 lea	 eax, DWORD PTR _favorite$10[ebp]
  00511	3b c7		 cmp	 eax, edi
  00513	74 45		 je	 SHORT $LN1567@LoadFavori
  00515	8b 85 30 fd ff
	ff		 mov	 eax, DWORD PTR _favorite$10[ebp+20]
  0051b	83 f8 10	 cmp	 eax, 16			; 00000010H
  0051e	72 13		 jb	 SHORT $LN1573@LoadFavori
  00520	40		 inc	 eax
  00521	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR _favorite$10[ebp]
  00527	50		 push	 eax
  00528	ff b5 1c fd ff
	ff		 push	 DWORD PTR _favorite$10[ebp]
  0052e	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN1573@LoadFavori:
  00533	57		 push	 edi
  00534	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR _favorite$10[ebp]
  0053a	c7 85 30 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR _favorite$10[ebp+20], 15 ; 0000000fH
  00544	c7 85 2c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _favorite$10[ebp+16], 0
  0054e	c6 85 1c fd ff
	ff 00		 mov	 BYTE PTR _favorite$10[ebp], 0
  00555	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN1567@LoadFavori:
  0055a	8b 85 b0 fd ff
	ff		 mov	 eax, DWORD PTR $T15[ebp+20]
  00560	83 f8 10	 cmp	 eax, 16			; 00000010H
  00563	72 13		 jb	 SHORT $LN1863@LoadFavori
  00565	40		 inc	 eax
  00566	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  0056c	50		 push	 eax
  0056d	ff b5 9c fd ff
	ff		 push	 DWORD PTR $T15[ebp]
  00573	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN1863@LoadFavori:
  00578	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR $T12[ebp+20]
  0057e	c7 85 b0 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T15[ebp+20], 15 ; 0000000fH
  00588	c7 85 ac fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp+16], 0
  00592	c6 85 9c fd ff
	ff 00		 mov	 BYTE PTR $T15[ebp], 0
  00599	83 f8 08	 cmp	 eax, 8
  0059c	72 13		 jb	 SHORT $LN1964@LoadFavori
  0059e	40		 inc	 eax
  0059f	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  005a5	50		 push	 eax
  005a6	ff b5 84 fd ff
	ff		 push	 DWORD PTR $T12[ebp]
  005ac	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN1964@LoadFavori:
  005b1	33 c0		 xor	 eax, eax
  005b3	c7 85 98 fd ff
	ff 07 00 00 00	 mov	 DWORD PTR $T12[ebp+20], 7
  005bd	66 89 85 84 fd
	ff ff		 mov	 WORD PTR $T12[ebp], ax
  005c4	8b 85 c8 fd ff
	ff		 mov	 eax, DWORD PTR $T17[ebp+20]
  005ca	c7 85 94 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T12[ebp+16], 0
  005d4	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+12], 9
  005d8	83 f8 10	 cmp	 eax, 16			; 00000010H
  005db	72 13		 jb	 SHORT $LN2067@LoadFavori
  005dd	40		 inc	 eax
  005de	8d 8d b4 fd ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  005e4	50		 push	 eax
  005e5	ff b5 b4 fd ff
	ff		 push	 DWORD PTR $T17[ebp]
  005eb	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN2067@LoadFavori:

; 628  : 
; 629  : 			char label[1024];
; 630  : 			XmlGetAttributeText (xml, "label", label, sizeof (label));

  005f0	68 00 04 00 00	 push	 1024			; 00000400H
  005f5	8d 85 d4 f8 ff
	ff		 lea	 eax, DWORD PTR _label$6[ebp]
  005fb	50		 push	 eax
  005fc	68 00 00 00 00	 push	 OFFSET ??_C@_05IDCCNNGI@label?$AA@
  00601	56		 push	 esi
  00602	e8 00 00 00 00	 call	 _XmlGetAttributeText
  00607	83 c4 10	 add	 esp, 16			; 00000010H

; 631  : 			favorite.Label = Utf8StringToWide (label);

  0060a	8d 85 d4 f8 ff
	ff		 lea	 eax, DWORD PTR _label$6[ebp]
  00610	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  00616	50		 push	 eax
  00617	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0061c	8d 85 9c fd ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  00622	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+12], 13 ; 0000000dH
  00626	50		 push	 eax
  00627	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  0062d	50		 push	 eax
  0062e	e8 00 00 00 00	 call	 ?Utf8StringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; Utf8StringToWide
  00633	83 c4 08	 add	 esp, 8
  00636	8b f8		 mov	 edi, eax
  00638	8d 85 64 fd ff
	ff		 lea	 eax, DWORD PTR _favorite$10[ebp+72]
  0063e	3b c7		 cmp	 eax, edi
  00640	74 47		 je	 SHORT $LN2166@LoadFavori
  00642	8b 85 78 fd ff
	ff		 mov	 eax, DWORD PTR _favorite$10[ebp+92]
  00648	83 f8 08	 cmp	 eax, 8
  0064b	72 13		 jb	 SHORT $LN2172@LoadFavori
  0064d	40		 inc	 eax
  0064e	8d 8d 64 fd ff
	ff		 lea	 ecx, DWORD PTR _favorite$10[ebp+72]
  00654	50		 push	 eax
  00655	ff b5 64 fd ff
	ff		 push	 DWORD PTR _favorite$10[ebp+72]
  0065b	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN2172@LoadFavori:
  00660	33 c0		 xor	 eax, eax
  00662	c7 85 78 fd ff
	ff 07 00 00 00	 mov	 DWORD PTR _favorite$10[ebp+92], 7
  0066c	57		 push	 edi
  0066d	8d 8d 64 fd ff
	ff		 lea	 ecx, DWORD PTR _favorite$10[ebp+72]
  00673	c7 85 74 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _favorite$10[ebp+88], 0
  0067d	66 89 85 64 fd
	ff ff		 mov	 WORD PTR _favorite$10[ebp+72], ax
  00684	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN2166@LoadFavori:
  00689	8b 85 98 fd ff
	ff		 mov	 eax, DWORD PTR $T11[ebp+20]
  0068f	83 f8 08	 cmp	 eax, 8
  00692	72 13		 jb	 SHORT $LN2394@LoadFavori
  00694	40		 inc	 eax
  00695	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  0069b	50		 push	 eax
  0069c	ff b5 84 fd ff
	ff		 push	 DWORD PTR $T11[ebp]
  006a2	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN2394@LoadFavori:
  006a7	33 c0		 xor	 eax, eax
  006a9	c7 85 98 fd ff
	ff 07 00 00 00	 mov	 DWORD PTR $T11[ebp+20], 7
  006b3	66 89 85 84 fd
	ff ff		 mov	 WORD PTR $T11[ebp], ax
  006ba	8b 85 b0 fd ff
	ff		 mov	 eax, DWORD PTR $T14[ebp+20]
  006c0	c7 85 94 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+16], 0
  006ca	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+12], 9
  006ce	83 f8 10	 cmp	 eax, 16			; 00000010H
  006d1	72 13		 jb	 SHORT $LN2497@LoadFavori
  006d3	40		 inc	 eax
  006d4	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  006da	50		 push	 eax
  006db	ff b5 9c fd ff
	ff		 push	 DWORD PTR $T14[ebp]
  006e1	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN2497@LoadFavori:

; 632  : 
; 633  : 			char boolVal[2];
; 634  : 			XmlGetAttributeText (xml, "readonly", boolVal, sizeof (boolVal));

  006e6	6a 02		 push	 2
  006e8	8d 85 08 f7 ff
	ff		 lea	 eax, DWORD PTR _boolVal$4[ebp]
  006ee	50		 push	 eax
  006ef	68 00 00 00 00	 push	 OFFSET ??_C@_08JOKHDEJH@readonly?$AA@
  006f4	56		 push	 esi
  006f5	e8 00 00 00 00	 call	 _XmlGetAttributeText

; 635  : 			if (boolVal[0])

  006fa	66 8b 85 08 f7
	ff ff		 mov	 ax, WORD PTR _boolVal$4[ebp]
  00701	83 c4 10	 add	 esp, 16			; 00000010H
  00704	84 c0		 test	 al, al
  00706	74 09		 je	 SHORT $LN9@LoadFavori

; 636  : 				favorite.ReadOnly = (boolVal[0] == '1');

  00708	3c 31		 cmp	 al, 49			; 00000031H
  0070a	0f 94 85 81 fd
	ff ff		 sete	 BYTE PTR _favorite$10[ebp+101]
$LN9@LoadFavori:

; 637  : 
; 638  : 			XmlGetAttributeText (xml, "removable", boolVal, sizeof (boolVal));

  00711	6a 02		 push	 2
  00713	8d 85 08 f7 ff
	ff		 lea	 eax, DWORD PTR _boolVal$4[ebp]
  00719	50		 push	 eax
  0071a	68 00 00 00 00	 push	 OFFSET ??_C@_09HPGMKNKO@removable?$AA@
  0071f	56		 push	 esi
  00720	e8 00 00 00 00	 call	 _XmlGetAttributeText

; 639  : 			if (boolVal[0])

  00725	66 8b 85 08 f7
	ff ff		 mov	 ax, WORD PTR _boolVal$4[ebp]
  0072c	83 c4 10	 add	 esp, 16			; 00000010H
  0072f	84 c0		 test	 al, al
  00731	74 09		 je	 SHORT $LN10@LoadFavori

; 640  : 				favorite.Removable = (boolVal[0] == '1');

  00733	3c 31		 cmp	 al, 49			; 00000031H
  00735	0f 94 85 82 fd
	ff ff		 sete	 BYTE PTR _favorite$10[ebp+102]
$LN10@LoadFavori:

; 641  : 
; 642  : 			XmlGetAttributeText (xml, "system", boolVal, sizeof (boolVal));

  0073c	6a 02		 push	 2
  0073e	8d 85 08 f7 ff
	ff		 lea	 eax, DWORD PTR _boolVal$4[ebp]
  00744	50		 push	 eax
  00745	68 00 00 00 00	 push	 OFFSET ??_C@_06FHFOAHML@system?$AA@
  0074a	56		 push	 esi
  0074b	e8 00 00 00 00	 call	 _XmlGetAttributeText

; 643  : 			if (boolVal[0])

  00750	66 8b 85 08 f7
	ff ff		 mov	 ax, WORD PTR _boolVal$4[ebp]
  00757	83 c4 10	 add	 esp, 16			; 00000010H
  0075a	84 c0		 test	 al, al
  0075c	74 09		 je	 SHORT $LN11@LoadFavori

; 644  : 				favorite.SystemEncryption = (boolVal[0] == '1');

  0075e	3c 31		 cmp	 al, 49			; 00000031H
  00760	0f 94 85 83 fd
	ff ff		 sete	 BYTE PTR _favorite$10[ebp+103]
$LN11@LoadFavori:

; 645  : 
; 646  : 			XmlGetAttributeText (xml, "noHotKeyMount", boolVal, sizeof (boolVal));

  00767	6a 02		 push	 2
  00769	8d 85 08 f7 ff
	ff		 lea	 eax, DWORD PTR _boolVal$4[ebp]
  0076f	50		 push	 eax
  00770	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KADIAEN@noHotKeyMount?$AA@
  00775	56		 push	 esi
  00776	e8 00 00 00 00	 call	 _XmlGetAttributeText

; 647  : 			if (boolVal[0])

  0077b	66 8b 85 08 f7
	ff ff		 mov	 ax, WORD PTR _boolVal$4[ebp]
  00782	83 c4 10	 add	 esp, 16			; 00000010H
  00785	84 c0		 test	 al, al
  00787	74 09		 je	 SHORT $LN12@LoadFavori

; 648  : 				favorite.DisableHotkeyMount = (boolVal[0] == '1');

  00789	3c 31		 cmp	 al, 49			; 00000031H
  0078b	0f 94 85 7c fd
	ff ff		 sete	 BYTE PTR _favorite$10[ebp+96]
$LN12@LoadFavori:

; 649  : 
; 650  : 			XmlGetAttributeText (xml, "openExplorerWindow", boolVal, sizeof (boolVal));

  00792	6a 02		 push	 2
  00794	8d 85 08 f7 ff
	ff		 lea	 eax, DWORD PTR _boolVal$4[ebp]
  0079a	50		 push	 eax
  0079b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FMMJHNKO@openExplorerWindow?$AA@
  007a0	56		 push	 esi
  007a1	e8 00 00 00 00	 call	 _XmlGetAttributeText

; 651  : 			if (boolVal[0])

  007a6	66 8b 85 08 f7
	ff ff		 mov	 ax, WORD PTR _boolVal$4[ebp]
  007ad	83 c4 10	 add	 esp, 16			; 00000010H
  007b0	84 c0		 test	 al, al
  007b2	74 09		 je	 SHORT $LN13@LoadFavori

; 652  : 				favorite.OpenExplorerWindow = (boolVal[0] == '1');

  007b4	3c 31		 cmp	 al, 49			; 00000031H
  007b6	0f 94 85 80 fd
	ff ff		 sete	 BYTE PTR _favorite$10[ebp+100]
$LN13@LoadFavori:

; 653  : 
; 654  : 			XmlGetAttributeText (xml, "mountOnArrival", boolVal, sizeof (boolVal));

  007bd	6a 02		 push	 2
  007bf	8d 85 08 f7 ff
	ff		 lea	 eax, DWORD PTR _boolVal$4[ebp]
  007c5	50		 push	 eax
  007c6	68 00 00 00 00	 push	 OFFSET ??_C@_0P@BNAHGHLI@mountOnArrival?$AA@
  007cb	56		 push	 esi
  007cc	e8 00 00 00 00	 call	 _XmlGetAttributeText

; 655  : 			if (boolVal[0])

  007d1	66 8b 85 08 f7
	ff ff		 mov	 ax, WORD PTR _boolVal$4[ebp]
  007d8	83 c4 10	 add	 esp, 16			; 00000010H
  007db	84 c0		 test	 al, al
  007dd	74 09		 je	 SHORT $LN14@LoadFavori

; 656  : 				favorite.MountOnArrival = (boolVal[0] == '1');

  007df	3c 31		 cmp	 al, 49			; 00000031H
  007e1	0f 94 85 7f fd
	ff ff		 sete	 BYTE PTR _favorite$10[ebp+99]
$LN14@LoadFavori:

; 657  : 
; 658  : 			XmlGetAttributeText (xml, "mountOnLogOn", boolVal, sizeof (boolVal));

  007e8	6a 02		 push	 2
  007ea	8d 85 08 f7 ff
	ff		 lea	 eax, DWORD PTR _boolVal$4[ebp]
  007f0	50		 push	 eax
  007f1	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GAADCGJD@mountOnLogOn?$AA@
  007f6	56		 push	 esi
  007f7	e8 00 00 00 00	 call	 _XmlGetAttributeText

; 659  : 			if (boolVal[0])

  007fc	66 8b 85 08 f7
	ff ff		 mov	 ax, WORD PTR _boolVal$4[ebp]
  00803	83 c4 10	 add	 esp, 16			; 00000010H
  00806	84 c0		 test	 al, al
  00808	74 09		 je	 SHORT $LN2596@LoadFavori

; 660  : 				favorite.MountOnLogOn = (boolVal[0] == '1');

  0080a	3c 31		 cmp	 al, 49			; 00000031H
  0080c	0f 94 85 7e fd
	ff ff		 sete	 BYTE PTR _favorite$10[ebp+98]

; 661  : 
; 662  : 			if (favorite.Path.find ("\\\\?\\Volume{") == 0 && favorite.Path.rfind ("}\\") == favorite.Path.size() - 2)

$LN2596@LoadFavori:
  00813	6a 0b		 push	 11			; 0000000bH
  00815	6a 00		 push	 0
  00817	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CJEJOKNC@?2?2?$DP?2Volume?$HL?$AA@
  0081c	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR _favorite$10[ebp]
  00822	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00827	85 c0		 test	 eax, eax
  00829	0f 85 be 00 00
	00		 jne	 $LN16@LoadFavori
  0082f	6a 02		 push	 2
  00831	6a ff		 push	 -1
  00833	68 00 00 00 00	 push	 OFFSET ??_C@_02EKJJMPLG@?$HN?2?$AA@
  00838	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR _favorite$10[ebp]
  0083e	e8 00 00 00 00	 call	 ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
  00843	8b 8d 2c fd ff
	ff		 mov	 ecx, DWORD PTR _favorite$10[ebp+16]
  00849	83 c1 fe	 add	 ecx, -2			; fffffffeH
  0084c	3b c1		 cmp	 eax, ecx
  0084e	0f 85 99 00 00
	00		 jne	 $LN16@LoadFavori

; 663  : 			{
; 664  : 				string resolvedPath = VolumeGuidPathToDevicePath (favorite.Path);

  00854	83 ec 18	 sub	 esp, 24			; 00000018H
  00857	8b cc		 mov	 ecx, esp
  00859	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00860	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00867	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0086b	72 04		 jb	 SHORT $LN2734@LoadFavori
  0086d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0086f	eb 02		 jmp	 SHORT $LN2735@LoadFavori
$LN2734@LoadFavori:
  00871	8b c1		 mov	 eax, ecx
$LN2735@LoadFavori:
  00873	6a ff		 push	 -1
  00875	c6 00 00	 mov	 BYTE PTR [eax], 0
  00878	8d 85 1c fd ff
	ff		 lea	 eax, DWORD PTR _favorite$10[ebp]
  0087e	6a 00		 push	 0
  00880	50		 push	 eax
  00881	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00886	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR _resolvedPath$9[ebp]
  0088c	50		 push	 eax
  0088d	e8 00 00 00 00	 call	 ?VolumeGuidPathToDevicePath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z ; VolumeGuidPathToDevicePath
  00892	83 c4 1c	 add	 esp, 28			; 0000001cH
  00895	83 bd 14 fd ff
	ff 00		 cmp	 DWORD PTR _resolvedPath$9[ebp+16], 0
  0089c	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+12], 15 ; 0000000fH

; 665  : 				if (!resolvedPath.empty())

  008a0	74 35		 je	 SHORT $LN17@LoadFavori

; 666  : 				{
; 667  : 					favorite.DisconnectedDevice = false;
; 668  : 					favorite.VolumePathId = favorite.Path;

  008a2	6a ff		 push	 -1
  008a4	6a 00		 push	 0
  008a6	8d 85 1c fd ff
	ff		 lea	 eax, DWORD PTR _favorite$10[ebp]
  008ac	c6 85 7d fd ff
	ff 00		 mov	 BYTE PTR _favorite$10[ebp+97], 0
  008b3	50		 push	 eax
  008b4	8d 8d 4c fd ff
	ff		 lea	 ecx, DWORD PTR _favorite$10[ebp+48]
  008ba	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 669  : 					favorite.Path = resolvedPath;

  008bf	6a ff		 push	 -1
  008c1	6a 00		 push	 0
  008c3	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR _resolvedPath$9[ebp]
  008c9	50		 push	 eax
  008ca	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR _favorite$10[ebp]
  008d0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 670  : 				}
; 671  : 				else

  008d5	eb 07		 jmp	 SHORT $LN18@LoadFavori
$LN17@LoadFavori:

; 672  : 					favorite.DisconnectedDevice = true;

  008d7	c6 85 7d fd ff
	ff 01		 mov	 BYTE PTR _favorite$10[ebp+97], 1
$LN18@LoadFavori:

; 673  : 			}

  008de	8d 8d 04 fd ff
	ff		 lea	 ecx, DWORD PTR _resolvedPath$9[ebp]
  008e4	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+12], 9
  008e8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN16@LoadFavori:

; 674  : 
; 675  : 			favorites.push_back (favorite);

  008ed	8d 85 1c fd ff
	ff		 lea	 eax, DWORD PTR _favorite$10[ebp]
  008f3	8b cb		 mov	 ecx, ebx
  008f5	50		 push	 eax
  008f6	e8 00 00 00 00	 call	 ?push_back@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::push_back

; 676  : 			xml++;
; 677  : 		}

  008fb	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR _favorite$10[ebp]
  00901	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00905	46		 inc	 esi
  00906	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  0090b	68 00 00 00 00	 push	 OFFSET ??_C@_06EMCPHFGM@volume?$AA@
  00910	56		 push	 esi
  00911	e8 00 00 00 00	 call	 _XmlFindElement
  00916	8b f0		 mov	 esi, eax
  00918	83 c4 08	 add	 esp, 8
  0091b	85 f6		 test	 esi, esi
  0091d	0f 85 8d fa ff
	ff		 jne	 $LL2@LoadFavori
$LN3@LoadFavori:

; 678  : 
; 679  : 		free (favoritesXml);

  00923	ff b5 04 f7 ff
	ff		 push	 DWORD PTR _favoritesXml$1$[ebp]
  00929	e8 00 00 00 00	 call	 _free
  0092e	83 c4 04	 add	 esp, 4
$LN44@LoadFavori:

; 680  : 	}

  00931	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _favoritesFilePath$[ebp]
  00937	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1@LoadFavori:
  0093c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0093f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00946	59		 pop	 ecx
  00947	5f		 pop	 edi
  00948	5e		 pop	 esi
  00949	5b		 pop	 ebx
  0094a	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0094d	33 cd		 xor	 ecx, ebp
  0094f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00954	8b e5		 mov	 esp, ebp
  00956	5d		 pop	 ebp
  00957	c3		 ret	 0
$LN2853@LoadFavori:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$2:
  00000	8b 85 04 f7 ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00006	83 e0 01	 and	 eax, 1
  00009	0f 84 12 00 00
	00		 je	 $LN25@LoadFavori
  0000f	83 a5 04 f7 ff
	ff fe		 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00016	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN25@LoadFavori:
  00021	c3		 ret	 0
__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$4:
  00022	8d 8d cc fd ff
	ff		 lea	 ecx, DWORD PTR _favoritesFilePath$[ebp]
  00028	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$5:
  0002d	8d 8d 0c f7 ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$5[ebp]
  00033	e9 00 00 00 00	 jmp	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$6:
  00038	8d 8d ec fc ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0003e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$7:
  00043	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00049	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$8:
  0004e	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00054	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$9:
  00059	8d 8d 1c fd ff
	ff		 lea	 ecx, DWORD PTR _favorite$10[ebp]
  0005f	e9 00 00 00 00	 jmp	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$10:
  00064	8d 8d b4 fd ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  0006a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$11:
  0006f	8d 8d 84 fd ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00075	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$381:
  0007a	e8 00 00 00 00	 call	 ___std_terminate
  0007f	c3		 ret	 0
__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$13:
  00080	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  00086	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$530:
  0008b	e8 00 00 00 00	 call	 ___std_terminate
  00090	c3		 ret	 0
__unwindfunclet$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z$16:
  00091	8d 8d 04 fd ff
	ff		 lea	 ecx, DWORD PTR _resolvedPath$9[ebp]
  00097	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z:
  0009c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000a0	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000a3	8b 8a f4 f6 ff
	ff		 mov	 ecx, DWORD PTR [edx-2316]
  000a9	33 c8		 xor	 ecx, eax
  000ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b0	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  000b3	33 c8		 xor	 ecx, eax
  000b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ba	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z
  000bf	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z ENDP ; GostCrypt::LoadFavoriteVolumes
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ?LoadFavoriteVolumes@GostCrypt@@YAXXZ
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
?LoadFavoriteVolumes@GostCrypt@@YAXXZ PROC		; GostCrypt::LoadFavoriteVolumes, COMDAT

; 561  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadFavoriteVolumes@GostCrypt@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 562  : 		LoadFavoriteVolumes (FavoriteVolumes, false);

  00029	6a 00		 push	 0
  0002b	6a 00		 push	 0
  0002d	68 00 00 00 00	 push	 OFFSET ?FavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoriteVolumes
  00032	e8 00 00 00 00	 call	 ?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z ; GostCrypt::LoadFavoriteVolumes

; 563  : 
; 564  : 		try
; 565  : 		{
; 566  : 			LoadFavoriteVolumes (SystemFavoriteVolumes, true, true);

  00037	6a 01		 push	 1
  00039	6a 01		 push	 1
  0003b	68 00 00 00 00	 push	 OFFSET ?SystemFavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::SystemFavoriteVolumes
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00047	e8 00 00 00 00	 call	 ?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z ; GostCrypt::LoadFavoriteVolumes
  0004c	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@LoadFavori:
  0004f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 569  : 
; 570  : 		OnFavoriteVolumesUpdated();

  00056	e8 00 00 00 00	 call	 ?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ ; GostCrypt::OnFavoriteVolumesUpdated

; 571  : 	}

  0005b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0005e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00065	59		 pop	 ecx
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
__catch$?LoadFavoriteVolumes@GostCrypt@@YAXXZ$0:

; 567  : 		}
; 568  : 		catch (...) { }	// Ignore errors as SystemFavoriteVolumes list is used only for resolving volume paths to labels

  0006d	b8 00 00 00 00	 mov	 eax, $LN7@LoadFavori
  00072	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?LoadFavoriteVolumes@GostCrypt@@YAXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadFavoriteVolumes@GostCrypt@@YAXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadFavoriteVolumes@GostCrypt@@YAXXZ ENDP		; GostCrypt::LoadFavoriteVolumes
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ?GetFavoriteVolumeLabel@GostCrypt@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
_TEXT	SEGMENT
_$S6$2 = -80						; size = 28
_$S5$3 = -52						; size = 28
$T4 = -24						; size = 4
tv3010 = -20						; size = 4
__Right_size$1$ = -20					; size = 4
__Right_size$1$ = -16					; size = 4
tv3012 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_volumePath$ = 12					; size = 4
?GetFavoriteVolumeLabel@GostCrypt@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z PROC ; GostCrypt::GetFavoriteVolumeLabel, COMDAT

; 536  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetFavoriteVolumeLabel@GostCrypt@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 537  : 		foreach (const FavoriteVolume &favorite, FavoriteVolumes)

  00028	8d 45 cc	 lea	 eax, DWORD PTR _$S5$3[ebp]
  0002b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], 0
  00032	68 00 00 00 00	 push	 OFFSET ?FavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoriteVolumes
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
  0003d	83 c4 08	 add	 esp, 8
  00040	8b 45 cc	 mov	 eax, DWORD PTR _$S5$3[ebp]
  00043	8d 4d cc	 lea	 ecx, DWORD PTR _$S5$3[ebp]
  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00050	ff d0		 call	 eax
  00052	84 c0		 test	 al, al
  00054	0f 84 f1 00 00
	00		 je	 $LN3@GetFavorit
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL4@GetFavorit:
  00060	33 c9		 xor	 ecx, ecx
  00062	38 4d d1	 cmp	 BYTE PTR _$S5$3[ebp+5], cl
  00065	0f 94 c1	 sete	 cl
  00068	89 4d f0	 mov	 DWORD PTR tv3012[ebp], ecx
  0006b	88 4d d1	 mov	 BYTE PTR _$S5$3[ebp+5], cl
  0006e	84 c9		 test	 cl, cl
  00070	0f 84 b9 00 00
	00		 je	 $LN2@GetFavorit

; 538  : 		{
; 539  : 			if (favorite.Path == volumePath)

  00076	8b 45 0c	 mov	 eax, DWORD PTR _volumePath$[ebp]
  00079	8b 5d e4	 mov	 ebx, DWORD PTR _$S5$3[ebp+24]
  0007c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0007f	89 4d ec	 mov	 DWORD PTR __Right_size$1$[ebp], ecx
$LL7@GetFavorit:
  00082	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00086	72 04		 jb	 SHORT $LN62@GetFavorit
  00088	8b 30		 mov	 esi, DWORD PTR [eax]
  0008a	eb 02		 jmp	 SHORT $LN63@GetFavorit
$LN62@GetFavorit:
  0008c	8b f0		 mov	 esi, eax
$LN63@GetFavorit:
  0008e	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00092	72 04		 jb	 SHORT $LN85@GetFavorit
  00094	8b 13		 mov	 edx, DWORD PTR [ebx]
  00096	eb 02		 jmp	 SHORT $LN86@GetFavorit
$LN85@GetFavorit:
  00098	8b d3		 mov	 edx, ebx
$LN86@GetFavorit:
  0009a	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  0009d	8b c1		 mov	 eax, ecx
  0009f	3b f9		 cmp	 edi, ecx
  000a1	0f 42 c7	 cmovb	 eax, edi
  000a4	85 c0		 test	 eax, eax
  000a6	74 5b		 je	 SHORT $LN90@GetFavorit
  000a8	83 e8 04	 sub	 eax, 4
  000ab	72 14		 jb	 SHORT $LN1195@GetFavorit
  000ad	0f 1f 00	 npad	 3
$LL1196@GetFavorit:
  000b0	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000b2	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  000b4	75 10		 jne	 SHORT $LN1194@GetFavorit
  000b6	83 c2 04	 add	 edx, 4
  000b9	83 c6 04	 add	 esi, 4
  000bc	83 e8 04	 sub	 eax, 4
  000bf	73 ef		 jae	 SHORT $LL1196@GetFavorit
$LN1195@GetFavorit:
  000c1	83 f8 fc	 cmp	 eax, -4			; fffffffcH
  000c4	74 34		 je	 SHORT $LN1193@GetFavorit
$LN1194@GetFavorit:
  000c6	8a 0a		 mov	 cl, BYTE PTR [edx]
  000c8	3a 0e		 cmp	 cl, BYTE PTR [esi]
  000ca	75 27		 jne	 SHORT $LN1197@GetFavorit
  000cc	83 f8 fd	 cmp	 eax, -3			; fffffffdH
  000cf	74 29		 je	 SHORT $LN1193@GetFavorit
  000d1	8a 4a 01	 mov	 cl, BYTE PTR [edx+1]
  000d4	3a 4e 01	 cmp	 cl, BYTE PTR [esi+1]
  000d7	75 1a		 jne	 SHORT $LN1197@GetFavorit
  000d9	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  000dc	74 1c		 je	 SHORT $LN1193@GetFavorit
  000de	8a 4a 02	 mov	 cl, BYTE PTR [edx+2]
  000e1	3a 4e 02	 cmp	 cl, BYTE PTR [esi+2]
  000e4	75 0d		 jne	 SHORT $LN1197@GetFavorit
  000e6	83 f8 ff	 cmp	 eax, -1
  000e9	74 0f		 je	 SHORT $LN1193@GetFavorit
  000eb	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  000ee	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  000f1	74 07		 je	 SHORT $LN1193@GetFavorit
$LN1197@GetFavorit:
  000f3	1b c0		 sbb	 eax, eax
  000f5	83 c8 01	 or	 eax, 1
  000f8	eb 02		 jmp	 SHORT $LN1198@GetFavorit
$LN1193@GetFavorit:
  000fa	33 c0		 xor	 eax, eax
$LN1198@GetFavorit:
  000fc	85 c0		 test	 eax, eax
  000fe	75 0d		 jne	 SHORT $LN89@GetFavorit
  00100	8b 4d ec	 mov	 ecx, DWORD PTR __Right_size$1$[ebp]
$LN90@GetFavorit:
  00103	3b f9		 cmp	 edi, ecx
  00105	72 06		 jb	 SHORT $LN89@GetFavorit
  00107	0f 86 8e 00 00
	00		 jbe	 $LN1163@GetFavorit
$LN89@GetFavorit:

; 537  : 		foreach (const FavoriteVolume &favorite, FavoriteVolumes)

  0010d	33 c0		 xor	 eax, eax
  0010f	c6 45 d0 01	 mov	 BYTE PTR _$S5$3[ebp+4], 1
  00113	38 45 f0	 cmp	 BYTE PTR tv3012[ebp], al
  00116	0f 94 c0	 sete	 al
  00119	8a c8		 mov	 cl, al
  0011b	84 c0		 test	 al, al
  0011d	8b 45 0c	 mov	 eax, DWORD PTR _volumePath$[ebp]
  00120	89 4d f0	 mov	 DWORD PTR tv3012[ebp], ecx
  00123	88 4d d1	 mov	 BYTE PTR _$S5$3[ebp+5], cl
  00126	8b 4d ec	 mov	 ecx, DWORD PTR __Right_size$1$[ebp]
  00129	0f 85 53 ff ff
	ff		 jne	 $LL7@GetFavorit
$LN2@GetFavorit:
  0012f	8b 45 cc	 mov	 eax, DWORD PTR _$S5$3[ebp]
  00132	8d 4d cc	 lea	 ecx, DWORD PTR _$S5$3[ebp]
  00135	ff 50 08	 call	 DWORD PTR [eax+8]
  00138	8b 45 cc	 mov	 eax, DWORD PTR _$S5$3[ebp]
  0013b	8d 4d cc	 lea	 ecx, DWORD PTR _$S5$3[ebp]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	ff d0		 call	 eax
  00143	84 c0		 test	 al, al
  00145	0f 85 15 ff ff
	ff		 jne	 $LL4@GetFavorit
$LN3@GetFavorit:

; 541  : 		}

  0014b	8b 75 d4	 mov	 esi, DWORD PTR _$S5$3[ebp+8]
  0014e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00155	85 f6		 test	 esi, esi
  00157	0f 84 3f 01 00
	00		 je	 $LN392@GetFavorit
  0015d	8b 7d d8	 mov	 edi, DWORD PTR _$S5$3[ebp+12]
  00160	3b f7		 cmp	 esi, edi
  00162	74 11		 je	 SHORT $LN433@GetFavorit
$LL434@GetFavorit:
  00164	8b ce		 mov	 ecx, esi
  00166	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  0016b	83 c6 68	 add	 esi, 104		; 00000068H
  0016e	3b f7		 cmp	 esi, edi
  00170	75 f2		 jne	 SHORT $LL434@GetFavorit
  00172	8b 75 d4	 mov	 esi, DWORD PTR _$S5$3[ebp+8]
$LN433@GetFavorit:
  00175	8b 4d dc	 mov	 ecx, DWORD PTR _$S5$3[ebp+16]
  00178	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  0017d	2b ce		 sub	 ecx, esi
  0017f	f7 e9		 imul	 ecx
  00181	c1 fa 05	 sar	 edx, 5
  00184	8b c2		 mov	 eax, edx
  00186	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00189	03 c2		 add	 eax, edx
  0018b	3d 62 27 76 02	 cmp	 eax, 41297762		; 02762762H
  00190	0f 86 c4 00 00
	00		 jbe	 $LN486@GetFavorit
  00196	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1207@GetFavorit:
$LN1163@GetFavorit:

; 540  : 				return favorite.Label;

  0019b	8d 43 48	 lea	 eax, DWORD PTR [ebx+72]
  0019e	33 c9		 xor	 ecx, ecx
  001a0	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  001a3	6a ff		 push	 -1
  001a5	51		 push	 ecx
  001a6	50		 push	 eax
  001a7	c7 43 14 07 00
	00 00		 mov	 DWORD PTR [ebx+20], 7
  001ae	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
  001b5	66 89 0b	 mov	 WORD PTR [ebx], cx
  001b8	8b cb		 mov	 ecx, ebx
  001ba	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  001bf	8b 75 d4	 mov	 esi, DWORD PTR _$S5$3[ebp+8]
  001c2	85 f6		 test	 esi, esi
  001c4	0f 84 7c 00 00
	00		 je	 $LN249@GetFavorit
  001ca	8b 7d d8	 mov	 edi, DWORD PTR _$S5$3[ebp+12]
  001cd	3b f7		 cmp	 esi, edi
  001cf	74 11		 je	 SHORT $LN290@GetFavorit
$LL291@GetFavorit:
  001d1	8b ce		 mov	 ecx, esi
  001d3	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  001d8	83 c6 68	 add	 esi, 104		; 00000068H
  001db	3b f7		 cmp	 esi, edi
  001dd	75 f2		 jne	 SHORT $LL291@GetFavorit
  001df	8b 75 d4	 mov	 esi, DWORD PTR _$S5$3[ebp+8]
$LN290@GetFavorit:
  001e2	8b 4d dc	 mov	 ecx, DWORD PTR _$S5$3[ebp+16]
  001e5	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  001ea	2b ce		 sub	 ecx, esi
  001ec	f7 e9		 imul	 ecx
  001ee	c1 fa 05	 sar	 edx, 5
  001f1	8b c2		 mov	 eax, edx
  001f3	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001f6	03 c2		 add	 eax, edx
  001f8	3d 62 27 76 02	 cmp	 eax, 41297762		; 02762762H
  001fd	76 05		 jbe	 SHORT $LN343@GetFavorit
  001ff	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1208@GetFavorit:
$LN343@GetFavorit:
  00204	6b c0 68	 imul	 eax, eax, 104
  00207	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0020c	72 2f		 jb	 SHORT $LN344@GetFavorit
  0020e	f6 45 d4 1f	 test	 BYTE PTR _$S5$3[ebp+8], 31 ; 0000001fH
  00212	74 05		 je	 SHORT $LN345@GetFavorit
  00214	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1209@GetFavorit:
$LN345@GetFavorit:
  00219	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  0021c	3b c6		 cmp	 eax, esi
  0021e	72 05		 jb	 SHORT $LN346@GetFavorit
  00220	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1210@GetFavorit:
$LN346@GetFavorit:
  00225	2b f0		 sub	 esi, eax
  00227	83 fe 04	 cmp	 esi, 4
  0022a	73 05		 jae	 SHORT $LN347@GetFavorit
  0022c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1211@GetFavorit:
$LN347@GetFavorit:
  00231	83 fe 23	 cmp	 esi, 35			; 00000023H
  00234	76 05		 jbe	 SHORT $LN348@GetFavorit
  00236	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1212@GetFavorit:
$LN348@GetFavorit:
  0023b	8b f0		 mov	 esi, eax
$LN344@GetFavorit:
  0023d	56		 push	 esi
  0023e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00243	83 c4 04	 add	 esp, 4
$LN249@GetFavorit:
  00246	8b c3		 mov	 eax, ebx

; 550  : 	}

  00248	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0024b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00252	59		 pop	 ecx
  00253	5f		 pop	 edi
  00254	5e		 pop	 esi
  00255	5b		 pop	 ebx
  00256	8b e5		 mov	 esp, ebp
  00258	5d		 pop	 ebp
  00259	c3		 ret	 0

; 541  : 		}

$LN486@GetFavorit:
  0025a	6b c0 68	 imul	 eax, eax, 104
  0025d	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00262	72 2f		 jb	 SHORT $LN487@GetFavorit
  00264	f6 45 d4 1f	 test	 BYTE PTR _$S5$3[ebp+8], 31 ; 0000001fH
  00268	74 05		 je	 SHORT $LN488@GetFavorit
  0026a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1213@GetFavorit:
$LN488@GetFavorit:
  0026f	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00272	3b c6		 cmp	 eax, esi
  00274	72 05		 jb	 SHORT $LN489@GetFavorit
  00276	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1214@GetFavorit:
$LN489@GetFavorit:
  0027b	2b f0		 sub	 esi, eax
  0027d	83 fe 04	 cmp	 esi, 4
  00280	73 05		 jae	 SHORT $LN490@GetFavorit
  00282	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1215@GetFavorit:
$LN490@GetFavorit:
  00287	83 fe 23	 cmp	 esi, 35			; 00000023H
  0028a	76 05		 jbe	 SHORT $LN491@GetFavorit
  0028c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1216@GetFavorit:
$LN491@GetFavorit:
  00291	8b f0		 mov	 esi, eax
$LN487@GetFavorit:
  00293	56		 push	 esi
  00294	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00299	83 c4 04	 add	 esp, 4
$LN392@GetFavorit:

; 542  : 
; 543  : 		foreach (const FavoriteVolume &favorite, SystemFavoriteVolumes)

  0029c	8d 45 b0	 lea	 eax, DWORD PTR _$S6$2[ebp]
  0029f	68 00 00 00 00	 push	 OFFSET ?SystemFavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::SystemFavoriteVolumes
  002a4	50		 push	 eax
  002a5	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
  002aa	83 c4 08	 add	 esp, 8
  002ad	8b 45 b0	 mov	 eax, DWORD PTR _$S6$2[ebp]
  002b0	8d 4d b0	 lea	 ecx, DWORD PTR _$S6$2[ebp]
  002b3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  002ba	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002bd	ff d0		 call	 eax
  002bf	84 c0		 test	 al, al
  002c1	0f 84 f4 00 00
	00		 je	 $LN9@GetFavorit
$LL10@GetFavorit:
  002c7	33 c9		 xor	 ecx, ecx
  002c9	38 4d b5	 cmp	 BYTE PTR _$S6$2[ebp+5], cl
  002cc	0f 94 c1	 sete	 cl
  002cf	89 4d ec	 mov	 DWORD PTR tv3010[ebp], ecx
  002d2	88 4d b5	 mov	 BYTE PTR _$S6$2[ebp+5], cl
  002d5	84 c9		 test	 cl, cl
  002d7	0f 84 c2 00 00
	00		 je	 $LN8@GetFavorit

; 544  : 		{
; 545  : 			if (favorite.Path == volumePath)

  002dd	8b 4d 0c	 mov	 ecx, DWORD PTR _volumePath$[ebp]
  002e0	8b 5d c8	 mov	 ebx, DWORD PTR _$S6$2[ebp+24]
  002e3	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  002e6	89 45 f0	 mov	 DWORD PTR __Right_size$1$[ebp], eax
  002e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@GetFavorit:
  002f0	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  002f4	72 04		 jb	 SHORT $LN565@GetFavorit
  002f6	8b 31		 mov	 esi, DWORD PTR [ecx]
  002f8	eb 02		 jmp	 SHORT $LN566@GetFavorit
$LN565@GetFavorit:
  002fa	8b f1		 mov	 esi, ecx
$LN566@GetFavorit:
  002fc	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00300	72 04		 jb	 SHORT $LN588@GetFavorit
  00302	8b 13		 mov	 edx, DWORD PTR [ebx]
  00304	eb 02		 jmp	 SHORT $LN589@GetFavorit
$LN588@GetFavorit:
  00306	8b d3		 mov	 edx, ebx
$LN589@GetFavorit:
  00308	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  0030b	8b c8		 mov	 ecx, eax
  0030d	3b f8		 cmp	 edi, eax
  0030f	0f 42 cf	 cmovb	 ecx, edi
  00312	85 c9		 test	 ecx, ecx
  00314	74 5d		 je	 SHORT $LN593@GetFavorit
  00316	83 e9 04	 sub	 ecx, 4
  00319	72 16		 jb	 SHORT $LN1201@GetFavorit
  0031b	0f 1f 44 00 00	 npad	 5
$LL1202@GetFavorit:
  00320	8b 02		 mov	 eax, DWORD PTR [edx]
  00322	3b 06		 cmp	 eax, DWORD PTR [esi]
  00324	75 10		 jne	 SHORT $LN1200@GetFavorit
  00326	83 c2 04	 add	 edx, 4
  00329	83 c6 04	 add	 esi, 4
  0032c	83 e9 04	 sub	 ecx, 4
  0032f	73 ef		 jae	 SHORT $LL1202@GetFavorit
$LN1201@GetFavorit:
  00331	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00334	74 34		 je	 SHORT $LN1199@GetFavorit
$LN1200@GetFavorit:
  00336	8a 02		 mov	 al, BYTE PTR [edx]
  00338	3a 06		 cmp	 al, BYTE PTR [esi]
  0033a	75 27		 jne	 SHORT $LN1203@GetFavorit
  0033c	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  0033f	74 29		 je	 SHORT $LN1199@GetFavorit
  00341	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00344	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00347	75 1a		 jne	 SHORT $LN1203@GetFavorit
  00349	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0034c	74 1c		 je	 SHORT $LN1199@GetFavorit
  0034e	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00351	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00354	75 0d		 jne	 SHORT $LN1203@GetFavorit
  00356	83 f9 ff	 cmp	 ecx, -1
  00359	74 0f		 je	 SHORT $LN1199@GetFavorit
  0035b	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  0035e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00361	74 07		 je	 SHORT $LN1199@GetFavorit
$LN1203@GetFavorit:
  00363	1b c0		 sbb	 eax, eax
  00365	83 c8 01	 or	 eax, 1
  00368	eb 02		 jmp	 SHORT $LN1204@GetFavorit
$LN1199@GetFavorit:
  0036a	33 c0		 xor	 eax, eax
$LN1204@GetFavorit:
  0036c	85 c0		 test	 eax, eax
  0036e	75 0d		 jne	 SHORT $LN592@GetFavorit
  00370	8b 45 f0	 mov	 eax, DWORD PTR __Right_size$1$[ebp]
$LN593@GetFavorit:
  00373	3b f8		 cmp	 edi, eax
  00375	72 06		 jb	 SHORT $LN592@GetFavorit
  00377	0f 86 8a 00 00
	00		 jbe	 $LN1164@GetFavorit
$LN592@GetFavorit:

; 542  : 
; 543  : 		foreach (const FavoriteVolume &favorite, SystemFavoriteVolumes)

  0037d	33 c0		 xor	 eax, eax
  0037f	c6 45 b4 01	 mov	 BYTE PTR _$S6$2[ebp+4], 1
  00383	38 45 ec	 cmp	 BYTE PTR tv3010[ebp], al
  00386	0f 94 c0	 sete	 al
  00389	8a c8		 mov	 cl, al
  0038b	84 c0		 test	 al, al
  0038d	8b 45 f0	 mov	 eax, DWORD PTR __Right_size$1$[ebp]
  00390	89 4d ec	 mov	 DWORD PTR tv3010[ebp], ecx
  00393	88 4d b5	 mov	 BYTE PTR _$S6$2[ebp+5], cl
  00396	8b 4d 0c	 mov	 ecx, DWORD PTR _volumePath$[ebp]
  00399	0f 85 51 ff ff
	ff		 jne	 $LL13@GetFavorit
$LN8@GetFavorit:
  0039f	8b 45 b0	 mov	 eax, DWORD PTR _$S6$2[ebp]
  003a2	8d 4d b0	 lea	 ecx, DWORD PTR _$S6$2[ebp]
  003a5	ff 50 08	 call	 DWORD PTR [eax+8]
  003a8	8b 45 b0	 mov	 eax, DWORD PTR _$S6$2[ebp]
  003ab	8d 4d b0	 lea	 ecx, DWORD PTR _$S6$2[ebp]
  003ae	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003b1	ff d0		 call	 eax
  003b3	84 c0		 test	 al, al
  003b5	0f 85 0c ff ff
	ff		 jne	 $LL10@GetFavorit
$LN9@GetFavorit:

; 547  : 		}

  003bb	8b 75 b8	 mov	 esi, DWORD PTR _$S6$2[ebp+8]
  003be	85 f6		 test	 esi, esi
  003c0	0f 84 0c 01 00
	00		 je	 $LN894@GetFavorit
  003c6	8b 7d bc	 mov	 edi, DWORD PTR _$S6$2[ebp+12]
  003c9	3b f7		 cmp	 esi, edi
  003cb	74 14		 je	 SHORT $LN935@GetFavorit
  003cd	0f 1f 00	 npad	 3
$LL936@GetFavorit:
  003d0	8b ce		 mov	 ecx, esi
  003d2	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  003d7	83 c6 68	 add	 esi, 104		; 00000068H
  003da	3b f7		 cmp	 esi, edi
  003dc	75 f2		 jne	 SHORT $LL936@GetFavorit
  003de	8b 75 b8	 mov	 esi, DWORD PTR _$S6$2[ebp+8]
$LN935@GetFavorit:
  003e1	8b 4d c0	 mov	 ecx, DWORD PTR _$S6$2[ebp+16]
  003e4	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  003e9	2b ce		 sub	 ecx, esi
  003eb	f7 e9		 imul	 ecx
  003ed	c1 fa 05	 sar	 edx, 5
  003f0	8b c2		 mov	 eax, edx
  003f2	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  003f5	03 c2		 add	 eax, edx
  003f7	3d 62 27 76 02	 cmp	 eax, 41297762		; 02762762H
  003fc	0f 86 8e 00 00
	00		 jbe	 $LN988@GetFavorit
  00402	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1217@GetFavorit:
$LN1164@GetFavorit:

; 546  : 				return favorite.Label;

  00407	8d 43 48	 lea	 eax, DWORD PTR [ebx+72]
  0040a	33 c9		 xor	 ecx, ecx
  0040c	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  0040f	6a ff		 push	 -1
  00411	51		 push	 ecx
  00412	50		 push	 eax
  00413	c7 43 14 07 00
	00 00		 mov	 DWORD PTR [ebx+20], 7
  0041a	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
  00421	66 89 0b	 mov	 WORD PTR [ebx], cx
  00424	8b cb		 mov	 ecx, ebx
  00426	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0042b	8b 75 b8	 mov	 esi, DWORD PTR _$S6$2[ebp+8]
  0042e	85 f6		 test	 esi, esi
  00430	0f 84 10 fe ff
	ff		 je	 $LN249@GetFavorit
  00436	8b 7d bc	 mov	 edi, DWORD PTR _$S6$2[ebp+12]
  00439	3b f7		 cmp	 esi, edi
  0043b	74 14		 je	 SHORT $LN792@GetFavorit
  0043d	0f 1f 00	 npad	 3
$LL793@GetFavorit:
  00440	8b ce		 mov	 ecx, esi
  00442	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  00447	83 c6 68	 add	 esi, 104		; 00000068H
  0044a	3b f7		 cmp	 esi, edi
  0044c	75 f2		 jne	 SHORT $LL793@GetFavorit
  0044e	8b 75 b8	 mov	 esi, DWORD PTR _$S6$2[ebp+8]
$LN792@GetFavorit:
  00451	8b 4d c0	 mov	 ecx, DWORD PTR _$S6$2[ebp+16]
  00454	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00459	2b ce		 sub	 ecx, esi
  0045b	f7 e9		 imul	 ecx
  0045d	c1 fa 05	 sar	 edx, 5
  00460	8b c2		 mov	 eax, edx
  00462	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00465	03 c2		 add	 eax, edx
  00467	3d 62 27 76 02	 cmp	 eax, 41297762		; 02762762H
  0046c	76 05		 jbe	 SHORT $LN845@GetFavorit
  0046e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1218@GetFavorit:
$LN845@GetFavorit:
  00473	6b c0 68	 imul	 eax, eax, 104
  00476	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0047b	0f 82 bc fd ff
	ff		 jb	 $LN344@GetFavorit
  00481	f6 45 b8 1f	 test	 BYTE PTR _$S6$2[ebp+8], 31 ; 0000001fH
  00485	0f 84 8e fd ff
	ff		 je	 $LN345@GetFavorit
  0048b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1219@GetFavorit:

; 547  : 		}

$LN988@GetFavorit:
  00490	6b c0 68	 imul	 eax, eax, 104
  00493	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00498	72 2f		 jb	 SHORT $LN989@GetFavorit
  0049a	f6 45 b8 1f	 test	 BYTE PTR _$S6$2[ebp+8], 31 ; 0000001fH
  0049e	74 05		 je	 SHORT $LN990@GetFavorit
  004a0	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1220@GetFavorit:
$LN990@GetFavorit:
  004a5	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  004a8	3b c6		 cmp	 eax, esi
  004aa	72 05		 jb	 SHORT $LN991@GetFavorit
  004ac	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1221@GetFavorit:
$LN991@GetFavorit:
  004b1	2b f0		 sub	 esi, eax
  004b3	83 fe 04	 cmp	 esi, 4
  004b6	73 05		 jae	 SHORT $LN992@GetFavorit
  004b8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1222@GetFavorit:
$LN992@GetFavorit:
  004bd	83 fe 23	 cmp	 esi, 35			; 00000023H
  004c0	76 05		 jbe	 SHORT $LN993@GetFavorit
  004c2	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1223@GetFavorit:
$LN993@GetFavorit:
  004c7	8b f0		 mov	 esi, eax
$LN989@GetFavorit:
  004c9	56		 push	 esi
  004ca	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  004cf	83 c4 04	 add	 esp, 4
$LN894@GetFavorit:

; 548  : 
; 549  : 		return wstring();

  004d2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  004d5	33 c9		 xor	 ecx, ecx
  004d7	c7 40 14 07 00
	00 00		 mov	 DWORD PTR [eax+20], 7
  004de	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  004e5	66 89 08	 mov	 WORD PTR [eax], cx

; 550  : 	}

  004e8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004eb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004f2	59		 pop	 ecx
  004f3	5f		 pop	 edi
  004f4	5e		 pop	 esi
  004f5	5b		 pop	 ebx
  004f6	8b e5		 mov	 esp, ebp
  004f8	5d		 pop	 ebp
  004f9	c3		 ret	 0
$LN1206@GetFavorit:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFavoriteVolumeLabel@GostCrypt@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z$0:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR _$S5$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?GetFavoriteVolumeLabel@GostCrypt@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z$2:
  00008	8d 4d b0	 lea	 ecx, DWORD PTR _$S6$2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__ehhandler$?GetFavoriteVolumeLabel@GostCrypt@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetFavoriteVolumeLabel@GostCrypt@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetFavoriteVolumeLabel@GostCrypt@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@Z ENDP ; GostCrypt::GetFavoriteVolumeLabel
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ?FillListControlSubItems@GostCrypt@@YAXPAUHWND__@@HABUFavoriteVolume@1@@Z
_TEXT	SEGMENT
$T2 = -88						; size = 24
$T3 = -64						; size = 24
$T4 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_FavoriteListControl$ = 8				; size = 4
_line$ = 12						; size = 4
_favorite$ = 16						; size = 4
?FillListControlSubItems@GostCrypt@@YAXPAUHWND__@@HABUFavoriteVolume@1@@Z PROC ; GostCrypt::FillListControlSubItems, COMDAT

; 517  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?FillListControlSubItems@GostCrypt@@YAXPAUHWND__@@HABUFavoriteVolume@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 75 10	 mov	 esi, DWORD PTR _favorite$[ebp]

; 518  : 		ListSubItemSetW (FavoriteListControl, line, 1, (wchar_t *) favorite.Label.c_str());

  0002e	83 7e 5c 08	 cmp	 DWORD PTR [esi+92], 8
  00032	8d 46 48	 lea	 eax, DWORD PTR [esi+72]
  00035	8b 7d 08	 mov	 edi, DWORD PTR _FavoriteListControl$[ebp]
  00038	72 02		 jb	 SHORT $LN22@FillListCo
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
$LN22@FillListCo:
  0003c	8b 5d 0c	 mov	 ebx, DWORD PTR _line$[ebp]
  0003f	50		 push	 eax
  00040	6a 01		 push	 1
  00042	53		 push	 ebx
  00043	57		 push	 edi
  00044	e8 00 00 00 00	 call	 _ListSubItemSetW
  00049	83 c4 10	 add	 esp, 16			; 00000010H

; 519  : 
; 520  : 		if (favorite.DisconnectedDevice)

  0004c	80 7e 61 00	 cmp	 BYTE PTR [esi+97], 0
  00050	0f 84 d6 00 00
	00		 je	 $LN2@FillListCo

; 521  : 			ListSubItemSetW (FavoriteListControl, line, 2, (wchar_t *) (wstring (L"(") + GetString ("FAVORITE_DISCONNECTED_DEV") + L")").c_str());

  00056	6a 01		 push	 1
  00058	33 c0		 xor	 eax, eax
  0005a	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 7
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_13LLDNKHDC@?$AA?$CI?$AA?$AA@
  00066	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00069	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+16], 0
  00070	66 89 45 d8	 mov	 WORD PTR $T4[ebp], ax
  00074	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@OGKIEBOP@FAVORITE_DISCONNECTED_DEV?$AA@
  0007e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00085	e8 00 00 00 00	 call	 _GetString
  0008a	50		 push	 eax
  0008b	8d 45 d8	 lea	 eax, DWORD PTR $T4[ebp]
  0008e	50		 push	 eax
  0008f	8d 45 a8	 lea	 eax, DWORD PTR $T2[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_13DIBMAFH@?$AA?$CJ?$AA?$AA@
  0009d	50		 push	 eax
  0009e	8d 45 c0	 lea	 eax, DWORD PTR $T3[ebp]
  000a1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  000ab	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ae	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  000b2	72 02		 jb	 SHORT $LN153@FillListCo
  000b4	8b 00		 mov	 eax, DWORD PTR [eax]
$LN153@FillListCo:
  000b6	50		 push	 eax
  000b7	6a 02		 push	 2
  000b9	53		 push	 ebx
  000ba	57		 push	 edi
  000bb	e8 00 00 00 00	 call	 _ListSubItemSetW
  000c0	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp+20]
  000c3	83 c4 10	 add	 esp, 16			; 00000010H
  000c6	83 f8 08	 cmp	 eax, 8
  000c9	72 0d		 jb	 SHORT $LN162@FillListCo
  000cb	40		 inc	 eax
  000cc	8d 4d c0	 lea	 ecx, DWORD PTR $T3[ebp]
  000cf	50		 push	 eax
  000d0	ff 75 c0	 push	 DWORD PTR $T3[ebp]
  000d3	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN162@FillListCo:
  000d8	33 c0		 xor	 eax, eax
  000da	c7 45 d4 07 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 7
  000e1	66 89 45 c0	 mov	 WORD PTR $T3[ebp], ax
  000e5	8b 45 bc	 mov	 eax, DWORD PTR $T2[ebp+20]
  000e8	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0
  000ef	83 f8 08	 cmp	 eax, 8
  000f2	72 0d		 jb	 SHORT $LN265@FillListCo
  000f4	40		 inc	 eax
  000f5	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  000f8	50		 push	 eax
  000f9	ff 75 a8	 push	 DWORD PTR $T2[ebp]
  000fc	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN265@FillListCo:
  00101	33 c0		 xor	 eax, eax
  00103	c7 45 bc 07 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 7
  0010a	66 89 45 a8	 mov	 WORD PTR $T2[ebp], ax
  0010e	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp+20]
  00111	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0
  00118	83 f8 08	 cmp	 eax, 8
  0011b	72 24		 jb	 SHORT $LN3@FillListCo
  0011d	40		 inc	 eax
  0011e	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00121	50		 push	 eax
  00122	ff 75 d8	 push	 DWORD PTR $T4[ebp]
  00125	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate

; 522  : 		else

  0012a	eb 15		 jmp	 SHORT $LN3@FillListCo
$LN2@FillListCo:

; 523  : 			ListSubItemSet (FavoriteListControl, line, 2, (char *) favorite.Path.c_str());

  0012c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00130	72 02		 jb	 SHORT $LN479@FillListCo
  00132	8b 36		 mov	 esi, DWORD PTR [esi]
$LN479@FillListCo:
  00134	56		 push	 esi
  00135	6a 02		 push	 2
  00137	53		 push	 ebx
  00138	57		 push	 edi
  00139	e8 00 00 00 00	 call	 _ListSubItemSet
  0013e	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@FillListCo:

; 524  : 	}

  00141	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00144	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0014b	59		 pop	 ecx
  0014c	5f		 pop	 edi
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00152	33 cd		 xor	 ecx, ebp
  00154	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FillListControlSubItems@GostCrypt@@YAXPAUHWND__@@HABUFavoriteVolume@1@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?FillListControlSubItems@GostCrypt@@YAXPAUHWND__@@HABUFavoriteVolume@1@@Z$1:
  00008	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?FillListControlSubItems@GostCrypt@@YAXPAUHWND__@@HABUFavoriteVolume@1@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?FillListControlSubItems@GostCrypt@@YAXPAUHWND__@@HABUFavoriteVolume@1@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?FillListControlSubItems@GostCrypt@@YAXPAUHWND__@@HABUFavoriteVolume@1@@Z ENDP ; GostCrypt::FillListControlSubItems
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
_TEXT	SEGMENT
_$S4$2 = -172						; size = 28
_favorite$3 = -144					; size = 104
$T4 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_favoriteListControl$ = 8				; size = 4
_favorites$ = 12					; size = 4
?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z PROC ; GostCrypt::FillListControl, COMDAT

; 494  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 5d 08	 mov	 ebx, DWORD PTR _favoriteListControl$[ebp]
  00031	8b 75 0c	 mov	 esi, DWORD PTR _favorites$[ebp]

; 495  : 		SendMessage (favoriteListControl, LVM_DELETEALLITEMS, 0, 0);

  00034	6a 00		 push	 0
  00036	6a 00		 push	 0
  00038	68 09 10 00 00	 push	 4105			; 00001009H
  0003d	53		 push	 ebx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 496  : 
; 497  : 		int line = 0;
; 498  : 		foreach (const FavoriteVolume favorite, favorites)

  00044	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _$S4$2[ebp]
  0004a	33 ff		 xor	 edi, edi
  0004c	56		 push	 esi
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
  00053	83 c4 08	 add	 esp, 8
  00056	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _$S4$2[ebp]
  0005c	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _$S4$2[ebp]
  00062	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00065	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00068	ff d0		 call	 eax
  0006a	84 c0		 test	 al, al
  0006c	0f 84 00 01 00
	00		 je	 $LN321@FillListCo
$LL4@FillListCo:
  00072	ff b5 6c ff ff
	ff		 push	 DWORD PTR _$S4$2[ebp+24]
  00078	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _favorite$3[ebp]
  0007e	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
  00083	33 c0		 xor	 eax, eax
  00085	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00089	38 85 59 ff ff
	ff		 cmp	 BYTE PTR _$S4$2[ebp+5], al
  0008f	0f 94 c0	 sete	 al
  00092	88 85 59 ff ff
	ff		 mov	 BYTE PTR _$S4$2[ebp+5], al
  00098	84 c0		 test	 al, al
  0009a	0f 84 9b 00 00
	00		 je	 $LN6@FillListCo
$LL7@FillListCo:

; 499  : 		{
; 500  : 			ListItemAdd (favoriteListControl, line, (char *) favorite.MountPoint.substr (0, 2).c_str());

  000a0	6a 02		 push	 2
  000a2	6a 00		 push	 0
  000a4	8d 45 d8	 lea	 eax, DWORD PTR $T4[ebp]
  000a7	50		 push	 eax
  000a8	8d 4d 88	 lea	 ecx, DWORD PTR _favorite$3[ebp+24]
  000ab	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  000b0	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  000b4	72 02		 jb	 SHORT $LN40@FillListCo
  000b6	8b 00		 mov	 eax, DWORD PTR [eax]
$LN40@FillListCo:
  000b8	50		 push	 eax
  000b9	57		 push	 edi
  000ba	53		 push	 ebx
  000bb	e8 00 00 00 00	 call	 _ListItemAdd
  000c0	8b 4d ec	 mov	 ecx, DWORD PTR $T4[ebp+20]
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c6	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000c9	72 3e		 jb	 SHORT $LN129@FillListCo
  000cb	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  000ce	41		 inc	 ecx
  000cf	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000d5	72 29		 jb	 SHORT $LN124@FillListCo
  000d7	a8 1f		 test	 al, 31			; 0000001fH
  000d9	0f 85 e5 00 00
	00		 jne	 $LN311@FillListCo
  000df	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  000e2	3b c8		 cmp	 ecx, eax
  000e4	0f 83 da 00 00
	00		 jae	 $LN311@FillListCo
  000ea	2b c1		 sub	 eax, ecx
  000ec	83 f8 04	 cmp	 eax, 4
  000ef	0f 82 cf 00 00
	00		 jb	 $LN311@FillListCo
  000f5	83 f8 23	 cmp	 eax, 35			; 00000023H
  000f8	0f 87 c6 00 00
	00		 ja	 $LN311@FillListCo
  000fe	8b c1		 mov	 eax, ecx
$LN124@FillListCo:
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00106	83 c4 04	 add	 esp, 4
$LN129@FillListCo:

; 501  : 			FillListControlSubItems (favoriteListControl, line++, favorite);

  00109	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _favorite$3[ebp]
  0010f	50		 push	 eax
  00110	57		 push	 edi
  00111	53		 push	 ebx
  00112	e8 00 00 00 00	 call	 ?FillListControlSubItems@GostCrypt@@YAXPAUHWND__@@HABUFavoriteVolume@1@@Z ; GostCrypt::FillListControlSubItems
  00117	33 c0		 xor	 eax, eax
  00119	c6 85 58 ff ff
	ff 01		 mov	 BYTE PTR _$S4$2[ebp+4], 1
  00120	83 c4 0c	 add	 esp, 12			; 0000000cH
  00123	47		 inc	 edi
  00124	38 85 59 ff ff
	ff		 cmp	 BYTE PTR _$S4$2[ebp+5], al
  0012a	0f 94 c0	 sete	 al
  0012d	88 85 59 ff ff
	ff		 mov	 BYTE PTR _$S4$2[ebp+5], al
  00133	84 c0		 test	 al, al
  00135	0f 85 65 ff ff
	ff		 jne	 $LL7@FillListCo
$LN6@FillListCo:

; 502  : 		}

  0013b	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _favorite$3[ebp]
  00141	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00145	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  0014a	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _$S4$2[ebp]
  00150	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _$S4$2[ebp]
  00156	ff 50 08	 call	 DWORD PTR [eax+8]
  00159	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _$S4$2[ebp]
  0015f	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _$S4$2[ebp]
  00165	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00168	ff d0		 call	 eax
  0016a	84 c0		 test	 al, al
  0016c	0f 85 00 ff ff
	ff		 jne	 $LL4@FillListCo
$LN321@FillListCo:
  00172	8b b5 5c ff ff
	ff		 mov	 esi, DWORD PTR _$S4$2[ebp+8]
  00178	85 f6		 test	 esi, esi
  0017a	0f 84 8e 00 00
	00		 je	 $LN168@FillListCo
  00180	8b bd 60 ff ff
	ff		 mov	 edi, DWORD PTR _$S4$2[ebp+12]
  00186	3b f7		 cmp	 esi, edi
  00188	74 1a		 je	 SHORT $LN209@FillListCo
  0018a	66 0f 1f 44 00
	00		 npad	 6
$LL210@FillListCo:
  00190	8b ce		 mov	 ecx, esi
  00192	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  00197	83 c6 68	 add	 esi, 104		; 00000068H
  0019a	3b f7		 cmp	 esi, edi
  0019c	75 f2		 jne	 SHORT $LL210@FillListCo
  0019e	8b b5 5c ff ff
	ff		 mov	 esi, DWORD PTR _$S4$2[ebp+8]
$LN209@FillListCo:
  001a4	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _$S4$2[ebp+16]
  001aa	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  001af	2b ce		 sub	 ecx, esi
  001b1	f7 e9		 imul	 ecx
  001b3	c1 fa 05	 sar	 edx, 5
  001b6	8b c2		 mov	 eax, edx
  001b8	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001bb	03 c2		 add	 eax, edx
  001bd	3d 62 27 76 02	 cmp	 eax, 41297762		; 02762762H
  001c2	76 05		 jbe	 SHORT $LN262@FillListCo
$LN311@FillListCo:
  001c4	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN324@FillListCo:
$LN262@FillListCo:
  001c9	6b c0 68	 imul	 eax, eax, 104
  001cc	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  001d1	72 32		 jb	 SHORT $LN263@FillListCo
  001d3	f6 85 5c ff ff
	ff 1f		 test	 BYTE PTR _$S4$2[ebp+8], 31 ; 0000001fH
  001da	74 05		 je	 SHORT $LN264@FillListCo
  001dc	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN325@FillListCo:
$LN264@FillListCo:
  001e1	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  001e4	3b c6		 cmp	 eax, esi
  001e6	72 05		 jb	 SHORT $LN265@FillListCo
  001e8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN326@FillListCo:
$LN265@FillListCo:
  001ed	2b f0		 sub	 esi, eax
  001ef	83 fe 04	 cmp	 esi, 4
  001f2	73 05		 jae	 SHORT $LN266@FillListCo
  001f4	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN327@FillListCo:
$LN266@FillListCo:
  001f9	83 fe 23	 cmp	 esi, 35			; 00000023H
  001fc	76 05		 jbe	 SHORT $LN267@FillListCo
  001fe	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN328@FillListCo:
$LN267@FillListCo:
  00203	8b f0		 mov	 esi, eax
$LN263@FillListCo:
  00205	56		 push	 esi
  00206	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0020b	83 c4 04	 add	 esp, 4
$LN168@FillListCo:

; 503  : 	}

  0020e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00211	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00218	59		 pop	 ecx
  00219	5f		 pop	 edi
  0021a	5e		 pop	 esi
  0021b	5b		 pop	 ebx
  0021c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021f	33 cd		 xor	 ecx, ebp
  00221	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00226	8b e5		 mov	 esp, ebp
  00228	5d		 pop	 ebp
  00229	c3		 ret	 0
$LN323@FillListCo:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z$0:
  00000	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _$S4$2[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z$1:
  0000b	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _favorite$3[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
__ehhandler$?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a 50 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-176]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ENDP ; GostCrypt::FillListControl
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ
_TEXT	SEGMENT
_$S3$2 = -180						; size = 28
tv4761 = -152						; size = 4
_favorite$1$ = -148					; size = 4
_i$1$ = -144						; size = 4
$T3 = -140						; size = 4
$T4 = -136						; size = 24
$T5 = -136						; size = 24
$T6 = -112						; size = 24
$T7 = -112						; size = 24
$T8 = -88						; size = 24
$T9 = -88						; size = 24
$T10 = -88						; size = 24
$T11 = -64						; size = 24
$T12 = -64						; size = 24
$T13 = -64						; size = 24
_menuText$14 = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ PROC		; GostCrypt::FillFavoriteVolumesMenu, COMDAT

; 450  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	33 db		 xor	 ebx, ebx
  00030	89 9d 74 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], ebx
  00036	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__DeleteMenu@12
  0003c	0f 1f 40 00	 npad	 4
$LL2@FillFavori:

; 451  : 		while (DeleteMenu (FavoriteVolumesMenu, 7, MF_BYPOSITION)) { }

  00040	68 00 04 00 00	 push	 1024			; 00000400H
  00045	6a 07		 push	 7
  00047	ff 35 00 00 00
	00		 push	 DWORD PTR ?FavoriteVolumesMenu@GostCrypt@@3PAUHMENU__@@A ; GostCrypt::FavoriteVolumesMenu
  0004d	ff d6		 call	 esi
  0004f	85 c0		 test	 eax, eax
  00051	75 ed		 jne	 SHORT $LL2@FillFavori

; 452  : 
; 453  : 		if (FavoriteVolumes.empty())

  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00058	3b 05 04 00 00
	00		 cmp	 eax, DWORD PTR ?FavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+4
  0005e	0f 94 c0	 sete	 al
  00061	84 c0		 test	 al, al
  00063	0f 85 fd 04 00
	00		 jne	 $LN2445@FillFavori

; 454  : 			return;
; 455  : 
; 456  : 		AppendMenu (FavoriteVolumesMenu, MF_SEPARATOR, 0, NULL);

  00069	6a 00		 push	 0
  0006b	6a 00		 push	 0
  0006d	68 00 08 00 00	 push	 2048			; 00000800H
  00072	ff 35 00 00 00
	00		 push	 DWORD PTR ?FavoriteVolumesMenu@GostCrypt@@3PAUHMENU__@@A ; GostCrypt::FavoriteVolumesMenu
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AppendMenuA@16

; 457  : 		
; 458  : 		int i = 0;
; 459  : 		foreach (const FavoriteVolume &favorite, FavoriteVolumes)

  0007e	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _$S3$2[ebp]
  00084	89 9d 70 ff ff
	ff		 mov	 DWORD PTR _i$1$[ebp], ebx
  0008a	68 00 00 00 00	 push	 OFFSET ?FavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoriteVolumes
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
  00095	83 c4 08	 add	 esp, 8
  00098	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _$S3$2[ebp]
  0009e	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _$S3$2[ebp]
  000a4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000ab	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ae	ff d0		 call	 eax
  000b0	84 c0		 test	 al, al
  000b2	0f 84 a3 04 00
	00		 je	 $LN5@FillFavori
  000b8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL6@FillFavori:
  000c0	8b bd 64 ff ff
	ff		 mov	 edi, DWORD PTR _$S3$2[ebp+24]
  000c6	33 c0		 xor	 eax, eax
  000c8	38 85 51 ff ff
	ff		 cmp	 BYTE PTR _$S3$2[ebp+5], al
  000ce	89 bd 6c ff ff
	ff		 mov	 DWORD PTR _favorite$1$[ebp], edi
  000d4	0f 94 c0	 sete	 al
  000d7	88 85 51 ff ff
	ff		 mov	 BYTE PTR _$S3$2[ebp+5], al
  000dd	84 c0		 test	 al, al
  000df	0f 84 4e 04 00
	00		 je	 $LN4@FillFavori
$LL9@FillFavori:
  000e5	33 c0		 xor	 eax, eax
  000e7	38 47 61	 cmp	 BYTE PTR [edi+97], al

; 460  : 		{
; 461  : 			UINT flags = MF_STRING;
; 462  : 
; 463  : 			if (favorite.DisconnectedDevice)
; 464  : 				flags |= MF_GRAYED;
; 465  : 
; 466  : 			wstring menuText = SingleStringToWide (favorite.Path);

  000ea	57		 push	 edi
  000eb	0f 95 c0	 setne	 al
  000ee	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv4761[ebp], eax
  000f4	8d 45 d8	 lea	 eax, DWORD PTR _menuText$14[ebp]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 ?SingleStringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; SingleStringToWide
  000fd	83 c4 08	 add	 esp, 8

; 467  : 			if (favorite.DisconnectedDevice)

  00100	80 7f 61 00	 cmp	 BYTE PTR [edi+97], 0
  00104	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00108	0f 84 09 02 00
	00		 je	 $LN1162@FillFavori

; 468  : 				menuText = favorite.Label.empty() ? wstring (L"(") + GetString ("FAVORITE_DISCONNECTED_DEV") + L")" : L"";

  0010e	33 c0		 xor	 eax, eax
  00110	39 47 58	 cmp	 DWORD PTR [edi+88], eax
  00113	75 7e		 jne	 SHORT $LN19@FillFavori
  00115	6a 01		 push	 1
  00117	68 00 00 00 00	 push	 OFFSET ??_C@_13LLDNKHDC@?$AA?$CI?$AA?$AA@
  0011c	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00122	c7 45 8c 07 00
	00 00		 mov	 DWORD PTR $T5[ebp+20], 7
  00129	89 45 88	 mov	 DWORD PTR $T5[ebp+16], eax
  0012c	66 89 85 78 ff
	ff ff		 mov	 WORD PTR $T5[ebp], ax
  00133	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00138	83 cb 01	 or	 ebx, 1
  0013b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@OGKIEBOP@FAVORITE_DISCONNECTED_DEV?$AA@
  00144	89 9d 74 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], ebx
  0014a	8b fb		 mov	 edi, ebx
  0014c	e8 00 00 00 00	 call	 _GetString
  00151	50		 push	 eax
  00152	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00158	50		 push	 eax
  00159	8d 45 c0	 lea	 eax, DWORD PTR $T13[ebp]
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00162	68 00 00 00 00	 push	 OFFSET ??_C@_13DIBMAFH@?$AA?$CJ?$AA?$AA@
  00167	50		 push	 eax
  00168	8d 45 a8	 lea	 eax, DWORD PTR $T10[ebp]
  0016b	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00172	83 cb 02	 or	 ebx, 2
  00175	50		 push	 eax
  00176	89 9d 74 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], ebx
  0017c	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00181	83 c4 1c	 add	 esp, 28			; 0000001cH
  00184	8b f0		 mov	 esi, eax
  00186	8b df		 mov	 ebx, edi
  00188	8b bd 6c ff ff
	ff		 mov	 edi, DWORD PTR _favorite$1$[ebp]
  0018e	83 cb 06	 or	 ebx, 6
  00191	eb 27		 jmp	 SHORT $LN2459@FillFavori
$LN19@FillFavori:
  00193	6a 00		 push	 0
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
  0019a	8d 4d 90	 lea	 ecx, DWORD PTR $T7[ebp]
  0019d	c7 45 a4 07 00
	00 00		 mov	 DWORD PTR $T7[ebp+20], 7
  001a4	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR $T7[ebp+16], 0
  001ab	66 89 45 90	 mov	 WORD PTR $T7[ebp], ax
  001af	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  001b4	8d 75 90	 lea	 esi, DWORD PTR $T7[ebp]
  001b7	83 cb 08	 or	 ebx, 8
$LN2459@FillFavori:
  001ba	89 9d 74 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], ebx
  001c0	8d 45 d8	 lea	 eax, DWORD PTR _menuText$14[ebp]
  001c3	3b c6		 cmp	 eax, esi
  001c5	74 7b		 je	 SHORT $LN845@FillFavori
  001c7	8b 45 ec	 mov	 eax, DWORD PTR _menuText$14[ebp+20]
  001ca	83 f8 08	 cmp	 eax, 8
  001cd	72 0d		 jb	 SHORT $LN324@FillFavori
  001cf	40		 inc	 eax
  001d0	8d 4d d8	 lea	 ecx, DWORD PTR _menuText$14[ebp]
  001d3	50		 push	 eax
  001d4	ff 75 d8	 push	 DWORD PTR _menuText$14[ebp]
  001d7	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN324@FillFavori:
  001dc	33 c0		 xor	 eax, eax
  001de	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR _menuText$14[ebp+20], 7
  001e5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _menuText$14[ebp+16], 0
  001ec	66 89 45 d8	 mov	 WORD PTR _menuText$14[ebp], ax
  001f0	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  001f4	73 1a		 jae	 SHORT $LN611@FillFavori
  001f6	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  001f9	83 c0 01	 add	 eax, 1
  001fc	74 1d		 je	 SHORT $LN612@FillFavori
  001fe	03 c0		 add	 eax, eax
  00200	50		 push	 eax
  00201	8d 45 d8	 lea	 eax, DWORD PTR _menuText$14[ebp]
  00204	56		 push	 esi
  00205	50		 push	 eax
  00206	e8 00 00 00 00	 call	 _memmove
  0020b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020e	eb 0b		 jmp	 SHORT $LN612@FillFavori
$LN611@FillFavori:
  00210	8b 06		 mov	 eax, DWORD PTR [esi]
  00212	89 45 d8	 mov	 DWORD PTR _menuText$14[ebp], eax
  00215	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN612@FillFavori:
  0021b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0021e	89 45 e8	 mov	 DWORD PTR _menuText$14[ebp+16], eax
  00221	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00224	89 45 ec	 mov	 DWORD PTR _menuText$14[ebp+20], eax
  00227	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0022e	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00232	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00239	72 02		 jb	 SHORT $LN841@FillFavori
  0023b	8b 36		 mov	 esi, DWORD PTR [esi]
$LN841@FillFavori:
  0023d	33 c0		 xor	 eax, eax
  0023f	66 89 06	 mov	 WORD PTR [esi], ax
$LN845@FillFavori:
  00242	f6 c3 08	 test	 bl, 8
  00245	74 32		 je	 SHORT $LN848@FillFavori
  00247	8b 45 a4	 mov	 eax, DWORD PTR $T7[ebp+20]
  0024a	83 e3 f7	 and	 ebx, -9			; fffffff7H
  0024d	89 9d 74 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], ebx
  00253	83 f8 08	 cmp	 eax, 8
  00256	72 0d		 jb	 SHORT $LN853@FillFavori
  00258	40		 inc	 eax
  00259	8d 4d 90	 lea	 ecx, DWORD PTR $T7[ebp]
  0025c	50		 push	 eax
  0025d	ff 75 90	 push	 DWORD PTR $T7[ebp]
  00260	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN853@FillFavori:
  00265	33 c0		 xor	 eax, eax
  00267	c7 45 a4 07 00
	00 00		 mov	 DWORD PTR $T7[ebp+20], 7
  0026e	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR $T7[ebp+16], 0
  00275	66 89 45 90	 mov	 WORD PTR $T7[ebp], ax
$LN848@FillFavori:
  00279	f6 c3 04	 test	 bl, 4
  0027c	74 32		 je	 SHORT $LN951@FillFavori
  0027e	8b 45 bc	 mov	 eax, DWORD PTR $T10[ebp+20]
  00281	83 e3 fb	 and	 ebx, -5			; fffffffbH
  00284	89 9d 74 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], ebx
  0028a	83 f8 08	 cmp	 eax, 8
  0028d	72 0d		 jb	 SHORT $LN956@FillFavori
  0028f	40		 inc	 eax
  00290	8d 4d a8	 lea	 ecx, DWORD PTR $T10[ebp]
  00293	50		 push	 eax
  00294	ff 75 a8	 push	 DWORD PTR $T10[ebp]
  00297	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN956@FillFavori:
  0029c	33 c0		 xor	 eax, eax
  0029e	c7 45 bc 07 00
	00 00		 mov	 DWORD PTR $T10[ebp+20], 7
  002a5	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T10[ebp+16], 0
  002ac	66 89 45 a8	 mov	 WORD PTR $T10[ebp], ax
$LN951@FillFavori:
  002b0	f6 c3 02	 test	 bl, 2
  002b3	74 32		 je	 SHORT $LN1054@FillFavori
  002b5	8b 45 d4	 mov	 eax, DWORD PTR $T13[ebp+20]
  002b8	83 e3 fd	 and	 ebx, -3			; fffffffdH
  002bb	89 9d 74 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], ebx
  002c1	83 f8 08	 cmp	 eax, 8
  002c4	72 0d		 jb	 SHORT $LN1059@FillFavori
  002c6	40		 inc	 eax
  002c7	8d 4d c0	 lea	 ecx, DWORD PTR $T13[ebp]
  002ca	50		 push	 eax
  002cb	ff 75 c0	 push	 DWORD PTR $T13[ebp]
  002ce	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN1059@FillFavori:
  002d3	33 c0		 xor	 eax, eax
  002d5	c7 45 d4 07 00
	00 00		 mov	 DWORD PTR $T13[ebp+20], 7
  002dc	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T13[ebp+16], 0
  002e3	66 89 45 c0	 mov	 WORD PTR $T13[ebp], ax
$LN1054@FillFavori:
  002e7	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  002ee	f6 c3 01	 test	 bl, 1
  002f1	74 24		 je	 SHORT $LN1162@FillFavori
  002f3	8b 45 8c	 mov	 eax, DWORD PTR $T5[ebp+20]
  002f6	83 e3 fe	 and	 ebx, -2			; fffffffeH
  002f9	89 9d 74 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], ebx
  002ff	83 f8 08	 cmp	 eax, 8
  00302	72 13		 jb	 SHORT $LN1162@FillFavori
  00304	40		 inc	 eax
  00305	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0030b	50		 push	 eax
  0030c	ff b5 78 ff ff
	ff		 push	 DWORD PTR $T5[ebp]
  00312	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN1162@FillFavori:
  00317	83 7f 58 00	 cmp	 DWORD PTR [edi+88], 0

; 469  : 
; 470  : 			if (!favorite.Label.empty())

  0031b	0f 84 c1 00 00
	00		 je	 $LN1774@FillFavori

; 471  : 			{
; 472  : 				if (favorite.DisconnectedDevice)

  00321	80 7f 61 00	 cmp	 BYTE PTR [edi+97], 0

; 473  : 					menuText = favorite.Label + L" " + menuText;

  00325	8d 47 48	 lea	 eax, DWORD PTR [edi+72]
  00328	0f 84 a3 00 00
	00		 je	 $LN14@FillFavori
  0032e	68 00 00 00 00	 push	 OFFSET ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
  00333	50		 push	 eax
  00334	8d 45 a8	 lea	 eax, DWORD PTR $T9[ebp]
  00337	50		 push	 eax
  00338	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0033d	8d 4d d8	 lea	 ecx, DWORD PTR _menuText$14[ebp]
  00340	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00344	51		 push	 ecx
  00345	50		 push	 eax
  00346	8d 45 c0	 lea	 eax, DWORD PTR $T12[ebp]
  00349	50		 push	 eax
  0034a	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@ABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0034f	83 c4 18	 add	 esp, 24			; 00000018H
  00352	8b f0		 mov	 esi, eax
  00354	8d 45 d8	 lea	 eax, DWORD PTR _menuText$14[ebp]
  00357	3b c6		 cmp	 eax, esi
  00359	74 32		 je	 SHORT $LN1275@FillFavori
  0035b	8b 45 ec	 mov	 eax, DWORD PTR _menuText$14[ebp+20]
  0035e	83 f8 08	 cmp	 eax, 8
  00361	72 0d		 jb	 SHORT $LN1281@FillFavori
  00363	40		 inc	 eax
  00364	8d 4d d8	 lea	 ecx, DWORD PTR _menuText$14[ebp]
  00367	50		 push	 eax
  00368	ff 75 d8	 push	 DWORD PTR _menuText$14[ebp]
  0036b	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN1281@FillFavori:
  00370	33 c0		 xor	 eax, eax
  00372	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR _menuText$14[ebp+20], 7
  00379	56		 push	 esi
  0037a	8d 4d d8	 lea	 ecx, DWORD PTR _menuText$14[ebp]
  0037d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _menuText$14[ebp+16], 0
  00384	66 89 45 d8	 mov	 WORD PTR _menuText$14[ebp], ax
  00388	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN1275@FillFavori:
  0038d	8b 45 d4	 mov	 eax, DWORD PTR $T12[ebp+20]
  00390	83 f8 08	 cmp	 eax, 8
  00393	72 0d		 jb	 SHORT $LN1573@FillFavori
  00395	40		 inc	 eax
  00396	8d 4d c0	 lea	 ecx, DWORD PTR $T12[ebp]
  00399	50		 push	 eax
  0039a	ff 75 c0	 push	 DWORD PTR $T12[ebp]
  0039d	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN1573@FillFavori:
  003a2	33 c0		 xor	 eax, eax
  003a4	c7 45 d4 07 00
	00 00		 mov	 DWORD PTR $T12[ebp+20], 7
  003ab	66 89 45 c0	 mov	 WORD PTR $T12[ebp], ax
  003af	8b 45 bc	 mov	 eax, DWORD PTR $T9[ebp+20]
  003b2	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T12[ebp+16], 0
  003b9	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  003bd	83 f8 08	 cmp	 eax, 8
  003c0	72 20		 jb	 SHORT $LN1774@FillFavori
  003c2	40		 inc	 eax
  003c3	8d 4d a8	 lea	 ecx, DWORD PTR $T9[ebp]
  003c6	50		 push	 eax
  003c7	ff 75 a8	 push	 DWORD PTR $T9[ebp]
  003ca	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate

; 474  : 				else

  003cf	eb 11		 jmp	 SHORT $LN1774@FillFavori
$LN14@FillFavori:

; 475  : 					menuText = favorite.Label;

  003d1	8d 4d d8	 lea	 ecx, DWORD PTR _menuText$14[ebp]
  003d4	3b c8		 cmp	 ecx, eax
  003d6	74 0a		 je	 SHORT $LN1774@FillFavori
  003d8	6a ff		 push	 -1
  003da	6a 00		 push	 0
  003dc	50		 push	 eax
  003dd	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN1774@FillFavori:

; 476  : 			}
; 477  : 
; 478  : 			AppendMenuW (FavoriteVolumesMenu, flags, GST_FAVORITE_MENU_CMD_ID_OFFSET + i++,

  003e2	8d 47 18	 lea	 eax, DWORD PTR [edi+24]
  003e5	50		 push	 eax
  003e6	8d 45 90	 lea	 eax, DWORD PTR $T6[ebp]
  003e9	50		 push	 eax
  003ea	e8 00 00 00 00	 call	 ?SingleStringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; SingleStringToWide
  003ef	83 c4 08	 add	 esp, 8
  003f2	6a 02		 push	 2
  003f4	6a 00		 push	 0
  003f6	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  003fc	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00400	51		 push	 ecx
  00401	8b c8		 mov	 ecx, eax
  00403	e8 00 00 00 00	 call	 ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
  00408	8b f0		 mov	 esi, eax
  0040a	68 00 00 00 00	 push	 OFFSET ??_C@_13KDLDGPGJ@?$AA?7?$AA?$AA@
  0040f	8d 45 d8	 lea	 eax, DWORD PTR _menuText$14[ebp]
  00412	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00416	50		 push	 eax
  00417	8d 45 a8	 lea	 eax, DWORD PTR $T8[ebp]
  0041a	50		 push	 eax
  0041b	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00420	56		 push	 esi
  00421	50		 push	 eax
  00422	8d 45 c0	 lea	 eax, DWORD PTR $T11[ebp]
  00425	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00429	50		 push	 eax
  0042a	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0042f	83 c4 18	 add	 esp, 24			; 00000018H
  00432	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00436	72 02		 jb	 SHORT $LN1920@FillFavori
  00438	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1920@FillFavori:
  0043a	8b b5 70 ff ff
	ff		 mov	 esi, DWORD PTR _i$1$[ebp]
  00440	50		 push	 eax
  00441	8d 86 10 27 00
	00		 lea	 eax, DWORD PTR [esi+10000]
  00447	50		 push	 eax
  00448	ff b5 68 ff ff
	ff		 push	 DWORD PTR tv4761[ebp]
  0044e	ff 35 00 00 00
	00		 push	 DWORD PTR ?FavoriteVolumesMenu@GostCrypt@@3PAUHMENU__@@A ; GostCrypt::FavoriteVolumesMenu
  00454	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AppendMenuW@16
  0045a	8b 45 d4	 mov	 eax, DWORD PTR $T11[ebp+20]
  0045d	46		 inc	 esi
  0045e	89 b5 70 ff ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  00464	83 f8 08	 cmp	 eax, 8
  00467	72 0d		 jb	 SHORT $LN1929@FillFavori
  00469	40		 inc	 eax
  0046a	8d 4d c0	 lea	 ecx, DWORD PTR $T11[ebp]
  0046d	50		 push	 eax
  0046e	ff 75 c0	 push	 DWORD PTR $T11[ebp]
  00471	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN1929@FillFavori:
  00476	33 c0		 xor	 eax, eax
  00478	c7 45 d4 07 00
	00 00		 mov	 DWORD PTR $T11[ebp+20], 7
  0047f	66 89 45 c0	 mov	 WORD PTR $T11[ebp], ax
  00483	8b 45 bc	 mov	 eax, DWORD PTR $T8[ebp+20]
  00486	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T11[ebp+16], 0
  0048d	83 f8 08	 cmp	 eax, 8
  00490	72 0d		 jb	 SHORT $LN2032@FillFavori
  00492	40		 inc	 eax
  00493	8d 4d a8	 lea	 ecx, DWORD PTR $T8[ebp]
  00496	50		 push	 eax
  00497	ff 75 a8	 push	 DWORD PTR $T8[ebp]
  0049a	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN2032@FillFavori:
  0049f	33 c0		 xor	 eax, eax
  004a1	c7 45 bc 07 00
	00 00		 mov	 DWORD PTR $T8[ebp+20], 7
  004a8	66 89 45 a8	 mov	 WORD PTR $T8[ebp], ax
  004ac	8b 45 8c	 mov	 eax, DWORD PTR $T4[ebp+20]
  004af	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T8[ebp+16], 0
  004b6	83 f8 08	 cmp	 eax, 8
  004b9	72 13		 jb	 SHORT $LN2135@FillFavori
  004bb	40		 inc	 eax
  004bc	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  004c2	50		 push	 eax
  004c3	ff b5 78 ff ff
	ff		 push	 DWORD PTR $T4[ebp]
  004c9	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN2135@FillFavori:
  004ce	33 c0		 xor	 eax, eax
  004d0	c7 45 8c 07 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 7
  004d7	66 89 85 78 ff
	ff ff		 mov	 WORD PTR $T4[ebp], ax
  004de	8b 45 a4	 mov	 eax, DWORD PTR $T6[ebp+20]
  004e1	c7 45 88 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+16], 0
  004e8	83 f8 08	 cmp	 eax, 8
  004eb	72 0d		 jb	 SHORT $LN2238@FillFavori
  004ed	40		 inc	 eax
  004ee	8d 4d 90	 lea	 ecx, DWORD PTR $T6[ebp]
  004f1	50		 push	 eax
  004f2	ff 75 90	 push	 DWORD PTR $T6[ebp]
  004f5	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN2238@FillFavori:

; 479  : 				(menuText + L"\t" + SingleStringToWide (favorite.MountPoint).substr (0, 2)).c_str());
; 480  : 		}

  004fa	8b 45 ec	 mov	 eax, DWORD PTR _menuText$14[ebp+20]
  004fd	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00501	83 f8 08	 cmp	 eax, 8
  00504	72 0d		 jb	 SHORT $LN2341@FillFavori
  00506	40		 inc	 eax
  00507	8d 4d d8	 lea	 ecx, DWORD PTR _menuText$14[ebp]
  0050a	50		 push	 eax
  0050b	ff 75 d8	 push	 DWORD PTR _menuText$14[ebp]
  0050e	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN2341@FillFavori:

; 457  : 		
; 458  : 		int i = 0;
; 459  : 		foreach (const FavoriteVolume &favorite, FavoriteVolumes)

  00513	33 c0		 xor	 eax, eax
  00515	c6 85 50 ff ff
	ff 01		 mov	 BYTE PTR _$S3$2[ebp+4], 1
  0051c	38 85 51 ff ff
	ff		 cmp	 BYTE PTR _$S3$2[ebp+5], al
  00522	0f 94 c0	 sete	 al
  00525	88 85 51 ff ff
	ff		 mov	 BYTE PTR _$S3$2[ebp+5], al
  0052b	84 c0		 test	 al, al
  0052d	0f 85 b2 fb ff
	ff		 jne	 $LL9@FillFavori
$LN4@FillFavori:
  00533	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _$S3$2[ebp]
  00539	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _$S3$2[ebp]
  0053f	ff 50 08	 call	 DWORD PTR [eax+8]
  00542	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _$S3$2[ebp]
  00548	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _$S3$2[ebp]
  0054e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00551	ff d0		 call	 eax
  00553	84 c0		 test	 al, al
  00555	0f 85 65 fb ff
	ff		 jne	 $LL6@FillFavori
$LN5@FillFavori:

; 479  : 				(menuText + L"\t" + SingleStringToWide (favorite.MountPoint).substr (0, 2)).c_str());
; 480  : 		}

  0055b	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _$S3$2[ebp+8]
  00561	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Tidy
$LN2445@FillFavori:

; 481  : 	}

  00566	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00569	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00570	59		 pop	 ecx
  00571	5f		 pop	 edi
  00572	5e		 pop	 esi
  00573	5b		 pop	 ebx
  00574	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00577	33 cd		 xor	 ecx, ebp
  00579	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0057e	8b e5		 mov	 esp, ebp
  00580	5d		 pop	 ebp
  00581	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$0:
  00000	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _$S3$2[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$1:
  0000b	8d 4d d8	 lea	 ecx, DWORD PTR _menuText$14[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$2:
  00013	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	0f 84 12 00 00
	00		 je	 $LN24@FillFavori
  00022	83 a5 74 ff ff
	ff fe		 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00029	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0002f	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN24@FillFavori:
  00034	c3		 ret	 0
__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$3:
  00035	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0003b	83 e0 02	 and	 eax, 2
  0003e	0f 84 0f 00 00
	00		 je	 $LN26@FillFavori
  00044	83 a5 74 ff ff
	ff fd		 and	 DWORD PTR $T3[ebp], -3	; fffffffdH
  0004b	8d 4d c0	 lea	 ecx, DWORD PTR $T13[ebp]
  0004e	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN26@FillFavori:
  00053	c3		 ret	 0
__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$4:
  00054	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0005a	83 e0 04	 and	 eax, 4
  0005d	0f 84 0f 00 00
	00		 je	 $LN28@FillFavori
  00063	83 a5 74 ff ff
	ff fb		 and	 DWORD PTR $T3[ebp], -5	; fffffffbH
  0006a	8d 4d a8	 lea	 ecx, DWORD PTR $T10[ebp]
  0006d	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN28@FillFavori:
  00072	c3		 ret	 0
__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$75:
  00073	e8 00 00 00 00	 call	 ___std_terminate
  00078	c3		 ret	 0
__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$6:
  00079	8d 4d a8	 lea	 ecx, DWORD PTR $T9[ebp]
  0007c	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$320:
  00081	e8 00 00 00 00	 call	 ___std_terminate
  00086	c3		 ret	 0
__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$8:
  00087	8d 4d 90	 lea	 ecx, DWORD PTR $T6[ebp]
  0008a	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$9:
  0008f	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00095	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ$10:
  0009a	8d 4d a8	 lea	 ecx, DWORD PTR $T8[ebp]
  0009d	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ:
  000a2	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000a6	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000a9	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  000af	33 c8		 xor	 ecx, eax
  000b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b6	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  000b9	33 c8		 xor	 ecx, eax
  000bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c0	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ
  000c5	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?FillFavoriteVolumesMenu@GostCrypt@@YAXXZ ENDP		; GostCrypt::FillFavoriteVolumesMenu
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_e$2 = -1828						; size = 4
_e$3 = -1824						; size = 4
_hwndDlg$GSCopy$ = -1820				; size = 4
$T4 = -1820						; size = 4
_lParam$GSCopy$1$ = -1816				; size = 4
_BootEncObj$5 = -1812					; size = 1480
$T6 = -1812						; size = 1480
$T7 = -332						; size = 94
_bootEncStatus$8 = -332					; size = 94
__macro_lvi$9 = -292					; size = 52
__macro_lvi$10 = -292					; size = 52
$T11 = -236						; size = 24
$T12 = -236						; size = 24
$T13 = -212						; size = 32
$T14 = -180						; size = 24
$T15 = -180						; size = 24
_rec$16 = -172						; size = 16
$T17 = -156						; size = 104
$T18 = -156						; size = 104
_favorite$19 = -156					; size = 104
$T20 = -156						; size = 104
_column$21 = -52					; size = 32
_$S2$22 = -48						; size = 28
_$S1$23 = -48						; size = 28
$T24 = -44						; size = 24
$T25 = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_hwndDlg$ = 8						; size = 4
_msg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z PROC ; GostCrypt::FavoriteVolumesDlgProc, COMDAT

; 134  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 18 07 00
	00		 sub	 esp, 1816		; 00000718H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 135  : 		/* This dialog is used both for System Favorites and non-system Favorites. 
; 136  : 
; 137  : 		The following options have different meaning in System Favorites mode:
; 138  : 
; 139  : 		IDC_FAVORITE_OPEN_EXPLORER_WIN_ON_MOUNT	=> MOUNT_SYSTEM_FAVORITES_ON_BOOT
; 140  : 		IDC_FAVORITE_DISABLE_HOTKEY		=> DISABLE_NONADMIN_SYS_FAVORITES_ACCESS
; 141  : 
; 142  : 		*/
; 143  : 
; 144  : 		WORD lw = LOWORD (wParam);
; 145  : 		static bool SystemFavoritesMode;
; 146  : 		static vector <FavoriteVolume> Favorites;

  00031	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __tls_index
  0003d	8b 7d 08	 mov	 edi, DWORD PTR _hwndDlg$[ebp]
  00040	8b 55 14	 mov	 edx, DWORD PTR _lParam$[ebp]
  00043	89 bd e4 f8 ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$[ebp], edi
  00049	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA
  00051	89 95 e8 f8 ff
	ff		 mov	 DWORD PTR _lParam$GSCopy$1$[ebp], edx
  00057	3b 81 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[ecx]
  0005d	7e 33		 jle	 SHORT $LN2@FavoriteVo
  0005f	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA
  00064	e8 00 00 00 00	 call	 __Init_thread_header
  00069	83 c4 04	 add	 esp, 4
  0006c	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA, -1
  00073	75 17		 jne	 SHORT $LN1812@FavoriteVo
  00075	68 00 00 00 00	 push	 OFFSET ??__FFavorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@YAXXZ ; `GostCrypt::FavoriteVolumesDlgProc'::`2'::`dynamic atexit destructor for 'Favorites''
  0007a	e8 00 00 00 00	 call	 _atexit
  0007f	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA
  00084	e8 00 00 00 00	 call	 __Init_thread_footer
  00089	83 c4 08	 add	 esp, 8
$LN1812@FavoriteVo:
  0008c	8b 95 e8 f8 ff
	ff		 mov	 edx, DWORD PTR _lParam$GSCopy$1$[ebp]
$LN2@FavoriteVo:

; 147  : 		static int SelectedItem;
; 148  : 		static HWND FavoriteListControl;
; 149  : 
; 150  : 		switch (msg)

  00092	8b 45 0c	 mov	 eax, DWORD PTR _msg$[ebp]
  00095	3d 10 01 00 00	 cmp	 eax, 272		; 00000110H
  0009a	0f 87 91 05 00
	00		 ja	 $LN72@FavoriteVo
  000a0	0f 84 57 01 00
	00		 je	 $LN19@FavoriteVo
  000a6	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a9	0f 84 b0 05 00
	00		 je	 $LN65@FavoriteVo
  000af	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  000b2	0f 85 2d 0c 00
	00		 jne	 $LN5@FavoriteVo

; 405  : 
; 406  : 		case WM_NOTIFY:
; 407  : 			if (((LPNMHDR) lParam)->code == LVN_ITEMCHANGED)

  000b8	83 7a 08 9b	 cmp	 DWORD PTR [edx+8], -101	; ffffff9bH
  000bc	0f 85 23 0c 00
	00		 jne	 $LN5@FavoriteVo

; 408  : 			{
; 409  : 				static bool reentry = false;
; 410  : 				if (reentry)

  000c2	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?reentry@?FJ@??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA, 0
  000c9	0f 85 16 0c 00
	00		 jne	 $LN5@FavoriteVo

; 411  : 					break;
; 412  : 
; 413  : 				reentry = true;
; 414  : 
; 415  : 				if (SelectedItem != -1)

  000cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SelectedItem@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA
  000d5	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?reentry@?FJ@??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA, 1
  000dc	83 f9 ff	 cmp	 ecx, -1
  000df	74 37		 je	 SHORT $LN62@FavoriteVo

; 416  : 				{
; 417  : 					SetFavoriteVolume (hwndDlg, Favorites[SelectedItem], SystemFavoritesMode);

  000e1	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA
  000e8	50		 push	 eax
  000e9	6b c1 68	 imul	 eax, ecx, 104
  000ec	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  000f2	50		 push	 eax
  000f3	57		 push	 edi
  000f4	e8 00 00 00 00	 call	 ?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z ; GostCrypt::SetFavoriteVolume

; 418  : 					FillListControlSubItems (FavoriteListControl, SelectedItem, Favorites[SelectedItem]);

  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?SelectedItem@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA
  000ff	6b c1 68	 imul	 eax, ecx, 104
  00102	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00108	50		 push	 eax
  00109	51		 push	 ecx
  0010a	ff 35 00 00 00
	00		 push	 DWORD PTR ?FavoriteListControl@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4PAU3@A
  00110	e8 00 00 00 00	 call	 ?FillListControlSubItems@GostCrypt@@YAXPAUHWND__@@HABUFavoriteVolume@1@@Z ; GostCrypt::FillListControlSubItems
  00115	83 c4 18	 add	 esp, 24			; 00000018H
$LN62@FavoriteVo:

; 419  : 				}
; 420  : 
; 421  : 				SelectedItem = ListView_GetNextItem (GetDlgItem (hwndDlg, IDC_FAVORITE_VOLUMES_LIST), -1, LVIS_SELECTED);

  00118	6a 02		 push	 2
  0011a	6a ff		 push	 -1
  0011c	68 0c 10 00 00	 push	 4108			; 0000100cH
  00121	68 5c 04 00 00	 push	 1116			; 0000045cH
  00126	57		 push	 edi
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0012d	50		 push	 eax
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16
  00134	a3 00 00 00 00	 mov	 DWORD PTR ?SelectedItem@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA, eax

; 422  : 
; 423  : 				if (SelectedItem != -1)

  00139	83 f8 ff	 cmp	 eax, -1
  0013c	74 2e		 je	 SHORT $LN63@FavoriteVo

; 424  : 					SetControls (hwndDlg, Favorites[SelectedItem], SystemFavoritesMode);

  0013e	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA
  00145	6b c0 68	 imul	 eax, eax, 104
  00148	6a 01		 push	 1
  0014a	51		 push	 ecx
  0014b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00151	50		 push	 eax
  00152	57		 push	 edi
  00153	e8 00 00 00 00	 call	 ?SetControls@GostCrypt@@YAXPAUHWND__@@ABUFavoriteVolume@1@_N2@Z ; GostCrypt::SetControls
  00158	83 c4 10	 add	 esp, 16			; 00000010H

; 427  : 
; 428  : 				reentry = false;

  0015b	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?reentry@?FJ@??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA, 0
  00162	b8 01 00 00 00	 mov	 eax, 1
  00167	e9 7b 0b 00 00	 jmp	 $LN1@FavoriteVo
$LN63@FavoriteVo:

; 425  : 				else
; 426  : 					SetControls (hwndDlg, FavoriteVolume(), SystemFavoritesMode, false);

  0016c	33 c0		 xor	 eax, eax
  0016e	c7 85 78 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+20], 15 ; 0000000fH
  00178	50		 push	 eax
  00179	66 89 45 ac	 mov	 WORD PTR $T17[ebp+72], ax
  0017d	89 45 c4	 mov	 DWORD PTR $T17[ebp+96], eax
  00180	89 45 c8	 mov	 DWORD PTR $T17[ebp+100], eax
  00183	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA
  0018a	50		 push	 eax
  0018b	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  00191	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+16], 0
  0019b	50		 push	 eax
  0019c	57		 push	 edi
  0019d	c6 85 64 ff ff
	ff 00		 mov	 BYTE PTR $T17[ebp], 0
  001a4	c7 45 90 0f 00
	00 00		 mov	 DWORD PTR $T17[ebp+44], 15 ; 0000000fH
  001ab	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+40], 0
  001b2	c6 85 7c ff ff
	ff 00		 mov	 BYTE PTR $T17[ebp+24], 0
  001b9	c7 45 a8 0f 00
	00 00		 mov	 DWORD PTR $T17[ebp+68], 15 ; 0000000fH
  001c0	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+64], 0
  001c7	c6 45 94 00	 mov	 BYTE PTR $T17[ebp+48], 0
  001cb	c7 45 c0 07 00
	00 00		 mov	 DWORD PTR $T17[ebp+92], 7
  001d2	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+88], 0
  001d9	e8 00 00 00 00	 call	 ?SetControls@GostCrypt@@YAXPAUHWND__@@ABUFavoriteVolume@1@_N2@Z ; GostCrypt::SetControls
  001de	83 c4 10	 add	 esp, 16			; 00000010H
  001e1	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  001e7	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ

; 427  : 
; 428  : 				reentry = false;

  001ec	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?reentry@?FJ@??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA, 0
  001f3	b8 01 00 00 00	 mov	 eax, 1
  001f8	e9 ea 0a 00 00	 jmp	 $LN1@FavoriteVo
$LN19@FavoriteVo:

; 151  : 		{
; 152  : 		case WM_INITDIALOG:
; 153  : 			{
; 154  : 				try
; 155  : 				{
; 156  : 					FavoriteListControl = GetDlgItem (hwndDlg, IDC_FAVORITE_VOLUMES_LIST);

  001fd	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  00203	68 5c 04 00 00	 push	 1116			; 0000045cH
  00208	57		 push	 edi
  00209	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00210	ff d6		 call	 esi
  00212	a3 00 00 00 00	 mov	 DWORD PTR ?FavoriteListControl@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4PAU3@A, eax

; 157  : 
; 158  : 					FavoriteVolumesDlgProcArguments *args = (FavoriteVolumesDlgProcArguments *) lParam;
; 159  : 					SystemFavoritesMode = args->SystemFavorites;
; 160  : 
; 161  : 					LocalizeDialog (hwndDlg, SystemFavoritesMode ? "SYSTEM_FAVORITES_DLG_TITLE" : "IDD_FAVORITE_VOLUMES");

  00217	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BF@HCOFEODH@IDD_FAVORITE_VOLUMES?$AA@
  0021c	8b 85 e8 f8 ff
	ff		 mov	 eax, DWORD PTR _lParam$GSCopy$1$[ebp]
  00222	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BL@JDDKFBO@SYSTEM_FAVORITES_DLG_TITLE?$AA@
  00227	8a 00		 mov	 al, BYTE PTR [eax]
  00229	84 c0		 test	 al, al
  0022b	a2 00 00 00 00	 mov	 BYTE PTR ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA, al
  00230	0f 44 ca	 cmove	 ecx, edx
  00233	51		 push	 ecx
  00234	57		 push	 edi
  00235	e8 00 00 00 00	 call	 _LocalizeDialog
  0023a	83 c4 08	 add	 esp, 8

; 162  : 
; 163  : 					if (SystemFavoritesMode)

  0023d	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA, 0
  00244	0f 84 3d 01 00
	00		 je	 $LN21@FavoriteVo

; 164  : 					{
; 165  : 						RECT rec;
; 166  : 
; 167  : 						BootEncryptionStatus bootEncStatus = BootEncryption (hwndDlg).GetStatus();

  0024a	57		 push	 edi
  0024b	8d 8d ec f8 ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00251	e8 00 00 00 00	 call	 ??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z ; GostCrypt::BootEncryption::BootEncryption
  00256	8d 8d b4 fe ff
	ff		 lea	 ecx, DWORD PTR _bootEncStatus$8[ebp]
  0025c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00260	51		 push	 ecx
  00261	8b c8		 mov	 ecx, eax
  00263	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  00268	8d 8d ec f8 ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0026e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00272	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption

; 168  : 
; 169  : 						if (!bootEncStatus.DriveMounted)

  00277	83 bd ba fe ff
	ff 00		 cmp	 DWORD PTR _bootEncStatus$8[ebp+6], 0
  0027e	75 42		 jne	 SHORT $LN23@FavoriteVo

; 170  : 							throw ErrorException ("SYS_FAVORITES_REQUIRE_PBA");

  00280	33 c0		 xor	 eax, eax
  00282	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp], OFFSET ??_7ErrorException@GostCrypt@@6B@
  0028c	66 89 85 34 ff
	ff ff		 mov	 WORD PTR $T13[ebp+8], ax
  00293	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  00299	68 00 00 00 00	 push	 OFFSET __TI2?AUErrorException@GostCrypt@@
  0029e	50		 push	 eax
  0029f	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp+4], OFFSET ??_C@_0BK@ELJEKFFN@SYS_FAVORITES_REQUIRE_PBA?$AA@
  002a9	c7 85 48 ff ff
	ff 07 00 00 00	 mov	 DWORD PTR $T13[ebp+28], 7
  002b3	c7 85 44 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp+24], 0
  002bd	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1817@FavoriteVo:
$LN23@FavoriteVo:

; 171  : 
; 172  : 						ShowWindow (GetDlgItem(hwndDlg, IDC_FAVORITE_MOUNT_ON_LOGON), SW_HIDE);

  002c2	6a 00		 push	 0
  002c4	68 62 04 00 00	 push	 1122			; 00000462H
  002c9	57		 push	 edi
  002ca	ff d6		 call	 esi
  002cc	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ShowWindow@8
  002d2	50		 push	 eax
  002d3	ff d6		 call	 esi

; 173  : 						ShowWindow (GetDlgItem(hwndDlg, IDC_FAVORITE_MOUNT_ON_ARRIVAL), SW_HIDE);

  002d5	6a 00		 push	 0
  002d7	68 5f 04 00 00	 push	 1119			; 0000045fH
  002dc	57		 push	 edi
  002dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  002e3	50		 push	 eax
  002e4	ff d6		 call	 esi

; 174  : 
; 175  : 						// MOUNT_SYSTEM_FAVORITES_ON_BOOT
; 176  : 
; 177  : 						SetWindowTextW (GetDlgItem (hwndDlg, IDC_FAVORITE_OPEN_EXPLORER_WIN_ON_MOUNT), GetString ("MOUNT_SYSTEM_FAVORITES_ON_BOOT"));

  002e6	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EKHONFKP@MOUNT_SYSTEM_FAVORITES_ON_BOOT?$AA@
  002eb	e8 00 00 00 00	 call	 _GetString
  002f0	83 c4 04	 add	 esp, 4
  002f3	50		 push	 eax
  002f4	68 68 04 00 00	 push	 1128			; 00000468H
  002f9	57		 push	 edi
  002fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00300	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetWindowTextW@8
  00306	50		 push	 eax
  00307	ff d6		 call	 esi

; 178  : 						
; 179  : 						// DISABLE_NONADMIN_SYS_FAVORITES_ACCESS
; 180  : 
; 181  : 						SetWindowTextW (GetDlgItem (hwndDlg, IDC_FAVORITE_DISABLE_HOTKEY), GetString ("DISABLE_NONADMIN_SYS_FAVORITES_ACCESS"));

  00309	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OLJJJKLA@DISABLE_NONADMIN_SYS_FAVORITES_A@
  0030e	e8 00 00 00 00	 call	 _GetString
  00313	83 c4 04	 add	 esp, 4
  00316	50		 push	 eax
  00317	68 63 04 00 00	 push	 1123			; 00000463H
  0031c	57		 push	 edi
  0031d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00323	50		 push	 eax
  00324	ff d6		 call	 esi

; 182  : 
; 183  : 						// Group box
; 184  : 
; 185  : 						GetClientRect (GetDlgItem (hwndDlg, IDC_FAV_VOL_OPTIONS_GROUP_BOX), &rec);		

  00326	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDlgItem@8
  0032c	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _rec$16[ebp]
  00332	50		 push	 eax
  00333	68 6e 04 00 00	 push	 1134			; 0000046eH
  00338	57		 push	 edi
  00339	ff d6		 call	 esi
  0033b	50		 push	 eax
  0033c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 186  : 
; 187  : 						SetWindowPos (GetDlgItem (hwndDlg, IDC_FAV_VOL_OPTIONS_GROUP_BOX), 0, 0, 0,

  00342	6a 06		 push	 6
  00344	6a 5a		 push	 90			; 0000005aH
  00346	e8 00 00 00 00	 call	 _CompensateYDPI
  0034b	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _rec$16[ebp+12]
  00351	83 c4 04	 add	 esp, 4
  00354	2b c8		 sub	 ecx, eax
  00356	51		 push	 ecx
  00357	ff b5 5c ff ff
	ff		 push	 DWORD PTR _rec$16[ebp+8]
  0035d	6a 00		 push	 0
  0035f	6a 00		 push	 0
  00361	6a 00		 push	 0
  00363	68 6e 04 00 00	 push	 1134			; 0000046eH
  00368	57		 push	 edi
  00369	ff d6		 call	 esi
  0036b	50		 push	 eax
  0036c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28

; 188  : 							rec.right,
; 189  : 							rec.bottom - CompensateYDPI (90),
; 190  : 							SWP_NOMOVE | SWP_NOZORDER);
; 191  : 
; 192  : 						InvalidateRect (GetDlgItem (hwndDlg, IDC_FAV_VOL_OPTIONS_GROUP_BOX), NULL, TRUE);

  00372	6a 01		 push	 1
  00374	6a 00		 push	 0
  00376	68 6e 04 00 00	 push	 1134			; 0000046eH
  0037b	57		 push	 edi
  0037c	ff d6		 call	 esi
  0037e	50		 push	 eax
  0037f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12

; 193  : 					}
; 194  : 					else

  00385	eb 11		 jmp	 SHORT $LN22@FavoriteVo
$LN21@FavoriteVo:

; 195  : 					{
; 196  : 						ShowWindow (GetDlgItem(hwndDlg, IDC_FAV_VOL_OPTIONS_GLOBAL_SETTINGS_BOX), SW_HIDE);

  00387	6a 00		 push	 0
  00389	68 70 04 00 00	 push	 1136			; 00000470H
  0038e	57		 push	 edi
  0038f	ff d6		 call	 esi
  00391	50		 push	 eax
  00392	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$LN22@FavoriteVo:

; 197  : 					}
; 198  : 
; 199  : 					Favorites.clear();

  00398	b9 00 00 00 00	 mov	 ecx, OFFSET ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  0039d	e8 00 00 00 00	 call	 ?clear@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXXZ ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::clear

; 200  : 
; 201  : 					LVCOLUMNW column;
; 202  : 					SendMessageW (FavoriteListControl, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT); 

  003a2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageW@16
  003a8	6a 20		 push	 32			; 00000020H
  003aa	6a 00		 push	 0
  003ac	68 36 10 00 00	 push	 4150			; 00001036H
  003b1	ff 35 00 00 00
	00		 push	 DWORD PTR ?FavoriteListControl@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4PAU3@A
  003b7	ff d6		 call	 esi
  003b9	0f 57 c0	 xorps	 xmm0, xmm0

; 203  : 
; 204  : 					memset (&column, 0, sizeof (column));

  003bc	0f 11 45 cc	 movups	 XMMWORD PTR _column$21[ebp], xmm0

; 205  : 					column.mask = LVCF_TEXT|LVCF_WIDTH|LVCF_SUBITEM|LVCF_FMT;
; 206  : 					column.pszText = GetString ("DRIVE");

  003c0	68 00 00 00 00	 push	 OFFSET ??_C@_05JLAEHEHI@DRIVE?$AA@
  003c5	0f 11 45 dc	 movups	 XMMWORD PTR _column$21[ebp+16], xmm0
  003c9	c7 45 cc 0f 00
	00 00		 mov	 DWORD PTR _column$21[ebp], 15 ; 0000000fH
  003d0	e8 00 00 00 00	 call	 _GetString

; 207  : 					column.cx = CompensateXDPI (38);

  003d5	6a 26		 push	 38			; 00000026H
  003d7	89 45 d8	 mov	 DWORD PTR _column$21[ebp+12], eax
  003da	e8 00 00 00 00	 call	 _CompensateXDPI
  003df	83 c4 08	 add	 esp, 8
  003e2	89 45 d4	 mov	 DWORD PTR _column$21[ebp+8], eax

; 208  : 					column.fmt = LVCFMT_CENTER;
; 209  : 					SendMessageW (FavoriteListControl, LVM_INSERTCOLUMNW, 1, (LPARAM) &column);

  003e5	8d 45 cc	 lea	 eax, DWORD PTR _column$21[ebp]
  003e8	c7 45 d0 02 00
	00 00		 mov	 DWORD PTR _column$21[ebp+4], 2
  003ef	50		 push	 eax
  003f0	6a 01		 push	 1
  003f2	68 61 10 00 00	 push	 4193			; 00001061H
  003f7	ff 35 00 00 00
	00		 push	 DWORD PTR ?FavoriteListControl@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4PAU3@A
  003fd	ff d6		 call	 esi

; 210  : 
; 211  : 					++column.iSubItem;

  003ff	ff 45 e0	 inc	 DWORD PTR _column$21[ebp+20]

; 212  : 					column.fmt = LVCFMT_LEFT;
; 213  : 					column.pszText = GetString ("LABEL");

  00402	68 00 00 00 00	 push	 OFFSET ??_C@_05EILEDKCG@LABEL?$AA@
  00407	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _column$21[ebp+4], 0
  0040e	e8 00 00 00 00	 call	 _GetString

; 214  : 					column.cx = CompensateXDPI (160);

  00413	68 a0 00 00 00	 push	 160			; 000000a0H
  00418	89 45 d8	 mov	 DWORD PTR _column$21[ebp+12], eax
  0041b	e8 00 00 00 00	 call	 _CompensateXDPI
  00420	83 c4 08	 add	 esp, 8
  00423	89 45 d4	 mov	 DWORD PTR _column$21[ebp+8], eax

; 215  : 					SendMessageW (FavoriteListControl, LVM_INSERTCOLUMNW, 2, (LPARAM) &column);

  00426	8d 45 cc	 lea	 eax, DWORD PTR _column$21[ebp]
  00429	50		 push	 eax
  0042a	6a 02		 push	 2
  0042c	68 61 10 00 00	 push	 4193			; 00001061H
  00431	ff 35 00 00 00
	00		 push	 DWORD PTR ?FavoriteListControl@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4PAU3@A
  00437	ff d6		 call	 esi

; 216  : 
; 217  : 					++column.iSubItem;

  00439	ff 45 e0	 inc	 DWORD PTR _column$21[ebp+20]

; 218  : 					column.fmt = LVCFMT_LEFT;
; 219  : 					column.pszText = GetString ("VOLUME");

  0043c	68 00 00 00 00	 push	 OFFSET ??_C@_06EIAEKLLO@VOLUME?$AA@
  00441	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _column$21[ebp+4], 0
  00448	e8 00 00 00 00	 call	 _GetString

; 220  : 					column.cx = CompensateXDPI (330);

  0044d	68 4a 01 00 00	 push	 330			; 0000014aH
  00452	89 45 d8	 mov	 DWORD PTR _column$21[ebp+12], eax
  00455	e8 00 00 00 00	 call	 _CompensateXDPI
  0045a	83 c4 08	 add	 esp, 8
  0045d	89 45 d4	 mov	 DWORD PTR _column$21[ebp+8], eax

; 221  : 					SendMessageW (FavoriteListControl, LVM_INSERTCOLUMNW, 3, (LPARAM) &column);

  00460	8d 45 cc	 lea	 eax, DWORD PTR _column$21[ebp]
  00463	50		 push	 eax
  00464	6a 03		 push	 3
  00466	68 61 10 00 00	 push	 4193			; 00001061H
  0046b	ff 35 00 00 00
	00		 push	 DWORD PTR ?FavoriteListControl@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4PAU3@A
  00471	ff d6		 call	 esi

; 222  : 
; 223  : 					SetControls (hwndDlg, FavoriteVolume(), SystemFavoritesMode, false);

  00473	33 c0		 xor	 eax, eax
  00475	c7 85 78 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T20[ebp+20], 15 ; 0000000fH
  0047f	50		 push	 eax
  00480	66 89 45 ac	 mov	 WORD PTR $T20[ebp+72], ax
  00484	89 45 c4	 mov	 DWORD PTR $T20[ebp+96], eax
  00487	89 45 c8	 mov	 DWORD PTR $T20[ebp+100], eax
  0048a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA
  00491	50		 push	 eax
  00492	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR $T20[ebp]
  00498	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+16], 0
  004a2	50		 push	 eax
  004a3	57		 push	 edi
  004a4	c6 85 64 ff ff
	ff 00		 mov	 BYTE PTR $T20[ebp], 0
  004ab	c7 45 90 0f 00
	00 00		 mov	 DWORD PTR $T20[ebp+44], 15 ; 0000000fH
  004b2	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR $T20[ebp+40], 0
  004b9	c6 85 7c ff ff
	ff 00		 mov	 BYTE PTR $T20[ebp+24], 0
  004c0	c7 45 a8 0f 00
	00 00		 mov	 DWORD PTR $T20[ebp+68], 15 ; 0000000fH
  004c7	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR $T20[ebp+64], 0
  004ce	c6 45 94 00	 mov	 BYTE PTR $T20[ebp+48], 0
  004d2	c7 45 c0 07 00
	00 00		 mov	 DWORD PTR $T20[ebp+92], 7
  004d9	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T20[ebp+88], 0
  004e0	e8 00 00 00 00	 call	 ?SetControls@GostCrypt@@YAXPAUHWND__@@ABUFavoriteVolume@1@_N2@Z ; GostCrypt::SetControls
  004e5	83 c4 10	 add	 esp, 16			; 00000010H
  004e8	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  004ee	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ

; 224  : 
; 225  : 					if (SystemFavoritesMode)

  004f3	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA, 0
  004fa	74 13		 je	 SHORT $LN24@FavoriteVo

; 226  : 						LoadFavoriteVolumes (Favorites, true);

  004fc	6a 00		 push	 0
  004fe	6a 01		 push	 1
  00500	68 00 00 00 00	 push	 OFFSET ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00505	e8 00 00 00 00	 call	 ?LoadFavoriteVolumes@GostCrypt@@YAXAAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N1@Z ; GostCrypt::LoadFavoriteVolumes
  0050a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 227  : 					else

  0050d	eb 0f		 jmp	 SHORT $LN25@FavoriteVo
$LN24@FavoriteVo:

; 228  : 						Favorites = FavoriteVolumes;

  0050f	68 00 00 00 00	 push	 OFFSET ?FavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoriteVolumes
  00514	b9 00 00 00 00	 mov	 ecx, OFFSET ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00519	e8 00 00 00 00	 call	 ??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::operator=
$LN25@FavoriteVo:

; 229  : 
; 230  : 					if (args->AddFavoriteVolume)

  0051e	8b b5 e8 f8 ff
	ff		 mov	 esi, DWORD PTR _lParam$GSCopy$1$[ebp]
  00524	80 7e 01 00	 cmp	 BYTE PTR [esi+1], 0
  00528	74 0e		 je	 SHORT $LN26@FavoriteVo

; 231  : 						Favorites.push_back (args->NewFavoriteVolume);

  0052a	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0052d	b9 00 00 00 00	 mov	 ecx, OFFSET ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00532	50		 push	 eax
  00533	e8 00 00 00 00	 call	 ?push_back@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEXABUFavoriteVolume@GostCrypt@@@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::push_back
$LN26@FavoriteVo:

; 232  : 
; 233  : 					FillListControl (FavoriteListControl, Favorites);

  00538	68 00 00 00 00	 push	 OFFSET ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  0053d	ff 35 00 00 00
	00		 push	 DWORD PTR ?FavoriteListControl@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4PAU3@A
  00543	e8 00 00 00 00	 call	 ?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ; GostCrypt::FillListControl
  00548	83 c4 08	 add	 esp, 8

; 234  : 
; 235  : 					SelectedItem = -1;

  0054b	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?SelectedItem@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA, -1

; 236  : 
; 237  : 					if (args->AddFavoriteVolume)

  00555	80 7e 01 00	 cmp	 BYTE PTR [esi+1], 0
  00559	74 7b		 je	 SHORT $LN27@FavoriteVo

; 238  : 					{
; 239  : 						ListView_SetItemState (FavoriteListControl, Favorites.size() - 1, LVIS_SELECTED, LVIS_SELECTED);

  0055b	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+4
  00561	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR __macro_lvi$10[ebp]
  00567	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  0056d	50		 push	 eax
  0056e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  00574	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00579	f7 e9		 imul	 ecx
  0057b	c7 85 ec fe ff
	ff 02 00 00 00	 mov	 DWORD PTR __macro_lvi$10[ebp+16], 2
  00585	c1 fa 05	 sar	 edx, 5
  00588	8b c2		 mov	 eax, edx
  0058a	c7 85 e8 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR __macro_lvi$10[ebp+12], 2
  00594	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00597	4a		 dec	 edx
  00598	03 c2		 add	 eax, edx
  0059a	50		 push	 eax
  0059b	68 2b 10 00 00	 push	 4139			; 0000102bH
  005a0	ff 35 00 00 00
	00		 push	 DWORD PTR ?FavoriteListControl@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4PAU3@A
  005a6	ff d6		 call	 esi

; 240  : 						ListView_EnsureVisible (FavoriteListControl, Favorites.size() - 1, FALSE);

  005a8	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+4
  005ae	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  005b3	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  005b9	f7 e9		 imul	 ecx
  005bb	6a 00		 push	 0
  005bd	c1 fa 05	 sar	 edx, 5
  005c0	8b c2		 mov	 eax, edx
  005c2	4a		 dec	 edx
  005c3	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  005c6	03 c2		 add	 eax, edx
  005c8	50		 push	 eax
  005c9	68 13 10 00 00	 push	 4115			; 00001013H
  005ce	ff 35 00 00 00
	00		 push	 DWORD PTR ?FavoriteListControl@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4PAU3@A
  005d4	ff d6		 call	 esi
$LN27@FavoriteVo:

; 241  : 					}
; 242  : 
; 243  : 					if (SystemFavoritesMode)

  005d6	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA, 0
  005dd	74 1a		 je	 SHORT $LN28@FavoriteVo

; 244  : 						SetDlgItemTextW (hwndDlg, IDC_FAVORITES_HELP_LINK, GetString ("SYS_FAVORITES_HELP_LINK"));

  005df	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CHIEPLIO@SYS_FAVORITES_HELP_LINK?$AA@
  005e4	e8 00 00 00 00	 call	 _GetString
  005e9	83 c4 04	 add	 esp, 4
  005ec	50		 push	 eax
  005ed	68 6f 04 00 00	 push	 1135			; 0000046fH
  005f2	57		 push	 edi
  005f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetDlgItemTextW@12
$LN28@FavoriteVo:

; 245  : 
; 246  : 					ToHyperlink (hwndDlg, IDC_FAVORITES_HELP_LINK);

  005f9	68 6f 04 00 00	 push	 1135			; 0000046fH
  005fe	57		 push	 edi
  005ff	e8 00 00 00 00	 call	 _ToHyperlink
  00604	83 c4 08	 add	 esp, 8

; 329  : 				}
; 330  : 
; 331  : 				return 1;

  00607	b8 01 00 00 00	 mov	 eax, 1
  0060c	e9 d6 06 00 00	 jmp	 $LN1@FavoriteVo
__catch$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$0:

; 247  : 				}
; 248  : 				catch (Exception &e)
; 249  : 				{
; 250  : 					e.Show (hwndDlg);

  00611	8b 8d e0 f8 ff
	ff		 mov	 ecx, DWORD PTR _e$3[ebp]
  00617	8b b5 e4 f8 ff
	ff		 mov	 esi, DWORD PTR _hwndDlg$GSCopy$[ebp]
  0061d	56		 push	 esi
  0061e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00620	ff 10		 call	 DWORD PTR [eax]

; 251  : 					EndDialog (hwndDlg, IDCLOSE);

  00622	6a 08		 push	 8
  00624	56		 push	 esi
  00625	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8

; 252  : 				}

  0062b	b8 00 00 00 00	 mov	 eax, $LN92@FavoriteVo
  00630	c3		 ret	 0
$LN72@FavoriteVo:

; 147  : 		static int SelectedItem;
; 148  : 		static HWND FavoriteListControl;
; 149  : 
; 150  : 		switch (msg)

  00631	3d 11 01 00 00	 cmp	 eax, 273		; 00000111H
  00636	0f 85 a9 06 00
	00		 jne	 $LN5@FavoriteVo

; 253  : 			}
; 254  : 			return 1;
; 255  : 
; 256  : 		case WM_COMMAND:
; 257  : 
; 258  : 			switch (lw)

  0063c	0f b7 45 10	 movzx	 eax, WORD PTR _wParam$[ebp]
  00640	3d 63 04 00 00	 cmp	 eax, 1123		; 00000463H
  00645	0f 87 b8 03 00
	00		 ja	 $LN71@FavoriteVo
  0064b	0f 84 f5 02 00
	00		 je	 $LN54@FavoriteVo
  00651	83 e8 01	 sub	 eax, 1
  00654	74 1c		 je	 SHORT $LN30@FavoriteVo
  00656	83 e8 01	 sub	 eax, 1
  00659	0f 85 86 06 00
	00		 jne	 $LN5@FavoriteVo
$LN65@FavoriteVo:

; 332  : 
; 333  : 			case IDCANCEL:
; 334  : 				EndDialog (hwndDlg, IDCLOSE);

  0065f	6a 08		 push	 8
  00661	57		 push	 edi
  00662	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8

; 335  : 				return 1;

  00668	b8 01 00 00 00	 mov	 eax, 1
  0066d	e9 75 06 00 00	 jmp	 $LN1@FavoriteVo
$LN30@FavoriteVo:

; 259  : 			{
; 260  : 			case IDOK:
; 261  : 
; 262  : 				/* Global System Favorites settings */
; 263  : 
; 264  : 				if (SystemFavoritesMode)

  00672	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA
  00678	84 c9		 test	 cl, cl
  0067a	0f 84 af 00 00
	00		 je	 $LN31@FavoriteVo

; 265  : 				{
; 266  : 					BootEncryption BootEncObj (NULL);

  00680	6a 00		 push	 0
  00682	8d 8d ec f8 ff
	ff		 lea	 ecx, DWORD PTR _BootEncObj$5[ebp]
  00688	e8 00 00 00 00	 call	 ??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z ; GostCrypt::BootEncryption::BootEncryption

; 267  : 
; 268  : 					if (BootEncObj.GetStatus().DriveMounted)

  0068d	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00693	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  0069a	50		 push	 eax
  0069b	8d 8d ec f8 ff
	ff		 lea	 ecx, DWORD PTR _BootEncObj$5[ebp]
  006a1	e8 00 00 00 00	 call	 ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
  006a6	83 78 06 00	 cmp	 DWORD PTR [eax+6], 0
  006aa	74 6b		 je	 SHORT $LN94@FavoriteVo

; 269  : 					{
; 270  : 						try
; 271  : 						{
; 272  : 							uint32 reqConfig = IsDlgButtonChecked (hwndDlg, IDC_FAVORITE_OPEN_EXPLORER_WIN_ON_MOUNT) ? GST_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES : 0;

  006ac	68 68 04 00 00	 push	 1128			; 00000468H
  006b1	57		 push	 edi
  006b2	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  006b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDlgButtonChecked@8
  006bc	f7 d8		 neg	 eax
  006be	1b f6		 sbb	 esi, esi
  006c0	83 e6 02	 and	 esi, 2

; 273  : 							if (reqConfig != (ReadDriverConfigurationFlags() & GST_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES))

  006c3	e8 00 00 00 00	 call	 _ReadDriverConfigurationFlags
  006c8	83 e0 02	 and	 eax, 2
  006cb	3b f0		 cmp	 esi, eax
  006cd	74 13		 je	 SHORT $LN34@FavoriteVo

; 274  : 								BootEncObj.RegisterSystemFavoritesService (reqConfig ? TRUE : FALSE);

  006cf	33 c0		 xor	 eax, eax
  006d1	8d 8d ec f8 ff
	ff		 lea	 ecx, DWORD PTR _BootEncObj$5[ebp]
  006d7	85 f6		 test	 esi, esi
  006d9	0f 95 c0	 setne	 al
  006dc	50		 push	 eax
  006dd	e8 00 00 00 00	 call	 ?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z ; GostCrypt::BootEncryption::RegisterSystemFavoritesService
$LN34@FavoriteVo:

; 275  : 
; 276  : 							SetDriverConfigurationFlag (GST_DRIVER_CONFIG_DISABLE_NONADMIN_SYS_FAVORITES_ACCESS, IsDlgButtonChecked (hwndDlg, IDC_FAVORITE_DISABLE_HOTKEY));

  006e2	68 63 04 00 00	 push	 1123			; 00000463H
  006e7	57		 push	 edi
  006e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDlgButtonChecked@8
  006ee	50		 push	 eax
  006ef	6a 04		 push	 4
  006f1	e8 00 00 00 00	 call	 ?SetDriverConfigurationFlag@@YAXIH@Z ; SetDriverConfigurationFlag
  006f6	83 c4 08	 add	 esp, 8
  006f9	eb 1c		 jmp	 SHORT $LN94@FavoriteVo
__catch$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$2:

; 277  : 						}
; 278  : 						catch (Exception &e)
; 279  : 						{
; 280  : 							e.Show (hwndDlg);

  006fb	8b 8d dc f8 ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  00701	ff b5 e4 f8 ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$[ebp]
  00707	8b 01		 mov	 eax, DWORD PTR [ecx]
  00709	ff 10		 call	 DWORD PTR [eax]

; 281  : 						}

  0070b	b8 00 00 00 00	 mov	 eax, $LN1811@FavoriteVo
  00710	c3		 ret	 0
$LN1811@FavoriteVo:
  00711	8b bd e4 f8 ff
	ff		 mov	 edi, DWORD PTR _hwndDlg$GSCopy$[ebp]
$LN94@FavoriteVo:

; 282  : 					}
; 283  : 				}

  00717	8d 8d ec f8 ff
	ff		 lea	 ecx, DWORD PTR _BootEncObj$5[ebp]
  0071d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00724	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
  00729	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA
$LN31@FavoriteVo:

; 284  : 
; 285  : 				/* (System) Favorites list */
; 286  : 
; 287  : 				if (SelectedItem != -1 && !Favorites.empty())

  0072f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?SelectedItem@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA
  00735	83 fa ff	 cmp	 edx, -1
  00738	74 2c		 je	 SHORT $LN35@FavoriteVo
  0073a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00740	3b 35 04 00 00
	00		 cmp	 esi, DWORD PTR ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+4
  00746	0f 94 c0	 sete	 al
  00749	84 c0		 test	 al, al
  0074b	75 19		 jne	 SHORT $LN35@FavoriteVo

; 288  : 					SetFavoriteVolume (hwndDlg, Favorites[SelectedItem], SystemFavoritesMode);

  0074d	0f b6 c1	 movzx	 eax, cl
  00750	50		 push	 eax
  00751	6b c2 68	 imul	 eax, edx, 104
  00754	03 c6		 add	 eax, esi
  00756	50		 push	 eax
  00757	57		 push	 edi
  00758	e8 00 00 00 00	 call	 ?SetFavoriteVolume@GostCrypt@@YAXPAUHWND__@@AAUFavoriteVolume@1@_N@Z ; GostCrypt::SetFavoriteVolume
  0075d	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA
  00763	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN35@FavoriteVo:

; 289  : 
; 290  : 				if (SaveFavoriteVolumes (Favorites, SystemFavoritesMode))

  00766	0f b6 c1	 movzx	 eax, cl
  00769	50		 push	 eax
  0076a	68 00 00 00 00	 push	 OFFSET ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  0076f	e8 00 00 00 00	 call	 ?SaveFavoriteVolumes@GostCrypt@@YA_NABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@_N@Z ; GostCrypt::SaveFavoriteVolumes
  00774	83 c4 08	 add	 esp, 8
  00777	84 c0		 test	 al, al
  00779	0f 84 bd 01 00
	00		 je	 $LN92@FavoriteVo

; 291  : 				{
; 292  : 					if (!SystemFavoritesMode)

  0077f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA, 0

; 293  : 					{
; 294  : 						bMountFavoritesOnLogon = FALSE;
; 295  : 
; 296  : 						foreach (const FavoriteVolume &favorite, Favorites)

  00786	68 00 00 00 00	 push	 OFFSET ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  0078b	0f 85 77 01 00
	00		 jne	 $LN37@FavoriteVo
  00791	8d 45 d0	 lea	 eax, DWORD PTR _$S1$23[ebp]
  00794	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _bMountFavoritesOnLogon, 0
  0079e	50		 push	 eax
  0079f	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
  007a4	83 c4 08	 add	 esp, 8
  007a7	8b 45 d0	 mov	 eax, DWORD PTR _$S1$23[ebp]
  007aa	8d 4d d0	 lea	 ecx, DWORD PTR _$S1$23[ebp]
  007ad	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 6
  007b4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  007b7	ff d0		 call	 eax
  007b9	84 c0		 test	 al, al
  007bb	74 53		 je	 SHORT $LN8@FavoriteVo
  007bd	0f 1f 00	 npad	 3
$LL9@FavoriteVo:
  007c0	33 c9		 xor	 ecx, ecx
  007c2	38 4d d5	 cmp	 BYTE PTR _$S1$23[ebp+5], cl
  007c5	0f 94 c1	 sete	 cl
  007c8	88 4d d5	 mov	 BYTE PTR _$S1$23[ebp+5], cl
  007cb	84 c9		 test	 cl, cl
  007cd	74 29		 je	 SHORT $LN7@FavoriteVo
  007cf	8b 55 e8	 mov	 edx, DWORD PTR _$S1$23[ebp+24]
$LL12@FavoriteVo:

; 297  : 						{
; 298  : 							if (favorite.MountOnLogOn)

  007d2	80 7a 62 00	 cmp	 BYTE PTR [edx+98], 0
  007d6	75 16		 jne	 SHORT $LN1796@FavoriteVo

; 293  : 					{
; 294  : 						bMountFavoritesOnLogon = FALSE;
; 295  : 
; 296  : 						foreach (const FavoriteVolume &favorite, Favorites)

  007d8	33 c0		 xor	 eax, eax
  007da	c6 45 d4 01	 mov	 BYTE PTR _$S1$23[ebp+4], 1
  007de	84 c9		 test	 cl, cl
  007e0	0f 94 c0	 sete	 al
  007e3	8a c8		 mov	 cl, al
  007e5	88 4d d5	 mov	 BYTE PTR _$S1$23[ebp+5], cl
  007e8	84 c0		 test	 al, al
  007ea	75 e6		 jne	 SHORT $LL12@FavoriteVo

; 308  : 							{
; 309  : 								if (favorite.MountOnArrival)

  007ec	eb 0a		 jmp	 SHORT $LN7@FavoriteVo
$LN1796@FavoriteVo:

; 299  : 							{
; 300  : 								bMountFavoritesOnLogon = TRUE;

  007ee	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _bMountFavoritesOnLogon, 1
$LN7@FavoriteVo:

; 293  : 					{
; 294  : 						bMountFavoritesOnLogon = FALSE;
; 295  : 
; 296  : 						foreach (const FavoriteVolume &favorite, Favorites)

  007f8	8b 45 d0	 mov	 eax, DWORD PTR _$S1$23[ebp]
  007fb	8d 4d d0	 lea	 ecx, DWORD PTR _$S1$23[ebp]
  007fe	ff 50 08	 call	 DWORD PTR [eax+8]
  00801	8b 45 d0	 mov	 eax, DWORD PTR _$S1$23[ebp]
  00804	8d 4d d0	 lea	 ecx, DWORD PTR _$S1$23[ebp]
  00807	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0080a	ff d0		 call	 eax
  0080c	84 c0		 test	 al, al
  0080e	75 b0		 jne	 SHORT $LL9@FavoriteVo
$LN8@FavoriteVo:

; 301  : 								break;
; 302  : 							}
; 303  : 						}

  00810	8d 4d d8	 lea	 ecx, DWORD PTR _$S1$23[ebp+8]
  00813	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0081a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Tidy

; 304  : 
; 305  : 						if (!bEnableBkgTask || bCloseBkgTaskWhenNoVolumes || IsNonInstallMode())

  0081f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bEnableBkgTask, 0
  00826	74 16		 je	 SHORT $LN41@FavoriteVo
  00828	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bCloseBkgTaskWhenNoVolumes, 0
  0082f	75 0d		 jne	 SHORT $LN41@FavoriteVo
  00831	e8 00 00 00 00	 call	 _IsNonInstallMode
  00836	85 c0		 test	 eax, eax
  00838	0f 84 ab 00 00
	00		 je	 $LN764@FavoriteVo
$LN41@FavoriteVo:

; 306  : 						{
; 307  : 							foreach (const FavoriteVolume favorite, Favorites)

  0083e	8d 45 d0	 lea	 eax, DWORD PTR _$S2$22[ebp]
  00841	68 00 00 00 00	 push	 OFFSET ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00846	50		 push	 eax
  00847	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@01@ABV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> > >
  0084c	83 c4 08	 add	 esp, 8
  0084f	8b 45 d0	 mov	 eax, DWORD PTR _$S2$22[ebp]
  00852	8d 4d d0	 lea	 ecx, DWORD PTR _$S2$22[ebp]
  00855	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 7
  0085c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0085f	ff d0		 call	 eax
  00861	84 c0		 test	 al, al
  00863	74 75		 je	 SHORT $LN14@FavoriteVo
  00865	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL15@FavoriteVo:
  00870	ff 75 e8	 push	 DWORD PTR _$S2$22[ebp+24]
  00873	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _favorite$19[ebp]
  00879	e8 00 00 00 00	 call	 ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
  0087e	33 c9		 xor	 ecx, ecx
  00880	38 4d d5	 cmp	 BYTE PTR _$S2$22[ebp+5], cl
  00883	0f 94 c1	 sete	 cl
  00886	88 4d d5	 mov	 BYTE PTR _$S2$22[ebp+5], cl
  00889	84 c9		 test	 cl, cl
  0088b	74 2a		 je	 SHORT $LN17@FavoriteVo
  0088d	8a 55 c7	 mov	 dl, BYTE PTR _favorite$19[ebp+99]
$LL18@FavoriteVo:

; 308  : 							{
; 309  : 								if (favorite.MountOnArrival)

  00890	84 d2		 test	 dl, dl
  00892	75 16		 jne	 SHORT $LN1797@FavoriteVo

; 306  : 						{
; 307  : 							foreach (const FavoriteVolume favorite, Favorites)

  00894	33 c0		 xor	 eax, eax
  00896	c6 45 d4 01	 mov	 BYTE PTR _$S2$22[ebp+4], 1
  0089a	84 c9		 test	 cl, cl
  0089c	0f 94 c0	 sete	 al
  0089f	8a c8		 mov	 cl, al
  008a1	88 4d d5	 mov	 BYTE PTR _$S2$22[ebp+5], cl
  008a4	84 c0		 test	 al, al
  008a6	75 e8		 jne	 SHORT $LL18@FavoriteVo

; 308  : 							{
; 309  : 								if (favorite.MountOnArrival)

  008a8	eb 0d		 jmp	 SHORT $LN17@FavoriteVo
$LN1797@FavoriteVo:

; 310  : 								{
; 311  : 									Warning ("FAVORITE_ARRIVAL_MOUNT_BACKGROUND_TASK_ERR");

  008aa	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@LJFCINAI@FAVORITE_ARRIVAL_MOUNT_BACKGROUN@
  008af	e8 00 00 00 00	 call	 _Warning
  008b4	83 c4 04	 add	 esp, 4
$LN17@FavoriteVo:

; 312  : 									break;
; 313  : 								}
; 314  : 							}

  008b7	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _favorite$19[ebp]
  008bd	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  008c2	8b 45 d0	 mov	 eax, DWORD PTR _$S2$22[ebp]
  008c5	8d 4d d0	 lea	 ecx, DWORD PTR _$S2$22[ebp]
  008c8	ff 50 08	 call	 DWORD PTR [eax+8]
  008cb	8b 45 d0	 mov	 eax, DWORD PTR _$S2$22[ebp]
  008ce	8d 4d d0	 lea	 ecx, DWORD PTR _$S2$22[ebp]
  008d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  008d4	ff d0		 call	 eax
  008d6	84 c0		 test	 al, al
  008d8	75 96		 jne	 SHORT $LL15@FavoriteVo
$LN14@FavoriteVo:
  008da	8d 4d d8	 lea	 ecx, DWORD PTR _$S2$22[ebp+8]
  008dd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  008e4	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@IAEXXZ ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::_Tidy
$LN764@FavoriteVo:

; 315  : 						}
; 316  : 
; 317  : 						FavoriteVolumes = Favorites;

  008e9	68 00 00 00 00	 push	 OFFSET ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  008ee	b9 00 00 00 00	 mov	 ecx, OFFSET ?FavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::FavoriteVolumes
  008f3	e8 00 00 00 00	 call	 ??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::operator=

; 318  : 
; 319  : 						ManageStartupSeq();

  008f8	e8 00 00 00 00	 call	 _ManageStartupSeq

; 320  : 						SaveSettings (hwndDlg);

  008fd	57		 push	 edi
  008fe	e8 00 00 00 00	 call	 _SaveSettings
  00903	83 c4 04	 add	 esp, 4

; 321  : 					}
; 322  : 					else

  00906	eb 0a		 jmp	 SHORT $LN38@FavoriteVo
$LN37@FavoriteVo:

; 323  : 						SystemFavoriteVolumes = Favorites;

  00908	b9 00 00 00 00	 mov	 ecx, OFFSET ?SystemFavoriteVolumes@GostCrypt@@3V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A ; GostCrypt::SystemFavoriteVolumes
  0090d	e8 00 00 00 00	 call	 ??4?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::operator=
$LN38@FavoriteVo:

; 324  : 
; 325  : 					OnFavoriteVolumesUpdated();

  00912	e8 00 00 00 00	 call	 ?OnFavoriteVolumesUpdated@GostCrypt@@YAXXZ ; GostCrypt::OnFavoriteVolumesUpdated

; 326  : 					LoadDriveLetters (GetDlgItem (MainDlg, IDC_DRIVELIST), 0);

  00917	6a 00		 push	 0
  00919	68 ef 03 00 00	 push	 1007			; 000003efH
  0091e	ff 35 00 00 00
	00		 push	 DWORD PTR _MainDlg
  00924	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0092a	50		 push	 eax
  0092b	e8 00 00 00 00	 call	 _LoadDriveLetters
  00930	83 c4 08	 add	 esp, 8

; 327  : 
; 328  : 					EndDialog (hwndDlg, IDOK);

  00933	6a 01		 push	 1
  00935	57		 push	 edi
  00936	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndDialog@8
$LN92@FavoriteVo:

; 329  : 				}
; 330  : 
; 331  : 				return 1;

  0093c	b8 01 00 00 00	 mov	 eax, 1
  00941	e9 a1 03 00 00	 jmp	 $LN1@FavoriteVo
$LN54@FavoriteVo:

; 383  : 					}
; 384  : 				}
; 385  : 				return 1;
; 386  : 
; 387  : 			case IDC_FAVORITE_DISABLE_HOTKEY: // Note that this option means "DISABLE_NONADMIN_SYS_FAVORITES_ACCESS" when SystemFavoritesMode is true
; 388  : 				if (SystemFavoritesMode)

  00946	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA, 0
  0094d	74 ed		 je	 SHORT $LN92@FavoriteVo

; 389  : 				{
; 390  : 					// DISABLE_NONADMIN_SYS_FAVORITES_ACCESS
; 391  : 
; 392  : 					if (IsDlgButtonChecked (hwndDlg, IDC_FAVORITE_DISABLE_HOTKEY))

  0094f	68 63 04 00 00	 push	 1123			; 00000463H
  00954	57		 push	 edi
  00955	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDlgButtonChecked@8
  0095b	85 c0		 test	 eax, eax
  0095d	0f 84 89 00 00
	00		 je	 $LN56@FavoriteVo

; 393  : 						WarningDirect ((wstring (GetString ("SYS_FAVORITES_ADMIN_ONLY_WARNING")) + L"\n\n" + GetString ("SETTING_REQUIRES_REBOOT")).c_str());

  00963	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@FJMJOJID@SYS_FAVORITES_ADMIN_ONLY_WARNING@
  00968	e8 00 00 00 00	 call	 _GetString
  0096d	83 c4 04	 add	 esp, 4
  00970	8d 4d d4	 lea	 ecx, DWORD PTR $T24[ebp]
  00973	50		 push	 eax
  00974	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00979	68 00 00 00 00	 push	 OFFSET ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  0097e	50		 push	 eax
  0097f	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  00985	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  0098c	50		 push	 eax
  0098d	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00992	8b f0		 mov	 esi, eax
  00994	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BHGNKFED@SETTING_REQUIRES_REBOOT?$AA@
  00999	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+12], 11 ; 0000000bH
  0099d	e8 00 00 00 00	 call	 _GetString
  009a2	50		 push	 eax
  009a3	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  009a9	56		 push	 esi
  009aa	50		 push	 eax
  009ab	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  009b0	83 c4 1c	 add	 esp, 28			; 0000001cH
  009b3	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  009b7	72 02		 jb	 SHORT $LN1324@FavoriteVo
  009b9	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1324@FavoriteVo:
  009bb	50		 push	 eax
  009bc	e8 00 00 00 00	 call	 _WarningDirect
  009c1	83 c4 04	 add	 esp, 4
  009c4	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  009ca	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  009cf	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  009d5	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  009da	8d 4d d4	 lea	 ecx, DWORD PTR $T24[ebp]
  009dd	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  009e2	b8 01 00 00 00	 mov	 eax, 1
  009e7	e9 fb 02 00 00	 jmp	 $LN1@FavoriteVo
$LN56@FavoriteVo:

; 394  : 					else
; 395  : 						Warning ("SETTING_REQUIRES_REBOOT");

  009ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BHGNKFED@SETTING_REQUIRES_REBOOT?$AA@
  009f1	e8 00 00 00 00	 call	 _Warning
  009f6	83 c4 04	 add	 esp, 4
  009f9	b8 01 00 00 00	 mov	 eax, 1
  009fe	e9 e4 02 00 00	 jmp	 $LN1@FavoriteVo
$LN71@FavoriteVo:

; 253  : 			}
; 254  : 			return 1;
; 255  : 
; 256  : 		case WM_COMMAND:
; 257  : 
; 258  : 			switch (lw)

  00a03	2d 64 04 00 00	 sub	 eax, 1124		; 00000464H
  00a08	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00a0b	0f 87 d4 02 00
	00		 ja	 $LN5@FavoriteVo
  00a11	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN1810@FavoriteVo[eax]
  00a18	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN1816@FavoriteVo[eax*4]
$LN44@FavoriteVo:

; 336  : 
; 337  : 			case IDC_FAVORITE_MOVE_DOWN:
; 338  : 				if (SelectedItem != -1 && Favorites.size() > (size_t) SelectedItem + 1)

  00a1f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?SelectedItem@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA
  00a25	83 fe ff	 cmp	 esi, -1
  00a28	0f 84 0e ff ff
	ff		 je	 $LN92@FavoriteVo
  00a2e	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A+4
  00a34	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00a39	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00a3f	2b cf		 sub	 ecx, edi
  00a41	f7 e9		 imul	 ecx
  00a43	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00a46	c1 fa 05	 sar	 edx, 5
  00a49	8b ca		 mov	 ecx, edx
  00a4b	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00a4e	03 ca		 add	 ecx, edx
  00a50	3b c8		 cmp	 ecx, eax
  00a52	0f 86 e4 fe ff
	ff		 jbe	 $LN92@FavoriteVo

; 339  : 				{
; 340  : 					swap (Favorites[SelectedItem], Favorites[SelectedItem + 1]);

  00a58	6b ce 68	 imul	 ecx, esi, 104
  00a5b	03 cf		 add	 ecx, edi
  00a5d	8d 41 68	 lea	 eax, DWORD PTR [ecx+104]
  00a60	50		 push	 eax
  00a61	51		 push	 ecx
  00a62	e8 00 00 00 00	 call	 ??$swap@UFavoriteVolume@GostCrypt@@X@std@@YAXAAUFavoriteVolume@GostCrypt@@0@Z ; std::swap<GostCrypt::FavoriteVolume,void>

; 341  : 
; 342  : 					FillListControl (FavoriteListControl, Favorites);

  00a67	68 00 00 00 00	 push	 OFFSET ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00a6c	ff 35 00 00 00
	00		 push	 DWORD PTR ?FavoriteListControl@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4PAU3@A
  00a72	e8 00 00 00 00	 call	 ?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ; GostCrypt::FillListControl

; 343  : 					++SelectedItem;

  00a77	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SelectedItem@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA
  00a7c	83 c4 10	 add	 esp, 16			; 00000010H
  00a7f	40		 inc	 eax
$LN1815@FavoriteVo:

; 344  : 					ListView_SetItemState (FavoriteListControl, SelectedItem, LVIS_SELECTED, LVIS_SELECTED);

  00a80	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SendMessageA@16
  00a86	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR __macro_lvi$9[ebp]
  00a8c	51		 push	 ecx
  00a8d	50		 push	 eax
  00a8e	68 2b 10 00 00	 push	 4139			; 0000102bH
  00a93	ff 35 00 00 00
	00		 push	 DWORD PTR ?FavoriteListControl@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4PAU3@A
  00a99	a3 00 00 00 00	 mov	 DWORD PTR ?SelectedItem@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA, eax
  00a9e	c7 85 ec fe ff
	ff 02 00 00 00	 mov	 DWORD PTR __macro_lvi$9[ebp+16], 2
  00aa8	c7 85 e8 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR __macro_lvi$9[ebp+12], 2
  00ab2	ff d6		 call	 esi

; 345  : 					ListView_EnsureVisible (FavoriteListControl, SelectedItem, FALSE);

  00ab4	6a 00		 push	 0
  00ab6	ff 35 00 00 00
	00		 push	 DWORD PTR ?SelectedItem@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA
  00abc	68 13 10 00 00	 push	 4115			; 00001013H
  00ac1	ff 35 00 00 00
	00		 push	 DWORD PTR ?FavoriteListControl@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4PAU3@A
  00ac7	ff d6		 call	 esi

; 346  : 				}
; 347  : 				return 1;

  00ac9	b8 01 00 00 00	 mov	 eax, 1
  00ace	e9 14 02 00 00	 jmp	 $LN1@FavoriteVo
$LN46@FavoriteVo:

; 348  : 
; 349  : 			case IDC_FAVORITE_MOVE_UP:
; 350  : 				if (SelectedItem > 0)

  00ad3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SelectedItem@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA
  00ad8	85 c0		 test	 eax, eax
  00ada	0f 8e 5c fe ff
	ff		 jle	 $LN92@FavoriteVo

; 351  : 				{
; 352  : 					swap (Favorites[SelectedItem], Favorites[SelectedItem - 1]);

  00ae0	6b c8 68	 imul	 ecx, eax, 104
  00ae3	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00ae9	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00aec	50		 push	 eax
  00aed	51		 push	 ecx
  00aee	e8 00 00 00 00	 call	 ??$swap@UFavoriteVolume@GostCrypt@@X@std@@YAXAAUFavoriteVolume@GostCrypt@@0@Z ; std::swap<GostCrypt::FavoriteVolume,void>

; 353  : 
; 354  : 					FillListControl (FavoriteListControl, Favorites);

  00af3	68 00 00 00 00	 push	 OFFSET ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00af8	ff 35 00 00 00
	00		 push	 DWORD PTR ?FavoriteListControl@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4PAU3@A
  00afe	e8 00 00 00 00	 call	 ?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ; GostCrypt::FillListControl

; 355  : 					--SelectedItem;

  00b03	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SelectedItem@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA
  00b08	83 c4 10	 add	 esp, 16			; 00000010H
  00b0b	48		 dec	 eax

; 356  : 					ListView_SetItemState (FavoriteListControl, SelectedItem, LVIS_SELECTED, LVIS_SELECTED);
; 357  : 					ListView_EnsureVisible (FavoriteListControl, SelectedItem, FALSE);
; 358  : 				}
; 359  : 				return 1;

  00b0c	e9 6f ff ff ff	 jmp	 $LN1815@FavoriteVo
$LN48@FavoriteVo:

; 360  : 
; 361  : 			case IDC_FAVORITE_REMOVE:
; 362  : 				if (SelectedItem != -1)

  00b11	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SelectedItem@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA
  00b16	83 f8 ff	 cmp	 eax, -1
  00b19	0f 84 1d fe ff
	ff		 je	 $LN92@FavoriteVo

; 363  : 				{
; 364  : 					Favorites.erase (Favorites.begin() + SelectedItem);

  00b1f	6b c0 68	 imul	 eax, eax, 104
  00b22	b9 00 00 00 00	 mov	 ecx, OFFSET ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00b27	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00b2d	50		 push	 eax
  00b2e	8d 85 e4 f8 ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00b34	50		 push	 eax
  00b35	e8 00 00 00 00	 call	 ?erase@?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UFavoriteVolume@GostCrypt@@@std@@@std@@@2@@Z ; std::vector<GostCrypt::FavoriteVolume,std::allocator<GostCrypt::FavoriteVolume> >::erase

; 365  : 					FillListControl (GetDlgItem (hwndDlg, IDC_FAVORITE_VOLUMES_LIST), Favorites);

  00b3a	68 00 00 00 00	 push	 OFFSET ?Favorites@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@A
  00b3f	68 5c 04 00 00	 push	 1116			; 0000045cH
  00b44	57		 push	 edi
  00b45	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  00b4b	50		 push	 eax
  00b4c	e8 00 00 00 00	 call	 ?FillListControl@GostCrypt@@YAXPAUHWND__@@AAV?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@Z ; GostCrypt::FillListControl

; 366  : 					SetControls (hwndDlg, FavoriteVolume(), SystemFavoritesMode, false);

  00b51	33 c0		 xor	 eax, eax
  00b53	c7 85 78 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T18[ebp+20], 15 ; 0000000fH
  00b5d	50		 push	 eax
  00b5e	66 89 45 ac	 mov	 WORD PTR $T18[ebp+72], ax
  00b62	89 45 c4	 mov	 DWORD PTR $T18[ebp+96], eax
  00b65	89 45 c8	 mov	 DWORD PTR $T18[ebp+100], eax
  00b68	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA
  00b6f	50		 push	 eax
  00b70	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  00b76	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+16], 0
  00b80	50		 push	 eax
  00b81	57		 push	 edi
  00b82	c6 85 64 ff ff
	ff 00		 mov	 BYTE PTR $T18[ebp], 0
  00b89	c7 45 90 0f 00
	00 00		 mov	 DWORD PTR $T18[ebp+44], 15 ; 0000000fH
  00b90	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR $T18[ebp+40], 0
  00b97	c6 85 7c ff ff
	ff 00		 mov	 BYTE PTR $T18[ebp+24], 0
  00b9e	c7 45 a8 0f 00
	00 00		 mov	 DWORD PTR $T18[ebp+68], 15 ; 0000000fH
  00ba5	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR $T18[ebp+64], 0
  00bac	c6 45 94 00	 mov	 BYTE PTR $T18[ebp+48], 0
  00bb0	c7 45 c0 07 00
	00 00		 mov	 DWORD PTR $T18[ebp+92], 7
  00bb7	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T18[ebp+88], 0
  00bbe	e8 00 00 00 00	 call	 ?SetControls@GostCrypt@@YAXPAUHWND__@@ABUFavoriteVolume@1@_N2@Z ; GostCrypt::SetControls
  00bc3	83 c4 18	 add	 esp, 24			; 00000018H
  00bc6	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  00bcc	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ

; 367  : 					SelectedItem = -1;

  00bd1	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?SelectedItem@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4HA, -1
  00bdb	b8 01 00 00 00	 mov	 eax, 1
  00be0	e9 02 01 00 00	 jmp	 $LN1@FavoriteVo
$LN50@FavoriteVo:

; 368  : 				}
; 369  : 				return 1;
; 370  : 
; 371  : 
; 372  : 			case IDC_FAVORITE_OPEN_EXPLORER_WIN_ON_MOUNT:	// Note that this option means "MOUNT_SYSTEM_FAVORITES_ON_BOOT" when SystemFavoritesMode is true
; 373  : 				if (SystemFavoritesMode)

  00be5	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA, 0
  00bec	0f 84 4a fd ff
	ff		 je	 $LN92@FavoriteVo

; 374  : 				{
; 375  : 					// MOUNT_SYSTEM_FAVORITES_ON_BOOT
; 376  : 
; 377  : 					if (IsDlgButtonChecked (hwndDlg, IDC_FAVORITE_OPEN_EXPLORER_WIN_ON_MOUNT))

  00bf2	68 68 04 00 00	 push	 1128			; 00000468H
  00bf7	57		 push	 edi
  00bf8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDlgButtonChecked@8
  00bfe	85 c0		 test	 eax, eax
  00c00	0f 84 36 fd ff
	ff		 je	 $LN92@FavoriteVo

; 378  : 					{
; 379  : 						WarningDirect ((wstring (GetString ("SYS_FAVORITES_KEYBOARD_WARNING")) + L"\n\n" + GetString ("BOOT_PASSWORD_CACHE_KEYBOARD_WARNING")).c_str());

  00c06	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EBHLJFH@SYS_FAVORITES_KEYBOARD_WARNING?$AA@
  00c0b	e8 00 00 00 00	 call	 _GetString
  00c10	83 c4 04	 add	 esp, 4
  00c13	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  00c19	50		 push	 eax
  00c1a	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00c1f	68 00 00 00 00	 push	 OFFSET ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  00c24	50		 push	 eax
  00c25	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  00c2b	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 8
  00c32	50		 push	 eax
  00c33	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00c38	8b f0		 mov	 esi, eax
  00c3a	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@JLONOHPL@BOOT_PASSWORD_CACHE_KEYBOARD_WAR@
  00c3f	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+12], 9
  00c43	e8 00 00 00 00	 call	 _GetString
  00c48	50		 push	 eax
  00c49	8d 45 d4	 lea	 eax, DWORD PTR $T25[ebp]
  00c4c	56		 push	 esi
  00c4d	50		 push	 eax
  00c4e	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00c53	83 c4 1c	 add	 esp, 28			; 0000001cH
  00c56	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00c5a	72 02		 jb	 SHORT $LN1307@FavoriteVo
  00c5c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1307@FavoriteVo:
  00c5e	50		 push	 eax
  00c5f	e8 00 00 00 00	 call	 _WarningDirect
  00c64	83 c4 04	 add	 esp, 4
  00c67	8d 4d d4	 lea	 ecx, DWORD PTR $T25[ebp]
  00c6a	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00c6f	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00c75	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00c7a	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  00c80	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 380  : 
; 381  : 						if (!IsServerOS() && !IsDlgButtonChecked (hwndDlg, IDC_FAVORITE_DISABLE_HOTKEY))

  00c85	e8 00 00 00 00	 call	 _IsServerOS
  00c8a	85 c0		 test	 eax, eax
  00c8c	0f 85 aa fc ff
	ff		 jne	 $LN92@FavoriteVo
  00c92	68 63 04 00 00	 push	 1123			; 00000463H
  00c97	57		 push	 edi
  00c98	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsDlgButtonChecked@8
  00c9e	85 c0		 test	 eax, eax
  00ca0	0f 85 96 fc ff
	ff		 jne	 $LN92@FavoriteVo

; 382  : 							Info ("SYS_FAVORITES_ADMIN_ONLY_INFO");

  00ca6	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@EPEDCGFA@SYS_FAVORITES_ADMIN_ONLY_INFO?$AA@
  00cab	e8 00 00 00 00	 call	 _Info
  00cb0	83 c4 04	 add	 esp, 4
  00cb3	b8 01 00 00 00	 mov	 eax, 1
  00cb8	eb 2d		 jmp	 SHORT $LN1@FavoriteVo
$LN58@FavoriteVo:

; 396  : 				}
; 397  : 				return 1;
; 398  : 
; 399  : 			case IDC_FAVORITES_HELP_LINK:
; 400  : 				Applink (SystemFavoritesMode ? "sysfavorites" : "favorites", TRUE, "");

  00cba	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?SystemFavoritesMode@?1??FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z@4_NA, 0
  00cc1	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09OAMOHPIB@favorites?$AA@
  00cc6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00ccb	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@NFCNMOKI@sysfavorites?$AA@
  00cd0	0f 44 c1	 cmove	 eax, ecx
  00cd3	6a 01		 push	 1
  00cd5	50		 push	 eax
  00cd6	e8 00 00 00 00	 call	 _Applink
  00cdb	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cde	b8 01 00 00 00	 mov	 eax, 1
  00ce3	eb 02		 jmp	 SHORT $LN1@FavoriteVo
$LN5@FavoriteVo:

; 401  : 				return 1;
; 402  : 			}
; 403  : 
; 404  : 			return 0;

  00ce5	33 c0		 xor	 eax, eax
$LN1@FavoriteVo:

; 429  : 				return 1;
; 430  : 			}
; 431  : 			break;
; 432  : 
; 433  : 		case WM_CLOSE:
; 434  : 			EndDialog (hwndDlg, IDCLOSE);
; 435  : 			return 1;
; 436  : 		}
; 437  : 
; 438  : 		return 0;
; 439  : 	}

  00ce7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00cea	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00cf1	59		 pop	 ecx
  00cf2	5f		 pop	 edi
  00cf3	5e		 pop	 esi
  00cf4	5b		 pop	 ebx
  00cf5	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cf8	33 cd		 xor	 ecx, ebp
  00cfa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00cff	8b e5		 mov	 esp, ebp
  00d01	5d		 pop	 ebp
  00d02	c2 10 00	 ret	 16			; 00000010H
$LN1814@FavoriteVo:
  00d05	0f 1f 00	 npad	 3
$LN1816@FavoriteVo:
  00d08	00 00 00 00	 DD	 $LN46@FavoriteVo
  00d0c	00 00 00 00	 DD	 $LN44@FavoriteVo
  00d10	00 00 00 00	 DD	 $LN48@FavoriteVo
  00d14	00 00 00 00	 DD	 $LN50@FavoriteVo
  00d18	00 00 00 00	 DD	 $LN58@FavoriteVo
  00d1c	00 00 00 00	 DD	 $LN5@FavoriteVo
$LN1810@FavoriteVo:
  00d20	00		 DB	 0
  00d21	01		 DB	 1
  00d22	02		 DB	 2
  00d23	05		 DB	 5
  00d24	03		 DB	 3
  00d25	05		 DB	 5
  00d26	05		 DB	 5
  00d27	05		 DB	 5
  00d28	05		 DB	 5
  00d29	05		 DB	 5
  00d2a	05		 DB	 5
  00d2b	04		 DB	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$4:
  00000	8d 8d ec f8 ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
__unwindfunclet$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$6:
  0000b	8d 8d ec f8 ff
	ff		 lea	 ecx, DWORD PTR _BootEncObj$5[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
__unwindfunclet$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$7:
  00016	8d 4d d0	 lea	 ecx, DWORD PTR _$S1$23[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$8:
  0001e	8d 4d d0	 lea	 ecx, DWORD PTR _$S2$22[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$vector@UFavoriteVolume@GostCrypt@@V?$allocator@UFavoriteVolume@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$14:
  00026	8d 4d d4	 lea	 ecx, DWORD PTR $T24[ebp]
  00029	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$15:
  0002e	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00034	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$11:
  00039	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  0003f	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z$12:
  00044	8d 8d 14 ff ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  0004a	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z:
  0004f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00053	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00056	8b 8a d8 f8 ff
	ff		 mov	 ecx, DWORD PTR [edx-1832]
  0005c	33 c8		 xor	 ecx, eax
  0005e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00063	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00066	33 c8		 xor	 ecx, eax
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z
  00072	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?FavoriteVolumesDlgProc@GostCrypt@@YGHPAUHWND__@@IIJ@Z ENDP ; GostCrypt::FavoriteVolumesDlgProc
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.cpp
;	COMDAT ?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z
_TEXT	SEGMENT
$T2 = -1836						; size = 4
_bytesReturned$ = -1836					; size = 4
_hwndDlg$GSCopy$1$ = -1832				; size = 4
_prop$ = -1828						; size = 596
$T3 = -1232						; size = 24
$T4 = -1232						; size = 24
$T5 = -1232						; size = 24
_favorite$ = -1208					; size = 104
_volumeDevPath$6 = -1104				; size = 24
$T7 = -1104						; size = 24
_vn$8 = -1080						; size = 24
$T9 = -1080						; size = 24
$T10 = -1080						; size = 24
$T11 = -1080						; size = 24
_resolvedVolumeDevPath$12 = -1056			; size = 520
_findVolumeDevPath$13 = -536				; size = 260
_volumeName$14 = -276					; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_hwndDlg$ = 8						; size = 4
_driveNo$ = 12						; size = 4
_systemFavorites$ = 16					; size = 1
?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z PROC ; GostCrypt::AddMountedVolumeToFavorites, COMDAT

; 52   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 20 07 00
	00		 sub	 esp, 1824		; 00000720H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 5d 08	 mov	 ebx, DWORD PTR _hwndDlg$[ebp]

; 53   : 		VOLUME_PROPERTIES_STRUCT prop;
; 54   : 		DWORD bytesReturned;
; 55   : 
; 56   : 		memset (&prop, 0, sizeof (prop));

  00031	8d 85 dc f8 ff
	ff		 lea	 eax, DWORD PTR _prop$[ebp]
  00037	33 ff		 xor	 edi, edi
  00039	89 9d d8 f8 ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$1$[ebp], ebx
  0003f	68 54 02 00 00	 push	 596			; 00000254H
  00044	57		 push	 edi
  00045	50		 push	 eax
  00046	89 bd d4 f8 ff
	ff		 mov	 DWORD PTR $T2[ebp], edi
  0004c	e8 00 00 00 00	 call	 _memset

; 57   : 		prop.driveNo = driveNo;

  00051	8b 45 0c	 mov	 eax, DWORD PTR _driveNo$[ebp]
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	89 85 dc f8 ff
	ff		 mov	 DWORD PTR _prop$[ebp], eax

; 58   : 
; 59   : 		if (!DeviceIoControl (hDriver, GST_IOCTL_GET_VOLUME_PROPERTIES, &prop, sizeof (prop), &prop, sizeof (prop), &bytesReturned, NULL))

  0005d	8d 85 d4 f8 ff
	ff		 lea	 eax, DWORD PTR _bytesReturned$[ebp]
  00063	57		 push	 edi
  00064	50		 push	 eax
  00065	68 54 02 00 00	 push	 596			; 00000254H
  0006a	8d 85 dc f8 ff
	ff		 lea	 eax, DWORD PTR _prop$[ebp]
  00070	50		 push	 eax
  00071	68 54 02 00 00	 push	 596			; 00000254H
  00076	50		 push	 eax
  00077	68 1c 20 22 00	 push	 2236444			; 0022201cH
  0007c	ff 35 00 00 00
	00		 push	 DWORD PTR _hDriver
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00088	85 c0		 test	 eax, eax
  0008a	75 10		 jne	 SHORT $LN5@AddMounted

; 60   : 		{
; 61   : 			handleWin32Error (hwndDlg);

  0008c	53		 push	 ebx
  0008d	e8 00 00 00 00	 call	 _handleWin32Error
  00092	83 c4 04	 add	 esp, 4

; 62   : 			return FALSE;

  00095	33 c0		 xor	 eax, eax
  00097	e9 4c 05 00 00	 jmp	 $LN1@AddMounted
$LN5@AddMounted:

; 63   : 		}
; 64   : 
; 65   : 		FavoriteVolume favorite;

  0009c	33 c0		 xor	 eax, eax
  0009e	c7 85 5c fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR _favorite$[ebp+20], 15 ; 0000000fH
  000a8	89 bd 58 fb ff
	ff		 mov	 DWORD PTR _favorite$[ebp+16], edi
  000ae	c6 85 48 fb ff
	ff 00		 mov	 BYTE PTR _favorite$[ebp], 0
  000b5	c7 85 74 fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR _favorite$[ebp+44], 15 ; 0000000fH
  000bf	89 bd 70 fb ff
	ff		 mov	 DWORD PTR _favorite$[ebp+40], edi
  000c5	c6 85 60 fb ff
	ff 00		 mov	 BYTE PTR _favorite$[ebp+24], 0
  000cc	c7 85 8c fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR _favorite$[ebp+68], 15 ; 0000000fH
  000d6	89 bd 88 fb ff
	ff		 mov	 DWORD PTR _favorite$[ebp+64], edi
  000dc	c6 85 78 fb ff
	ff 00		 mov	 BYTE PTR _favorite$[ebp+48], 0
  000e3	c7 85 a4 fb ff
	ff 07 00 00 00	 mov	 DWORD PTR _favorite$[ebp+92], 7
  000ed	89 bd a0 fb ff
	ff		 mov	 DWORD PTR _favorite$[ebp+88], edi
  000f3	66 89 85 90 fb
	ff ff		 mov	 WORD PTR _favorite$[ebp+72], ax
  000fa	89 85 a8 fb ff
	ff		 mov	 DWORD PTR _favorite$[ebp+96], eax
  00100	89 85 ac fb ff
	ff		 mov	 DWORD PTR _favorite$[ebp+100], eax

; 66   : 		favorite.MountPoint = "X:\\";

  00106	6a 03		 push	 3
  00108	68 00 00 00 00	 push	 OFFSET ??_C@_03OPPAHFLA@X?3?2?$AA@
  0010d	8d 8d 60 fb ff
	ff		 lea	 ecx, DWORD PTR _favorite$[ebp+24]
  00113	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
  00116	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 67   : 		favorite.MountPoint[0] = (char) (prop.driveNo + 'A');

  0011b	83 bd 74 fb ff
	ff 10		 cmp	 DWORD PTR _favorite$[ebp+44], 16 ; 00000010H
  00122	8d 8d 60 fb ff
	ff		 lea	 ecx, DWORD PTR _favorite$[ebp+24]
  00128	8a 85 dc f8 ff
	ff		 mov	 al, BYTE PTR _prop$[ebp]
  0012e	0f 43 8d 60 fb
	ff ff		 cmovae	 ecx, DWORD PTR _favorite$[ebp+24]
  00135	04 41		 add	 al, 65			; 00000041H

; 68   : 
; 69   : 		favorite.Path = WideToSingleString ((wchar_t *) prop.wszVolume);

  00137	c7 85 c4 fb ff
	ff 07 00 00 00	 mov	 DWORD PTR $T7[ebp+20], 7
  00141	c7 85 c0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+16], 0
  0014b	88 01		 mov	 BYTE PTR [ecx], al
  0014d	33 c0		 xor	 eax, eax
  0014f	66 89 85 b0 fb
	ff ff		 mov	 WORD PTR $T7[ebp], ax
  00156	66 39 85 e4 f8
	ff ff		 cmp	 WORD PTR _prop$[ebp+8], ax
  0015d	75 04		 jne	 SHORT $LN595@AddMounted
  0015f	33 c9		 xor	 ecx, ecx
  00161	eb 1c		 jmp	 SHORT $LN596@AddMounted
$LN595@AddMounted:
  00163	8d 8d e4 f8 ff
	ff		 lea	 ecx, DWORD PTR _prop$[ebp+8]
  00169	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  0016c	0f 1f 40 00	 npad	 4
$LL1919@AddMounted:
  00170	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00173	83 c1 02	 add	 ecx, 2
  00176	66 85 c0	 test	 ax, ax
  00179	75 f5		 jne	 SHORT $LL1919@AddMounted
  0017b	2b ca		 sub	 ecx, edx
  0017d	d1 f9		 sar	 ecx, 1
$LN596@AddMounted:
  0017f	51		 push	 ecx
  00180	8d 85 e4 f8 ff
	ff		 lea	 eax, DWORD PTR _prop$[ebp+8]
  00186	50		 push	 eax
  00187	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  0018d	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00192	8d 85 b0 fb ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00198	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0019c	50		 push	 eax
  0019d	8d 85 c8 fb ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 ?WideToSingleString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; WideToSingleString
  001a9	83 c4 08	 add	 esp, 8
  001ac	8b f0		 mov	 esi, eax
  001ae	8d 85 48 fb ff
	ff		 lea	 eax, DWORD PTR _favorite$[ebp]
  001b4	3b c6		 cmp	 eax, esi
  001b6	74 45		 je	 SHORT $LN601@AddMounted
  001b8	8b 85 5c fb ff
	ff		 mov	 eax, DWORD PTR _favorite$[ebp+20]
  001be	83 f8 10	 cmp	 eax, 16			; 00000010H
  001c1	72 13		 jb	 SHORT $LN607@AddMounted
  001c3	40		 inc	 eax
  001c4	8d 8d 48 fb ff
	ff		 lea	 ecx, DWORD PTR _favorite$[ebp]
  001ca	50		 push	 eax
  001cb	ff b5 48 fb ff
	ff		 push	 DWORD PTR _favorite$[ebp]
  001d1	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN607@AddMounted:
  001d6	56		 push	 esi
  001d7	8d 8d 48 fb ff
	ff		 lea	 ecx, DWORD PTR _favorite$[ebp]
  001dd	c7 85 5c fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR _favorite$[ebp+20], 15 ; 0000000fH
  001e7	c7 85 58 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _favorite$[ebp+16], 0
  001f1	c6 85 48 fb ff
	ff 00		 mov	 BYTE PTR _favorite$[ebp], 0
  001f8	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN601@AddMounted:
  001fd	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR $T11[ebp+20]
  00203	83 f8 10	 cmp	 eax, 16			; 00000010H
  00206	72 13		 jb	 SHORT $LN897@AddMounted
  00208	40		 inc	 eax
  00209	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  0020f	50		 push	 eax
  00210	ff b5 c8 fb ff
	ff		 push	 DWORD PTR $T11[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN897@AddMounted:
  0021b	8b 85 c4 fb ff
	ff		 mov	 eax, DWORD PTR $T7[ebp+20]
  00221	c7 85 dc fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T11[ebp+20], 15 ; 0000000fH
  0022b	c7 85 d8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+16], 0
  00235	c6 85 c8 fb ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
  0023c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00240	83 f8 08	 cmp	 eax, 8
  00243	72 13		 jb	 SHORT $LN998@AddMounted
  00245	40		 inc	 eax
  00246	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  0024c	50		 push	 eax
  0024d	ff b5 b0 fb ff
	ff		 push	 DWORD PTR $T7[ebp]
  00253	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN998@AddMounted:

; 70   : 		if (favorite.Path.find ("\\??\\") == 0)

  00258	6a 04		 push	 4
  0025a	6a 00		 push	 0
  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_04FFEPHCCK@?2?$DP?$DP?2?$AA@
  00261	8d 8d 48 fb ff
	ff		 lea	 ecx, DWORD PTR _favorite$[ebp]
  00267	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0026c	85 c0		 test	 eax, eax
  0026e	0f 85 89 00 00
	00		 jne	 $LN1401@AddMounted

; 71   : 			favorite.Path = favorite.Path.substr (4);

  00274	6a ff		 push	 -1
  00276	6a 04		 push	 4
  00278	8d 85 c8 fb ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  0027e	50		 push	 eax
  0027f	8d 8d 48 fb ff
	ff		 lea	 ecx, DWORD PTR _favorite$[ebp]
  00285	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  0028a	8b f0		 mov	 esi, eax
  0028c	8d 85 48 fb ff
	ff		 lea	 eax, DWORD PTR _favorite$[ebp]
  00292	3b c6		 cmp	 eax, esi
  00294	74 45		 je	 SHORT $LN1105@AddMounted
  00296	8b 85 5c fb ff
	ff		 mov	 eax, DWORD PTR _favorite$[ebp+20]
  0029c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0029f	72 13		 jb	 SHORT $LN1111@AddMounted
  002a1	40		 inc	 eax
  002a2	8d 8d 48 fb ff
	ff		 lea	 ecx, DWORD PTR _favorite$[ebp]
  002a8	50		 push	 eax
  002a9	ff b5 48 fb ff
	ff		 push	 DWORD PTR _favorite$[ebp]
  002af	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN1111@AddMounted:
  002b4	56		 push	 esi
  002b5	8d 8d 48 fb ff
	ff		 lea	 ecx, DWORD PTR _favorite$[ebp]
  002bb	c7 85 5c fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR _favorite$[ebp+20], 15 ; 0000000fH
  002c5	c7 85 58 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _favorite$[ebp+16], 0
  002cf	c6 85 48 fb ff
	ff 00		 mov	 BYTE PTR _favorite$[ebp], 0
  002d6	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN1105@AddMounted:
  002db	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR $T10[ebp+20]
  002e1	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002e5	83 f8 10	 cmp	 eax, 16			; 00000010H
  002e8	72 13		 jb	 SHORT $LN1401@AddMounted
  002ea	40		 inc	 eax
  002eb	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  002f1	50		 push	 eax
  002f2	ff b5 c8 fb ff
	ff		 push	 DWORD PTR $T10[ebp]
  002f8	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN1401@AddMounted:

; 72   : 
; 73   : 		if (IsVolumeDeviceHosted (favorite.Path.c_str()))

  002fd	83 bd 5c fb ff
	ff 10		 cmp	 DWORD PTR _favorite$[ebp+20], 16 ; 00000010H
  00304	8d 85 48 fb ff
	ff		 lea	 eax, DWORD PTR _favorite$[ebp]
  0030a	0f 43 85 48 fb
	ff ff		 cmovae	 eax, DWORD PTR _favorite$[ebp]
  00311	50		 push	 eax
  00312	e8 00 00 00 00	 call	 _IsVolumeDeviceHosted
  00317	83 c4 04	 add	 esp, 4
  0031a	85 c0		 test	 eax, eax
  0031c	0f 84 01 02 00
	00		 je	 $LN7@AddMounted

; 74   : 		{
; 75   : 			// Get GUID path
; 76   : 			string volumeDevPath = favorite.Path;

  00322	6a ff		 push	 -1
  00324	6a 00		 push	 0
  00326	8d 85 48 fb ff
	ff		 lea	 eax, DWORD PTR _favorite$[ebp]
  0032c	c7 85 c4 fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR _volumeDevPath$6[ebp+20], 15 ; 0000000fH
  00336	50		 push	 eax
  00337	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _volumeDevPath$6[ebp]
  0033d	c7 85 c0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _volumeDevPath$6[ebp+16], 0
  00347	c6 85 b0 fb ff
	ff 00		 mov	 BYTE PTR _volumeDevPath$6[ebp], 0
  0034e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 77   : 
; 78   : 			wchar_t resolvedVolumeDevPath[GST_MAX_PATH];
; 79   : 			if (ResolveSymbolicLink (SingleStringToWide (volumeDevPath).c_str(), resolvedVolumeDevPath))

  00353	8d 85 b0 fb ff
	ff		 lea	 eax, DWORD PTR _volumeDevPath$6[ebp]
  00359	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0035d	50		 push	 eax
  0035e	8d 85 30 fb ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00364	50		 push	 eax
  00365	e8 00 00 00 00	 call	 ?SingleStringToWide@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; SingleStringToWide
  0036a	83 c4 08	 add	 esp, 8
  0036d	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00371	72 02		 jb	 SHORT $LN1652@AddMounted
  00373	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1652@AddMounted:
  00375	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _resolvedVolumeDevPath$12[ebp]
  0037b	51		 push	 ecx
  0037c	50		 push	 eax
  0037d	e8 00 00 00 00	 call	 _ResolveSymbolicLink
  00382	83 c4 08	 add	 esp, 8
  00385	8d 8d 30 fb ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0038b	8b f0		 mov	 esi, eax
  0038d	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00392	85 f6		 test	 esi, esi
  00394	74 52		 je	 SHORT $LN8@AddMounted

; 80   : 				volumeDevPath = WideToSingleString (resolvedVolumeDevPath);

  00396	8d 85 e0 fb ff
	ff		 lea	 eax, DWORD PTR _resolvedVolumeDevPath$12[ebp]
  0039c	50		 push	 eax
  0039d	8d 8d 30 fb ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  003a3	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  003a8	8d 85 30 fb ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  003ae	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  003b2	50		 push	 eax
  003b3	8d 85 c8 fb ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  003b9	50		 push	 eax
  003ba	e8 00 00 00 00	 call	 ?WideToSingleString@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; WideToSingleString
  003bf	83 c4 08	 add	 esp, 8
  003c2	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _volumeDevPath$6[ebp]
  003c8	50		 push	 eax
  003c9	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  003ce	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  003d4	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  003d9	8d 8d 30 fb ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  003df	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  003e3	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN8@AddMounted:

; 81   : 
; 82   : 			char volumeName[GST_MAX_PATH];
; 83   : 			HANDLE find = FindFirstVolume (volumeName, sizeof (volumeName));

  003e8	68 04 01 00 00	 push	 260			; 00000104H
  003ed	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _volumeName$14[ebp]
  003f3	50		 push	 eax
  003f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstVolumeA@8
  003fa	8b f0		 mov	 esi, eax

; 84   : 
; 85   : 			if (find != INVALID_HANDLE_VALUE)

  003fc	83 fe ff	 cmp	 esi, -1
  003ff	0f 84 0f 01 00
	00		 je	 $LN9@AddMounted
  00405	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@AddMounted:

; 86   : 			{
; 87   : 				do
; 88   : 				{
; 89   : 					char findVolumeDevPath[GST_MAX_PATH];
; 90   : 					string vn = volumeName;

  00410	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _volumeName$14[ebp]
  00416	50		 push	 eax
  00417	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR _vn$8[ebp]
  0041d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 91   : 
; 92   : 					if (QueryDosDevice (vn.substr (4, vn.size() - 5).c_str(), findVolumeDevPath, sizeof (findVolumeDevPath)) != 0
; 93   : 						&& volumeDevPath == findVolumeDevPath)

  00422	8b 85 d8 fb ff
	ff		 mov	 eax, DWORD PTR _vn$8[ebp+16]
  00428	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR _vn$8[ebp]
  0042e	83 c0 fb	 add	 eax, -5			; fffffffbH
  00431	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00435	50		 push	 eax
  00436	6a 04		 push	 4
  00438	8d 85 30 fb ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0043e	50		 push	 eax
  0043f	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  00444	83 cf 01	 or	 edi, 1
  00447	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0044b	72 02		 jb	 SHORT $LN1681@AddMounted
  0044d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1681@AddMounted:
  0044f	68 04 01 00 00	 push	 260			; 00000104H
  00454	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _findVolumeDevPath$13[ebp]
  0045a	51		 push	 ecx
  0045b	50		 push	 eax
  0045c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryDosDeviceA@12
  00462	85 c0		 test	 eax, eax
  00464	74 1e		 je	 SHORT $LN13@AddMounted
  00466	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _findVolumeDevPath$13[ebp]
  0046c	50		 push	 eax
  0046d	8d 85 b0 fb ff
	ff		 lea	 eax, DWORD PTR _volumeDevPath$6[ebp]
  00473	50		 push	 eax
  00474	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  00479	83 c4 08	 add	 esp, 8
  0047c	84 c0		 test	 al, al
  0047e	74 04		 je	 SHORT $LN13@AddMounted
  00480	b3 01		 mov	 bl, 1
  00482	eb 02		 jmp	 SHORT $LN14@AddMounted
$LN13@AddMounted:
  00484	32 db		 xor	 bl, bl
$LN14@AddMounted:
  00486	8b 85 44 fb ff
	ff		 mov	 eax, DWORD PTR $T3[ebp+20]
  0048c	83 e7 fe	 and	 edi, -2			; fffffffeH
  0048f	83 f8 10	 cmp	 eax, 16			; 00000010H
  00492	72 13		 jb	 SHORT $LN1690@AddMounted
  00494	40		 inc	 eax
  00495	8d 8d 30 fb ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0049b	50		 push	 eax
  0049c	ff b5 30 fb ff
	ff		 push	 DWORD PTR $T3[ebp]
  004a2	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN1690@AddMounted:
  004a7	84 db		 test	 bl, bl
  004a9	75 3f		 jne	 SHORT $LN1916@AddMounted

; 97   : 					}
; 98   : 
; 99   : 				} while (FindNextVolume (find, volumeName, sizeof (volumeName)));

  004ab	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _vn$8[ebp+20]
  004b1	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  004b5	83 f8 10	 cmp	 eax, 16			; 00000010H
  004b8	72 13		 jb	 SHORT $LN1791@AddMounted
  004ba	40		 inc	 eax
  004bb	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR _vn$8[ebp]
  004c1	50		 push	 eax
  004c2	ff b5 c8 fb ff
	ff		 push	 DWORD PTR _vn$8[ebp]
  004c8	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN1791@AddMounted:
  004cd	68 04 01 00 00	 push	 260			; 00000104H
  004d2	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _volumeName$14[ebp]
  004d8	50		 push	 eax
  004d9	56		 push	 esi
  004da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextVolumeA@12
  004e0	85 c0		 test	 eax, eax
  004e2	0f 85 28 ff ff
	ff		 jne	 $LL4@AddMounted
  004e8	eb 1d		 jmp	 SHORT $LN3@AddMounted
$LN1916@AddMounted:

; 94   : 					{
; 95   : 						favorite.VolumePathId = volumeName;

  004ea	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _volumeName$14[ebp]
  004f0	50		 push	 eax
  004f1	8d 8d 78 fb ff
	ff		 lea	 ecx, DWORD PTR _favorite$[ebp+48]
  004f7	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 96   : 						break;

  004fc	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR _vn$8[ebp]
  00502	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN3@AddMounted:

; 100  : 
; 101  : 				FindVolumeClose (find);

  00507	56		 push	 esi
  00508	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindVolumeClose@4
  0050e	8b 9d d8 f8 ff
	ff		 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
$LN9@AddMounted:

; 102  : 			}
; 103  : 		}

  00514	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _volumeDevPath$6[ebp]
  0051a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0051e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN7@AddMounted:

; 104  : 
; 105  : 		favorite.ReadOnly = prop.readOnly ? true : false;

  00523	83 bd 08 fb ff
	ff 00		 cmp	 DWORD PTR _prop$[ebp+556], 0
  0052a	0f 95 85 ad fb
	ff ff		 setne	 BYTE PTR _favorite$[ebp+101]

; 106  : 		favorite.Removable = prop.removable ? true : false;

  00531	83 bd 0c fb ff
	ff 00		 cmp	 DWORD PTR _prop$[ebp+560], 0
  00538	0f 95 85 ae fb
	ff ff		 setne	 BYTE PTR _favorite$[ebp+102]

; 107  : 		favorite.SystemEncryption = prop.partitionInInactiveSysEncScope ? true : false;

  0053f	83 bd 10 fb ff
	ff 00		 cmp	 DWORD PTR _prop$[ebp+564], 0
  00546	0f 95 85 af fb
	ff ff		 setne	 BYTE PTR _favorite$[ebp+103]

; 108  : 		favorite.OpenExplorerWindow = (bExplore == TRUE);

  0054d	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _bExplore, 1
  00554	0f 94 85 ac fb
	ff ff		 sete	 BYTE PTR _favorite$[ebp+100]

; 109  : 
; 110  : 		if (favorite.VolumePathId.empty()
; 111  : 			&& IsVolumeDeviceHosted (favorite.Path.c_str())
; 112  : 			&& favorite.Path.find ("\\\\?\\Volume{") != 0)

  0055b	83 bd 88 fb ff
	ff 00		 cmp	 DWORD PTR _favorite$[ebp+64], 0
  00562	75 62		 jne	 SHORT $LN11@AddMounted
  00564	83 bd 5c fb ff
	ff 10		 cmp	 DWORD PTR _favorite$[ebp+20], 16 ; 00000010H
  0056b	8d 85 48 fb ff
	ff		 lea	 eax, DWORD PTR _favorite$[ebp]
  00571	0f 43 85 48 fb
	ff ff		 cmovae	 eax, DWORD PTR _favorite$[ebp]
  00578	50		 push	 eax
  00579	e8 00 00 00 00	 call	 _IsVolumeDeviceHosted
  0057e	83 c4 04	 add	 esp, 4
  00581	85 c0		 test	 eax, eax
  00583	74 41		 je	 SHORT $LN11@AddMounted
  00585	6a 00		 push	 0
  00587	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CJEJOKNC@?2?2?$DP?2Volume?$HL?$AA@
  0058c	8d 8d 48 fb ff
	ff		 lea	 ecx, DWORD PTR _favorite$[ebp]
  00592	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00597	85 c0		 test	 eax, eax
  00599	74 2b		 je	 SHORT $LN11@AddMounted

; 113  : 		{
; 114  : 			Warning (favorite.Path.find ("\\Partition0") == string::npos ? "FAVORITE_ADD_PARTITION_TYPE_WARNING" : "FAVORITE_ADD_DRIVE_DEV_WARNING");

  0059b	6a 00		 push	 0
  0059d	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OJHKIMBP@?2Partition0?$AA@
  005a2	8d 8d 48 fb ff
	ff		 lea	 ecx, DWORD PTR _favorite$[ebp]
  005a8	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  005ad	83 f8 ff	 cmp	 eax, -1
  005b0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BP@BOKIMCAM@FAVORITE_ADD_DRIVE_DEV_WARNING?$AA@
  005b5	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CE@GJAIEOAP@FAVORITE_ADD_PARTITION_TYPE_WARN@
  005ba	0f 45 ca	 cmovne	 ecx, edx
  005bd	51		 push	 ecx
  005be	e8 00 00 00 00	 call	 _Warning
  005c3	83 c4 04	 add	 esp, 4
$LN11@AddMounted:

; 115  : 		}
; 116  : 
; 117  : 		return OrganizeFavoriteVolumes (hwndDlg, systemFavorites, favorite);

  005c6	8d 85 48 fb ff
	ff		 lea	 eax, DWORD PTR _favorite$[ebp]
  005cc	50		 push	 eax
  005cd	ff 75 10	 push	 DWORD PTR _systemFavorites$[ebp]
  005d0	53		 push	 ebx
  005d1	e8 00 00 00 00	 call	 ?OrganizeFavoriteVolumes@GostCrypt@@YAHPAUHWND__@@_NABUFavoriteVolume@1@@Z ; GostCrypt::OrganizeFavoriteVolumes
  005d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  005d9	8d 8d 48 fb ff
	ff		 lea	 ecx, DWORD PTR _favorite$[ebp]
  005df	8b f0		 mov	 esi, eax
  005e1	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  005e6	8b c6		 mov	 eax, esi
$LN1@AddMounted:

; 118  : 	}

  005e8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005eb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005f2	59		 pop	 ecx
  005f3	5f		 pop	 edi
  005f4	5e		 pop	 esi
  005f5	5b		 pop	 ebx
  005f6	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005f9	33 cd		 xor	 ecx, ebp
  005fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00600	8b e5		 mov	 esp, ebp
  00602	5d		 pop	 ebp
  00603	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z$0:
  00000	8d 8d 48 fb ff
	ff		 lea	 ecx, DWORD PTR _favorite$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
__unwindfunclet$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z$1:
  0000b	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z$146:
  00016	e8 00 00 00 00	 call	 ___std_terminate
  0001b	c3		 ret	 0
__unwindfunclet$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z$268:
  0001c	e8 00 00 00 00	 call	 ___std_terminate
  00021	c3		 ret	 0
__unwindfunclet$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z$4:
  00022	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _volumeDevPath$6[ebp]
  00028	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z$6:
  0002d	8d 8d 30 fb ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00033	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z$8:
  00038	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR _vn$8[ebp]
  0003e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z:
  00043	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00047	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0004a	8b 8a d0 f8 ff
	ff		 mov	 ecx, DWORD PTR [edx-1840]
  00050	33 c8		 xor	 ecx, eax
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0005a	33 c8		 xor	 ecx, eax
  0005c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00061	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z
  00066	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddMountedVolumeToFavorites@GostCrypt@@YAHPAUHWND__@@H_N@Z ENDP ; GostCrypt::AddMountedVolumeToFavorites
; Function compile flags: /Ogtp
;	COMDAT ??1FavoriteVolumesDlgProcArguments@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??1FavoriteVolumesDlgProcArguments@GostCrypt@@QAE@XZ PROC ; GostCrypt::FavoriteVolumesDlgProcArguments::~FavoriteVolumesDlgProcArguments, COMDAT
; _this$ = ecx
  00000	83 c1 04	 add	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
??1FavoriteVolumesDlgProcArguments@GostCrypt@@QAE@XZ ENDP ; GostCrypt::FavoriteVolumesDlgProcArguments::~FavoriteVolumesDlgProcArguments
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0FavoriteVolumesDlgProcArguments@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0FavoriteVolumesDlgProcArguments@GostCrypt@@QAE@XZ PROC ; GostCrypt::FavoriteVolumesDlgProcArguments::FavoriteVolumesDlgProcArguments, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  0000b	33 c0		 xor	 eax, eax
  0000d	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00014	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00018	c7 41 30 0f 00
	00 00		 mov	 DWORD PTR [ecx+48], 15	; 0000000fH
  0001f	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
  00026	c6 41 1c 00	 mov	 BYTE PTR [ecx+28], 0
  0002a	c7 41 48 0f 00
	00 00		 mov	 DWORD PTR [ecx+72], 15	; 0000000fH
  00031	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0
  00038	c6 41 34 00	 mov	 BYTE PTR [ecx+52], 0
  0003c	c7 41 60 07 00
	00 00		 mov	 DWORD PTR [ecx+96], 7
  00043	c7 41 5c 00 00
	00 00		 mov	 DWORD PTR [ecx+92], 0
  0004a	66 89 41 4c	 mov	 WORD PTR [ecx+76], ax
  0004e	89 41 64	 mov	 DWORD PTR [ecx+100], eax
  00051	89 41 68	 mov	 DWORD PTR [ecx+104], eax
  00054	8b c1		 mov	 eax, ecx
  00056	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
??0FavoriteVolumesDlgProcArguments@GostCrypt@@QAE@XZ ENDP ; GostCrypt::FavoriteVolumesDlgProcArguments::FavoriteVolumesDlgProcArguments
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GFavoriteVolume@GostCrypt@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GFavoriteVolume@GostCrypt@@QAEPAXI@Z PROC		; GostCrypt::FavoriteVolume::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1FavoriteVolume@GostCrypt@@QAE@XZ
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 68		 push	 104			; 00000068H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GFavoriteVolume@GostCrypt@@QAEPAXI@Z ENDP		; GostCrypt::FavoriteVolume::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z PROC	; GostCrypt::FavoriteVolume::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___that$[ebp]
  0002a	3b f3		 cmp	 esi, ebx
  0002c	74 36		 je	 SHORT $LN7@operator
  0002e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00031	83 f8 10	 cmp	 eax, 16			; 00000010H
  00034	72 09		 jb	 SHORT $LN13@operator
  00036	40		 inc	 eax
  00037	50		 push	 eax
  00038	ff 36		 push	 DWORD PTR [esi]
  0003a	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN13@operator:
  0003f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00046	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0004a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00051	72 04		 jb	 SHORT $LN101@operator
  00053	8b 06		 mov	 eax, DWORD PTR [esi]
  00055	eb 02		 jmp	 SHORT $LN102@operator
$LN101@operator:
  00057	8b c6		 mov	 eax, esi
$LN102@operator:
  00059	53		 push	 ebx
  0005a	8b ce		 mov	 ecx, esi
  0005c	c6 00 00	 mov	 BYTE PTR [eax], 0
  0005f	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN7@operator:
  00064	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
  00067	8d 7e 18	 lea	 edi, DWORD PTR [esi+24]
  0006a	3b f9		 cmp	 edi, ecx
  0006c	74 3b		 je	 SHORT $LN301@operator
  0006e	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00071	83 f8 10	 cmp	 eax, 16			; 00000010H
  00074	72 0e		 jb	 SHORT $LN307@operator
  00076	40		 inc	 eax
  00077	8b cf		 mov	 ecx, edi
  00079	50		 push	 eax
  0007a	ff 37		 push	 DWORD PTR [edi]
  0007c	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  00081	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
$LN307@operator:
  00084	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
  0008b	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  0008f	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00096	72 04		 jb	 SHORT $LN395@operator
  00098	8b 07		 mov	 eax, DWORD PTR [edi]
  0009a	eb 02		 jmp	 SHORT $LN396@operator
$LN395@operator:
  0009c	8b c7		 mov	 eax, edi
$LN396@operator:
  0009e	51		 push	 ecx
  0009f	8b cf		 mov	 ecx, edi
  000a1	c6 00 00	 mov	 BYTE PTR [eax], 0
  000a4	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN301@operator:
  000a9	8d 4b 30	 lea	 ecx, DWORD PTR [ebx+48]
  000ac	8d 7e 30	 lea	 edi, DWORD PTR [esi+48]
  000af	3b f9		 cmp	 edi, ecx
  000b1	74 3b		 je	 SHORT $LN595@operator
  000b3	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  000b6	83 f8 10	 cmp	 eax, 16			; 00000010H
  000b9	72 0e		 jb	 SHORT $LN601@operator
  000bb	40		 inc	 eax
  000bc	8b cf		 mov	 ecx, edi
  000be	50		 push	 eax
  000bf	ff 37		 push	 DWORD PTR [edi]
  000c1	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  000c6	8d 4b 30	 lea	 ecx, DWORD PTR [ebx+48]
$LN601@operator:
  000c9	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
  000d0	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  000d4	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  000db	72 04		 jb	 SHORT $LN689@operator
  000dd	8b 07		 mov	 eax, DWORD PTR [edi]
  000df	eb 02		 jmp	 SHORT $LN690@operator
$LN689@operator:
  000e1	8b c7		 mov	 eax, edi
$LN690@operator:
  000e3	51		 push	 ecx
  000e4	8b cf		 mov	 ecx, edi
  000e6	c6 00 00	 mov	 BYTE PTR [eax], 0
  000e9	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN595@operator:
  000ee	8d 4b 48	 lea	 ecx, DWORD PTR [ebx+72]
  000f1	8d 7e 48	 lea	 edi, DWORD PTR [esi+72]
  000f4	3b f9		 cmp	 edi, ecx
  000f6	74 3d		 je	 SHORT $LN889@operator
  000f8	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  000fb	83 f8 08	 cmp	 eax, 8
  000fe	72 0e		 jb	 SHORT $LN895@operator
  00100	40		 inc	 eax
  00101	8b cf		 mov	 ecx, edi
  00103	50		 push	 eax
  00104	ff 37		 push	 DWORD PTR [edi]
  00106	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
  0010b	8d 4b 48	 lea	 ecx, DWORD PTR [ebx+72]
$LN895@operator:
  0010e	c7 47 14 07 00
	00 00		 mov	 DWORD PTR [edi+20], 7
  00115	83 7f 14 08	 cmp	 DWORD PTR [edi+20], 8
  00119	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00120	72 04		 jb	 SHORT $LN985@operator
  00122	8b 07		 mov	 eax, DWORD PTR [edi]
  00124	eb 02		 jmp	 SHORT $LN986@operator
$LN985@operator:
  00126	8b c7		 mov	 eax, edi
$LN986@operator:
  00128	33 d2		 xor	 edx, edx
  0012a	51		 push	 ecx
  0012b	8b cf		 mov	 ecx, edi
  0012d	66 89 10	 mov	 WORD PTR [eax], dx
  00130	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN889@operator:
  00135	0f b6 43 60	 movzx	 eax, BYTE PTR [ebx+96]
  00139	88 46 60	 mov	 BYTE PTR [esi+96], al
  0013c	0f b6 43 61	 movzx	 eax, BYTE PTR [ebx+97]
  00140	88 46 61	 mov	 BYTE PTR [esi+97], al
  00143	0f b6 43 62	 movzx	 eax, BYTE PTR [ebx+98]
  00147	88 46 62	 mov	 BYTE PTR [esi+98], al
  0014a	0f b6 43 63	 movzx	 eax, BYTE PTR [ebx+99]
  0014e	88 46 63	 mov	 BYTE PTR [esi+99], al
  00151	0f b6 43 64	 movzx	 eax, BYTE PTR [ebx+100]
  00155	88 46 64	 mov	 BYTE PTR [esi+100], al
  00158	0f b6 43 65	 movzx	 eax, BYTE PTR [ebx+101]
  0015c	88 46 65	 mov	 BYTE PTR [esi+101], al
  0015f	0f b6 43 66	 movzx	 eax, BYTE PTR [ebx+102]
  00163	88 46 66	 mov	 BYTE PTR [esi+102], al
  00166	0f b6 43 67	 movzx	 eax, BYTE PTR [ebx+103]
  0016a	88 46 67	 mov	 BYTE PTR [esi+103], al
  0016d	8b c6		 mov	 eax, esi
  0016f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00172	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00179	59		 pop	 ecx
  0017a	5f		 pop	 edi
  0017b	5e		 pop	 esi
  0017c	5b		 pop	 ebx
  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__unwindfunclet$??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z$68:
  00006	e8 00 00 00 00	 call	 ___std_terminate
  0000b	c3		 ret	 0
__unwindfunclet$??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z$136:
  0000c	e8 00 00 00 00	 call	 ___std_terminate
  00011	c3		 ret	 0
__unwindfunclet$??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z$204:
  00012	e8 00 00 00 00	 call	 ___std_terminate
  00017	c3		 ret	 0
__ehhandler$??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4FavoriteVolume@GostCrypt@@QAEAAU01@$$QAU01@@Z ENDP	; GostCrypt::FavoriteVolume::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4FavoriteVolume@GostCrypt@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4FavoriteVolume@GostCrypt@@QAEAAU01@ABU01@@Z PROC	; GostCrypt::FavoriteVolume::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 0a		 je	 SHORT $LN4@operator
  0000e	6a ff		 push	 -1
  00010	6a 00		 push	 0
  00012	57		 push	 edi
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN4@operator:
  00018	8d 47 18	 lea	 eax, DWORD PTR [edi+24]
  0001b	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  0001e	3b c8		 cmp	 ecx, eax
  00020	74 0a		 je	 SHORT $LN135@operator
  00022	6a ff		 push	 -1
  00024	6a 00		 push	 0
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN135@operator:
  0002c	8d 47 30	 lea	 eax, DWORD PTR [edi+48]
  0002f	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  00032	3b c8		 cmp	 ecx, eax
  00034	74 0a		 je	 SHORT $LN266@operator
  00036	6a ff		 push	 -1
  00038	6a 00		 push	 0
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN266@operator:
  00040	8d 47 48	 lea	 eax, DWORD PTR [edi+72]
  00043	8d 4e 48	 lea	 ecx, DWORD PTR [esi+72]
  00046	3b c8		 cmp	 ecx, eax
  00048	74 0a		 je	 SHORT $LN397@operator
  0004a	6a ff		 push	 -1
  0004c	6a 00		 push	 0
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN397@operator:
  00054	0f b6 47 60	 movzx	 eax, BYTE PTR [edi+96]
  00058	88 46 60	 mov	 BYTE PTR [esi+96], al
  0005b	0f b6 47 61	 movzx	 eax, BYTE PTR [edi+97]
  0005f	88 46 61	 mov	 BYTE PTR [esi+97], al
  00062	0f b6 47 62	 movzx	 eax, BYTE PTR [edi+98]
  00066	88 46 62	 mov	 BYTE PTR [esi+98], al
  00069	0f b6 47 63	 movzx	 eax, BYTE PTR [edi+99]
  0006d	88 46 63	 mov	 BYTE PTR [esi+99], al
  00070	0f b6 47 64	 movzx	 eax, BYTE PTR [edi+100]
  00074	88 46 64	 mov	 BYTE PTR [esi+100], al
  00077	0f b6 47 65	 movzx	 eax, BYTE PTR [edi+101]
  0007b	88 46 65	 mov	 BYTE PTR [esi+101], al
  0007e	0f b6 47 66	 movzx	 eax, BYTE PTR [edi+102]
  00082	88 46 66	 mov	 BYTE PTR [esi+102], al
  00085	0f b6 47 67	 movzx	 eax, BYTE PTR [edi+103]
  00089	88 46 67	 mov	 BYTE PTR [esi+103], al
  0008c	8b c6		 mov	 eax, esi
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
??4FavoriteVolume@GostCrypt@@QAEAAU01@ABU01@@Z ENDP	; GostCrypt::FavoriteVolume::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0FavoriteVolume@GostCrypt@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0FavoriteVolume@GostCrypt@@QAE@$$QAU01@@Z PROC	; GostCrypt::FavoriteVolume::FavoriteVolume, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	56		 push	 esi
  0000b	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
  00012	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00019	c6 07 00	 mov	 BYTE PTR [edi], 0
  0001c	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00021	8d 4f 18	 lea	 ecx, DWORD PTR [edi+24]
  00024	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  00027	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0002e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00035	50		 push	 eax
  00036	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00039	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0003e	8d 4f 30	 lea	 ecx, DWORD PTR [edi+48]
  00041	8d 46 30	 lea	 eax, DWORD PTR [esi+48]
  00044	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0004b	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00052	50		 push	 eax
  00053	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00056	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0005b	8d 4f 48	 lea	 ecx, DWORD PTR [edi+72]
  0005e	33 d2		 xor	 edx, edx
  00060	8d 46 48	 lea	 eax, DWORD PTR [esi+72]
  00063	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  0006a	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00071	50		 push	 eax
  00072	66 89 11	 mov	 WORD PTR [ecx], dx
  00075	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  0007a	0f b6 46 60	 movzx	 eax, BYTE PTR [esi+96]
  0007e	88 47 60	 mov	 BYTE PTR [edi+96], al
  00081	0f b6 46 61	 movzx	 eax, BYTE PTR [esi+97]
  00085	88 47 61	 mov	 BYTE PTR [edi+97], al
  00088	0f b6 46 62	 movzx	 eax, BYTE PTR [esi+98]
  0008c	88 47 62	 mov	 BYTE PTR [edi+98], al
  0008f	0f b6 46 63	 movzx	 eax, BYTE PTR [esi+99]
  00093	88 47 63	 mov	 BYTE PTR [edi+99], al
  00096	0f b6 46 64	 movzx	 eax, BYTE PTR [esi+100]
  0009a	88 47 64	 mov	 BYTE PTR [edi+100], al
  0009d	0f b6 46 65	 movzx	 eax, BYTE PTR [esi+101]
  000a1	88 47 65	 mov	 BYTE PTR [edi+101], al
  000a4	0f b6 46 66	 movzx	 eax, BYTE PTR [esi+102]
  000a8	88 47 66	 mov	 BYTE PTR [edi+102], al
  000ab	0f b6 46 67	 movzx	 eax, BYTE PTR [esi+103]
  000af	88 47 67	 mov	 BYTE PTR [edi+103], al
  000b2	8b c7		 mov	 eax, edi
  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5d		 pop	 ebp
  000b7	c2 04 00	 ret	 4
??0FavoriteVolume@GostCrypt@@QAE@$$QAU01@@Z ENDP	; GostCrypt::FavoriteVolume::FavoriteVolume
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z PROC		; GostCrypt::FavoriteVolume::FavoriteVolume, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00031	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00038	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0003f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00043	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004a	72 04		 jb	 SHORT $LN125@FavoriteVo
  0004c	8b 06		 mov	 eax, DWORD PTR [esi]
  0004e	eb 02		 jmp	 SHORT $LN126@FavoriteVo
$LN125@FavoriteVo:
  00050	8b c6		 mov	 eax, esi
$LN126@FavoriteVo:
  00052	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00055	6a ff		 push	 -1
  00057	6a 00		 push	 0
  00059	57		 push	 edi
  0005a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0005d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00062	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00065	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006c	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00073	8d 57 18	 lea	 edx, DWORD PTR [edi+24]
  00076	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0007d	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00081	72 04		 jb	 SHORT $LN250@FavoriteVo
  00083	8b 01		 mov	 eax, DWORD PTR [ecx]
  00085	eb 02		 jmp	 SHORT $LN251@FavoriteVo
$LN250@FavoriteVo:
  00087	8b c1		 mov	 eax, ecx
$LN251@FavoriteVo:
  00089	6a ff		 push	 -1
  0008b	6a 00		 push	 0
  0008d	52		 push	 edx
  0008e	c6 00 00	 mov	 BYTE PTR [eax], 0
  00091	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00096	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  00099	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0009d	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  000a4	8d 57 30	 lea	 edx, DWORD PTR [edi+48]
  000a7	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  000ae	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  000b2	72 04		 jb	 SHORT $LN375@FavoriteVo
  000b4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b6	eb 02		 jmp	 SHORT $LN376@FavoriteVo
$LN375@FavoriteVo:
  000b8	8b c1		 mov	 eax, ecx
$LN376@FavoriteVo:
  000ba	6a ff		 push	 -1
  000bc	6a 00		 push	 0
  000be	52		 push	 edx
  000bf	c6 00 00	 mov	 BYTE PTR [eax], 0
  000c2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000c7	33 d2		 xor	 edx, edx
  000c9	c7 46 5c 07 00
	00 00		 mov	 DWORD PTR [esi+92], 7
  000d0	6a ff		 push	 -1
  000d2	8d 4e 48	 lea	 ecx, DWORD PTR [esi+72]
  000d5	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000d9	8d 47 48	 lea	 eax, DWORD PTR [edi+72]
  000dc	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  000e3	52		 push	 edx
  000e4	50		 push	 eax
  000e5	66 89 11	 mov	 WORD PTR [ecx], dx
  000e8	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  000ed	0f b6 47 60	 movzx	 eax, BYTE PTR [edi+96]
  000f1	88 46 60	 mov	 BYTE PTR [esi+96], al
  000f4	0f b6 47 61	 movzx	 eax, BYTE PTR [edi+97]
  000f8	88 46 61	 mov	 BYTE PTR [esi+97], al
  000fb	0f b6 47 62	 movzx	 eax, BYTE PTR [edi+98]
  000ff	88 46 62	 mov	 BYTE PTR [esi+98], al
  00102	0f b6 47 63	 movzx	 eax, BYTE PTR [edi+99]
  00106	88 46 63	 mov	 BYTE PTR [esi+99], al
  00109	0f b6 47 64	 movzx	 eax, BYTE PTR [edi+100]
  0010d	88 46 64	 mov	 BYTE PTR [esi+100], al
  00110	0f b6 47 65	 movzx	 eax, BYTE PTR [edi+101]
  00114	88 46 65	 mov	 BYTE PTR [esi+101], al
  00117	0f b6 47 66	 movzx	 eax, BYTE PTR [edi+102]
  0011b	88 46 66	 mov	 BYTE PTR [esi+102], al
  0011e	0f b6 47 67	 movzx	 eax, BYTE PTR [edi+103]
  00122	88 46 67	 mov	 BYTE PTR [esi+103], al
  00125	8b c6		 mov	 eax, esi
  00127	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00131	59		 pop	 ecx
  00132	5f		 pop	 edi
  00133	5e		 pop	 esi
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 18	 add	 ecx, 24			; 00000018H
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 30	 add	 ecx, 48			; 00000030H
  00019	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z:
  0001e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00022	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00025	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00028	33 c8		 xor	 ecx, eax
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0FavoriteVolume@GostCrypt@@QAE@ABU01@@Z ENDP		; GostCrypt::FavoriteVolume::FavoriteVolume
; Function compile flags: /Ogtp
;	COMDAT ??1FavoriteVolume@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??1FavoriteVolume@GostCrypt@@QAE@XZ PROC		; GostCrypt::FavoriteVolume::~FavoriteVolume, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  00006	57		 push	 edi
  00007	8d 7e 48	 lea	 edi, DWORD PTR [esi+72]
  0000a	83 f8 08	 cmp	 eax, 8
  0000d	72 0b		 jb	 SHORT $LN9@FavoriteVo
  0000f	40		 inc	 eax
  00010	8b cf		 mov	 ecx, edi
  00012	50		 push	 eax
  00013	ff 37		 push	 DWORD PTR [edi]
  00015	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN9@FavoriteVo:
  0001a	c7 47 14 07 00
	00 00		 mov	 DWORD PTR [edi+20], 7
  00021	83 7f 14 08	 cmp	 DWORD PTR [edi+20], 8
  00025	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  0002c	72 02		 jb	 SHORT $LN99@FavoriteVo
  0002e	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN99@FavoriteVo:
  00030	33 c0		 xor	 eax, eax
  00032	66 89 07	 mov	 WORD PTR [edi], ax
  00035	8d 7e 30	 lea	 edi, DWORD PTR [esi+48]
  00038	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0003b	83 f8 10	 cmp	 eax, 16			; 00000010H
  0003e	72 0b		 jb	 SHORT $LN112@FavoriteVo
  00040	40		 inc	 eax
  00041	8b cf		 mov	 ecx, edi
  00043	50		 push	 eax
  00044	ff 37		 push	 DWORD PTR [edi]
  00046	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN112@FavoriteVo:
  0004b	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
  00052	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00056	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  0005d	72 02		 jb	 SHORT $LN200@FavoriteVo
  0005f	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN200@FavoriteVo:
  00061	c6 07 00	 mov	 BYTE PTR [edi], 0
  00064	8d 7e 18	 lea	 edi, DWORD PTR [esi+24]
  00067	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0006a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0006d	72 0b		 jb	 SHORT $LN213@FavoriteVo
  0006f	40		 inc	 eax
  00070	8b cf		 mov	 ecx, edi
  00072	50		 push	 eax
  00073	ff 37		 push	 DWORD PTR [edi]
  00075	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN213@FavoriteVo:
  0007a	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
  00081	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00085	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  0008c	72 02		 jb	 SHORT $LN301@FavoriteVo
  0008e	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN301@FavoriteVo:
  00090	c6 07 00	 mov	 BYTE PTR [edi], 0
  00093	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00096	83 f8 10	 cmp	 eax, 16			; 00000010H
  00099	72 0b		 jb	 SHORT $LN314@FavoriteVo
  0009b	40		 inc	 eax
  0009c	8b ce		 mov	 ecx, esi
  0009e	50		 push	 eax
  0009f	ff 36		 push	 DWORD PTR [esi]
  000a1	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN314@FavoriteVo:
  000a6	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  000ad	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b1	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000b8	72 08		 jb	 SHORT $LN402@FavoriteVo
  000ba	8b 06		 mov	 eax, DWORD PTR [esi]
  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	c6 00 00	 mov	 BYTE PTR [eax], 0
  000c1	c3		 ret	 0
$LN402@FavoriteVo:
  000c2	5f		 pop	 edi
  000c3	c6 06 00	 mov	 BYTE PTR [esi], 0
  000c6	5e		 pop	 esi
  000c7	c3		 ret	 0
??1FavoriteVolume@GostCrypt@@QAE@XZ ENDP		; GostCrypt::FavoriteVolume::~FavoriteVolume
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\mount\favorites.h
;	COMDAT ??0FavoriteVolume@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0FavoriteVolume@GostCrypt@@QAE@XZ PROC		; GostCrypt::FavoriteVolume::FavoriteVolume, COMDAT
; _this$ = ecx

; 28   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0000b	33 c0		 xor	 eax, eax
  0000d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00014	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00017	c7 41 2c 0f 00
	00 00		 mov	 DWORD PTR [ecx+44], 15	; 0000000fH
  0001e	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
  00025	c6 41 18 00	 mov	 BYTE PTR [ecx+24], 0
  00029	c7 41 44 0f 00
	00 00		 mov	 DWORD PTR [ecx+68], 15	; 0000000fH
  00030	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0
  00037	c6 41 30 00	 mov	 BYTE PTR [ecx+48], 0
  0003b	c7 41 5c 07 00
	00 00		 mov	 DWORD PTR [ecx+92], 7
  00042	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0
  00049	66 89 41 48	 mov	 WORD PTR [ecx+72], ax
  0004d	89 41 60	 mov	 DWORD PTR [ecx+96], eax
  00050	89 41 64	 mov	 DWORD PTR [ecx+100], eax

; 29   : 		}

  00053	8b c1		 mov	 eax, ecx
  00055	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
??0FavoriteVolume@GostCrypt@@QAE@XZ ENDP		; GostCrypt::FavoriteVolume::FavoriteVolume
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0ErrorException@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0ErrorException@GostCrypt@@QAE@ABU01@@Z PROC		; GostCrypt::ErrorException::ErrorException, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	6a ff		 push	 -1
  0000c	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0000f	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ErrorException@GostCrypt@@6B@
  00018	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001b	83 c2 08	 add	 edx, 8
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	33 c0		 xor	 eax, eax
  00023	50		 push	 eax
  00024	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  0002b	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00032	52		 push	 edx
  00033	66 89 01	 mov	 WORD PTR [ecx], ax
  00036	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0003b	8b c6		 mov	 eax, esi
  0003d	5e		 pop	 esi
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0ErrorException@GostCrypt@@QAE@ABU01@@Z ENDP		; GostCrypt::ErrorException::ErrorException
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1ErrorException@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??1ErrorException@GostCrypt@@QAE@XZ PROC		; GostCrypt::ErrorException::~ErrorException, COMDAT
; _this$ = ecx
  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00003	56		 push	 esi
  00004	8d 71 08	 lea	 esi, DWORD PTR [ecx+8]
  00007	83 f8 08	 cmp	 eax, 8
  0000a	72 0b		 jb	 SHORT $LN9@ErrorExcep
  0000c	40		 inc	 eax
  0000d	8b ce		 mov	 ecx, esi
  0000f	50		 push	 eax
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN9@ErrorExcep:
  00017	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0001e	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00022	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00029	72 09		 jb	 SHORT $LN99@ErrorExcep
  0002b	8b 06		 mov	 eax, DWORD PTR [esi]
  0002d	33 c9		 xor	 ecx, ecx
  0002f	5e		 pop	 esi
  00030	66 89 08	 mov	 WORD PTR [eax], cx
  00033	c3		 ret	 0
$LN99@ErrorExcep:
  00034	33 c0		 xor	 eax, eax
  00036	66 89 06	 mov	 WORD PTR [esi], ax
  00039	5e		 pop	 esi
  0003a	c3		 ret	 0
??1ErrorException@GostCrypt@@QAE@XZ ENDP		; GostCrypt::ErrorException::~ErrorException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ?Show@ErrorException@GostCrypt@@UBEXPAUHWND__@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
?Show@ErrorException@GostCrypt@@UBEXPAUHWND__@@@Z PROC	; GostCrypt::ErrorException::Show, COMDAT
; _this$ = ecx

; 42   : 			if (ErrMsg.empty())

  00000	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  00004	75 0e		 jne	 SHORT $LN2@Show

; 43   : 				::Error (ErrLangId);

  00006	ff 71 04	 push	 DWORD PTR [ecx+4]
  00009	e8 00 00 00 00	 call	 _Error
  0000e	83 c4 04	 add	 esp, 4

; 46   : 		}

  00011	c2 04 00	 ret	 4
$LN2@Show:

; 44   : 			else
; 45   : 				::ErrorDirect (ErrMsg.c_str());

  00014	83 79 1c 08	 cmp	 DWORD PTR [ecx+28], 8
  00018	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  0001b	72 02		 jb	 SHORT $LN31@Show
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN31@Show:
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _ErrorDirect
  00025	59		 pop	 ecx

; 46   : 		}

  00026	c2 04 00	 ret	 4
?Show@ErrorException@GostCrypt@@UBEXPAUHWND__@@@Z ENDP	; GostCrypt::ErrorException::Show
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ??0ErrorException@GostCrypt@@QAE@PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_langId$ = 8						; size = 4
??0ErrorException@GostCrypt@@QAE@PAD@Z PROC		; GostCrypt::ErrorException::ErrorException, COMDAT
; _this$ = ecx

; 37   : 		ErrorException (char *langId) : ErrLangId (langId) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 45 08	 mov	 eax, DWORD PTR _langId$[ebp]
  00007	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000a	33 c0		 xor	 eax, eax
  0000c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ErrorException@GostCrypt@@6B@
  00012	c7 41 1c 07 00
	00 00		 mov	 DWORD PTR [ecx+28], 7
  00019	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00020	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
  00024	8b c1		 mov	 eax, ecx
  00026	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??0ErrorException@GostCrypt@@QAE@PAD@Z ENDP		; GostCrypt::ErrorException::ErrorException
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0Exception@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0Exception@GostCrypt@@QAE@ABU01@@Z PROC		; GostCrypt::Exception::Exception, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Exception@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c2 04 00	 ret	 4
??0Exception@GostCrypt@@QAE@ABU01@@Z ENDP		; GostCrypt::Exception::Exception
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0Exception@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??0Exception@GostCrypt@@QAE@XZ PROC			; GostCrypt::Exception::Exception, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Exception@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0Exception@GostCrypt@@QAE@XZ ENDP			; GostCrypt::Exception::Exception
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GContainer@ForEach@GostCrypt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GContainer@ForEach@GostCrypt@@UAEPAXI@Z PROC		; GostCrypt::ForEach::Container::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00010	74 0b		 je	 SHORT $LN7@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_GContainer@ForEach@GostCrypt@@UAEPAXI@Z ENDP		; GostCrypt::ForEach::Container::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?InnerIsNotEnd@Container@ForEach@GostCrypt@@QBE_NXZ
_TEXT	SEGMENT
?InnerIsNotEnd@Container@ForEach@GostCrypt@@QBE_NXZ PROC ; GostCrypt::ForEach::Container::InnerIsNotEnd, COMDAT
; _this$ = ecx

; 23   : 			bool InnerIsNotEnd () const { return InnerEndCondition = !InnerEndCondition; }

  00000	33 c0		 xor	 eax, eax
  00002	38 41 05	 cmp	 BYTE PTR [ecx+5], al
  00005	0f 94 c0	 sete	 al
  00008	88 41 05	 mov	 BYTE PTR [ecx+5], al
  0000b	c3		 ret	 0
?InnerIsNotEnd@Container@ForEach@GostCrypt@@QBE_NXZ ENDP ; GostCrypt::ForEach::Container::InnerIsNotEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?Continue@Container@ForEach@GostCrypt@@QBEXXZ
_TEXT	SEGMENT
?Continue@Container@ForEach@GostCrypt@@QBEXXZ PROC	; GostCrypt::ForEach::Container::Continue, COMDAT
; _this$ = ecx

; 22   : 			void Continue () const { InnerContinue = true; }

  00000	c6 41 04 01	 mov	 BYTE PTR [ecx+4], 1
  00004	c3		 ret	 0
?Continue@Container@ForEach@GostCrypt@@QBEXXZ ENDP	; GostCrypt::ForEach::Container::Continue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??1Container@ForEach@GostCrypt@@UAE@XZ
_TEXT	SEGMENT
??1Container@ForEach@GostCrypt@@UAE@XZ PROC		; GostCrypt::ForEach::Container::~Container, COMDAT
; _this$ = ecx

; 20   : 			virtual ~Container () { }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00006	c3		 ret	 0
??1Container@ForEach@GostCrypt@@UAE@XZ ENDP		; GostCrypt::ForEach::Container::~Container
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??0Container@ForEach@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??0Container@ForEach@GostCrypt@@QAE@XZ PROC		; GostCrypt::ForEach::Container::Container, COMDAT
; _this$ = ecx

; 19   : 			Container () : InnerContinue (true), InnerEndCondition (false) { }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	66 c7 41 04 01
	00		 mov	 WORD PTR [ecx+4], 1
  0000e	c3		 ret	 0
??0Container@ForEach@GostCrypt@@QAE@XZ ENDP		; GostCrypt::ForEach::Container::Container
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran, COMDAT
; _this$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset_exclusive@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset_exclusive@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset_exclusive, COMDAT
; _this$ = ecx

; 2276 : 		{	// checks whether _Off is in the bounds of [0, this->size())

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2277 : 		if (this->_Mysize() <= _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	76 04		 jbe	 SHORT $LN17@Check_offs

; 2279 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN17@Check_offs:

; 2278 : 			_Xran();

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN19@Check_offs:
$LN16@Check_offs:
  00019	cc		 int	 3
?_Check_offset_exclusive@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset_exclusive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	72 04		 jb	 SHORT $LN17@Check_offs

; 2273 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN17@Check_offs:

; 2272 : 			_Xran();

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN19@Check_offs:
$LN16@Check_offs:
  00019	cc		 int	 3
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen, COMDAT
; _this$ = ecx

; 2266 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2249 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 29		 je	 SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00010	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00014	72 23		 jb	 SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0e		 je	 SHORT $LN57@Tidy

; 2256 : 				_Traits::copy(this->_Bx()._Buf,

  0001d	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00020	50		 push	 eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	e8 00 00 00 00	 call	 _memcpy
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@Tidy:

; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  0002b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002e	8b ce		 mov	 ecx, esi
  00030	40		 inc	 eax
  00031	50		 push	 eax
  00032	53		 push	 ebx
  00033	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
  00038	5b		 pop	 ebx
$LN4@Tidy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00039	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7

; 2261 : 		_Eos(_Newsize);

  00040	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00044	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00047	72 0e		 jb	 SHORT $LN94@Tidy
  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	33 c9		 xor	 ecx, ecx
  0004d	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 2262 : 		}

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8

; 2261 : 		_Eos(_Newsize);

$LN94@Tidy:
  00057	33 c0		 xor	 eax, eax
  00059	66 89 04 7e	 mov	 WORD PTR [esi+edi*2], ax
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi

; 2262 : 		}

  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	74 2e		 je	 SHORT $LN4@Inside
  0000b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000e	83 f8 08	 cmp	 eax, 8
  00011	72 04		 jb	 SHORT $LN16@Inside
  00013	8b 31		 mov	 esi, DWORD PTR [ecx]
  00015	eb 02		 jmp	 SHORT $LN17@Inside
$LN16@Inside:
  00017	8b f1		 mov	 esi, ecx
$LN17@Inside:
  00019	3b d6		 cmp	 edx, esi
  0001b	72 1c		 jb	 SHORT $LN4@Inside
  0001d	83 f8 08	 cmp	 eax, 8
  00020	72 04		 jb	 SHORT $LN30@Inside
  00022	8b 31		 mov	 esi, DWORD PTR [ecx]
  00024	eb 02		 jmp	 SHORT $LN31@Inside
$LN30@Inside:
  00026	8b f1		 mov	 esi, ecx
$LN31@Inside:
  00028	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002b	8d 04 46	 lea	 eax, DWORD PTR [esi+eax*2]
  0002e	3b c2		 cmp	 eax, edx
  00030	76 07		 jbe	 SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

  00032	b0 01		 mov	 al, 1
  00034	5e		 pop	 esi

; 2244 : 		}

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

  00039	32 c0		 xor	 al, al
  0003b	5e		 pop	 esi

; 2244 : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2225 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH
  0000d	77 5b		 ja	 SHORT $LN89@Grow

; 2227 : 		if (this->_Myres() < _Newsize)

  0000f	39 71 14	 cmp	 DWORD PTR [ecx+20], esi
  00012	73 13		 jae	 SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00014	ff 71 10	 push	 DWORD PTR [ecx+16]
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0001d	85 f6		 test	 esi, esi
  0001f	5e		 pop	 esi
  00020	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00027	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  0002b	74 1f		 je	 SHORT $LN5@Grow
  0002d	83 fe 08	 cmp	 esi, 8
  00030	73 1a		 jae	 SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  00032	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00035	3b f0		 cmp	 esi, eax
  00037	0f 42 c6	 cmovb	 eax, esi
  0003a	50		 push	 eax
  0003b	6a 01		 push	 1
  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
  00042	85 f6		 test	 esi, esi
  00044	5e		 pop	 esi
  00045	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

  0004c	85 f6		 test	 esi, esi
  0004e	75 12		 jne	 SHORT $LN88@Grow

; 2233 : 			_Eos(0);	// new size is zero, just null terminate

  00050	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00054	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  00057	72 02		 jb	 SHORT $LN80@Grow
  00059	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN80@Grow:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 f6		 test	 esi, esi
  0005f	66 89 01	 mov	 WORD PTR [ecx], ax
$LN88@Grow:
  00062	0f 95 c0	 setne	 al
  00065	5e		 pop	 esi

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
$LN89@Grow:

; 2226 : 			_Xlen();	// result too long

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0006f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN91@Grow:
$LN87@Grow:
  00074	cc		 int	 3
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

  00003	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00007	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0000a	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000d	72 0c		 jb	 SHORT $LN11@Eos
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	33 c9		 xor	 ecx, ecx
  00013	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 2220 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

$LN11@Eos:
  0001b	33 c0		 xor	 eax, eax
  0001d	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax

; 2220 : 		}

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$1$ = -24						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f8		 mov	 edi, eax
  00035	83 cf 07	 or	 edi, 7

; 2184 : 		if (max_size() < _Newres)

  00038	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  0003e	76 04		 jbe	 SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

  00040	8b f8		 mov	 edi, eax
  00042	eb 27		 jmp	 SHORT $LN108@Copy
$LN2@Copy:

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  00044	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00047	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0004c	f7 e7		 mul	 edi
  0004e	8b cb		 mov	 ecx, ebx
  00050	d1 e9		 shr	 ecx, 1
  00052	d1 ea		 shr	 edx, 1
  00054	3b ca		 cmp	 ecx, edx
  00056	76 13		 jbe	 SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00058	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH

; 2189 : 			_Newres = this->_Myres()

  0005d	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]
  00060	2b c1		 sub	 eax, ecx
  00062	3b d8		 cmp	 ebx, eax
  00064	76 05		 jbe	 SHORT $LN108@Copy

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()

  00066	bf fe ff ff 7f	 mov	 edi, 2147483646		; 7ffffffeH
$LN108@Copy:

; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  0006b	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0006e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00075	50		 push	 eax
  00076	8b ce		 mov	 ecx, esi
  00078	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  0007d	8b d0		 mov	 edx, eax
  0007f	eb 29		 jmp	 SHORT $LN429@Copy
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  00081	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax
  0008a	40		 inc	 eax
  0008b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0008e	50		 push	 eax
  0008f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00093	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  00098	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

  0009b	b8 00 00 00 00	 mov	 eax, $LN426@Copy
  000a0	c3		 ret	 0
$LN426@Copy:
  000a1	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000a4	8b 7d 08	 mov	 edi, DWORD PTR __Newres$[ebp]
  000a7	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN429@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

  000aa	8b 5d 0c	 mov	 ebx, DWORD PTR __Oldlen$[ebp]
  000ad	89 55 e8	 mov	 DWORD PTR __Ptr$1$[ebp], edx
  000b0	85 db		 test	 ebx, ebx
  000b2	74 1e		 je	 SHORT $LN260@Copy

; 2208 : 			_Traits::copy(_Unfancy(_Ptr), this->_Myptr(),

  000b4	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000b8	72 04		 jb	 SHORT $LN251@Copy
  000ba	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000bc	eb 02		 jmp	 SHORT $LN252@Copy
$LN251@Copy:
  000be	8b ce		 mov	 ecx, esi
$LN252@Copy:
  000c0	85 db		 test	 ebx, ebx
  000c2	74 0e		 je	 SHORT $LN260@Copy
  000c4	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  000c7	50		 push	 eax
  000c8	51		 push	 ecx
  000c9	52		 push	 edx
  000ca	e8 00 00 00 00	 call	 _memcpy
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN260@Copy:

; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);

  000d2	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000d5	83 f8 08	 cmp	 eax, 8
  000d8	72 0b		 jb	 SHORT $LN266@Copy
  000da	40		 inc	 eax
  000db	8b ce		 mov	 ecx, esi
  000dd	50		 push	 eax
  000de	ff 36		 push	 DWORD PTR [esi]
  000e0	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN266@Copy:
  000e5	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  000ec	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000f0	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000f7	72 04		 jb	 SHORT $LN356@Copy
  000f9	8b 06		 mov	 eax, DWORD PTR [esi]
  000fb	eb 02		 jmp	 SHORT $LN357@Copy
$LN356@Copy:
  000fd	8b c6		 mov	 eax, esi
$LN357@Copy:
  000ff	33 c9		 xor	 ecx, ecx
  00101	66 89 08	 mov	 WORD PTR [eax], cx

; 2211 : 		this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Ptr);

  00104	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  00107	89 06		 mov	 DWORD PTR [esi], eax

; 2212 : 		this->_Myres() = _Newres;

  00109	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 2213 : 		_Eos(_Oldlen);

  0010c	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00110	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00113	72 02		 jb	 SHORT $LN420@Copy
  00115	8b f0		 mov	 esi, eax
$LN420@Copy:
  00117	33 c0		 xor	 eax, eax
  00119	66 89 04 5e	 mov	 WORD PTR [esi+ebx*2], ax

; 2214 : 		}

  0011d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00120	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00127	59		 pop	 ecx
  00128	5f		 pop	 edi
  00129	5e		 pop	 esi
  0012a	5b		 pop	 ebx
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

  00131	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00134	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00137	83 f8 08	 cmp	 eax, 8
  0013a	72 0b		 jb	 SHORT $LN144@Copy
  0013c	40		 inc	 eax
  0013d	8b ce		 mov	 ecx, esi
  0013f	50		 push	 eax
  00140	ff 36		 push	 DWORD PTR [esi]
  00142	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN144@Copy:
  00147	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0014e	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00152	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00159	72 02		 jb	 SHORT $LN235@Copy
  0015b	8b 36		 mov	 esi, DWORD PTR [esi]
$LN235@Copy:
  0015d	33 c0		 xor	 eax, eax

; 2203 : 			_RERAISE;

  0015f	50		 push	 eax
  00160	50		 push	 eax
  00161	66 89 06	 mov	 WORD PTR [esi], ax
  00164	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN430@Copy:
$LN428@Copy:
  00169	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::get_allocator, COMDAT
; _this$ = ecx

; 2168 : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2169 : 		allocator_type _Ret(this->_Getal());
; 2170 : 		return (_Ret);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2171 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

  00009	39 45 0c	 cmp	 DWORD PTR __Size$[ebp], eax
  0000c	0f 46 45 0c	 cmovbe	 eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr, COMDAT
; _this$ = ecx

; 2088 : 		{	// return [_Off, _Off + _Count) as new string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 2089 : 		return (_Myt(*this, _Off, _Count, get_allocator()));

  00005	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	33 c0		 xor	 eax, eax
  0000d	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00017	51		 push	 ecx
  00018	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0001f	8b ce		 mov	 ecx, esi
  00021	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00028	66 89 06	 mov	 WORD PTR [esi], ax
  0002b	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi

; 2090 : 		}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 0c 00	 ret	 12			; 0000000cH
?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::empty, COMDAT
; _this$ = ecx

; 1803 : 		{	// test if sequence is empty

  00000	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00004	0f 94 c0	 sete	 al

; 1804 : 		return (this->_Mysize() == 0);
; 1805 : 		}

  00007	c3		 ret	 0
?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::reserve, COMDAT
; _this$ = ecx

; 1793 : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Newcap$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f8		 cmp	 edi, eax
  0000f	77 22		 ja	 SHORT $LN47@reserve
  00011	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  00014	74 1d		 je	 SHORT $LN47@reserve

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

  00016	6a 01		 push	 1
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
  0001e	84 c0		 test	 al, al
  00020	74 11		 je	 SHORT $LN47@reserve

; 1798 : 				_Eos(_Size);

  00022	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00026	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00029	72 02		 jb	 SHORT $LN42@reserve
  0002b	8b 36		 mov	 esi, DWORD PTR [esi]
$LN42@reserve:
  0002d	33 c0		 xor	 eax, eax
  0002f	66 89 04 7e	 mov	 WORD PTR [esi+edi*2], ax
$LN47@reserve:
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi

; 1799 : 			}
; 1800 : 		}

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::capacity, COMDAT
; _this$ = ecx

; 1789 : 		return (this->_Myres());

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1790 : 		}

  00003	c3		 ret	 0
?capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH

; 1772 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT
; _this$ = ecx

; 1765 : 		return (this->_Mysize());

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1766 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 1743 : 		return (this->_Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN13@c_str
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1744 : 		}

  00008	c3		 ret	 0

; 1743 : 		return (this->_Myptr());

$LN13@c_str:
  00009	8b c1		 mov	 eax, ecx

; 1744 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[], COMDAT
; _this$ = ecx

; 1679 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1680 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1681 : 		if (this->_Mysize() < _Off)	// sic
; 1682 : 			_DEBUG_ERROR("string subscript out of range");
; 1683 : 
; 1684 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1685 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1686 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1687 : 
; 1688 : 		return (this->_Myptr()[_Off]);

  00003	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	72 02		 jb	 SHORT $LN13@operator
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN13@operator:
  0000e	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 1689 : 		}

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?at@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?at@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::at, COMDAT
; _this$ = ecx

; 1667 : 		{	// subscript mutable sequence with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1668 : 		_Check_offset_exclusive(_Off);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	76 0f		 jbe	 SHORT $LN34@at

; 1669 : 		return (this->_Myptr()[_Off]);

  0000b	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  0000f	72 02		 jb	 SHORT $LN30@at
  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN30@at:
  00013	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 1670 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN34@at:

; 1668 : 		_Check_offset_exclusive(_Off);

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0001f	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN36@at:
$LN33@at:
  00024	cc		 int	 3
?at@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAA_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::at
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end, COMDAT
; _this$ = ecx

; 1606 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1607 : 		auto _Mydata = &this->_Get_data();
; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

  00003	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00007	72 11		 jb	 SHORT $LN11@end
  00009	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000e	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  00011	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00014	89 08		 mov	 DWORD PTR [eax], ecx

; 1609 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1607 : 		auto _Mydata = &this->_Get_data();
; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

$LN11@end:
  0001a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0001d	8b d1		 mov	 edx, ecx
  0001f	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00025	89 08		 mov	 DWORD PTR [eax], ecx

; 1609 : 		}

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin, COMDAT
; _this$ = ecx

; 1594 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1595 : 		auto _Mydata = &this->_Get_data();
; 1596 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));

  00003	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	72 02		 jb	 SHORT $LN11@begin
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN11@begin:
  0000e	89 08		 mov	 DWORD PTR [eax], ecx

; 1597 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace, COMDAT
; _this$ = ecx

; 1584 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1585 : 		if (_First2 == _Last2)

  00003	8b 55 10	 mov	 edx, DWORD PTR __First2$[ebp]

; 1586 : 			erase(_First - begin(), _Last - _First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 4d 14	 mov	 ecx, DWORD PTR __Last2$[ebp]
  0000f	3b d1		 cmp	 edx, ecx
  00011	75 39		 jne	 SHORT $LN2@replace
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00016	2b c8		 sub	 ecx, eax
  00018	d1 f9		 sar	 ecx, 1
  0001a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0001e	72 16		 jb	 SHORT $LN24@replace
  00020	8b 16		 mov	 edx, DWORD PTR [esi]
  00022	2b c2		 sub	 eax, edx
  00024	51		 push	 ecx
  00025	d1 f8		 sar	 eax, 1
  00027	8b ce		 mov	 ecx, esi
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  0002f	8b c6		 mov	 eax, esi
  00031	5e		 pop	 esi

; 1591 : 		}

  00032	5d		 pop	 ebp
  00033	c2 10 00	 ret	 16			; 00000010H

; 1586 : 			erase(_First - begin(), _Last - _First);

$LN24@replace:
  00036	8b d6		 mov	 edx, esi
  00038	2b c2		 sub	 eax, edx
  0003a	51		 push	 ecx
  0003b	d1 f8		 sar	 eax, 1
  0003d	8b ce		 mov	 ecx, esi
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  00045	8b c6		 mov	 eax, esi
  00047	5e		 pop	 esi

; 1591 : 		}

  00048	5d		 pop	 ebp
  00049	c2 10 00	 ret	 16			; 00000010H
$LN2@replace:
  0004c	53		 push	 ebx
  0004d	57		 push	 edi

; 1587 : 		else
; 1588 : 			replace(_First - begin(), _Last - _First,

  0004e	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  00051	2b ca		 sub	 ecx, edx
  00053	2b f8		 sub	 edi, eax
  00055	d1 f9		 sar	 ecx, 1
  00057	d1 ff		 sar	 edi, 1
  00059	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0005d	72 04		 jb	 SHORT $LN76@replace
  0005f	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00061	eb 02		 jmp	 SHORT $LN77@replace
$LN76@replace:
  00063	8b de		 mov	 ebx, esi
$LN77@replace:
  00065	51		 push	 ecx
  00066	52		 push	 edx
  00067	2b c3		 sub	 eax, ebx
  00069	8b ce		 mov	 ecx, esi
  0006b	57		 push	 edi
  0006c	d1 f8		 sar	 eax, 1
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace
  00074	5f		 pop	 edi
  00075	5b		 pop	 ebx

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  00076	8b c6		 mov	 eax, esi
  00078	5e		 pop	 esi

; 1591 : 		}

  00079	5d		 pop	 ebp
  0007a	c2 10 00	 ret	 16			; 00000010H
?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIPB_WI@Z
_TEXT	SEGMENT
__Nm$1$ = -12						; size = 4
__N0$2$ = -8						; size = 4
tv906 = -4						; size = 4
__Off$ = 8						; size = 4
tv907 = 12						; size = 4
tv904 = 12						; size = 4
tv873 = 12						; size = 4
__N0$ = 12						; size = 4
tv903 = 16						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIPB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace, COMDAT
; _this$ = ecx

; 1453 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1454 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1455 : 		if (_Inside(_Ptr))

  00007	8b 5d 10	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 db		 test	 ebx, ebx
  0000f	74 50		 je	 SHORT $LN2@replace
  00011	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00014	83 f9 08	 cmp	 ecx, 8
  00017	72 04		 jb	 SHORT $LN24@replace
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	eb 02		 jmp	 SHORT $LN25@replace
$LN24@replace:
  0001d	8b c6		 mov	 eax, esi
$LN25@replace:
  0001f	3b d8		 cmp	 ebx, eax
  00021	72 3e		 jb	 SHORT $LN2@replace
  00023	83 f9 08	 cmp	 ecx, 8
  00026	72 04		 jb	 SHORT $LN38@replace
  00028	8b 16		 mov	 edx, DWORD PTR [esi]
  0002a	eb 02		 jmp	 SHORT $LN39@replace
$LN38@replace:
  0002c	8b d6		 mov	 edx, esi
$LN39@replace:
  0002e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00031	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00034	3b c3		 cmp	 eax, ebx
  00036	76 29		 jbe	 SHORT $LN2@replace

; 1456 : 			return (replace(_Off, _N0, *this,

  00038	83 f9 08	 cmp	 ecx, 8
  0003b	72 04		 jb	 SHORT $LN61@replace
  0003d	8b 06		 mov	 eax, DWORD PTR [esi]
  0003f	eb 02		 jmp	 SHORT $LN62@replace
$LN61@replace:
  00041	8b c6		 mov	 eax, esi
$LN62@replace:
  00043	ff 75 14	 push	 DWORD PTR __Count$[ebp]
  00046	2b d8		 sub	 ebx, eax
  00048	8b ce		 mov	 ecx, esi
  0004a	d1 fb		 sar	 ebx, 1
  0004c	53		 push	 ebx
  0004d	56		 push	 esi
  0004e	ff 75 0c	 push	 DWORD PTR __N0$[ebp]
  00051	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00054	e8 00 00 00 00	 call	 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx

; 1480 : 		}

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 10 00	 ret	 16			; 00000010H
$LN2@replace:

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);

  00061	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00064	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00067	3b c1		 cmp	 eax, ecx
  00069	0f 82 97 01 00
	00		 jb	 $LN318@replace

; 1460 : 		_N0 = _Clamp_suffix_size(_Off, _N0);

  0006f	8b d0		 mov	 edx, eax
  00071	2b d1		 sub	 edx, ecx
  00073	8b 4d 0c	 mov	 ecx, DWORD PTR __N0$[ebp]
  00076	3b ca		 cmp	 ecx, edx
  00078	57		 push	 edi

; 1461 : 		if (npos - _Count <= this->_Mysize() - _N0)

  00079	8b 7d 14	 mov	 edi, DWORD PTR __Count$[ebp]
  0007c	0f 47 ca	 cmova	 ecx, edx
  0007f	2b c1		 sub	 eax, ecx
  00081	89 4d f8	 mov	 DWORD PTR __N0$2$[ebp], ecx
  00084	89 45 0c	 mov	 DWORD PTR tv873[ebp], eax
  00087	8b c7		 mov	 eax, edi
  00089	f7 d0		 not	 eax
  0008b	3b 45 0c	 cmp	 eax, DWORD PTR tv873[ebp]
  0008e	0f 86 7c 01 00
	00		 jbe	 $LN320@replace

; 1463 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;

  00094	2b d1		 sub	 edx, ecx
  00096	89 55 f4	 mov	 DWORD PTR __Nm$1$[ebp], edx

; 1464 : 
; 1465 : 		if (_Count < _N0)

  00099	3b f9		 cmp	 edi, ecx
  0009b	73 4e		 jae	 SHORT $LN145@replace

; 1466 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  0009d	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000a0	83 f8 08	 cmp	 eax, 8
  000a3	72 0a		 jb	 SHORT $LN124@replace
  000a5	8b 1e		 mov	 ebx, DWORD PTR [esi]
  000a7	89 5d 0c	 mov	 DWORD PTR tv907[ebp], ebx
  000aa	8b 5d 10	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  000ad	eb 03		 jmp	 SHORT $LN125@replace
$LN124@replace:
  000af	89 75 0c	 mov	 DWORD PTR tv907[ebp], esi
$LN125@replace:
  000b2	83 f8 08	 cmp	 eax, 8
  000b5	72 07		 jb	 SHORT $LN138@replace
  000b7	8b 06		 mov	 eax, DWORD PTR [esi]
  000b9	89 45 fc	 mov	 DWORD PTR tv906[ebp], eax
  000bc	eb 03		 jmp	 SHORT $LN139@replace
$LN138@replace:
  000be	89 75 fc	 mov	 DWORD PTR tv906[ebp], esi
$LN139@replace:
  000c1	85 d2		 test	 edx, edx
  000c3	74 26		 je	 SHORT $LN145@replace
  000c5	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  000c8	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000cb	50		 push	 eax
  000cc	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  000cf	8b 4d 0c	 mov	 ecx, DWORD PTR tv907[ebp]
  000d2	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000d5	8b 4d fc	 mov	 ecx, DWORD PTR tv906[ebp]
  000d8	50		 push	 eax
  000d9	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  000dc	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _memmove
  000e5	8b 4d f8	 mov	 ecx, DWORD PTR __N0$2$[ebp]
  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN145@replace:

; 1467 : 				this->_Myptr() + _Off + _N0,
; 1468 : 				_Nm);	// smaller hole, move tail up
; 1469 : 		const size_type _Num = this->_Mysize() + _Count - _N0;

  000eb	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000ee	8b f8		 mov	 edi, eax
  000f0	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  000f3	2b f9		 sub	 edi, ecx
  000f5	03 fa		 add	 edi, edx

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

  000f7	85 d2		 test	 edx, edx
  000f9	75 08		 jne	 SHORT $LN6@replace
  000fb	85 c9		 test	 ecx, ecx
  000fd	0f 84 f8 00 00
	00		 je	 $LN312@replace
$LN6@replace:
  00103	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00109	0f 87 0b 01 00
	00		 ja	 $LN321@replace
  0010f	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00112	73 31		 jae	 SHORT $LN159@replace
  00114	50		 push	 eax
  00115	57		 push	 edi
  00116	8b ce		 mov	 ecx, esi
  00118	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0011d	8b 4d f8	 mov	 ecx, DWORD PTR __N0$2$[ebp]
  00120	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  00123	85 ff		 test	 edi, edi
  00125	0f 84 d0 00 00
	00		 je	 $LN312@replace
$LN317@replace:

; 1472 : 			{	// make room and rearrange
; 1473 : 			if (_N0 < _Count)

  0012b	3b ca		 cmp	 ecx, edx
  0012d	0f 83 80 00 00
	00		 jae	 $LN274@replace

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

  00133	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00136	83 f8 08	 cmp	 eax, 8
  00139	72 39		 jb	 SHORT $LN253@replace
  0013b	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0013d	89 5d 0c	 mov	 DWORD PTR tv904[ebp], ebx
  00140	8b 5d 10	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00143	eb 32		 jmp	 SHORT $LN254@replace

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

$LN159@replace:
  00145	85 ff		 test	 edi, edi
  00147	75 e2		 jne	 SHORT $LN317@replace
  00149	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0014c	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00150	72 12		 jb	 SHORT $LN236@replace
  00152	8b 06		 mov	 eax, DWORD PTR [esi]
  00154	33 c9		 xor	 ecx, ecx
  00156	5f		 pop	 edi
  00157	66 89 08	 mov	 WORD PTR [eax], cx

; 1478 : 			}
; 1479 : 		return (*this);

  0015a	8b c6		 mov	 eax, esi
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx

; 1480 : 		}

  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 10 00	 ret	 16			; 00000010H

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

$LN236@replace:
  00164	8b c6		 mov	 eax, esi
  00166	33 c9		 xor	 ecx, ecx
  00168	5f		 pop	 edi
  00169	5e		 pop	 esi
  0016a	5b		 pop	 ebx
  0016b	66 89 08	 mov	 WORD PTR [eax], cx

; 1480 : 		}

  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c2 10 00	 ret	 16			; 00000010H

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

$LN253@replace:
  00174	89 75 0c	 mov	 DWORD PTR tv904[ebp], esi
$LN254@replace:
  00177	83 f8 08	 cmp	 eax, 8
  0017a	72 07		 jb	 SHORT $LN267@replace
  0017c	8b 06		 mov	 eax, DWORD PTR [esi]
  0017e	89 45 10	 mov	 DWORD PTR tv903[ebp], eax
  00181	eb 03		 jmp	 SHORT $LN268@replace
$LN267@replace:
  00183	89 75 10	 mov	 DWORD PTR tv903[ebp], esi
$LN268@replace:
  00186	8b 45 f4	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00189	85 c0		 test	 eax, eax
  0018b	74 26		 je	 SHORT $LN274@replace
  0018d	03 c0		 add	 eax, eax
  0018f	50		 push	 eax
  00190	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00193	03 c1		 add	 eax, ecx
  00195	8b 4d 0c	 mov	 ecx, DWORD PTR tv904[ebp]
  00198	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0019b	8b 4d 10	 mov	 ecx, DWORD PTR tv903[ebp]
  0019e	50		 push	 eax
  0019f	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  001a2	03 c2		 add	 eax, edx
  001a4	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 _memmove
  001ad	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  001b0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN274@replace:

; 1475 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1476 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

  001b3	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  001b7	72 04		 jb	 SHORT $LN287@replace
  001b9	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001bb	eb 02		 jmp	 SHORT $LN288@replace
$LN287@replace:
  001bd	8b ce		 mov	 ecx, esi
$LN288@replace:
  001bf	85 d2		 test	 edx, edx
  001c1	74 14		 je	 SHORT $LN294@replace
  001c3	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  001c6	50		 push	 eax
  001c7	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  001ca	53		 push	 ebx
  001cb	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 _memcpy
  001d4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN294@replace:

; 1477 : 			_Eos(_Num);

  001d7	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  001db	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  001de	72 13		 jb	 SHORT $LN307@replace
  001e0	8b 06		 mov	 eax, DWORD PTR [esi]
  001e2	33 c9		 xor	 ecx, ecx
  001e4	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1478 : 			}
; 1479 : 		return (*this);

  001e8	8b c6		 mov	 eax, esi
  001ea	5f		 pop	 edi
  001eb	5e		 pop	 esi
  001ec	5b		 pop	 ebx

; 1480 : 		}

  001ed	8b e5		 mov	 esp, ebp
  001ef	5d		 pop	 ebp
  001f0	c2 10 00	 ret	 16			; 00000010H

; 1477 : 			_Eos(_Num);

$LN307@replace:
  001f3	8b c6		 mov	 eax, esi
  001f5	33 c9		 xor	 ecx, ecx
  001f7	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN312@replace:

; 1478 : 			}
; 1479 : 		return (*this);

  001fb	5f		 pop	 edi
  001fc	8b c6		 mov	 eax, esi
  001fe	5e		 pop	 esi
  001ff	5b		 pop	 ebx

; 1480 : 		}

  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c2 10 00	 ret	 16			; 00000010H
$LN318@replace:

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);

  00206	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0020b	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN322@replace:
$LN320@replace:

; 1462 : 			_Xlen();	// result too long

  00210	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00215	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN323@replace:
$LN321@replace:

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

  0021a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0021f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN324@replace:
$LN315@replace:
  00224	cc		 int	 3
?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIPB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z
_TEXT	SEGMENT
tv1837 = -12						; size = 4
__Max_effective_size$1$ = -12				; size = 4
tv1838 = -8						; size = 4
tv1854 = -4						; size = 4
tv1842 = -4						; size = 4
__Nm$1$ = -4						; size = 4
tv1836 = 8						; size = 4
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
tv1846 = 16						; size = 4
tv1814 = 16						; size = 4
__Right$ = 16						; size = 4
tv1844 = 20						; size = 4
tv1840 = 20						; size = 4
__Roff$ = 20						; size = 4
tv1827 = 24						; size = 4
__Newsize$1$ = 24					; size = 4
__Count$ = 24						; size = 4
?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace, COMDAT
; _this$ = ecx

; 1389 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 1390 : 		_Check_offset(_Off);

  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0000c	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0000f	3b d1		 cmp	 edx, ecx
  00011	0f 82 ed 03 00
	00		 jb	 $LN625@replace

; 1391 : 		_Right._Check_offset(_Roff);

  00017	53		 push	 ebx
  00018	8b 5d 10	 mov	 ebx, DWORD PTR __Right$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  0001f	3b 7d 14	 cmp	 edi, DWORD PTR __Roff$[ebp]
  00022	0f 82 e6 03 00
	00		 jb	 $LN627@replace

; 1392 : 		_N0 = _Clamp_suffix_size(_Off, _N0);

  00028	8b 5d 0c	 mov	 ebx, DWORD PTR __N0$[ebp]
  0002b	8b c2		 mov	 eax, edx
  0002d	2b c1		 sub	 eax, ecx
  0002f	3b d8		 cmp	 ebx, eax
  00031	89 45 fc	 mov	 DWORD PTR __Nm$1$[ebp], eax
  00034	0f 47 d8	 cmova	 ebx, eax

; 1393 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00037	2b 7d 14	 sub	 edi, DWORD PTR __Roff$[ebp]
  0003a	89 7d f4	 mov	 DWORD PTR __Max_effective_size$1$[ebp], edi
  0003d	8b 7d 18	 mov	 edi, DWORD PTR __Count$[ebp]
  00040	3b 7d f4	 cmp	 edi, DWORD PTR __Max_effective_size$1$[ebp]
  00043	89 5d 0c	 mov	 DWORD PTR __N0$[ebp], ebx

; 1394 : 		if (npos - _Count <= this->_Mysize() - _N0)

  00046	8b da		 mov	 ebx, edx
  00048	0f 47 7d f4	 cmova	 edi, DWORD PTR __Max_effective_size$1$[ebp]
  0004c	2b 5d 0c	 sub	 ebx, DWORD PTR __N0$[ebp]
  0004f	8b c7		 mov	 eax, edi
  00051	f7 d0		 not	 eax
  00053	89 5d 18	 mov	 DWORD PTR tv1827[ebp], ebx
  00056	3b c3		 cmp	 eax, ebx
  00058	8b 5d 10	 mov	 ebx, DWORD PTR __Right$[ebp]
  0005b	0f 86 b7 03 00
	00		 jbe	 $LN628@replace

; 1396 : 
; 1397 : 		const size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1398 : 		const size_type _Newsize = this->_Mysize() + _Count - _N0;

  00061	8b 4d 18	 mov	 ecx, DWORD PTR tv1827[ebp]
  00064	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00067	03 cf		 add	 ecx, edi
  00069	2b 45 0c	 sub	 eax, DWORD PTR __N0$[ebp]

; 1399 : 		if (this->_Mysize() < _Newsize)

  0006c	3b d1		 cmp	 edx, ecx
  0006e	89 4d 18	 mov	 DWORD PTR __Newsize$1$[ebp], ecx
  00071	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00074	89 45 fc	 mov	 DWORD PTR __Nm$1$[ebp], eax
  00077	73 49		 jae	 SHORT $LN194@replace

; 1400 : 			_Grow(_Newsize);

  00079	81 7d 18 fe ff
	ff 7f		 cmp	 DWORD PTR __Newsize$1$[ebp], 2147483646 ; 7ffffffeH
  00080	0f 87 9c 03 00
	00		 ja	 $LN629@replace
  00086	8b 5d 18	 mov	 ebx, DWORD PTR __Newsize$1$[ebp]
  00089	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  0008c	8b 5d 10	 mov	 ebx, DWORD PTR __Right$[ebp]
  0008f	73 10		 jae	 SHORT $LN112@replace
  00091	52		 push	 edx
  00092	ff 75 18	 push	 DWORD PTR __Newsize$1$[ebp]
  00095	8b ce		 mov	 ecx, esi
  00097	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0009c	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  0009f	eb 1e		 jmp	 SHORT $LN622@replace
$LN112@replace:
  000a1	83 7d 18 00	 cmp	 DWORD PTR __Newsize$1$[ebp], 0
  000a5	75 1b		 jne	 SHORT $LN194@replace
  000a7	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000ae	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000b2	72 04		 jb	 SHORT $LN189@replace
  000b4	8b 16		 mov	 edx, DWORD PTR [esi]
  000b6	eb 02		 jmp	 SHORT $LN190@replace
$LN189@replace:
  000b8	8b d6		 mov	 edx, esi
$LN190@replace:
  000ba	33 c9		 xor	 ecx, ecx
  000bc	66 89 0a	 mov	 WORD PTR [edx], cx
$LN622@replace:
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
$LN194@replace:

; 1401 : 
; 1402 : 		if (_Count == _N0)

  000c2	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  000c5	3b fa		 cmp	 edi, edx
  000c7	75 2f		 jne	 SHORT $LN4@replace

; 1403 : 			{	// only one movement required, so _Traits::move handles any overlap
; 1404 : 			_Traits::move(this->_Myptr() + _Off,

  000c9	83 7b 14 08	 cmp	 DWORD PTR [ebx+20], 8
  000cd	72 02		 jb	 SHORT $LN206@replace
  000cf	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN206@replace:
  000d1	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000d5	72 04		 jb	 SHORT $LN220@replace
  000d7	8b 16		 mov	 edx, DWORD PTR [esi]
  000d9	eb 02		 jmp	 SHORT $LN221@replace
$LN220@replace:
  000db	8b d6		 mov	 edx, esi
$LN221@replace:
  000dd	85 ff		 test	 edi, edi
  000df	0f 84 f1 02 00
	00		 je	 $LN601@replace
  000e5	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  000e8	50		 push	 eax
  000e9	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  000ec	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  000ef	50		 push	 eax
  000f0	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000f3	e9 d5 02 00 00	 jmp	 $LN623@replace
$LN4@replace:

; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (this != &_Right)

  000f8	3b f3		 cmp	 esi, ebx
  000fa	0f 84 80 00 00
	00		 je	 $LN6@replace

; 1408 : 			{	// no overlap, just move down and copy in new stuff
; 1409 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00100	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00103	83 fa 08	 cmp	 edx, 8
  00106	72 0a		 jb	 SHORT $LN240@replace
  00108	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0010a	89 5d fc	 mov	 DWORD PTR tv1854[ebp], ebx
  0010d	8b 5d 10	 mov	 ebx, DWORD PTR __Right$[ebp]
  00110	eb 06		 jmp	 SHORT $LN241@replace
$LN240@replace:
  00112	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00115	89 75 fc	 mov	 DWORD PTR tv1854[ebp], esi
$LN241@replace:
  00118	83 fa 08	 cmp	 edx, 8
  0011b	72 04		 jb	 SHORT $LN254@replace
  0011d	8b 16		 mov	 edx, DWORD PTR [esi]
  0011f	eb 02		 jmp	 SHORT $LN255@replace
$LN254@replace:
  00121	8b d6		 mov	 edx, esi
$LN255@replace:
  00123	85 c0		 test	 eax, eax
  00125	74 21		 je	 SHORT $LN261@replace
  00127	8b 5d fc	 mov	 ebx, DWORD PTR tv1854[ebp]
  0012a	03 c0		 add	 eax, eax
  0012c	50		 push	 eax
  0012d	8b 45 0c	 mov	 eax, DWORD PTR __N0$[ebp]
  00130	03 c1		 add	 eax, ecx
  00132	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  00135	50		 push	 eax
  00136	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00139	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 _memmove
  00142	8b 5d 10	 mov	 ebx, DWORD PTR __Right$[ebp]
  00145	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN261@replace:

; 1410 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1411 : 			_Traits::copy(this->_Myptr() + _Off,

  00148	83 7b 14 08	 cmp	 DWORD PTR [ebx+20], 8
  0014c	72 02		 jb	 SHORT $LN274@replace
  0014e	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN274@replace:
  00150	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00154	72 04		 jb	 SHORT $LN288@replace
  00156	8b 16		 mov	 edx, DWORD PTR [esi]
  00158	eb 02		 jmp	 SHORT $LN289@replace
$LN288@replace:
  0015a	8b d6		 mov	 edx, esi
$LN289@replace:
  0015c	85 ff		 test	 edi, edi
  0015e	0f 84 72 02 00
	00		 je	 $LN601@replace
  00164	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00167	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  0016a	50		 push	 eax
  0016b	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  0016e	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  00171	50		 push	 eax
  00172	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 _memcpy
  0017b	e9 53 02 00 00	 jmp	 $LN624@replace
$LN6@replace:

; 1412 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1413 : 			}
; 1414 : 		else if (_Count < _N0)

  00180	3b fa		 cmp	 edi, edx
  00182	73 72		 jae	 SHORT $LN8@replace

; 1415 : 			{	// hole doesn't get larger, just copy in substring
; 1416 : 			_Traits::move(this->_Myptr() + _Off,

  00184	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00187	83 f8 08	 cmp	 eax, 8
  0018a	72 04		 jb	 SHORT $LN308@replace
  0018c	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0018e	eb 02		 jmp	 SHORT $LN309@replace
$LN308@replace:
  00190	8b de		 mov	 ebx, esi
$LN309@replace:
  00192	83 f8 08	 cmp	 eax, 8
  00195	72 04		 jb	 SHORT $LN322@replace
  00197	8b 16		 mov	 edx, DWORD PTR [esi]
  00199	eb 02		 jmp	 SHORT $LN323@replace
$LN322@replace:
  0019b	8b d6		 mov	 edx, esi
$LN323@replace:
  0019d	85 ff		 test	 edi, edi
  0019f	74 17		 je	 SHORT $LN329@replace
  001a1	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  001a4	50		 push	 eax
  001a5	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  001a8	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  001ab	50		 push	 eax
  001ac	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 _memmove
  001b5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN329@replace:

; 1417 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1418 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  001b8	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001bb	83 f8 08	 cmp	 eax, 8
  001be	72 04		 jb	 SHORT $LN342@replace
  001c0	8b 1e		 mov	 ebx, DWORD PTR [esi]
  001c2	eb 02		 jmp	 SHORT $LN343@replace
$LN342@replace:
  001c4	8b de		 mov	 ebx, esi
$LN343@replace:
  001c6	83 f8 08	 cmp	 eax, 8
  001c9	72 04		 jb	 SHORT $LN356@replace
  001cb	8b 16		 mov	 edx, DWORD PTR [esi]
  001cd	eb 02		 jmp	 SHORT $LN357@replace
$LN356@replace:
  001cf	8b d6		 mov	 edx, esi
$LN357@replace:
  001d1	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  001d4	85 c0		 test	 eax, eax
  001d6	0f 84 fa 01 00
	00		 je	 $LN601@replace
  001dc	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  001df	03 c0		 add	 eax, eax
  001e1	50		 push	 eax
  001e2	8b 45 0c	 mov	 eax, DWORD PTR __N0$[ebp]
  001e5	03 c1		 add	 eax, ecx
  001e7	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  001ea	50		 push	 eax
  001eb	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  001ee	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  001f1	e9 d7 01 00 00	 jmp	 $LN623@replace
$LN8@replace:

; 1419 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1420 : 			}
; 1421 : 		else if (_Roff <= _Off)

  001f6	8b 5d 14	 mov	 ebx, DWORD PTR __Roff$[ebp]
  001f9	3b d9		 cmp	 ebx, ecx
  001fb	0f 87 80 00 00
	00		 ja	 $LN10@replace

; 1422 : 			{	// hole gets larger, substring begins before hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00201	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00204	83 fa 08	 cmp	 edx, 8
  00207	72 0a		 jb	 SHORT $LN376@replace
  00209	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0020b	89 5d 10	 mov	 DWORD PTR tv1846[ebp], ebx
  0020e	8b 5d 14	 mov	 ebx, DWORD PTR __Roff$[ebp]
  00211	eb 03		 jmp	 SHORT $LN377@replace
$LN376@replace:
  00213	89 75 10	 mov	 DWORD PTR tv1846[ebp], esi
$LN377@replace:
  00216	83 fa 08	 cmp	 edx, 8
  00219	72 04		 jb	 SHORT $LN390@replace
  0021b	8b 16		 mov	 edx, DWORD PTR [esi]
  0021d	eb 02		 jmp	 SHORT $LN391@replace
$LN390@replace:
  0021f	8b d6		 mov	 edx, esi
$LN391@replace:
  00221	85 c0		 test	 eax, eax
  00223	74 24		 je	 SHORT $LN397@replace
  00225	8b 5d 10	 mov	 ebx, DWORD PTR tv1846[ebp]
  00228	03 c0		 add	 eax, eax
  0022a	50		 push	 eax
  0022b	8b 45 0c	 mov	 eax, DWORD PTR __N0$[ebp]
  0022e	03 c1		 add	 eax, ecx
  00230	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  00233	50		 push	 eax
  00234	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00237	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0023a	50		 push	 eax
  0023b	e8 00 00 00 00	 call	 _memmove
  00240	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00243	83 c4 0c	 add	 esp, 12			; 0000000cH
  00246	8b 5d 14	 mov	 ebx, DWORD PTR __Roff$[ebp]
$LN397@replace:

; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,

  00249	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0024c	83 f8 08	 cmp	 eax, 8
  0024f	72 07		 jb	 SHORT $LN410@replace
  00251	8b 16		 mov	 edx, DWORD PTR [esi]
  00253	89 55 14	 mov	 DWORD PTR tv1844[ebp], edx
  00256	eb 03		 jmp	 SHORT $LN411@replace
$LN410@replace:
  00258	89 75 14	 mov	 DWORD PTR tv1844[ebp], esi
$LN411@replace:
  0025b	83 f8 08	 cmp	 eax, 8
  0025e	72 04		 jb	 SHORT $LN424@replace
  00260	8b 16		 mov	 edx, DWORD PTR [esi]
  00262	eb 02		 jmp	 SHORT $LN425@replace
$LN424@replace:
  00264	8b d6		 mov	 edx, esi
$LN425@replace:
  00266	85 ff		 test	 edi, edi
  00268	0f 84 68 01 00
	00		 je	 $LN601@replace
  0026e	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00271	50		 push	 eax
  00272	8b 45 14	 mov	 eax, DWORD PTR tv1844[ebp]
  00275	8d 04 58	 lea	 eax, DWORD PTR [eax+ebx*2]
  00278	50		 push	 eax
  00279	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0027c	e9 4c 01 00 00	 jmp	 $LN623@replace
$LN10@replace:

; 1426 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1427 : 			}
; 1428 : 		else if (_Off + _N0 <= _Roff)

  00281	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00284	89 45 10	 mov	 DWORD PTR tv1814[ebp], eax
  00287	3b c3		 cmp	 eax, ebx
  00289	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  0028c	0f 87 83 00 00
	00		 ja	 $LN12@replace

; 1429 : 			{	// hole gets larger, substring begins after hole
; 1430 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00292	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00295	83 fa 08	 cmp	 edx, 8
  00298	72 0a		 jb	 SHORT $LN444@replace
  0029a	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0029c	89 5d fc	 mov	 DWORD PTR tv1842[ebp], ebx
  0029f	8b 5d 14	 mov	 ebx, DWORD PTR __Roff$[ebp]
  002a2	eb 03		 jmp	 SHORT $LN445@replace
$LN444@replace:
  002a4	89 75 fc	 mov	 DWORD PTR tv1842[ebp], esi
$LN445@replace:
  002a7	83 fa 08	 cmp	 edx, 8
  002aa	72 04		 jb	 SHORT $LN458@replace
  002ac	8b 16		 mov	 edx, DWORD PTR [esi]
  002ae	eb 02		 jmp	 SHORT $LN459@replace
$LN458@replace:
  002b0	8b d6		 mov	 edx, esi
$LN459@replace:
  002b2	85 c0		 test	 eax, eax
  002b4	74 22		 je	 SHORT $LN465@replace
  002b6	8b 5d 10	 mov	 ebx, DWORD PTR tv1814[ebp]
  002b9	03 c0		 add	 eax, eax
  002bb	50		 push	 eax
  002bc	8b 45 fc	 mov	 eax, DWORD PTR tv1842[ebp]
  002bf	8d 04 58	 lea	 eax, DWORD PTR [eax+ebx*2]
  002c2	50		 push	 eax
  002c3	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  002c6	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  002c9	50		 push	 eax
  002ca	e8 00 00 00 00	 call	 _memmove
  002cf	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  002d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d5	8b 5d 14	 mov	 ebx, DWORD PTR __Roff$[ebp]
$LN465@replace:

; 1431 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1432 : 			_Traits::move(this->_Myptr() + _Off,

  002d8	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  002db	83 f8 08	 cmp	 eax, 8
  002de	72 07		 jb	 SHORT $LN478@replace
  002e0	8b 16		 mov	 edx, DWORD PTR [esi]
  002e2	89 55 14	 mov	 DWORD PTR tv1840[ebp], edx
  002e5	eb 03		 jmp	 SHORT $LN479@replace
$LN478@replace:
  002e7	89 75 14	 mov	 DWORD PTR tv1840[ebp], esi
$LN479@replace:
  002ea	83 f8 08	 cmp	 eax, 8
  002ed	72 04		 jb	 SHORT $LN492@replace
  002ef	8b 16		 mov	 edx, DWORD PTR [esi]
  002f1	eb 02		 jmp	 SHORT $LN493@replace
$LN492@replace:
  002f3	8b d6		 mov	 edx, esi
$LN493@replace:
  002f5	85 ff		 test	 edi, edi
  002f7	0f 84 d9 00 00
	00		 je	 $LN601@replace
  002fd	2b 5d 0c	 sub	 ebx, DWORD PTR __N0$[ebp]
  00300	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00303	50		 push	 eax
  00304	8b 45 14	 mov	 eax, DWORD PTR tv1840[ebp]
  00307	03 df		 add	 ebx, edi
  00309	8d 04 58	 lea	 eax, DWORD PTR [eax+ebx*2]
  0030c	50		 push	 eax
  0030d	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]

; 1433 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1434 : 				_Count);	// fill hole
; 1435 : 			}
; 1436 : 		else

  00310	e9 b8 00 00 00	 jmp	 $LN623@replace
$LN12@replace:

; 1437 : 			{	// hole gets larger, substring begins in hole
; 1438 : 			_Traits::move(this->_Myptr() + _Off,

  00315	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00318	83 f8 08	 cmp	 eax, 8
  0031b	72 0a		 jb	 SHORT $LN512@replace
  0031d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0031f	89 4d f8	 mov	 DWORD PTR tv1838[ebp], ecx
  00322	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00325	eb 03		 jmp	 SHORT $LN513@replace
$LN512@replace:
  00327	89 75 f8	 mov	 DWORD PTR tv1838[ebp], esi
$LN513@replace:
  0032a	83 f8 08	 cmp	 eax, 8
  0032d	72 07		 jb	 SHORT $LN526@replace
  0032f	8b 06		 mov	 eax, DWORD PTR [esi]
  00331	89 45 f4	 mov	 DWORD PTR tv1837[ebp], eax
  00334	eb 03		 jmp	 SHORT $LN527@replace
$LN526@replace:
  00336	89 75 f4	 mov	 DWORD PTR tv1837[ebp], esi
$LN527@replace:
  00339	85 d2		 test	 edx, edx
  0033b	74 1d		 je	 SHORT $LN533@replace
  0033d	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  00340	50		 push	 eax
  00341	8b 45 f8	 mov	 eax, DWORD PTR tv1838[ebp]
  00344	8d 04 58	 lea	 eax, DWORD PTR [eax+ebx*2]
  00347	50		 push	 eax
  00348	8b 45 f4	 mov	 eax, DWORD PTR tv1837[ebp]
  0034b	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  0034e	50		 push	 eax
  0034f	e8 00 00 00 00	 call	 _memmove
  00354	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00357	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN533@replace:

; 1439 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  0035a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0035d	83 f8 08	 cmp	 eax, 8
  00360	72 07		 jb	 SHORT $LN546@replace
  00362	8b 16		 mov	 edx, DWORD PTR [esi]
  00364	89 55 08	 mov	 DWORD PTR tv1836[ebp], edx
  00367	eb 03		 jmp	 SHORT $LN547@replace
$LN546@replace:
  00369	89 75 08	 mov	 DWORD PTR tv1836[ebp], esi
$LN547@replace:
  0036c	83 f8 08	 cmp	 eax, 8
  0036f	72 04		 jb	 SHORT $LN560@replace
  00371	8b 16		 mov	 edx, DWORD PTR [esi]
  00373	eb 02		 jmp	 SHORT $LN561@replace
$LN560@replace:
  00375	8b d6		 mov	 edx, esi
$LN561@replace:
  00377	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  0037a	85 c0		 test	 eax, eax
  0037c	74 1f		 je	 SHORT $LN567@replace
  0037e	8b 5d 10	 mov	 ebx, DWORD PTR tv1814[ebp]
  00381	03 c0		 add	 eax, eax
  00383	50		 push	 eax
  00384	8b 45 08	 mov	 eax, DWORD PTR tv1836[ebp]
  00387	8d 04 58	 lea	 eax, DWORD PTR [eax+ebx*2]
  0038a	50		 push	 eax
  0038b	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0038e	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00391	50		 push	 eax
  00392	e8 00 00 00 00	 call	 _memmove
  00397	8b 5d 14	 mov	 ebx, DWORD PTR __Roff$[ebp]
  0039a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN567@replace:

; 1441 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1442 : 			_Traits::move(this->_Myptr() + _Off + _N0,

  0039d	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  003a0	83 f8 08	 cmp	 eax, 8
  003a3	72 04		 jb	 SHORT $LN580@replace
  003a5	8b 16		 mov	 edx, DWORD PTR [esi]
  003a7	eb 02		 jmp	 SHORT $LN581@replace
$LN580@replace:
  003a9	8b d6		 mov	 edx, esi
$LN581@replace:
  003ab	83 f8 08	 cmp	 eax, 8
  003ae	72 04		 jb	 SHORT $LN594@replace
  003b0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003b2	eb 02		 jmp	 SHORT $LN595@replace
$LN594@replace:
  003b4	8b ce		 mov	 ecx, esi
$LN595@replace:
  003b6	8b c7		 mov	 eax, edi
  003b8	2b 45 0c	 sub	 eax, DWORD PTR __N0$[ebp]
  003bb	74 19		 je	 SHORT $LN601@replace
  003bd	03 c0		 add	 eax, eax
  003bf	50		 push	 eax
  003c0	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]
  003c3	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  003c6	50		 push	 eax
  003c7	8b 45 10	 mov	 eax, DWORD PTR tv1814[ebp]
  003ca	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
$LN623@replace:
  003cd	50		 push	 eax
  003ce	e8 00 00 00 00	 call	 _memmove
$LN624@replace:
  003d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN601@replace:

; 1443 : 				this->_Myptr() + _Roff + _Count,
; 1444 : 				_Count - _N0);	// fill rest of new hole
; 1445 : 			}
; 1446 : 
; 1447 : 		_Eos(_Newsize);

  003d6	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  003da	8b 4d 18	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]
  003dd	5f		 pop	 edi
  003de	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  003e1	5b		 pop	 ebx
  003e2	72 11		 jb	 SHORT $LN614@replace
  003e4	8b 06		 mov	 eax, DWORD PTR [esi]
  003e6	33 d2		 xor	 edx, edx
  003e8	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1448 : 		return (*this);

  003ec	8b c6		 mov	 eax, esi
  003ee	5e		 pop	 esi

; 1449 : 		}

  003ef	8b e5		 mov	 esp, ebp
  003f1	5d		 pop	 ebp
  003f2	c2 14 00	 ret	 20			; 00000014H

; 1443 : 				this->_Myptr() + _Roff + _Count,
; 1444 : 				_Count - _N0);	// fill rest of new hole
; 1445 : 			}
; 1446 : 
; 1447 : 		_Eos(_Newsize);

$LN614@replace:
  003f5	8b c6		 mov	 eax, esi
  003f7	33 d2		 xor	 edx, edx
  003f9	5e		 pop	 esi
  003fa	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1449 : 		}

  003fe	8b e5		 mov	 esp, ebp
  00400	5d		 pop	 ebp
  00401	c2 14 00	 ret	 20			; 00000014H
$LN625@replace:

; 1390 : 		_Check_offset(_Off);

  00404	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00409	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN630@replace:
$LN627@replace:

; 1391 : 		_Right._Check_offset(_Roff);

  0040e	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00413	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN631@replace:
$LN628@replace:

; 1395 : 			_Xlen();	// result too long

  00418	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0041d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN632@replace:
$LN629@replace:

; 1400 : 			_Grow(_Newsize);

  00422	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00427	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN633@replace:
$LN621@replace:
  0042c	cc		 int	 3
?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?clear@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::clear, COMDAT
; _this$ = ecx

; 1378 : 		_Eos(0);

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0000b	72 08		 jb	 SHORT $LN13@clear
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	33 c9		 xor	 ecx, ecx
  00011	66 89 08	 mov	 WORD PTR [eax], cx

; 1379 : 		}

  00014	c3		 ret	 0

; 1378 : 		_Eos(0);

$LN13@clear:
  00015	33 c0		 xor	 eax, eax
  00017	66 89 01	 mov	 WORD PTR [ecx], ax

; 1379 : 		}

  0001a	c3		 ret	 0
?clear@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1348 : 		_Check_offset(_Off);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	0f 82 88 00 00
	00		 jb	 $LN95@erase

; 1349 : 		if (this->_Mysize() - _Off <= _Count)

  00015	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00018	8b c7		 mov	 eax, edi
  0001a	2b c1		 sub	 eax, ecx
  0001c	3b c2		 cmp	 eax, edx
  0001e	77 27		 ja	 SHORT $LN2@erase

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

  00020	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00023	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00027	72 10		 jb	 SHORT $LN41@erase
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	33 d2		 xor	 edx, edx
  0002d	5f		 pop	 edi
  0002e	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1357 : 			}
; 1358 : 		return (*this);

  00032	8b c6		 mov	 eax, esi
  00034	5e		 pop	 esi

; 1359 : 		}

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

$LN41@erase:
  00039	8b c6		 mov	 eax, esi
  0003b	33 d2		 xor	 edx, edx
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1359 : 		}

  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
$LN2@erase:

; 1351 : 		else if (0 < _Count)

  00047	85 d2		 test	 edx, edx
  00049	74 4a		 je	 SHORT $LN92@erase

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;

  0004b	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0004f	72 04		 jb	 SHORT $LN58@erase
  00051	8b 06		 mov	 eax, DWORD PTR [esi]
  00053	eb 02		 jmp	 SHORT $LN59@erase
$LN58@erase:
  00055	8b c6		 mov	 eax, esi
$LN59@erase:

; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

  00057	2b fa		 sub	 edi, edx
  00059	53		 push	 ebx
  0005a	8d 1c 48	 lea	 ebx, DWORD PTR [eax+ecx*2]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  0005d	8b c7		 mov	 eax, edi
  0005f	2b c1		 sub	 eax, ecx
  00061	74 10		 je	 SHORT $LN74@erase
  00063	03 c0		 add	 eax, eax
  00065	50		 push	 eax
  00066	8d 04 53	 lea	 eax, DWORD PTR [ebx+edx*2]
  00069	50		 push	 eax
  0006a	53		 push	 ebx
  0006b	e8 00 00 00 00	 call	 _memmove
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@erase:

; 1356 : 			_Eos(_Newsize);

  00073	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00077	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0007a	5b		 pop	 ebx
  0007b	72 10		 jb	 SHORT $LN87@erase
  0007d	8b 06		 mov	 eax, DWORD PTR [esi]
  0007f	33 c9		 xor	 ecx, ecx
  00081	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1357 : 			}
; 1358 : 		return (*this);

  00085	8b c6		 mov	 eax, esi
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 1359 : 		}

  00089	5d		 pop	 ebp
  0008a	c2 08 00	 ret	 8

; 1356 : 			_Eos(_Newsize);

$LN87@erase:
  0008d	8b c6		 mov	 eax, esi
  0008f	33 c9		 xor	 ecx, ecx
  00091	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN92@erase:

; 1357 : 			}
; 1358 : 		return (*this);

  00095	5f		 pop	 edi
  00096	8b c6		 mov	 eax, esi
  00098	5e		 pop	 esi

; 1359 : 		}

  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
$LN95@erase:

; 1348 : 		_Check_offset(_Off);

  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000a2	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN97@erase:
$LN94@erase:
  000a7	cc		 int	 3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1341 : 		_Check_offset(_Off);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	72 29		 jb	 SHORT $LN37@erase

; 1342 : 		_Eos(_Off);

  0000b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000e	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00012	72 10		 jb	 SHORT $LN29@erase
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	56		 push	 esi
  00017	33 f6		 xor	 esi, esi
  00019	66 89 34 42	 mov	 WORD PTR [edx+eax*2], si

; 1343 : 		return (*this);

  0001d	8b c1		 mov	 eax, ecx
  0001f	5e		 pop	 esi

; 1344 : 		}

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4

; 1342 : 		_Eos(_Off);

$LN29@erase:
  00024	8b d1		 mov	 edx, ecx
  00026	56		 push	 esi
  00027	33 f6		 xor	 esi, esi
  00029	66 89 34 42	 mov	 WORD PTR [edx+eax*2], si

; 1343 : 		return (*this);

  0002d	8b c1		 mov	 eax, ecx
  0002f	5e		 pop	 esi

; 1344 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN37@erase:

; 1341 : 		_Check_offset(_Off);

  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00039	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN39@erase:
$LN36@erase:
  0003e	cc		 int	 3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_W@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert, COMDAT
; _this$ = ecx

; 1271 : 		{	// insert [_Ptr, <null>) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1272 : 		_DEBUG_POINTER(_Ptr);
; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  0000b	75 11		 jne	 SHORT $LN5@insert
  0000d	33 d2		 xor	 edx, edx
  0000f	52		 push	 edx
  00010	56		 push	 esi
  00011	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00014	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
  00019	5e		 pop	 esi

; 1274 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8

; 1272 : 		_DEBUG_POINTER(_Ptr);
; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

$LN5@insert:
  0001e	8b d6		 mov	 edx, esi
  00020	57		 push	 edi
  00021	8d 7a 02	 lea	 edi, DWORD PTR [edx+2]
$LL7@insert:
  00024	66 8b 02	 mov	 ax, WORD PTR [edx]
  00027	83 c2 02	 add	 edx, 2
  0002a	66 85 c0	 test	 ax, ax
  0002d	75 f5		 jne	 SHORT $LL7@insert
  0002f	2b d7		 sub	 edx, edi
  00031	5f		 pop	 edi
  00032	d1 fa		 sar	 edx, 1
  00034	52		 push	 edx
  00035	56		 push	 esi
  00036	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00039	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
  0003e	5e		 pop	 esi

; 1274 : 		}

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z
_TEXT	SEGMENT
tv794 = -4						; size = 4
__Off$ = 8						; size = 4
tv795 = 12						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert, COMDAT
; _this$ = ecx

; 1250 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1251 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1252 : 		if (_Inside(_Ptr))

  00006	8b 7d 0c	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	85 ff		 test	 edi, edi
  0000d	74 4d		 je	 SHORT $LN2@insert
  0000f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00012	83 f9 08	 cmp	 ecx, 8
  00015	72 04		 jb	 SHORT $LN21@insert
  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	eb 02		 jmp	 SHORT $LN22@insert
$LN21@insert:
  0001b	8b c6		 mov	 eax, esi
$LN22@insert:
  0001d	3b f8		 cmp	 edi, eax
  0001f	72 3b		 jb	 SHORT $LN2@insert
  00021	83 f9 08	 cmp	 ecx, 8
  00024	72 04		 jb	 SHORT $LN35@insert
  00026	8b 16		 mov	 edx, DWORD PTR [esi]
  00028	eb 02		 jmp	 SHORT $LN36@insert
$LN35@insert:
  0002a	8b d6		 mov	 edx, esi
$LN36@insert:
  0002c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002f	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00032	3b c7		 cmp	 eax, edi
  00034	76 26		 jbe	 SHORT $LN2@insert

; 1253 : 			return (insert(_Off, *this,

  00036	83 f9 08	 cmp	 ecx, 8
  00039	72 04		 jb	 SHORT $LN58@insert
  0003b	8b 06		 mov	 eax, DWORD PTR [esi]
  0003d	eb 02		 jmp	 SHORT $LN59@insert
$LN58@insert:
  0003f	8b c6		 mov	 eax, esi
$LN59@insert:
  00041	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00044	2b f8		 sub	 edi, eax
  00046	8b ce		 mov	 ecx, esi
  00048	d1 ff		 sar	 edi, 1
  0004a	57		 push	 edi
  0004b	56		 push	 esi
  0004c	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  0004f	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi

; 1268 : 		}

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 0c 00	 ret	 12			; 0000000cH
$LN2@insert:

; 1254 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1255 : 		_Check_offset(_Off);

  0005c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0005f	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  00062	0f 82 0b 01 00
	00		 jb	 $LN268@insert

; 1256 : 		if (npos - this->_Mysize() <= _Count)

  00068	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  0006b	8b c1		 mov	 eax, ecx
  0006d	f7 d0		 not	 eax
  0006f	3b c2		 cmp	 eax, edx
  00071	0f 86 06 01 00
	00		 jbe	 $LN270@insert

; 1258 : 		const size_type _Num = this->_Mysize() + _Count;

  00077	53		 push	 ebx
  00078	8d 1c 11	 lea	 ebx, DWORD PTR [ecx+edx]

; 1259 : 		if (0 < _Count && _Grow(_Num))

  0007b	85 d2		 test	 edx, edx
  0007d	0f 84 e5 00 00
	00		 je	 $LN262@insert
  00083	81 fb fe ff ff
	7f		 cmp	 ebx, 2147483646		; 7ffffffeH
  00089	0f 87 f8 00 00
	00		 ja	 $LN271@insert
  0008f	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00092	73 23		 jae	 SHORT $LN100@insert
  00094	51		 push	 ecx
  00095	53		 push	 ebx
  00096	8b ce		 mov	 ecx, esi
  00098	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0009d	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  000a0	85 db		 test	 ebx, ebx
  000a2	0f 84 c0 00 00
	00		 je	 $LN262@insert
$LN267@insert:

; 1260 : 			{	// make room and insert new stuff
; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  000a8	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000ab	83 f8 08	 cmp	 eax, 8
  000ae	72 36		 jb	 SHORT $LN203@insert
  000b0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b2	89 4d 0c	 mov	 DWORD PTR tv795[ebp], ecx
  000b5	eb 32		 jmp	 SHORT $LN204@insert

; 1259 : 		if (0 < _Count && _Grow(_Num))

$LN100@insert:
  000b7	85 db		 test	 ebx, ebx
  000b9	75 ed		 jne	 SHORT $LN267@insert
  000bb	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000be	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000c2	72 12		 jb	 SHORT $LN177@insert
  000c4	8b 06		 mov	 eax, DWORD PTR [esi]
  000c6	33 c9		 xor	 ecx, ecx
  000c8	5b		 pop	 ebx
  000c9	5f		 pop	 edi
  000ca	66 89 08	 mov	 WORD PTR [eax], cx

; 1266 : 			}
; 1267 : 		return (*this);

  000cd	8b c6		 mov	 eax, esi
  000cf	5e		 pop	 esi

; 1268 : 		}

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 0c 00	 ret	 12			; 0000000cH

; 1259 : 		if (0 < _Count && _Grow(_Num))

$LN177@insert:
  000d6	8b c6		 mov	 eax, esi
  000d8	33 c9		 xor	 ecx, ecx
  000da	5b		 pop	 ebx
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	66 89 08	 mov	 WORD PTR [eax], cx

; 1268 : 		}

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 0c 00	 ret	 12			; 0000000cH

; 1260 : 			{	// make room and insert new stuff
; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

$LN203@insert:
  000e6	89 75 0c	 mov	 DWORD PTR tv795[ebp], esi
$LN204@insert:
  000e9	83 f8 08	 cmp	 eax, 8
  000ec	72 07		 jb	 SHORT $LN217@insert
  000ee	8b 06		 mov	 eax, DWORD PTR [esi]
  000f0	89 45 fc	 mov	 DWORD PTR tv794[ebp], eax
  000f3	eb 03		 jmp	 SHORT $LN218@insert
$LN217@insert:
  000f5	89 75 fc	 mov	 DWORD PTR tv794[ebp], esi
$LN218@insert:
  000f8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  000fe	2b c1		 sub	 eax, ecx
  00100	74 1f		 je	 SHORT $LN224@insert
  00102	03 c0		 add	 eax, eax
  00104	50		 push	 eax
  00105	8b 45 0c	 mov	 eax, DWORD PTR tv795[ebp]
  00108	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  0010b	50		 push	 eax
  0010c	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  0010f	8b 4d fc	 mov	 ecx, DWORD PTR tv794[ebp]
  00112	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 _memmove
  0011b	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0011e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN224@insert:

; 1262 : 				this->_Myptr() + _Off,
; 1263 : 				this->_Mysize() - _Off);	// empty out hole
; 1264 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

  00121	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00125	72 04		 jb	 SHORT $LN237@insert
  00127	8b 16		 mov	 edx, DWORD PTR [esi]
  00129	eb 02		 jmp	 SHORT $LN238@insert
$LN237@insert:
  0012b	8b d6		 mov	 edx, esi
$LN238@insert:
  0012d	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00130	85 c0		 test	 eax, eax
  00132	74 10		 je	 SHORT $LN244@insert
  00134	03 c0		 add	 eax, eax
  00136	50		 push	 eax
  00137	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0013a	57		 push	 edi
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _memcpy
  00141	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN244@insert:

; 1265 : 			_Eos(_Num);

  00144	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00148	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  0014b	72 13		 jb	 SHORT $LN257@insert
  0014d	8b 06		 mov	 eax, DWORD PTR [esi]
  0014f	33 c9		 xor	 ecx, ecx
  00151	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx

; 1266 : 			}
; 1267 : 		return (*this);

  00155	8b c6		 mov	 eax, esi
  00157	5b		 pop	 ebx
  00158	5f		 pop	 edi
  00159	5e		 pop	 esi

; 1268 : 		}

  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c2 0c 00	 ret	 12			; 0000000cH

; 1265 : 			_Eos(_Num);

$LN257@insert:
  00160	8b c6		 mov	 eax, esi
  00162	33 c9		 xor	 ecx, ecx
  00164	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx
$LN262@insert:

; 1266 : 			}
; 1267 : 		return (*this);

  00168	5b		 pop	 ebx
  00169	5f		 pop	 edi
  0016a	8b c6		 mov	 eax, esi
  0016c	5e		 pop	 esi

; 1268 : 		}

  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c2 0c 00	 ret	 12			; 0000000cH
$LN268@insert:

; 1254 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1255 : 		_Check_offset(_Off);

  00173	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00178	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN272@insert:
$LN270@insert:

; 1257 : 			_Xlen();	// result too long

  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00182	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN273@insert:
$LN271@insert:

; 1259 : 		if (0 < _Count && _Grow(_Num))

  00187	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0018c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN274@insert:
$LN265@insert:
  00191	cc		 int	 3
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IPB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z
_TEXT	SEGMENT
tv845 = 8						; size = 4
tv843 = 8						; size = 4
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
tv846 = 16						; size = 4
__Roff$ = 16						; size = 4
tv848 = 20						; size = 4
__Count$ = 20						; size = 4
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert, COMDAT
; _this$ = ecx

; 1223 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 1224 : 		_Check_offset(_Off);

  00008	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000b	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  0000e	0f 82 76 01 00
	00		 jb	 $LN291@insert

; 1225 : 		_Right._Check_offset(_Roff);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00017	8b 55 10	 mov	 edx, DWORD PTR __Roff$[ebp]
  0001a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0001d	3b c2		 cmp	 eax, edx
  0001f	0f 82 6f 01 00
	00		 jb	 $LN293@insert

; 1226 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00025	8b 7d 14	 mov	 edi, DWORD PTR __Count$[ebp]
  00028	2b c2		 sub	 eax, edx
  0002a	3b f8		 cmp	 edi, eax
  0002c	0f 47 f8	 cmova	 edi, eax

; 1227 : 		if (npos - this->_Mysize() <= _Count)

  0002f	8b c1		 mov	 eax, ecx
  00031	f7 d0		 not	 eax
  00033	3b c7		 cmp	 eax, edi
  00035	0f 86 63 01 00
	00		 jbe	 $LN294@insert

; 1229 : 
; 1230 : 		const size_type _Num = this->_Mysize() + _Count;

  0003b	8d 1c 39	 lea	 ebx, DWORD PTR [ecx+edi]

; 1231 : 		if (0 < _Count && _Grow(_Num))

  0003e	85 ff		 test	 edi, edi
  00040	0f 84 3b 01 00
	00		 je	 $LN285@insert
  00046	81 fb fe ff ff
	7f		 cmp	 ebx, 2147483646		; 7ffffffeH
  0004c	0f 87 56 01 00
	00		 ja	 $LN295@insert
  00052	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00055	73 20		 jae	 SHORT $LN75@insert
  00057	51		 push	 ecx
  00058	53		 push	 ebx
  00059	8b ce		 mov	 ecx, esi
  0005b	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00060	85 db		 test	 ebx, ebx
  00062	0f 84 19 01 00
	00		 je	 $LN285@insert
$LN289@insert:

; 1232 : 			{	// make room and insert new stuff
; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00068	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0006b	83 f8 08	 cmp	 eax, 8
  0006e	72 32		 jb	 SHORT $LN178@insert
  00070	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00072	89 4d 14	 mov	 DWORD PTR tv848[ebp], ecx
  00075	eb 2e		 jmp	 SHORT $LN179@insert

; 1231 : 		if (0 < _Count && _Grow(_Num))

$LN75@insert:
  00077	85 db		 test	 ebx, ebx
  00079	75 ed		 jne	 SHORT $LN289@insert
  0007b	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  0007e	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00082	72 10		 jb	 SHORT $LN152@insert
  00084	8b 06		 mov	 eax, DWORD PTR [esi]
  00086	33 c9		 xor	 ecx, ecx
  00088	5f		 pop	 edi
  00089	66 89 08	 mov	 WORD PTR [eax], cx

; 1244 : 			}
; 1245 : 		return (*this);

  0008c	8b c6		 mov	 eax, esi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx

; 1246 : 		}

  00090	5d		 pop	 ebp
  00091	c2 10 00	 ret	 16			; 00000010H

; 1231 : 		if (0 < _Count && _Grow(_Num))

$LN152@insert:
  00094	8b c6		 mov	 eax, esi
  00096	33 c9		 xor	 ecx, ecx
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx
  0009b	66 89 08	 mov	 WORD PTR [eax], cx

; 1246 : 		}

  0009e	5d		 pop	 ebp
  0009f	c2 10 00	 ret	 16			; 00000010H

; 1232 : 			{	// make room and insert new stuff
; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

$LN178@insert:
  000a2	89 75 14	 mov	 DWORD PTR tv848[ebp], esi
$LN179@insert:
  000a5	83 f8 08	 cmp	 eax, 8
  000a8	72 04		 jb	 SHORT $LN192@insert
  000aa	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000ac	eb 02		 jmp	 SHORT $LN193@insert
$LN192@insert:
  000ae	8b ce		 mov	 ecx, esi
$LN193@insert:
  000b0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b3	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000b6	2b c2		 sub	 eax, edx
  000b8	74 1c		 je	 SHORT $LN199@insert
  000ba	03 c0		 add	 eax, eax
  000bc	50		 push	 eax
  000bd	8b 45 14	 mov	 eax, DWORD PTR tv848[ebp]
  000c0	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  000c3	50		 push	 eax
  000c4	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  000c7	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _memmove
  000d0	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN199@insert:

; 1234 : 				this->_Myptr() + _Off,
; 1235 : 				this->_Mysize() - _Off);	// empty out hole
; 1236 : 			if (this == &_Right)

  000d6	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  000d9	3b f1		 cmp	 esi, ecx
  000db	75 4c		 jne	 SHORT $LN4@insert

; 1237 : 				_Traits::move(this->_Myptr() + _Off,

  000dd	8b 45 10	 mov	 eax, DWORD PTR __Roff$[ebp]
  000e0	3b d0		 cmp	 edx, eax
  000e2	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  000e5	0f 43 c8	 cmovae	 ecx, eax
  000e8	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000eb	83 f8 08	 cmp	 eax, 8
  000ee	72 0a		 jb	 SHORT $LN212@insert
  000f0	8b 16		 mov	 edx, DWORD PTR [esi]
  000f2	89 55 10	 mov	 DWORD PTR tv846[ebp], edx
  000f5	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000f8	eb 03		 jmp	 SHORT $LN213@insert
$LN212@insert:
  000fa	89 75 10	 mov	 DWORD PTR tv846[ebp], esi
$LN213@insert:
  000fd	83 f8 08	 cmp	 eax, 8
  00100	72 07		 jb	 SHORT $LN226@insert
  00102	8b 06		 mov	 eax, DWORD PTR [esi]
  00104	89 45 08	 mov	 DWORD PTR tv845[ebp], eax
  00107	eb 03		 jmp	 SHORT $LN227@insert
$LN226@insert:
  00109	89 75 08	 mov	 DWORD PTR tv845[ebp], esi
$LN227@insert:
  0010c	85 ff		 test	 edi, edi
  0010e	74 4f		 je	 SHORT $LN267@insert
  00110	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00113	50		 push	 eax
  00114	8b 45 10	 mov	 eax, DWORD PTR tv846[ebp]
  00117	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  0011a	50		 push	 eax
  0011b	8b 45 08	 mov	 eax, DWORD PTR tv845[ebp]
  0011e	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 _memmove

; 1238 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1239 : 						_Count);	// substring
; 1240 : 			else

  00127	eb 33		 jmp	 SHORT $LN290@insert
$LN4@insert:

; 1241 : 				_Traits::copy(this->_Myptr() + _Off,

  00129	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  0012d	72 02		 jb	 SHORT $LN246@insert
  0012f	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN246@insert:
  00131	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00135	72 07		 jb	 SHORT $LN260@insert
  00137	8b 06		 mov	 eax, DWORD PTR [esi]
  00139	89 45 08	 mov	 DWORD PTR tv843[ebp], eax
  0013c	eb 03		 jmp	 SHORT $LN261@insert
$LN260@insert:
  0013e	89 75 08	 mov	 DWORD PTR tv843[ebp], esi
$LN261@insert:
  00141	85 ff		 test	 edi, edi
  00143	74 1a		 je	 SHORT $LN267@insert
  00145	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00148	50		 push	 eax
  00149	8b 45 10	 mov	 eax, DWORD PTR __Roff$[ebp]
  0014c	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0014f	50		 push	 eax
  00150	8b 45 08	 mov	 eax, DWORD PTR tv843[ebp]
  00153	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 _memcpy
$LN290@insert:
  0015c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN267@insert:

; 1242 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1243 : 			_Eos(_Num);

  0015f	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00163	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00166	72 11		 jb	 SHORT $LN280@insert
  00168	8b 06		 mov	 eax, DWORD PTR [esi]
  0016a	33 c9		 xor	 ecx, ecx
  0016c	5f		 pop	 edi
  0016d	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx

; 1244 : 			}
; 1245 : 		return (*this);

  00171	8b c6		 mov	 eax, esi
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx

; 1246 : 		}

  00175	5d		 pop	 ebp
  00176	c2 10 00	 ret	 16			; 00000010H

; 1242 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1243 : 			_Eos(_Num);

$LN280@insert:
  00179	8b c6		 mov	 eax, esi
  0017b	33 c9		 xor	 ecx, ecx
  0017d	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx
$LN285@insert:

; 1244 : 			}
; 1245 : 		return (*this);

  00181	5f		 pop	 edi
  00182	8b c6		 mov	 eax, esi
  00184	5e		 pop	 esi
  00185	5b		 pop	 ebx

; 1246 : 		}

  00186	5d		 pop	 ebp
  00187	c2 10 00	 ret	 16			; 00000010H
$LN291@insert:

; 1224 : 		_Check_offset(_Off);

  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0018f	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN296@insert:
$LN293@insert:

; 1225 : 		_Right._Check_offset(_Roff);

  00194	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00199	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN297@insert:
$LN294@insert:

; 1228 : 			_Xlen();	// result too long

  0019e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  001a3	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN298@insert:
$LN295@insert:

; 1231 : 		if (0 < _Count && _Grow(_Num))

  001a8	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  001ad	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN299@insert:
$LN287@insert:
  001b2	cc		 int	 3
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert, COMDAT
; _this$ = ecx

; 1217 : 		{	// insert _Right at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1218 : 		return (insert(_Off, _Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 0c	 push	 DWORD PTR __Right$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  0000d	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert

; 1219 : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000d	75 0e		 jne	 SHORT $LN5@assign
  0000f	33 c0		 xor	 eax, eax
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00018	5e		 pop	 esi

; 1183 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

$LN5@assign:
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL7@assign:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL7@assign
  0002e	2b c7		 sub	 eax, edi
  00030	8b ce		 mov	 ecx, esi
  00032	5f		 pop	 edi
  00033	d1 f8		 sar	 eax, 1
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0003c	5e		 pop	 esi

; 1183 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1166 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1167 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 48		 je	 SHORT $LN2@assign
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 08	 cmp	 ecx, 8
  00014	72 04		 jb	 SHORT $LN20@assign
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN21@assign
$LN20@assign:
  0001a	8b c6		 mov	 eax, esi
$LN21@assign:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 36		 jb	 SHORT $LN2@assign
  00020	83 f9 08	 cmp	 ecx, 8
  00023	72 04		 jb	 SHORT $LN34@assign
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN35@assign
$LN34@assign:
  00029	8b d6		 mov	 edx, esi
$LN35@assign:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00031	3b c3		 cmp	 eax, ebx
  00033	76 21		 jbe	 SHORT $LN2@assign

; 1168 : 			return (assign(*this,

  00035	83 f9 08	 cmp	 ecx, 8
  00038	72 04		 jb	 SHORT $LN57@assign
  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	eb 02		 jmp	 SHORT $LN58@assign
$LN57@assign:
  0003e	8b c6		 mov	 eax, esi
$LN58@assign:
  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	2b d8		 sub	 ebx, eax
  00045	8b ce		 mov	 ecx, esi
  00047	d1 fb		 sar	 ebx, 1
  00049	53		 push	 ebx
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 1177 : 		}

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN2@assign:
  00056	57		 push	 edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  00057	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0005a	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00060	0f 87 88 00 00
	00		 ja	 $LN189@assign
  00066	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00069	73 19		 jae	 SHORT $LN63@assign
  0006b	ff 76 10	 push	 DWORD PTR [esi+16]
  0006e	8b ce		 mov	 ecx, esi
  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00076	85 ff		 test	 edi, edi
  00078	74 6b		 je	 SHORT $LN183@assign
$LN188@assign:

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  0007a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0007e	72 2f		 jb	 SHORT $LN158@assign
  00080	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00082	eb 2d		 jmp	 SHORT $LN159@assign

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN63@assign:
  00084	85 ff		 test	 edi, edi
  00086	75 f2		 jne	 SHORT $LN188@assign
  00088	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0008c	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0008f	72 10		 jb	 SHORT $LN140@assign
  00091	8b 06		 mov	 eax, DWORD PTR [esi]
  00093	33 c9		 xor	 ecx, ecx
  00095	5f		 pop	 edi
  00096	66 89 08	 mov	 WORD PTR [eax], cx

; 1175 : 			}
; 1176 : 		return (*this);

  00099	8b c6		 mov	 eax, esi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx

; 1177 : 		}

  0009d	5d		 pop	 ebp
  0009e	c2 08 00	 ret	 8

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN140@assign:
  000a1	8b c6		 mov	 eax, esi
  000a3	33 c9		 xor	 ecx, ecx
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx
  000a8	66 89 08	 mov	 WORD PTR [eax], cx

; 1177 : 		}

  000ab	5d		 pop	 ebp
  000ac	c2 08 00	 ret	 8

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

$LN158@assign:
  000af	8b ce		 mov	 ecx, esi
$LN159@assign:
  000b1	85 ff		 test	 edi, edi
  000b3	74 0e		 je	 SHORT $LN165@assign
  000b5	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  000b8	50		 push	 eax
  000b9	53		 push	 ebx
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 _memcpy
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN165@assign:

; 1174 : 			_Eos(_Count);

  000c3	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000c7	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ca	72 11		 jb	 SHORT $LN178@assign
  000cc	8b 06		 mov	 eax, DWORD PTR [esi]
  000ce	33 c9		 xor	 ecx, ecx
  000d0	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1175 : 			}
; 1176 : 		return (*this);

  000d4	8b c6		 mov	 eax, esi
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx

; 1177 : 		}

  000d9	5d		 pop	 ebp
  000da	c2 08 00	 ret	 8

; 1174 : 			_Eos(_Count);

$LN178@assign:
  000dd	8b c6		 mov	 eax, esi
  000df	33 c9		 xor	 ecx, ecx
  000e1	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN183@assign:

; 1175 : 			}
; 1176 : 		return (*this);

  000e5	5f		 pop	 edi
  000e6	8b c6		 mov	 eax, esi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx

; 1177 : 		}

  000ea	5d		 pop	 ebp
  000eb	c2 08 00	 ret	 8
$LN189@assign:

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f3	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN191@assign:
$LN186@assign:
  000f8	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1150 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 e3 00 00
	00		 jb	 $LN210@assign

; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00019	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
  0001c	2b c1		 sub	 eax, ecx
  0001e	3b f8		 cmp	 edi, eax
  00020	0f 47 f8	 cmova	 edi, eax

; 1152 : 
; 1153 : 		if (this == &_Right)

  00023	3b f3		 cmp	 esi, ebx
  00025	75 33		 jne	 SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  0002d	0f 82 d3 00 00
	00		 jb	 $LN212@assign
  00033	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00036	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0003a	72 04		 jb	 SHORT $LN63@assign
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	eb 02		 jmp	 SHORT $LN64@assign
$LN63@assign:
  00040	8b d6		 mov	 edx, esi
$LN64@assign:
  00042	33 ff		 xor	 edi, edi
  00044	51		 push	 ecx
  00045	57		 push	 edi
  00046	8b ce		 mov	 ecx, esi
  00048	66 89 3c 42	 mov	 WORD PTR [edx+eax*2], di
  0004c	e8 00 00 00 00	 call	 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
  00051	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  00052	8b c6		 mov	 eax, esi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx

; 1162 : 		}

  00056	5d		 pop	 ebp
  00057	c2 0c 00	 ret	 12			; 0000000cH
$LN2@assign:

; 1155 : 		else if (_Grow(_Count))

  0005a	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00060	0f 87 aa 00 00
	00		 ja	 $LN213@assign
  00066	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00069	73 24		 jae	 SHORT $LN72@assign
  0006b	ff 76 10	 push	 DWORD PTR [esi+16]
  0006e	8b ce		 mov	 ecx, esi
  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00076	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  00079	85 ff		 test	 edi, edi
  0007b	74 76		 je	 SHORT $LN205@assign
$LN209@assign:

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

  0007d	83 7b 14 08	 cmp	 DWORD PTR [ebx+20], 8
  00081	72 02		 jb	 SHORT $LN166@assign
  00083	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN166@assign:
  00085	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00089	72 2f		 jb	 SHORT $LN180@assign
  0008b	8b 16		 mov	 edx, DWORD PTR [esi]
  0008d	eb 2d		 jmp	 SHORT $LN181@assign

; 1155 : 		else if (_Grow(_Count))

$LN72@assign:
  0008f	85 ff		 test	 edi, edi
  00091	75 ea		 jne	 SHORT $LN209@assign
  00093	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00097	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0009a	72 10		 jb	 SHORT $LN149@assign
  0009c	8b 06		 mov	 eax, DWORD PTR [esi]
  0009e	33 c9		 xor	 ecx, ecx
  000a0	5f		 pop	 edi
  000a1	66 89 08	 mov	 WORD PTR [eax], cx

; 1160 : 			}
; 1161 : 		return (*this);

  000a4	8b c6		 mov	 eax, esi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx

; 1162 : 		}

  000a8	5d		 pop	 ebp
  000a9	c2 0c 00	 ret	 12			; 0000000cH

; 1155 : 		else if (_Grow(_Count))

$LN149@assign:
  000ac	8b c6		 mov	 eax, esi
  000ae	33 c9		 xor	 ecx, ecx
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	66 89 08	 mov	 WORD PTR [eax], cx

; 1162 : 		}

  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

$LN180@assign:
  000ba	8b d6		 mov	 edx, esi
$LN181@assign:
  000bc	85 ff		 test	 edi, edi
  000be	74 11		 je	 SHORT $LN187@assign
  000c0	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  000c3	50		 push	 eax
  000c4	8d 04 4b	 lea	 eax, DWORD PTR [ebx+ecx*2]
  000c7	50		 push	 eax
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 _memcpy
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN187@assign:

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

  000d1	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000d5	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000d8	72 11		 jb	 SHORT $LN200@assign
  000da	8b 06		 mov	 eax, DWORD PTR [esi]
  000dc	33 c9		 xor	 ecx, ecx
  000de	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1160 : 			}
; 1161 : 		return (*this);

  000e2	8b c6		 mov	 eax, esi
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 1162 : 		}

  000e7	5d		 pop	 ebp
  000e8	c2 0c 00	 ret	 12			; 0000000cH

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

$LN200@assign:
  000eb	8b c6		 mov	 eax, esi
  000ed	33 c9		 xor	 ecx, ecx
  000ef	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN205@assign:

; 1160 : 			}
; 1161 : 		return (*this);

  000f3	5f		 pop	 edi
  000f4	8b c6		 mov	 eax, esi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx

; 1162 : 		}

  000f8	5d		 pop	 ebp
  000f9	c2 0c 00	 ret	 12			; 0000000cH
$LN210@assign:

; 1150 : 		_Right._Check_offset(_Roff);

  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00101	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN214@assign:
$LN212@assign:

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0010b	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN215@assign:
$LN213@assign:

; 1155 : 		else if (_Grow(_Count))

  00110	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00115	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN216@assign:
$LN207@assign:
  0011a	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1143 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1144 : 		return (assign(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 1145 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1105 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000d	75 0e		 jne	 SHORT $LN5@append
  0000f	33 c0		 xor	 eax, eax
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00018	5e		 pop	 esi

; 1108 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

$LN5@append:
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL7@append:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL7@append
  0002e	2b c7		 sub	 eax, edi
  00030	8b ce		 mov	 ecx, esi
  00032	5f		 pop	 edi
  00033	d1 f8		 sar	 eax, 1
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  0003c	5e		 pop	 esi

; 1108 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1087 : 		{	// append [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1088 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1089 : 		if (_Inside(_Ptr))

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	74 48		 je	 SHORT $LN2@append
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 08	 cmp	 ecx, 8
  00014	72 04		 jb	 SHORT $LN21@append
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN22@append
$LN21@append:
  0001a	8b c6		 mov	 eax, esi
$LN22@append:
  0001c	3b f8		 cmp	 edi, eax
  0001e	72 36		 jb	 SHORT $LN2@append
  00020	83 f9 08	 cmp	 ecx, 8
  00023	72 04		 jb	 SHORT $LN35@append
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN36@append
$LN35@append:
  00029	8b d6		 mov	 edx, esi
$LN36@append:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00031	3b c7		 cmp	 eax, edi
  00033	76 21		 jbe	 SHORT $LN2@append

; 1090 : 			return (append(*this,

  00035	83 f9 08	 cmp	 ecx, 8
  00038	72 04		 jb	 SHORT $LN58@append
  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	eb 02		 jmp	 SHORT $LN59@append
$LN58@append:
  0003e	8b c6		 mov	 eax, esi
$LN59@append:
  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	2b f8		 sub	 edi, eax
  00045	8b ce		 mov	 ecx, esi
  00047	d1 ff		 sar	 edi, 1
  00049	57		 push	 edi
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 1102 : 		}

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN2@append:

; 1091 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1092 : 		if (npos - this->_Mysize() <= _Count)

  00056	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00059	8b c2		 mov	 eax, edx
  0005b	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005e	f7 d0		 not	 eax
  00060	3b c1		 cmp	 eax, ecx
  00062	0f 86 a7 00 00
	00		 jbe	 $LN219@append

; 1094 : 
; 1095 : 		const size_type _Num = this->_Mysize() + _Count;

  00068	53		 push	 ebx
  00069	8d 1c 0a	 lea	 ebx, DWORD PTR [edx+ecx]

; 1096 : 		if (0 < _Count && _Grow(_Num))

  0006c	85 c9		 test	 ecx, ecx
  0006e	0f 84 92 00 00
	00		 je	 $LN213@append
  00074	81 fb fe ff ff
	7f		 cmp	 ebx, 2147483646		; 7ffffffeH
  0007a	0f 87 99 00 00
	00		 ja	 $LN221@append
  00080	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00083	73 1a		 jae	 SHORT $LN85@append
  00085	52		 push	 edx
  00086	53		 push	 ebx
  00087	8b ce		 mov	 ecx, esi
  00089	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0008e	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00091	85 db		 test	 ebx, ebx
  00093	74 71		 je	 SHORT $LN213@append
$LN218@append:

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

  00095	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00099	72 2f		 jb	 SHORT $LN179@append
  0009b	8b 16		 mov	 edx, DWORD PTR [esi]
  0009d	eb 2d		 jmp	 SHORT $LN180@append

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN85@append:
  0009f	85 db		 test	 ebx, ebx
  000a1	75 f2		 jne	 SHORT $LN218@append
  000a3	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000a6	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000aa	72 10		 jb	 SHORT $LN162@append
  000ac	8b 06		 mov	 eax, DWORD PTR [esi]
  000ae	33 c9		 xor	 ecx, ecx
  000b0	5b		 pop	 ebx
  000b1	5f		 pop	 edi
  000b2	66 89 08	 mov	 WORD PTR [eax], cx

; 1100 : 			}
; 1101 : 		return (*this);

  000b5	8b c6		 mov	 eax, esi
  000b7	5e		 pop	 esi

; 1102 : 		}

  000b8	5d		 pop	 ebp
  000b9	c2 08 00	 ret	 8

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN162@append:
  000bc	8b c6		 mov	 eax, esi
  000be	33 c9		 xor	 ecx, ecx
  000c0	5b		 pop	 ebx
  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	66 89 08	 mov	 WORD PTR [eax], cx

; 1102 : 		}

  000c6	5d		 pop	 ebp
  000c7	c2 08 00	 ret	 8

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

$LN179@append:
  000ca	8b d6		 mov	 edx, esi
$LN180@append:
  000cc	85 c9		 test	 ecx, ecx
  000ce	74 14		 je	 SHORT $LN195@append
  000d0	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  000d3	50		 push	 eax
  000d4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000d7	57		 push	 edi
  000d8	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _memcpy
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN195@append:

; 1099 : 			_Eos(_Num);

  000e4	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000e8	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000eb	72 11		 jb	 SHORT $LN208@append
  000ed	8b 06		 mov	 eax, DWORD PTR [esi]
  000ef	33 c9		 xor	 ecx, ecx
  000f1	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx

; 1100 : 			}
; 1101 : 		return (*this);

  000f5	8b c6		 mov	 eax, esi
  000f7	5b		 pop	 ebx
  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi

; 1102 : 		}

  000fa	5d		 pop	 ebp
  000fb	c2 08 00	 ret	 8

; 1099 : 			_Eos(_Num);

$LN208@append:
  000fe	8b c6		 mov	 eax, esi
  00100	33 c9		 xor	 ecx, ecx
  00102	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx
$LN213@append:

; 1100 : 			}
; 1101 : 		return (*this);

  00106	5b		 pop	 ebx
  00107	5f		 pop	 edi
  00108	8b c6		 mov	 eax, esi
  0010a	5e		 pop	 esi

; 1102 : 		}

  0010b	5d		 pop	 ebp
  0010c	c2 08 00	 ret	 8
$LN219@append:

; 1093 : 			_Xlen();	// result too long

  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00114	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN222@append:
$LN221@append:

; 1096 : 		if (0 < _Count && _Grow(_Num))

  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN223@append:
$LN216@append:
  00123	cc		 int	 3
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1071 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 d0 00 00
	00		 jb	 $LN203@append

; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

  00019	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0001c	2b c1		 sub	 eax, ecx
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00021	3b c8		 cmp	 ecx, eax
  00023	0f 47 c8	 cmova	 ecx, eax
  00026	8b c2		 mov	 eax, edx
  00028	f7 d0		 not	 eax
  0002a	89 4d 10	 mov	 DWORD PTR __Count$[ebp], ecx
  0002d	3b c1		 cmp	 eax, ecx
  0002f	0f 86 be 00 00
	00		 jbe	 $LN205@append

; 1075 : 
; 1076 : 		const size_type _Num = this->_Mysize() + _Count;

  00035	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 1077 : 		if (0 < _Count && _Grow(_Num))

  00038	85 c9		 test	 ecx, ecx
  0003a	0f 84 a0 00 00
	00		 je	 $LN198@append
  00040	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00046	0f 87 b1 00 00
	00		 ja	 $LN206@append
  0004c	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0004f	73 22		 jae	 SHORT $LN56@append
  00051	52		 push	 edx
  00052	57		 push	 edi
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0005a	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005d	85 ff		 test	 edi, edi
  0005f	74 7f		 je	 SHORT $LN198@append
$LN202@append:

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

  00061	83 7b 14 08	 cmp	 DWORD PTR [ebx+20], 8
  00065	72 02		 jb	 SHORT $LN150@append
  00067	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN150@append:
  00069	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0006d	72 2f		 jb	 SHORT $LN164@append
  0006f	8b 16		 mov	 edx, DWORD PTR [esi]
  00071	eb 2d		 jmp	 SHORT $LN165@append

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN56@append:
  00073	85 ff		 test	 edi, edi
  00075	75 ea		 jne	 SHORT $LN202@append
  00077	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0007a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0007e	72 10		 jb	 SHORT $LN133@append
  00080	8b 06		 mov	 eax, DWORD PTR [esi]
  00082	33 c9		 xor	 ecx, ecx
  00084	5f		 pop	 edi
  00085	66 89 08	 mov	 WORD PTR [eax], cx

; 1082 : 			}
; 1083 : 		return (*this);

  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx

; 1084 : 		}

  0008c	5d		 pop	 ebp
  0008d	c2 0c 00	 ret	 12			; 0000000cH

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN133@append:
  00090	8b c6		 mov	 eax, esi
  00092	33 c9		 xor	 ecx, ecx
  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	66 89 08	 mov	 WORD PTR [eax], cx

; 1084 : 		}

  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

$LN164@append:
  0009e	8b d6		 mov	 edx, esi
$LN165@append:
  000a0	85 c9		 test	 ecx, ecx
  000a2	74 1a		 je	 SHORT $LN180@append
  000a4	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  000a7	50		 push	 eax
  000a8	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  000ab	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  000ae	50		 push	 eax
  000af	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b2	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _memcpy
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN180@append:

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

  000be	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000c2	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000c5	72 11		 jb	 SHORT $LN193@append
  000c7	8b 06		 mov	 eax, DWORD PTR [esi]
  000c9	33 c9		 xor	 ecx, ecx
  000cb	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1082 : 			}
; 1083 : 		return (*this);

  000cf	8b c6		 mov	 eax, esi
  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx

; 1084 : 		}

  000d4	5d		 pop	 ebp
  000d5	c2 0c 00	 ret	 12			; 0000000cH

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

$LN193@append:
  000d8	8b c6		 mov	 eax, esi
  000da	33 c9		 xor	 ecx, ecx
  000dc	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN198@append:

; 1082 : 			}
; 1083 : 		return (*this);

  000e0	5f		 pop	 edi
  000e1	8b c6		 mov	 eax, esi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx

; 1084 : 		}

  000e5	5d		 pop	 ebp
  000e6	c2 0c 00	 ret	 12			; 0000000cH
$LN203@append:

; 1071 : 		_Right._Check_offset(_Roff);

  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000ee	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN207@append:
$LN205@append:

; 1074 : 			_Xlen();	// result too long

  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f8	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN208@append:
$LN206@append:

; 1077 : 		if (0 < _Count && _Grow(_Num))

  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00102	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN209@append:
$LN200@append:
  00107	cc		 int	 3
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1064 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1065 : 		return (append(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 1066 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=, COMDAT
; _this$ = ecx

; 1054 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1055 : 		return (append(_Ptr));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000d	75 0e		 jne	 SHORT $LN7@operator
  0000f	33 c0		 xor	 eax, eax
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00018	5e		 pop	 esi

; 1056 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4

; 1055 : 		return (append(_Ptr));

$LN7@operator:
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL9@operator:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL9@operator
  0002e	2b c7		 sub	 eax, edi
  00030	8b ce		 mov	 ecx, esi
  00032	5f		 pop	 edi
  00033	d1 f8		 sar	 eax, 1
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  0003c	5e		 pop	 esi

; 1056 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=, COMDAT
; _this$ = ecx

; 1049 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1050 : 		return (append(_Right));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 1051 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 1039 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1040 : 		return (assign(_Ptr));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000d	75 0e		 jne	 SHORT $LN7@operator
  0000f	33 c0		 xor	 eax, eax
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00018	5e		 pop	 esi

; 1041 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4

; 1040 : 		return (assign(_Ptr));

$LN7@operator:
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL9@operator:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL9@operator
  0002e	2b c7		 sub	 eax, edi
  00030	8b ce		 mov	 ecx, esi
  00032	5f		 pop	 edi
  00033	d1 f8		 sar	 eax, 1
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0003c	5e		 pop	 esi

; 1041 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 1023 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1024 : 		if (this != &_Right)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b f0		 cmp	 esi, eax
  0000b	74 0a		 je	 SHORT $LN134@operator

; 1025 : 			{	// different, assign it
; 1026 : 			if (this->_Getal() != _Right._Getal()
; 1027 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1028 : 				{	// change allocator before copying
; 1029 : 				_Tidy(true);
; 1030 : 				this->_Copy_alloc(_Right._Getal());
; 1031 : 				}
; 1032 : 
; 1033 : 			assign(_Right);

  0000d	6a ff		 push	 -1
  0000f	6a 00		 push	 0
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN134@operator:

; 1034 : 			}
; 1035 : 		return (*this);

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi

; 1036 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1017 : 		_Tidy(true);

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 08	 cmp	 eax, 8
  00009	72 09		 jb	 SHORT $LN6@basic_stri
  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN6@basic_stri:
  00014	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0001b	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	72 09		 jb	 SHORT $LN96@basic_stri
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	33 c9		 xor	 ecx, ecx
  0002c	5e		 pop	 esi
  0002d	66 89 08	 mov	 WORD PTR [eax], cx

; 1018 : 		}

  00030	c3		 ret	 0

; 1017 : 		_Tidy(true);

$LN96@basic_stri:
  00031	33 c0		 xor	 eax, eax
  00033	66 89 06	 mov	 WORD PTR [esi], ax
  00036	5e		 pop	 esi

; 1018 : 		}

  00037	c3		 ret	 0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv, COMDAT
; _this$ = ecx

; 961  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0000e	73 17		 jae	 SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	83 c0 01	 add	 eax, 1
  00016	74 1d		 je	 SHORT $LN3@Assign_rv
  00018	03 c0		 add	 eax, eax
  0001a	50		 push	 eax
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 964  : 				_Right._Mysize() + 1);
; 965  : 		else

  00025	eb 0e		 jmp	 SHORT $LN3@Assign_rv
$LN2@Assign_rv:

; 966  : 			{	// copy pointer
; 967  : 			this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Right._Bx()._Ptr);

  00027	85 ff		 test	 edi, edi
  00029	74 04		 je	 SHORT $LN86@Assign_rv
  0002b	8b 06		 mov	 eax, DWORD PTR [esi]
  0002d	89 07		 mov	 DWORD PTR [edi], eax
$LN86@Assign_rv:

; 968  : 			_Right._Bx()._Ptr = pointer();

  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

  00035	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00038	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

  0003b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0003e	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 972  : 		_Right._Tidy();

  00041	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00048	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0004c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00053	72 0d		 jb	 SHORT $LN231@Assign_rv
  00055	8b 06		 mov	 eax, DWORD PTR [esi]
  00057	33 c9		 xor	 ecx, ecx
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	66 89 08	 mov	 WORD PTR [eax], cx

; 973  : 		}

  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4

; 972  : 		_Right._Tidy();

$LN231@Assign_rv:
  00062	33 c0		 xor	 eax, eax
  00064	5f		 pop	 edi
  00065	66 89 06	 mov	 WORD PTR [esi], ax
  00068	5e		 pop	 esi

; 973  : 		}

  00069	5d		 pop	 ebp
  0006a	c2 04 00	 ret	 4
?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 928  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 929  : 		if (this != &_Right)

  00025	3b 75 08	 cmp	 esi, DWORD PTR __Right$[ebp]
  00028	74 3a		 je	 SHORT $LN296@operator

; 930  : 			{	// different, assign it
; 931  : 			_Tidy(true);

  0002a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002d	83 f8 08	 cmp	 eax, 8
  00030	72 09		 jb	 SHORT $LN10@operator
  00032	40		 inc	 eax
  00033	50		 push	 eax
  00034	ff 36		 push	 DWORD PTR [esi]
  00036	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN10@operator:
  0003b	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00042	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00046	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004d	72 04		 jb	 SHORT $LN100@operator
  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	eb 02		 jmp	 SHORT $LN101@operator
$LN100@operator:
  00053	8b c6		 mov	 eax, esi
$LN101@operator:

; 932  : 
; 933  : 			if (_Alty::propagate_on_container_move_assignment::value
; 934  : 				&& this->_Getal() != _Right._Getal())
; 935  : 				this->_Move_alloc(_Right._Getal());
; 936  : 
; 937  : 			if (this->_Getal() != _Right._Getal())
; 938  : 				assign(_Right.begin(), _Right.end());
; 939  : 			else
; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

  00055	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00058	33 c9		 xor	 ecx, ecx
  0005a	66 89 08	 mov	 WORD PTR [eax], cx
  0005d	8b ce		 mov	 ecx, esi
  0005f	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN296@operator:

; 941  : 			}
; 942  : 		return (*this);

  00064	8b c6		 mov	 eax, esi

; 943  : 		}

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	5e		 pop	 esi
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 911  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 912  : 		_Tidy();
; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00004	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	33 c0		 xor	 eax, eax
  0000b	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00012	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00019	66 89 06	 mov	 WORD PTR [esi], ax
  0001c	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv

; 914  : 		}

  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00012	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00019	66 89 06	 mov	 WORD PTR [esi], ax
  0001c	66 39 02	 cmp	 WORD PTR [edx], ax
  0001f	75 12		 jne	 SHORT $LN113@basic_stri
  00021	33 c9		 xor	 ecx, ecx
  00023	51		 push	 ecx
  00024	52		 push	 edx
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 839  : 		}

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

$LN113@basic_stri:
  00033	8b ca		 mov	 ecx, edx
  00035	57		 push	 edi
  00036	8d 79 02	 lea	 edi, DWORD PTR [ecx+2]
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL115@basic_stri:
  00040	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00043	83 c1 02	 add	 ecx, 2
  00046	66 85 c0	 test	 ax, ax
  00049	75 f5		 jne	 SHORT $LL115@basic_stri
  0004b	2b cf		 sub	 ecx, edi
  0004d	d1 f9		 sar	 ecx, 1
  0004f	5f		 pop	 edi
  00050	51		 push	 ecx
  00051	52		 push	 edx
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 839  : 		}

  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$ = 20						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 815  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 816  : 		_Tidy();
; 817  : 		assign(_Right, _Roff, _Count);

  00004	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	33 c0		 xor	 eax, eax
  0000b	ff 75 0c	 push	 DWORD PTR __Roff$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00011	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00018	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001f	66 89 06	 mov	 WORD PTR [esi], ax
  00022	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 818  : 		}

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 795  : 		_Tidy();

  00000	33 c0		 xor	 eax, eax
  00002	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  00009	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00010	66 89 01	 mov	 WORD PTR [ecx], ax

; 796  : 		}

  00013	8b c1		 mov	 eax, ecx
  00015	c3		 ret	 0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 781  : 		_Tidy();

  00006	33 c0		 xor	 eax, eax

; 782  : 		assign(_Right, 0, npos);

  00008	6a ff		 push	 -1
  0000a	50		 push	 eax
  0000b	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000e	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00015	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001c	66 89 06	 mov	 WORD PTR [esi], ax
  0001f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 783  : 		}

  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres, COMDAT
; _this$ = ecx

; 739  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 740  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 735  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 730  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 725  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

  00000	8b c1		 mov	 eax, ecx

; 715  : 		}

  00002	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 708  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 703  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 698  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 693  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Move_alloc, COMDAT
; _this$ = ecx

; 607  : 		_Pocma(_Getal(), _Al);
; 608  : 		}

  00000	c2 04 00	 ret	 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 602  : 		_Pocca(_Getal(), _Al);
; 603  : 		}

  00000	c2 04 00	 ret	 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

; 588  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 590  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 583  : 		return (_Get_data()._Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 584  : 		}

  00008	c3		 ret	 0

; 583  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 584  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 578  : 		return (_Get_data()._Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 579  : 		}

  00008	c3		 ret	 0

; 578  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 579  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 534  : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 499  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1009 : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000e	77 30		 ja	 SHORT $LN16@deallocate
  00010	03 c0		 add	 eax, eax
  00012	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00017	72 1a		 jb	 SHORT $LN7@deallocate
  00019	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001c	75 27		 jne	 SHORT $LN18@deallocate
  0001e	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00021	3b c1		 cmp	 eax, ecx
  00023	73 25		 jae	 SHORT $LN19@deallocate
  00025	2b c8		 sub	 ecx, eax
  00027	83 f9 04	 cmp	 ecx, 4
  0002a	72 23		 jb	 SHORT $LN20@deallocate
  0002c	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0002f	77 23		 ja	 SHORT $LN21@deallocate
  00031	8b c8		 mov	 ecx, eax
$LN7@deallocate:
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4

; 988  : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00040	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:
  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  00059	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 977  : 		}

  00003	5d		 pop	 ebp

; 976  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??4?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEAAU01@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 963  : 		_Mybase::operator=(_STD move(_Right));
; 964  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 965  : 		}

  00002	c2 04 00	 ret	 4
??4?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?address@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEPA_WAA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?address@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEPA_WAA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::address, COMDAT
; _this$ = ecx

; 925  : 		{	// return address of mutable _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 926  : 		return (pointer_traits<pointer>::pointer_to(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 927  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?address@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEPA_WAA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 870  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@_W@std@@QBEIXZ PROC		; std::allocator<wchar_t>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 750  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@_W@std@@QBEIXZ ENDP		; std::allocator<wchar_t>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z PROC		; std::allocator<wchar_t>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00013	77 3b		 ja	 SHORT $LN14@allocate
  00015	03 c0		 add	 eax, eax
  00017	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001c	72 23		 jb	 SHORT $LN6@allocate
  0001e	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00021	3b c8		 cmp	 ecx, eax
  00023	76 30		 jbe	 SHORT $LN16@allocate
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002b	8b c8		 mov	 ecx, eax
  0002d	83 c4 04	 add	 esp, 4
  00030	85 c9		 test	 ecx, ecx
  00032	74 26		 je	 SHORT $LN17@allocate
  00034	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00037	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0003a	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00047	83 c4 04	 add	 esp, 4
  0004a	85 c0		 test	 eax, eax
  0004c	75 bc		 jne	 SHORT $LN12@allocate
  0004e	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:
  00050	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:
  00055	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:
  0005a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:
  0005f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00064	cc		 int	 3
?allocate@?$allocator@_W@std@@QAEPA_WI@Z ENDP		; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000e	77 30		 ja	 SHORT $LN13@deallocate
  00010	03 c0		 add	 eax, eax
  00012	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00017	72 1a		 jb	 SHORT $LN5@deallocate
  00019	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001c	75 27		 jne	 SHORT $LN15@deallocate
  0001e	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00021	3b c1		 cmp	 eax, ecx
  00023	73 25		 jae	 SHORT $LN16@deallocate
  00025	2b c8		 sub	 ecx, eax
  00027	83 f9 04	 cmp	 ecx, 4
  0002a	72 23		 jb	 SHORT $LN17@deallocate
  0002c	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0002f	77 23		 ja	 SHORT $LN18@deallocate
  00031	8b c8		 mov	 ecx, eax
$LN5@deallocate:
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4

; 721  : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00040	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:
  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  00059	cc		 int	 3
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@_W@std@@QAE@ABV01@@Z PROC		; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@_W@std@@QAE@ABV01@@Z ENDP		; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_W@std@@QAE@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	72 04		 jb	 SHORT $LN17@Check_offs

; 2273 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN17@Check_offs:

; 2272 : 			_Xran();

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN19@Check_offs:
$LN16@Check_offs:
  00019	cc		 int	 3
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2266 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2249 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 26		 je	 SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 20		 jb	 SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN57@Tidy

; 2256 : 				_Traits::copy(this->_Bx()._Buf,

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@Tidy:

; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00028	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002b	8b ce		 mov	 ecx, esi
  0002d	40		 inc	 eax
  0002e	50		 push	 eax
  0002f	53		 push	 ebx
  00030	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  00035	5b		 pop	 ebx
$LN4@Tidy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00036	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2261 : 		_Eos(_Newsize);

  0003d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00041	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00044	72 0c		 jb	 SHORT $LN92@Tidy
  00046	8b 06		 mov	 eax, DWORD PTR [esi]
  00048	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi

; 2262 : 		}

  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8

; 2261 : 		_Eos(_Newsize);

$LN92@Tidy:
  00052	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 2262 : 		}

  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	74 2d		 je	 SHORT $LN4@Inside
  0000b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00011	72 04		 jb	 SHORT $LN16@Inside
  00013	8b 31		 mov	 esi, DWORD PTR [ecx]
  00015	eb 02		 jmp	 SHORT $LN17@Inside
$LN16@Inside:
  00017	8b f1		 mov	 esi, ecx
$LN17@Inside:
  00019	3b d6		 cmp	 edx, esi
  0001b	72 1b		 jb	 SHORT $LN4@Inside
  0001d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00020	72 04		 jb	 SHORT $LN30@Inside
  00022	8b 31		 mov	 esi, DWORD PTR [ecx]
  00024	eb 02		 jmp	 SHORT $LN31@Inside
$LN30@Inside:
  00026	8b f1		 mov	 esi, ecx
$LN31@Inside:
  00028	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002b	03 c6		 add	 eax, esi
  0002d	3b c2		 cmp	 eax, edx
  0002f	76 07		 jbe	 SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

  00031	b0 01		 mov	 al, 1
  00033	5e		 pop	 esi

; 2244 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 2244 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2225 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0000a	77 59		 ja	 SHORT $LN89@Grow

; 2227 : 		if (this->_Myres() < _Newsize)

  0000c	39 71 14	 cmp	 DWORD PTR [ecx+20], esi
  0000f	73 13		 jae	 SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00011	ff 71 10	 push	 DWORD PTR [ecx+16]
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0001a	85 f6		 test	 esi, esi
  0001c	5e		 pop	 esi
  0001d	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00024	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  00028	74 1f		 je	 SHORT $LN5@Grow
  0002a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0002d	73 1a		 jae	 SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  0002f	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00032	3b f0		 cmp	 esi, eax
  00034	0f 42 c6	 cmovb	 eax, esi
  00037	50		 push	 eax
  00038	6a 01		 push	 1
  0003a	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  0003f	85 f6		 test	 esi, esi
  00041	5e		 pop	 esi
  00042	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

  00049	85 f6		 test	 esi, esi
  0004b	75 10		 jne	 SHORT $LN88@Grow

; 2233 : 			_Eos(0);	// new size is zero, just null terminate

  0004d	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00051	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  00054	72 02		 jb	 SHORT $LN80@Grow
  00056	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN80@Grow:
  00058	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0005b	85 f6		 test	 esi, esi
$LN88@Grow:
  0005d	0f 95 c0	 setne	 al
  00060	5e		 pop	 esi

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN89@Grow:

; 2226 : 			_Xlen();	// result too long

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0006a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN91@Grow:
$LN87@Grow:
  0006f	cc		 int	 3
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0000a	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000d	72 0a		 jb	 SHORT $LN11@Eos
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0

; 2220 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

$LN11@Eos:
  00019	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0

; 2220 : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f8		 mov	 edi, eax
  00035	83 cf 0f	 or	 edi, 15			; 0000000fH

; 2184 : 		if (max_size() < _Newres)

  00038	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0003b	76 04		 jbe	 SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

  0003d	8b f8		 mov	 edi, eax
  0003f	eb 27		 jmp	 SHORT $LN108@Copy
$LN2@Copy:

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  00041	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00044	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00049	f7 e7		 mul	 edi
  0004b	8b cb		 mov	 ecx, ebx
  0004d	d1 e9		 shr	 ecx, 1
  0004f	d1 ea		 shr	 edx, 1
  00051	3b ca		 cmp	 ecx, edx
  00053	76 13		 jbe	 SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 2189 : 			_Newres = this->_Myres()

  0005a	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]
  0005d	2b c1		 sub	 eax, ecx
  0005f	3b d8		 cmp	 ebx, eax
  00061	76 05		 jbe	 SHORT $LN108@Copy

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()

  00063	bf fe ff ff ff	 mov	 edi, -2			; fffffffeH
$LN108@Copy:

; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  00068	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0006b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00072	85 c0		 test	 eax, eax
  00074	75 04		 jne	 SHORT $LN136@Copy
  00076	33 db		 xor	 ebx, ebx
  00078	eb 6d		 jmp	 SHORT $LN19@Copy
$LN136@Copy:
  0007a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0007f	72 29		 jb	 SHORT $LN138@Copy
  00081	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00084	3b c8		 cmp	 ecx, eax
  00086	77 05		 ja	 SHORT $LN140@Copy
  00088	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN435@Copy:
$LN140@Copy:
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00093	83 c4 04	 add	 esp, 4
  00096	85 c0		 test	 eax, eax
  00098	75 05		 jne	 SHORT $LN141@Copy
  0009a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN436@Copy:
$LN141@Copy:
  0009f	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  000a2	83 e3 e0	 and	 ebx, -32		; ffffffe0H
  000a5	89 43 fc	 mov	 DWORD PTR [ebx-4], eax
  000a8	eb 3d		 jmp	 SHORT $LN19@Copy
$LN138@Copy:
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b0	8b d8		 mov	 ebx, eax
  000b2	83 c4 04	 add	 esp, 4
  000b5	85 db		 test	 ebx, ebx
  000b7	75 2e		 jne	 SHORT $LN19@Copy
  000b9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN437@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000be	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  000c1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax
  000c7	40		 inc	 eax
  000c8	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  000cb	50		 push	 eax
  000cc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000d0	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  000d5	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

  000d8	b8 00 00 00 00	 mov	 eax, $LN432@Copy
  000dd	c3		 ret	 0
$LN432@Copy:
  000de	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000e1	8b 7d 08	 mov	 edi, DWORD PTR __Newres$[ebp]
  000e4	8b 5d e8	 mov	 ebx, DWORD PTR __Ptr$[ebp]
$LN19@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

  000e7	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  000ea	85 c0		 test	 eax, eax
  000ec	74 1b		 je	 SHORT $LN270@Copy

; 2208 : 			_Traits::copy(_Unfancy(_Ptr), this->_Myptr(),

  000ee	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000f2	72 04		 jb	 SHORT $LN261@Copy
  000f4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000f6	eb 02		 jmp	 SHORT $LN262@Copy
$LN261@Copy:
  000f8	8b ce		 mov	 ecx, esi
$LN262@Copy:
  000fa	85 c0		 test	 eax, eax
  000fc	74 0b		 je	 SHORT $LN270@Copy
  000fe	50		 push	 eax
  000ff	51		 push	 ecx
  00100	53		 push	 ebx
  00101	e8 00 00 00 00	 call	 _memcpy
  00106	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN270@Copy:

; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);

  00109	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0010c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0010f	72 0b		 jb	 SHORT $LN274@Copy
  00111	40		 inc	 eax
  00112	8b ce		 mov	 ecx, esi
  00114	50		 push	 eax
  00115	ff 36		 push	 DWORD PTR [esi]
  00117	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN274@Copy:
  0011c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00123	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00127	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0012e	72 04		 jb	 SHORT $LN362@Copy
  00130	8b 06		 mov	 eax, DWORD PTR [esi]
  00132	eb 02		 jmp	 SHORT $LN363@Copy
$LN362@Copy:
  00134	8b c6		 mov	 eax, esi
$LN363@Copy:
  00136	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2211 : 		this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Ptr);
; 2212 : 		this->_Myres() = _Newres;
; 2213 : 		_Eos(_Oldlen);

  00139	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  0013c	89 1e		 mov	 DWORD PTR [esi], ebx
  0013e	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00141	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00145	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00148	72 02		 jb	 SHORT $LN426@Copy
  0014a	8b f3		 mov	 esi, ebx
$LN426@Copy:
  0014c	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0

; 2214 : 		}

  00150	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00153	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015a	59		 pop	 ecx
  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

  00164	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00167	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0016a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0016d	72 0b		 jb	 SHORT $LN156@Copy
  0016f	40		 inc	 eax
  00170	8b ce		 mov	 ecx, esi
  00172	50		 push	 eax
  00173	ff 36		 push	 DWORD PTR [esi]
  00175	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN156@Copy:
  0017a	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00181	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00185	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0018c	72 02		 jb	 SHORT $LN245@Copy
  0018e	8b 36		 mov	 esi, DWORD PTR [esi]
$LN245@Copy:

; 2203 : 			_RERAISE;

  00190	6a 00		 push	 0
  00192	6a 00		 push	 0
  00194	c6 06 00	 mov	 BYTE PTR [esi], 0
  00197	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN438@Copy:
$LN434@Copy:
  0019c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$ = ecx

; 2168 : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2169 : 		allocator_type _Ret(this->_Getal());
; 2170 : 		return (_Ret);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2171 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 2144 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	80 3a 00	 cmp	 BYTE PTR [edx], 0
  0000b	75 04		 jne	 SHORT $LN5@compare
  0000d	33 f6		 xor	 esi, esi
  0000f	eb 0e		 jmp	 SHORT $LN6@compare
$LN5@compare:
  00011	8b f2		 mov	 esi, edx
  00013	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]
$LL35@compare:
  00016	8a 06		 mov	 al, BYTE PTR [esi]
  00018	46		 inc	 esi
  00019	84 c0		 test	 al, al
  0001b	75 f9		 jne	 SHORT $LL35@compare
  0001d	2b f7		 sub	 esi, edi
$LN6@compare:
  0001f	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00023	8d 79 10	 lea	 edi, DWORD PTR [ecx+16]
  00026	72 02		 jb	 SHORT $LN26@compare
  00028	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN26@compare:
  0002a	8b 3f		 mov	 edi, DWORD PTR [edi]
  0002c	8b c6		 mov	 eax, esi
  0002e	3b fe		 cmp	 edi, esi
  00030	0f 42 c7	 cmovb	 eax, edi
  00033	50		 push	 eax
  00034	52		 push	 edx
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003e	85 c0		 test	 eax, eax
  00040	75 11		 jne	 SHORT $LN33@compare
  00042	3b f7		 cmp	 esi, edi
  00044	76 09		 jbe	 SHORT $LN36@compare
  00046	5f		 pop	 edi
  00047	83 c8 ff	 or	 eax, -1
  0004a	5e		 pop	 esi

; 2147 : 			_Ptr, _Traits::length(_Ptr)));
; 2148 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
$LN36@compare:

; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

  0004f	1b c0		 sbb	 eax, eax
  00051	f7 d8		 neg	 eax
$LN33@compare:
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi

; 2147 : 			_Ptr, _Traits::length(_Ptr)));
; 2148 : 		}

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 2120 : 		{	// compare [0, _Mysize()) with _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  0000c	8d 72 10	 lea	 esi, DWORD PTR [edx+16]
  0000f	72 02		 jb	 SHORT $LN22@compare
  00011	8b 12		 mov	 edx, DWORD PTR [edx]
$LN22@compare:
  00013	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00017	8d 79 10	 lea	 edi, DWORD PTR [ecx+16]
  0001a	72 02		 jb	 SHORT $LN45@compare
  0001c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN45@compare:
  0001e	8b 36		 mov	 esi, DWORD PTR [esi]
  00020	8b c6		 mov	 eax, esi
  00022	8b 3f		 mov	 edi, DWORD PTR [edi]
  00024	3b fe		 cmp	 edi, esi
  00026	0f 42 c7	 cmovb	 eax, edi
  00029	50		 push	 eax
  0002a	52		 push	 edx
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	85 c0		 test	 eax, eax
  00036	75 11		 jne	 SHORT $LN52@compare
  00038	3b f7		 cmp	 esi, edi
  0003a	76 09		 jbe	 SHORT $LN54@compare
  0003c	5f		 pop	 edi
  0003d	83 c8 ff	 or	 eax, -1
  00040	5e		 pop	 esi

; 2122 : 			_Right._Myptr(), _Right._Mysize()));
; 2123 : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN54@compare:

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

  00045	1b c0		 sbb	 eax, eax
  00047	f7 d8		 neg	 eax
$LN52@compare:
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi

; 2122 : 			_Right._Myptr(), _Right._Mysize()));
; 2123 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

  00009	39 45 0c	 cmp	 DWORD PTR __Size$[ebp], eax
  0000c	0f 46 45 0c	 cmovbe	 eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Traits_compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAHQBDI0I@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Left_size$ = 12					; size = 4
__Right$ = 16						; size = 4
__Right_size$ = 20					; size = 4
?_Traits_compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAHQBDI0I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Traits_compare, COMDAT

; 2094 : 		{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

  00004	8b 75 14	 mov	 esi, DWORD PTR __Right_size$[ebp]
  00007	8b c6		 mov	 eax, esi
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR __Left_size$[ebp]
  0000d	3b fe		 cmp	 edi, esi
  0000f	0f 42 c7	 cmovb	 eax, edi

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

  00012	50		 push	 eax
  00013	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  00016	ff 75 08	 push	 DWORD PTR __Left$[ebp]
  00019	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2097 : 
; 2098 : 		if (_Ans != 0)

  00021	85 c0		 test	 eax, eax
  00023	75 0f		 jne	 SHORT $LN4@Traits_com

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

  00025	3b f7		 cmp	 esi, edi
  00027	76 07		 jbe	 SHORT $LN6@Traits_com

; 2102 : 			return (-1);

  00029	5f		 pop	 edi
  0002a	83 c8 ff	 or	 eax, -1
  0002d	5e		 pop	 esi

; 2105 : 			return (1);
; 2106 : 
; 2107 : 		return (0);
; 2108 : 		}

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN6@Traits_com:

; 2103 : 
; 2104 : 		if (_Left_size > _Right_size)

  00030	1b c0		 sbb	 eax, eax
  00032	f7 d8		 neg	 eax
$LN4@Traits_com:
  00034	5f		 pop	 edi
  00035	5e		 pop	 esi

; 2105 : 			return (1);
; 2106 : 
; 2107 : 		return (0);
; 2108 : 		}

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?_Traits_compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAHQBDI0I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Traits_compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT
; _this$ = ecx

; 2088 : 		{	// return [_Off, _Off + _Count) as new string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 2089 : 		return (_Myt(*this, _Off, _Count, get_allocator()));

  00005	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00015	51		 push	 ecx
  00016	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001d	8b ce		 mov	 ecx, esi
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	c6 06 00	 mov	 BYTE PTR [esi], 0
  00029	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi

; 2090 : 		}

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind, COMDAT
; _this$ = ecx

; 1934 : 		{	// look for [_Ptr, <null>) beginning before _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1935 : 		_DEBUG_POINTER(_Ptr);
; 1936 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 11		 jne	 SHORT $LN5@rfind
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
  00018	5e		 pop	 esi

; 1937 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8

; 1935 : 		_DEBUG_POINTER(_Ptr);
; 1936 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));

$LN5@rfind:
  0001d	8b d6		 mov	 edx, esi
  0001f	57		 push	 edi
  00020	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@rfind:
  00023	8a 02		 mov	 al, BYTE PTR [edx]
  00025	42		 inc	 edx
  00026	84 c0		 test	 al, al
  00028	75 f9		 jne	 SHORT $LL7@rfind
  0002a	2b d7		 sub	 edx, edi
  0002c	5f		 pop	 edi
  0002d	52		 push	 edx
  0002e	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
  00037	5e		 pop	 esi

; 1937 : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
tv298 = 15						; size = 1
__Count$ = 16						; size = 4
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind, COMDAT
; _this$ = ecx

; 1912 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1913 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1914 : 		if (_Count == 0)

  00004	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	75 10		 jne	 SHORT $LN5@rfind

; 1915 : 			return (_Off < this->_Mysize() ? _Off

  0000e	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00011	39 45 0c	 cmp	 DWORD PTR __Off$[ebp], eax
  00014	5f		 pop	 edi
  00015	0f 42 45 0c	 cmovb	 eax, DWORD PTR __Off$[ebp]
  00019	5b		 pop	 ebx

; 1931 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
$LN5@rfind:

; 1916 : 				: this->_Mysize());	// null always matches
; 1917 : 		if (_Count <= this->_Mysize())

  0001e	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00021	56		 push	 esi
  00022	3b d9		 cmp	 ebx, ecx
  00024	77 5a		 ja	 SHORT $LN93@rfind

; 1918 : 			{	// room for match, look for it
; 1919 : 			const _Elem *_Uptr = this->_Myptr() +

  00026	2b cb		 sub	 ecx, ebx
  00028	39 4d 0c	 cmp	 DWORD PTR __Off$[ebp], ecx
  0002b	0f 42 4d 0c	 cmovb	 ecx, DWORD PTR __Off$[ebp]
  0002f	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00033	72 04		 jb	 SHORT $LN70@rfind
  00035	8b 07		 mov	 eax, DWORD PTR [edi]
  00037	eb 02		 jmp	 SHORT $LN71@rfind
$LN70@rfind:
  00039	8b c7		 mov	 eax, edi
$LN71@rfind:
  0003b	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 1923 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1924 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)

  0003e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00041	8a 08		 mov	 cl, BYTE PTR [eax]
  00043	88 4d 0f	 mov	 BYTE PTR tv298[ebp], cl
$LL4@rfind:
  00046	38 0e		 cmp	 BYTE PTR [esi], cl
  00048	75 0f		 jne	 SHORT $LN7@rfind
  0004a	53		 push	 ebx
  0004b	50		 push	 eax
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	85 c0		 test	 eax, eax
  00057	74 14		 je	 SHORT $LN92@rfind
$LN7@rfind:

; 1926 : 				else if (_Uptr == this->_Myptr())

  00059	8b cf		 mov	 ecx, edi
  0005b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00060	3b f0		 cmp	 esi, eax
  00062	74 1c		 je	 SHORT $LN93@rfind

; 1920 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1921 : 					: this->_Mysize() - _Count);
; 1922 : 			for (; ; --_Uptr)

  00064	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00067	4e		 dec	 esi
  00068	8a 4d 0f	 mov	 cl, BYTE PTR tv298[ebp]
  0006b	eb d9		 jmp	 SHORT $LL4@rfind
$LN92@rfind:

; 1925 : 					return (_Uptr - this->_Myptr());	// found a match

  0006d	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00071	72 02		 jb	 SHORT $LN87@rfind
  00073	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN87@rfind:
  00075	2b f7		 sub	 esi, edi
  00077	8b c6		 mov	 eax, esi
  00079	5e		 pop	 esi
  0007a	5f		 pop	 edi
  0007b	5b		 pop	 ebx

; 1931 : 		}

  0007c	5d		 pop	 ebp
  0007d	c2 0c 00	 ret	 12			; 0000000cH
$LN93@rfind:
  00080	5e		 pop	 esi
  00081	5f		 pop	 edi

; 1927 : 					break;	// at beginning, no more chance for match
; 1928 : 			}
; 1929 : 
; 1930 : 		return (npos);	// no match

  00082	83 c8 ff	 or	 eax, -1
  00085	5b		 pop	 ebx

; 1931 : 		}

  00086	5d		 pop	 ebp
  00087	c2 0c 00	 ret	 12			; 0000000cH
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1895 : 		{	// look for [_Ptr, <null>) beginning at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1896 : 		_DEBUG_POINTER(_Ptr);
; 1897 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 11		 jne	 SHORT $LN5@find
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00018	5e		 pop	 esi

; 1898 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8

; 1896 : 		_DEBUG_POINTER(_Ptr);
; 1897 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));

$LN5@find:
  0001d	8b d6		 mov	 edx, esi
  0001f	57		 push	 edi
  00020	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@find:
  00023	8a 02		 mov	 al, BYTE PTR [edx]
  00025	42		 inc	 edx
  00026	84 c0		 test	 al, al
  00028	75 f9		 jne	 SHORT $LL7@find
  0002a	2b d7		 sub	 edx, edi
  0002c	5f		 pop	 edi
  0002d	52		 push	 edx
  0002e	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00037	5e		 pop	 esi

; 1898 : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1875 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1876 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1877 : 		if (_Count == 0 && _Off <= this->_Mysize())

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00007	53		 push	 ebx
  00008	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000b	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000e	85 db		 test	 ebx, ebx
  00010	75 0e		 jne	 SHORT $LN5@find
  00012	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00015	77 09		 ja	 SHORT $LN5@find

; 1878 : 			return (_Off);	// null string always matches (if inside string)

  00017	8b c2		 mov	 eax, edx
  00019	5b		 pop	 ebx

; 1892 : 		}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
$LN5@find:
  00020	56		 push	 esi

; 1879 : 
; 1880 : 		size_type _Nm;
; 1881 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))

  00021	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  00024	57		 push	 edi
  00025	3b d6		 cmp	 edx, esi
  00027	73 6a		 jae	 SHORT $LN3@find
  00029	2b f2		 sub	 esi, edx
  0002b	3b de		 cmp	 ebx, esi
  0002d	77 64		 ja	 SHORT $LN3@find

; 1882 : 			{	// room for match, look for it
; 1883 : 			const _Elem *_Uptr, *_Vptr;
; 1884 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	2b c3		 sub	 eax, ebx
  00036	03 f0		 add	 esi, eax
  00038	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0003c	72 02		 jb	 SHORT $LN46@find
  0003e	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN46@find:
  00040	8d 1c 11	 lea	 ebx, DWORD PTR [ecx+edx]
$LL4@find:

; 1885 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;

  00043	85 f6		 test	 esi, esi
  00045	74 4c		 je	 SHORT $LN3@find
  00047	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004a	56		 push	 esi
  0004b	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0004e	50		 push	 eax
  0004f	53		 push	 ebx
  00050	e8 00 00 00 00	 call	 _memchr
  00055	8b f8		 mov	 edi, eax
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	85 ff		 test	 edi, edi
  0005c	74 35		 je	 SHORT $LN3@find

; 1887 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)

  0005e	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00061	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00064	57		 push	 edi
  00065	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	85 c0		 test	 eax, eax
  0006f	74 0a		 je	 SHORT $LN69@find

; 1886 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)

  00071	2b df		 sub	 ebx, edi
  00073	4b		 dec	 ebx
  00074	03 f3		 add	 esi, ebx
  00076	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]
  00079	eb c8		 jmp	 SHORT $LL4@find
$LN69@find:

; 1888 : 					return (_Uptr - this->_Myptr());	// found a match

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  0007e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00082	72 02		 jb	 SHORT $LN64@find
  00084	8b 00		 mov	 eax, DWORD PTR [eax]
$LN64@find:
  00086	2b f8		 sub	 edi, eax
  00088	8b c7		 mov	 eax, edi
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx

; 1892 : 		}

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 0c 00	 ret	 12			; 0000000cH
$LN3@find:
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi

; 1889 : 			}
; 1890 : 
; 1891 : 		return (npos);	// no match

  00095	83 c8 ff	 or	 eax, -1
  00098	5b		 pop	 ebx

; 1892 : 		}

  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 1803 : 		{	// test if sequence is empty

  00000	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00004	0f 94 c0	 sete	 al

; 1804 : 		return (this->_Mysize() == 0);
; 1805 : 		}

  00007	c3		 ret	 0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1772 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1765 : 		return (this->_Mysize());

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1766 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1743 : 		return (this->_Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN13@c_str
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1744 : 		}

  00008	c3		 ret	 0

; 1743 : 		return (this->_Myptr());

$LN13@c_str:
  00009	8b c1		 mov	 eax, ecx

; 1744 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1679 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1680 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1681 : 		if (this->_Mysize() < _Off)	// sic
; 1682 : 			_DEBUG_ERROR("string subscript out of range");
; 1683 : 
; 1684 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1685 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1686 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1687 : 
; 1688 : 		return (this->_Myptr()[_Off]);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	72 02		 jb	 SHORT $LN13@operator
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN13@operator:
  0000e	03 c1		 add	 eax, ecx

; 1689 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 1606 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1607 : 		auto _Mydata = &this->_Get_data();
; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	72 10		 jb	 SHORT $LN11@end
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000e	03 c8		 add	 ecx, eax
  00010	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00013	89 08		 mov	 DWORD PTR [eax], ecx

; 1609 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4

; 1607 : 		auto _Mydata = &this->_Get_data();
; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

$LN11@end:
  00019	8b c1		 mov	 eax, ecx
  0001b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0001e	03 c8		 add	 ecx, eax
  00020	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 1609 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 1594 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1595 : 		auto _Mydata = &this->_Get_data();
; 1596 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	72 02		 jb	 SHORT $LN11@begin
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN11@begin:
  0000e	89 08		 mov	 DWORD PTR [eax], ecx

; 1597 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1584 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1585 : 		if (_First2 == _Last2)

  00003	8b 45 10	 mov	 eax, DWORD PTR __First2$[ebp]
  00006	8b 55 14	 mov	 edx, DWORD PTR __Last2$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	3b c2		 cmp	 eax, edx
  0000e	75 36		 jne	 SHORT $LN2@replace

; 1586 : 			erase(_First - begin(), _Last - _First);

  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00013	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00016	2b c8		 sub	 ecx, eax
  00018	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0001c	72 14		 jb	 SHORT $LN24@replace
  0001e	8b 16		 mov	 edx, DWORD PTR [esi]
  00020	2b c2		 sub	 eax, edx
  00022	51		 push	 ecx
  00023	50		 push	 eax
  00024	8b ce		 mov	 ecx, esi
  00026	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  0002b	8b c6		 mov	 eax, esi
  0002d	5e		 pop	 esi

; 1591 : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 10 00	 ret	 16			; 00000010H

; 1586 : 			erase(_First - begin(), _Last - _First);

$LN24@replace:
  00032	8b d6		 mov	 edx, esi
  00034	51		 push	 ecx
  00035	2b c2		 sub	 eax, edx
  00037	8b ce		 mov	 ecx, esi
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  0003f	8b c6		 mov	 eax, esi
  00041	5e		 pop	 esi

; 1591 : 		}

  00042	5d		 pop	 ebp
  00043	c2 10 00	 ret	 16			; 00000010H
$LN2@replace:

; 1587 : 		else
; 1588 : 			replace(_First - begin(), _Last - _First,

  00046	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00049	2b d0		 sub	 edx, eax
  0004b	53		 push	 ebx
  0004c	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0004f	2b d9		 sub	 ebx, ecx
  00051	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00055	57		 push	 edi
  00056	72 04		 jb	 SHORT $LN76@replace
  00058	8b 3e		 mov	 edi, DWORD PTR [esi]
  0005a	eb 02		 jmp	 SHORT $LN77@replace
$LN76@replace:
  0005c	8b fe		 mov	 edi, esi
$LN77@replace:
  0005e	52		 push	 edx
  0005f	50		 push	 eax
  00060	2b cf		 sub	 ecx, edi
  00062	53		 push	 ebx
  00063	51		 push	 ecx
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
  0006b	5f		 pop	 edi
  0006c	5b		 pop	 ebx

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi

; 1591 : 		}

  00070	5d		 pop	 ebp
  00071	c2 10 00	 ret	 16			; 00000010H
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z
_TEXT	SEGMENT
__Nm$1$ = -8						; size = 4
tv890 = -4						; size = 4
tv887 = -4						; size = 4
__Off$ = 8						; size = 4
tv891 = 12						; size = 4
tv888 = 12						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1453 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1454 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1455 : 		if (_Inside(_Ptr))

  00003	8b 55 10	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	85 d2		 test	 edx, edx
  0000f	74 4d		 je	 SHORT $LN2@replace
  00011	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00014	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00017	72 04		 jb	 SHORT $LN24@replace
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	eb 02		 jmp	 SHORT $LN25@replace
$LN24@replace:
  0001d	8b c6		 mov	 eax, esi
$LN25@replace:
  0001f	3b d0		 cmp	 edx, eax
  00021	72 3b		 jb	 SHORT $LN2@replace
  00023	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00026	72 04		 jb	 SHORT $LN38@replace
  00028	8b 3e		 mov	 edi, DWORD PTR [esi]
  0002a	eb 02		 jmp	 SHORT $LN39@replace
$LN38@replace:
  0002c	8b fe		 mov	 edi, esi
$LN39@replace:
  0002e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00031	03 c7		 add	 eax, edi
  00033	3b c2		 cmp	 eax, edx
  00035	76 27		 jbe	 SHORT $LN2@replace

; 1456 : 			return (replace(_Off, _N0, *this,

  00037	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0003a	72 04		 jb	 SHORT $LN61@replace
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	eb 02		 jmp	 SHORT $LN62@replace
$LN61@replace:
  00040	8b c6		 mov	 eax, esi
$LN62@replace:
  00042	ff 75 14	 push	 DWORD PTR __Count$[ebp]
  00045	2b d0		 sub	 edx, eax
  00047	8b ce		 mov	 ecx, esi
  00049	52		 push	 edx
  0004a	56		 push	 esi
  0004b	ff 75 0c	 push	 DWORD PTR __N0$[ebp]
  0004e	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00051	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 1480 : 		}

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 10 00	 ret	 16			; 00000010H
$LN2@replace:

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);

  0005e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00061	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00064	3b c8		 cmp	 ecx, eax
  00066	0f 82 61 01 00
	00		 jb	 $LN312@replace

; 1460 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1461 : 		if (npos - _Count <= this->_Mysize() - _N0)

  0006c	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  0006f	8b f9		 mov	 edi, ecx
  00071	2b f8		 sub	 edi, eax
  00073	8b c2		 mov	 eax, edx
  00075	53		 push	 ebx
  00076	8b 5d 0c	 mov	 ebx, DWORD PTR __N0$[ebp]
  00079	f7 d0		 not	 eax
  0007b	3b df		 cmp	 ebx, edi
  0007d	0f 47 df	 cmova	 ebx, edi
  00080	2b cb		 sub	 ecx, ebx
  00082	3b c1		 cmp	 eax, ecx
  00084	0f 86 4d 01 00
	00		 jbe	 $LN314@replace

; 1463 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;

  0008a	2b fb		 sub	 edi, ebx
  0008c	89 7d f8	 mov	 DWORD PTR __Nm$1$[ebp], edi

; 1464 : 
; 1465 : 		if (_Count < _N0)

  0008f	3b d3		 cmp	 edx, ebx
  00091	73 43		 jae	 SHORT $LN145@replace

; 1466 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00093	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00096	83 f8 10	 cmp	 eax, 16			; 00000010H
  00099	72 07		 jb	 SHORT $LN124@replace
  0009b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0009d	89 4d 0c	 mov	 DWORD PTR tv891[ebp], ecx
  000a0	eb 03		 jmp	 SHORT $LN125@replace
$LN124@replace:
  000a2	89 75 0c	 mov	 DWORD PTR tv891[ebp], esi
$LN125@replace:
  000a5	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a8	72 07		 jb	 SHORT $LN138@replace
  000aa	8b 06		 mov	 eax, DWORD PTR [esi]
  000ac	89 45 fc	 mov	 DWORD PTR tv890[ebp], eax
  000af	eb 03		 jmp	 SHORT $LN139@replace
$LN138@replace:
  000b1	89 75 fc	 mov	 DWORD PTR tv890[ebp], esi
$LN139@replace:
  000b4	85 ff		 test	 edi, edi
  000b6	74 1e		 je	 SHORT $LN145@replace
  000b8	8b 45 0c	 mov	 eax, DWORD PTR tv891[ebp]
  000bb	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  000be	03 c3		 add	 eax, ebx
  000c0	57		 push	 edi
  000c1	50		 push	 eax
  000c2	8b 45 fc	 mov	 eax, DWORD PTR tv890[ebp]
  000c5	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  000c8	03 c2		 add	 eax, edx
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _memmove
  000d0	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN145@replace:

; 1467 : 				this->_Myptr() + _Off + _N0,
; 1468 : 				_Nm);	// smaller hole, move tail up
; 1469 : 		const size_type _Num = this->_Mysize() + _Count - _N0;

  000d6	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000d9	8b f8		 mov	 edi, eax
  000db	2b fb		 sub	 edi, ebx
  000dd	03 fa		 add	 edi, edx

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

  000df	85 d2		 test	 edx, edx
  000e1	75 08		 jne	 SHORT $LN6@replace
  000e3	85 db		 test	 ebx, ebx
  000e5	0f 84 d7 00 00
	00		 je	 $LN306@replace
$LN6@replace:
  000eb	83 ff fe	 cmp	 edi, -2			; fffffffeH
  000ee	0f 87 ed 00 00
	00		 ja	 $LN315@replace
  000f4	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  000f7	73 27		 jae	 SHORT $LN157@replace
  000f9	50		 push	 eax
  000fa	57		 push	 edi
  000fb	8b ce		 mov	 ecx, esi
  000fd	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00102	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  00105	85 ff		 test	 edi, edi
  00107	0f 84 b5 00 00
	00		 je	 $LN306@replace
$LN311@replace:

; 1472 : 			{	// make room and rearrange
; 1473 : 			if (_N0 < _Count)

  0010d	3b da		 cmp	 ebx, edx
  0010f	73 71		 jae	 SHORT $LN272@replace

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

  00111	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00114	83 f8 10	 cmp	 eax, 16			; 00000010H
  00117	72 32		 jb	 SHORT $LN251@replace
  00119	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0011b	89 4d 0c	 mov	 DWORD PTR tv888[ebp], ecx
  0011e	eb 2e		 jmp	 SHORT $LN252@replace

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

$LN157@replace:
  00120	85 ff		 test	 edi, edi
  00122	75 e9		 jne	 SHORT $LN311@replace
  00124	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00127	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0012b	72 10		 jb	 SHORT $LN234@replace
  0012d	8b 06		 mov	 eax, DWORD PTR [esi]
  0012f	5b		 pop	 ebx
  00130	5f		 pop	 edi
  00131	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1478 : 			}
; 1479 : 		return (*this);

  00134	8b c6		 mov	 eax, esi
  00136	5e		 pop	 esi

; 1480 : 		}

  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c2 10 00	 ret	 16			; 00000010H

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

$LN234@replace:
  0013d	8b c6		 mov	 eax, esi
  0013f	5b		 pop	 ebx
  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1480 : 		}

  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c2 10 00	 ret	 16			; 00000010H

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

$LN251@replace:
  0014b	89 75 0c	 mov	 DWORD PTR tv888[ebp], esi
$LN252@replace:
  0014e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00151	72 07		 jb	 SHORT $LN265@replace
  00153	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00155	89 4d fc	 mov	 DWORD PTR tv887[ebp], ecx
  00158	eb 03		 jmp	 SHORT $LN266@replace
$LN265@replace:
  0015a	89 75 fc	 mov	 DWORD PTR tv887[ebp], esi
$LN266@replace:
  0015d	8b 45 f8	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00160	85 c0		 test	 eax, eax
  00162	74 1e		 je	 SHORT $LN272@replace
  00164	50		 push	 eax
  00165	8b 45 0c	 mov	 eax, DWORD PTR tv888[ebp]
  00168	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  0016b	03 c3		 add	 eax, ebx
  0016d	50		 push	 eax
  0016e	8b 45 fc	 mov	 eax, DWORD PTR tv887[ebp]
  00171	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00174	03 c2		 add	 eax, edx
  00176	50		 push	 eax
  00177	e8 00 00 00 00	 call	 _memmove
  0017c	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  0017f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN272@replace:

; 1475 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1476 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

  00182	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00186	72 04		 jb	 SHORT $LN283@replace
  00188	8b 06		 mov	 eax, DWORD PTR [esi]
  0018a	eb 02		 jmp	 SHORT $LN284@replace
$LN283@replace:
  0018c	8b c6		 mov	 eax, esi
$LN284@replace:
  0018e	85 d2		 test	 edx, edx
  00190	74 10		 je	 SHORT $LN290@replace
  00192	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00195	52		 push	 edx
  00196	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00199	50		 push	 eax
  0019a	e8 00 00 00 00	 call	 _memcpy
  0019f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN290@replace:

; 1477 : 			_Eos(_Num);

  001a2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  001a6	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  001a9	72 11		 jb	 SHORT $LN301@replace
  001ab	8b 06		 mov	 eax, DWORD PTR [esi]
  001ad	5b		 pop	 ebx
  001ae	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1478 : 			}
; 1479 : 		return (*this);

  001b2	8b c6		 mov	 eax, esi
  001b4	5f		 pop	 edi
  001b5	5e		 pop	 esi

; 1480 : 		}

  001b6	8b e5		 mov	 esp, ebp
  001b8	5d		 pop	 ebp
  001b9	c2 10 00	 ret	 16			; 00000010H

; 1477 : 			_Eos(_Num);

$LN301@replace:
  001bc	8b c6		 mov	 eax, esi
  001be	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN306@replace:

; 1478 : 			}
; 1479 : 		return (*this);

  001c2	5b		 pop	 ebx
  001c3	5f		 pop	 edi
  001c4	8b c6		 mov	 eax, esi
  001c6	5e		 pop	 esi

; 1480 : 		}

  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	c2 10 00	 ret	 16			; 00000010H
$LN312@replace:

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);

  001cd	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  001d2	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN316@replace:
$LN314@replace:

; 1462 : 			_Xlen();	// result too long

  001d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  001dc	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN317@replace:
$LN315@replace:

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

  001e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  001e6	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN318@replace:
$LN309@replace:
  001eb	cc		 int	 3
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z
_TEXT	SEGMENT
tv1828 = -8						; size = 4
tv1825 = -8						; size = 4
__Max_effective_size$1$ = -8				; size = 4
__Nm$1$ = -4						; size = 4
tv1824 = 8						; size = 4
tv1821 = 8						; size = 4
tv1817 = 8						; size = 4
tv1813 = 8						; size = 4
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
tv1809 = 16						; size = 4
tv1807 = 16						; size = 4
tv1805 = 16						; size = 4
__Right$ = 16						; size = 4
tv1819 = 20						; size = 4
__Roff$ = 20						; size = 4
tv1798 = 24						; size = 4
__Newsize$1$ = 24					; size = 4
__Count$ = 24						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1389 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 1390 : 		_Check_offset(_Off);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00011	3b c3		 cmp	 eax, ebx
  00013	0f 82 95 03 00
	00		 jb	 $LN600@replace

; 1391 : 		_Right._Check_offset(_Roff);

  00019	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001c	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
  0001f	3b 7d 14	 cmp	 edi, DWORD PTR __Roff$[ebp]
  00022	0f 82 90 03 00
	00		 jb	 $LN602@replace

; 1392 : 		_N0 = _Clamp_suffix_size(_Off, _N0);

  00028	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0002b	2b c3		 sub	 eax, ebx
  0002d	3b d0		 cmp	 edx, eax
  0002f	89 45 fc	 mov	 DWORD PTR __Nm$1$[ebp], eax
  00032	0f 47 d0	 cmova	 edx, eax

; 1393 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00035	2b 7d 14	 sub	 edi, DWORD PTR __Roff$[ebp]

; 1394 : 		if (npos - _Count <= this->_Mysize() - _N0)

  00038	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0003b	89 7d f8	 mov	 DWORD PTR __Max_effective_size$1$[ebp], edi
  0003e	8b 7d 18	 mov	 edi, DWORD PTR __Count$[ebp]
  00041	3b 7d f8	 cmp	 edi, DWORD PTR __Max_effective_size$1$[ebp]
  00044	89 55 0c	 mov	 DWORD PTR __N0$[ebp], edx
  00047	0f 47 7d f8	 cmova	 edi, DWORD PTR __Max_effective_size$1$[ebp]
  0004b	2b c2		 sub	 eax, edx
  0004d	89 45 18	 mov	 DWORD PTR tv1798[ebp], eax
  00050	8b c7		 mov	 eax, edi
  00052	f7 d0		 not	 eax
  00054	3b 45 18	 cmp	 eax, DWORD PTR tv1798[ebp]
  00057	0f 86 65 03 00
	00		 jbe	 $LN603@replace

; 1396 : 
; 1397 : 		const size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1398 : 		const size_type _Newsize = this->_Mysize() + _Count - _N0;

  0005d	8b 5d 18	 mov	 ebx, DWORD PTR tv1798[ebp]
  00060	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00063	03 df		 add	 ebx, edi
  00065	2b c2		 sub	 eax, edx
  00067	89 5d 18	 mov	 DWORD PTR __Newsize$1$[ebp], ebx

; 1399 : 		if (this->_Mysize() < _Newsize)

  0006a	39 5e 10	 cmp	 DWORD PTR [esi+16], ebx
  0006d	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  00070	89 45 fc	 mov	 DWORD PTR __Nm$1$[ebp], eax
  00073	73 53		 jae	 SHORT $LN194@replace

; 1400 : 			_Grow(_Newsize);

  00075	83 7d 18 fe	 cmp	 DWORD PTR __Newsize$1$[ebp], -2 ; fffffffeH
  00079	0f 87 4d 03 00
	00		 ja	 $LN604@replace
  0007f	8b 5d 18	 mov	 ebx, DWORD PTR __Newsize$1$[ebp]
  00082	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00085	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  00088	73 18		 jae	 SHORT $LN112@replace
  0008a	ff 76 10	 push	 DWORD PTR [esi+16]
  0008d	8b ce		 mov	 ecx, esi
  0008f	ff 75 18	 push	 DWORD PTR __Newsize$1$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00097	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0009a	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  000a0	eb 26		 jmp	 SHORT $LN194@replace
$LN112@replace:
  000a2	83 7d 18 00	 cmp	 DWORD PTR __Newsize$1$[ebp], 0
  000a6	75 20		 jne	 SHORT $LN194@replace
  000a8	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000af	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b3	72 07		 jb	 SHORT $LN189@replace
  000b5	8b 1e		 mov	 ebx, DWORD PTR [esi]
  000b7	89 5d f8	 mov	 DWORD PTR tv1828[ebp], ebx
  000ba	eb 03		 jmp	 SHORT $LN190@replace
$LN189@replace:
  000bc	89 75 f8	 mov	 DWORD PTR tv1828[ebp], esi
$LN190@replace:
  000bf	8b 5d f8	 mov	 ebx, DWORD PTR tv1828[ebp]
  000c2	c6 03 00	 mov	 BYTE PTR [ebx], 0
  000c5	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
$LN194@replace:

; 1401 : 
; 1402 : 		if (_Count == _N0)

  000c8	3b fa		 cmp	 edi, edx
  000ca	75 2b		 jne	 SHORT $LN4@replace

; 1403 : 			{	// only one movement required, so _Traits::move handles any overlap
; 1404 : 			_Traits::move(this->_Myptr() + _Off,

  000cc	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  000d0	72 02		 jb	 SHORT $LN206@replace
  000d2	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN206@replace:
  000d4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000d8	72 04		 jb	 SHORT $LN220@replace
  000da	8b 16		 mov	 edx, DWORD PTR [esi]
  000dc	eb 02		 jmp	 SHORT $LN221@replace
$LN220@replace:
  000de	8b d6		 mov	 edx, esi
$LN221@replace:
  000e0	85 ff		 test	 edi, edi
  000e2	0f 84 9a 02 00
	00		 je	 $LN579@replace
  000e8	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  000eb	03 c1		 add	 eax, ecx
  000ed	57		 push	 edi
  000ee	50		 push	 eax
  000ef	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  000f2	e9 82 02 00 00	 jmp	 $LN598@replace
$LN4@replace:

; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (this != &_Right)

  000f7	3b f1		 cmp	 esi, ecx
  000f9	74 77		 je	 SHORT $LN6@replace

; 1408 : 			{	// no overlap, just move down and copy in new stuff
; 1409 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  000fb	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000ff	72 0a		 jb	 SHORT $LN238@replace
  00101	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00103	89 5d f8	 mov	 DWORD PTR tv1825[ebp], ebx
  00106	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  00109	eb 03		 jmp	 SHORT $LN239@replace
$LN238@replace:
  0010b	89 75 f8	 mov	 DWORD PTR tv1825[ebp], esi
$LN239@replace:
  0010e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00112	72 0a		 jb	 SHORT $LN252@replace
  00114	8b 16		 mov	 edx, DWORD PTR [esi]
  00116	89 55 08	 mov	 DWORD PTR tv1824[ebp], edx
  00119	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0011c	eb 03		 jmp	 SHORT $LN253@replace
$LN252@replace:
  0011e	89 75 08	 mov	 DWORD PTR tv1824[ebp], esi
$LN253@replace:
  00121	85 c0		 test	 eax, eax
  00123	74 1c		 je	 SHORT $LN259@replace
  00125	50		 push	 eax
  00126	8b 45 f8	 mov	 eax, DWORD PTR tv1825[ebp]
  00129	03 c3		 add	 eax, ebx
  0012b	03 c2		 add	 eax, edx
  0012d	50		 push	 eax
  0012e	8b 45 08	 mov	 eax, DWORD PTR tv1824[ebp]
  00131	03 c3		 add	 eax, ebx
  00133	03 c7		 add	 eax, edi
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 _memmove
  0013b	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0013e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN259@replace:

; 1410 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1411 : 			_Traits::copy(this->_Myptr() + _Off,

  00141	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00145	72 02		 jb	 SHORT $LN270@replace
  00147	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN270@replace:
  00149	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0014d	72 04		 jb	 SHORT $LN284@replace
  0014f	8b 16		 mov	 edx, DWORD PTR [esi]
  00151	eb 02		 jmp	 SHORT $LN285@replace
$LN284@replace:
  00153	8b d6		 mov	 edx, esi
$LN285@replace:
  00155	85 ff		 test	 edi, edi
  00157	0f 84 25 02 00
	00		 je	 $LN579@replace
  0015d	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  00160	03 c1		 add	 eax, ecx
  00162	57		 push	 edi
  00163	50		 push	 eax
  00164	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 _memcpy
  0016d	e9 0d 02 00 00	 jmp	 $LN599@replace
$LN6@replace:

; 1412 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1413 : 			}
; 1414 : 		else if (_Count < _N0)

  00172	3b fa		 cmp	 edi, edx
  00174	73 73		 jae	 SHORT $LN8@replace

; 1415 : 			{	// hole doesn't get larger, just copy in substring
; 1416 : 			_Traits::move(this->_Myptr() + _Off,

  00176	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00179	83 f8 10	 cmp	 eax, 16			; 00000010H
  0017c	72 07		 jb	 SHORT $LN302@replace
  0017e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00180	89 4d 08	 mov	 DWORD PTR tv1821[ebp], ecx
  00183	eb 03		 jmp	 SHORT $LN303@replace
$LN302@replace:
  00185	89 75 08	 mov	 DWORD PTR tv1821[ebp], esi
$LN303@replace:
  00188	83 f8 10	 cmp	 eax, 16			; 00000010H
  0018b	72 04		 jb	 SHORT $LN316@replace
  0018d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0018f	eb 02		 jmp	 SHORT $LN317@replace
$LN316@replace:
  00191	8b ce		 mov	 ecx, esi
$LN317@replace:
  00193	85 ff		 test	 edi, edi
  00195	74 17		 je	 SHORT $LN323@replace
  00197	8b 45 08	 mov	 eax, DWORD PTR tv1821[ebp]
  0019a	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  0019d	57		 push	 edi
  0019e	50		 push	 eax
  0019f	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  001a2	50		 push	 eax
  001a3	e8 00 00 00 00	 call	 _memmove
  001a8	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  001ab	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN323@replace:

; 1417 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1418 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  001ae	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001b1	83 f8 10	 cmp	 eax, 16			; 00000010H
  001b4	72 07		 jb	 SHORT $LN334@replace
  001b6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001b8	89 4d 14	 mov	 DWORD PTR tv1819[ebp], ecx
  001bb	eb 03		 jmp	 SHORT $LN335@replace
$LN334@replace:
  001bd	89 75 14	 mov	 DWORD PTR tv1819[ebp], esi
$LN335@replace:
  001c0	83 f8 10	 cmp	 eax, 16			; 00000010H
  001c3	72 04		 jb	 SHORT $LN348@replace
  001c5	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001c7	eb 02		 jmp	 SHORT $LN349@replace
$LN348@replace:
  001c9	8b ce		 mov	 ecx, esi
$LN349@replace:
  001cb	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  001ce	85 c0		 test	 eax, eax
  001d0	0f 84 ac 01 00
	00		 je	 $LN579@replace
  001d6	50		 push	 eax
  001d7	8b 45 14	 mov	 eax, DWORD PTR tv1819[ebp]
  001da	03 c3		 add	 eax, ebx
  001dc	03 c2		 add	 eax, edx
  001de	50		 push	 eax
  001df	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  001e2	03 c7		 add	 eax, edi
  001e4	e9 90 01 00 00	 jmp	 $LN598@replace
$LN8@replace:

; 1419 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1420 : 			}
; 1421 : 		else if (_Roff <= _Off)

  001e9	8b 4d 14	 mov	 ecx, DWORD PTR __Roff$[ebp]
  001ec	3b cb		 cmp	 ecx, ebx
  001ee	77 6b		 ja	 SHORT $LN10@replace

; 1422 : 			{	// hole gets larger, substring begins before hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  001f0	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  001f3	83 f9 10	 cmp	 ecx, 16			; 00000010H
  001f6	72 0a		 jb	 SHORT $LN366@replace
  001f8	8b 16		 mov	 edx, DWORD PTR [esi]
  001fa	89 55 08	 mov	 DWORD PTR tv1817[ebp], edx
  001fd	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  00200	eb 03		 jmp	 SHORT $LN367@replace
$LN366@replace:
  00202	89 75 08	 mov	 DWORD PTR tv1817[ebp], esi
$LN367@replace:
  00205	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00208	72 04		 jb	 SHORT $LN380@replace
  0020a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0020c	eb 02		 jmp	 SHORT $LN381@replace
$LN380@replace:
  0020e	8b ce		 mov	 ecx, esi
$LN381@replace:
  00210	85 c0		 test	 eax, eax
  00212	74 17		 je	 SHORT $LN387@replace
  00214	50		 push	 eax
  00215	8b 45 08	 mov	 eax, DWORD PTR tv1817[ebp]
  00218	03 c3		 add	 eax, ebx
  0021a	03 c2		 add	 eax, edx
  0021c	50		 push	 eax
  0021d	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00220	03 c7		 add	 eax, edi
  00222	50		 push	 eax
  00223	e8 00 00 00 00	 call	 _memmove
  00228	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN387@replace:

; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,

  0022b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0022e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00231	72 04		 jb	 SHORT $LN398@replace
  00233	8b 16		 mov	 edx, DWORD PTR [esi]
  00235	eb 02		 jmp	 SHORT $LN399@replace
$LN398@replace:
  00237	8b d6		 mov	 edx, esi
$LN399@replace:
  00239	83 f8 10	 cmp	 eax, 16			; 00000010H
  0023c	72 04		 jb	 SHORT $LN412@replace
  0023e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00240	eb 02		 jmp	 SHORT $LN413@replace
$LN412@replace:
  00242	8b ce		 mov	 ecx, esi
$LN413@replace:
  00244	85 ff		 test	 edi, edi
  00246	0f 84 36 01 00
	00		 je	 $LN579@replace
  0024c	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  0024f	03 c2		 add	 eax, edx
  00251	57		 push	 edi
  00252	50		 push	 eax
  00253	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00256	e9 1e 01 00 00	 jmp	 $LN598@replace
$LN10@replace:

; 1426 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1427 : 			}
; 1428 : 		else if (_Off + _N0 <= _Roff)

  0025b	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  0025e	3b c1		 cmp	 eax, ecx

; 1429 : 			{	// hole gets larger, substring begins after hole
; 1430 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00260	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00263	77 6d		 ja	 SHORT $LN12@replace
  00265	83 f8 10	 cmp	 eax, 16			; 00000010H
  00268	72 07		 jb	 SHORT $LN430@replace
  0026a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0026c	89 4d 08	 mov	 DWORD PTR tv1813[ebp], ecx
  0026f	eb 03		 jmp	 SHORT $LN431@replace
$LN430@replace:
  00271	89 75 08	 mov	 DWORD PTR tv1813[ebp], esi
$LN431@replace:
  00274	83 f8 10	 cmp	 eax, 16			; 00000010H
  00277	72 04		 jb	 SHORT $LN444@replace
  00279	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0027b	eb 02		 jmp	 SHORT $LN445@replace
$LN444@replace:
  0027d	8b ce		 mov	 ecx, esi
$LN445@replace:
  0027f	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00282	85 c0		 test	 eax, eax
  00284	74 1a		 je	 SHORT $LN451@replace
  00286	50		 push	 eax
  00287	8b 45 08	 mov	 eax, DWORD PTR tv1813[ebp]
  0028a	03 c3		 add	 eax, ebx
  0028c	03 c2		 add	 eax, edx
  0028e	50		 push	 eax
  0028f	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00292	03 c7		 add	 eax, edi
  00294	50		 push	 eax
  00295	e8 00 00 00 00	 call	 _memmove
  0029a	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0029d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN451@replace:

; 1431 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1432 : 			_Traits::move(this->_Myptr() + _Off,

  002a0	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  002a3	83 f9 10	 cmp	 ecx, 16			; 00000010H
  002a6	72 04		 jb	 SHORT $LN462@replace
  002a8	8b 06		 mov	 eax, DWORD PTR [esi]
  002aa	eb 02		 jmp	 SHORT $LN463@replace
$LN462@replace:
  002ac	8b c6		 mov	 eax, esi
$LN463@replace:
  002ae	83 f9 10	 cmp	 ecx, 16			; 00000010H
  002b1	72 04		 jb	 SHORT $LN476@replace
  002b3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002b5	eb 02		 jmp	 SHORT $LN477@replace
$LN476@replace:
  002b7	8b ce		 mov	 ecx, esi
$LN477@replace:
  002b9	85 ff		 test	 edi, edi
  002bb	0f 84 c1 00 00
	00		 je	 $LN579@replace
  002c1	2b c2		 sub	 eax, edx
  002c3	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  002c6	03 c7		 add	 eax, edi
  002c8	57		 push	 edi
  002c9	50		 push	 eax
  002ca	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]

; 1433 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1434 : 				_Count);	// fill hole
; 1435 : 			}
; 1436 : 		else

  002cd	e9 a7 00 00 00	 jmp	 $LN598@replace
$LN12@replace:

; 1437 : 			{	// hole gets larger, substring begins in hole
; 1438 : 			_Traits::move(this->_Myptr() + _Off,

  002d2	83 f8 10	 cmp	 eax, 16			; 00000010H
  002d5	72 07		 jb	 SHORT $LN494@replace
  002d7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002d9	89 4d 10	 mov	 DWORD PTR tv1809[ebp], ecx
  002dc	eb 03		 jmp	 SHORT $LN495@replace
$LN494@replace:
  002de	89 75 10	 mov	 DWORD PTR tv1809[ebp], esi
$LN495@replace:
  002e1	83 f8 10	 cmp	 eax, 16			; 00000010H
  002e4	72 04		 jb	 SHORT $LN508@replace
  002e6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002e8	eb 02		 jmp	 SHORT $LN509@replace
$LN508@replace:
  002ea	8b ce		 mov	 ecx, esi
$LN509@replace:
  002ec	85 d2		 test	 edx, edx
  002ee	74 17		 je	 SHORT $LN515@replace
  002f0	8b 45 10	 mov	 eax, DWORD PTR tv1809[ebp]
  002f3	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  002f6	52		 push	 edx
  002f7	50		 push	 eax
  002f8	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  002fb	50		 push	 eax
  002fc	e8 00 00 00 00	 call	 _memmove
  00301	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  00304	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN515@replace:

; 1439 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00307	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0030a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0030d	72 07		 jb	 SHORT $LN526@replace
  0030f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00311	89 4d 10	 mov	 DWORD PTR tv1807[ebp], ecx
  00314	eb 03		 jmp	 SHORT $LN527@replace
$LN526@replace:
  00316	89 75 10	 mov	 DWORD PTR tv1807[ebp], esi
$LN527@replace:
  00319	83 f8 10	 cmp	 eax, 16			; 00000010H
  0031c	72 04		 jb	 SHORT $LN540@replace
  0031e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00320	eb 02		 jmp	 SHORT $LN541@replace
$LN540@replace:
  00322	8b ce		 mov	 ecx, esi
$LN541@replace:
  00324	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00327	85 c0		 test	 eax, eax
  00329	74 17		 je	 SHORT $LN547@replace
  0032b	50		 push	 eax
  0032c	8b 45 10	 mov	 eax, DWORD PTR tv1807[ebp]
  0032f	03 c3		 add	 eax, ebx
  00331	03 c2		 add	 eax, edx
  00333	50		 push	 eax
  00334	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00337	03 c7		 add	 eax, edi
  00339	50		 push	 eax
  0033a	e8 00 00 00 00	 call	 _memmove
  0033f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN547@replace:

; 1441 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1442 : 			_Traits::move(this->_Myptr() + _Off + _N0,

  00342	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00345	83 f8 10	 cmp	 eax, 16			; 00000010H
  00348	72 07		 jb	 SHORT $LN558@replace
  0034a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0034c	89 4d 10	 mov	 DWORD PTR tv1805[ebp], ecx
  0034f	eb 03		 jmp	 SHORT $LN559@replace
$LN558@replace:
  00351	89 75 10	 mov	 DWORD PTR tv1805[ebp], esi
$LN559@replace:
  00354	83 f8 10	 cmp	 eax, 16			; 00000010H
  00357	72 04		 jb	 SHORT $LN572@replace
  00359	8b 16		 mov	 edx, DWORD PTR [esi]
  0035b	eb 02		 jmp	 SHORT $LN573@replace
$LN572@replace:
  0035d	8b d6		 mov	 edx, esi
$LN573@replace:
  0035f	8b 4d 0c	 mov	 ecx, DWORD PTR __N0$[ebp]
  00362	8b c7		 mov	 eax, edi
  00364	2b c1		 sub	 eax, ecx
  00366	74 1a		 je	 SHORT $LN579@replace
  00368	50		 push	 eax
  00369	8b 45 10	 mov	 eax, DWORD PTR tv1805[ebp]
  0036c	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  0036f	03 c7		 add	 eax, edi
  00371	50		 push	 eax
  00372	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00375	03 c2		 add	 eax, edx
  00377	03 c1		 add	 eax, ecx
$LN598@replace:
  00379	50		 push	 eax
  0037a	e8 00 00 00 00	 call	 _memmove
$LN599@replace:
  0037f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN579@replace:

; 1443 : 				this->_Myptr() + _Roff + _Count,
; 1444 : 				_Count - _N0);	// fill rest of new hole
; 1445 : 			}
; 1446 : 
; 1447 : 		_Eos(_Newsize);

  00382	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00386	8b 4d 18	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]
  00389	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0038c	72 11		 jb	 SHORT $LN590@replace
  0038e	8b 06		 mov	 eax, DWORD PTR [esi]
  00390	5f		 pop	 edi
  00391	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1448 : 		return (*this);

  00395	8b c6		 mov	 eax, esi
  00397	5e		 pop	 esi
  00398	5b		 pop	 ebx

; 1449 : 		}

  00399	8b e5		 mov	 esp, ebp
  0039b	5d		 pop	 ebp
  0039c	c2 14 00	 ret	 20			; 00000014H

; 1443 : 				this->_Myptr() + _Roff + _Count,
; 1444 : 				_Count - _N0);	// fill rest of new hole
; 1445 : 			}
; 1446 : 
; 1447 : 		_Eos(_Newsize);

$LN590@replace:
  0039f	8b c6		 mov	 eax, esi
  003a1	5f		 pop	 edi
  003a2	5e		 pop	 esi
  003a3	5b		 pop	 ebx
  003a4	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1449 : 		}

  003a8	8b e5		 mov	 esp, ebp
  003aa	5d		 pop	 ebp
  003ab	c2 14 00	 ret	 20			; 00000014H
$LN600@replace:

; 1390 : 		_Check_offset(_Off);

  003ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  003b3	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN605@replace:
$LN602@replace:

; 1391 : 		_Right._Check_offset(_Roff);

  003b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  003bd	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN606@replace:
$LN603@replace:

; 1395 : 			_Xlen();	// result too long

  003c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  003c7	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN607@replace:
$LN604@replace:

; 1400 : 			_Grow(_Newsize);

  003cc	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  003d1	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN608@replace:
$LN597@replace:
  003d6	cc		 int	 3
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1348 : 		_Check_offset(_Off);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	72 7e		 jb	 SHORT $LN93@erase

; 1349 : 		if (this->_Mysize() - _Off <= _Count)

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00014	8b c7		 mov	 eax, edi
  00016	2b c1		 sub	 eax, ecx
  00018	3b c2		 cmp	 eax, edx
  0001a	77 23		 ja	 SHORT $LN2@erase

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

  0001c	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0001f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00023	72 0e		 jb	 SHORT $LN41@erase
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	5f		 pop	 edi
  00028	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1357 : 			}
; 1358 : 		return (*this);

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi

; 1359 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

$LN41@erase:
  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1359 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN2@erase:

; 1351 : 		else if (0 < _Count)

  0003f	85 d2		 test	 edx, edx
  00041	74 44		 je	 SHORT $LN90@erase

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;

  00043	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00047	72 04		 jb	 SHORT $LN58@erase
  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	eb 02		 jmp	 SHORT $LN59@erase
$LN58@erase:
  0004d	8b c6		 mov	 eax, esi
$LN59@erase:

; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

  0004f	2b fa		 sub	 edi, edx
  00051	53		 push	 ebx
  00052	8d 1c 08	 lea	 ebx, DWORD PTR [eax+ecx]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00055	8b c7		 mov	 eax, edi
  00057	2b c1		 sub	 eax, ecx
  00059	74 0e		 je	 SHORT $LN74@erase
  0005b	50		 push	 eax
  0005c	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  0005f	50		 push	 eax
  00060	53		 push	 ebx
  00061	e8 00 00 00 00	 call	 _memmove
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@erase:

; 1356 : 			_Eos(_Newsize);

  00069	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0006d	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00070	5b		 pop	 ebx
  00071	72 0e		 jb	 SHORT $LN85@erase
  00073	8b 06		 mov	 eax, DWORD PTR [esi]
  00075	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1357 : 			}
; 1358 : 		return (*this);

  00079	8b c6		 mov	 eax, esi
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 1359 : 		}

  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8

; 1356 : 			_Eos(_Newsize);

$LN85@erase:
  00081	8b c6		 mov	 eax, esi
  00083	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN90@erase:

; 1357 : 			}
; 1358 : 		return (*this);

  00087	5f		 pop	 edi
  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi

; 1359 : 		}

  0008b	5d		 pop	 ebp
  0008c	c2 08 00	 ret	 8
$LN93@erase:

; 1348 : 		_Check_offset(_Off);

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00094	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN95@erase:
$LN92@erase:
  00099	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1341 : 		_Check_offset(_Off);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	72 21		 jb	 SHORT $LN37@erase

; 1342 : 		_Eos(_Off);

  0000b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000e	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00012	72 0c		 jb	 SHORT $LN29@erase
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 1343 : 		return (*this);

  0001a	8b c1		 mov	 eax, ecx

; 1344 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4

; 1342 : 		_Eos(_Off);

$LN29@erase:
  00020	8b d1		 mov	 edx, ecx
  00022	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 1343 : 		return (*this);

  00026	8b c1		 mov	 eax, ecx

; 1344 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN37@erase:

; 1341 : 		_Check_offset(_Off);

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00031	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN39@erase:
$LN36@erase:
  00036	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN5@assign
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00015	5e		 pop	 esi

; 1183 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

$LN5@assign:
  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@assign:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL7@assign
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00031	5e		 pop	 esi

; 1183 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1166 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1167 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 57		 je	 SHORT $LN2@assign
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN20@assign
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN21@assign
$LN20@assign:
  0001a	8b c6		 mov	 eax, esi
$LN21@assign:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 45		 jb	 SHORT $LN2@assign
  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN34@assign
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN35@assign
$LN34@assign:
  00029	8b d6		 mov	 edx, esi
$LN35@assign:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	03 c2		 add	 eax, edx
  00030	3b c3		 cmp	 eax, ebx
  00032	76 31		 jbe	 SHORT $LN2@assign

; 1168 : 			return (assign(*this,

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 16		 jb	 SHORT $LN57@assign
  00039	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	8b ce		 mov	 ecx, esi
  00040	2b d8		 sub	 ebx, eax
  00042	53		 push	 ebx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 1177 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8

; 1168 : 			return (assign(*this,

$LN57@assign:
  0004f	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00052	8b c6		 mov	 eax, esi
  00054	8b ce		 mov	 ecx, esi
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 1177 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN2@assign:
  00065	57		 push	 edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  00066	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00069	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0006c	77 7d		 ja	 SHORT $LN187@assign
  0006e	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00071	73 19		 jae	 SHORT $LN63@assign
  00073	ff 76 10	 push	 DWORD PTR [esi+16]
  00076	8b ce		 mov	 ecx, esi
  00078	57		 push	 edi
  00079	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0007e	85 ff		 test	 edi, edi
  00080	74 60		 je	 SHORT $LN181@assign
$LN186@assign:

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  00082	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00086	72 2b		 jb	 SHORT $LN158@assign
  00088	8b 06		 mov	 eax, DWORD PTR [esi]
  0008a	eb 29		 jmp	 SHORT $LN159@assign

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN63@assign:
  0008c	85 ff		 test	 edi, edi
  0008e	75 f2		 jne	 SHORT $LN186@assign
  00090	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00094	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00097	72 0e		 jb	 SHORT $LN140@assign
  00099	8b 06		 mov	 eax, DWORD PTR [esi]
  0009b	5f		 pop	 edi
  0009c	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1175 : 			}
; 1176 : 		return (*this);

  0009f	8b c6		 mov	 eax, esi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx

; 1177 : 		}

  000a3	5d		 pop	 ebp
  000a4	c2 08 00	 ret	 8

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN140@assign:
  000a7	8b c6		 mov	 eax, esi
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1177 : 		}

  000af	5d		 pop	 ebp
  000b0	c2 08 00	 ret	 8

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

$LN158@assign:
  000b3	8b c6		 mov	 eax, esi
$LN159@assign:
  000b5	85 ff		 test	 edi, edi
  000b7	74 0b		 je	 SHORT $LN165@assign
  000b9	57		 push	 edi
  000ba	53		 push	 ebx
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN165@assign:

; 1174 : 			_Eos(_Count);

  000c4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000c8	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000cb	72 0f		 jb	 SHORT $LN176@assign
  000cd	8b 06		 mov	 eax, DWORD PTR [esi]
  000cf	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1175 : 			}
; 1176 : 		return (*this);

  000d3	8b c6		 mov	 eax, esi
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx

; 1177 : 		}

  000d8	5d		 pop	 ebp
  000d9	c2 08 00	 ret	 8

; 1174 : 			_Eos(_Count);

$LN176@assign:
  000dc	8b c6		 mov	 eax, esi
  000de	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN181@assign:

; 1175 : 			}
; 1176 : 		return (*this);

  000e2	5f		 pop	 edi
  000e3	8b c6		 mov	 eax, esi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 1177 : 		}

  000e7	5d		 pop	 ebp
  000e8	c2 08 00	 ret	 8
$LN187@assign:

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f0	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN189@assign:
$LN184@assign:
  000f5	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1150 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 e9 00 00
	00		 jb	 $LN208@assign

; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00019	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
  0001c	2b c1		 sub	 eax, ecx
  0001e	3b f8		 cmp	 edi, eax
  00020	0f 47 f8	 cmova	 edi, eax

; 1152 : 
; 1153 : 		if (this == &_Right)

  00023	3b f3		 cmp	 esi, ebx
  00025	75 47		 jne	 SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  0002d	0f 82 d9 00 00
	00		 jb	 $LN210@assign
  00033	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00036	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0003a	72 19		 jb	 SHORT $LN63@assign
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	51		 push	 ecx
  0003f	6a 00		 push	 0
  00041	8b ce		 mov	 ecx, esi
  00043	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
  00047	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0004c	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  0004d	8b c6		 mov	 eax, esi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx

; 1162 : 		}

  00051	5d		 pop	 ebp
  00052	c2 0c 00	 ret	 12			; 0000000cH

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

$LN63@assign:
  00055	8b d6		 mov	 edx, esi
  00057	51		 push	 ecx
  00058	6a 00		 push	 0
  0005a	8b ce		 mov	 ecx, esi
  0005c	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
  00060	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00065	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  00066	8b c6		 mov	 eax, esi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 1162 : 		}

  0006a	5d		 pop	 ebp
  0006b	c2 0c 00	 ret	 12			; 0000000cH
$LN2@assign:

; 1155 : 		else if (_Grow(_Count))

  0006e	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00071	0f 87 9f 00 00
	00		 ja	 $LN211@assign
  00077	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0007a	73 24		 jae	 SHORT $LN72@assign
  0007c	ff 76 10	 push	 DWORD PTR [esi+16]
  0007f	8b ce		 mov	 ecx, esi
  00081	57		 push	 edi
  00082	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00087	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0008a	85 ff		 test	 edi, edi
  0008c	74 6b		 je	 SHORT $LN203@assign
$LN207@assign:

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

  0008e	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00092	72 02		 jb	 SHORT $LN166@assign
  00094	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN166@assign:
  00096	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0009a	72 2b		 jb	 SHORT $LN180@assign
  0009c	8b 16		 mov	 edx, DWORD PTR [esi]
  0009e	eb 29		 jmp	 SHORT $LN181@assign

; 1155 : 		else if (_Grow(_Count))

$LN72@assign:
  000a0	85 ff		 test	 edi, edi
  000a2	75 ea		 jne	 SHORT $LN207@assign
  000a4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000a8	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ab	72 0e		 jb	 SHORT $LN149@assign
  000ad	8b 06		 mov	 eax, DWORD PTR [esi]
  000af	5f		 pop	 edi
  000b0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1160 : 			}
; 1161 : 		return (*this);

  000b3	8b c6		 mov	 eax, esi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx

; 1162 : 		}

  000b7	5d		 pop	 ebp
  000b8	c2 0c 00	 ret	 12			; 0000000cH

; 1155 : 		else if (_Grow(_Count))

$LN149@assign:
  000bb	8b c6		 mov	 eax, esi
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1162 : 		}

  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

$LN180@assign:
  000c7	8b d6		 mov	 edx, esi
$LN181@assign:
  000c9	85 ff		 test	 edi, edi
  000cb	74 0e		 je	 SHORT $LN187@assign
  000cd	57		 push	 edi
  000ce	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  000d1	50		 push	 eax
  000d2	52		 push	 edx
  000d3	e8 00 00 00 00	 call	 _memcpy
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN187@assign:

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

  000db	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000df	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000e2	72 0f		 jb	 SHORT $LN198@assign
  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1160 : 			}
; 1161 : 		return (*this);

  000ea	8b c6		 mov	 eax, esi
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx

; 1162 : 		}

  000ef	5d		 pop	 ebp
  000f0	c2 0c 00	 ret	 12			; 0000000cH

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

$LN198@assign:
  000f3	8b c6		 mov	 eax, esi
  000f5	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN203@assign:

; 1160 : 			}
; 1161 : 		return (*this);

  000f9	5f		 pop	 edi
  000fa	8b c6		 mov	 eax, esi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx

; 1162 : 		}

  000fe	5d		 pop	 ebp
  000ff	c2 0c 00	 ret	 12			; 0000000cH
$LN208@assign:

; 1150 : 		_Right._Check_offset(_Roff);

  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00107	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN212@assign:
$LN210@assign:

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  0010c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00111	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN213@assign:
$LN211@assign:

; 1155 : 		else if (_Grow(_Count))

  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN214@assign:
$LN205@assign:
  00120	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1143 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1144 : 		return (assign(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1039 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1040 : 		return (assign(_Ptr));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN7@operator
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00015	5e		 pop	 esi

; 1041 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1040 : 		return (assign(_Ptr));

$LN7@operator:
  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL9@operator:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL9@operator
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00031	5e		 pop	 esi

; 1041 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1023 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1024 : 		if (this != &_Right)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b f0		 cmp	 esi, eax
  0000b	74 0a		 je	 SHORT $LN132@operator

; 1025 : 			{	// different, assign it
; 1026 : 			if (this->_Getal() != _Right._Getal()
; 1027 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1028 : 				{	// change allocator before copying
; 1029 : 				_Tidy(true);
; 1030 : 				this->_Copy_alloc(_Right._Getal());
; 1031 : 				}
; 1032 : 
; 1033 : 			assign(_Right);

  0000d	6a ff		 push	 -1
  0000f	6a 00		 push	 0
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN132@operator:

; 1034 : 			}
; 1035 : 		return (*this);

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi

; 1036 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1017 : 		_Tidy(true);

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 10	 cmp	 eax, 16			; 00000010H
  00009	72 09		 jb	 SHORT $LN6@basic_stri
  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN6@basic_stri:
  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	72 07		 jb	 SHORT $LN94@basic_stri
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	5e		 pop	 esi
  0002b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1018 : 		}

  0002e	c3		 ret	 0

; 1017 : 		_Tidy(true);

$LN94@basic_stri:
  0002f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00032	5e		 pop	 esi

; 1018 : 		}

  00033	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 961  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0000e	73 15		 jae	 SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	83 c0 01	 add	 eax, 1
  00016	74 1b		 je	 SHORT $LN3@Assign_rv
  00018	50		 push	 eax
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 964  : 				_Right._Mysize() + 1);
; 965  : 		else

  00023	eb 0e		 jmp	 SHORT $LN3@Assign_rv
$LN2@Assign_rv:

; 966  : 			{	// copy pointer
; 967  : 			this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Right._Bx()._Ptr);

  00025	85 ff		 test	 edi, edi
  00027	74 04		 je	 SHORT $LN84@Assign_rv
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	89 07		 mov	 DWORD PTR [edi], eax
$LN84@Assign_rv:

; 968  : 			_Right._Bx()._Ptr = pointer();

  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

  00039	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0003c	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 972  : 		_Right._Tidy();

  0003f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00046	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0004a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00051	72 0b		 jb	 SHORT $LN227@Assign_rv
  00053	8b 06		 mov	 eax, DWORD PTR [esi]
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	c6 00 00	 mov	 BYTE PTR [eax], 0

; 973  : 		}

  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4

; 972  : 		_Right._Tidy();

$LN227@Assign_rv:
  0005e	5f		 pop	 edi
  0005f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00062	5e		 pop	 esi

; 973  : 		}

  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 928  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 929  : 		if (this != &_Right)

  00025	3b 75 08	 cmp	 esi, DWORD PTR __Right$[ebp]
  00028	74 38		 je	 SHORT $LN294@operator

; 930  : 			{	// different, assign it
; 931  : 			_Tidy(true);

  0002a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00030	72 09		 jb	 SHORT $LN10@operator
  00032	40		 inc	 eax
  00033	50		 push	 eax
  00034	ff 36		 push	 DWORD PTR [esi]
  00036	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN10@operator:
  0003b	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00042	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00046	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004d	72 04		 jb	 SHORT $LN98@operator
  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	eb 02		 jmp	 SHORT $LN99@operator
$LN98@operator:
  00053	8b c6		 mov	 eax, esi
$LN99@operator:

; 932  : 
; 933  : 			if (_Alty::propagate_on_container_move_assignment::value
; 934  : 				&& this->_Getal() != _Right._Getal())
; 935  : 				this->_Move_alloc(_Right._Getal());
; 936  : 
; 937  : 			if (this->_Getal() != _Right._Getal())
; 938  : 				assign(_Right.begin(), _Right.end());
; 939  : 			else
; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

  00055	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00058	8b ce		 mov	 ecx, esi
  0005a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0005d	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN294@operator:

; 941  : 			}
; 942  : 		return (*this);

  00062	8b c6		 mov	 eax, esi

; 943  : 		}

  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5e		 pop	 esi
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 911  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 912  : 		_Tidy();
; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00004	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00017	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001a	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 914  : 		}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00017	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001a	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0001d	75 12		 jne	 SHORT $LN111@basic_stri
  0001f	33 d2		 xor	 edx, edx
  00021	52		 push	 edx
  00022	51		 push	 ecx
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 839  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

$LN111@basic_stri:
  00031	8b d1		 mov	 edx, ecx
  00033	57		 push	 edi
  00034	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL113@basic_stri:
  00037	8a 02		 mov	 al, BYTE PTR [edx]
  00039	42		 inc	 edx
  0003a	84 c0		 test	 al, al
  0003c	75 f9		 jne	 SHORT $LL113@basic_stri
  0003e	2b d7		 sub	 edx, edi
  00040	5f		 pop	 edi
  00041	52		 push	 edx
  00042	51		 push	 ecx
  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 839  : 		}

  0004a	8b c6		 mov	 eax, esi
  0004c	5e		 pop	 esi
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$ = 20						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 815  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 816  : 		_Tidy();
; 817  : 		assign(_Right, _Roff, _Count);

  00004	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 0c	 push	 DWORD PTR __Roff$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00016	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001d	c6 06 00	 mov	 BYTE PTR [esi], 0
  00020	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 818  : 		}

  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 10 00	 ret	 16			; 00000010H
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 795  : 		_Tidy();

  00000	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 796  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00013	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 781  : 		_Tidy();
; 782  : 		assign(_Right, 0, npos);

  00006	6a ff		 push	 -1
  00008	6a 00		 push	 0
  0000a	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00014	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 783  : 		}

  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 735  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 730  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 725  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

  00000	8b c1		 mov	 eax, ecx

; 715  : 		}

  00002	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 708  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 703  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 698  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 693  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc, COMDAT
; _this$ = ecx

; 607  : 		_Pocma(_Getal(), _Al);
; 608  : 		}

  00000	c2 04 00	 ret	 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 602  : 		_Pocca(_Getal(), _Al);
; 603  : 		}

  00000	c2 04 00	 ret	 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 588  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 590  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 583  : 		return (_Get_data()._Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 584  : 		}

  00008	c3		 ret	 0

; 583  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 584  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 578  : 		return (_Get_data()._Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 579  : 		}

  00008	c3		 ret	 0

; 578  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 579  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 534  : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 499  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	83 c8 ff	 or	 eax, -1

; 1009 : 		}

  00003	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000d	72 19		 jb	 SHORT $LN7@deallocate
  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $LN16@deallocate
  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00016	3b c8		 cmp	 ecx, eax
  00018	73 20		 jae	 SHORT $LN18@deallocate
  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 1e		 jb	 SHORT $LN19@deallocate
  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 1e		 ja	 SHORT $LN20@deallocate
  00026	8b c1		 mov	 eax, ecx
$LN7@deallocate:
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 988  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00035	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN18@deallocate:
  0003a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN19@deallocate:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN20@deallocate:
  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN15@deallocate:
  00049	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 976  : 		return (_Mybase::allocate(_Count));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN6@allocate
$LN15@allocate:

; 977  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 976  : 		return (_Mybase::allocate(_Count));

$LN6@allocate:
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 23		 jb	 SHORT $LN8@allocate
  00015	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00018	3b c8		 cmp	 ecx, eax
  0001a	76 2b		 jbe	 SHORT $LN17@allocate
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	8b c8		 mov	 ecx, eax
  00024	83 c4 04	 add	 esp, 4
  00027	85 c9		 test	 ecx, ecx
  00029	74 21		 je	 SHORT $LN19@allocate
  0002b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002e	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00031	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 977  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4

; 976  : 		return (_Mybase::allocate(_Count));

$LN8@allocate:
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 c5		 jne	 SHORT $LN15@allocate
  00045	eb 0a		 jmp	 SHORT $LN20@allocate
$LN17@allocate:
  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN21@allocate:
$LN19@allocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN20@allocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@allocate:
$LN16@allocate:
  00056	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 963  : 		_Mybase::operator=(_STD move(_Right));
; 964  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 965  : 		}

  00002	c2 04 00	 ret	 4
??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::address, COMDAT
; _this$ = ecx

; 925  : 		{	// return address of mutable _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 926  : 		return (pointer_traits<pointer>::pointer_to(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 927  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	83 c8 ff	 or	 eax, -1

; 870  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	83 c8 ff	 or	 eax, -1

; 750  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 23		 jb	 SHORT $LN6@allocate
  00015	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00018	3b c8		 cmp	 ecx, eax
  0001a	76 2b		 jbe	 SHORT $LN14@allocate
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	8b c8		 mov	 ecx, eax
  00024	83 c4 04	 add	 esp, 4
  00027	85 c9		 test	 ecx, ecx
  00029	74 21		 je	 SHORT $LN16@allocate
  0002b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002e	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00031	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 c5		 jne	 SHORT $LN12@allocate
  00045	eb 0a		 jmp	 SHORT $LN17@allocate
$LN14@allocate:
  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN18@allocate:
$LN16@allocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@allocate:
$LN17@allocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@allocate:
$LN13@allocate:
  00056	cc		 int	 3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000d	72 19		 jb	 SHORT $LN5@deallocate
  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $LN13@deallocate
  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00016	3b c8		 cmp	 ecx, eax
  00018	73 20		 jae	 SHORT $LN15@deallocate
  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 1e		 jb	 SHORT $LN16@deallocate
  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 1e		 ja	 SHORT $LN17@deallocate
  00026	8b c1		 mov	 eax, ecx
$LN5@deallocate:
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 721  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00035	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
$LN15@deallocate:
  0003a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN16@deallocate:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN17@deallocate:
  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN12@deallocate:
  00049	cc		 int	 3
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 95   : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 133  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	void *_Ptr = 0;
; 50   : 
; 51   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 56   : 		_Xbad_alloc();	// report no memory
; 57   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 66   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 67   : 			_Xbad_alloc();	// report no memory
; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else
; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ
_TEXT	SEGMENT
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ PROC ; std::_Iterator_base0::_Getcont, COMDAT
; _this$ = ecx

; 59   : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 60   : 		}

  00002	c3		 ret	 0
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ENDP ; std::_Iterator_base0::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq@?$char_traits@D@std@@SA_NABD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq@?$char_traits@D@std@@SA_NABD0@Z PROC		; std::char_traits<char>::eq, COMDAT

; 570  : 		{	// test for element equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000b	3a 08		 cmp	 cl, BYTE PTR [eax]
  0000d	0f 94 c0	 sete	 al

; 571  : 		return (_Left == _Right);
; 572  : 		}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?eq@?$char_traits@D@std@@SA_NABD0@Z ENDP		; std::char_traits<char>::eq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 564  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 565  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000b	88 08		 mov	 BYTE PTR [eax], cl

; 566  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 552  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 553  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@move
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@move:

; 553  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  00012	5d		 pop	 ebp

; 553  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?find@?$char_traits@D@std@@SAPBDPBDIABD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 4
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z PROC		; std::char_traits<char>::find, COMDAT

; 545  : 		{	// look for _Ch in [_First, _First + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 546  : 		return (_Count == 0 ? (const _Elem *)0

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN3@find

; 547  : 			: (const _Elem *)_CSTD memchr(_First, _Ch, _Count));
; 548  : 		}

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN3@find:

; 546  : 		return (_Count == 0 ? (const _Elem *)0

  0000c	50		 push	 eax
  0000d	8b 45 10	 mov	 eax, DWORD PTR __Ch$[ebp]
  00010	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00017	e8 00 00 00 00	 call	 _memchr
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 547  : 			: (const _Elem *)_CSTD memchr(_First, _Ch, _Count));
; 548  : 		}

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z ENDP		; std::char_traits<char>::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 530  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 530  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  00012	5d		 pop	 ebp

; 530  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 522  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 523  : 		return (*_First == 0 ? 0

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	80 38 00	 cmp	 BYTE PTR [eax], 0
  00009	75 04		 jne	 SHORT $LN3@length
  0000b	33 c0		 xor	 eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

  0000f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL5@length:
  00012	8a 08		 mov	 cl, BYTE PTR [eax]
  00014	40		 inc	 eax
  00015	84 c9		 test	 cl, cl
  00017	75 f9		 jne	 SHORT $LL5@length
  00019	2b c2		 sub	 eax, edx

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC		; std::char_traits<char>::compare, COMDAT

; 516  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 517  : 		return (_Count == 0 ? 0

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN3@compare
  0000a	33 c0		 xor	 eax, eax

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN3@compare:

; 517  : 		return (_Count == 0 ? 0

  0000e	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00011	56		 push	 esi
  00012	8b 75 0c	 mov	 esi, DWORD PTR __First2$[ebp]
  00015	83 e9 04	 sub	 ecx, 4
  00018	72 17		 jb	 SHORT $LN7@compare
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL8@compare:
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	3b 06		 cmp	 eax, DWORD PTR [esi]
  00024	75 10		 jne	 SHORT $LN6@compare
  00026	83 c2 04	 add	 edx, 4
  00029	83 c6 04	 add	 esi, 4
  0002c	83 e9 04	 sub	 ecx, 4
  0002f	73 ef		 jae	 SHORT $LL8@compare
$LN7@compare:
  00031	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00034	74 35		 je	 SHORT $LN5@compare
$LN6@compare:
  00036	8a 02		 mov	 al, BYTE PTR [edx]
  00038	3a 06		 cmp	 al, BYTE PTR [esi]
  0003a	75 27		 jne	 SHORT $LN9@compare
  0003c	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  0003f	74 2a		 je	 SHORT $LN5@compare
  00041	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00044	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00047	75 1a		 jne	 SHORT $LN9@compare
  00049	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0004c	74 1d		 je	 SHORT $LN5@compare
  0004e	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00051	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00054	75 0d		 jne	 SHORT $LN9@compare
  00056	83 f9 ff	 cmp	 ecx, -1
  00059	74 10		 je	 SHORT $LN5@compare
  0005b	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  0005e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00061	74 08		 je	 SHORT $LN5@compare
$LN9@compare:
  00063	1b c0		 sbb	 eax, eax
  00065	83 c8 01	 or	 eax, 1
  00068	5e		 pop	 esi

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
$LN5@compare:

; 517  : 		return (_Count == 0 ? 0

  0006b	33 c0		 xor	 eax, eax
  0006d	5e		 pop	 esi

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 344  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 345  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	66 8b 08	 mov	 cx, WORD PTR [eax]
  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	66 89 08	 mov	 WORD PTR [eax], cx

; 346  : 		}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z PROC	; std::char_traits<wchar_t>::move, COMDAT

; 332  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 333  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@move
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 334  : 			: (_Elem *)_CSTD wmemmove(_First1, _First2, _Count));
; 335  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@move:

; 333  : 		return (_Count == 0 ? _First1

  0000f	03 c0		 add	 eax, eax
  00011	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 334  : 			: (_Elem *)_CSTD wmemmove(_First1, _First2, _Count));
; 335  : 		}

  00014	5d		 pop	 ebp

; 333  : 		return (_Count == 0 ? _First1

  00015	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ENDP	; std::char_traits<wchar_t>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z PROC	; std::char_traits<wchar_t>::copy, COMDAT

; 309  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 310  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 311  : 			: (_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));
; 312  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 310  : 		return (_Count == 0 ? _First1

  0000f	03 c0		 add	 eax, eax
  00011	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 311  : 			: (_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));
; 312  : 		}

  00014	5d		 pop	 ebp

; 310  : 		return (_Count == 0 ? _First1

  00015	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ENDP	; std::char_traits<wchar_t>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@_W@std@@SAIPB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@_W@std@@SAIPB_W@Z PROC		; std::char_traits<wchar_t>::length, COMDAT

; 302  : 		{	// find length of null-terminated sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 303  : 		return (*_First == 0 ? 0

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	66 83 38 00	 cmp	 WORD PTR [eax], 0
  0000a	75 04		 jne	 SHORT $LN3@length
  0000c	33 c0		 xor	 eax, eax

; 304  : 			: _CSTD wcslen(_First));
; 305  : 		}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN3@length:

; 303  : 		return (*_First == 0 ? 0

  00010	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
$LL5@length:
  00013	66 8b 08	 mov	 cx, WORD PTR [eax]
  00016	83 c0 02	 add	 eax, 2
  00019	66 85 c9	 test	 cx, cx
  0001c	75 f5		 jne	 SHORT $LL5@length
  0001e	2b c2		 sub	 eax, edx
  00020	d1 f8		 sar	 eax, 1

; 304  : 			: _CSTD wcslen(_First));
; 305  : 		}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?length@?$char_traits@_W@std@@SAIPB_W@Z ENDP		; std::char_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 94   :         return;
; 95   :     }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemmove
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemmove PROC						; COMDAT

; 244  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00006	03 c0		 add	 eax, eax
  00008	89 45 10	 mov	 DWORD PTR __N$[ebp], eax

; 248  :         #pragma warning(pop)
; 249  :     }

  0000b	5d		 pop	 ebp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  0000c	e9 00 00 00 00	 jmp	 _memmove
_wmemmove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 231  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00006	03 c0		 add	 eax, eax
  00008	89 45 10	 mov	 DWORD PTR __N$[ebp], eax

; 235  :         #pragma warning(pop)
; 236  :     }

  0000b	5d		 pop	 ebp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0000c	e9 00 00 00 00	 jmp	 _memcpy
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<wchar_t const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<wchar_t const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT _fwprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fwprintf PROC						; COMDAT

; 496  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 497  :     int _Result;
; 498  :     va_list _ArgList;
; 499  :     __crt_va_start(_ArgList, _Format);
; 500  :     _Result = _vfwprintf_l(_Stream, _Format, NULL, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfwprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 501  :     __crt_va_end(_ArgList);
; 502  :     return _Result;
; 503  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_fwprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT __vfwprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfwprintf_l PROC					; COMDAT

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 304  :     return __stdio_common_vfwprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfwprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 305  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
__vfwprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
