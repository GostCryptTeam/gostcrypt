; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Common\Crypto.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0O@POKHNLDL@GOST?528147?989?$AA@		; `string'
PUBLIC	??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@	; `string'
PUBLIC	??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@	; `string'
PUBLIC	??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@	; `string'
PUBLIC	??_C@_09HLDHDDJL@Whirlpool?$AA@			; `string'
;	COMDAT ??_C@_09HLDHDDJL@Whirlpool?$AA@
CONST	SEGMENT
??_C@_09HLDHDDJL@Whirlpool?$AA@ DB 'Whirlpool', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@
CONST	SEGMENT
??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@ DB 'GOST R 34.11-94', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@
CONST	SEGMENT
??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@ DB 'GOST R 34.11-2012', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@
CONST	SEGMENT
??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@ DB 'Gost Grasshopper', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@POKHNLDL@GOST?528147?989?$AA@
CONST	SEGMENT
??_C@_0O@POKHNLDL@GOST?528147?989?$AA@ DB 'GOST 28147-89', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_Ciphers DD	01H
	DD	FLAT:??_C@_0O@POKHNLDL@GOST?528147?989?$AA@
	DD	08H
	DD	020H
	DD	0220H
	DD	02H
	DD	FLAT:??_C@_0BB@BMJBGELP@Gost?5Grasshopper?$AA@
	DD	010H
	DD	020H
	DD	0a0H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_EncryptionAlgorithms DD 00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	ORG $+4
	DD	00H
	DD	01H
	DD	00H
	ORG $+8
	DD	02H
	DD	00H
	ORG $+4
	DD	01H
	DD	02H
	DD	00H
	ORG $+8
	DD	01H
	DD	00H
	ORG $+4
	DD	01H
	DD	00H
	DD	00H
	ORG $+8
	DD	00H
	DD	00H
	ORG $+4
	DD	00H
_Hashes	DD	01H
	DD	FLAT:??_C@_0BC@IEIFLFFI@GOST?5R?534?411?92012?$AA@
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:??_C@_0BA@KDEBPBMN@GOST?5R?534?411?994?$AA@
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_09HLDHDDJL@Whirlpool?$AA@
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_DATA	ENDS
PUBLIC	_crypto_open
PUBLIC	_crypto_loadkey
PUBLIC	_crypto_close
PUBLIC	_CipherGetBlockSize
PUBLIC	_CipherGetKeySize
PUBLIC	_CipherGetKeyScheduleSize
PUBLIC	_CipherSupportsIntraDataUnitParallelization
PUBLIC	_CipherGetName
PUBLIC	_CipherInit
PUBLIC	_EAInit
PUBLIC	_EAInitMode
PUBLIC	_XorKeySchedule
PUBLIC	_EncipherBlock
PUBLIC	_DecipherBlock
PUBLIC	_EncipherBlocks
PUBLIC	_DecipherBlocks
PUBLIC	_EAGetFirst
PUBLIC	_EAGetCount
PUBLIC	_EAGetNext
PUBLIC	_EAGetName
PUBLIC	_EAGetByName
PUBLIC	_EAGetKeySize
PUBLIC	_EAGetFirstMode
PUBLIC	_EAGetNextMode
PUBLIC	_EAGetModeName
PUBLIC	_EAGetKeyScheduleSize
PUBLIC	_EAGetLargestKey
PUBLIC	_EAGetLargestKeyForMode
PUBLIC	_EAGetCipherCount
PUBLIC	_EAGetFirstCipher
PUBLIC	_EAGetLastCipher
PUBLIC	_EAGetNextCipher
PUBLIC	_EAGetPreviousCipher
PUBLIC	_EAIsFormatEnabled
PUBLIC	_EAIsModeSupported
PUBLIC	_HashGetName
PUBLIC	_HashIsDeprecated
PUBLIC	_GetMaxPkcs5OutSize
PUBLIC	_EncryptDataUnits
PUBLIC	_EncryptDataUnitsCurrentThread
PUBLIC	_DecryptDataUnits
PUBLIC	_DecryptDataUnitsCurrentThread
PUBLIC	_EncryptBuffer
PUBLIC	_DecryptBuffer
PUBLIC	_IsAesHwCpuSupported
PUBLIC	_EnableHwEncryption
PUBLIC	_IsHwEncryptionEnabled
PUBLIC	_CipherGet
PUBLIC	_HashGet
PUBLIC	_HashGetIdByName
PUBLIC	_Xor128
PUBLIC	_Xor64
PUBLIC	??_C@_01OGPIMHDM@?$DP?$AA@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
PUBLIC	??_C@_03CKCBIPFF@XTS?$AA@			; `string'
PUBLIC	??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@	; `string'
PUBLIC	??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@		; `string'
EXTRN	__imp__VirtualLock@8:PROC
EXTRN	__imp__VirtualUnlock@8:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_gost_encrypt:PROC
EXTRN	_gost_decrypt:PROC
EXTRN	_gost_set_key:PROC
EXTRN	_gost_xor_ks:PROC
EXTRN	_grasshopper_set_key:PROC
EXTRN	_grasshopper_encrypt:PROC
EXTRN	_grasshopper_decrypt:PROC
EXTRN	_grasshopper_xor_ks:PROC
EXTRN	_EncryptBufferXTS:PROC
EXTRN	_EncryptBufferXTS8Byte:PROC
EXTRN	_DecryptBufferXTS:PROC
EXTRN	_DecryptBufferXTS8Byte:PROC
EXTRN	_EncryptionThreadPoolDoWork:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_HwEncryptionDisabled DD 01H DUP (?)
?state@?1??IsAesHwCpuSupported@@9@9 DD 01H DUP (?)	; `IsAesHwCpuSupported'::`2'::state
?stateValid@?1??IsAesHwCpuSupported@@9@9 DD 01H DUP (?)	; `IsAesHwCpuSupported'::`2'::stateValid
_BSS	ENDS
;	COMDAT ??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@
CONST	SEGMENT
??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@ DB '[unknown]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@
CONST	SEGMENT
??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@ DB 'XTS 64-bit version', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03CKCBIPFF@XTS?$AA@
CONST	SEGMENT
??_C@_03CKCBIPFF@XTS?$AA@ DB 'XTS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP?$AA@
CONST	SEGMENT
??_C@_01OGPIMHDM@?$DP?$AA@ DB '?', 00H			; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _Xor64
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_Xor64	PROC						; COMDAT

; 1011 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1012 : 	*a ^= *b;

  00003	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00009	8b 02		 mov	 eax, DWORD PTR [edx]
  0000b	31 01		 xor	 DWORD PTR [ecx], eax
  0000d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00010	31 41 04	 xor	 DWORD PTR [ecx+4], eax

; 1013 : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_Xor64	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _Xor128
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_Xor128	PROC						; COMDAT

; 996  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 997  : 	*a++ ^= *b++;

  00003	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00009	8b 02		 mov	 eax, DWORD PTR [edx]
  0000b	31 01		 xor	 DWORD PTR [ecx], eax
  0000d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00010	31 41 04	 xor	 DWORD PTR [ecx+4], eax

; 998  : 	*a ^= *b;

  00013	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00016	31 41 08	 xor	 DWORD PTR [ecx+8], eax
  00019	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001c	31 41 0c	 xor	 DWORD PTR [ecx+12], eax

; 999  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_Xor128	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _HashGetIdByName
_TEXT	SEGMENT
_name$ = 8						; size = 4
_HashGetIdByName PROC					; COMDAT

; 846  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 847  : 	int i;
; 848  : 	for (i = 0; Hashes[i].Id != 0; i++)

  00004	33 f6		 xor	 esi, esi
  00006	57		 push	 edi
  00007	39 35 00 00 00
	00		 cmp	 DWORD PTR _Hashes, esi
  0000d	74 49		 je	 SHORT $LN3@HashGetIdB
  0000f	8b 7d 08	 mov	 edi, DWORD PTR _name$[ebp]
  00012	33 c9		 xor	 ecx, ecx
$LL4@HashGetIdB:

; 849  : 		if (strcmp (Hashes[i].Name, name) == 0)

  00014	8b 89 04 00 00
	00		 mov	 ecx, DWORD PTR _Hashes[ecx+4]
  0001a	8b c7		 mov	 eax, edi
  0001c	0f 1f 40 00	 npad	 4
$LL12@HashGetIdB:
  00020	8a 11		 mov	 dl, BYTE PTR [ecx]
  00022	3a 10		 cmp	 dl, BYTE PTR [eax]
  00024	75 1a		 jne	 SHORT $LN13@HashGetIdB
  00026	84 d2		 test	 dl, dl
  00028	74 12		 je	 SHORT $LN14@HashGetIdB
  0002a	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0002d	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00030	75 0e		 jne	 SHORT $LN13@HashGetIdB
  00032	83 c1 02	 add	 ecx, 2
  00035	83 c0 02	 add	 eax, 2
  00038	84 d2		 test	 dl, dl
  0003a	75 e4		 jne	 SHORT $LL12@HashGetIdB
$LN14@HashGetIdB:
  0003c	33 c0		 xor	 eax, eax
  0003e	eb 05		 jmp	 SHORT $LN15@HashGetIdB
$LN13@HashGetIdB:
  00040	1b c0		 sbb	 eax, eax
  00042	83 c8 01	 or	 eax, 1
$LN15@HashGetIdB:
  00045	85 c0		 test	 eax, eax
  00047	74 15		 je	 SHORT $LN8@HashGetIdB

; 847  : 	int i;
; 848  : 	for (i = 0; Hashes[i].Id != 0; i++)

  00049	46		 inc	 esi
  0004a	8b ce		 mov	 ecx, esi
  0004c	c1 e1 04	 shl	 ecx, 4
  0004f	83 b9 00 00 00
	00 00		 cmp	 DWORD PTR _Hashes[ecx], 0
  00056	75 bc		 jne	 SHORT $LL4@HashGetIdB
$LN3@HashGetIdB:
  00058	5f		 pop	 edi

; 851  : 
; 852  : 	return 0;

  00059	33 c0		 xor	 eax, eax
  0005b	5e		 pop	 esi

; 853  : }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN8@HashGetIdB:

; 850  : 			return Hashes[i].Id;

  0005e	c1 e6 04	 shl	 esi, 4
  00061	5f		 pop	 edi
  00062	8b 86 00 00 00
	00		 mov	 eax, DWORD PTR _Hashes[esi]
  00068	5e		 pop	 esi

; 853  : }

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_HashGetIdByName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _HashGet
_TEXT	SEGMENT
_id$ = 8						; size = 4
_HashGet PROC						; COMDAT

; 826  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 827  : 	int i;
; 828  : 	for (i = 0; Hashes[i].Id != 0; i++)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _Hashes
  00008	33 c9		 xor	 ecx, ecx
  0000a	85 c0		 test	 eax, eax
  0000c	74 17		 je	 SHORT $LN3@HashGet
  0000e	8b 55 08	 mov	 edx, DWORD PTR _id$[ebp]
$LL4@HashGet:

; 829  : 		if (Hashes[i].Id == id)

  00011	3b c2		 cmp	 eax, edx
  00013	74 14		 je	 SHORT $LN8@HashGet

; 827  : 	int i;
; 828  : 	for (i = 0; Hashes[i].Id != 0; i++)

  00015	41		 inc	 ecx
  00016	8b c1		 mov	 eax, ecx
  00018	c1 e0 04	 shl	 eax, 4
  0001b	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _Hashes[eax]
  00021	85 c0		 test	 eax, eax
  00023	75 ec		 jne	 SHORT $LL4@HashGet
$LN3@HashGet:

; 831  : 
; 832  : 	return 0;

  00025	33 c0		 xor	 eax, eax

; 833  : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN8@HashGet:

; 830  : 			return &Hashes[i];

  00029	c1 e1 04	 shl	 ecx, 4
  0002c	81 c1 00 00 00
	00		 add	 ecx, OFFSET _Hashes
  00032	8b c1		 mov	 eax, ecx

; 833  : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
_HashGet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _CipherGet
_TEXT	SEGMENT
_id$ = 8						; size = 4
_CipherGet PROC						; COMDAT

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 243  : 	int i;
; 244  : 	for (i = 0; Ciphers[i].Id != 0; i++)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _Ciphers
  00008	33 c9		 xor	 ecx, ecx
  0000a	85 c0		 test	 eax, eax
  0000c	74 16		 je	 SHORT $LN3@CipherGet
  0000e	8b 55 08	 mov	 edx, DWORD PTR _id$[ebp]
$LL4@CipherGet:

; 245  : 		if (Ciphers[i].Id == id)

  00011	3b c2		 cmp	 eax, edx
  00013	74 13		 je	 SHORT $LN8@CipherGet

; 243  : 	int i;
; 244  : 	for (i = 0; Ciphers[i].Id != 0; i++)

  00015	41		 inc	 ecx
  00016	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00019	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4]
  00020	85 c0		 test	 eax, eax
  00022	75 ed		 jne	 SHORT $LL4@CipherGet
$LN3@CipherGet:

; 247  : 
; 248  : 	return NULL;

  00024	33 c0		 xor	 eax, eax

; 249  : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
$LN8@CipherGet:

; 246  : 			return &Ciphers[i];

  00028	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0002b	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]

; 249  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
_CipherGet ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _IsHwEncryptionEnabled
_TEXT	SEGMENT
_IsHwEncryptionEnabled PROC				; COMDAT

; 1618 : 	return !HwEncryptionDisabled;

  00000	33 c0		 xor	 eax, eax
  00002	39 05 00 00 00
	00		 cmp	 DWORD PTR _HwEncryptionDisabled, eax
  00008	0f 94 c0	 sete	 al

; 1619 : }

  0000b	c3		 ret	 0
_IsHwEncryptionEnabled ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EnableHwEncryption
_TEXT	SEGMENT
_enable$ = 8						; size = 4
_EnableHwEncryption PROC				; COMDAT

; 1606 : 	//Deprecated
; 1607 : }

  00000	c3		 ret	 0
_EnableHwEncryption ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _IsAesHwCpuSupported
_TEXT	SEGMENT
_IsAesHwCpuSupported PROC				; COMDAT

; 1591 : 	}
; 1592 : 
; 1593 : 	return FALSE;//state && !HwEncryptionDisabled;

  00000	33 c0		 xor	 eax, eax
  00002	39 05 00 00 00
	00		 cmp	 DWORD PTR ?stateValid@?1??IsAesHwCpuSupported@@9@9, eax
  00008	75 0f		 jne	 SHORT $LN2@IsAesHwCpu

; 1584 : 	static BOOL state = FALSE;
; 1585 : 	static BOOL stateValid = FALSE;
; 1586 : 
; 1587 : 	if (!stateValid)
; 1588 : 	{
; 1589 : 		state = FALSE;//state = is_aes_hw_cpu_supported() ? TRUE : FALSE;
; 1590 : 		stateValid = TRUE;

  0000a	a3 00 00 00 00	 mov	 DWORD PTR ?state@?1??IsAesHwCpuSupported@@9@9, eax
  0000f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?stateValid@?1??IsAesHwCpuSupported@@9@9, 1
$LN2@IsAesHwCpu:

; 1594 : }

  00019	c3		 ret	 0
_IsAesHwCpuSupported ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _DecryptBuffer
_TEXT	SEGMENT
_dataUnitNo$1 = -8					; size = 8
_dataUnitNo$2 = -8					; size = 8
_buf$ = 8						; size = 4
_len$ = 12						; size = 8
_cryptoInfo$ = 20					; size = 4
_DecryptBuffer PROC					; COMDAT

; 1174 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 1175 : 	switch (cryptoInfo->mode)

  00007	8b 5d 14	 mov	 ebx, DWORD PTR _cryptoInfo$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0000f	83 e8 01	 sub	 eax, 1
  00012	0f 84 46 01 00
	00		 je	 $LN10@DecryptBuf
  00018	83 e8 01	 sub	 eax, 1
  0001b	74 0e		 je	 SHORT $LN11@DecryptBuf

; 1222 : 				 }
; 1223 : 	}
; 1224 : 		break;
; 1225 : 	default:		
; 1226 : 		// Unknown/wrong ID
; 1227 : 		GST_THROW_FATAL_EXCEPTION;

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  00026	5b		 pop	 ebx

; 1228 : 	}
; 1229 : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN11@DecryptBuf:

; 1198 : 			}
; 1199 : 		}
; 1200 : 		break;
; 1201 : 	case XTS8:
; 1202 : 	{
; 1203 : 				 unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize(cryptoInfo->ea);

  0002b	8b 33		 mov	 esi, DWORD PTR [ebx]
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize
  00033	8d 7b 08	 lea	 edi, DWORD PTR [ebx+8]

; 1204 : 				 unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize(cryptoInfo->ea);

  00036	56		 push	 esi
  00037	03 f8		 add	 edi, eax
  00039	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize
  0003e	81 c3 28 02 00
	00		 add	 ebx, 552		; 00000228H

; 1205 : 				 UINT64_STRUCT dataUnitNo;
; 1206 : 				 int cipher;
; 1207 : 
; 1208 : 				 // When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1209 : 				 // of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1210 : 				 // always assumed to be aligned with the start of the data unit 0.
; 1211 : 				 dataUnitNo.LowPart = 0;

  00044	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$1[ebp], 0
  0004b	8b ce		 mov	 ecx, esi

; 1212 : 				 dataUnitNo.HighPart = 0;

  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$1[ebp+4], 0
  00054	c1 e1 05	 shl	 ecx, 5
  00057	83 c4 08	 add	 esp, 8
  0005a	03 d8		 add	 ebx, eax

; 1213 : 
; 1214 : 				 for (cipher = EAGetLastCipher(cryptoInfo->ea);

  0005c	33 d2		 xor	 edx, edx
  0005e	81 c1 00 00 00
	00		 add	 ecx, OFFSET _EncryptionAlgorithms
$LL41@DecryptBuf:
  00064	8b 01		 mov	 eax, DWORD PTR [ecx]
  00066	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00069	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  0006c	85 c0		 test	 eax, eax
  0006e	75 f4		 jne	 SHORT $LL41@DecryptBuf
  00070	8d 04 f2	 lea	 eax, DWORD PTR [edx+esi*8]
  00073	8b 34 85 f8 ff
	ff ff		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax*4-8]

; 1215 : 					 cipher != 0;

  0007a	85 f6		 test	 esi, esi
  0007c	0f 84 04 02 00
	00		 je	 $LN116@DecryptBuf

; 1216 : 					 cipher = EAGetPreviousCipher(cryptoInfo->ea, cipher))

$LL44@DecryptBuf:

; 1217 : 				 {
; 1218 : 					 ks -= CipherGetKeyScheduleSize(cipher);

  00082	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Ciphers
  00088	33 c9		 xor	 ecx, ecx
  0008a	85 d2		 test	 edx, edx
  0008c	74 19		 je	 SHORT $LN54@DecryptBuf
  0008e	8b c2		 mov	 eax, edx
$LL55@DecryptBuf:
  00090	3b c6		 cmp	 eax, esi
  00092	0f 84 95 00 00
	00		 je	 $LN76@DecryptBuf
  00098	41		 inc	 ecx
  00099	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0009c	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4]
  000a3	85 c0		 test	 eax, eax
  000a5	75 e9		 jne	 SHORT $LL55@DecryptBuf
$LN54@DecryptBuf:
  000a7	33 c0		 xor	 eax, eax
$LN52@DecryptBuf:
  000a9	2b 78 10	 sub	 edi, DWORD PTR [eax+16]

; 1219 : 					 ks2 -= CipherGetKeyScheduleSize(cipher);

  000ac	33 c9		 xor	 ecx, ecx
  000ae	85 d2		 test	 edx, edx
  000b0	74 17		 je	 SHORT $LN62@DecryptBuf
$LL63@DecryptBuf:
  000b2	3b d6		 cmp	 edx, esi
  000b4	0f 84 82 00 00
	00		 je	 $LN77@DecryptBuf
  000ba	41		 inc	 ecx
  000bb	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  000be	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _Ciphers[eax*4]
  000c5	85 d2		 test	 edx, edx
  000c7	75 e9		 jne	 SHORT $LL63@DecryptBuf
$LN62@DecryptBuf:
  000c9	33 c0		 xor	 eax, eax
$LN60@DecryptBuf:
  000cb	2b 58 10	 sub	 ebx, DWORD PTR [eax+16]

; 1220 : 
; 1221 : 					 DecryptBufferXTS8Byte(buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  000ce	8d 45 f8	 lea	 eax, DWORD PTR _dataUnitNo$1[ebp]
  000d1	56		 push	 esi
  000d2	53		 push	 ebx
  000d3	57		 push	 edi
  000d4	6a 00		 push	 0
  000d6	50		 push	 eax
  000d7	ff 75 10	 push	 DWORD PTR _len$[ebp+4]
  000da	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  000dd	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  000e0	e8 00 00 00 00	 call	 _DecryptBufferXTS8Byte
  000e5	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  000e8	83 c4 20	 add	 esp, 32			; 00000020H
  000eb	b9 01 00 00 00	 mov	 ecx, 1
  000f0	8b 10		 mov	 edx, DWORD PTR [eax]
  000f2	8b c2		 mov	 eax, edx
  000f4	c1 e0 05	 shl	 eax, 5
  000f7	39 b0 00 00 00
	00		 cmp	 DWORD PTR _EncryptionAlgorithms[eax], esi
  000fd	0f 84 83 01 00
	00		 je	 $LN116@DecryptBuf

; 1216 : 					 cipher = EAGetPreviousCipher(cryptoInfo->ea, cipher))

  00103	8b 80 04 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+4]
  00109	85 c0		 test	 eax, eax
  0010b	0f 84 75 01 00
	00		 je	 $LN116@DecryptBuf
$LL45@DecryptBuf:
  00111	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00114	3b c6		 cmp	 eax, esi
  00116	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00119	74 2d		 je	 SHORT $LN78@DecryptBuf
  0011b	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4]
  00122	85 c0		 test	 eax, eax
  00124	75 eb		 jne	 SHORT $LL45@DecryptBuf
  00126	5f		 pop	 edi
  00127	5e		 pop	 esi
  00128	5b		 pop	 ebx

; 1228 : 	}
; 1229 : }

  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
$LN76@DecryptBuf:

; 1217 : 				 {
; 1218 : 					 ks -= CipherGetKeyScheduleSize(cipher);

  0012d	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00130	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  00137	e9 6d ff ff ff	 jmp	 $LN52@DecryptBuf
$LN77@DecryptBuf:

; 1219 : 					 ks2 -= CipherGetKeyScheduleSize(cipher);

  0013c	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0013f	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  00146	eb 83		 jmp	 SHORT $LN60@DecryptBuf
$LN78@DecryptBuf:

; 1216 : 					 cipher = EAGetPreviousCipher(cryptoInfo->ea, cipher))

  00148	8b 34 85 f8 ff
	ff ff		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax*4-8]
  0014f	85 f6		 test	 esi, esi
  00151	0f 85 2b ff ff
	ff		 jne	 $LL44@DecryptBuf
  00157	5f		 pop	 edi
  00158	5e		 pop	 esi
  00159	5b		 pop	 ebx

; 1228 : 	}
; 1229 : }

  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c3		 ret	 0
$LN10@DecryptBuf:

; 1176 : 	{
; 1177 : 	case XTS:
; 1178 : 		{
; 1179 : 			unsigned __int8 *ks = cryptoInfo->ks + EAGetKeyScheduleSize (cryptoInfo->ea);

  0015e	8b 33		 mov	 esi, DWORD PTR [ebx]
  00160	56		 push	 esi
  00161	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize
  00166	8d 7b 08	 lea	 edi, DWORD PTR [ebx+8]

; 1180 : 			unsigned __int8 *ks2 = cryptoInfo->ks2 + EAGetKeyScheduleSize (cryptoInfo->ea);

  00169	56		 push	 esi
  0016a	03 f8		 add	 edi, eax
  0016c	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize
  00171	81 c3 28 02 00
	00		 add	 ebx, 552		; 00000228H

; 1181 : 			UINT64_STRUCT dataUnitNo;
; 1182 : 			int cipher;
; 1183 : 
; 1184 : 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1185 : 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1186 : 			// always assumed to be aligned with the start of the data unit 0.
; 1187 : 			dataUnitNo.LowPart = 0;

  00177	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$2[ebp], 0
  0017e	8b ce		 mov	 ecx, esi

; 1188 : 			dataUnitNo.HighPart = 0;

  00180	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$2[ebp+4], 0
  00187	c1 e1 05	 shl	 ecx, 5
  0018a	83 c4 08	 add	 esp, 8
  0018d	03 d8		 add	 ebx, eax

; 1189 : 
; 1190 : 			for (cipher = EAGetLastCipher (cryptoInfo->ea);

  0018f	33 d2		 xor	 edx, edx
  00191	81 c1 00 00 00
	00		 add	 ecx, OFFSET _EncryptionAlgorithms
$LL15@DecryptBuf:
  00197	8b 01		 mov	 eax, DWORD PTR [ecx]
  00199	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0019c	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  0019f	85 c0		 test	 eax, eax
  001a1	75 f4		 jne	 SHORT $LL15@DecryptBuf
  001a3	8d 04 f2	 lea	 eax, DWORD PTR [edx+esi*8]
  001a6	8b 34 85 f8 ff
	ff ff		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax*4-8]

; 1191 : 				cipher != 0;

  001ad	85 f6		 test	 esi, esi
  001af	0f 84 d1 00 00
	00		 je	 $LN116@DecryptBuf

; 1192 : 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))

$LL18@DecryptBuf:

; 1193 : 			{
; 1194 : 				ks -= CipherGetKeyScheduleSize (cipher);

  001b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Ciphers
  001bb	33 c9		 xor	 ecx, ecx
  001bd	85 d2		 test	 edx, edx
  001bf	74 19		 je	 SHORT $LN28@DecryptBuf
  001c1	8b c2		 mov	 eax, edx
$LL29@DecryptBuf:
  001c3	3b c6		 cmp	 eax, esi
  001c5	0f 84 91 00 00
	00		 je	 $LN79@DecryptBuf
  001cb	41		 inc	 ecx
  001cc	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  001cf	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4]
  001d6	85 c0		 test	 eax, eax
  001d8	75 e9		 jne	 SHORT $LL29@DecryptBuf
$LN28@DecryptBuf:
  001da	33 c0		 xor	 eax, eax
$LN26@DecryptBuf:
  001dc	2b 78 10	 sub	 edi, DWORD PTR [eax+16]

; 1195 : 				ks2 -= CipherGetKeyScheduleSize (cipher);

  001df	33 c9		 xor	 ecx, ecx
  001e1	85 d2		 test	 edx, edx
  001e3	74 17		 je	 SHORT $LN36@DecryptBuf
$LL37@DecryptBuf:
  001e5	3b d6		 cmp	 edx, esi
  001e7	0f 84 7e 00 00
	00		 je	 $LN80@DecryptBuf
  001ed	41		 inc	 ecx
  001ee	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  001f1	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _Ciphers[eax*4]
  001f8	85 d2		 test	 edx, edx
  001fa	75 e9		 jne	 SHORT $LL37@DecryptBuf
$LN36@DecryptBuf:
  001fc	33 c0		 xor	 eax, eax
$LN34@DecryptBuf:
  001fe	2b 58 10	 sub	 ebx, DWORD PTR [eax+16]

; 1196 : 
; 1197 : 				DecryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  00201	8d 45 f8	 lea	 eax, DWORD PTR _dataUnitNo$2[ebp]
  00204	56		 push	 esi
  00205	53		 push	 ebx
  00206	57		 push	 edi
  00207	6a 00		 push	 0
  00209	50		 push	 eax
  0020a	ff 75 10	 push	 DWORD PTR _len$[ebp+4]
  0020d	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  00210	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00213	e8 00 00 00 00	 call	 _DecryptBufferXTS
  00218	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  0021b	83 c4 20	 add	 esp, 32			; 00000020H
  0021e	b9 01 00 00 00	 mov	 ecx, 1
  00223	8b 10		 mov	 edx, DWORD PTR [eax]
  00225	8b c2		 mov	 eax, edx
  00227	c1 e0 05	 shl	 eax, 5
  0022a	39 b0 00 00 00
	00		 cmp	 DWORD PTR _EncryptionAlgorithms[eax], esi
  00230	74 54		 je	 SHORT $LN116@DecryptBuf

; 1192 : 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))

  00232	8b 80 04 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+4]
  00238	85 c0		 test	 eax, eax
  0023a	74 4a		 je	 SHORT $LN116@DecryptBuf
  0023c	0f 1f 40 00	 npad	 4
$LL19@DecryptBuf:
  00240	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00243	3b c6		 cmp	 eax, esi
  00245	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00248	74 2d		 je	 SHORT $LN81@DecryptBuf
  0024a	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4]
  00251	85 c0		 test	 eax, eax
  00253	75 eb		 jne	 SHORT $LL19@DecryptBuf
  00255	5f		 pop	 edi
  00256	5e		 pop	 esi
  00257	5b		 pop	 ebx

; 1228 : 	}
; 1229 : }

  00258	8b e5		 mov	 esp, ebp
  0025a	5d		 pop	 ebp
  0025b	c3		 ret	 0
$LN79@DecryptBuf:

; 1193 : 			{
; 1194 : 				ks -= CipherGetKeyScheduleSize (cipher);

  0025c	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0025f	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  00266	e9 71 ff ff ff	 jmp	 $LN26@DecryptBuf
$LN80@DecryptBuf:

; 1195 : 				ks2 -= CipherGetKeyScheduleSize (cipher);

  0026b	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0026e	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  00275	eb 87		 jmp	 SHORT $LN34@DecryptBuf
$LN81@DecryptBuf:

; 1192 : 				cipher = EAGetPreviousCipher (cryptoInfo->ea, cipher))

  00277	8b 34 85 f8 ff
	ff ff		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax*4-8]
  0027e	85 f6		 test	 esi, esi
  00280	0f 85 2f ff ff
	ff		 jne	 $LL18@DecryptBuf
$LN116@DecryptBuf:
  00286	5f		 pop	 edi
  00287	5e		 pop	 esi
  00288	5b		 pop	 ebx

; 1228 : 	}
; 1229 : }

  00289	8b e5		 mov	 esp, ebp
  0028b	5d		 pop	 ebp
  0028c	c3		 ret	 0
_DecryptBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EncryptBuffer
_TEXT	SEGMENT
_dataUnitNo$1 = -8					; size = 8
_dataUnitNo$2 = -8					; size = 8
_buf$ = 8						; size = 4
_len$ = 12						; size = 8
_cryptoInfo$ = 20					; size = 4
_EncryptBuffer PROC					; COMDAT

; 1028 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1029 : 	switch (cryptoInfo->mode)

  00003	8b 4d 14	 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	83 e8 01	 sub	 eax, 1
  00012	0f 84 04 01 00
	00		 je	 $LN10@EncryptBuf
  00018	83 e8 01	 sub	 eax, 1
  0001b	74 0e		 je	 SHORT $LN11@EncryptBuf

; 1076 : 				 }
; 1077 : 		}
; 1078 : 		break;
; 1079 : 
; 1080 : 	default:		
; 1081 : 		// Unknown/wrong ID
; 1082 : 		GST_THROW_FATAL_EXCEPTION;

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  00026	5b		 pop	 ebx

; 1083 : 	}
; 1084 : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN11@EncryptBuf:

; 1052 : 			}
; 1053 : 		}
; 1054 : 		break;
; 1055 : 	case XTS8:
; 1056 : 		{
; 1057 : 				 unsigned __int8 *ks = cryptoInfo->ks;
; 1058 : 				 unsigned __int8 *ks2 = cryptoInfo->ks2;
; 1059 : 				 UINT64_STRUCT dataUnitNo;
; 1060 : 				 int cipher;
; 1061 : 
; 1062 : 				 // When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1063 : 				 // of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1064 : 				 // always assumed to be aligned with the start of a data unit.
; 1065 : 				 dataUnitNo.LowPart = 0;
; 1066 : 				 dataUnitNo.HighPart = 0;
; 1067 : 
; 1068 : 				 for (cipher = EAGetFirstCipher(cryptoInfo->ea);

  0002b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002d	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]
  00030	c1 e0 05	 shl	 eax, 5
  00033	8d 99 28 02 00
	00		 lea	 ebx, DWORD PTR [ecx+552]
  00039	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$1[ebp], 0
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$1[ebp+4], 0
  00047	8b b0 00 00 00
	00		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax]

; 1069 : 					 cipher != 0;

  0004d	85 f6		 test	 esi, esi
  0004f	0f 84 ae 01 00
	00		 je	 $LN102@EncryptBuf

; 1070 : 					 cipher = EAGetNextCipher(cryptoInfo->ea, cipher))

$LL39@EncryptBuf:

; 1071 : 				 {
; 1072 : 					 EncryptBufferXTS8Byte(buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  00055	56		 push	 esi
  00056	53		 push	 ebx
  00057	57		 push	 edi
  00058	6a 00		 push	 0
  0005a	8d 45 f8	 lea	 eax, DWORD PTR _dataUnitNo$1[ebp]
  0005d	50		 push	 eax
  0005e	ff 75 10	 push	 DWORD PTR _len$[ebp+4]
  00061	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  00064	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00067	e8 00 00 00 00	 call	 _EncryptBufferXTS8Byte

; 1073 : 
; 1074 : 					 ks += CipherGetKeyScheduleSize(cipher);

  0006c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Ciphers
  00072	83 c4 20	 add	 esp, 32			; 00000020H
  00075	33 c9		 xor	 ecx, ecx
  00077	85 d2		 test	 edx, edx
  00079	74 18		 je	 SHORT $LN48@EncryptBuf
  0007b	8b c2		 mov	 eax, edx
  0007d	0f 1f 00	 npad	 3
$LL49@EncryptBuf:
  00080	3b c6		 cmp	 eax, esi
  00082	74 6a		 je	 SHORT $LN68@EncryptBuf
  00084	41		 inc	 ecx
  00085	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00088	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4]
  0008f	85 c0		 test	 eax, eax
  00091	75 ed		 jne	 SHORT $LL49@EncryptBuf
$LN48@EncryptBuf:
  00093	33 c0		 xor	 eax, eax
$LN46@EncryptBuf:
  00095	03 78 10	 add	 edi, DWORD PTR [eax+16]

; 1075 : 					 ks2 += CipherGetKeyScheduleSize(cipher);

  00098	33 c9		 xor	 ecx, ecx
  0009a	85 d2		 test	 edx, edx
  0009c	74 15		 je	 SHORT $LN56@EncryptBuf
  0009e	66 90		 npad	 2
$LL57@EncryptBuf:
  000a0	3b d6		 cmp	 edx, esi
  000a2	74 56		 je	 SHORT $LN69@EncryptBuf
  000a4	41		 inc	 ecx
  000a5	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  000a8	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _Ciphers[eax*4]
  000af	85 d2		 test	 edx, edx
  000b1	75 ed		 jne	 SHORT $LL57@EncryptBuf
$LN56@EncryptBuf:
  000b3	33 c0		 xor	 eax, eax
$LN54@EncryptBuf:
  000b5	03 58 10	 add	 ebx, DWORD PTR [eax+16]
  000b8	33 c9		 xor	 ecx, ecx
  000ba	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  000bd	8b 10		 mov	 edx, DWORD PTR [eax]
  000bf	8b c2		 mov	 eax, edx
  000c1	c1 e0 05	 shl	 eax, 5
  000c4	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 31 01 00
	00		 je	 $LN102@EncryptBuf

; 1070 : 					 cipher = EAGetNextCipher(cryptoInfo->ea, cipher))

$LL40@EncryptBuf:
  000d2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000d5	3b c6		 cmp	 eax, esi
  000d7	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  000da	74 2a		 je	 SHORT $LN70@EncryptBuf
  000dc	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4]
  000e3	85 c0		 test	 eax, eax
  000e5	75 eb		 jne	 SHORT $LL40@EncryptBuf
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx

; 1083 : 	}
; 1084 : }

  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
$LN68@EncryptBuf:

; 1073 : 
; 1074 : 					 ks += CipherGetKeyScheduleSize(cipher);

  000ee	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  000f1	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  000f8	eb 9b		 jmp	 SHORT $LN46@EncryptBuf
$LN69@EncryptBuf:

; 1075 : 					 ks2 += CipherGetKeyScheduleSize(cipher);

  000fa	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  000fd	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  00104	eb af		 jmp	 SHORT $LN54@EncryptBuf
$LN70@EncryptBuf:

; 1070 : 					 cipher = EAGetNextCipher(cryptoInfo->ea, cipher))

  00106	8b 34 85 00 00
	00 00		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax*4]
  0010d	85 f6		 test	 esi, esi
  0010f	0f 85 40 ff ff
	ff		 jne	 $LL39@EncryptBuf
  00115	5f		 pop	 edi
  00116	5e		 pop	 esi
  00117	5b		 pop	 ebx

; 1083 : 	}
; 1084 : }

  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
$LN10@EncryptBuf:

; 1030 : 	{
; 1031 : 	case XTS:
; 1032 : 		{
; 1033 : 			unsigned __int8 *ks = cryptoInfo->ks;
; 1034 : 			unsigned __int8 *ks2 = cryptoInfo->ks2;
; 1035 : 			UINT64_STRUCT dataUnitNo;
; 1036 : 			int cipher;
; 1037 : 
; 1038 : 			// When encrypting/decrypting a buffer (typically a volume header) the sequential number
; 1039 : 			// of the first XTS data unit in the buffer is always 0 and the start of the buffer is
; 1040 : 			// always assumed to be aligned with the start of a data unit.
; 1041 : 			dataUnitNo.LowPart = 0;
; 1042 : 			dataUnitNo.HighPart = 0;
; 1043 : 
; 1044 : 			for (cipher = EAGetFirstCipher (cryptoInfo->ea);

  0011c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0011e	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]
  00121	c1 e0 05	 shl	 eax, 5
  00124	8d 99 28 02 00
	00		 lea	 ebx, DWORD PTR [ecx+552]
  0012a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$2[ebp], 0
  00131	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dataUnitNo$2[ebp+4], 0
  00138	8b b0 00 00 00
	00		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax]

; 1045 : 				cipher != 0;

  0013e	85 f6		 test	 esi, esi
  00140	0f 84 bd 00 00
	00		 je	 $LN102@EncryptBuf

; 1046 : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

$LL16@EncryptBuf:

; 1047 : 			{
; 1048 : 				EncryptBufferXTS (buf, len, &dataUnitNo, 0, ks, ks2, cipher);

  00146	56		 push	 esi
  00147	53		 push	 ebx
  00148	57		 push	 edi
  00149	6a 00		 push	 0
  0014b	8d 45 f8	 lea	 eax, DWORD PTR _dataUnitNo$2[ebp]
  0014e	50		 push	 eax
  0014f	ff 75 10	 push	 DWORD PTR _len$[ebp+4]
  00152	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  00155	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00158	e8 00 00 00 00	 call	 _EncryptBufferXTS

; 1049 : 
; 1050 : 				ks += CipherGetKeyScheduleSize (cipher);

  0015d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Ciphers
  00163	83 c4 20	 add	 esp, 32			; 00000020H
  00166	33 c9		 xor	 ecx, ecx
  00168	85 d2		 test	 edx, edx
  0016a	74 17		 je	 SHORT $LN25@EncryptBuf
  0016c	8b c2		 mov	 eax, edx
  0016e	66 90		 npad	 2
$LL26@EncryptBuf:
  00170	3b c6		 cmp	 eax, esi
  00172	74 68		 je	 SHORT $LN71@EncryptBuf
  00174	41		 inc	 ecx
  00175	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00178	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4]
  0017f	85 c0		 test	 eax, eax
  00181	75 ed		 jne	 SHORT $LL26@EncryptBuf
$LN25@EncryptBuf:
  00183	33 c0		 xor	 eax, eax
$LN23@EncryptBuf:
  00185	03 78 10	 add	 edi, DWORD PTR [eax+16]

; 1051 : 				ks2 += CipherGetKeyScheduleSize (cipher);

  00188	33 c9		 xor	 ecx, ecx
  0018a	85 d2		 test	 edx, edx
  0018c	74 15		 je	 SHORT $LN33@EncryptBuf
  0018e	66 90		 npad	 2
$LL34@EncryptBuf:
  00190	3b d6		 cmp	 edx, esi
  00192	74 54		 je	 SHORT $LN72@EncryptBuf
  00194	41		 inc	 ecx
  00195	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00198	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _Ciphers[eax*4]
  0019f	85 d2		 test	 edx, edx
  001a1	75 ed		 jne	 SHORT $LL34@EncryptBuf
$LN33@EncryptBuf:
  001a3	33 c0		 xor	 eax, eax
$LN31@EncryptBuf:
  001a5	03 58 10	 add	 ebx, DWORD PTR [eax+16]
  001a8	33 c9		 xor	 ecx, ecx
  001aa	8b 45 14	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  001ad	8b 10		 mov	 edx, DWORD PTR [eax]
  001af	8b c2		 mov	 eax, edx
  001b1	c1 e0 05	 shl	 eax, 5
  001b4	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]
  001ba	85 c0		 test	 eax, eax
  001bc	74 45		 je	 SHORT $LN102@EncryptBuf
  001be	66 90		 npad	 2

; 1046 : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

$LL17@EncryptBuf:
  001c0	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  001c3	3b c6		 cmp	 eax, esi
  001c5	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  001c8	74 2a		 je	 SHORT $LN73@EncryptBuf
  001ca	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4]
  001d1	85 c0		 test	 eax, eax
  001d3	75 eb		 jne	 SHORT $LL17@EncryptBuf
  001d5	5f		 pop	 edi
  001d6	5e		 pop	 esi
  001d7	5b		 pop	 ebx

; 1083 : 	}
; 1084 : }

  001d8	8b e5		 mov	 esp, ebp
  001da	5d		 pop	 ebp
  001db	c3		 ret	 0
$LN71@EncryptBuf:

; 1049 : 
; 1050 : 				ks += CipherGetKeyScheduleSize (cipher);

  001dc	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  001df	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  001e6	eb 9d		 jmp	 SHORT $LN23@EncryptBuf
$LN72@EncryptBuf:

; 1051 : 				ks2 += CipherGetKeyScheduleSize (cipher);

  001e8	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  001eb	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  001f2	eb b1		 jmp	 SHORT $LN31@EncryptBuf
$LN73@EncryptBuf:

; 1046 : 				cipher = EAGetNextCipher (cryptoInfo->ea, cipher))

  001f4	8b 34 85 00 00
	00 00		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax*4]
  001fb	85 f6		 test	 esi, esi
  001fd	0f 85 43 ff ff
	ff		 jne	 $LL16@EncryptBuf
$LN102@EncryptBuf:
  00203	5f		 pop	 edi
  00204	5e		 pop	 esi
  00205	5b		 pop	 ebx

; 1083 : 	}
; 1084 : }

  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c3		 ret	 0
_EncryptBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _DecryptDataUnitsCurrentThread
_TEXT	SEGMENT
tv790 = -12						; size = 4
tv760 = -12						; size = 4
tv789 = -8						; size = 4
tv744 = -8						; size = 4
_ks2$1$ = -4						; size = 4
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
_nbrUnits$ = 16						; size = 8
_ks$1$ = 24						; size = 4
_ci$ = 24						; size = 4
_DecryptDataUnitsCurrentThread PROC			; COMDAT

; 1265 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1266 : 	int ea = ci->ea;

  00003	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b 30		 mov	 esi, DWORD PTR [eax]

; 1267 : 	unsigned __int8 *ks = ci->ks;

  0000d	8d 58 08	 lea	 ebx, DWORD PTR [eax+8]
  00010	57		 push	 edi

; 1268 : 	unsigned __int8 *ks2 = ci->ks2;

  00011	8d b8 28 02 00
	00		 lea	 edi, DWORD PTR [eax+552]

; 1269 : 	int cipher;
; 1270 : 
; 1271 : 	switch (ci->mode)

  00017	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001a	83 e8 01	 sub	 eax, 1
  0001d	0f 84 58 01 00
	00		 je	 $LN10@DecryptDat
  00023	83 e8 01	 sub	 eax, 1
  00026	74 0e		 je	 SHORT $LN11@DecryptDat

; 1301 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1302 : 				structUnitNo,
; 1303 : 				0,
; 1304 : 				ks,
; 1305 : 				ks2,
; 1306 : 				cipher);
; 1307 : 		}
; 1308 : 		break;
; 1309 : 	default:		
; 1310 : 		// Unknown/wrong ID
; 1311 : 		GST_THROW_FATAL_EXCEPTION;

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  00031	5b		 pop	 ebx

; 1312 : 	}
; 1313 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN11@DecryptDat:

; 1283 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1284 : 				structUnitNo,
; 1285 : 				0,
; 1286 : 				ks,
; 1287 : 				ks2,
; 1288 : 				cipher);
; 1289 : 		}
; 1290 : 		break;
; 1291 : 	case XTS8:
; 1292 : 		ks += EAGetKeyScheduleSize(ea);

  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize
  0003c	03 d8		 add	 ebx, eax

; 1293 : 		ks2 += EAGetKeyScheduleSize(ea);

  0003e	56		 push	 esi
  0003f	89 5d 18	 mov	 DWORD PTR _ks$1$[ebp], ebx
  00042	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize
  00047	03 f8		 add	 edi, eax
  00049	83 c4 08	 add	 esp, 8
  0004c	89 7d fc	 mov	 DWORD PTR _ks2$1$[ebp], edi

; 1294 : 
; 1295 : 		for (cipher = EAGetLastCipher(ea); cipher != 0; cipher = EAGetPreviousCipher(ea, cipher))

  0004f	33 d2		 xor	 edx, edx
  00051	8b fe		 mov	 edi, esi
  00053	c1 e7 05	 shl	 edi, 5
  00056	8d 8f 00 00 00
	00		 lea	 ecx, DWORD PTR _EncryptionAlgorithms[edi]
  0005c	0f 1f 40 00	 npad	 4
$LL41@DecryptDat:
  00060	8b 01		 mov	 eax, DWORD PTR [ecx]
  00062	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  00065	42		 inc	 edx
  00066	85 c0		 test	 eax, eax
  00068	75 f6		 jne	 SHORT $LL41@DecryptDat
  0006a	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  00071	89 45 f4	 mov	 DWORD PTR tv790[ebp], eax
  00074	03 c2		 add	 eax, edx
  00076	8b 34 85 f8 ff
	ff ff		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax*4-8]
  0007d	85 f6		 test	 esi, esi
  0007f	0f 84 23 02 00
	00		 je	 $LN116@DecryptDat
  00085	8b 5d 10	 mov	 ebx, DWORD PTR _nbrUnits$[ebp]
  00088	8b 45 14	 mov	 eax, DWORD PTR _nbrUnits$[ebp+4]
  0008b	0f a4 d8 09	 shld	 eax, ebx, 9
  0008f	89 45 f8	 mov	 DWORD PTR tv744[ebp], eax
  00092	c1 e3 09	 shl	 ebx, 9
$LL44@DecryptDat:

; 1296 : 		{
; 1297 : 			ks -= CipherGetKeyScheduleSize(cipher);

  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Ciphers
  0009b	33 c9		 xor	 ecx, ecx
  0009d	85 d2		 test	 edx, edx
  0009f	74 19		 je	 SHORT $LN54@DecryptDat
  000a1	8b c2		 mov	 eax, edx
$LL55@DecryptDat:
  000a3	3b c6		 cmp	 eax, esi
  000a5	0f 84 9a 00 00
	00		 je	 $LN76@DecryptDat
  000ab	41		 inc	 ecx
  000ac	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  000af	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4]
  000b6	85 c0		 test	 eax, eax
  000b8	75 e9		 jne	 SHORT $LL55@DecryptDat
$LN54@DecryptDat:
  000ba	33 c0		 xor	 eax, eax
$LN52@DecryptDat:
  000bc	8b 4d 18	 mov	 ecx, DWORD PTR _ks$1$[ebp]
  000bf	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  000c2	89 4d 18	 mov	 DWORD PTR _ks$1$[ebp], ecx

; 1298 : 			ks2 -= CipherGetKeyScheduleSize(cipher);

  000c5	33 c9		 xor	 ecx, ecx
  000c7	85 d2		 test	 edx, edx
  000c9	74 1c		 je	 SHORT $LN62@DecryptDat
  000cb	0f 1f 44 00 00	 npad	 5
$LL63@DecryptDat:
  000d0	3b d6		 cmp	 edx, esi
  000d2	0f 84 7c 00 00
	00		 je	 $LN77@DecryptDat
  000d8	41		 inc	 ecx
  000d9	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  000dc	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _Ciphers[eax*4]
  000e3	85 d2		 test	 edx, edx
  000e5	75 e9		 jne	 SHORT $LL63@DecryptDat
$LN62@DecryptDat:
  000e7	33 c0		 xor	 eax, eax
$LN60@DecryptDat:
  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _ks2$1$[ebp]
  000ec	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]

; 1299 : 
; 1300 : 			DecryptBufferXTS8Byte(buf,

  000ef	56		 push	 esi
  000f0	51		 push	 ecx
  000f1	ff 75 18	 push	 DWORD PTR _ks$1$[ebp]
  000f4	89 4d fc	 mov	 DWORD PTR _ks2$1$[ebp], ecx
  000f7	6a 00		 push	 0
  000f9	ff 75 0c	 push	 DWORD PTR _structUnitNo$[ebp]
  000fc	ff 75 f8	 push	 DWORD PTR tv744[ebp]
  000ff	53		 push	 ebx
  00100	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00103	e8 00 00 00 00	 call	 _DecryptBufferXTS8Byte
  00108	83 c4 20	 add	 esp, 32			; 00000020H
  0010b	ba 01 00 00 00	 mov	 edx, 1
  00110	39 b7 00 00 00
	00		 cmp	 DWORD PTR _EncryptionAlgorithms[edi], esi
  00116	0f 84 8c 01 00
	00		 je	 $LN116@DecryptDat

; 1294 : 
; 1295 : 		for (cipher = EAGetLastCipher(ea); cipher != 0; cipher = EAGetPreviousCipher(ea, cipher))

  0011c	8b 87 04 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[edi+4]
  00122	85 c0		 test	 eax, eax
  00124	0f 84 7e 01 00
	00		 je	 $LN116@DecryptDat
  0012a	8d 8f 04 00 00
	00		 lea	 ecx, DWORD PTR _EncryptionAlgorithms[edi+4]
$LL45@DecryptDat:
  00130	42		 inc	 edx
  00131	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  00134	3b c6		 cmp	 eax, esi
  00136	74 28		 je	 SHORT $LN78@DecryptDat
  00138	8b 01		 mov	 eax, DWORD PTR [ecx]
  0013a	85 c0		 test	 eax, eax
  0013c	75 f2		 jne	 SHORT $LL45@DecryptDat
  0013e	5f		 pop	 edi
  0013f	5e		 pop	 esi
  00140	5b		 pop	 ebx

; 1312 : 	}
; 1313 : }

  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c3		 ret	 0
$LN76@DecryptDat:

; 1296 : 		{
; 1297 : 			ks -= CipherGetKeyScheduleSize(cipher);

  00145	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00148	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  0014f	e9 68 ff ff ff	 jmp	 $LN52@DecryptDat
$LN77@DecryptDat:

; 1298 : 			ks2 -= CipherGetKeyScheduleSize(cipher);

  00154	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00157	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  0015e	eb 89		 jmp	 SHORT $LN60@DecryptDat
$LN78@DecryptDat:

; 1294 : 
; 1295 : 		for (cipher = EAGetLastCipher(ea); cipher != 0; cipher = EAGetPreviousCipher(ea, cipher))

  00160	8b 45 f4	 mov	 eax, DWORD PTR tv790[ebp]
  00163	03 c2		 add	 eax, edx
  00165	8b 34 85 f8 ff
	ff ff		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax*4-8]
  0016c	85 f6		 test	 esi, esi
  0016e	0f 85 21 ff ff
	ff		 jne	 $LL44@DecryptDat
  00174	5f		 pop	 edi
  00175	5e		 pop	 esi
  00176	5b		 pop	 ebx

; 1312 : 	}
; 1313 : }

  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c3		 ret	 0
$LN10@DecryptDat:

; 1272 : 	{
; 1273 : 	case XTS:
; 1274 : 		ks += EAGetKeyScheduleSize (ea);

  0017b	56		 push	 esi
  0017c	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize
  00181	03 d8		 add	 ebx, eax

; 1275 : 		ks2 += EAGetKeyScheduleSize (ea);

  00183	56		 push	 esi
  00184	89 5d 18	 mov	 DWORD PTR _ks$1$[ebp], ebx
  00187	e8 00 00 00 00	 call	 _EAGetKeyScheduleSize
  0018c	03 f8		 add	 edi, eax
  0018e	83 c4 08	 add	 esp, 8
  00191	89 7d fc	 mov	 DWORD PTR _ks2$1$[ebp], edi

; 1276 : 
; 1277 : 		for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))

  00194	33 d2		 xor	 edx, edx
  00196	8b fe		 mov	 edi, esi
  00198	c1 e7 05	 shl	 edi, 5
  0019b	8d 8f 00 00 00
	00		 lea	 ecx, DWORD PTR _EncryptionAlgorithms[edi]
$LL15@DecryptDat:
  001a1	8b 01		 mov	 eax, DWORD PTR [ecx]
  001a3	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  001a6	42		 inc	 edx
  001a7	85 c0		 test	 eax, eax
  001a9	75 f6		 jne	 SHORT $LL15@DecryptDat
  001ab	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  001b2	89 45 f8	 mov	 DWORD PTR tv789[ebp], eax
  001b5	03 c2		 add	 eax, edx
  001b7	8b 34 85 f8 ff
	ff ff		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax*4-8]
  001be	85 f6		 test	 esi, esi
  001c0	0f 84 e2 00 00
	00		 je	 $LN116@DecryptDat
  001c6	8b 5d 10	 mov	 ebx, DWORD PTR _nbrUnits$[ebp]
  001c9	8b 45 14	 mov	 eax, DWORD PTR _nbrUnits$[ebp+4]
  001cc	0f a4 d8 09	 shld	 eax, ebx, 9
  001d0	89 45 f4	 mov	 DWORD PTR tv760[ebp], eax
  001d3	c1 e3 09	 shl	 ebx, 9
$LL18@DecryptDat:

; 1278 : 		{
; 1279 : 			ks -= CipherGetKeyScheduleSize (cipher);

  001d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Ciphers
  001dc	33 c9		 xor	 ecx, ecx
  001de	85 d2		 test	 edx, edx
  001e0	74 19		 je	 SHORT $LN28@DecryptDat
  001e2	8b c2		 mov	 eax, edx
$LL29@DecryptDat:
  001e4	3b c6		 cmp	 eax, esi
  001e6	0f 84 8d 00 00
	00		 je	 $LN79@DecryptDat
  001ec	41		 inc	 ecx
  001ed	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  001f0	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4]
  001f7	85 c0		 test	 eax, eax
  001f9	75 e9		 jne	 SHORT $LL29@DecryptDat
$LN28@DecryptDat:
  001fb	33 c0		 xor	 eax, eax
$LN26@DecryptDat:
  001fd	8b 4d 18	 mov	 ecx, DWORD PTR _ks$1$[ebp]
  00200	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  00203	89 4d 18	 mov	 DWORD PTR _ks$1$[ebp], ecx

; 1280 : 			ks2 -= CipherGetKeyScheduleSize (cipher);

  00206	33 c9		 xor	 ecx, ecx
  00208	85 d2		 test	 edx, edx
  0020a	74 17		 je	 SHORT $LN36@DecryptDat
  0020c	0f 1f 40 00	 npad	 4
$LL37@DecryptDat:
  00210	3b d6		 cmp	 edx, esi
  00212	74 74		 je	 SHORT $LN80@DecryptDat
  00214	41		 inc	 ecx
  00215	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00218	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _Ciphers[eax*4]
  0021f	85 d2		 test	 edx, edx
  00221	75 ed		 jne	 SHORT $LL37@DecryptDat
$LN36@DecryptDat:
  00223	33 c0		 xor	 eax, eax
$LN34@DecryptDat:
  00225	8b 4d fc	 mov	 ecx, DWORD PTR _ks2$1$[ebp]
  00228	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]

; 1281 : 
; 1282 : 			DecryptBufferXTS (buf,

  0022b	56		 push	 esi
  0022c	51		 push	 ecx
  0022d	ff 75 18	 push	 DWORD PTR _ks$1$[ebp]
  00230	89 4d fc	 mov	 DWORD PTR _ks2$1$[ebp], ecx
  00233	6a 00		 push	 0
  00235	ff 75 0c	 push	 DWORD PTR _structUnitNo$[ebp]
  00238	ff 75 f4	 push	 DWORD PTR tv760[ebp]
  0023b	53		 push	 ebx
  0023c	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  0023f	e8 00 00 00 00	 call	 _DecryptBufferXTS
  00244	83 c4 20	 add	 esp, 32			; 00000020H
  00247	ba 01 00 00 00	 mov	 edx, 1
  0024c	39 b7 00 00 00
	00		 cmp	 DWORD PTR _EncryptionAlgorithms[edi], esi
  00252	74 54		 je	 SHORT $LN116@DecryptDat

; 1276 : 
; 1277 : 		for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))

  00254	8b 87 04 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[edi+4]
  0025a	85 c0		 test	 eax, eax
  0025c	74 4a		 je	 SHORT $LN116@DecryptDat
  0025e	8d 8f 04 00 00
	00		 lea	 ecx, DWORD PTR _EncryptionAlgorithms[edi+4]
$LL19@DecryptDat:
  00264	42		 inc	 edx
  00265	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  00268	3b c6		 cmp	 eax, esi
  0026a	74 28		 je	 SHORT $LN81@DecryptDat
  0026c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0026e	85 c0		 test	 eax, eax
  00270	75 f2		 jne	 SHORT $LL19@DecryptDat
  00272	5f		 pop	 edi
  00273	5e		 pop	 esi
  00274	5b		 pop	 ebx

; 1312 : 	}
; 1313 : }

  00275	8b e5		 mov	 esp, ebp
  00277	5d		 pop	 ebp
  00278	c3		 ret	 0
$LN79@DecryptDat:

; 1278 : 		{
; 1279 : 			ks -= CipherGetKeyScheduleSize (cipher);

  00279	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0027c	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  00283	e9 75 ff ff ff	 jmp	 $LN26@DecryptDat
$LN80@DecryptDat:

; 1280 : 			ks2 -= CipherGetKeyScheduleSize (cipher);

  00288	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0028b	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  00292	eb 91		 jmp	 SHORT $LN34@DecryptDat
$LN81@DecryptDat:

; 1276 : 
; 1277 : 		for (cipher = EAGetLastCipher (ea); cipher != 0; cipher = EAGetPreviousCipher (ea, cipher))

  00294	8b 45 f8	 mov	 eax, DWORD PTR tv789[ebp]
  00297	03 c2		 add	 eax, edx
  00299	8b 34 85 f8 ff
	ff ff		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax*4-8]
  002a0	85 f6		 test	 esi, esi
  002a2	0f 85 2e ff ff
	ff		 jne	 $LL18@DecryptDat
$LN116@DecryptDat:
  002a8	5f		 pop	 edi
  002a9	5e		 pop	 esi
  002aa	5b		 pop	 ebx

; 1312 : 	}
; 1313 : }

  002ab	8b e5		 mov	 esp, ebp
  002ad	5d		 pop	 ebp
  002ae	c3		 ret	 0
_DecryptDataUnitsCurrentThread ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _DecryptDataUnits
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
_nbrUnits$ = 16						; size = 4
_ci$ = 20						; size = 4
_DecryptDataUnits PROC					; COMDAT

; 1246 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1247 : 	EncryptionThreadPoolDoWork (DecryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);

  00003	ff 75 14	 push	 DWORD PTR _ci$[ebp]
  00006	ff 75 10	 push	 DWORD PTR _nbrUnits$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR _structUnitNo$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  0000f	6a 01		 push	 1
  00011	e8 00 00 00 00	 call	 _EncryptionThreadPoolDoWork
  00016	83 c4 14	 add	 esp, 20			; 00000014H

; 1248 : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
_DecryptDataUnits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EncryptDataUnitsCurrentThread
_TEXT	SEGMENT
tv373 = -12						; size = 4
tv359 = -12						; size = 4
tv372 = -8						; size = 4
tv360 = -8						; size = 4
_ks$1$ = -4						; size = 4
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
_nbrUnits$ = 16						; size = 8
_ks2$1$ = 24						; size = 4
_ci$ = 24						; size = 4
_EncryptDataUnitsCurrentThread PROC			; COMDAT

; 1118 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1119 : 	int ea = ci->ea;

  00006	8b 45 18	 mov	 eax, DWORD PTR _ci$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 38		 mov	 edi, DWORD PTR [eax]

; 1120 : 	unsigned __int8 *ks = ci->ks;

  0000e	8d 50 08	 lea	 edx, DWORD PTR [eax+8]

; 1121 : 	unsigned __int8 *ks2 = ci->ks2;

  00011	8d 88 28 02 00
	00		 lea	 ecx, DWORD PTR [eax+552]
  00017	89 55 fc	 mov	 DWORD PTR _ks$1$[ebp], edx

; 1122 : 	int cipher;
; 1123 : 
; 1124 : 	switch (ci->mode)

  0001a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001d	89 4d 18	 mov	 DWORD PTR _ks2$1$[ebp], ecx
  00020	83 e8 01	 sub	 eax, 1
  00023	0f 84 0a 01 00
	00		 je	 $LN10@EncryptDat
  00029	83 e8 01	 sub	 eax, 1
  0002c	74 0e		 je	 SHORT $LN11@EncryptDat

; 1154 : 		}
; 1155 : 		break;
; 1156 : 	default:		
; 1157 : 		// Unknown/wrong ID
; 1158 : 		GST_THROW_FATAL_EXCEPTION;

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  00037	5b		 pop	 ebx

; 1159 : 	}
; 1160 : }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN11@EncryptDat:

; 1139 : 		}
; 1140 : 		break;
; 1141 : 	case XTS8:
; 1142 : 		for (cipher = EAGetFirstCipher(ea); cipher != 0; cipher = EAGetNextCipher(ea, cipher))

  0003c	8b df		 mov	 ebx, edi
  0003e	c1 e3 05	 shl	 ebx, 5
  00041	8b b3 00 00 00
	00		 mov	 esi, DWORD PTR _EncryptionAlgorithms[ebx]
  00047	85 f6		 test	 esi, esi
  00049	0f 84 dd 01 00
	00		 je	 $LN102@EncryptDat
  0004f	8b 45 10	 mov	 eax, DWORD PTR _nbrUnits$[ebp]
  00052	8b 4d 14	 mov	 ecx, DWORD PTR _nbrUnits$[ebp+4]
  00055	0f a4 c1 09	 shld	 ecx, eax, 9
  00059	c1 e0 09	 shl	 eax, 9
  0005c	89 4d f4	 mov	 DWORD PTR tv359[ebp], ecx
  0005f	89 45 f8	 mov	 DWORD PTR tv360[ebp], eax
$LL39@EncryptDat:

; 1143 : 		{
; 1144 : 			EncryptBufferXTS8Byte(buf,

  00062	56		 push	 esi
  00063	ff 75 18	 push	 DWORD PTR _ks2$1$[ebp]
  00066	52		 push	 edx
  00067	6a 00		 push	 0
  00069	ff 75 0c	 push	 DWORD PTR _structUnitNo$[ebp]
  0006c	51		 push	 ecx
  0006d	50		 push	 eax
  0006e	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00071	e8 00 00 00 00	 call	 _EncryptBufferXTS8Byte

; 1145 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1146 : 				structUnitNo,
; 1147 : 				0,
; 1148 : 				ks,
; 1149 : 				ks2,
; 1150 : 				cipher);
; 1151 : 
; 1152 : 			ks += CipherGetKeyScheduleSize(cipher);

  00076	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Ciphers
  0007c	83 c4 20	 add	 esp, 32			; 00000020H
  0007f	33 c9		 xor	 ecx, ecx
  00081	85 d2		 test	 edx, edx
  00083	74 15		 je	 SHORT $LN48@EncryptDat
  00085	8b c2		 mov	 eax, edx
$LL49@EncryptDat:
  00087	3b c6		 cmp	 eax, esi
  00089	74 71		 je	 SHORT $LN68@EncryptDat
  0008b	41		 inc	 ecx
  0008c	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0008f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4]
  00096	85 c0		 test	 eax, eax
  00098	75 ed		 jne	 SHORT $LL49@EncryptDat
$LN48@EncryptDat:
  0009a	33 c0		 xor	 eax, eax
$LN46@EncryptDat:
  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _ks$1$[ebp]
  0009f	03 48 10	 add	 ecx, DWORD PTR [eax+16]
  000a2	89 4d fc	 mov	 DWORD PTR _ks$1$[ebp], ecx

; 1153 : 			ks2 += CipherGetKeyScheduleSize(cipher);

  000a5	33 c9		 xor	 ecx, ecx
  000a7	85 d2		 test	 edx, edx
  000a9	74 18		 je	 SHORT $LN56@EncryptDat
  000ab	0f 1f 44 00 00	 npad	 5
$LL57@EncryptDat:
  000b0	3b d6		 cmp	 edx, esi
  000b2	74 54		 je	 SHORT $LN69@EncryptDat
  000b4	41		 inc	 ecx
  000b5	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  000b8	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _Ciphers[eax*4]
  000bf	85 d2		 test	 edx, edx
  000c1	75 ed		 jne	 SHORT $LL57@EncryptDat
$LN56@EncryptDat:
  000c3	33 c0		 xor	 eax, eax
$LN54@EncryptDat:
  000c5	8b 4d 18	 mov	 ecx, DWORD PTR _ks2$1$[ebp]
  000c8	03 48 10	 add	 ecx, DWORD PTR [eax+16]
  000cb	8b 83 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[ebx]
  000d1	89 4d 18	 mov	 DWORD PTR _ks2$1$[ebp], ecx
  000d4	33 c9		 xor	 ecx, ecx
  000d6	85 c0		 test	 eax, eax
  000d8	0f 84 4e 01 00
	00		 je	 $LN102@EncryptDat
  000de	66 90		 npad	 2

; 1139 : 		}
; 1140 : 		break;
; 1141 : 	case XTS8:
; 1142 : 		for (cipher = EAGetFirstCipher(ea); cipher != 0; cipher = EAGetNextCipher(ea, cipher))

$LL40@EncryptDat:
  000e0	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000e3	3b c6		 cmp	 eax, esi
  000e5	8d 04 f9	 lea	 eax, DWORD PTR [ecx+edi*8]
  000e8	74 2a		 je	 SHORT $LN70@EncryptDat
  000ea	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4]
  000f1	85 c0		 test	 eax, eax
  000f3	75 eb		 jne	 SHORT $LL40@EncryptDat
  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx

; 1159 : 	}
; 1160 : }

  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
$LN68@EncryptDat:

; 1145 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1146 : 				structUnitNo,
; 1147 : 				0,
; 1148 : 				ks,
; 1149 : 				ks2,
; 1150 : 				cipher);
; 1151 : 
; 1152 : 			ks += CipherGetKeyScheduleSize(cipher);

  000fc	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  000ff	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  00106	eb 94		 jmp	 SHORT $LN46@EncryptDat
$LN69@EncryptDat:

; 1153 : 			ks2 += CipherGetKeyScheduleSize(cipher);

  00108	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0010b	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  00112	eb b1		 jmp	 SHORT $LN54@EncryptDat
$LN70@EncryptDat:

; 1139 : 		}
; 1140 : 		break;
; 1141 : 	case XTS8:
; 1142 : 		for (cipher = EAGetFirstCipher(ea); cipher != 0; cipher = EAGetNextCipher(ea, cipher))

  00114	8b 34 85 00 00
	00 00		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax*4]
  0011b	8b 45 f8	 mov	 eax, DWORD PTR tv360[ebp]
  0011e	8b 4d f4	 mov	 ecx, DWORD PTR tv359[ebp]
  00121	8b 55 fc	 mov	 edx, DWORD PTR _ks$1$[ebp]
  00124	85 f6		 test	 esi, esi
  00126	0f 85 36 ff ff
	ff		 jne	 $LL39@EncryptDat
  0012c	5f		 pop	 edi
  0012d	5e		 pop	 esi
  0012e	5b		 pop	 ebx

; 1159 : 	}
; 1160 : }

  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c3		 ret	 0
$LN10@EncryptDat:

; 1125 : 	{
; 1126 : 	case XTS:
; 1127 : 		for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

  00133	8b df		 mov	 ebx, edi
  00135	c1 e3 05	 shl	 ebx, 5
  00138	8b b3 00 00 00
	00		 mov	 esi, DWORD PTR _EncryptionAlgorithms[ebx]
  0013e	85 f6		 test	 esi, esi
  00140	0f 84 e6 00 00
	00		 je	 $LN102@EncryptDat
  00146	8b 45 10	 mov	 eax, DWORD PTR _nbrUnits$[ebp]
  00149	8b 4d 14	 mov	 ecx, DWORD PTR _nbrUnits$[ebp+4]
  0014c	0f a4 c1 09	 shld	 ecx, eax, 9
  00150	c1 e0 09	 shl	 eax, 9
  00153	89 4d f8	 mov	 DWORD PTR tv372[ebp], ecx
  00156	89 45 f4	 mov	 DWORD PTR tv373[ebp], eax
  00159	0f 1f 80 00 00
	00 00		 npad	 7
$LL16@EncryptDat:

; 1128 : 		{
; 1129 : 			EncryptBufferXTS (buf,

  00160	56		 push	 esi
  00161	ff 75 18	 push	 DWORD PTR _ks2$1$[ebp]
  00164	52		 push	 edx
  00165	6a 00		 push	 0
  00167	ff 75 0c	 push	 DWORD PTR _structUnitNo$[ebp]
  0016a	51		 push	 ecx
  0016b	50		 push	 eax
  0016c	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  0016f	e8 00 00 00 00	 call	 _EncryptBufferXTS

; 1130 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1131 : 				structUnitNo,
; 1132 : 				0,
; 1133 : 				ks,
; 1134 : 				ks2,
; 1135 : 				cipher);
; 1136 : 
; 1137 : 			ks += CipherGetKeyScheduleSize (cipher);

  00174	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Ciphers
  0017a	83 c4 20	 add	 esp, 32			; 00000020H
  0017d	33 c9		 xor	 ecx, ecx
  0017f	85 d2		 test	 edx, edx
  00181	74 15		 je	 SHORT $LN25@EncryptDat
  00183	8b c2		 mov	 eax, edx
$LL26@EncryptDat:
  00185	3b c6		 cmp	 eax, esi
  00187	74 73		 je	 SHORT $LN71@EncryptDat
  00189	41		 inc	 ecx
  0018a	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0018d	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4]
  00194	85 c0		 test	 eax, eax
  00196	75 ed		 jne	 SHORT $LL26@EncryptDat
$LN25@EncryptDat:
  00198	33 c0		 xor	 eax, eax
$LN23@EncryptDat:
  0019a	8b 4d fc	 mov	 ecx, DWORD PTR _ks$1$[ebp]
  0019d	03 48 10	 add	 ecx, DWORD PTR [eax+16]
  001a0	89 4d fc	 mov	 DWORD PTR _ks$1$[ebp], ecx

; 1138 : 			ks2 += CipherGetKeyScheduleSize (cipher);

  001a3	33 c9		 xor	 ecx, ecx
  001a5	85 d2		 test	 edx, edx
  001a7	74 1a		 je	 SHORT $LN33@EncryptDat
  001a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL34@EncryptDat:
  001b0	3b d6		 cmp	 edx, esi
  001b2	74 54		 je	 SHORT $LN72@EncryptDat
  001b4	41		 inc	 ecx
  001b5	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  001b8	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _Ciphers[eax*4]
  001bf	85 d2		 test	 edx, edx
  001c1	75 ed		 jne	 SHORT $LL34@EncryptDat
$LN33@EncryptDat:
  001c3	33 c0		 xor	 eax, eax
$LN31@EncryptDat:
  001c5	8b 4d 18	 mov	 ecx, DWORD PTR _ks2$1$[ebp]
  001c8	03 48 10	 add	 ecx, DWORD PTR [eax+16]
  001cb	8b 83 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[ebx]
  001d1	89 4d 18	 mov	 DWORD PTR _ks2$1$[ebp], ecx
  001d4	33 c9		 xor	 ecx, ecx
  001d6	85 c0		 test	 eax, eax
  001d8	74 52		 je	 SHORT $LN102@EncryptDat
  001da	66 0f 1f 44 00
	00		 npad	 6

; 1125 : 	{
; 1126 : 	case XTS:
; 1127 : 		for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

$LL17@EncryptDat:
  001e0	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  001e3	3b c6		 cmp	 eax, esi
  001e5	8d 04 f9	 lea	 eax, DWORD PTR [ecx+edi*8]
  001e8	74 2a		 je	 SHORT $LN73@EncryptDat
  001ea	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4]
  001f1	85 c0		 test	 eax, eax
  001f3	75 eb		 jne	 SHORT $LL17@EncryptDat
  001f5	5f		 pop	 edi
  001f6	5e		 pop	 esi
  001f7	5b		 pop	 ebx

; 1159 : 	}
; 1160 : }

  001f8	8b e5		 mov	 esp, ebp
  001fa	5d		 pop	 ebp
  001fb	c3		 ret	 0
$LN71@EncryptDat:

; 1130 : 				nbrUnits * ENCRYPTION_DATA_UNIT_SIZE,
; 1131 : 				structUnitNo,
; 1132 : 				0,
; 1133 : 				ks,
; 1134 : 				ks2,
; 1135 : 				cipher);
; 1136 : 
; 1137 : 			ks += CipherGetKeyScheduleSize (cipher);

  001fc	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  001ff	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  00206	eb 92		 jmp	 SHORT $LN23@EncryptDat
$LN72@EncryptDat:

; 1138 : 			ks2 += CipherGetKeyScheduleSize (cipher);

  00208	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0020b	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  00212	eb b1		 jmp	 SHORT $LN31@EncryptDat
$LN73@EncryptDat:

; 1125 : 	{
; 1126 : 	case XTS:
; 1127 : 		for (cipher = EAGetFirstCipher (ea); cipher != 0; cipher = EAGetNextCipher (ea, cipher))

  00214	8b 34 85 00 00
	00 00		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax*4]
  0021b	8b 45 f4	 mov	 eax, DWORD PTR tv373[ebp]
  0021e	8b 4d f8	 mov	 ecx, DWORD PTR tv372[ebp]
  00221	8b 55 fc	 mov	 edx, DWORD PTR _ks$1$[ebp]
  00224	85 f6		 test	 esi, esi
  00226	0f 85 34 ff ff
	ff		 jne	 $LL16@EncryptDat
$LN102@EncryptDat:
  0022c	5f		 pop	 edi
  0022d	5e		 pop	 esi
  0022e	5b		 pop	 ebx

; 1159 : 	}
; 1160 : }

  0022f	8b e5		 mov	 esp, ebp
  00231	5d		 pop	 ebp
  00232	c3		 ret	 0
_EncryptDataUnitsCurrentThread ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EncryptDataUnits
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_structUnitNo$ = 12					; size = 4
_nbrUnits$ = 16						; size = 4
_ci$ = 20						; size = 4
_EncryptDataUnits PROC					; COMDAT

; 1101 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1102 : 	EncryptionThreadPoolDoWork (EncryptDataUnitsWork, buf, structUnitNo, nbrUnits, ci);

  00003	ff 75 14	 push	 DWORD PTR _ci$[ebp]
  00006	ff 75 10	 push	 DWORD PTR _nbrUnits$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR _structUnitNo$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  0000f	6a 00		 push	 0
  00011	e8 00 00 00 00	 call	 _EncryptionThreadPoolDoWork
  00016	83 c4 14	 add	 esp, 20			; 00000014H

; 1103 : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
_EncryptDataUnits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _GetMaxPkcs5OutSize
_TEXT	SEGMENT
_GetMaxPkcs5OutSize PROC				; COMDAT

; 1323 : {

  00000	56		 push	 esi

; 1324 : 	int size = 32;
; 1325 : 
; 1326 : 	size = max (size, EAGetLargestKeyForMode (XTS) * 2);	// Sizes of primary + secondary keys

  00001	6a 01		 push	 1
  00003	be 20 00 00 00	 mov	 esi, 32			; 00000020H
  00008	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode
  0000d	03 c0		 add	 eax, eax
  0000f	83 c4 04	 add	 esp, 4
  00012	3b c6		 cmp	 eax, esi
  00014	7c 0e		 jl	 SHORT $LN4@GetMaxPkcs
  00016	6a 01		 push	 1
  00018	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode
  0001d	8b f0		 mov	 esi, eax
  0001f	83 c4 04	 add	 esp, 4
  00022	03 f6		 add	 esi, esi
$LN4@GetMaxPkcs:

; 1327 : 	size = max (size, EAGetLargestKeyForMode (XTS8) * 2);

  00024	6a 02		 push	 2
  00026	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode
  0002b	03 c0		 add	 eax, eax
  0002d	83 c4 04	 add	 esp, 4
  00030	3b f0		 cmp	 esi, eax
  00032	7f 0e		 jg	 SHORT $LN7@GetMaxPkcs
  00034	6a 02		 push	 2
  00036	e8 00 00 00 00	 call	 _EAGetLargestKeyForMode
  0003b	83 c4 04	 add	 esp, 4
  0003e	03 c0		 add	 eax, eax
  00040	5e		 pop	 esi

; 1330 : }

  00041	c3		 ret	 0
$LN7@GetMaxPkcs:

; 1328 : 
; 1329 : 	return size;

  00042	8b c6		 mov	 eax, esi
  00044	5e		 pop	 esi

; 1330 : }

  00045	c3		 ret	 0
_GetMaxPkcs5OutSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _HashIsDeprecated
_TEXT	SEGMENT
_hashId$ = 8						; size = 4
_HashIsDeprecated PROC					; COMDAT

; 879  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 880  : 	return HashGet (hashId) -> Deprecated;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _Hashes
  00008	33 c9		 xor	 ecx, ecx
  0000a	85 c0		 test	 eax, eax
  0000c	74 17		 je	 SHORT $LN5@HashIsDepr
  0000e	8b 55 08	 mov	 edx, DWORD PTR _hashId$[ebp]
$LL6@HashIsDepr:
  00011	3b c2		 cmp	 eax, edx
  00013	74 17		 je	 SHORT $LN10@HashIsDepr
  00015	41		 inc	 ecx
  00016	8b c1		 mov	 eax, ecx
  00018	c1 e0 04	 shl	 eax, 4
  0001b	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _Hashes[eax]
  00021	85 c0		 test	 eax, eax
  00023	75 ec		 jne	 SHORT $LL6@HashIsDepr
$LN5@HashIsDepr:
  00025	33 c0		 xor	 eax, eax
  00027	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 881  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN10@HashIsDepr:

; 880  : 	return HashGet (hashId) -> Deprecated;

  0002c	c1 e1 04	 shl	 ecx, 4
  0002f	81 c1 00 00 00
	00		 add	 ecx, OFFSET _Hashes
  00035	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 881  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_HashIsDeprecated ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _HashGetName
_TEXT	SEGMENT
_hashId$ = 8						; size = 4
_HashGetName PROC					; COMDAT

; 865  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 866  : 	return HashGet (hashId) -> Name;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _Hashes
  00008	33 c9		 xor	 ecx, ecx
  0000a	85 c0		 test	 eax, eax
  0000c	74 17		 je	 SHORT $LN5@HashGetNam
  0000e	8b 55 08	 mov	 edx, DWORD PTR _hashId$[ebp]
$LL6@HashGetNam:
  00011	3b c2		 cmp	 eax, edx
  00013	74 17		 je	 SHORT $LN10@HashGetNam
  00015	41		 inc	 ecx
  00016	8b c1		 mov	 eax, ecx
  00018	c1 e0 04	 shl	 eax, 4
  0001b	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _Hashes[eax]
  00021	85 c0		 test	 eax, eax
  00023	75 ec		 jne	 SHORT $LL6@HashGetNam
$LN5@HashGetNam:
  00025	33 c0		 xor	 eax, eax
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 867  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN10@HashGetNam:

; 866  : 	return HashGet (hashId) -> Name;

  0002c	c1 e1 04	 shl	 ecx, 4
  0002f	81 c1 00 00 00
	00		 add	 ecx, OFFSET _Hashes
  00035	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 867  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_HashGetName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAIsModeSupported
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_testedMode$ = 12					; size = 4
_EAIsModeSupported PROC					; COMDAT

; 804  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 805  : 	int mode;
; 806  : 
; 807  : 	for (mode = EAGetFirstMode (ea); mode != 0; mode = EAGetNextMode (ea, mode))

  00005	8b 75 08	 mov	 esi, DWORD PTR _ea$[ebp]
  00008	8b c6		 mov	 eax, esi
  0000a	c1 e0 05	 shl	 eax, 5
  0000d	57		 push	 edi
  0000e	8b 98 10 00 00
	00		 mov	 ebx, DWORD PTR _EncryptionAlgorithms[eax+16]
  00014	8b d3		 mov	 edx, ebx
  00016	85 d2		 test	 edx, edx
  00018	74 2b		 je	 SHORT $LN3@EAIsModeSu
  0001a	8b 7d 0c	 mov	 edi, DWORD PTR _testedMode$[ebp]
  0001d	0f 1f 00	 npad	 3
$LL9@EAIsModeSu:

; 808  : 	{
; 809  : 		if (mode == testedMode)

  00020	3b d7		 cmp	 edx, edi
  00022	74 3d		 je	 SHORT $LN17@EAIsModeSu

; 805  : 	int mode;
; 806  : 
; 807  : 	for (mode = EAGetFirstMode (ea); mode != 0; mode = EAGetNextMode (ea, mode))

  00024	8b cb		 mov	 ecx, ebx
  00026	33 c0		 xor	 eax, eax
  00028	85 c9		 test	 ecx, ecx
  0002a	74 19		 je	 SHORT $LN3@EAIsModeSu
  0002c	0f 1f 40 00	 npad	 4
$LL10@EAIsModeSu:
  00030	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00033	3b ca		 cmp	 ecx, edx
  00035	74 15		 je	 SHORT $LN16@EAIsModeSu
  00037	8d 0c f0	 lea	 ecx, DWORD PTR [eax+esi*8]
  0003a	8b 0c 8d 10 00
	00 00		 mov	 ecx, DWORD PTR _EncryptionAlgorithms[ecx*4+16]
  00041	85 c9		 test	 ecx, ecx
  00043	75 eb		 jne	 SHORT $LL10@EAIsModeSu
$LN3@EAIsModeSu:
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi

; 811  : 	}
; 812  : 	return FALSE;

  00047	33 c0		 xor	 eax, eax
  00049	5b		 pop	 ebx

; 813  : }

  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN16@EAIsModeSu:

; 805  : 	int mode;
; 806  : 
; 807  : 	for (mode = EAGetFirstMode (ea); mode != 0; mode = EAGetNextMode (ea, mode))

  0004c	8d 04 f0	 lea	 eax, DWORD PTR [eax+esi*8]
  0004f	8b 14 85 10 00
	00 00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax*4+16]
  00056	85 d2		 test	 edx, edx
  00058	75 c6		 jne	 SHORT $LL9@EAIsModeSu

; 811  : 	}
; 812  : 	return FALSE;

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	33 c0		 xor	 eax, eax
  0005e	5b		 pop	 ebx

; 813  : }

  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
$LN17@EAIsModeSu:
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi

; 810  : 			return TRUE;

  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	5b		 pop	 ebx

; 813  : }

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_EAIsModeSupported ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAIsFormatEnabled
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAIsFormatEnabled PROC					; COMDAT

; 789  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 790  : 	return EncryptionAlgorithms[ea].FormatEnabled;

  00003	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00006	c1 e0 05	 shl	 eax, 5
  00009	8b 80 1c 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+28]

; 791  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_EAIsFormatEnabled ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetPreviousCipher
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_previousCipherId$ = 12					; size = 4
_EAGetPreviousCipher PROC				; COMDAT

; 764  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 765  : 	int c, i = 0;
; 766  : 
; 767  : 	if (EncryptionAlgorithms[ea].Ciphers[i++] == previousCipherId)

  00003	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  00006	b9 01 00 00 00	 mov	 ecx, 1
  0000b	8b c2		 mov	 eax, edx
  0000d	c1 e0 05	 shl	 eax, 5
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _previousCipherId$[ebp]
  00014	39 b0 00 00 00
	00		 cmp	 DWORD PTR _EncryptionAlgorithms[eax], esi
  0001a	74 1f		 je	 SHORT $LN9@EAGetPrevi

; 768  : 		return 0;
; 769  : 
; 770  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  0001c	8b 80 04 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+4]
  00022	85 c0		 test	 eax, eax
  00024	74 15		 je	 SHORT $LN9@EAGetPrevi
$LL2@EAGetPrevi:
  00026	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 771  : 	{
; 772  : 		if (c == previousCipherId) 

  00029	3b c6		 cmp	 eax, esi
  0002b	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  0002e	74 10		 je	 SHORT $LN8@EAGetPrevi

; 768  : 		return 0;
; 769  : 
; 770  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  00030	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4]
  00037	85 c0		 test	 eax, eax
  00039	75 eb		 jne	 SHORT $LL2@EAGetPrevi
$LN9@EAGetPrevi:

; 774  : 	}
; 775  : 
; 776  : 	return 0;

  0003b	33 c0		 xor	 eax, eax
  0003d	5e		 pop	 esi

; 777  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN8@EAGetPrevi:

; 773  : 			return EncryptionAlgorithms[ea].Ciphers[i - 2];

  00040	8b 04 85 f8 ff
	ff ff		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4-8]
  00047	5e		 pop	 esi

; 777  : }

  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
_EAGetPreviousCipher ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetNextCipher
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_previousCipherId$ = 12					; size = 4
_EAGetNextCipher PROC					; COMDAT

; 741  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 742  : 	int c, i = 0;
; 743  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  00003	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	8b c2		 mov	 eax, edx
  0000a	c1 e0 05	 shl	 eax, 5
  0000d	56		 push	 esi
  0000e	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]
  00014	85 c0		 test	 eax, eax
  00016	74 1d		 je	 SHORT $LN8@EAGetNextC
  00018	8b 75 0c	 mov	 esi, DWORD PTR _previousCipherId$[ebp]
  0001b	0f 1f 44 00 00	 npad	 5
$LL2@EAGetNextC:
  00020	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 744  : 	{
; 745  : 		if (c == previousCipherId) 

  00023	3b c6		 cmp	 eax, esi
  00025	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00028	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4]
  0002f	74 06		 je	 SHORT $LN1@EAGetNextC

; 742  : 	int c, i = 0;
; 743  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++])

  00031	85 c0		 test	 eax, eax
  00033	75 eb		 jne	 SHORT $LL2@EAGetNextC
$LN8@EAGetNextC:

; 746  : 			return EncryptionAlgorithms[ea].Ciphers[i];
; 747  : 	}
; 748  : 
; 749  : 	return 0;

  00035	33 c0		 xor	 eax, eax
$LN1@EAGetNextC:
  00037	5e		 pop	 esi

; 750  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_EAGetNextCipher ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetLastCipher
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetLastCipher PROC					; COMDAT

; 722  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 723  : 	int c, i = 0;

  00004	8b 75 08	 mov	 esi, DWORD PTR _ea$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	8b c6		 mov	 eax, esi
  0000b	c1 e0 05	 shl	 eax, 5
  0000e	05 00 00 00 00	 add	 eax, OFFSET _EncryptionAlgorithms
$LL2@EAGetLastC:

; 724  : 	while (c = EncryptionAlgorithms[ea].Ciphers[i++]);

  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00018	8d 40 04	 lea	 eax, DWORD PTR [eax+4]
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 f4		 jne	 SHORT $LL2@EAGetLastC

; 725  : 
; 726  : 	return EncryptionAlgorithms[ea].Ciphers[i - 2];

  0001f	8d 04 f2	 lea	 eax, DWORD PTR [edx+esi*8]
  00022	8b 04 85 f8 ff
	ff ff		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4-8]
  00029	5e		 pop	 esi

; 727  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
_EAGetLastCipher ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetFirstCipher
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetFirstCipher PROC					; COMDAT

; 708  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 709  : 	return EncryptionAlgorithms[ea].Ciphers[0];

  00003	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00006	c1 e0 05	 shl	 eax, 5
  00009	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]

; 710  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_EAGetFirstCipher ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetCipherCount
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetCipherCount PROC					; COMDAT

; 691  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 692  : 	int i = 0;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _ea$[ebp]
  00006	56		 push	 esi
  00007	c1 e1 05	 shl	 ecx, 5
  0000a	33 f6		 xor	 esi, esi
  0000c	81 c1 00 00 00
	00		 add	 ecx, OFFSET _EncryptionAlgorithms
$LL2@EAGetCiphe:

; 693  : 	while (EncryptionAlgorithms[ea].Ciphers[i++]);

  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  00017	8b c6		 mov	 eax, esi
  00019	46		 inc	 esi
  0001a	85 d2		 test	 edx, edx
  0001c	75 f4		 jne	 SHORT $LL2@EAGetCiphe
  0001e	5e		 pop	 esi

; 694  : 
; 695  : 	return i - 1;
; 696  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_EAGetCipherCount ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetLargestKeyForMode
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_EAGetLargestKeyForMode PROC				; COMDAT

; 648  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 649  : 	int ea, key = 0;
; 650  : 
; 651  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _mode$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	be 01 00 00 00	 mov	 esi, 1
$LL10@EAGetLarge:

; 652  : 	{
; 653  : 		if (!EAIsModeSupported (ea, mode))

  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 _EAIsModeSupported
  00017	83 c4 08	 add	 esp, 8
  0001a	85 c0		 test	 eax, eax
  0001c	74 18		 je	 SHORT $LN2@EAGetLarge

; 654  : 			continue;
; 655  : 
; 656  : 		if (EAGetKeySize (ea) >= key)

  0001e	56		 push	 esi
  0001f	e8 00 00 00 00	 call	 _EAGetKeySize
  00024	83 c4 04	 add	 esp, 4
  00027	3b c7		 cmp	 eax, edi
  00029	7c 0b		 jl	 SHORT $LN2@EAGetLarge

; 657  : 			key = EAGetKeySize (ea);

  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 _EAGetKeySize
  00031	83 c4 04	 add	 esp, 4
  00034	8b f8		 mov	 edi, eax
$LN2@EAGetLarge:

; 649  : 	int ea, key = 0;
; 650  : 
; 651  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  00036	46		 inc	 esi
  00037	33 c0		 xor	 eax, eax
  00039	8b ce		 mov	 ecx, esi
  0003b	c1 e1 05	 shl	 ecx, 5
  0003e	39 81 00 00 00
	00		 cmp	 DWORD PTR _EncryptionAlgorithms[ecx], eax
  00044	0f 44 f0	 cmove	 esi, eax
  00047	85 f6		 test	 esi, esi
  00049	75 c5		 jne	 SHORT $LL10@EAGetLarge

; 658  : 	}
; 659  : 	return key;

  0004b	8b c7		 mov	 eax, edi
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx

; 660  : }

  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_EAGetLargestKeyForMode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetLargestKey
_TEXT	SEGMENT
_EAGetLargestKey PROC					; COMDAT

; 670  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 671  : 	int ea, key = 0;

  00002	33 ff		 xor	 edi, edi

; 672  : 
; 673  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  00004	be 01 00 00 00	 mov	 esi, 1
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@EAGetLarge:

; 674  : 	{
; 675  : 		if (EAGetKeySize (ea) >= key)

  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 _EAGetKeySize
  00016	83 c4 04	 add	 esp, 4
  00019	3b c7		 cmp	 eax, edi
  0001b	7c 0b		 jl	 SHORT $LN2@EAGetLarge

; 676  : 			key = EAGetKeySize (ea);

  0001d	56		 push	 esi
  0001e	e8 00 00 00 00	 call	 _EAGetKeySize
  00023	83 c4 04	 add	 esp, 4
  00026	8b f8		 mov	 edi, eax
$LN2@EAGetLarge:

; 672  : 
; 673  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  00028	46		 inc	 esi
  00029	33 c0		 xor	 eax, eax
  0002b	8b ce		 mov	 ecx, esi
  0002d	c1 e1 05	 shl	 ecx, 5
  00030	39 81 00 00 00
	00		 cmp	 DWORD PTR _EncryptionAlgorithms[ecx], eax
  00036	0f 44 f0	 cmove	 esi, eax
  00039	85 f6		 test	 esi, esi
  0003b	75 d3		 jne	 SHORT $LL9@EAGetLarge

; 677  : 	}
; 678  : 
; 679  : 	return key;

  0003d	8b c7		 mov	 eax, edi
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi

; 680  : }

  00041	c3		 ret	 0
_EAGetLargestKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetKeyScheduleSize
_TEXT	SEGMENT
tv242 = 8						; size = 4
_ea$ = 8						; size = 4
_EAGetKeyScheduleSize PROC				; COMDAT

; 627  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 628  : 	int i = EAGetFirstCipher(ea);
; 629  : 	int size = CipherGetKeyScheduleSize (i);

  00004	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _Ciphers
  0000a	33 c9		 xor	 ecx, ecx
  0000c	56		 push	 esi
  0000d	8b 75 08	 mov	 esi, DWORD PTR _ea$[ebp]
  00010	8b c6		 mov	 eax, esi
  00012	c1 e0 05	 shl	 eax, 5
  00015	57		 push	 edi
  00016	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]
  0001c	8b d0		 mov	 edx, eax
  0001e	89 45 08	 mov	 DWORD PTR tv242[ebp], eax
  00021	85 db		 test	 ebx, ebx
  00023	74 15		 je	 SHORT $LN11@EAGetKeySc
  00025	8b c3		 mov	 eax, ebx
$LL12@EAGetKeySc:
  00027	3b c2		 cmp	 eax, edx
  00029	74 41		 je	 SHORT $LN32@EAGetKeySc
  0002b	41		 inc	 ecx
  0002c	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0002f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4]
  00036	85 c0		 test	 eax, eax
  00038	75 ed		 jne	 SHORT $LL12@EAGetKeySc
$LN11@EAGetKeySc:
  0003a	33 c0		 xor	 eax, eax
$LN9@EAGetKeySc:
  0003c	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  0003f	90		 npad	 1
$LL2@EAGetKeySc:

; 630  : 
; 631  : 	while (i = EAGetNextCipher(ea, i))

  00040	8b 45 08	 mov	 eax, DWORD PTR tv242[ebp]
  00043	33 c9		 xor	 ecx, ecx
  00045	85 c0		 test	 eax, eax
  00047	74 1c		 je	 SHORT $LN48@EAGetKeySc
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL16@EAGetKeySc:
  00050	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00053	3b c2		 cmp	 eax, edx
  00055	8d 04 f1	 lea	 eax, DWORD PTR [ecx+esi*8]
  00058	74 1e		 je	 SHORT $LN33@EAGetKeySc
  0005a	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4]
  00061	85 c0		 test	 eax, eax
  00063	75 eb		 jne	 SHORT $LL16@EAGetKeySc
$LN48@EAGetKeySc:

; 635  : 
; 636  : 	return size;

  00065	8b c7		 mov	 eax, edi
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 637  : }

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
$LN32@EAGetKeySc:

; 628  : 	int i = EAGetFirstCipher(ea);
; 629  : 	int size = CipherGetKeyScheduleSize (i);

  0006c	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0006f	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  00076	eb c4		 jmp	 SHORT $LN9@EAGetKeySc
$LN33@EAGetKeySc:

; 630  : 
; 631  : 	while (i = EAGetNextCipher(ea, i))

  00078	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax*4]
  0007f	85 d2		 test	 edx, edx
  00081	74 e2		 je	 SHORT $LN48@EAGetKeySc

; 632  : 	{
; 633  : 		size += CipherGetKeyScheduleSize (i);

  00083	33 c0		 xor	 eax, eax
  00085	85 db		 test	 ebx, ebx
  00087	74 1a		 je	 SHORT $LN24@EAGetKeySc
  00089	8b cb		 mov	 ecx, ebx
  0008b	0f 1f 44 00 00	 npad	 5
$LL25@EAGetKeySc:
  00090	3b ca		 cmp	 ecx, edx
  00092	74 16		 je	 SHORT $LN34@EAGetKeySc
  00094	40		 inc	 eax
  00095	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00098	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _Ciphers[ecx*4]
  0009f	85 c9		 test	 ecx, ecx
  000a1	75 ed		 jne	 SHORT $LL25@EAGetKeySc
$LN24@EAGetKeySc:
  000a3	33 c0		 xor	 eax, eax
  000a5	03 78 10	 add	 edi, DWORD PTR [eax+16]

; 634  : 	}

  000a8	eb 96		 jmp	 SHORT $LL2@EAGetKeySc
$LN34@EAGetKeySc:

; 632  : 	{
; 633  : 		size += CipherGetKeyScheduleSize (i);

  000aa	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  000ad	03 3c 85 10 00
	00 00		 add	 edi, DWORD PTR _Ciphers[eax*4+16]
  000b4	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]

; 634  : 	}

  000bb	eb 83		 jmp	 SHORT $LL2@EAGetKeySc
_EAGetKeyScheduleSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetModeName
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_mode$ = 12						; size = 4
_capitalLetters$ = 16					; size = 4
_EAGetModeName PROC					; COMDAT

; 605  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 606  : 	switch (mode)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00006	83 e8 01	 sub	 eax, 1
  00009	74 13		 je	 SHORT $LN4@EAGetModeN
  0000b	83 e8 01	 sub	 eax, 1
  0000e	74 07		 je	 SHORT $LN5@EAGetModeN

; 612  : 	}
; 613  : 	return "[unknown]";

  00010	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09DJENBFJK@?$FLunknown?$FN?$AA@

; 614  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
$LN5@EAGetModeN:

; 610  : 	case XTS8:
; 611  : 		return "XTS 64-bit version";

  00017	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BD@GMAMAMGI@XTS?564?9bit?5version?$AA@

; 614  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
$LN4@EAGetModeN:

; 607  : 	{
; 608  : 	case XTS:
; 609  : 		return "XTS";

  0001e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03CKCBIPFF@XTS?$AA@

; 614  : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_EAGetModeName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetNextMode
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_previousModeId$ = 12					; size = 4
_EAGetNextMode PROC					; COMDAT

; 578  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 579  : 	int c, i = 0;
; 580  : 	while (c = EncryptionAlgorithms[ea].Modes[i++])

  00003	8b 55 08	 mov	 edx, DWORD PTR _ea$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	8b c2		 mov	 eax, edx
  0000a	c1 e0 05	 shl	 eax, 5
  0000d	56		 push	 esi
  0000e	8b 80 10 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+16]
  00014	85 c0		 test	 eax, eax
  00016	74 1d		 je	 SHORT $LN8@EAGetNextM
  00018	8b 75 0c	 mov	 esi, DWORD PTR _previousModeId$[ebp]
  0001b	0f 1f 44 00 00	 npad	 5
$LL2@EAGetNextM:
  00020	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 581  : 	{
; 582  : 		if (c == previousModeId) 

  00023	3b c6		 cmp	 eax, esi
  00025	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00028	8b 04 85 10 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4+16]
  0002f	74 06		 je	 SHORT $LN1@EAGetNextM

; 579  : 	int c, i = 0;
; 580  : 	while (c = EncryptionAlgorithms[ea].Modes[i++])

  00031	85 c0		 test	 eax, eax
  00033	75 eb		 jne	 SHORT $LL2@EAGetNextM
$LN8@EAGetNextM:

; 583  : 			return EncryptionAlgorithms[ea].Modes[i];
; 584  : 	}
; 585  : 
; 586  : 	return 0;

  00035	33 c0		 xor	 eax, eax
$LN1@EAGetNextM:
  00037	5e		 pop	 esi

; 587  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_EAGetNextMode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetFirstMode
_TEXT	SEGMENT
_ea$ = 8						; size = 4
_EAGetFirstMode PROC					; COMDAT

; 562  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 563  : 	return (EncryptionAlgorithms[ea].Modes[0]);

  00003	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00006	c1 e0 05	 shl	 eax, 5
  00009	8b 80 10 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax+16]

; 564  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_EAGetFirstMode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetKeySize
_TEXT	SEGMENT
tv242 = 8						; size = 4
_ea$ = 8						; size = 4
_EAGetKeySize PROC					; COMDAT

; 540  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 541  : 	int i = EAGetFirstCipher (ea);
; 542  : 	int size = CipherGetKeySize (i);

  00004	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _Ciphers
  0000a	33 c9		 xor	 ecx, ecx
  0000c	56		 push	 esi
  0000d	8b 75 08	 mov	 esi, DWORD PTR _ea$[ebp]
  00010	8b c6		 mov	 eax, esi
  00012	c1 e0 05	 shl	 eax, 5
  00015	57		 push	 edi
  00016	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]
  0001c	8b d0		 mov	 edx, eax
  0001e	89 45 08	 mov	 DWORD PTR tv242[ebp], eax
  00021	85 db		 test	 ebx, ebx
  00023	74 15		 je	 SHORT $LN11@EAGetKeySi
  00025	8b c3		 mov	 eax, ebx
$LL12@EAGetKeySi:
  00027	3b c2		 cmp	 eax, edx
  00029	74 41		 je	 SHORT $LN32@EAGetKeySi
  0002b	41		 inc	 ecx
  0002c	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0002f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4]
  00036	85 c0		 test	 eax, eax
  00038	75 ed		 jne	 SHORT $LL12@EAGetKeySi
$LN11@EAGetKeySi:
  0003a	33 c0		 xor	 eax, eax
$LN9@EAGetKeySi:
  0003c	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  0003f	90		 npad	 1
$LL2@EAGetKeySi:

; 543  : 
; 544  : 	while (i = EAGetNextCipher (ea, i))

  00040	8b 45 08	 mov	 eax, DWORD PTR tv242[ebp]
  00043	33 c9		 xor	 ecx, ecx
  00045	85 c0		 test	 eax, eax
  00047	74 1c		 je	 SHORT $LN48@EAGetKeySi
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL16@EAGetKeySi:
  00050	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00053	3b c2		 cmp	 eax, edx
  00055	8d 04 f1	 lea	 eax, DWORD PTR [ecx+esi*8]
  00058	74 1e		 je	 SHORT $LN33@EAGetKeySi
  0005a	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4]
  00061	85 c0		 test	 eax, eax
  00063	75 eb		 jne	 SHORT $LL16@EAGetKeySi
$LN48@EAGetKeySi:

; 548  : 
; 549  : 	return size;

  00065	8b c7		 mov	 eax, edi
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 550  : }

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
$LN32@EAGetKeySi:

; 541  : 	int i = EAGetFirstCipher (ea);
; 542  : 	int size = CipherGetKeySize (i);

  0006c	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0006f	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  00076	eb c4		 jmp	 SHORT $LN9@EAGetKeySi
$LN33@EAGetKeySi:

; 543  : 
; 544  : 	while (i = EAGetNextCipher (ea, i))

  00078	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR _EncryptionAlgorithms[eax*4]
  0007f	85 d2		 test	 edx, edx
  00081	74 e2		 je	 SHORT $LN48@EAGetKeySi

; 545  : 	{
; 546  : 		size += CipherGetKeySize (i);

  00083	33 c0		 xor	 eax, eax
  00085	85 db		 test	 ebx, ebx
  00087	74 1a		 je	 SHORT $LN24@EAGetKeySi
  00089	8b cb		 mov	 ecx, ebx
  0008b	0f 1f 44 00 00	 npad	 5
$LL25@EAGetKeySi:
  00090	3b ca		 cmp	 ecx, edx
  00092	74 16		 je	 SHORT $LN34@EAGetKeySi
  00094	40		 inc	 eax
  00095	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00098	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _Ciphers[ecx*4]
  0009f	85 c9		 test	 ecx, ecx
  000a1	75 ed		 jne	 SHORT $LL25@EAGetKeySi
$LN24@EAGetKeySi:
  000a3	33 c0		 xor	 eax, eax
  000a5	03 78 0c	 add	 edi, DWORD PTR [eax+12]

; 547  : 	}

  000a8	eb 96		 jmp	 SHORT $LL2@EAGetKeySi
$LN34@EAGetKeySi:

; 545  : 	{
; 546  : 		size += CipherGetKeySize (i);

  000aa	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  000ad	03 3c 85 0c 00
	00 00		 add	 edi, DWORD PTR _Ciphers[eax*4+12]
  000b4	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]

; 547  : 	}

  000bb	eb 83		 jmp	 SHORT $LL2@EAGetKeySi
_EAGetKeySize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetByName
_TEXT	SEGMENT
_n$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_EAGetByName PROC					; COMDAT

; 513  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi

; 514  : 	int ea = EAGetFirst ();

  00015	be 01 00 00 00	 mov	 esi, 1

; 515  : 	char n[128];
; 516  : 
; 517  : 	do
; 518  : 	{
; 519  : 		EAGetName (n, ea);

  0001a	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _n$[ebp]
  00020	56		 push	 esi
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _EAGetName

; 520  : 		if (strcmp (n, name) == 0)

  00027	8b 7d 08	 mov	 edi, DWORD PTR _name$[ebp]
  0002a	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _n$[ebp]
  00030	83 c4 08	 add	 esp, 8
  00033	8b cf		 mov	 ecx, edi
$LL18@EAGetByNam:
  00035	8a 10		 mov	 dl, BYTE PTR [eax]
  00037	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00039	75 1a		 jne	 SHORT $LN19@EAGetByNam
  0003b	84 d2		 test	 dl, dl
  0003d	74 12		 je	 SHORT $LN20@EAGetByNam
  0003f	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00042	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00045	75 0e		 jne	 SHORT $LN19@EAGetByNam
  00047	83 c0 02	 add	 eax, 2
  0004a	83 c1 02	 add	 ecx, 2
  0004d	84 d2		 test	 dl, dl
  0004f	75 e4		 jne	 SHORT $LL18@EAGetByNam
$LN20@EAGetByNam:
  00051	33 c0		 xor	 eax, eax
  00053	eb 05		 jmp	 SHORT $LN21@EAGetByNam
$LN19@EAGetByNam:
  00055	1b c0		 sbb	 eax, eax
  00057	83 c8 01	 or	 eax, 1
$LN21@EAGetByNam:
  0005a	85 c0		 test	 eax, eax
  0005c	74 5b		 je	 SHORT $LN13@EAGetByNam
  0005e	66 90		 npad	 2
$LL4@EAGetByNam:

; 522  : 	}
; 523  : 	while (ea = EAGetNext (ea));

  00060	46		 inc	 esi
  00061	33 c9		 xor	 ecx, ecx
  00063	8b c6		 mov	 eax, esi
  00065	c1 e0 05	 shl	 eax, 5
  00068	39 88 00 00 00
	00		 cmp	 DWORD PTR _EncryptionAlgorithms[eax], ecx
  0006e	0f 44 f1	 cmove	 esi, ecx
  00071	85 f6		 test	 esi, esi
  00073	74 56		 je	 SHORT $LN14@EAGetByNam

; 515  : 	char n[128];
; 516  : 
; 517  : 	do
; 518  : 	{
; 519  : 		EAGetName (n, ea);

  00075	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _n$[ebp]
  0007b	56		 push	 esi
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _EAGetName
  00082	83 c4 08	 add	 esp, 8

; 520  : 		if (strcmp (n, name) == 0)

  00085	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _n$[ebp]
  0008b	8b c7		 mov	 eax, edi
  0008d	0f 1f 00	 npad	 3
$LL22@EAGetByNam:
  00090	8a 11		 mov	 dl, BYTE PTR [ecx]
  00092	3a 10		 cmp	 dl, BYTE PTR [eax]
  00094	75 1a		 jne	 SHORT $LN23@EAGetByNam
  00096	84 d2		 test	 dl, dl
  00098	74 12		 je	 SHORT $LN24@EAGetByNam
  0009a	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0009d	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  000a0	75 0e		 jne	 SHORT $LN23@EAGetByNam
  000a2	83 c1 02	 add	 ecx, 2
  000a5	83 c0 02	 add	 eax, 2
  000a8	84 d2		 test	 dl, dl
  000aa	75 e4		 jne	 SHORT $LL22@EAGetByNam
$LN24@EAGetByNam:
  000ac	33 c0		 xor	 eax, eax
  000ae	eb 05		 jmp	 SHORT $LN25@EAGetByNam
$LN23@EAGetByNam:
  000b0	1b c0		 sbb	 eax, eax
  000b2	83 c8 01	 or	 eax, 1
$LN25@EAGetByNam:
  000b5	85 c0		 test	 eax, eax
  000b7	75 a7		 jne	 SHORT $LL4@EAGetByNam
$LN13@EAGetByNam:
  000b9	5f		 pop	 edi

; 521  : 			return ea;

  000ba	8b c6		 mov	 eax, esi
  000bc	5e		 pop	 esi

; 524  : 
; 525  : 	return 0;
; 526  : }

  000bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c0	33 cd		 xor	 ecx, ebp
  000c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
$LN14@EAGetByNam:
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ce	33 c0		 xor	 eax, eax
  000d0	5f		 pop	 edi
  000d1	33 cd		 xor	 ecx, ebp
  000d3	5e		 pop	 esi
  000d4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
_EAGetByName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetName
_TEXT	SEGMENT
tv424 = -4						; size = 4
_buf$ = 8						; size = 4
tv428 = 12						; size = 4
_ea$ = 12						; size = 4
_EAGetName PROC						; COMDAT

; 489  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 490  : 	int i = EAGetLastCipher(ea);

  00006	8b 75 0c	 mov	 esi, DWORD PTR _ea$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	57		 push	 edi
  0000c	8b fe		 mov	 edi, esi
  0000e	c1 e7 05	 shl	 edi, 5
  00011	89 7d fc	 mov	 DWORD PTR tv424[ebp], edi
  00014	8d 8f 00 00 00
	00		 lea	 ecx, DWORD PTR _EncryptionAlgorithms[edi]
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL10@EAGetName:
  00020	8b 01		 mov	 eax, DWORD PTR [ecx]
  00022	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  00025	42		 inc	 edx
  00026	85 c0		 test	 eax, eax
  00028	75 f6		 jne	 SHORT $LL10@EAGetName
  0002a	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  00031	89 45 0c	 mov	 DWORD PTR tv428[ebp], eax
  00034	03 c2		 add	 eax, edx
  00036	8b 1c 85 f8 ff
	ff ff		 mov	 ebx, DWORD PTR _EncryptionAlgorithms[eax*4-8]

; 491  : 	strcpy (buf, (i != 0) ? CipherGetName (i) : "?");

  0003d	85 db		 test	 ebx, ebx
  0003f	74 38		 je	 SHORT $LN5@EAGetName
  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR _Ciphers
  00046	33 c9		 xor	 ecx, ecx
  00048	85 c0		 test	 eax, eax
  0004a	74 17		 je	 SHORT $LN17@EAGetName
  0004c	0f 1f 40 00	 npad	 4
$LL18@EAGetName:
  00050	3b c3		 cmp	 eax, ebx
  00052	74 16		 je	 SHORT $LN41@EAGetName
  00054	41		 inc	 ecx
  00055	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00058	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4]
  0005f	85 c0		 test	 eax, eax
  00061	75 ed		 jne	 SHORT $LL18@EAGetName
$LN17@EAGetName:
  00063	33 c9		 xor	 ecx, ecx
  00065	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00068	eb 14		 jmp	 SHORT $LN6@EAGetName
$LN41@EAGetName:
  0006a	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0006d	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR _Ciphers[eax*4]
  00074	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00077	eb 05		 jmp	 SHORT $LN6@EAGetName
$LN5@EAGetName:
  00079	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01OGPIMHDM@?$DP?$AA@
$LN6@EAGetName:
  0007e	8b 75 08	 mov	 esi, DWORD PTR _buf$[ebp]
  00081	8b d6		 mov	 edx, esi
$LL7@EAGetName:
  00083	8a 01		 mov	 al, BYTE PTR [ecx]
  00085	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00088	88 02		 mov	 BYTE PTR [edx], al
  0008a	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0008d	84 c0		 test	 al, al
  0008f	75 f2		 jne	 SHORT $LL7@EAGetName
$LL2@EAGetName:

; 492  : 
; 493  : 	while (i = EAGetPreviousCipher(ea, i))

  00091	ba 01 00 00 00	 mov	 edx, 1
  00096	39 9f 00 00 00
	00		 cmp	 DWORD PTR _EncryptionAlgorithms[edi], ebx
  0009c	74 20		 je	 SHORT $LN91@EAGetName
  0009e	8b 87 04 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[edi+4]
  000a4	85 c0		 test	 eax, eax
  000a6	74 16		 je	 SHORT $LN91@EAGetName
  000a8	8d 8f 04 00 00
	00		 lea	 ecx, DWORD PTR _EncryptionAlgorithms[edi+4]
  000ae	66 90		 npad	 2
$LL22@EAGetName:
  000b0	42		 inc	 edx
  000b1	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  000b4	3b c3		 cmp	 eax, ebx
  000b6	74 0f		 je	 SHORT $LN42@EAGetName
  000b8	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ba	85 c0		 test	 eax, eax
  000bc	75 f2		 jne	 SHORT $LL22@EAGetName
$LN91@EAGetName:
  000be	5f		 pop	 edi

; 498  : 
; 499  : 	return buf;

  000bf	8b c6		 mov	 eax, esi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx

; 500  : }

  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
$LN42@EAGetName:

; 492  : 
; 493  : 	while (i = EAGetPreviousCipher(ea, i))

  000c7	8b 45 0c	 mov	 eax, DWORD PTR tv428[ebp]
  000ca	03 c2		 add	 eax, edx
  000cc	8b 1c 85 f8 ff
	ff ff		 mov	 ebx, DWORD PTR _EncryptionAlgorithms[eax*4-8]
  000d3	85 db		 test	 ebx, ebx
  000d5	74 e7		 je	 SHORT $LN91@EAGetName

; 494  : 	{
; 495  : 		strcat (buf, "-");

  000d7	8d 7e ff	 lea	 edi, DWORD PTR [esi-1]
  000da	66 0f 1f 44 00
	00		 npad	 6
$LL76@EAGetName:
  000e0	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  000e3	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  000e6	84 c0		 test	 al, al
  000e8	75 f6		 jne	 SHORT $LL76@EAGetName
  000ea	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01JOAMLHOP@?9?$AA@
  000f0	66 89 07	 mov	 WORD PTR [edi], ax

; 496  : 		strcat (buf, CipherGetName (i));

  000f3	33 c0		 xor	 eax, eax
  000f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Ciphers
  000fb	85 c9		 test	 ecx, ecx
  000fd	74 14		 je	 SHORT $LN31@EAGetName
  000ff	90		 npad	 1
$LL32@EAGetName:
  00100	3b cb		 cmp	 ecx, ebx
  00102	74 4d		 je	 SHORT $LN43@EAGetName
  00104	40		 inc	 eax
  00105	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00108	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _Ciphers[ecx*4]
  0010f	85 c9		 test	 ecx, ecx
  00111	75 ed		 jne	 SHORT $LL32@EAGetName
$LN31@EAGetName:
  00113	33 d2		 xor	 edx, edx
$LN29@EAGetName:
  00115	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00118	8b f2		 mov	 esi, edx
  0011a	66 0f 1f 44 00
	00		 npad	 6
$LL77@EAGetName:
  00120	8a 02		 mov	 al, BYTE PTR [edx]
  00122	42		 inc	 edx
  00123	84 c0		 test	 al, al
  00125	75 f9		 jne	 SHORT $LL77@EAGetName
  00127	8b 7d 08	 mov	 edi, DWORD PTR _buf$[ebp]
  0012a	2b d6		 sub	 edx, esi
  0012c	4f		 dec	 edi
  0012d	0f 1f 00	 npad	 3
$LL78@EAGetName:
  00130	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00133	47		 inc	 edi
  00134	84 c0		 test	 al, al
  00136	75 f8		 jne	 SHORT $LL78@EAGetName
  00138	8b ca		 mov	 ecx, edx
  0013a	c1 e9 02	 shr	 ecx, 2
  0013d	f3 a5		 rep movsd
  0013f	8b ca		 mov	 ecx, edx
  00141	83 e1 03	 and	 ecx, 3
  00144	f3 a4		 rep movsb

; 497  : 	}

  00146	8b 75 08	 mov	 esi, DWORD PTR _buf$[ebp]
  00149	8b 7d fc	 mov	 edi, DWORD PTR tv424[ebp]
  0014c	e9 40 ff ff ff	 jmp	 $LL2@EAGetName
$LN43@EAGetName:

; 496  : 		strcat (buf, CipherGetName (i));

  00151	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00154	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR _Ciphers[eax*4]
  0015b	eb b8		 jmp	 SHORT $LN29@EAGetName
_EAGetName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetNext
_TEXT	SEGMENT
_previousEA$ = 8					; size = 4
_EAGetNext PROC						; COMDAT

; 394  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 395  : 	int id = previousEA + 1;

  00003	8b 55 08	 mov	 edx, DWORD PTR _previousEA$[ebp]

; 396  : 	if (EncryptionAlgorithms[id].Ciphers[0] != 0) return id;

  00006	33 c0		 xor	 eax, eax
  00008	42		 inc	 edx
  00009	8b ca		 mov	 ecx, edx
  0000b	c1 e1 05	 shl	 ecx, 5
  0000e	39 81 00 00 00
	00		 cmp	 DWORD PTR _EncryptionAlgorithms[ecx], eax
  00014	0f 45 c2	 cmovne	 eax, edx

; 397  : 	return 0;
; 398  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
_EAGetNext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetCount
_TEXT	SEGMENT
_EAGetCount PROC					; COMDAT

; 375  : 	int ea, count = 0;

  00000	33 c0		 xor	 eax, eax

; 376  : 
; 377  : 	for (ea = EAGetFirst (); ea != 0; ea = EAGetNext (ea))

  00002	b9 01 00 00 00	 mov	 ecx, 1
  00007	56		 push	 esi
$LL8@EAGetCount:
  00008	41		 inc	 ecx
  00009	33 f6		 xor	 esi, esi
  0000b	8b d1		 mov	 edx, ecx

; 378  : 	{
; 379  : 		count++;

  0000d	40		 inc	 eax
  0000e	c1 e2 05	 shl	 edx, 5
  00011	39 b2 00 00 00
	00		 cmp	 DWORD PTR _EncryptionAlgorithms[edx], esi
  00017	0f 44 ce	 cmove	 ecx, esi
  0001a	85 c9		 test	 ecx, ecx
  0001c	75 ea		 jne	 SHORT $LL8@EAGetCount
  0001e	5e		 pop	 esi

; 380  : 	}
; 381  : 	return count;
; 382  : }

  0001f	c3		 ret	 0
_EAGetCount ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAGetFirst
_TEXT	SEGMENT
_EAGetFirst PROC					; COMDAT

; 362  : 	return 1;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 363  : }

  00005	c3		 ret	 0
_EAGetFirst ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _DecipherBlocks
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_blockSize$1$ = 12					; size = 4
_dataPtr$ = 12						; size = 4
_ks$ = 16						; size = 4
_blockCount$ = 20					; size = 4
_DecipherBlocks PROC					; COMDAT

; 217  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 218  : 	byte *data = dataPtr;
; 219  : 	size_t blockSize = CipherGetBlockSize (cipher);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _Ciphers
  00008	33 c9		 xor	 ecx, ecx
  0000a	8b 55 08	 mov	 edx, DWORD PTR _cipher$[ebp]
  0000d	56		 push	 esi
  0000e	8b 75 0c	 mov	 esi, DWORD PTR _dataPtr$[ebp]
  00011	57		 push	 edi
  00012	85 c0		 test	 eax, eax
  00014	74 13		 je	 SHORT $LN9@DecipherBl
$LL10@DecipherBl:
  00016	3b c2		 cmp	 eax, edx
  00018	74 3c		 je	 SHORT $LN22@DecipherBl
  0001a	41		 inc	 ecx
  0001b	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0001e	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4]
  00025	85 c0		 test	 eax, eax
  00027	75 ed		 jne	 SHORT $LL10@DecipherBl
$LN9@DecipherBl:
  00029	33 c0		 xor	 eax, eax
$LN7@DecipherBl:

; 220  : 	while (blockCount-- > 0)

  0002b	8b 7d 14	 mov	 edi, DWORD PTR _blockCount$[ebp]
  0002e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00031	89 45 0c	 mov	 DWORD PTR _blockSize$1$[ebp], eax
  00034	85 ff		 test	 edi, edi
  00036	74 4a		 je	 SHORT $LN24@DecipherBl
  00038	53		 push	 ebx
  00039	8b 5d 10	 mov	 ebx, DWORD PTR _ks$[ebp]
  0003c	0f 1f 40 00	 npad	 4
$LL2@DecipherBl:

; 221  : 	{
; 222  : 		DecipherBlock (cipher, data, ks);

  00040	8b c2		 mov	 eax, edx
  00042	4f		 dec	 edi
  00043	83 e8 01	 sub	 eax, 1
  00046	74 24		 je	 SHORT $LN16@DecipherBl
  00048	83 e8 01	 sub	 eax, 1
  0004b	74 15		 je	 SHORT $LN17@DecipherBl
  0004d	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  00054	eb 24		 jmp	 SHORT $LN14@DecipherBl
$LN22@DecipherBl:

; 218  : 	byte *data = dataPtr;
; 219  : 	size_t blockSize = CipherGetBlockSize (cipher);

  00056	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00059	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  00060	eb c9		 jmp	 SHORT $LN7@DecipherBl

; 221  : 	{
; 222  : 		DecipherBlock (cipher, data, ks);

$LN17@DecipherBl:
  00062	56		 push	 esi
  00063	56		 push	 esi
  00064	53		 push	 ebx
  00065	e8 00 00 00 00	 call	 _grasshopper_decrypt
  0006a	eb 08		 jmp	 SHORT $LN30@DecipherBl
$LN16@DecipherBl:
  0006c	53		 push	 ebx
  0006d	56		 push	 esi
  0006e	56		 push	 esi
  0006f	e8 00 00 00 00	 call	 _gost_decrypt
$LN30@DecipherBl:
  00074	8b 55 08	 mov	 edx, DWORD PTR _cipher$[ebp]
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@DecipherBl:

; 223  : 		data += blockSize;

  0007a	03 75 0c	 add	 esi, DWORD PTR _blockSize$1$[ebp]
  0007d	85 ff		 test	 edi, edi
  0007f	75 bf		 jne	 SHORT $LL2@DecipherBl
  00081	5b		 pop	 ebx
$LN24@DecipherBl:
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi

; 224  : 	}
; 225  : }

  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_DecipherBlocks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EncipherBlocks
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_blockSize$1$ = 12					; size = 4
_dataPtr$ = 12						; size = 4
_ks$ = 16						; size = 4
_blockCount$ = 20					; size = 4
_EncipherBlocks PROC					; COMDAT

; 167  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 168  : 	byte *data = dataPtr;
; 169  : 	size_t blockSize = CipherGetBlockSize (cipher);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _Ciphers
  00008	33 c9		 xor	 ecx, ecx
  0000a	8b 55 08	 mov	 edx, DWORD PTR _cipher$[ebp]
  0000d	56		 push	 esi
  0000e	8b 75 0c	 mov	 esi, DWORD PTR _dataPtr$[ebp]
  00011	57		 push	 edi
  00012	85 c0		 test	 eax, eax
  00014	74 13		 je	 SHORT $LN9@EncipherBl
$LL10@EncipherBl:
  00016	3b c2		 cmp	 eax, edx
  00018	74 3c		 je	 SHORT $LN22@EncipherBl
  0001a	41		 inc	 ecx
  0001b	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0001e	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4]
  00025	85 c0		 test	 eax, eax
  00027	75 ed		 jne	 SHORT $LL10@EncipherBl
$LN9@EncipherBl:
  00029	33 c0		 xor	 eax, eax
$LN7@EncipherBl:

; 170  : 	while (blockCount-- > 0)

  0002b	8b 7d 14	 mov	 edi, DWORD PTR _blockCount$[ebp]
  0002e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00031	89 45 0c	 mov	 DWORD PTR _blockSize$1$[ebp], eax
  00034	85 ff		 test	 edi, edi
  00036	74 4a		 je	 SHORT $LN24@EncipherBl
  00038	53		 push	 ebx
  00039	8b 5d 10	 mov	 ebx, DWORD PTR _ks$[ebp]
  0003c	0f 1f 40 00	 npad	 4
$LL2@EncipherBl:

; 171  : 	{
; 172  : 		EncipherBlock (cipher, data, ks);

  00040	8b c2		 mov	 eax, edx
  00042	4f		 dec	 edi
  00043	83 e8 01	 sub	 eax, 1
  00046	74 24		 je	 SHORT $LN16@EncipherBl
  00048	83 e8 01	 sub	 eax, 1
  0004b	74 15		 je	 SHORT $LN17@EncipherBl
  0004d	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  00054	eb 24		 jmp	 SHORT $LN14@EncipherBl
$LN22@EncipherBl:

; 168  : 	byte *data = dataPtr;
; 169  : 	size_t blockSize = CipherGetBlockSize (cipher);

  00056	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00059	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  00060	eb c9		 jmp	 SHORT $LN7@EncipherBl

; 171  : 	{
; 172  : 		EncipherBlock (cipher, data, ks);

$LN17@EncipherBl:
  00062	56		 push	 esi
  00063	56		 push	 esi
  00064	53		 push	 ebx
  00065	e8 00 00 00 00	 call	 _grasshopper_encrypt
  0006a	eb 08		 jmp	 SHORT $LN30@EncipherBl
$LN16@EncipherBl:
  0006c	53		 push	 ebx
  0006d	56		 push	 esi
  0006e	56		 push	 esi
  0006f	e8 00 00 00 00	 call	 _gost_encrypt
$LN30@EncipherBl:
  00074	8b 55 08	 mov	 edx, DWORD PTR _cipher$[ebp]
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@EncipherBl:

; 173  : 		data += blockSize;

  0007a	03 75 0c	 add	 esi, DWORD PTR _blockSize$1$[ebp]
  0007d	85 ff		 test	 edi, edi
  0007f	75 bf		 jne	 SHORT $LL2@EncipherBl
  00081	5b		 pop	 ebx
$LN24@EncipherBl:
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi

; 174  : 	}
; 175  : }

  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_EncipherBlocks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _DecipherBlock
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_data$ = 12						; size = 4
_ks$ = 16						; size = 4
_DecipherBlock PROC					; COMDAT

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 191  : 	switch (cipher)

  00003	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00006	83 e8 01	 sub	 eax, 1
  00009	74 20		 je	 SHORT $LN4@DecipherBl
  0000b	83 e8 01	 sub	 eax, 1
  0000e	74 09		 je	 SHORT $LN5@DecipherBl

; 198  : 		break;
; 199  : 	default:		GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0

; 200  : 	}
; 201  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
$LN5@DecipherBl:

; 195  : 		break;
; 196  : 	case GRASSHOPPER:
; 197  : 		grasshopper_decrypt(ks, (unsigned long*)data, (unsigned long*)data);

  00019	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0001c	50		 push	 eax
  0001d	50		 push	 eax
  0001e	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00021	e8 00 00 00 00	 call	 _grasshopper_decrypt
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 200  : 	}
; 201  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN4@DecipherBl:

; 192  : 	{
; 193  : 	case GOST:
; 194  : 		gost_decrypt((byte *)data, (byte *)data, ks);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0002e	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax
  00031	89 45 08	 mov	 DWORD PTR _cipher$[ebp], eax

; 200  : 	}
; 201  : }

  00034	5d		 pop	 ebp

; 192  : 	{
; 193  : 	case GOST:
; 194  : 		gost_decrypt((byte *)data, (byte *)data, ks);

  00035	e9 00 00 00 00	 jmp	 _gost_decrypt
_DecipherBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EncipherBlock
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_data$ = 12						; size = 4
_ks$ = 16						; size = 4
_EncipherBlock PROC					; COMDAT

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 141  : 	switch (cipher)

  00003	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00006	83 e8 01	 sub	 eax, 1
  00009	74 20		 je	 SHORT $LN4@EncipherBl
  0000b	83 e8 01	 sub	 eax, 1
  0000e	74 09		 je	 SHORT $LN5@EncipherBl

; 148  : 		break;
; 149  : 	default:			GST_THROW_FATAL_EXCEPTION;	// Unknown/wrong ID

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0

; 150  : 	}
; 151  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
$LN5@EncipherBl:

; 145  : 		break;
; 146  : 	case GRASSHOPPER:
; 147  : 		grasshopper_encrypt(ks, (unsigned long *)data, (unsigned long *)data);

  00019	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0001c	50		 push	 eax
  0001d	50		 push	 eax
  0001e	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00021	e8 00 00 00 00	 call	 _grasshopper_encrypt
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 150  : 	}
; 151  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN4@EncipherBl:

; 142  : 	{
; 143  : 	case GOST:
; 144  : 		gost_encrypt((byte *)data, (byte *)data, ks);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]
  0002e	89 45 0c	 mov	 DWORD PTR _data$[ebp], eax
  00031	89 45 08	 mov	 DWORD PTR _cipher$[ebp], eax

; 150  : 	}
; 151  : }

  00034	5d		 pop	 ebp

; 142  : 	{
; 143  : 	case GOST:
; 144  : 		gost_encrypt((byte *)data, (byte *)data, ks);

  00035	e9 00 00 00 00	 jmp	 _gost_encrypt
_EncipherBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _XorKeySchedule
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_ks$ = 12						; size = 4
_out_ks$ = 16						; size = 4
_data$ = 20						; size = 4
_len$ = 24						; size = 4
_XorKeySchedule PROC					; COMDAT

; 337  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 338  : 	switch (cipher)

  00003	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00006	83 e8 01	 sub	 eax, 1
  00009	74 28		 je	 SHORT $LN4@XorKeySche
  0000b	83 e8 01	 sub	 eax, 1
  0000e	74 09		 je	 SHORT $LN5@XorKeySche

; 345  : 		break;
; 346  : 	default:
; 347  : 		GST_THROW_FATAL_EXCEPTION;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0

; 348  : 	}
; 349  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
$LN5@XorKeySche:

; 342  : 		break;
; 343  : 	case GRASSHOPPER:
; 344  : 		grasshopper_xor_ks(ks, out_ks, data, len / sizeof(__int32));

  00019	8b 45 18	 mov	 eax, DWORD PTR _len$[ebp]
  0001c	c1 e8 02	 shr	 eax, 2
  0001f	50		 push	 eax
  00020	ff 75 14	 push	 DWORD PTR _data$[ebp]
  00023	ff 75 10	 push	 DWORD PTR _out_ks$[ebp]
  00026	ff 75 0c	 push	 DWORD PTR _ks$[ebp]
  00029	e8 00 00 00 00	 call	 _grasshopper_xor_ks
  0002e	83 c4 10	 add	 esp, 16			; 00000010H

; 348  : 	}
; 349  : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
$LN4@XorKeySche:

; 339  : 	{
; 340  : 	case GOST:
; 341  : 		gost_xor_ks(ks, out_ks, data, len / sizeof(__int32));

  00033	8b 45 18	 mov	 eax, DWORD PTR _len$[ebp]
  00036	c1 e8 02	 shr	 eax, 2
  00039	50		 push	 eax
  0003a	ff 75 14	 push	 DWORD PTR _data$[ebp]
  0003d	ff 75 10	 push	 DWORD PTR _out_ks$[ebp]
  00040	ff 75 0c	 push	 DWORD PTR _ks$[ebp]
  00043	e8 00 00 00 00	 call	 _gost_xor_ks
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 348  : 	}
; 349  : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_XorKeySchedule ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAInitMode
_TEXT	SEGMENT
_ci$ = 8						; size = 4
_EAInitMode PROC					; COMDAT

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 453  : 	switch (ci->mode)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _ci$[ebp]
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	83 e8 01	 sub	 eax, 1
  0000c	74 13		 je	 SHORT $LN4@EAInitMode
  0000e	83 e8 01	 sub	 eax, 1
  00011	74 0e		 je	 SHORT $LN4@EAInitMode

; 459  : 
; 460  : 		/* Note: XTS mode could potentially be initialized with a weak key causing all blocks in one data unit
; 461  : 		on the volume to be tweaked with zero tweaks (i.e. 512 bytes of the volume would be encrypted in ECB
; 462  : 		mode). However, to create a GostCrypt volume with such a weak key, each human being on Earth would have
; 463  : 		to create approximately 11,378,125,361,078,862 (about eleven quadrillion) GostCrypt volumes (provided 
; 464  : 		that the size of each of the volumes is 1024 terabytes). */
; 465  : 		break;
; 466  : 	case XTS8:
; 467  : 		if (EAInit(ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)
; 468  : 			return FALSE;
; 469  : 		break;
; 470  : 
; 471  : 	default:		
; 472  : 		// Unknown/wrong ID
; 473  : 		GST_THROW_FATAL_EXCEPTION;

  00013	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN5@EAInitMode:

; 474  : 	}
; 475  : 	return TRUE;

  0001a	b8 01 00 00 00	 mov	 eax, 1

; 476  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN4@EAInitMode:

; 454  : 	{
; 455  : 	case XTS:
; 456  : 		// Secondary key schedule
; 457  : 		if (EAInit (ci->ea, ci->k2, ci->ks2) != ERR_SUCCESS)

  00021	8d 81 28 02 00
	00		 lea	 eax, DWORD PTR [ecx+552]
  00027	50		 push	 eax
  00028	8d 81 50 1d 00
	00		 lea	 eax, DWORD PTR [ecx+7504]
  0002e	50		 push	 eax
  0002f	ff 31		 push	 DWORD PTR [ecx]
  00031	e8 00 00 00 00	 call	 _EAInit
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	85 c0		 test	 eax, eax
  0003b	74 dd		 je	 SHORT $LN5@EAInitMode

; 458  : 			return FALSE;

  0003d	33 c0		 xor	 eax, eax

; 476  : }

  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
_EAInitMode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _EAInit
_TEXT	SEGMENT
_retVal$1$ = -4						; size = 4
tv260 = 8						; size = 4
_ea$ = 8						; size = 4
_key$ = 12						; size = 4
_ks$ = 16						; size = 4
_EAInit	PROC						; COMDAT

; 414  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 415  : 	int c, retVal = ERR_SUCCESS;
; 416  : 
; 417  : 	if (ea == 0)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _ea$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	89 4d fc	 mov	 DWORD PTR _retVal$1$[ebp], ecx
  0000d	85 ff		 test	 edi, edi
  0000f	75 08		 jne	 SHORT $LN7@EAInit

; 418  : 		return ERR_CIPHER_INIT_FAILURE;

  00011	8d 41 11	 lea	 eax, DWORD PTR [ecx+17]
  00014	5f		 pop	 edi

; 436  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
$LN7@EAInit:

; 419  : 
; 420  : 	for (c = EAGetFirstCipher (ea); c != 0; c = EAGetNextCipher (ea, c))

  00019	8b c7		 mov	 eax, edi
  0001b	c1 e0 05	 shl	 eax, 5
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	89 45 08	 mov	 DWORD PTR tv260[ebp], eax
  00023	8b b0 00 00 00
	00		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax]
  00029	85 f6		 test	 esi, esi
  0002b	0f 84 c7 00 00
	00		 je	 $LN3@EAInit
  00031	8b 5d 0c	 mov	 ebx, DWORD PTR _key$[ebp]
  00034	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Ciphers
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL13@EAInit:

; 421  : 	{
; 422  : 		switch (CipherInit (c, key, ks))

  00040	8b c6		 mov	 eax, esi
  00042	83 e8 01	 sub	 eax, 1
  00045	74 17		 je	 SHORT $LN21@EAInit
  00047	83 e8 01	 sub	 eax, 1
  0004a	74 07		 je	 SHORT $LN22@EAInit
  0004c	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  00051	eb 1f		 jmp	 SHORT $LN18@EAInit
$LN22@EAInit:
  00053	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00056	53		 push	 ebx
  00057	e8 00 00 00 00	 call	 _grasshopper_set_key
  0005c	eb 09		 jmp	 SHORT $LN66@EAInit
$LN21@EAInit:
  0005e	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  00061	53		 push	 ebx
  00062	e8 00 00 00 00	 call	 _gost_set_key
$LN66@EAInit:
  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Ciphers
  0006d	83 c4 08	 add	 esp, 8
  00070	33 c0		 xor	 eax, eax
$LN18@EAInit:
  00072	83 e8 11	 sub	 eax, 17			; 00000011H
  00075	0f 84 b9 00 00
	00		 je	 $LN8@EAInit
  0007b	83 e8 01	 sub	 eax, 1
  0007e	75 07		 jne	 SHORT $LN5@EAInit

; 426  : 
; 427  : 		case ERR_CIPHER_INIT_WEAK_KEY:
; 428  : 			retVal = ERR_CIPHER_INIT_WEAK_KEY;		// Non-fatal error

  00080	c7 45 fc 12 00
	00 00		 mov	 DWORD PTR _retVal$1$[ebp], 18 ; 00000012H
$LN5@EAInit:

; 429  : 			break;
; 430  : 		}
; 431  : 
; 432  : 		key += CipherGetKeySize (c);

  00087	33 c0		 xor	 eax, eax
  00089	85 d2		 test	 edx, edx
  0008b	74 16		 je	 SHORT $LN29@EAInit
  0008d	8b ca		 mov	 ecx, edx
  0008f	90		 npad	 1
$LL30@EAInit:
  00090	3b ce		 cmp	 ecx, esi
  00092	74 6d		 je	 SHORT $LN45@EAInit
  00094	40		 inc	 eax
  00095	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00098	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _Ciphers[ecx*4]
  0009f	85 c9		 test	 ecx, ecx
  000a1	75 ed		 jne	 SHORT $LL30@EAInit
$LN29@EAInit:
  000a3	33 c0		 xor	 eax, eax
$LN27@EAInit:
  000a5	03 58 0c	 add	 ebx, DWORD PTR [eax+12]

; 433  : 		ks += CipherGetKeyScheduleSize (c);

  000a8	33 c9		 xor	 ecx, ecx
  000aa	85 d2		 test	 edx, edx
  000ac	74 15		 je	 SHORT $LN37@EAInit
  000ae	8b c2		 mov	 eax, edx
$LL38@EAInit:
  000b0	3b c6		 cmp	 eax, esi
  000b2	74 59		 je	 SHORT $LN46@EAInit
  000b4	41		 inc	 ecx
  000b5	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  000b8	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4]
  000bf	85 c0		 test	 eax, eax
  000c1	75 ed		 jne	 SHORT $LL38@EAInit
$LN37@EAInit:
  000c3	33 c0		 xor	 eax, eax
$LN35@EAInit:
  000c5	8b 4d 10	 mov	 ecx, DWORD PTR _ks$[ebp]
  000c8	03 48 10	 add	 ecx, DWORD PTR [eax+16]
  000cb	8b 45 08	 mov	 eax, DWORD PTR tv260[ebp]
  000ce	89 4d 10	 mov	 DWORD PTR _ks$[ebp], ecx
  000d1	33 c9		 xor	 ecx, ecx
  000d3	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax]
  000d9	85 c0		 test	 eax, eax
  000db	74 18		 je	 SHORT $LN63@EAInit
  000dd	0f 1f 00	 npad	 3

; 419  : 
; 420  : 	for (c = EAGetFirstCipher (ea); c != 0; c = EAGetNextCipher (ea, c))

$LL14@EAInit:
  000e0	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000e3	3b c6		 cmp	 eax, esi
  000e5	8d 04 f9	 lea	 eax, DWORD PTR [ecx+edi*8]
  000e8	74 2f		 je	 SHORT $LN47@EAInit
  000ea	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _EncryptionAlgorithms[eax*4]
  000f1	85 c0		 test	 eax, eax
  000f3	75 eb		 jne	 SHORT $LL14@EAInit
$LN63@EAInit:
  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _retVal$1$[ebp]
$LN3@EAInit:
  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx

; 434  : 	}
; 435  : 	return retVal;

  000fa	8b c1		 mov	 eax, ecx
  000fc	5f		 pop	 edi

; 436  : }

  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c3		 ret	 0
$LN45@EAInit:

; 429  : 			break;
; 430  : 		}
; 431  : 
; 432  : 		key += CipherGetKeySize (c);

  00101	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00104	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  0010b	eb 98		 jmp	 SHORT $LN27@EAInit
$LN46@EAInit:

; 433  : 		ks += CipherGetKeyScheduleSize (c);

  0010d	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  00110	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR _Ciphers[eax*4]
  00117	eb ac		 jmp	 SHORT $LN35@EAInit
$LN47@EAInit:

; 419  : 
; 420  : 	for (c = EAGetFirstCipher (ea); c != 0; c = EAGetNextCipher (ea, c))

  00119	8b 34 85 00 00
	00 00		 mov	 esi, DWORD PTR _EncryptionAlgorithms[eax*4]
  00120	85 f6		 test	 esi, esi
  00122	0f 85 18 ff ff
	ff		 jne	 $LL13@EAInit

; 434  : 	}
; 435  : 	return retVal;

  00128	8b 4d fc	 mov	 ecx, DWORD PTR _retVal$1$[ebp]
  0012b	8b c1		 mov	 eax, ecx
  0012d	5e		 pop	 esi
  0012e	5b		 pop	 ebx
  0012f	5f		 pop	 edi

; 436  : }

  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c3		 ret	 0
$LN8@EAInit:
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx

; 423  : 		{
; 424  : 		case ERR_CIPHER_INIT_FAILURE:
; 425  : 			return ERR_CIPHER_INIT_FAILURE;

  00136	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  0013b	5f		 pop	 edi

; 436  : }

  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c3		 ret	 0
_EAInit	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _CipherInit
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_key$ = 12						; size = 4
_ks$ = 16						; size = 4
_CipherInit PROC					; COMDAT

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	int retVal = ERR_SUCCESS;
; 112  : 
; 113  : 	switch (cipher)

  00003	8b 45 08	 mov	 eax, DWORD PTR _cipher$[ebp]
  00006	83 e8 01	 sub	 eax, 1
  00009	74 1e		 je	 SHORT $LN4@CipherInit
  0000b	83 e8 01	 sub	 eax, 1
  0000e	74 07		 je	 SHORT $LN5@CipherInit

; 120  : 		break;
; 121  : 	default:
; 122  : 		// Unknown/wrong cipher ID
; 123  : 		return ERR_CIPHER_INIT_FAILURE;

  00010	b8 11 00 00 00	 mov	 eax, 17			; 00000011H

; 127  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
$LN5@CipherInit:

; 117  : 		break;
; 118  : 	case GRASSHOPPER:
; 119  : 		grasshopper_set_key((unsigned long *)key, (grasshopper_kds*)ks);

  00017	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  0001a	ff 75 0c	 push	 DWORD PTR _key$[ebp]
  0001d	e8 00 00 00 00	 call	 _grasshopper_set_key
  00022	83 c4 08	 add	 esp, 8

; 124  : 	}
; 125  : 
; 126  : 	return retVal;

  00025	33 c0		 xor	 eax, eax

; 127  : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN4@CipherInit:

; 114  : 	{
; 115  : 	case GOST:
; 116  : 		gost_set_key(key, (gost_kds *)ks);

  00029	ff 75 10	 push	 DWORD PTR _ks$[ebp]
  0002c	ff 75 0c	 push	 DWORD PTR _key$[ebp]
  0002f	e8 00 00 00 00	 call	 _gost_set_key
  00034	83 c4 08	 add	 esp, 8

; 124  : 	}
; 125  : 
; 126  : 	return retVal;

  00037	33 c0		 xor	 eax, eax

; 127  : }

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
_CipherInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _CipherGetName
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetName PROC					; COMDAT

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  : 	return CipherGet (cipherId) -> Name;

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Ciphers
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 16		 je	 SHORT $LN5@CipherGetN
  0000f	8b 55 08	 mov	 edx, DWORD PTR _cipherId$[ebp]
$LL6@CipherGetN:
  00012	3b ca		 cmp	 ecx, edx
  00014	74 16		 je	 SHORT $LN10@CipherGetN
  00016	40		 inc	 eax
  00017	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0001a	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _Ciphers[ecx*4]
  00021	85 c9		 test	 ecx, ecx
  00023	75 ed		 jne	 SHORT $LL6@CipherGetN
$LN5@CipherGetN:
  00025	33 c0		 xor	 eax, eax
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 263  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN10@CipherGetN:

; 262  : 	return CipherGet (cipherId) -> Name;

  0002c	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0002f	8b 04 85 04 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4+4]

; 263  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_CipherGetName ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _CipherSupportsIntraDataUnitParallelization
_TEXT	SEGMENT
_cipher$ = 8						; size = 4
_CipherSupportsIntraDataUnitParallelization PROC	; COMDAT

; 319  : 	return 0;

  00000	33 c0		 xor	 eax, eax

; 320  : }

  00002	c3		 ret	 0
_CipherSupportsIntraDataUnitParallelization ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _CipherGetKeyScheduleSize
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetKeyScheduleSize PROC				; COMDAT

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 304  : 	return CipherGet (cipherId) -> KeyScheduleSize;

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Ciphers
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 16		 je	 SHORT $LN5@CipherGetK
  0000f	8b 55 08	 mov	 edx, DWORD PTR _cipherId$[ebp]
$LL6@CipherGetK:
  00012	3b ca		 cmp	 ecx, edx
  00014	74 16		 je	 SHORT $LN10@CipherGetK
  00016	40		 inc	 eax
  00017	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0001a	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _Ciphers[ecx*4]
  00021	85 c9		 test	 ecx, ecx
  00023	75 ed		 jne	 SHORT $LL6@CipherGetK
$LN5@CipherGetK:
  00025	33 c0		 xor	 eax, eax
  00027	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 305  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN10@CipherGetK:

; 304  : 	return CipherGet (cipherId) -> KeyScheduleSize;

  0002c	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0002f	8b 04 85 10 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4+16]

; 305  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_CipherGetKeyScheduleSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _CipherGetKeySize
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetKeySize PROC					; COMDAT

; 289  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 290  : 	return CipherGet (cipherId) -> KeySize;

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Ciphers
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 16		 je	 SHORT $LN5@CipherGetK
  0000f	8b 55 08	 mov	 edx, DWORD PTR _cipherId$[ebp]
$LL6@CipherGetK:
  00012	3b ca		 cmp	 ecx, edx
  00014	74 16		 je	 SHORT $LN10@CipherGetK
  00016	40		 inc	 eax
  00017	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0001a	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _Ciphers[ecx*4]
  00021	85 c9		 test	 ecx, ecx
  00023	75 ed		 jne	 SHORT $LL6@CipherGetK
$LN5@CipherGetK:
  00025	33 c0		 xor	 eax, eax
  00027	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 291  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN10@CipherGetK:

; 290  : 	return CipherGet (cipherId) -> KeySize;

  0002c	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0002f	8b 04 85 0c 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4+12]

; 291  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_CipherGetKeySize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _CipherGetBlockSize
_TEXT	SEGMENT
_cipherId$ = 8						; size = 4
_CipherGetBlockSize PROC				; COMDAT

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 276  : 	return CipherGet (cipherId) -> BlockSize;

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Ciphers
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 16		 je	 SHORT $LN5@CipherGetB
  0000f	8b 55 08	 mov	 edx, DWORD PTR _cipherId$[ebp]
$LL6@CipherGetB:
  00012	3b ca		 cmp	 ecx, edx
  00014	74 16		 je	 SHORT $LN10@CipherGetB
  00016	40		 inc	 eax
  00017	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0001a	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _Ciphers[ecx*4]
  00021	85 c9		 test	 ecx, ecx
  00023	75 ed		 jne	 SHORT $LL6@CipherGetB
$LN5@CipherGetB:
  00025	33 c0		 xor	 eax, eax
  00027	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 277  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN10@CipherGetB:

; 276  : 	return CipherGet (cipherId) -> BlockSize;

  0002c	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0002f	8b 04 85 08 00
	00 00		 mov	 eax, DWORD PTR _Ciphers[eax*4+8]

; 277  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_CipherGetBlockSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _crypto_close
_TEXT	SEGMENT
_cryptoInfo$ = 8					; size = 4
_crypto_close PROC					; COMDAT

; 960  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 961  : #ifndef GST_WINDOWS_BOOT
; 962  : 
; 963  : 	if (cryptoInfo != NULL)

  00004	8b 7d 08	 mov	 edi, DWORD PTR _cryptoInfo$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 38		 je	 SHORT $LN7@crypto_clo

; 964  : 	{
; 965  : 		burn (cryptoInfo, sizeof (CRYPTO_INFO));

  0000b	b8 10 1f 00 00	 mov	 eax, 7952		; 00001f10H
  00010	8b cf		 mov	 ecx, edi
  00012	56		 push	 esi
  00013	8b f0		 mov	 esi, eax
  00015	8b d7		 mov	 edx, edi
$LL10@crypto_clo:
  00017	c6 02 00	 mov	 BYTE PTR [edx], 0
  0001a	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  0001d	83 ee 01	 sub	 esi, 1
  00020	75 f5		 jne	 SHORT $LL10@crypto_clo
  00022	5e		 pop	 esi
$LL5@crypto_clo:
  00023	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00026	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00029	83 e8 01	 sub	 eax, 1
  0002c	75 f5		 jne	 SHORT $LL5@crypto_clo

; 966  : #ifndef DEVICE_DRIVER
; 967  : 		VirtualUnlock (cryptoInfo, sizeof (CRYPTO_INFO));

  0002e	68 10 1f 00 00	 push	 7952			; 00001f10H
  00033	57		 push	 edi
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualUnlock@8

; 968  : #endif
; 969  : 		GSTfree (cryptoInfo);

  0003a	57		 push	 edi
  0003b	e8 00 00 00 00	 call	 _free
  00040	83 c4 04	 add	 esp, 4
$LN7@crypto_clo:
  00043	5f		 pop	 edi

; 970  : 	}
; 971  : 
; 972  : #else // GST_WINDOWS_BOOT
; 973  : 
; 974  : 	burn (&CryptoInfoBuffer, sizeof (CryptoInfoBuffer));
; 975  : 	CryptoInfoBufferInUse = FALSE;
; 976  : 
; 977  : #endif // GST_WINDOWS_BOOT
; 978  : }

  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_crypto_close ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _crypto_loadkey
_TEXT	SEGMENT
_keyInfo$ = 8						; size = 4
_lpszUserKey$ = 12					; size = 4
_nUserKeyLen$ = 16					; size = 4
_crypto_loadkey PROC					; COMDAT

; 945  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 946  : 	keyInfo->keyLength = nUserKeyLen;

  00003	8b 45 08	 mov	 eax, DWORD PTR _keyInfo$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 10	 mov	 ebx, DWORD PTR _nUserKeyLen$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 947  : 	burn (keyInfo->userKey, sizeof (keyInfo->userKey));

  0000c	8d 78 08	 lea	 edi, DWORD PTR [eax+8]
  0000f	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00012	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00017	8b cf		 mov	 ecx, edi
  00019	8b f0		 mov	 esi, eax
  0001b	8b d7		 mov	 edx, edi
  0001d	0f 1f 00	 npad	 3
$LL9@crypto_loa:
  00020	c6 02 00	 mov	 BYTE PTR [edx], 0
  00023	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00026	83 ee 01	 sub	 esi, 1
  00029	75 f5		 jne	 SHORT $LL9@crypto_loa
  0002b	0f 1f 44 00 00	 npad	 5
$LL5@crypto_loa:
  00030	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00033	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00036	83 e8 01	 sub	 eax, 1
  00039	75 f5		 jne	 SHORT $LL5@crypto_loa

; 948  : 	memcpy (keyInfo->userKey, lpszUserKey, nUserKeyLen);

  0003b	53		 push	 ebx
  0003c	ff 75 0c	 push	 DWORD PTR _lpszUserKey$[ebp]
  0003f	57		 push	 edi
  00040	e8 00 00 00 00	 call	 _memcpy
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 949  : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_crypto_loadkey ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\crypto.c
;	COMDAT _crypto_open
_TEXT	SEGMENT
_crypto_open PROC					; COMDAT

; 905  : {

  00000	56		 push	 esi

; 906  : #ifndef GST_WINDOWS_BOOT
; 907  : 
; 908  : 	/* Do the crt allocation */
; 909  : 	PCRYPTO_INFO cryptoInfo = (PCRYPTO_INFO) GSTalloc (sizeof (CRYPTO_INFO));

  00001	68 10 1f 00 00	 push	 7952			; 00001f10H
  00006	e8 00 00 00 00	 call	 _malloc
  0000b	8b f0		 mov	 esi, eax
  0000d	83 c4 04	 add	 esp, 4

; 910  : 	if (cryptoInfo == NULL)

  00010	85 f6		 test	 esi, esi
  00012	75 02		 jne	 SHORT $LN2@crypto_ope
  00014	5e		 pop	 esi

; 921  : 
; 922  : #else // GST_WINDOWS_BOOT
; 923  : 
; 924  : #if 0
; 925  : 	if (CryptoInfoBufferInUse)
; 926  : 		GST_THROW_FATAL_EXCEPTION;
; 927  : #endif
; 928  : 	CryptoInfoBufferInUse = 1;
; 929  : 	return &CryptoInfoBuffer;
; 930  : 
; 931  : #endif // GST_WINDOWS_BOOT
; 932  : }

  00015	c3		 ret	 0
$LN2@crypto_ope:

; 911  : 		return NULL;
; 912  : 
; 913  : 	memset (cryptoInfo, 0, sizeof (CRYPTO_INFO));

  00016	68 10 1f 00 00	 push	 7952			; 00001f10H
  0001b	6a 00		 push	 0
  0001d	56		 push	 esi
  0001e	e8 00 00 00 00	 call	 _memset
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 914  : 
; 915  : #ifndef DEVICE_DRIVER
; 916  : 	VirtualLock (cryptoInfo, sizeof (CRYPTO_INFO));

  00026	68 10 1f 00 00	 push	 7952			; 00001f10H
  0002b	56		 push	 esi
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualLock@8

; 917  : #endif
; 918  : 
; 919  : 	cryptoInfo->ea = -1;

  00032	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1

; 920  : 	return cryptoInfo;

  00038	8b c6		 mov	 eax, esi
  0003a	5e		 pop	 esi

; 921  : 
; 922  : #else // GST_WINDOWS_BOOT
; 923  : 
; 924  : #if 0
; 925  : 	if (CryptoInfoBufferInUse)
; 926  : 		GST_THROW_FATAL_EXCEPTION;
; 927  : #endif
; 928  : 	CryptoInfoBufferInUse = 1;
; 929  : 	return &CryptoInfoBuffer;
; 930  : 
; 931  : #endif // GST_WINDOWS_BOOT
; 932  : }

  0003b	c3		 ret	 0
_crypto_open ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 17787: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17788:     volatile char *vptr = (volatile char *)ptr;
; 17789: 
; 17790: #if defined(_M_AMD64)
; 17791: 
; 17792:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 17793: 
; 17794: #else
; 17795: 
; 17796:     while (cnt) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR _cnt$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	8b c8		 mov	 ecx, eax
  0000b	85 d2		 test	 edx, edx
  0000d	74 0c		 je	 SHORT $LN3@RtlSecureZ
  0000f	90		 npad	 1
$LL2@RtlSecureZ:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

  00013	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 17809:         cnt--;

  00016	83 ea 01	 sub	 edx, 1
  00019	75 f5		 jne	 SHORT $LL2@RtlSecureZ
$LN3@RtlSecureZ:

; 17810:     }
; 17811: 
; 17812: #endif // _M_AMD64
; 17813: 
; 17814:     return ptr;
; 17815: }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
END
