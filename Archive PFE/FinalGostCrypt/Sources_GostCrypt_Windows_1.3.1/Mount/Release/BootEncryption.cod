; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Common\BootEncryption.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_1M@LJLLCMEH@?$AAp?$AAt?$AA?9?$AAb?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@NCMONAAL@?$AAp?$AAt?$AA?9?$AAp?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@EAKMAJDN@?$AAq?$AAu?$AAz?$AA?9?$AAb?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BA@IDBKCKK@atlTraceStencil?$AA@		; `string'
PUBLIC	??_C@_1O@BHHPIGDN@?$AAq?$AAu?$AAz?$AA?9?$AAe?$AAc?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@GBAPEKMJ@?$AAq?$AAu?$AAz?$AA?9?$AAp?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CLGLEFBO@?$AAr?$AAo?$AA?9?$AAr?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CEEDODME@?$AAr?$AAu?$AA?9?$AAr?$AAu?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@HPKKKMPP@?$AAs?$AAa?$AA?9?$AAi?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BKMAIGOJ@?$AAs?$AAe?$AA?9?$AAf?$AAi?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@NDPIFLFI@?$AAs?$AAe?$AA?9?$AAn?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DANKKHJ@?$AAs?$AAe?$AA?9?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PNBLONPJ@?$AAs?$AAk?$AA?9?$AAs?$AAk?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LFMODOAL@?$AAs?$AAl?$AA?9?$AAs?$AAi?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@DFKOMPG@?$AAs?$AAm?$AAa?$AA?9?$AAn?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@NDKPBNNH@?$AAs?$AAm?$AAa?$AA?9?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@PLLKBHAB@?$AAs?$AAm?$AAj?$AA?9?$AAn?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@CLEPOGCA@?$AAs?$AAm?$AAj?$AA?9?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@DLGJGKMK@?$AAs?$AAm?$AAn?$AA?9?$AAf?$AAi?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@OJDJGAJC@?$AAs?$AAm?$AAs?$AA?9?$AAf?$AAi?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BOFOGHPB@?$AAs?$AAq?$AA?9?$AAa?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@LJBBIPGB@?$AAs?$AAr?$AA?9?$AAb?$AAa?$AA?9?$AAc?$AAy?$AAr?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@JLBENFOE@?$AAs?$AAr?$AA?9?$AAb?$AAa?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@KODPNHE@?$AAs?$AAr?$AA?9?$AAs?$AAp?$AA?9?$AAc?$AAy?$AAr?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@CIOGKHPB@?$AAs?$AAr?$AA?9?$AAs?$AAp?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@NGFJLMAC@?$AAs?$AAv?$AA?9?$AAf?$AAi?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MPJEJAJC@?$AAs?$AAv?$AA?9?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MPNDHLFK@?$AAs?$AAw?$AA?9?$AAk?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@KOHBJJI@?$AAs?$AAy?$AAr?$AA?9?$AAs?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LDCEFHA@?$AAt?$AAa?$AA?9?$AAi?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CNJOFAK@?$AAt?$AAe?$AA?9?$AAi?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GNAECACD@?$AAt?$AAh?$AA?9?$AAt?$AAh?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CHBIHOJO@?$AAt?$AAn?$AA?9?$AAz?$AAa?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GCCMIGPJ@?$AAt?$AAr?$AA?9?$AAt?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CELMCNBK@?$AAt?$AAt?$AA?9?$AAr?$AAu?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KLMCELGA@?$AAu?$AAk?$AA?9?$AAu?$AAa?$AA?$AA@ ; `string'
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	??_C@_1M@EPAJJAJF@?$AAu?$AAr?$AA?9?$AAp?$AAk?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@GEGPMCDJ@?$AAu?$AAz?$AA?9?$AAu?$AAz?$AA?9?$AAc?$AAy?$AAr?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@EGGKJILM@?$AAu?$AAz?$AA?9?$AAu?$AAz?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GFOCLFF@?$AAv?$AAi?$AA?9?$AAv?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CPAMEDFI@?$AAx?$AAh?$AA?9?$AAz?$AAa?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@EBKIFIGN@?$AAz?$AAh?$AA?9?$AAc?$AAh?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@NMHPGANE@?$AAz?$AAh?$AA?9?$AAc?$AAh?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LPINJOMC@?$AAz?$AAh?$AA?9?$AAc?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@OCJEJODD@?$AAz?$AAh?$AA?9?$AAh?$AAk?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DNDLJINH@?$AAz?$AAh?$AA?9?$AAm?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MBFDNDND@?$AAz?$AAh?$AA?9?$AAs?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IMEPLEPE@?$AAz?$AAh?$AA?9?$AAt?$AAw?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BBGHNHJP@?$AAz?$AAu?$AA?9?$AAz?$AAa?$AA?$AA@ ; `string'
PUBLIC	??_C@_0P@MBNHGHMI@atlTraceString?$AA@		; `string'
PUBLIC	??_C@_0M@IOBBMAHG@atlTraceMap?$AA@		; `string'
PUBLIC	??_C@_0N@FEAAACHD@atlTraceUtil?$AA@		; `string'
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	??_C@_0BB@DNJDADMG@atlTraceSecurity?$AA@	; `string'
PUBLIC	_IID_IAxWinAmbientDispatch
PUBLIC	??_C@_0N@KLPNCFEE@atlTraceSync?$AA@		; `string'
PUBLIC	?chDirSep@ATL@@3DB				; ATL::chDirSep
PUBLIC	?chRightBracket@ATL@@3DB			; ATL::chRightBracket
PUBLIC	?chLeftBracket@ATL@@3DB				; ATL::chLeftBracket
PUBLIC	?chQuote@ATL@@3DB				; ATL::chQuote
PUBLIC	?chEquals@ATL@@3DB				; ATL::chEquals
PUBLIC	?szStringVal@ATL@@3QBDB				; ATL::szStringVal
PUBLIC	??_C@_01CPLAODJH@S?$AA@				; `string'
PUBLIC	?multiszStringVal@ATL@@3QBDB			; ATL::multiszStringVal
PUBLIC	??_C@_01PLPBNMEI@M?$AA@				; `string'
PUBLIC	?szDwordVal@ATL@@3QBDB				; ATL::szDwordVal
PUBLIC	??_C@_01CKDDGHAB@D?$AA@				; `string'
PUBLIC	?szBinaryVal@ATL@@3QBDB				; ATL::szBinaryVal
PUBLIC	??_C@_01HMGJMAIH@B?$AA@				; `string'
PUBLIC	?szValToken@ATL@@3QBDB				; ATL::szValToken
PUBLIC	??_C@_03LAIAPFCB@Val?$AA@			; `string'
PUBLIC	??_C@_0O@KHOBHOBJ@atlTraceISAPI?$AA@		; `string'
PUBLIC	?szForceRemove@ATL@@3QBDB			; ATL::szForceRemove
PUBLIC	??_C@_0M@DBGDLGLL@ForceRemove?$AA@		; `string'
PUBLIC	?szNoRemove@ATL@@3QBDB				; ATL::szNoRemove
PUBLIC	??_C@_08KAAPDIAN@NoRemove?$AA@			; `string'
PUBLIC	?szDelete@ATL@@3QBDB				; ATL::szDelete
PUBLIC	??_C@_06JBKGCNBB@Delete?$AA@			; `string'
PUBLIC	??_C@_0BA@MKMIKKJB@atlTraceGeneral?$AA@		; `string'
PUBLIC	??_C@_0M@DGPFJEBB@atlTraceCOM?$AA@		; `string'
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	??_C@_0L@LHELAKBP@atlTraceQI?$AA@		; `string'
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	??_C@_0BC@MALHFBAO@atlTraceRegistrar?$AA@	; `string'
PUBLIC	??_C@_0BB@ILPPDKFL@atlTraceRefcount?$AA@	; `string'
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	_IID_IInternalConnection
PUBLIC	??_C@_0BC@DGHHNKDC@atlTraceWindowing?$AA@	; `string'
PUBLIC	??_C@_0BB@GHKJKKIE@atlTraceControls?$AA@	; `string'
PUBLIC	??_C@_0BA@DKOAAGGM@atlTraceHosting?$AA@		; `string'
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	??_C@_0BB@BEBMGMDO@atlTraceDBClient?$AA@	; `string'
PUBLIC	_CLSID_Registrar
PUBLIC	__pAtlLcidToLocaleNameTable
PUBLIC	??_C@_15EMKDOKLE@?$AAa?$AAr?$AA?$AA@		; `string'
PUBLIC	??_C@_15KNPADPLH@?$AAb?$AAg?$AA?$AA@		; `string'
PUBLIC	??_C@_15EDMHLDMO@?$AAc?$AAa?$AA?$AA@		; `string'
PUBLIC	??_C@_1O@BPEAJADD@?$AAz?$AAh?$AA?9?$AAC?$AAH?$AAS?$AA?$AA@ ; `string'
PUBLIC	??_C@_15LJNHCMNK@?$AAc?$AAs?$AA?$AA@		; `string'
PUBLIC	??_C@_15FOMCIDHG@?$AAd?$AAa?$AA?$AA@		; `string'
PUBLIC	??_C@_15NBKABECB@?$AAd?$AAe?$AA?$AA@		; `string'
PUBLIC	??_C@_15GHPEIIAO@?$AAe?$AAl?$AA?$AA@		; `string'
PUBLIC	??_C@_15MNPNEAIF@?$AAe?$AAn?$AA?$AA@		; `string'
PUBLIC	??_C@_15GPIOMPMH@?$AAe?$AAs?$AA?$AA@		; `string'
PUBLIC	??_C@_15NGLOAKJC@?$AAf?$AAi?$AA?$AA@		; `string'
PUBLIC	??_C@_15FBKGNKAM@?$AAf?$AAr?$AA?$AA@		; `string'
PUBLIC	??_C@_15KGGCNEFK@?$AAh?$AAe?$AA?$AA@		; `string'
PUBLIC	??_C@_15PGHLIDMF@?$AAh?$AAu?$AA?$AA@		; `string'
PUBLIC	??_C@_15BIEMAPLM@?$AAi?$AAs?$AA?$AA@		; `string'
PUBLIC	??_C@_15IFJLDHAF@?$AAi?$AAt?$AA?$AA@		; `string'
PUBLIC	??_C@_0BD@KOADKDIA@atlTraceDBProvider?$AA@	; `string'
PUBLIC	??_C@_15GEMIOCAG@?$AAj?$AAa?$AA?$AA@		; `string'
PUBLIC	??_C@_15EPELEGJA@?$AAk?$AAo?$AA?$AA@		; `string'
PUBLIC	??_C@_15NDDHIMN@?$AAn?$AAl?$AA?$AA@		; `string'
PUBLIC	??_C@_15BPIGNHCD@?$AAn?$AAo?$AA?$AA@		; `string'
PUBLIC	??_C@_15DEOPBLCG@?$AAp?$AAl?$AA?$AA@		; `string'
PUBLIC	??_C@_15KBECGEFG@?$AAp?$AAt?$AA?$AA@		; `string'
PUBLIC	??_C@_15GLJCBFMD@?$AAr?$AAo?$AA?$AA@		; `string'
PUBLIC	??_C@_15FEDGKCDI@?$AAr?$AAu?$AA?$AA@		; `string'
PUBLIC	??_C@_15GLKMLLHM@?$AAh?$AAr?$AA?$AA@		; `string'
PUBLIC	??_C@_15CPKMFBDB@?$AAs?$AAk?$AA?$AA@		; `string'
PUBLIC	??_C@_15BAAIOGMK@?$AAs?$AAq?$AA?$AA@		; `string'
PUBLIC	??_C@_15INNPNOHD@?$AAs?$AAv?$AA?$AA@		; `string'
PUBLIC	??_C@_15CABMMOGH@?$AAt?$AAh?$AA?$AA@		; `string'
PUBLIC	??_C@_15BPLIHJJM@?$AAt?$AAr?$AA?$AA@		; `string'
PUBLIC	??_C@_15NEOEKKDJ@?$AAu?$AAr?$AA?$AA@		; `string'
PUBLIC	??_C@_15NFICGAJK@?$AAi?$AAd?$AA?$AA@		; `string'
PUBLIC	??_C@_15PJPFLCCM@?$AAu?$AAk?$AA?$AA@		; `string'
PUBLIC	??_C@_15HPJPHDM@?$AAb?$AAe?$AA?$AA@		; `string'
PUBLIC	??_C@_15LCHLGJII@?$AAs?$AAl?$AA?$AA@		; `string'
PUBLIC	??_C@_15PCFJPHHO@?$AAe?$AAt?$AA?$AA@		; `string'
PUBLIC	_IID_IRegistrar
PUBLIC	??_C@_15HPFPGODN@?$AAl?$AAv?$AA?$AA@		; `string'
PUBLIC	??_C@_15NFFGKGLG@?$AAl?$AAt?$AA?$AA@		; `string'
PUBLIC	??_C@_15BDAKCCHN@?$AAf?$AAa?$AA?$AA@		; `string'
PUBLIC	??_C@_15NFGIAIAJ@?$AAv?$AAi?$AA?$AA@		; `string'
PUBLIC	??_C@_15LMKNDMHN@?$AAh?$AAy?$AA?$AA@		; `string'
PUBLIC	??_C@_15IJBHMCFL@?$AAa?$AAz?$AA?$AA@		; `string'
PUBLIC	??_C@_15EKOFJABL@?$AAe?$AAu?$AA?$AA@		; `string'
PUBLIC	??_C@_15BGHADCNK@?$AAm?$AAk?$AA?$AA@		; `string'
PUBLIC	??_C@_15JDNICKHM@?$AAa?$AAf?$AA?$AA@		; `string'
PUBLIC	??_C@_15KPJEDBKD@?$AAk?$AAa?$AA?$AA@		; `string'
PUBLIC	??_C@_15PDNFFFEO@?$AAf?$AAo?$AA?$AA@		; `string'
PUBLIC	??_C@_15OMLEGLOC@?$AAh?$AAi?$AA?$AA@		; `string'
PUBLIC	??_C@_15IDNNENKK@?$AAm?$AAs?$AA?$AA@		; `string'
PUBLIC	??_C@_15MACJNBMH@?$AAk?$AAk?$AA?$AA@		; `string'
PUBLIC	??_C@_15DKDJEOND@?$AAk?$AAy?$AA?$AA@		; `string'
PUBLIC	??_C@_15DFGDLJBG@?$AAs?$AAw?$AA?$AA@		; `string'
PUBLIC	??_C@_15BBFAICNG@?$AAu?$AAz?$AA?$AA@		; `string'
PUBLIC	??_C@_15DKNDCGEA@?$AAt?$AAt?$AA?$AA@		; `string'
PUBLIC	??_C@_15MGIFMDPL@?$AAp?$AAa?$AA?$AA@		; `string'
PUBLIC	??_C@_15HCNDBBA@?$AAg?$AAu?$AA?$AA@		; `string'
PUBLIC	??_C@_15FNBEIBON@?$AAt?$AAa?$AA?$AA@		; `string'
PUBLIC	??_C@_15NCHGBGLK@?$AAt?$AAe?$AA?$AA@		; `string'
PUBLIC	??_C@_15PHPHCBPF@?$AAk?$AAn?$AA?$AA@		; `string'
PUBLIC	??_C@_15DLGBCKMP@?$AAm?$AAr?$AA?$AA@		; `string'
PUBLIC	??_C@_15EABBLBFF@?$AAs?$AAa?$AA?$AA@		; `string'
PUBLIC	??_C@_15CBKOMCOI@?$AAm?$AAn?$AA?$AA@		; `string'
PUBLIC	??_C@_15CKDMCJAF@?$AAg?$AAl?$AA?$AA@		; `string'
PUBLIC	??_C@_0P@LNEGBOLO@atlTraceSnapin?$AA@		; `string'
PUBLIC	??_C@_17CNJFBPG@?$AAk?$AAo?$AAk?$AA?$AA@	; `string'
PUBLIC	??_C@_17FFBJICPL@?$AAs?$AAy?$AAr?$AA?$AA@	; `string'
PUBLIC	??_C@_17KPNDCPAF@?$AAd?$AAi?$AAv?$AA?$AA@	; `string'
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	??_C@_1M@OKAHONE@?$AAa?$AAr?$AA?9?$AAS?$AAA?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FFFIGIGK@?$AAb?$AAg?$AA?9?$AAB?$AAG?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BJNKEDC@?$AAc?$AAa?$AA?9?$AAE?$AAS?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CLNBBOPM@?$AAz?$AAh?$AA?9?$AAT?$AAW?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IJJHFJHA@?$AAc?$AAs?$AA?9?$AAC?$AAZ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CLPEOBGI@?$AAd?$AAa?$AA?9?$AAD?$AAK?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MCMADGCB@?$AAd?$AAe?$AA?9?$AAD?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@OOCKEMAM@?$AAe?$AAl?$AA?9?$AAG?$AAR?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BMHNFIME@?$AAe?$AAn?$AA?9?$AAU?$AAS?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DDNJFGID@?$AAf?$AAi?$AA?9?$AAF?$AAI?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GLIPPMAC@?$AAf?$AAr?$AA?9?$AAF?$AAR?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GFMCHPE@?$AAh?$AAe?$AA?9?$AAI?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MHLPGNKM@?$AAh?$AAu?$AA?9?$AAH?$AAU?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LPDDNNPN@?$AAi?$AAs?$AA?9?$AAI?$AAS?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MADIPODN@?$AAi?$AAt?$AA?9?$AAI?$AAT?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@HPNHIDJI@?$AAj?$AAa?$AA?9?$AAJ?$AAP?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@JLOOOEGK@?$AAk?$AAo?$AA?9?$AAK?$AAR?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IHBJJGG@?$AAn?$AAl?$AA?9?$AAN?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@EANAGDL@?$AAn?$AAb?$AA?9?$AAN?$AAO?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@NEIEMEGP@?$AAp?$AAl?$AA?9?$AAP?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BOCFIGEP@?$AAp?$AAt?$AA?9?$AAB?$AAR?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IMPFOPBG@?$AAr?$AAo?$AA?9?$AAR?$AAO?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IDNNEJMM@?$AAr?$AAu?$AA?9?$AAR?$AAU?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LILEEOGM@?$AAh?$AAr?$AA?9?$AAH?$AAR?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FKIFEHPB@?$AAs?$AAk?$AA?9?$AAS?$AAK?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LJMAMNPJ@?$AAs?$AAq?$AA?9?$AAA?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GIAKDKJK@?$AAs?$AAv?$AA?9?$AAS?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MKJKIKCL@?$AAt?$AAh?$AA?9?$AAT?$AAH?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MFLCCMPB@?$AAt?$AAr?$AA?9?$AAT?$AAR?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@OIJHDKJN@?$AAu?$AAr?$AA?9?$AAP?$AAK?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LHIPCIEK@?$AAi?$AAd?$AA?9?$AAI?$AAD?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MFMOBGI@?$AAu?$AAk?$AA?9?$AAU?$AAA?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@OBGLJIPL@?$AAb?$AAe?$AA?9?$AAB?$AAY?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BCFAJEAD@?$AAs?$AAl?$AA?9?$AAS?$AAI?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FKFFEDDN@?$AAe?$AAt?$AA?9?$AAE?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KGKKAACI@?$AAl?$AAv?$AA?9?$AAL?$AAV?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IFGBIJO@?$AAl?$AAt?$AA?9?$AAL?$AAT?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FGEAHEDM@?$AAf?$AAa?$AA?9?$AAI?$AAR?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KBMAIBFN@?$AAv?$AAi?$AA?9?$AAV?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GPCBKDJK@?$AAh?$AAy?$AA?9?$AAA?$AAM?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@BECMDDJB@?$AAa?$AAz?$AA?9?$AAA?$AAZ?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MAOFCAEA@?$AAe?$AAu?$AA?9?$AAE?$AAS?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IGHABKPI@?$AAm?$AAk?$AA?9?$AAM?$AAK?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BA@MCBFIDIC@atlTraceNotImpl?$AA@		; `string'
PUBLIC	??_C@_1M@IAIGNEJG@?$AAt?$AAn?$AA?9?$AAZ?$AAA?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IIJCOJFA@?$AAx?$AAh?$AA?9?$AAZ?$AAA?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LGPJHNJH@?$AAz?$AAu?$AA?9?$AAZ?$AAA?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@HOKAOIO@?$AAa?$AAf?$AA?9?$AAZ?$AAA?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DPCLHLIE@?$AAk?$AAa?$AA?9?$AAG?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BLKMHJBI@?$AAf?$AAo?$AA?9?$AAF?$AAO?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LGGJAPPB@?$AAh?$AAi?$AA?9?$AAI?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FIKPIHFE@?$AAm?$AAt?$AA?9?$AAM?$AAT?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@HEGGPBFA@?$AAs?$AAe?$AA?9?$AAN?$AAO?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@EIBJEEPA@?$AAm?$AAs?$AA?9?$AAM?$AAY?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FHLBGMPP@?$AAk?$AAk?$AA?9?$AAK?$AAZ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@NGJJLCGI@?$AAk?$AAy?$AA?9?$AAK?$AAG?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GIENNBFC@?$AAs?$AAw?$AA?9?$AAK?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@NDGMJIMJ@?$AAu?$AAz?$AA?9?$AAU?$AAZ?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IDCCIHBC@?$AAt?$AAt?$AA?9?$AAR?$AAU?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LOICPMOJ@?$AAb?$AAn?$AA?9?$AAI?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KPKKNEAH@?$AAp?$AAa?$AA?9?$AAI?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PJGPPBOG@?$AAg?$AAu?$AA?9?$AAI?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KMKMOPHI@?$AAt?$AAa?$AA?9?$AAI?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KFEHEPAC@?$AAt?$AAe?$AA?9?$AAI?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CDCLMGHI@?$AAk?$AAn?$AA?9?$AAI?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MIODLDKF@?$AAm?$AAl?$AA?9?$AAI?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PBIEACPO@?$AAm?$AAr?$AA?9?$AAI?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@NIDEAGPH@?$AAs?$AAa?$AA?9?$AAI?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FHIHCBIO@?$AAm?$AAn?$AA?9?$AAM?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@JAIJPENP@?$AAc?$AAy?$AA?9?$AAG?$AAB?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PHGFBEPN@?$AAg?$AAl?$AA?9?$AAE?$AAS?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@KPIPDNCP@?$AAk?$AAo?$AAk?$AA?9?$AAI?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@KNHJLDJA@?$AAs?$AAy?$AAr?$AA?9?$AAS?$AAY?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@MKEKBLAH@?$AAd?$AAi?$AAv?$AA?9?$AAM?$AAV?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@OHDCKDDF@?$AAq?$AAu?$AAz?$AA?9?$AAB?$AAO?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LEPJNLFD@?$AAn?$AAs?$AA?9?$AAZ?$AAA?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@OMLEIIJB@?$AAm?$AAi?$AA?9?$AAN?$AAZ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PMPEAILG@?$AAa?$AAr?$AA?9?$AAI?$AAQ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BIBDDEMK@?$AAz?$AAh?$AA?9?$AAC?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CNKPNOEE@?$AAd?$AAe?$AA?9?$AAC?$AAH?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LKMGMLKO@?$AAe?$AAn?$AA?9?$AAG?$AAB?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PGKJFFGL@?$AAe?$AAs?$AA?9?$AAM?$AAX?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DNNANBDC@?$AAf?$AAr?$AA?9?$AAB?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@HLGMDFHM@?$AAi?$AAt?$AA?9?$AAC?$AAH?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CLLBGJH@?$AAn?$AAl?$AA?9?$AAB?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BODBOGLF@?$AAn?$AAn?$AA?9?$AAN?$AAO?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@HFFAHKAD@?$AAp?$AAt?$AA?9?$AAP?$AAT?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@LNOAKHIE@?$AAs?$AAr?$AA?9?$AAS?$AAP?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@ ; `string'
PUBLIC	_LIBID_ATLLib
PUBLIC	??_C@_1M@HBMHBGAK@?$AAs?$AAv?$AA?9?$AAF?$AAI?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@DGCJGJBE@?$AAa?$AAz?$AA?9?$AAA?$AAZ?$AA?9?$AAC?$AAy?$AAr?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KEJDAAHB@?$AAs?$AAe?$AA?9?$AAS?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BD@PJPCCAKP@atlTraceAllocation?$AA@	; `string'
PUBLIC	??_C@_1M@HEIBJJAD@?$AAm?$AAs?$AA?9?$AAB?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@PBGJMCEM@?$AAu?$AAz?$AA?9?$AAU?$AAZ?$AA?9?$AAC?$AAy?$AAr?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@LAOBCMDF@?$AAq?$AAu?$AAz?$AA?9?$AAE?$AAC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@POEEMAIO@?$AAa?$AAr?$AA?9?$AAE?$AAG?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@EFAKDEDL@?$AAz?$AAh?$AA?9?$AAH?$AAK?$AA?$AA@ ; `string'
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	??_C@_1M@HKKIJHGI@?$AAd?$AAe?$AA?9?$AAA?$AAT?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KBFBEHJF@?$AAe?$AAn?$AA?9?$AAA?$AAU?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MNPLFAAH@?$AAe?$AAs?$AA?9?$AAE?$AAS?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@HJOOJFMA@?$AAf?$AAr?$AA?9?$AAC?$AAA?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@JPOFPNAB@?$AAs?$AAr?$AA?9?$AAS?$AAP?$AA?9?$AAC?$AAy?$AAr?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LNFOCMOB@?$AAs?$AAe?$AA?9?$AAF?$AAI?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@MGJBOAMB@?$AAq?$AAu?$AAz?$AA?9?$AAP?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GJINLBOK@?$AAa?$AAr?$AA?9?$AAL?$AAY?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GGMNHJNL@?$AAz?$AAh?$AA?9?$AAS?$AAG?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@HOIKODND@?$AAd?$AAe?$AA?9?$AAL?$AAU?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DDOCCGFG@?$AAe?$AAn?$AA?9?$AAC?$AAA?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BNOEMJLF@?$AAe?$AAs?$AA?9?$AAG?$AAT?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@EOGNKEK@?$AAf?$AAr?$AA?9?$AAC?$AAH?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FLIDJFHL@?$AAh?$AAr?$AA?9?$AAB?$AAA?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@FMCELNAJ@?$AAs?$AAm?$AAj?$AA?9?$AAN?$AAO?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@JHGLJMGJ@?$AAa?$AAr?$AA?9?$AAD?$AAZ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@JKKFDCNP@?$AAz?$AAh?$AA?9?$AAM?$AAO?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GEEFALPE@?$AAd?$AAe?$AA?9?$AAL?$AAI?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IGEOFBG@?$AAe?$AAn?$AA?9?$AAN?$AAZ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KDBONEHP@?$AAe?$AAs?$AA?9?$AAC?$AAR?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FHMDOHNN@?$AAf?$AAr?$AA?9?$AAL?$AAU?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@NFKKMAFG@?$AAb?$AAs?$AA?9?$AAB?$AAA?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@IMNBEMCI@?$AAs?$AAm?$AAj?$AA?9?$AAS?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DHHMBNDP@?$AAa?$AAr?$AA?9?$AAM?$AAA?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BNBLJCGH@?$AAe?$AAn?$AA?9?$AAI?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GEPAFMDL@?$AAe?$AAs?$AA?9?$AAP?$AAA?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@OJONDMDL@?$AAf?$AAr?$AA?9?$AAM?$AAC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@OBCNFJB@?$AAs?$AAr?$AA?9?$AAB?$AAA?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@KEMEEGPO@?$AAs?$AAm?$AAa?$AA?9?$AAN?$AAO?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@ELMGFODK@?$AAa?$AAr?$AA?9?$AAT?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BHDLHFAF@?$AAe?$AAn?$AA?9?$AAZ?$AAA?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BMGIGLIF@?$AAe?$AAs?$AA?9?$AAD?$AAO?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@CMBHIPBE@?$AAs?$AAr?$AA?9?$AAB?$AAA?$AA?9?$AAC?$AAy?$AAr?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@HEDBLHNP@?$AAs?$AAm?$AAa?$AA?9?$AAS?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DAGCADIM@?$AAa?$AAr?$AA?9?$AAO?$AAM?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FODLMICG@?$AAe?$AAn?$AA?9?$AAJ?$AAM?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DNMLCIHB@?$AAe?$AAs?$AA?9?$AAV?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@EOKHMKJK@?$AAs?$AAm?$AAs?$AA?9?$AAF?$AAI?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CAFJMKOF@?$AAa?$AAr?$AA?9?$AAY?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CBFHIJLI@?$AAe?$AAn?$AA?9?$AAC?$AAB?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BGNFLDN@?$AAe?$AAs?$AA?9?$AAC?$AAO?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@JMPHMAMC@?$AAs?$AAm?$AAn?$AA?9?$AAF?$AAI?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BC@PGMFNIFA@atlTraceException?$AA@	; `string'
PUBLIC	??_C@_1M@JLANABKE@?$AAa?$AAr?$AA?9?$AAS?$AAY?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@HPKGCFGN@?$AAe?$AAn?$AA?9?$AAB?$AAZ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@OLJCMLGM@?$AAe?$AAs?$AA?9?$AAP?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MKKGFKLE@?$AAa?$AAr?$AA?9?$AAJ?$AAO?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@EKPGLDNI@?$AAe?$AAn?$AA?9?$AAT?$AAT?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@OONGHFHE@?$AAe?$AAs?$AA?9?$AAA?$AAR?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@OOJFGBHE@?$AAa?$AAr?$AA?9?$AAL?$AAB?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GCEJHNEG@?$AAe?$AAn?$AA?9?$AAZ?$AAW?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@JNOCAHJI@?$AAe?$AAs?$AA?9?$AAE?$AAC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@JEFHPGGB@?$AAa?$AAr?$AA?9?$AAK?$AAW?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MLKIBJOJ@?$AAe?$AAn?$AA?9?$AAP?$AAH?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BDNIPEND@?$AAe?$AAs?$AA?9?$AAC?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MPNMEKBD@?$AAa?$AAr?$AA?9?$AAA?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KBJALCPI@?$AAe?$AAs?$AA?9?$AAU?$AAY?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LLCCOAGA@?$AAa?$AAr?$AA?9?$AAB?$AAH?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PBFNCDEL@?$AAe?$AAs?$AA?9?$AAP?$AAY?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@EDGINPNP@?$AAa?$AAr?$AA?9?$AAQ?$AAA?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MKDBIIJI@?$AAe?$AAs?$AA?9?$AAB?$AAO?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CPKKEBLD@?$AAe?$AAs?$AA?9?$AAS?$AAV?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@NDBGMMJL@?$AAe?$AAs?$AA?9?$AAH?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@JIJIBHDP@?$AAe?$AAs?$AA?9?$AAN?$AAI?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CGFMKEEK@?$AAe?$AAs?$AA?9?$AAP?$AAR?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@ICJHKIIK@?$AAz?$AAh?$AA?9?$AAC?$AAH?$AAT?$AA?$AA@ ; `string'
PUBLIC	??_C@_15CLNEJCE@?$AAs?$AAr?$AA?$AA@		; `string'
PUBLIC	__pAtlLocaleNameToIndexTable
PUBLIC	??_C@_1M@KAHEKEIG@?$AAa?$AAf?$AA?9?$AAz?$AAa?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GIECOABL@?$AAa?$AAr?$AA?9?$AAa?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BMLMEKGI@?$AAa?$AAr?$AA?9?$AAb?$AAh?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DAPFDGGB@?$AAa?$AAr?$AA?9?$AAd?$AAz?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FJNKGKIG@?$AAa?$AAr?$AA?9?$AAe?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FLGKKCLO@?$AAa?$AAr?$AA?9?$AAi?$AAq?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GNDIPALM@?$AAa?$AAr?$AA?9?$AAj?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DDMJFMGJ@?$AAa?$AAr?$AA?9?$AAk?$AAw?$AA?$AA@ ; `string'
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	??_C@_1M@EJALMLHM@?$AAa?$AAr?$AA?9?$AAl?$AAb?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MOBDBLOC@?$AAa?$AAr?$AA?9?$AAl?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@JAOCLHDH@?$AAa?$AAr?$AA?9?$AAm?$AAa?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@JHPMKJIE@?$AAa?$AAr?$AA?9?$AAo?$AAm?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@OEPGHFNH@?$AAa?$AAr?$AA?9?$AAq?$AAa?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KJDONENM@?$AAa?$AAr?$AA?9?$AAs?$AAa?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DMJDKLKM@?$AAa?$AAr?$AA?9?$AAs?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@OMFIPEDC@?$AAa?$AAr?$AA?9?$AAt?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IHMHGAON@?$AAa?$AAr?$AA?9?$AAy?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@KDCPGJGB@?$AAa?$AAz?$AA?9?$AAa?$AAz?$AA?9?$AAc?$AAy?$AAr?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@IBCKDDOE@?$AAa?$AAz?$AA?9?$AAa?$AAz?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@EGPFDCPD@?$AAb?$AAe?$AA?9?$AAb?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PCMGMCGC@?$AAb?$AAg?$AA?9?$AAb?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BJBMFGOB@?$AAb?$AAn?$AA?9?$AAi?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_0N@BNNILHBE@atlTraceTime?$AA@		; `string'
PUBLIC	??_C@_1BG@EAKMMACD@?$AAb?$AAs?$AA?9?$AAb?$AAa?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KGADAODK@?$AAc?$AAa?$AA?9?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@COAJPDHI@?$AAc?$AAs?$AA?9?$AAc?$AAz?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DHBHFONH@?$AAc?$AAy?$AA?9?$AAg?$AAb?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IMGKELGA@?$AAd?$AAa?$AA?9?$AAd?$AAk?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@NNDGDNGA@?$AAd?$AAe?$AA?9?$AAa?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IKDBHEEM@?$AAd?$AAe?$AA?9?$AAc?$AAh?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GFFOJMCJ@?$AAd?$AAe?$AA?9?$AAd?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MDNLKBPM@?$AAd?$AAe?$AA?9?$AAl?$AAi?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@NJBEEJNL@?$AAd?$AAe?$AA?9?$AAl?$AAu?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@GNNELBAP@?$AAd?$AAi?$AAv?$AA?9?$AAm?$AAv?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@EJLEOGAE@?$AAe?$AAl?$AA?9?$AAg?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GMPONJN@?$AAe?$AAn?$AA?9?$AAa?$AAu?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@NIDIIPGF@?$AAe?$AAn?$AA?9?$AAb?$AAz?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@JEHMIMFO@?$AAe?$AAn?$AA?9?$AAc?$AAa?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IGMJCDLA@?$AAe?$AAn?$AA?9?$AAc?$AAb?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BNFIGBKG@?$AAe?$AAn?$AA?9?$AAg?$AAb?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LKIFDIGP@?$AAe?$AAn?$AA?9?$AAi?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PJKFGCCO@?$AAe?$AAn?$AA?9?$AAj?$AAm?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KPPKEPBO@?$AAe?$AAn?$AA?9?$AAn?$AAz?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GMDGLDOB@?$AAe?$AAn?$AA?9?$AAp?$AAh?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@ONGIBJNA@?$AAe?$AAn?$AA?9?$AAt?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LLODPCMM@?$AAe?$AAn?$AA?9?$AAu?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LAKFNPAN@?$AAe?$AAn?$AA?9?$AAz?$AAa?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MFNHNHEO@?$AAe?$AAn?$AA?9?$AAz?$AAw?$AA?$AA@ ; `string'
PUBLIC	?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
PUBLIC	??_C@_1M@EJEINPHM@?$AAe?$AAs?$AA?9?$AAa?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GNKPCCJA@?$AAe?$AAs?$AA?9?$AAb?$AAo?$AA?$AA@ ; `string'
PUBLIC	?ElevatedComInstanceThreadId@Elevator@GostCrypt@@1KA ; GostCrypt::Elevator::ElevatedComInstanceThreadId
PUBLIC	??_C@_1M@LEEGFONL@?$AAe?$AAs?$AA?9?$AAc?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KGPDPBDF@?$AAe?$AAs?$AA?9?$AAc?$AAo?$AA?$AA@ ; `string'
PUBLIC	?ReferenceCount@Elevator@GostCrypt@@1HA		; GostCrypt::Elevator::ReferenceCount
PUBLIC	??_C@_1M@EIAHOHH@?$AAe?$AAs?$AA?9?$AAc?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LLPGMBIN@?$AAe?$AAs?$AA?9?$AAd?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DKHMKNJA@?$AAe?$AAs?$AA?9?$AAe?$AAc?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GKGFPKAP@?$AAe?$AAs?$AA?9?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LKHKGDLN@?$AAe?$AAs?$AA?9?$AAg?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@HEIIGGJD@?$AAe?$AAs?$AA?9?$AAh?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FBDHPPGD@?$AAe?$AAs?$AA?9?$AAm?$AAx?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DPAGLNDH@?$AAe?$AAs?$AA?9?$AAn?$AAi?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MDGOPGDD@?$AAe?$AAs?$AA?9?$AAp?$AAa?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@EMAMGBGE@?$AAe?$AAs?$AA?9?$AAp?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IBMCAOEC@?$AAe?$AAs?$AA?9?$AAp?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FGMDIJED@?$AAe?$AAs?$AA?9?$AAp?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IIDEOLLL@?$AAe?$AAs?$AA?9?$AAs?$AAv?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GAOBIPA@?$AAe?$AAs?$AA?9?$AAu?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@JKFFICHJ@?$AAe?$AAs?$AA?9?$AAv?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PNMLOJDF@?$AAe?$AAt?$AA?9?$AAe?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GHHLIKEI@?$AAe?$AAu?$AA?9?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PBNONODE@?$AAf?$AAa?$AA?9?$AAi?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_0O@MEOJAOKK@atlTraceCache?$AA@		; `string'
PUBLIC	??_C@_1M@JEEHPMIL@?$AAf?$AAi?$AA?9?$AAf?$AAi?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LMDCNDBA@?$AAf?$AAo?$AA?9?$AAf?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@JKEOHLDK@?$AAf?$AAr?$AA?9?$AAb?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@NOHADPMI@?$AAf?$AAr?$AA?9?$AAc?$AAa?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KDHIHAEC@?$AAf?$AAr?$AA?9?$AAc?$AAh?$AA?$AA@ ; `string'
PUBLIC	___pobjMapEntryFirst
PUBLIC	??_C@_1M@MMBBFGAK@?$AAf?$AAr?$AA?9?$AAf?$AAr?$AA?$AA@ ; `string'
PUBLIC	___pobjMapEntryLast
PUBLIC	??_C@_1M@PAFNENNF@?$AAf?$AAr?$AA?9?$AAl?$AAu?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@EOHDJGDD@?$AAf?$AAr?$AA?9?$AAm?$AAc?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FAPLLOPF@?$AAg?$AAl?$AA?9?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FOPBFLOO@?$AAg?$AAu?$AA?9?$AAi?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KBMCINPM@?$AAh?$AAe?$AA?9?$AAi?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BBPHKFPJ@?$AAh?$AAi?$AA?9?$AAi?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PMBNDPHD@?$AAh?$AAr?$AA?9?$AAb?$AAa?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BPCKOEGE@?$AAh?$AAr?$AA?9?$AAh?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GACBMHKE@?$AAh?$AAu?$AA?9?$AAh?$AAu?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@MILPAJJC@?$AAh?$AAy?$AA?9?$AAa?$AAm?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BABBICEC@?$AAi?$AAd?$AA?9?$AAi?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BIKNHHPF@?$AAi?$AAs?$AA?9?$AAi?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@NMPCJPHE@?$AAi?$AAt?$AA?9?$AAc?$AAh?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GHKGFEDF@?$AAi?$AAt?$AA?9?$AAi?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@NIEJCJJA@?$AAj?$AAa?$AA?9?$AAj?$AAp?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@JILFNBIM@?$AAk?$AAa?$AA?9?$AAg?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PACPMGPH@?$AAk?$AAk?$AA?9?$AAk?$AAz?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IELFGMHA@?$AAk?$AAn?$AA?9?$AAi?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@IBBJHCH@?$AAk?$AAo?$AAk?$AA?9?$AAi?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@DMHAEOGC@?$AAk?$AAo?$AA?9?$AAk?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@HBAHBIGA@?$AAk?$AAy?$AA?9?$AAk?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KPMILCJG@?$AAl?$AAt?$AA?9?$AAl?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BDEKKCA@?$AAl?$AAv?$AA?9?$AAl?$AAv?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@ELCKCCJJ@?$AAm?$AAi?$AA?9?$AAn?$AAz?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CBOOLAPA@?$AAm?$AAk?$AA?9?$AAm?$AAk?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@GPHNBJKN@?$AAm?$AAl?$AA?9?$AAi?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PABJILIG@?$AAm?$AAn?$AA?9?$AAm?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@FGBKKIPG@?$AAm?$AAr?$AA?9?$AAi?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@NDBPDDAL@?$AAm?$AAs?$AA?9?$AAb?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@OPIHOOPI@?$AAm?$AAs?$AA?9?$AAm?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PPDBCNFM@?$AAm?$AAt?$AA?9?$AAm?$AAt?$AA?$AA@ ; `string'
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	??_C@_1M@KDJDKMDD@?$AAn?$AAb?$AA?9?$AAn?$AAo?$AA?$AA@ ; `string'
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	??_C@_1M@KFCFLMJP@?$AAn?$AAl?$AA?9?$AAb?$AAe?$AA?$AA@ ; `string'
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	??_C@_1M@KPOPDDGO@?$AAn?$AAl?$AA?9?$AAn?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@LJKPEMLN@?$AAn?$AAn?$AA?9?$AAn?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BDGHHBFL@?$AAn?$AAs?$AA?9?$AAz?$AAa?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@IDEHOAP@?$AAp?$AAa?$AA?9?$AAi?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@HDBKGOGH@?$AAp?$AAl?$AA?9?$AAp?$AAl?$AA?$AA@ ; `string'
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	___ImageBase:BYTE
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
_BSS	SEGMENT
?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A DD 01H DUP (?) ; GostCrypt::Elevator::ElevatedComInstance
?ElevatedComInstanceThreadId@Elevator@GostCrypt@@1KA DD 01H DUP (?) ; GostCrypt::Elevator::ElevatedComInstanceThreadId
?ReferenceCount@Elevator@GostCrypt@@1HA DD 01H DUP (?)	; GostCrypt::Elevator::ReferenceCount
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
;	COMDAT ??_C@_1M@HDBKGOGH@?$AAp?$AAl?$AA?9?$AAp?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HDBKGOGH@?$AAp?$AAl?$AA?9?$AAp?$AAl?$AA?$AA@ DB 'p', 00H, 'l', 00H
	DB	'-', 00H, 'p', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IDEHOAP@?$AAp?$AAa?$AA?9?$AAi?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IDEHOAP@?$AAp?$AAa?$AA?9?$AAi?$AAn?$AA?$AA@ DB 'p', 00H, 'a', 00H
	DB	'-', 00H, 'i', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BDGHHBFL@?$AAn?$AAs?$AA?9?$AAz?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BDGHHBFL@?$AAn?$AAs?$AA?9?$AAz?$AAa?$AA?$AA@ DB 'n', 00H, 's', 00H
	DB	'-', 00H, 'z', 00H, 'a', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LJKPEMLN@?$AAn?$AAn?$AA?9?$AAn?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LJKPEMLN@?$AAn?$AAn?$AA?9?$AAn?$AAo?$AA?$AA@ DB 'n', 00H, 'n', 00H
	DB	'-', 00H, 'n', 00H, 'o', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KPOPDDGO@?$AAn?$AAl?$AA?9?$AAn?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KPOPDDGO@?$AAn?$AAl?$AA?9?$AAn?$AAl?$AA?$AA@ DB 'n', 00H, 'l', 00H
	DB	'-', 00H, 'n', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KFCFLMJP@?$AAn?$AAl?$AA?9?$AAb?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KFCFLMJP@?$AAn?$AAl?$AA?9?$AAb?$AAe?$AA?$AA@ DB 'n', 00H, 'l', 00H
	DB	'-', 00H, 'b', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KDJDKMDD@?$AAn?$AAb?$AA?9?$AAn?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KDJDKMDD@?$AAn?$AAb?$AA?9?$AAn?$AAo?$AA?$AA@ DB 'n', 00H, 'b', 00H
	DB	'-', 00H, 'n', 00H, 'o', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PPDBCNFM@?$AAm?$AAt?$AA?9?$AAm?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PPDBCNFM@?$AAm?$AAt?$AA?9?$AAm?$AAt?$AA?$AA@ DB 'm', 00H, 't', 00H
	DB	'-', 00H, 'm', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@OPIHOOPI@?$AAm?$AAs?$AA?9?$AAm?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1M@OPIHOOPI@?$AAm?$AAs?$AA?9?$AAm?$AAy?$AA?$AA@ DB 'm', 00H, 's', 00H
	DB	'-', 00H, 'm', 00H, 'y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@NDBPDDAL@?$AAm?$AAs?$AA?9?$AAb?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@NDBPDDAL@?$AAm?$AAs?$AA?9?$AAb?$AAn?$AA?$AA@ DB 'm', 00H, 's', 00H
	DB	'-', 00H, 'b', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FGBKKIPG@?$AAm?$AAr?$AA?9?$AAi?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FGBKKIPG@?$AAm?$AAr?$AA?9?$AAi?$AAn?$AA?$AA@ DB 'm', 00H, 'r', 00H
	DB	'-', 00H, 'i', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PABJILIG@?$AAm?$AAn?$AA?9?$AAm?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PABJILIG@?$AAm?$AAn?$AA?9?$AAm?$AAn?$AA?$AA@ DB 'm', 00H, 'n', 00H
	DB	'-', 00H, 'm', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GPHNBJKN@?$AAm?$AAl?$AA?9?$AAi?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GPHNBJKN@?$AAm?$AAl?$AA?9?$AAi?$AAn?$AA?$AA@ DB 'm', 00H, 'l', 00H
	DB	'-', 00H, 'i', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CBOOLAPA@?$AAm?$AAk?$AA?9?$AAm?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CBOOLAPA@?$AAm?$AAk?$AA?9?$AAm?$AAk?$AA?$AA@ DB 'm', 00H, 'k', 00H
	DB	'-', 00H, 'm', 00H, 'k', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@ELCKCCJJ@?$AAm?$AAi?$AA?9?$AAn?$AAz?$AA?$AA@
CONST	SEGMENT
??_C@_1M@ELCKCCJJ@?$AAm?$AAi?$AA?9?$AAn?$AAz?$AA?$AA@ DB 'm', 00H, 'i', 00H
	DB	'-', 00H, 'n', 00H, 'z', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BDEKKCA@?$AAl?$AAv?$AA?9?$AAl?$AAv?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BDEKKCA@?$AAl?$AAv?$AA?9?$AAl?$AAv?$AA?$AA@ DB 'l', 00H, 'v', 00H
	DB	'-', 00H, 'l', 00H, 'v', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KPMILCJG@?$AAl?$AAt?$AA?9?$AAl?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KPMILCJG@?$AAl?$AAt?$AA?9?$AAl?$AAt?$AA?$AA@ DB 'l', 00H, 't', 00H
	DB	'-', 00H, 'l', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HBAHBIGA@?$AAk?$AAy?$AA?9?$AAk?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HBAHBIGA@?$AAk?$AAy?$AA?9?$AAk?$AAg?$AA?$AA@ DB 'k', 00H, 'y', 00H
	DB	'-', 00H, 'k', 00H, 'g', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DMHAEOGC@?$AAk?$AAo?$AA?9?$AAk?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DMHAEOGC@?$AAk?$AAo?$AA?9?$AAk?$AAr?$AA?$AA@ DB 'k', 00H, 'o', 00H
	DB	'-', 00H, 'k', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@IBBJHCH@?$AAk?$AAo?$AAk?$AA?9?$AAi?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1O@IBBJHCH@?$AAk?$AAo?$AAk?$AA?9?$AAi?$AAn?$AA?$AA@ DB 'k', 00H, 'o'
	DB	00H, 'k', 00H, '-', 00H, 'i', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IELFGMHA@?$AAk?$AAn?$AA?9?$AAi?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IELFGMHA@?$AAk?$AAn?$AA?9?$AAi?$AAn?$AA?$AA@ DB 'k', 00H, 'n', 00H
	DB	'-', 00H, 'i', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PACPMGPH@?$AAk?$AAk?$AA?9?$AAk?$AAz?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PACPMGPH@?$AAk?$AAk?$AA?9?$AAk?$AAz?$AA?$AA@ DB 'k', 00H, 'k', 00H
	DB	'-', 00H, 'k', 00H, 'z', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JILFNBIM@?$AAk?$AAa?$AA?9?$AAg?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@JILFNBIM@?$AAk?$AAa?$AA?9?$AAg?$AAe?$AA?$AA@ DB 'k', 00H, 'a', 00H
	DB	'-', 00H, 'g', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@NIEJCJJA@?$AAj?$AAa?$AA?9?$AAj?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_1M@NIEJCJJA@?$AAj?$AAa?$AA?9?$AAj?$AAp?$AA?$AA@ DB 'j', 00H, 'a', 00H
	DB	'-', 00H, 'j', 00H, 'p', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GHKGFEDF@?$AAi?$AAt?$AA?9?$AAi?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GHKGFEDF@?$AAi?$AAt?$AA?9?$AAi?$AAt?$AA?$AA@ DB 'i', 00H, 't', 00H
	DB	'-', 00H, 'i', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@NMPCJPHE@?$AAi?$AAt?$AA?9?$AAc?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_1M@NMPCJPHE@?$AAi?$AAt?$AA?9?$AAc?$AAh?$AA?$AA@ DB 'i', 00H, 't', 00H
	DB	'-', 00H, 'c', 00H, 'h', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BIKNHHPF@?$AAi?$AAs?$AA?9?$AAi?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BIKNHHPF@?$AAi?$AAs?$AA?9?$AAi?$AAs?$AA?$AA@ DB 'i', 00H, 's', 00H
	DB	'-', 00H, 'i', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BABBICEC@?$AAi?$AAd?$AA?9?$AAi?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BABBICEC@?$AAi?$AAd?$AA?9?$AAi?$AAd?$AA?$AA@ DB 'i', 00H, 'd', 00H
	DB	'-', 00H, 'i', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MILPAJJC@?$AAh?$AAy?$AA?9?$AAa?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MILPAJJC@?$AAh?$AAy?$AA?9?$AAa?$AAm?$AA?$AA@ DB 'h', 00H, 'y', 00H
	DB	'-', 00H, 'a', 00H, 'm', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GACBMHKE@?$AAh?$AAu?$AA?9?$AAh?$AAu?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GACBMHKE@?$AAh?$AAu?$AA?9?$AAh?$AAu?$AA?$AA@ DB 'h', 00H, 'u', 00H
	DB	'-', 00H, 'h', 00H, 'u', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BPCKOEGE@?$AAh?$AAr?$AA?9?$AAh?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BPCKOEGE@?$AAh?$AAr?$AA?9?$AAh?$AAr?$AA?$AA@ DB 'h', 00H, 'r', 00H
	DB	'-', 00H, 'h', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PMBNDPHD@?$AAh?$AAr?$AA?9?$AAb?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PMBNDPHD@?$AAh?$AAr?$AA?9?$AAb?$AAa?$AA?$AA@ DB 'h', 00H, 'r', 00H
	DB	'-', 00H, 'b', 00H, 'a', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BBPHKFPJ@?$AAh?$AAi?$AA?9?$AAi?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BBPHKFPJ@?$AAh?$AAi?$AA?9?$AAi?$AAn?$AA?$AA@ DB 'h', 00H, 'i', 00H
	DB	'-', 00H, 'i', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KBMCINPM@?$AAh?$AAe?$AA?9?$AAi?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KBMCINPM@?$AAh?$AAe?$AA?9?$AAi?$AAl?$AA?$AA@ DB 'h', 00H, 'e', 00H
	DB	'-', 00H, 'i', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FOPBFLOO@?$AAg?$AAu?$AA?9?$AAi?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FOPBFLOO@?$AAg?$AAu?$AA?9?$AAi?$AAn?$AA?$AA@ DB 'g', 00H, 'u', 00H
	DB	'-', 00H, 'i', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FAPLLOPF@?$AAg?$AAl?$AA?9?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FAPLLOPF@?$AAg?$AAl?$AA?9?$AAe?$AAs?$AA?$AA@ DB 'g', 00H, 'l', 00H
	DB	'-', 00H, 'e', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@EOHDJGDD@?$AAf?$AAr?$AA?9?$AAm?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EOHDJGDD@?$AAf?$AAr?$AA?9?$AAm?$AAc?$AA?$AA@ DB 'f', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'c', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PAFNENNF@?$AAf?$AAr?$AA?9?$AAl?$AAu?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PAFNENNF@?$AAf?$AAr?$AA?9?$AAl?$AAu?$AA?$AA@ DB 'f', 00H, 'r', 00H
	DB	'-', 00H, 'l', 00H, 'u', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ??_C@_1M@MMBBFGAK@?$AAf?$AAr?$AA?9?$AAf?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MMBBFGAK@?$AAf?$AAr?$AA?9?$AAf?$AAr?$AA?$AA@ DB 'f', 00H, 'r', 00H
	DB	'-', 00H, 'f', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT ??_C@_1M@KDHIHAEC@?$AAf?$AAr?$AA?9?$AAc?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KDHIHAEC@?$AAf?$AAr?$AA?9?$AAc?$AAh?$AA?$AA@ DB 'f', 00H, 'r', 00H
	DB	'-', 00H, 'c', 00H, 'h', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@NOHADPMI@?$AAf?$AAr?$AA?9?$AAc?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1M@NOHADPMI@?$AAf?$AAr?$AA?9?$AAc?$AAa?$AA?$AA@ DB 'f', 00H, 'r', 00H
	DB	'-', 00H, 'c', 00H, 'a', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JKEOHLDK@?$AAf?$AAr?$AA?9?$AAb?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@JKEOHLDK@?$AAf?$AAr?$AA?9?$AAb?$AAe?$AA?$AA@ DB 'f', 00H, 'r', 00H
	DB	'-', 00H, 'b', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LMDCNDBA@?$AAf?$AAo?$AA?9?$AAf?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LMDCNDBA@?$AAf?$AAo?$AA?9?$AAf?$AAo?$AA?$AA@ DB 'f', 00H, 'o', 00H
	DB	'-', 00H, 'f', 00H, 'o', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JEEHPMIL@?$AAf?$AAi?$AA?9?$AAf?$AAi?$AA?$AA@
CONST	SEGMENT
??_C@_1M@JEEHPMIL@?$AAf?$AAi?$AA?9?$AAf?$AAi?$AA?$AA@ DB 'f', 00H, 'i', 00H
	DB	'-', 00H, 'f', 00H, 'i', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MEOJAOKK@atlTraceCache?$AA@
CONST	SEGMENT
??_C@_0O@MEOJAOKK@atlTraceCache?$AA@ DB 'atlTraceCache', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PBNONODE@?$AAf?$AAa?$AA?9?$AAi?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PBNONODE@?$AAf?$AAa?$AA?9?$AAi?$AAr?$AA?$AA@ DB 'f', 00H, 'a', 00H
	DB	'-', 00H, 'i', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GHHLIKEI@?$AAe?$AAu?$AA?9?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GHHLIKEI@?$AAe?$AAu?$AA?9?$AAe?$AAs?$AA?$AA@ DB 'e', 00H, 'u', 00H
	DB	'-', 00H, 'e', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PNMLOJDF@?$AAe?$AAt?$AA?9?$AAe?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PNMLOJDF@?$AAe?$AAt?$AA?9?$AAe?$AAe?$AA?$AA@ DB 'e', 00H, 't', 00H
	DB	'-', 00H, 'e', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JKFFICHJ@?$AAe?$AAs?$AA?9?$AAv?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@JKFFICHJ@?$AAe?$AAs?$AA?9?$AAv?$AAe?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'v', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GAOBIPA@?$AAe?$AAs?$AA?9?$AAu?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GAOBIPA@?$AAe?$AAs?$AA?9?$AAu?$AAy?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'u', 00H, 'y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IIDEOLLL@?$AAe?$AAs?$AA?9?$AAs?$AAv?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IIDEOLLL@?$AAe?$AAs?$AA?9?$AAs?$AAv?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 's', 00H, 'v', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FGMDIJED@?$AAe?$AAs?$AA?9?$AAp?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FGMDIJED@?$AAe?$AAs?$AA?9?$AAp?$AAy?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'p', 00H, 'y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IBMCAOEC@?$AAe?$AAs?$AA?9?$AAp?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IBMCAOEC@?$AAe?$AAs?$AA?9?$AAp?$AAr?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'p', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@EMAMGBGE@?$AAe?$AAs?$AA?9?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EMAMGBGE@?$AAe?$AAs?$AA?9?$AAp?$AAe?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'p', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MDGOPGDD@?$AAe?$AAs?$AA?9?$AAp?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MDGOPGDD@?$AAe?$AAs?$AA?9?$AAp?$AAa?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'p', 00H, 'a', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DPAGLNDH@?$AAe?$AAs?$AA?9?$AAn?$AAi?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DPAGLNDH@?$AAe?$AAs?$AA?9?$AAn?$AAi?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'n', 00H, 'i', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FBDHPPGD@?$AAe?$AAs?$AA?9?$AAm?$AAx?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FBDHPPGD@?$AAe?$AAs?$AA?9?$AAm?$AAx?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'm', 00H, 'x', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HEIIGGJD@?$AAe?$AAs?$AA?9?$AAh?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HEIIGGJD@?$AAe?$AAs?$AA?9?$AAh?$AAn?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'h', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LKHKGDLN@?$AAe?$AAs?$AA?9?$AAg?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LKHKGDLN@?$AAe?$AAs?$AA?9?$AAg?$AAt?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'g', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GKGFPKAP@?$AAe?$AAs?$AA?9?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GKGFPKAP@?$AAe?$AAs?$AA?9?$AAe?$AAs?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'e', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DKHMKNJA@?$AAe?$AAs?$AA?9?$AAe?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DKHMKNJA@?$AAe?$AAs?$AA?9?$AAe?$AAc?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'e', 00H, 'c', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LLPGMBIN@?$AAe?$AAs?$AA?9?$AAd?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LLPGMBIN@?$AAe?$AAs?$AA?9?$AAd?$AAo?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'd', 00H, 'o', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@EIAHOHH@?$AAe?$AAs?$AA?9?$AAc?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EIAHOHH@?$AAe?$AAs?$AA?9?$AAc?$AAr?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'c', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KGPDPBDF@?$AAe?$AAs?$AA?9?$AAc?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KGPDPBDF@?$AAe?$AAs?$AA?9?$AAc?$AAo?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'c', 00H, 'o', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LEEGFONL@?$AAe?$AAs?$AA?9?$AAc?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LEEGFONL@?$AAe?$AAs?$AA?9?$AAc?$AAl?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'c', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GNKPCCJA@?$AAe?$AAs?$AA?9?$AAb?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GNKPCCJA@?$AAe?$AAs?$AA?9?$AAb?$AAo?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'b', 00H, 'o', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@EJEINPHM@?$AAe?$AAs?$AA?9?$AAa?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EJEINPHM@?$AAe?$AAs?$AA?9?$AAa?$AAr?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'a', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MFNHNHEO@?$AAe?$AAn?$AA?9?$AAz?$AAw?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MFNHNHEO@?$AAe?$AAn?$AA?9?$AAz?$AAw?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'z', 00H, 'w', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LAKFNPAN@?$AAe?$AAn?$AA?9?$AAz?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LAKFNPAN@?$AAe?$AAn?$AA?9?$AAz?$AAa?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'z', 00H, 'a', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LLODPCMM@?$AAe?$AAn?$AA?9?$AAu?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LLODPCMM@?$AAe?$AAn?$AA?9?$AAu?$AAs?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'u', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@ONGIBJNA@?$AAe?$AAn?$AA?9?$AAt?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1M@ONGIBJNA@?$AAe?$AAn?$AA?9?$AAt?$AAt?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 't', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GMDGLDOB@?$AAe?$AAn?$AA?9?$AAp?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GMDGLDOB@?$AAe?$AAn?$AA?9?$AAp?$AAh?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'p', 00H, 'h', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KPPKEPBO@?$AAe?$AAn?$AA?9?$AAn?$AAz?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KPPKEPBO@?$AAe?$AAn?$AA?9?$AAn?$AAz?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'n', 00H, 'z', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PJKFGCCO@?$AAe?$AAn?$AA?9?$AAj?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PJKFGCCO@?$AAe?$AAn?$AA?9?$AAj?$AAm?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'j', 00H, 'm', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LKIFDIGP@?$AAe?$AAn?$AA?9?$AAi?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LKIFDIGP@?$AAe?$AAn?$AA?9?$AAi?$AAe?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'i', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BNFIGBKG@?$AAe?$AAn?$AA?9?$AAg?$AAb?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BNFIGBKG@?$AAe?$AAn?$AA?9?$AAg?$AAb?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'g', 00H, 'b', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IGMJCDLA@?$AAe?$AAn?$AA?9?$AAc?$AAb?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IGMJCDLA@?$AAe?$AAn?$AA?9?$AAc?$AAb?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'c', 00H, 'b', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JEHMIMFO@?$AAe?$AAn?$AA?9?$AAc?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1M@JEHMIMFO@?$AAe?$AAn?$AA?9?$AAc?$AAa?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'c', 00H, 'a', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@NIDIIPGF@?$AAe?$AAn?$AA?9?$AAb?$AAz?$AA?$AA@
CONST	SEGMENT
??_C@_1M@NIDIIPGF@?$AAe?$AAn?$AA?9?$AAb?$AAz?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'b', 00H, 'z', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GMPONJN@?$AAe?$AAn?$AA?9?$AAa?$AAu?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GMPONJN@?$AAe?$AAn?$AA?9?$AAa?$AAu?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'a', 00H, 'u', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@EJLEOGAE@?$AAe?$AAl?$AA?9?$AAg?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EJLEOGAE@?$AAe?$AAl?$AA?9?$AAg?$AAr?$AA?$AA@ DB 'e', 00H, 'l', 00H
	DB	'-', 00H, 'g', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@GNNELBAP@?$AAd?$AAi?$AAv?$AA?9?$AAm?$AAv?$AA?$AA@
CONST	SEGMENT
??_C@_1O@GNNELBAP@?$AAd?$AAi?$AAv?$AA?9?$AAm?$AAv?$AA?$AA@ DB 'd', 00H, 'i'
	DB	00H, 'v', 00H, '-', 00H, 'm', 00H, 'v', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@NJBEEJNL@?$AAd?$AAe?$AA?9?$AAl?$AAu?$AA?$AA@
CONST	SEGMENT
??_C@_1M@NJBEEJNL@?$AAd?$AAe?$AA?9?$AAl?$AAu?$AA?$AA@ DB 'd', 00H, 'e', 00H
	DB	'-', 00H, 'l', 00H, 'u', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MDNLKBPM@?$AAd?$AAe?$AA?9?$AAl?$AAi?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MDNLKBPM@?$AAd?$AAe?$AA?9?$AAl?$AAi?$AA?$AA@ DB 'd', 00H, 'e', 00H
	DB	'-', 00H, 'l', 00H, 'i', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GFFOJMCJ@?$AAd?$AAe?$AA?9?$AAd?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GFFOJMCJ@?$AAd?$AAe?$AA?9?$AAd?$AAe?$AA?$AA@ DB 'd', 00H, 'e', 00H
	DB	'-', 00H, 'd', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IKDBHEEM@?$AAd?$AAe?$AA?9?$AAc?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IKDBHEEM@?$AAd?$AAe?$AA?9?$AAc?$AAh?$AA?$AA@ DB 'd', 00H, 'e', 00H
	DB	'-', 00H, 'c', 00H, 'h', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@NNDGDNGA@?$AAd?$AAe?$AA?9?$AAa?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1M@NNDGDNGA@?$AAd?$AAe?$AA?9?$AAa?$AAt?$AA?$AA@ DB 'd', 00H, 'e', 00H
	DB	'-', 00H, 'a', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IMGKELGA@?$AAd?$AAa?$AA?9?$AAd?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IMGKELGA@?$AAd?$AAa?$AA?9?$AAd?$AAk?$AA?$AA@ DB 'd', 00H, 'a', 00H
	DB	'-', 00H, 'd', 00H, 'k', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DHBHFONH@?$AAc?$AAy?$AA?9?$AAg?$AAb?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DHBHFONH@?$AAc?$AAy?$AA?9?$AAg?$AAb?$AA?$AA@ DB 'c', 00H, 'y', 00H
	DB	'-', 00H, 'g', 00H, 'b', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@COAJPDHI@?$AAc?$AAs?$AA?9?$AAc?$AAz?$AA?$AA@
CONST	SEGMENT
??_C@_1M@COAJPDHI@?$AAc?$AAs?$AA?9?$AAc?$AAz?$AA?$AA@ DB 'c', 00H, 's', 00H
	DB	'-', 00H, 'c', 00H, 'z', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KGADAODK@?$AAc?$AAa?$AA?9?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KGADAODK@?$AAc?$AAa?$AA?9?$AAe?$AAs?$AA?$AA@ DB 'c', 00H, 'a', 00H
	DB	'-', 00H, 'e', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@EAKMMACD@?$AAb?$AAs?$AA?9?$AAb?$AAa?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@EAKMMACD@?$AAb?$AAs?$AA?9?$AAb?$AAa?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@ DB 'b'
	DB	00H, 's', 00H, '-', 00H, 'b', 00H, 'a', 00H, '-', 00H, 'l', 00H
	DB	'a', 00H, 't', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BNNILHBE@atlTraceTime?$AA@
CONST	SEGMENT
??_C@_0N@BNNILHBE@atlTraceTime?$AA@ DB 'atlTraceTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BJBMFGOB@?$AAb?$AAn?$AA?9?$AAi?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BJBMFGOB@?$AAb?$AAn?$AA?9?$AAi?$AAn?$AA?$AA@ DB 'b', 00H, 'n', 00H
	DB	'-', 00H, 'i', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PCMGMCGC@?$AAb?$AAg?$AA?9?$AAb?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PCMGMCGC@?$AAb?$AAg?$AA?9?$AAb?$AAg?$AA?$AA@ DB 'b', 00H, 'g', 00H
	DB	'-', 00H, 'b', 00H, 'g', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@EGPFDCPD@?$AAb?$AAe?$AA?9?$AAb?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EGPFDCPD@?$AAb?$AAe?$AA?9?$AAb?$AAy?$AA?$AA@ DB 'b', 00H, 'e', 00H
	DB	'-', 00H, 'b', 00H, 'y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@IBCKDDOE@?$AAa?$AAz?$AA?9?$AAa?$AAz?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@IBCKDDOE@?$AAa?$AAz?$AA?9?$AAa?$AAz?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@ DB 'a'
	DB	00H, 'z', 00H, '-', 00H, 'a', 00H, 'z', 00H, '-', 00H, 'l', 00H
	DB	'a', 00H, 't', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@KDCPGJGB@?$AAa?$AAz?$AA?9?$AAa?$AAz?$AA?9?$AAc?$AAy?$AAr?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@KDCPGJGB@?$AAa?$AAz?$AA?9?$AAa?$AAz?$AA?9?$AAc?$AAy?$AAr?$AAl?$AA?$AA@ DB 'a'
	DB	00H, 'z', 00H, '-', 00H, 'a', 00H, 'z', 00H, '-', 00H, 'c', 00H
	DB	'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IHMHGAON@?$AAa?$AAr?$AA?9?$AAy?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IHMHGAON@?$AAa?$AAr?$AA?9?$AAy?$AAe?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'y', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@OMFIPEDC@?$AAa?$AAr?$AA?9?$AAt?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@OMFIPEDC@?$AAa?$AAr?$AA?9?$AAt?$AAn?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 't', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DMJDKLKM@?$AAa?$AAr?$AA?9?$AAs?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DMJDKLKM@?$AAa?$AAr?$AA?9?$AAs?$AAy?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 's', 00H, 'y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KJDONENM@?$AAa?$AAr?$AA?9?$AAs?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KJDONENM@?$AAa?$AAr?$AA?9?$AAs?$AAa?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 's', 00H, 'a', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@OEPGHFNH@?$AAa?$AAr?$AA?9?$AAq?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1M@OEPGHFNH@?$AAa?$AAr?$AA?9?$AAq?$AAa?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'q', 00H, 'a', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JHPMKJIE@?$AAa?$AAr?$AA?9?$AAo?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_1M@JHPMKJIE@?$AAa?$AAr?$AA?9?$AAo?$AAm?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'o', 00H, 'm', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JAOCLHDH@?$AAa?$AAr?$AA?9?$AAm?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1M@JAOCLHDH@?$AAa?$AAr?$AA?9?$AAm?$AAa?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MOBDBLOC@?$AAa?$AAr?$AA?9?$AAl?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MOBDBLOC@?$AAa?$AAr?$AA?9?$AAl?$AAy?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'l', 00H, 'y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@EJALMLHM@?$AAa?$AAr?$AA?9?$AAl?$AAb?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EJALMLHM@?$AAa?$AAr?$AA?9?$AAl?$AAb?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'l', 00H, 'b', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DDMJFMGJ@?$AAa?$AAr?$AA?9?$AAk?$AAw?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DDMJFMGJ@?$AAa?$AAr?$AA?9?$AAk?$AAw?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'k', 00H, 'w', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GNDIPALM@?$AAa?$AAr?$AA?9?$AAj?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GNDIPALM@?$AAa?$AAr?$AA?9?$AAj?$AAo?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'j', 00H, 'o', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FLGKKCLO@?$AAa?$AAr?$AA?9?$AAi?$AAq?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FLGKKCLO@?$AAa?$AAr?$AA?9?$AAi?$AAq?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'i', 00H, 'q', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FJNKGKIG@?$AAa?$AAr?$AA?9?$AAe?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FJNKGKIG@?$AAa?$AAr?$AA?9?$AAe?$AAg?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'e', 00H, 'g', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DAPFDGGB@?$AAa?$AAr?$AA?9?$AAd?$AAz?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DAPFDGGB@?$AAa?$AAr?$AA?9?$AAd?$AAz?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'd', 00H, 'z', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BMLMEKGI@?$AAa?$AAr?$AA?9?$AAb?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BMLMEKGI@?$AAa?$AAr?$AA?9?$AAb?$AAh?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'b', 00H, 'h', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GIECOABL@?$AAa?$AAr?$AA?9?$AAa?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GIECOABL@?$AAa?$AAr?$AA?9?$AAa?$AAe?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'a', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KAHEKEIG@?$AAa?$AAf?$AA?9?$AAz?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KAHEKEIG@?$AAa?$AAf?$AA?9?$AAz?$AAa?$AA?$AA@ DB 'a', 00H, 'f', 00H
	DB	'-', 00H, 'z', 00H, 'a', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT __pAtlLocaleNameToIndexTable
CONST	SEGMENT
__pAtlLocaleNameToIndexTable DD FLAT:??_C@_11LOCGONAA@?$AA?$AA@
	DD	042H
	DD	FLAT:??_C@_15JDNICKHM@?$AAa?$AAf?$AA?$AA@
	DD	02cH
	DD	FLAT:??_C@_1M@KAHEKEIG@?$AAa?$AAf?$AA?9?$AAz?$AAa?$AA?$AA@
	DD	071H
	DD	FLAT:??_C@_15EMKDOKLE@?$AAa?$AAr?$AA?$AA@
	DD	00H
	DD	FLAT:??_C@_1M@GIECOABL@?$AAa?$AAr?$AA?9?$AAa?$AAe?$AA?$AA@
	DD	0d8H
	DD	FLAT:??_C@_1M@BMLMEKGI@?$AAa?$AAr?$AA?9?$AAb?$AAh?$AA?$AA@
	DD	0daH
	DD	FLAT:??_C@_1M@DAPFDGGB@?$AAa?$AAr?$AA?9?$AAd?$AAz?$AA?$AA@
	DD	0b1H
	DD	FLAT:??_C@_1M@FJNKGKIG@?$AAa?$AAr?$AA?9?$AAe?$AAg?$AA?$AA@
	DD	0a0H
	DD	FLAT:??_C@_1M@FLGKKCLO@?$AAa?$AAr?$AA?9?$AAi?$AAq?$AA?$AA@
	DD	08fH
	DD	FLAT:??_C@_1M@GNDIPALM@?$AAa?$AAr?$AA?9?$AAj?$AAo?$AA?$AA@
	DD	0cfH
	DD	FLAT:??_C@_1M@DDMJFMGJ@?$AAa?$AAr?$AA?9?$AAk?$AAw?$AA?$AA@
	DD	0d5H
	DD	FLAT:??_C@_1M@EJALMLHM@?$AAa?$AAr?$AA?9?$AAl?$AAb?$AA?$AA@
	DD	0d2H
	DD	FLAT:??_C@_1M@MOBDBLOC@?$AAa?$AAr?$AA?9?$AAl?$AAy?$AA?$AA@
	DD	0a9H
	DD	FLAT:??_C@_1M@JAOCLHDH@?$AAa?$AAr?$AA?9?$AAm?$AAa?$AA?$AA@
	DD	0b9H
	DD	FLAT:??_C@_1M@JHPMKJIE@?$AAa?$AAr?$AA?9?$AAo?$AAm?$AA?$AA@
	DD	0c4H
	DD	FLAT:??_C@_1M@OEPGHFNH@?$AAa?$AAr?$AA?9?$AAq?$AAa?$AA?$AA@
	DD	0dcH
	DD	FLAT:??_C@_1M@KJDONENM@?$AAa?$AAr?$AA?9?$AAs?$AAa?$AA?$AA@
	DD	043H
	DD	FLAT:??_C@_1M@DMJDKLKM@?$AAa?$AAr?$AA?9?$AAs?$AAy?$AA?$AA@
	DD	0ccH
	DD	FLAT:??_C@_1M@OMFIPEDC@?$AAa?$AAr?$AA?9?$AAt?$AAn?$AA?$AA@
	DD	0bfH
	DD	FLAT:??_C@_1M@IHMHGAON@?$AAa?$AAr?$AA?9?$AAy?$AAe?$AA?$AA@
	DD	0c8H
	DD	FLAT:??_C@_15IJBHMCFL@?$AAa?$AAz?$AA?$AA@
	DD	029H
	DD	FLAT:??_C@_1BG@KDCPGJGB@?$AAa?$AAz?$AA?9?$AAa?$AAz?$AA?9?$AAc?$AAy?$AAr?$AAl?$AA?$AA@
	DD	09bH
	DD	FLAT:??_C@_1BG@IBCKDDOE@?$AAa?$AAz?$AA?9?$AAa?$AAz?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@
	DD	06bH
	DD	FLAT:??_C@_15HPJPHDM@?$AAb?$AAe?$AA?$AA@
	DD	021H
	DD	FLAT:??_C@_1M@EGPFDCPD@?$AAb?$AAe?$AA?9?$AAb?$AAy?$AA?$AA@
	DD	063H
	DD	FLAT:??_C@_15KNPADPLH@?$AAb?$AAg?$AA?$AA@
	DD	01H
	DD	FLAT:??_C@_1M@PCMGMCGC@?$AAb?$AAg?$AA?9?$AAb?$AAg?$AA?$AA@
	DD	044H
	DD	FLAT:??_C@_1M@BJBMFGOB@?$AAb?$AAn?$AA?9?$AAi?$AAn?$AA?$AA@
	DD	07dH
	DD	FLAT:??_C@_1BG@EAKMMACD@?$AAb?$AAs?$AA?9?$AAb?$AAa?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@
	DD	0b7H
	DD	FLAT:??_C@_15EDMHLDMO@?$AAc?$AAa?$AA?$AA@
	DD	02H
	DD	FLAT:??_C@_1M@KGADAODK@?$AAc?$AAa?$AA?9?$AAe?$AAs?$AA?$AA@
	DD	045H
	DD	FLAT:??_C@_15LJNHCMNK@?$AAc?$AAs?$AA?$AA@
	DD	04H
	DD	FLAT:??_C@_1M@COAJPDHI@?$AAc?$AAs?$AA?9?$AAc?$AAz?$AA?$AA@
	DD	047H
	DD	FLAT:??_C@_1M@DHBHFONH@?$AAc?$AAy?$AA?9?$AAg?$AAb?$AA?$AA@
	DD	087H
	DD	FLAT:??_C@_15FOMCIDHG@?$AAd?$AAa?$AA?$AA@
	DD	05H
	DD	FLAT:??_C@_1M@IMGKELGA@?$AAd?$AAa?$AA?9?$AAd?$AAk?$AA?$AA@
	DD	048H
	DD	FLAT:??_C@_15NBKABECB@?$AAd?$AAe?$AA?$AA@
	DD	06H
	DD	FLAT:??_C@_1M@NNDGDNGA@?$AAd?$AAe?$AA?9?$AAa?$AAt?$AA?$AA@
	DD	0a2H
	DD	FLAT:??_C@_1M@IKDBHEEM@?$AAd?$AAe?$AA?9?$AAc?$AAh?$AA?$AA@
	DD	091H
	DD	FLAT:??_C@_1M@GFFOJMCJ@?$AAd?$AAe?$AA?9?$AAd?$AAe?$AA?$AA@
	DD	049H
	DD	FLAT:??_C@_1M@MDNLKBPM@?$AAd?$AAe?$AA?9?$AAl?$AAi?$AA?$AA@
	DD	0b3H
	DD	FLAT:??_C@_1M@NJBEEJNL@?$AAd?$AAe?$AA?9?$AAl?$AAu?$AA?$AA@
	DD	0abH
	DD	FLAT:??_C@_17KPNDCPAF@?$AAd?$AAi?$AAv?$AA?$AA@
	DD	041H
	DD	FLAT:??_C@_1O@GNNELBAP@?$AAd?$AAi?$AAv?$AA?9?$AAm?$AAv?$AA?$AA@
	DD	08bH
	DD	FLAT:??_C@_15GHPEIIAO@?$AAe?$AAl?$AA?$AA@
	DD	07H
	DD	FLAT:??_C@_1M@EJLEOGAE@?$AAe?$AAl?$AA?9?$AAg?$AAr?$AA?$AA@
	DD	04aH
	DD	FLAT:??_C@_15MNPNEAIF@?$AAe?$AAn?$AA?$AA@
	DD	08H
	DD	FLAT:??_C@_1M@GMPONJN@?$AAe?$AAn?$AA?9?$AAa?$AAu?$AA?$AA@
	DD	0a3H
	DD	FLAT:??_C@_1M@NIDIIPGF@?$AAe?$AAn?$AA?9?$AAb?$AAz?$AA?$AA@
	DD	0cdH
	DD	FLAT:??_C@_1M@JEHMIMFO@?$AAe?$AAn?$AA?9?$AAc?$AAa?$AA?$AA@
	DD	0acH
	DD	FLAT:??_C@_1M@IGMJCDLA@?$AAe?$AAn?$AA?9?$AAc?$AAb?$AA?$AA@
	DD	0c9H
	DD	FLAT:??_C@_1M@BNFIGBKG@?$AAe?$AAn?$AA?9?$AAg?$AAb?$AA?$AA@
	DD	092H
	DD	FLAT:??_C@_1M@LKIFDIGP@?$AAe?$AAn?$AA?9?$AAi?$AAe?$AA?$AA@
	DD	0baH
	DD	FLAT:??_C@_1M@PJKFGCCO@?$AAe?$AAn?$AA?9?$AAj?$AAm?$AA?$AA@
	DD	0c5H
	DD	FLAT:??_C@_1M@KPPKEPBO@?$AAe?$AAn?$AA?9?$AAn?$AAz?$AA?$AA@
	DD	0b4H
	DD	FLAT:??_C@_1M@GMDGLDOB@?$AAe?$AAn?$AA?9?$AAp?$AAh?$AA?$AA@
	DD	0d6H
	DD	FLAT:??_C@_1M@ONGIBJNA@?$AAe?$AAn?$AA?9?$AAt?$AAt?$AA?$AA@
	DD	0d0H
	DD	FLAT:??_C@_1M@LLODPCMM@?$AAe?$AAn?$AA?9?$AAu?$AAs?$AA?$AA@
	DD	04bH
	DD	FLAT:??_C@_1M@LAKFNPAN@?$AAe?$AAn?$AA?9?$AAz?$AAa?$AA?$AA@
	DD	0c0H
	DD	FLAT:??_C@_1M@MFNHNHEO@?$AAe?$AAn?$AA?9?$AAz?$AAw?$AA?$AA@
	DD	0d3H
	DD	FLAT:??_C@_15GPIOMPMH@?$AAe?$AAs?$AA?$AA@
	DD	09H
	DD	FLAT:??_C@_1M@EJEINPHM@?$AAe?$AAs?$AA?9?$AAa?$AAr?$AA?$AA@
	DD	0d1H
	DD	FLAT:??_C@_1M@GNKPCCJA@?$AAe?$AAs?$AA?9?$AAb?$AAo?$AA?$AA@
	DD	0ddH
	DD	FLAT:??_C@_1M@LEEGFONL@?$AAe?$AAs?$AA?9?$AAc?$AAl?$AA?$AA@
	DD	0d7H
	DD	FLAT:??_C@_1M@KGPDPBDF@?$AAe?$AAs?$AA?9?$AAc?$AAo?$AA?$AA@
	DD	0caH
	DD	FLAT:??_C@_1M@EIAHOHH@?$AAe?$AAs?$AA?9?$AAc?$AAr?$AA?$AA@
	DD	0b5H
	DD	FLAT:??_C@_1M@LLPGMBIN@?$AAe?$AAs?$AA?9?$AAd?$AAo?$AA?$AA@
	DD	0c1H
	DD	FLAT:??_C@_1M@DKHMKNJA@?$AAe?$AAs?$AA?9?$AAe?$AAc?$AA?$AA@
	DD	0d4H
	DD	FLAT:??_C@_1M@GKGFPKAP@?$AAe?$AAs?$AA?9?$AAe?$AAs?$AA?$AA@
	DD	0a4H
	DD	FLAT:??_C@_1M@LKHKGDLN@?$AAe?$AAs?$AA?9?$AAg?$AAt?$AA?$AA@
	DD	0adH
	DD	FLAT:??_C@_1M@HEIIGGJD@?$AAe?$AAs?$AA?9?$AAh?$AAn?$AA?$AA@
	DD	0dfH
	DD	FLAT:??_C@_1M@FBDHPPGD@?$AAe?$AAs?$AA?9?$AAm?$AAx?$AA?$AA@
	DD	093H
	DD	FLAT:??_C@_1M@DPAGLNDH@?$AAe?$AAs?$AA?9?$AAn?$AAi?$AA?$AA@
	DD	0e0H
	DD	FLAT:??_C@_1M@MDGOPGDD@?$AAe?$AAs?$AA?9?$AAp?$AAa?$AA?$AA@
	DD	0bbH
	DD	FLAT:??_C@_1M@EMAMGBGE@?$AAe?$AAs?$AA?9?$AAp?$AAe?$AA?$AA@
	DD	0ceH
	DD	FLAT:??_C@_1M@IBMCAOEC@?$AAe?$AAs?$AA?9?$AAp?$AAr?$AA?$AA@
	DD	0e1H
	DD	FLAT:??_C@_1M@FGMDIJED@?$AAe?$AAs?$AA?9?$AAp?$AAy?$AA?$AA@
	DD	0dbH
	DD	FLAT:??_C@_1M@IIDEOLLL@?$AAe?$AAs?$AA?9?$AAs?$AAv?$AA?$AA@
	DD	0deH
	DD	FLAT:??_C@_1M@GAOBIPA@?$AAe?$AAs?$AA?9?$AAu?$AAy?$AA?$AA@
	DD	0d9H
	DD	FLAT:??_C@_1M@JKFFICHJ@?$AAe?$AAs?$AA?9?$AAv?$AAe?$AA?$AA@
	DD	0c6H
	DD	FLAT:??_C@_15PCFJPHHO@?$AAe?$AAt?$AA?$AA@
	DD	023H
	DD	FLAT:??_C@_1M@PNMLOJDF@?$AAe?$AAt?$AA?9?$AAe?$AAe?$AA?$AA@
	DD	065H
	DD	FLAT:??_C@_15EKOFJABL@?$AAe?$AAu?$AA?$AA@
	DD	02aH
	DD	FLAT:??_C@_1M@GHHLIKEI@?$AAe?$AAu?$AA?9?$AAe?$AAs?$AA?$AA@
	DD	06cH
	DD	FLAT:??_C@_15BDAKCCHN@?$AAf?$AAa?$AA?$AA@
	DD	026H
	DD	FLAT:??_C@_1M@PBNONODE@?$AAf?$AAa?$AA?9?$AAi?$AAr?$AA?$AA@
	DD	068H
	DD	FLAT:??_C@_15NGLOAKJC@?$AAf?$AAi?$AA?$AA@
	DD	0aH
	DD	FLAT:??_C@_1M@JEEHPMIL@?$AAf?$AAi?$AA?9?$AAf?$AAi?$AA?$AA@
	DD	04cH
	DD	FLAT:??_C@_15PDNFFFEO@?$AAf?$AAo?$AA?$AA@
	DD	02eH
	DD	FLAT:??_C@_1M@LMDCNDBA@?$AAf?$AAo?$AA?9?$AAf?$AAo?$AA?$AA@
	DD	073H
	DD	FLAT:??_C@_15FBKGNKAM@?$AAf?$AAr?$AA?$AA@
	DD	0bH
	DD	FLAT:??_C@_1M@JKEOHLDK@?$AAf?$AAr?$AA?9?$AAb?$AAe?$AA?$AA@
	DD	094H
	DD	FLAT:??_C@_1M@NOHADPMI@?$AAf?$AAr?$AA?9?$AAc?$AAa?$AA?$AA@
	DD	0a5H
	DD	FLAT:??_C@_1M@KDHIHAEC@?$AAf?$AAr?$AA?9?$AAc?$AAh?$AA?$AA@
	DD	0aeH
	DD	FLAT:??_C@_1M@MMBBFGAK@?$AAf?$AAr?$AA?9?$AAf?$AAr?$AA?$AA@
	DD	04dH
	DD	FLAT:??_C@_1M@PAFNENNF@?$AAf?$AAr?$AA?9?$AAl?$AAu?$AA?$AA@
	DD	0b6H
	DD	FLAT:??_C@_1M@EOHDJGDD@?$AAf?$AAr?$AA?9?$AAm?$AAc?$AA?$AA@
	DD	0bcH
	DD	FLAT:??_C@_15CKDMCJAF@?$AAg?$AAl?$AA?$AA@
	DD	03eH
	DD	FLAT:??_C@_1M@FAPLLOPF@?$AAg?$AAl?$AA?9?$AAe?$AAs?$AA?$AA@
	DD	088H
	DD	FLAT:??_C@_15HCNDBBA@?$AAg?$AAu?$AA?$AA@
	DD	037H
	DD	FLAT:??_C@_1M@FOPBFLOO@?$AAg?$AAu?$AA?9?$AAi?$AAn?$AA?$AA@
	DD	07fH
	DD	FLAT:??_C@_15KGGCNEFK@?$AAh?$AAe?$AA?$AA@
	DD	0cH
	DD	FLAT:??_C@_1M@KBMCINPM@?$AAh?$AAe?$AA?9?$AAi?$AAl?$AA?$AA@
	DD	04eH
	DD	FLAT:??_C@_15OMLEGLOC@?$AAh?$AAi?$AA?$AA@
	DD	02fH
	DD	FLAT:??_C@_1M@BBPHKFPJ@?$AAh?$AAi?$AA?9?$AAi?$AAn?$AA?$AA@
	DD	074H
	DD	FLAT:??_C@_15GLKMLLHM@?$AAh?$AAr?$AA?$AA@
	DD	018H
	DD	FLAT:??_C@_1M@PMBNDPHD@?$AAh?$AAr?$AA?9?$AAb?$AAa?$AA?$AA@
	DD	0afH
	DD	FLAT:??_C@_1M@BPCKOEGE@?$AAh?$AAr?$AA?9?$AAh?$AAr?$AA?$AA@
	DD	05aH
	DD	FLAT:??_C@_15PGHLIDMF@?$AAh?$AAu?$AA?$AA@
	DD	0dH
	DD	FLAT:??_C@_1M@GACBMHKE@?$AAh?$AAu?$AA?9?$AAh?$AAu?$AA?$AA@
	DD	04fH
	DD	FLAT:??_C@_15LMKNDMHN@?$AAh?$AAy?$AA?$AA@
	DD	028H
	DD	FLAT:??_C@_1M@MILPAJJC@?$AAh?$AAy?$AA?9?$AAa?$AAm?$AA?$AA@
	DD	06aH
	DD	FLAT:??_C@_15NFICGAJK@?$AAi?$AAd?$AA?$AA@
	DD	01fH
	DD	FLAT:??_C@_1M@BABBICEC@?$AAi?$AAd?$AA?9?$AAi?$AAd?$AA?$AA@
	DD	061H
	DD	FLAT:??_C@_15BIEMAPLM@?$AAi?$AAs?$AA?$AA@
	DD	0eH
	DD	FLAT:??_C@_1M@BIKNHHPF@?$AAi?$AAs?$AA?9?$AAi?$AAs?$AA?$AA@
	DD	050H
	DD	FLAT:??_C@_15IFJLDHAF@?$AAi?$AAt?$AA?$AA@
	DD	0fH
	DD	FLAT:??_C@_1M@NMPCJPHE@?$AAi?$AAt?$AA?9?$AAc?$AAh?$AA?$AA@
	DD	095H
	DD	FLAT:??_C@_1M@GHKGFEDF@?$AAi?$AAt?$AA?9?$AAi?$AAt?$AA?$AA@
	DD	051H
	DD	FLAT:??_C@_15GEMIOCAG@?$AAj?$AAa?$AA?$AA@
	DD	010H
	DD	FLAT:??_C@_1M@NIEJCJJA@?$AAj?$AAa?$AA?9?$AAj?$AAp?$AA?$AA@
	DD	052H
	DD	FLAT:??_C@_15KPJEDBKD@?$AAk?$AAa?$AA?$AA@
	DD	02dH
	DD	FLAT:??_C@_1M@JILFNBIM@?$AAk?$AAa?$AA?9?$AAg?$AAe?$AA?$AA@
	DD	072H
	DD	FLAT:??_C@_15MACJNBMH@?$AAk?$AAk?$AA?$AA@
	DD	031H
	DD	FLAT:??_C@_1M@PACPMGPH@?$AAk?$AAk?$AA?9?$AAk?$AAz?$AA?$AA@
	DD	078H
	DD	FLAT:??_C@_15PHPHCBPF@?$AAk?$AAn?$AA?$AA@
	DD	03aH
	DD	FLAT:??_C@_1M@IELFGMHA@?$AAk?$AAn?$AA?9?$AAi?$AAn?$AA?$AA@
	DD	082H
	DD	FLAT:??_C@_15EPELEGJA@?$AAk?$AAo?$AA?$AA@
	DD	011H
	DD	FLAT:??_C@_17CNJFBPG@?$AAk?$AAo?$AAk?$AA?$AA@
	DD	03fH
	DD	FLAT:??_C@_1O@IBBJHCH@?$AAk?$AAo?$AAk?$AA?9?$AAi?$AAn?$AA?$AA@
	DD	089H
	DD	FLAT:??_C@_1M@DMHAEOGC@?$AAk?$AAo?$AA?9?$AAk?$AAr?$AA?$AA@
	DD	053H
	DD	FLAT:??_C@_15DKDJEOND@?$AAk?$AAy?$AA?$AA@
	DD	032H
	DD	FLAT:??_C@_1M@HBAHBIGA@?$AAk?$AAy?$AA?9?$AAk?$AAg?$AA?$AA@
	DD	079H
	DD	FLAT:??_C@_15NFFGKGLG@?$AAl?$AAt?$AA?$AA@
	DD	025H
	DD	FLAT:??_C@_1M@KPMILCJG@?$AAl?$AAt?$AA?9?$AAl?$AAt?$AA?$AA@
	DD	067H
	DD	FLAT:??_C@_15HPFPGODN@?$AAl?$AAv?$AA?$AA@
	DD	024H
	DD	FLAT:??_C@_1M@BDEKKCA@?$AAl?$AAv?$AA?9?$AAl?$AAv?$AA?$AA@
	DD	066H
	DD	FLAT:??_C@_1M@ELCKCCJJ@?$AAm?$AAi?$AA?9?$AAn?$AAz?$AA?$AA@
	DD	08eH
	DD	FLAT:??_C@_15BGHADCNK@?$AAm?$AAk?$AA?$AA@
	DD	02bH
	DD	FLAT:??_C@_1M@CBOOLAPA@?$AAm?$AAk?$AA?9?$AAm?$AAk?$AA?$AA@
	DD	06dH
	DD	FLAT:??_C@_1M@GPHNBJKN@?$AAm?$AAl?$AA?9?$AAi?$AAn?$AA?$AA@
	DD	083H
	DD	FLAT:??_C@_15CBKOMCOI@?$AAm?$AAn?$AA?$AA@
	DD	03dH
	DD	FLAT:??_C@_1M@PABJILIG@?$AAm?$AAn?$AA?9?$AAm?$AAn?$AA?$AA@
	DD	086H
	DD	FLAT:??_C@_15DLGBCKMP@?$AAm?$AAr?$AA?$AA@
	DD	03bH
	DD	FLAT:??_C@_1M@FGBKKIPG@?$AAm?$AAr?$AA?9?$AAi?$AAn?$AA?$AA@
	DD	084H
	DD	FLAT:??_C@_15IDNNENKK@?$AAm?$AAs?$AA?$AA@
	DD	030H
	DD	FLAT:??_C@_1M@NDBPDDAL@?$AAm?$AAs?$AA?9?$AAb?$AAn?$AA?$AA@
	DD	09dH
	DD	FLAT:??_C@_1M@OPIHOOPI@?$AAm?$AAs?$AA?9?$AAm?$AAy?$AA?$AA@
	DD	077H
	DD	FLAT:??_C@_1M@PPDBCNFM@?$AAm?$AAt?$AA?9?$AAm?$AAt?$AA?$AA@
	DD	075H
	DD	FLAT:??_C@_1M@KDJDKMDD@?$AAn?$AAb?$AA?9?$AAn?$AAo?$AA?$AA@
	DD	055H
	DD	FLAT:??_C@_15NDDHIMN@?$AAn?$AAl?$AA?$AA@
	DD	012H
	DD	FLAT:??_C@_1M@KFCFLMJP@?$AAn?$AAl?$AA?9?$AAb?$AAe?$AA?$AA@
	DD	096H
	DD	FLAT:??_C@_1M@KPOPDDGO@?$AAn?$AAl?$AA?9?$AAn?$AAl?$AA?$AA@
	DD	054H
	DD	FLAT:??_C@_1M@LJKPEMLN@?$AAn?$AAn?$AA?9?$AAn?$AAo?$AA?$AA@
	DD	097H
	DD	FLAT:??_C@_15BPIGNHCD@?$AAn?$AAo?$AA?$AA@
	DD	013H
	DD	FLAT:??_C@_1M@BDGHHBFL@?$AAn?$AAs?$AA?9?$AAz?$AAa?$AA?$AA@
	DD	08dH
	DD	FLAT:??_C@_15MGIFMDPL@?$AAp?$AAa?$AA?$AA@
	DD	036H
	DD	FLAT:??_C@_1M@IDEHOAP@?$AAp?$AAa?$AA?9?$AAi?$AAn?$AA?$AA@
	DD	07eH
	DD	FLAT:??_C@_15DEOPBLCG@?$AAp?$AAl?$AA?$AA@
	DD	014H
	DD	FLAT:??_C@_1M@HDBKGOGH@?$AAp?$AAl?$AA?9?$AAp?$AAl?$AA?$AA@
	DD	056H
	DD	FLAT:??_C@_15KBECGEFG@?$AAp?$AAt?$AA?$AA@
	DD	015H
	DD	FLAT:??_C@_1M@LJLLCMEH@?$AAp?$AAt?$AA?9?$AAb?$AAr?$AA?$AA@
	DD	057H
	DD	FLAT:??_C@_1M@NCMONAAL@?$AAp?$AAt?$AA?9?$AAp?$AAt?$AA?$AA@
	DD	098H
	DD	FLAT:??_C@_1O@EAKMAJDN@?$AAq?$AAu?$AAz?$AA?9?$AAb?$AAo?$AA?$AA@
	DD	08cH
	DD	FLAT:??_C@_1O@BHHPIGDN@?$AAq?$AAu?$AAz?$AA?9?$AAe?$AAc?$AA?$AA@
	DD	09fH
	DD	FLAT:??_C@_1O@GBAPEKMJ@?$AAq?$AAu?$AAz?$AA?9?$AAp?$AAe?$AA?$AA@
	DD	0a8H
	DD	FLAT:??_C@_15GLJCBFMD@?$AAr?$AAo?$AA?$AA@
	DD	016H
	DD	FLAT:??_C@_1M@CLGLEFBO@?$AAr?$AAo?$AA?9?$AAr?$AAo?$AA?$AA@
	DD	058H
	DD	FLAT:??_C@_15FEDGKCDI@?$AAr?$AAu?$AA?$AA@
	DD	017H
	DD	FLAT:??_C@_1M@CEEDODME@?$AAr?$AAu?$AA?9?$AAr?$AAu?$AA?$AA@
	DD	059H
	DD	FLAT:??_C@_15EABBLBFF@?$AAs?$AAa?$AA?$AA@
	DD	03cH
	DD	FLAT:??_C@_1M@HPKKKMPP@?$AAs?$AAa?$AA?9?$AAi?$AAn?$AA?$AA@
	DD	085H
	DD	FLAT:??_C@_1M@BKMAIGOJ@?$AAs?$AAe?$AA?9?$AAf?$AAi?$AA?$AA@
	DD	0a7H
	DD	FLAT:??_C@_1M@NDPIFLFI@?$AAs?$AAe?$AA?9?$AAn?$AAo?$AA?$AA@
	DD	076H
	DD	FLAT:??_C@_1M@DANKKHJ@?$AAs?$AAe?$AA?9?$AAs?$AAe?$AA?$AA@
	DD	09cH
	DD	FLAT:??_C@_15CPKMFBDB@?$AAs?$AAk?$AA?$AA@
	DD	019H
	DD	FLAT:??_C@_1M@PNBLONPJ@?$AAs?$AAk?$AA?9?$AAs?$AAk?$AA?$AA@
	DD	05bH
	DD	FLAT:??_C@_15LCHLGJII@?$AAs?$AAl?$AA?$AA@
	DD	022H
	DD	FLAT:??_C@_1M@LFMODOAL@?$AAs?$AAl?$AA?9?$AAs?$AAi?$AA?$AA@
	DD	064H
	DD	FLAT:??_C@_1O@DFKOMPG@?$AAs?$AAm?$AAa?$AA?9?$AAn?$AAo?$AA?$AA@
	DD	0beH
	DD	FLAT:??_C@_1O@NDKPBNNH@?$AAs?$AAm?$AAa?$AA?9?$AAs?$AAe?$AA?$AA@
	DD	0c3H
	DD	FLAT:??_C@_1O@PLLKBHAB@?$AAs?$AAm?$AAj?$AA?9?$AAn?$AAo?$AA?$AA@
	DD	0b0H
	DD	FLAT:??_C@_1O@CLEPOGCA@?$AAs?$AAm?$AAj?$AA?9?$AAs?$AAe?$AA?$AA@
	DD	0b8H
	DD	FLAT:??_C@_1O@DLGJGKMK@?$AAs?$AAm?$AAn?$AA?9?$AAf?$AAi?$AA?$AA@
	DD	0cbH
	DD	FLAT:??_C@_1O@OJDJGAJC@?$AAs?$AAm?$AAs?$AA?9?$AAf?$AAi?$AA?$AA@
	DD	0c7H
	DD	FLAT:??_C@_15BAAIOGMK@?$AAs?$AAq?$AA?$AA@
	DD	01aH
	DD	FLAT:??_C@_1M@BOFOGHPB@?$AAs?$AAq?$AA?9?$AAa?$AAl?$AA?$AA@
	DD	05cH
	DD	FLAT:??_C@_15CLNEJCE@?$AAs?$AAr?$AA?$AA@
	DD	0e3H
	DD	FLAT:??_C@_1BG@LJBBIPGB@?$AAs?$AAr?$AA?9?$AAb?$AAa?$AA?9?$AAc?$AAy?$AAr?$AAl?$AA?$AA@
	DD	0c2H
	DD	FLAT:??_C@_1BG@JLBENFOE@?$AAs?$AAr?$AA?9?$AAb?$AAa?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@
	DD	0bdH
	DD	FLAT:??_C@_1BG@KODPNHE@?$AAs?$AAr?$AA?9?$AAs?$AAp?$AA?9?$AAc?$AAy?$AAr?$AAl?$AA?$AA@
	DD	0a6H
	DD	FLAT:??_C@_1BG@CIOGKHPB@?$AAs?$AAr?$AA?9?$AAs?$AAp?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@
	DD	099H
	DD	FLAT:??_C@_15INNPNOHD@?$AAs?$AAv?$AA?$AA@
	DD	01bH
	DD	FLAT:??_C@_1M@NGFJLMAC@?$AAs?$AAv?$AA?9?$AAf?$AAi?$AA?$AA@
	DD	09aH
	DD	FLAT:??_C@_1M@MPJEJAJC@?$AAs?$AAv?$AA?9?$AAs?$AAe?$AA?$AA@
	DD	05dH
	DD	FLAT:??_C@_15DFGDLJBG@?$AAs?$AAw?$AA?$AA@
	DD	033H
	DD	FLAT:??_C@_1M@MPNDHLFK@?$AAs?$AAw?$AA?9?$AAk?$AAe?$AA?$AA@
	DD	07aH
	DD	FLAT:??_C@_17FFBJICPL@?$AAs?$AAy?$AAr?$AA?$AA@
	DD	040H
	DD	FLAT:??_C@_1O@KOHBJJI@?$AAs?$AAy?$AAr?$AA?9?$AAs?$AAy?$AA?$AA@
	DD	08aH
	DD	FLAT:??_C@_15FNBEIBON@?$AAt?$AAa?$AA?$AA@
	DD	038H
	DD	FLAT:??_C@_1M@LDCEFHA@?$AAt?$AAa?$AA?9?$AAi?$AAn?$AA?$AA@
	DD	080H
	DD	FLAT:??_C@_15NCHGBGLK@?$AAt?$AAe?$AA?$AA@
	DD	039H
	DD	FLAT:??_C@_1M@CNJOFAK@?$AAt?$AAe?$AA?9?$AAi?$AAn?$AA?$AA@
	DD	081H
	DD	FLAT:??_C@_15CABMMOGH@?$AAt?$AAh?$AA?$AA@
	DD	01cH
	DD	FLAT:??_C@_1M@GNAECACD@?$AAt?$AAh?$AA?9?$AAt?$AAh?$AA?$AA@
	DD	05eH
	DD	FLAT:??_C@_1M@CHBIHOJO@?$AAt?$AAn?$AA?9?$AAz?$AAa?$AA?$AA@
	DD	06eH
	DD	FLAT:??_C@_15BPLIHJJM@?$AAt?$AAr?$AA?$AA@
	DD	01dH
	DD	FLAT:??_C@_1M@GCCMIGPJ@?$AAt?$AAr?$AA?9?$AAt?$AAr?$AA?$AA@
	DD	05fH
	DD	FLAT:??_C@_15DKNDCGEA@?$AAt?$AAt?$AA?$AA@
	DD	035H
	DD	FLAT:??_C@_1M@CELMCNBK@?$AAt?$AAt?$AA?9?$AAr?$AAu?$AA?$AA@
	DD	07cH
	DD	FLAT:??_C@_15PJPFLCCM@?$AAu?$AAk?$AA?$AA@
	DD	020H
	DD	FLAT:??_C@_1M@KLMCELGA@?$AAu?$AAk?$AA?9?$AAu?$AAa?$AA?$AA@
	DD	062H
	DD	FLAT:??_C@_15NEOEKKDJ@?$AAu?$AAr?$AA?$AA@
	DD	01eH
	DD	FLAT:??_C@_1M@EPAJJAJF@?$AAu?$AAr?$AA?9?$AAp?$AAk?$AA?$AA@
	DD	060H
	DD	FLAT:??_C@_15BBFAICNG@?$AAu?$AAz?$AA?$AA@
	DD	034H
	DD	FLAT:??_C@_1BG@GEGPMCDJ@?$AAu?$AAz?$AA?9?$AAu?$AAz?$AA?9?$AAc?$AAy?$AAr?$AAl?$AA?$AA@
	DD	09eH
	DD	FLAT:??_C@_1BG@EGGKJILM@?$AAu?$AAz?$AA?9?$AAu?$AAz?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@
	DD	07bH
	DD	FLAT:??_C@_15NFGIAIAJ@?$AAv?$AAi?$AA?$AA@
	DD	027H
	DD	FLAT:??_C@_1M@GFOCLFF@?$AAv?$AAi?$AA?9?$AAv?$AAn?$AA?$AA@
	DD	069H
	DD	FLAT:??_C@_1M@CPAMEDFI@?$AAx?$AAh?$AA?9?$AAz?$AAa?$AA?$AA@
	DD	06fH
	DD	FLAT:??_C@_1O@EBKIFIGN@?$AAz?$AAh?$AA?9?$AAc?$AAh?$AAs?$AA?$AA@
	DD	03H
	DD	FLAT:??_C@_1O@NMHPGANE@?$AAz?$AAh?$AA?9?$AAc?$AAh?$AAt?$AA?$AA@
	DD	0e2H
	DD	FLAT:??_C@_1M@LPINJOMC@?$AAz?$AAh?$AA?9?$AAc?$AAn?$AA?$AA@
	DD	090H
	DD	FLAT:??_C@_1M@OCJEJODD@?$AAz?$AAh?$AA?9?$AAh?$AAk?$AA?$AA@
	DD	0a1H
	DD	FLAT:??_C@_1M@DNDLJINH@?$AAz?$AAh?$AA?9?$AAm?$AAo?$AA?$AA@
	DD	0b2H
	DD	FLAT:??_C@_1M@MBFDNDND@?$AAz?$AAh?$AA?9?$AAs?$AAg?$AA?$AA@
	DD	0aaH
	DD	FLAT:??_C@_1M@IMEPLEPE@?$AAz?$AAh?$AA?9?$AAt?$AAw?$AA?$AA@
	DD	046H
	DD	FLAT:??_C@_1M@BBGHNHJP@?$AAz?$AAu?$AA?9?$AAz?$AAa?$AA?$AA@
	DD	070H
CONST	ENDS
;	COMDAT ??_C@_15CLNEJCE@?$AAs?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_15CLNEJCE@?$AAs?$AAr?$AA?$AA@ DB 's', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@ICJHKIIK@?$AAz?$AAh?$AA?9?$AAC?$AAH?$AAT?$AA?$AA@
CONST	SEGMENT
??_C@_1O@ICJHKIIK@?$AAz?$AAh?$AA?9?$AAC?$AAH?$AAT?$AA?$AA@ DB 'z', 00H, 'h'
	DB	00H, '-', 00H, 'C', 00H, 'H', 00H, 'T', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CGFMKEEK@?$AAe?$AAs?$AA?9?$AAP?$AAR?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CGFMKEEK@?$AAe?$AAs?$AA?9?$AAP?$AAR?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'P', 00H, 'R', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JIJIBHDP@?$AAe?$AAs?$AA?9?$AAN?$AAI?$AA?$AA@
CONST	SEGMENT
??_C@_1M@JIJIBHDP@?$AAe?$AAs?$AA?9?$AAN?$AAI?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'N', 00H, 'I', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@NDBGMMJL@?$AAe?$AAs?$AA?9?$AAH?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1M@NDBGMMJL@?$AAe?$AAs?$AA?9?$AAH?$AAN?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'H', 00H, 'N', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CPKKEBLD@?$AAe?$AAs?$AA?9?$AAS?$AAV?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CPKKEBLD@?$AAe?$AAs?$AA?9?$AAS?$AAV?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'S', 00H, 'V', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MKDBIIJI@?$AAe?$AAs?$AA?9?$AAB?$AAO?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MKDBIIJI@?$AAe?$AAs?$AA?9?$AAB?$AAO?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'B', 00H, 'O', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@EDGINPNP@?$AAa?$AAr?$AA?9?$AAQ?$AAA?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EDGINPNP@?$AAa?$AAr?$AA?9?$AAQ?$AAA?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'Q', 00H, 'A', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PBFNCDEL@?$AAe?$AAs?$AA?9?$AAP?$AAY?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PBFNCDEL@?$AAe?$AAs?$AA?9?$AAP?$AAY?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'P', 00H, 'Y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LLCCOAGA@?$AAa?$AAr?$AA?9?$AAB?$AAH?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LLCCOAGA@?$AAa?$AAr?$AA?9?$AAB?$AAH?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'B', 00H, 'H', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KBJALCPI@?$AAe?$AAs?$AA?9?$AAU?$AAY?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KBJALCPI@?$AAe?$AAs?$AA?9?$AAU?$AAY?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'U', 00H, 'Y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MPNMEKBD@?$AAa?$AAr?$AA?9?$AAA?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MPNMEKBD@?$AAa?$AAr?$AA?9?$AAA?$AAE?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'A', 00H, 'E', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BDNIPEND@?$AAe?$AAs?$AA?9?$AAC?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BDNIPEND@?$AAe?$AAs?$AA?9?$AAC?$AAL?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'C', 00H, 'L', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MLKIBJOJ@?$AAe?$AAn?$AA?9?$AAP?$AAH?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MLKIBJOJ@?$AAe?$AAn?$AA?9?$AAP?$AAH?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'P', 00H, 'H', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JEFHPGGB@?$AAa?$AAr?$AA?9?$AAK?$AAW?$AA?$AA@
CONST	SEGMENT
??_C@_1M@JEFHPGGB@?$AAa?$AAr?$AA?9?$AAK?$AAW?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'K', 00H, 'W', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JNOCAHJI@?$AAe?$AAs?$AA?9?$AAE?$AAC?$AA?$AA@
CONST	SEGMENT
??_C@_1M@JNOCAHJI@?$AAe?$AAs?$AA?9?$AAE?$AAC?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'E', 00H, 'C', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GCEJHNEG@?$AAe?$AAn?$AA?9?$AAZ?$AAW?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GCEJHNEG@?$AAe?$AAn?$AA?9?$AAZ?$AAW?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'Z', 00H, 'W', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@OOJFGBHE@?$AAa?$AAr?$AA?9?$AAL?$AAB?$AA?$AA@
CONST	SEGMENT
??_C@_1M@OOJFGBHE@?$AAa?$AAr?$AA?9?$AAL?$AAB?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'L', 00H, 'B', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@OONGHFHE@?$AAe?$AAs?$AA?9?$AAA?$AAR?$AA?$AA@
CONST	SEGMENT
??_C@_1M@OONGHFHE@?$AAe?$AAs?$AA?9?$AAA?$AAR?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'A', 00H, 'R', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@EKPGLDNI@?$AAe?$AAn?$AA?9?$AAT?$AAT?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EKPGLDNI@?$AAe?$AAn?$AA?9?$AAT?$AAT?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'T', 00H, 'T', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MKKGFKLE@?$AAa?$AAr?$AA?9?$AAJ?$AAO?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MKKGFKLE@?$AAa?$AAr?$AA?9?$AAJ?$AAO?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'J', 00H, 'O', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@OLJCMLGM@?$AAe?$AAs?$AA?9?$AAP?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1M@OLJCMLGM@?$AAe?$AAs?$AA?9?$AAP?$AAE?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'P', 00H, 'E', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HPKGCFGN@?$AAe?$AAn?$AA?9?$AAB?$AAZ?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HPKGCFGN@?$AAe?$AAn?$AA?9?$AAB?$AAZ?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'B', 00H, 'Z', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JLANABKE@?$AAa?$AAr?$AA?9?$AAS?$AAY?$AA?$AA@
CONST	SEGMENT
??_C@_1M@JLANABKE@?$AAa?$AAr?$AA?9?$AAS?$AAY?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'S', 00H, 'Y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PGMFNIFA@atlTraceException?$AA@
CONST	SEGMENT
??_C@_0BC@PGMFNIFA@atlTraceException?$AA@ DB 'atlTraceException', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@JMPHMAMC@?$AAs?$AAm?$AAn?$AA?9?$AAF?$AAI?$AA?$AA@
CONST	SEGMENT
??_C@_1O@JMPHMAMC@?$AAs?$AAm?$AAn?$AA?9?$AAF?$AAI?$AA?$AA@ DB 's', 00H, 'm'
	DB	00H, 'n', 00H, '-', 00H, 'F', 00H, 'I', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BGNFLDN@?$AAe?$AAs?$AA?9?$AAC?$AAO?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BGNFLDN@?$AAe?$AAs?$AA?9?$AAC?$AAO?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'C', 00H, 'O', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CBFHIJLI@?$AAe?$AAn?$AA?9?$AAC?$AAB?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CBFHIJLI@?$AAe?$AAn?$AA?9?$AAC?$AAB?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'C', 00H, 'B', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CAFJMKOF@?$AAa?$AAr?$AA?9?$AAY?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CAFJMKOF@?$AAa?$AAr?$AA?9?$AAY?$AAE?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'Y', 00H, 'E', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@EOKHMKJK@?$AAs?$AAm?$AAs?$AA?9?$AAF?$AAI?$AA?$AA@
CONST	SEGMENT
??_C@_1O@EOKHMKJK@?$AAs?$AAm?$AAs?$AA?9?$AAF?$AAI?$AA?$AA@ DB 's', 00H, 'm'
	DB	00H, 's', 00H, '-', 00H, 'F', 00H, 'I', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DNMLCIHB@?$AAe?$AAs?$AA?9?$AAV?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DNMLCIHB@?$AAe?$AAs?$AA?9?$AAV?$AAE?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'V', 00H, 'E', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FODLMICG@?$AAe?$AAn?$AA?9?$AAJ?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FODLMICG@?$AAe?$AAn?$AA?9?$AAJ?$AAM?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'J', 00H, 'M', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DAGCADIM@?$AAa?$AAr?$AA?9?$AAO?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DAGCADIM@?$AAa?$AAr?$AA?9?$AAO?$AAM?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'O', 00H, 'M', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@HEDBLHNP@?$AAs?$AAm?$AAa?$AA?9?$AAS?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1O@HEDBLHNP@?$AAs?$AAm?$AAa?$AA?9?$AAS?$AAE?$AA?$AA@ DB 's', 00H, 'm'
	DB	00H, 'a', 00H, '-', 00H, 'S', 00H, 'E', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@CMBHIPBE@?$AAs?$AAr?$AA?9?$AAB?$AAA?$AA?9?$AAC?$AAy?$AAr?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@CMBHIPBE@?$AAs?$AAr?$AA?9?$AAB?$AAA?$AA?9?$AAC?$AAy?$AAr?$AAl?$AA?$AA@ DB 's'
	DB	00H, 'r', 00H, '-', 00H, 'B', 00H, 'A', 00H, '-', 00H, 'C', 00H
	DB	'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BMGIGLIF@?$AAe?$AAs?$AA?9?$AAD?$AAO?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BMGIGLIF@?$AAe?$AAs?$AA?9?$AAD?$AAO?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'D', 00H, 'O', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BHDLHFAF@?$AAe?$AAn?$AA?9?$AAZ?$AAA?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BHDLHFAF@?$AAe?$AAn?$AA?9?$AAZ?$AAA?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@ELMGFODK@?$AAa?$AAr?$AA?9?$AAT?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1M@ELMGFODK@?$AAa?$AAr?$AA?9?$AAT?$AAN?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'T', 00H, 'N', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@KEMEEGPO@?$AAs?$AAm?$AAa?$AA?9?$AAN?$AAO?$AA?$AA@
CONST	SEGMENT
??_C@_1O@KEMEEGPO@?$AAs?$AAm?$AAa?$AA?9?$AAN?$AAO?$AA?$AA@ DB 's', 00H, 'm'
	DB	00H, 'a', 00H, '-', 00H, 'N', 00H, 'O', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@OBCNFJB@?$AAs?$AAr?$AA?9?$AAB?$AAA?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@OBCNFJB@?$AAs?$AAr?$AA?9?$AAB?$AAA?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@ DB 's'
	DB	00H, 'r', 00H, '-', 00H, 'B', 00H, 'A', 00H, '-', 00H, 'L', 00H
	DB	'a', 00H, 't', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@OJONDMDL@?$AAf?$AAr?$AA?9?$AAM?$AAC?$AA?$AA@
CONST	SEGMENT
??_C@_1M@OJONDMDL@?$AAf?$AAr?$AA?9?$AAM?$AAC?$AA?$AA@ DB 'f', 00H, 'r', 00H
	DB	'-', 00H, 'M', 00H, 'C', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GEPAFMDL@?$AAe?$AAs?$AA?9?$AAP?$AAA?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GEPAFMDL@?$AAe?$AAs?$AA?9?$AAP?$AAA?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'P', 00H, 'A', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BNBLJCGH@?$AAe?$AAn?$AA?9?$AAI?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BNBLJCGH@?$AAe?$AAn?$AA?9?$AAI?$AAE?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'I', 00H, 'E', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DHHMBNDP@?$AAa?$AAr?$AA?9?$AAM?$AAA?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DHHMBNDP@?$AAa?$AAr?$AA?9?$AAM?$AAA?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'M', 00H, 'A', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@IMNBEMCI@?$AAs?$AAm?$AAj?$AA?9?$AAS?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1O@IMNBEMCI@?$AAs?$AAm?$AAj?$AA?9?$AAS?$AAE?$AA?$AA@ DB 's', 00H, 'm'
	DB	00H, 'j', 00H, '-', 00H, 'S', 00H, 'E', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@NFKKMAFG@?$AAb?$AAs?$AA?9?$AAB?$AAA?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@NFKKMAFG@?$AAb?$AAs?$AA?9?$AAB?$AAA?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@ DB 'b'
	DB	00H, 's', 00H, '-', 00H, 'B', 00H, 'A', 00H, '-', 00H, 'L', 00H
	DB	'a', 00H, 't', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FHMDOHNN@?$AAf?$AAr?$AA?9?$AAL?$AAU?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FHMDOHNN@?$AAf?$AAr?$AA?9?$AAL?$AAU?$AA?$AA@ DB 'f', 00H, 'r', 00H
	DB	'-', 00H, 'L', 00H, 'U', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KDBONEHP@?$AAe?$AAs?$AA?9?$AAC?$AAR?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KDBONEHP@?$AAe?$AAs?$AA?9?$AAC?$AAR?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'C', 00H, 'R', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IGEOFBG@?$AAe?$AAn?$AA?9?$AAN?$AAZ?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IGEOFBG@?$AAe?$AAn?$AA?9?$AAN?$AAZ?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'N', 00H, 'Z', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GEEFALPE@?$AAd?$AAe?$AA?9?$AAL?$AAI?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GEEFALPE@?$AAd?$AAe?$AA?9?$AAL?$AAI?$AA?$AA@ DB 'd', 00H, 'e', 00H
	DB	'-', 00H, 'L', 00H, 'I', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JKKFDCNP@?$AAz?$AAh?$AA?9?$AAM?$AAO?$AA?$AA@
CONST	SEGMENT
??_C@_1M@JKKFDCNP@?$AAz?$AAh?$AA?9?$AAM?$AAO?$AA?$AA@ DB 'z', 00H, 'h', 00H
	DB	'-', 00H, 'M', 00H, 'O', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JHGLJMGJ@?$AAa?$AAr?$AA?9?$AAD?$AAZ?$AA?$AA@
CONST	SEGMENT
??_C@_1M@JHGLJMGJ@?$AAa?$AAr?$AA?9?$AAD?$AAZ?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'D', 00H, 'Z', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@FMCELNAJ@?$AAs?$AAm?$AAj?$AA?9?$AAN?$AAO?$AA?$AA@
CONST	SEGMENT
??_C@_1O@FMCELNAJ@?$AAs?$AAm?$AAj?$AA?9?$AAN?$AAO?$AA?$AA@ DB 's', 00H, 'm'
	DB	00H, 'j', 00H, '-', 00H, 'N', 00H, 'O', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FLIDJFHL@?$AAh?$AAr?$AA?9?$AAB?$AAA?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FLIDJFHL@?$AAh?$AAr?$AA?9?$AAB?$AAA?$AA?$AA@ DB 'h', 00H, 'r', 00H
	DB	'-', 00H, 'B', 00H, 'A', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@EOGNKEK@?$AAf?$AAr?$AA?9?$AAC?$AAH?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EOGNKEK@?$AAf?$AAr?$AA?9?$AAC?$AAH?$AA?$AA@ DB 'f', 00H, 'r', 00H
	DB	'-', 00H, 'C', 00H, 'H', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BNOEMJLF@?$AAe?$AAs?$AA?9?$AAG?$AAT?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BNOEMJLF@?$AAe?$AAs?$AA?9?$AAG?$AAT?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'G', 00H, 'T', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DDOCCGFG@?$AAe?$AAn?$AA?9?$AAC?$AAA?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DDOCCGFG@?$AAe?$AAn?$AA?9?$AAC?$AAA?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'C', 00H, 'A', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HOIKODND@?$AAd?$AAe?$AA?9?$AAL?$AAU?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HOIKODND@?$AAd?$AAe?$AA?9?$AAL?$AAU?$AA?$AA@ DB 'd', 00H, 'e', 00H
	DB	'-', 00H, 'L', 00H, 'U', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GGMNHJNL@?$AAz?$AAh?$AA?9?$AAS?$AAG?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GGMNHJNL@?$AAz?$AAh?$AA?9?$AAS?$AAG?$AA?$AA@ DB 'z', 00H, 'h', 00H
	DB	'-', 00H, 'S', 00H, 'G', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GJINLBOK@?$AAa?$AAr?$AA?9?$AAL?$AAY?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GJINLBOK@?$AAa?$AAr?$AA?9?$AAL?$AAY?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'L', 00H, 'Y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@MGJBOAMB@?$AAq?$AAu?$AAz?$AA?9?$AAP?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1O@MGJBOAMB@?$AAq?$AAu?$AAz?$AA?9?$AAP?$AAE?$AA?$AA@ DB 'q', 00H, 'u'
	DB	00H, 'z', 00H, '-', 00H, 'P', 00H, 'E', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LNFOCMOB@?$AAs?$AAe?$AA?9?$AAF?$AAI?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LNFOCMOB@?$AAs?$AAe?$AA?9?$AAF?$AAI?$AA?$AA@ DB 's', 00H, 'e', 00H
	DB	'-', 00H, 'F', 00H, 'I', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@JPOFPNAB@?$AAs?$AAr?$AA?9?$AAS?$AAP?$AA?9?$AAC?$AAy?$AAr?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@JPOFPNAB@?$AAs?$AAr?$AA?9?$AAS?$AAP?$AA?9?$AAC?$AAy?$AAr?$AAl?$AA?$AA@ DB 's'
	DB	00H, 'r', 00H, '-', 00H, 'S', 00H, 'P', 00H, '-', 00H, 'C', 00H
	DB	'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HJOOJFMA@?$AAf?$AAr?$AA?9?$AAC?$AAA?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HJOOJFMA@?$AAf?$AAr?$AA?9?$AAC?$AAA?$AA?$AA@ DB 'f', 00H, 'r', 00H
	DB	'-', 00H, 'C', 00H, 'A', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MNPLFAAH@?$AAe?$AAs?$AA?9?$AAE?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MNPLFAAH@?$AAe?$AAs?$AA?9?$AAE?$AAS?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'E', 00H, 'S', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KBFBEHJF@?$AAe?$AAn?$AA?9?$AAA?$AAU?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KBFBEHJF@?$AAe?$AAn?$AA?9?$AAA?$AAU?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'A', 00H, 'U', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HKKIJHGI@?$AAd?$AAe?$AA?9?$AAA?$AAT?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HKKIJHGI@?$AAd?$AAe?$AA?9?$AAA?$AAT?$AA?$AA@ DB 'd', 00H, 'e', 00H
	DB	'-', 00H, 'A', 00H, 'T', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT ??_C@_1M@EFAKDEDL@?$AAz?$AAh?$AA?9?$AAH?$AAK?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EFAKDEDL@?$AAz?$AAh?$AA?9?$AAH?$AAK?$AA?$AA@ DB 'z', 00H, 'h', 00H
	DB	'-', 00H, 'H', 00H, 'K', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@POEEMAIO@?$AAa?$AAr?$AA?9?$AAE?$AAG?$AA?$AA@
CONST	SEGMENT
??_C@_1M@POEEMAIO@?$AAa?$AAr?$AA?9?$AAE?$AAG?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'E', 00H, 'G', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@LAOBCMDF@?$AAq?$AAu?$AAz?$AA?9?$AAE?$AAC?$AA?$AA@
CONST	SEGMENT
??_C@_1O@LAOBCMDF@?$AAq?$AAu?$AAz?$AA?9?$AAE?$AAC?$AA?$AA@ DB 'q', 00H, 'u'
	DB	00H, 'z', 00H, '-', 00H, 'E', 00H, 'C', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@PBGJMCEM@?$AAu?$AAz?$AA?9?$AAU?$AAZ?$AA?9?$AAC?$AAy?$AAr?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@PBGJMCEM@?$AAu?$AAz?$AA?9?$AAU?$AAZ?$AA?9?$AAC?$AAy?$AAr?$AAl?$AA?$AA@ DB 'u'
	DB	00H, 'z', 00H, '-', 00H, 'U', 00H, 'Z', 00H, '-', 00H, 'C', 00H
	DB	'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HEIBJJAD@?$AAm?$AAs?$AA?9?$AAB?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HEIBJJAD@?$AAm?$AAs?$AA?9?$AAB?$AAN?$AA?$AA@ DB 'm', 00H, 's', 00H
	DB	'-', 00H, 'B', 00H, 'N', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJPCCAKP@atlTraceAllocation?$AA@
CONST	SEGMENT
??_C@_0BD@PJPCCAKP@atlTraceAllocation?$AA@ DB 'atlTraceAllocation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KEJDAAHB@?$AAs?$AAe?$AA?9?$AAS?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KEJDAAHB@?$AAs?$AAe?$AA?9?$AAS?$AAE?$AA?$AA@ DB 's', 00H, 'e', 00H
	DB	'-', 00H, 'S', 00H, 'E', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@DGCJGJBE@?$AAa?$AAz?$AA?9?$AAA?$AAZ?$AA?9?$AAC?$AAy?$AAr?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@DGCJGJBE@?$AAa?$AAz?$AA?9?$AAA?$AAZ?$AA?9?$AAC?$AAy?$AAr?$AAl?$AA?$AA@ DB 'a'
	DB	00H, 'z', 00H, '-', 00H, 'A', 00H, 'Z', 00H, '-', 00H, 'C', 00H
	DB	'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HBMHBGAK@?$AAs?$AAv?$AA?9?$AAF?$AAI?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HBMHBGAK@?$AAs?$AAv?$AA?9?$AAF?$AAI?$AA?$AA@ DB 's', 00H, 'v', 00H
	DB	'-', 00H, 'F', 00H, 'I', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ??_C@_1BG@LNOAKHIE@?$AAs?$AAr?$AA?9?$AAS?$AAP?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@LNOAKHIE@?$AAs?$AAr?$AA?9?$AAS?$AAP?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@ DB 's'
	DB	00H, 'r', 00H, '-', 00H, 'S', 00H, 'P', 00H, '-', 00H, 'L', 00H
	DB	'a', 00H, 't', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HFFAHKAD@?$AAp?$AAt?$AA?9?$AAP?$AAT?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HFFAHKAD@?$AAp?$AAt?$AA?9?$AAP?$AAT?$AA?$AA@ DB 'p', 00H, 't', 00H
	DB	'-', 00H, 'P', 00H, 'T', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BODBOGLF@?$AAn?$AAn?$AA?9?$AAN?$AAO?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BODBOGLF@?$AAn?$AAn?$AA?9?$AAN?$AAO?$AA?$AA@ DB 'n', 00H, 'n', 00H
	DB	'-', 00H, 'N', 00H, 'O', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CLLBGJH@?$AAn?$AAl?$AA?9?$AAB?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CLLBGJH@?$AAn?$AAl?$AA?9?$AAB?$AAE?$AA?$AA@ DB 'n', 00H, 'l', 00H
	DB	'-', 00H, 'B', 00H, 'E', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HLGMDFHM@?$AAi?$AAt?$AA?9?$AAC?$AAH?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HLGMDFHM@?$AAi?$AAt?$AA?9?$AAC?$AAH?$AA?$AA@ DB 'i', 00H, 't', 00H
	DB	'-', 00H, 'C', 00H, 'H', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DNNANBDC@?$AAf?$AAr?$AA?9?$AAB?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DNNANBDC@?$AAf?$AAr?$AA?9?$AAB?$AAE?$AA?$AA@ DB 'f', 00H, 'r', 00H
	DB	'-', 00H, 'B', 00H, 'E', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PGKJFFGL@?$AAe?$AAs?$AA?9?$AAM?$AAX?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PGKJFFGL@?$AAe?$AAs?$AA?9?$AAM?$AAX?$AA?$AA@ DB 'e', 00H, 's', 00H
	DB	'-', 00H, 'M', 00H, 'X', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LKMGMLKO@?$AAe?$AAn?$AA?9?$AAG?$AAB?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LKMGMLKO@?$AAe?$AAn?$AA?9?$AAG?$AAB?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'G', 00H, 'B', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CNKPNOEE@?$AAd?$AAe?$AA?9?$AAC?$AAH?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CNKPNOEE@?$AAd?$AAe?$AA?9?$AAC?$AAH?$AA?$AA@ DB 'd', 00H, 'e', 00H
	DB	'-', 00H, 'C', 00H, 'H', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BIBDDEMK@?$AAz?$AAh?$AA?9?$AAC?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BIBDDEMK@?$AAz?$AAh?$AA?9?$AAC?$AAN?$AA?$AA@ DB 'z', 00H, 'h', 00H
	DB	'-', 00H, 'C', 00H, 'N', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PMPEAILG@?$AAa?$AAr?$AA?9?$AAI?$AAQ?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PMPEAILG@?$AAa?$AAr?$AA?9?$AAI?$AAQ?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'I', 00H, 'Q', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@OMLEIIJB@?$AAm?$AAi?$AA?9?$AAN?$AAZ?$AA?$AA@
CONST	SEGMENT
??_C@_1M@OMLEIIJB@?$AAm?$AAi?$AA?9?$AAN?$AAZ?$AA?$AA@ DB 'm', 00H, 'i', 00H
	DB	'-', 00H, 'N', 00H, 'Z', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LEPJNLFD@?$AAn?$AAs?$AA?9?$AAZ?$AAA?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LEPJNLFD@?$AAn?$AAs?$AA?9?$AAZ?$AAA?$AA?$AA@ DB 'n', 00H, 's', 00H
	DB	'-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@OHDCKDDF@?$AAq?$AAu?$AAz?$AA?9?$AAB?$AAO?$AA?$AA@
CONST	SEGMENT
??_C@_1O@OHDCKDDF@?$AAq?$AAu?$AAz?$AA?9?$AAB?$AAO?$AA?$AA@ DB 'q', 00H, 'u'
	DB	00H, 'z', 00H, '-', 00H, 'B', 00H, 'O', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@MKEKBLAH@?$AAd?$AAi?$AAv?$AA?9?$AAM?$AAV?$AA?$AA@
CONST	SEGMENT
??_C@_1O@MKEKBLAH@?$AAd?$AAi?$AAv?$AA?9?$AAM?$AAV?$AA?$AA@ DB 'd', 00H, 'i'
	DB	00H, 'v', 00H, '-', 00H, 'M', 00H, 'V', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@KNHJLDJA@?$AAs?$AAy?$AAr?$AA?9?$AAS?$AAY?$AA?$AA@
CONST	SEGMENT
??_C@_1O@KNHJLDJA@?$AAs?$AAy?$AAr?$AA?9?$AAS?$AAY?$AA?$AA@ DB 's', 00H, 'y'
	DB	00H, 'r', 00H, '-', 00H, 'S', 00H, 'Y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@KPIPDNCP@?$AAk?$AAo?$AAk?$AA?9?$AAI?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1O@KPIPDNCP@?$AAk?$AAo?$AAk?$AA?9?$AAI?$AAN?$AA?$AA@ DB 'k', 00H, 'o'
	DB	00H, 'k', 00H, '-', 00H, 'I', 00H, 'N', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PHGFBEPN@?$AAg?$AAl?$AA?9?$AAE?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PHGFBEPN@?$AAg?$AAl?$AA?9?$AAE?$AAS?$AA?$AA@ DB 'g', 00H, 'l', 00H
	DB	'-', 00H, 'E', 00H, 'S', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JAIJPENP@?$AAc?$AAy?$AA?9?$AAG?$AAB?$AA?$AA@
CONST	SEGMENT
??_C@_1M@JAIJPENP@?$AAc?$AAy?$AA?9?$AAG?$AAB?$AA?$AA@ DB 'c', 00H, 'y', 00H
	DB	'-', 00H, 'G', 00H, 'B', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FHIHCBIO@?$AAm?$AAn?$AA?9?$AAM?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FHIHCBIO@?$AAm?$AAn?$AA?9?$AAM?$AAN?$AA?$AA@ DB 'm', 00H, 'n', 00H
	DB	'-', 00H, 'M', 00H, 'N', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@NIDEAGPH@?$AAs?$AAa?$AA?9?$AAI?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1M@NIDEAGPH@?$AAs?$AAa?$AA?9?$AAI?$AAN?$AA?$AA@ DB 's', 00H, 'a', 00H
	DB	'-', 00H, 'I', 00H, 'N', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PBIEACPO@?$AAm?$AAr?$AA?9?$AAI?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PBIEACPO@?$AAm?$AAr?$AA?9?$AAI?$AAN?$AA?$AA@ DB 'm', 00H, 'r', 00H
	DB	'-', 00H, 'I', 00H, 'N', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MIODLDKF@?$AAm?$AAl?$AA?9?$AAI?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MIODLDKF@?$AAm?$AAl?$AA?9?$AAI?$AAN?$AA?$AA@ DB 'm', 00H, 'l', 00H
	DB	'-', 00H, 'I', 00H, 'N', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CDCLMGHI@?$AAk?$AAn?$AA?9?$AAI?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CDCLMGHI@?$AAk?$AAn?$AA?9?$AAI?$AAN?$AA?$AA@ DB 'k', 00H, 'n', 00H
	DB	'-', 00H, 'I', 00H, 'N', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KFEHEPAC@?$AAt?$AAe?$AA?9?$AAI?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KFEHEPAC@?$AAt?$AAe?$AA?9?$AAI?$AAN?$AA?$AA@ DB 't', 00H, 'e', 00H
	DB	'-', 00H, 'I', 00H, 'N', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KMKMOPHI@?$AAt?$AAa?$AA?9?$AAI?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KMKMOPHI@?$AAt?$AAa?$AA?9?$AAI?$AAN?$AA?$AA@ DB 't', 00H, 'a', 00H
	DB	'-', 00H, 'I', 00H, 'N', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PJGPPBOG@?$AAg?$AAu?$AA?9?$AAI?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PJGPPBOG@?$AAg?$AAu?$AA?9?$AAI?$AAN?$AA?$AA@ DB 'g', 00H, 'u', 00H
	DB	'-', 00H, 'I', 00H, 'N', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KPKKNEAH@?$AAp?$AAa?$AA?9?$AAI?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KPKKNEAH@?$AAp?$AAa?$AA?9?$AAI?$AAN?$AA?$AA@ DB 'p', 00H, 'a', 00H
	DB	'-', 00H, 'I', 00H, 'N', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LOICPMOJ@?$AAb?$AAn?$AA?9?$AAI?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LOICPMOJ@?$AAb?$AAn?$AA?9?$AAI?$AAN?$AA?$AA@ DB 'b', 00H, 'n', 00H
	DB	'-', 00H, 'I', 00H, 'N', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IDCCIHBC@?$AAt?$AAt?$AA?9?$AAR?$AAU?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IDCCIHBC@?$AAt?$AAt?$AA?9?$AAR?$AAU?$AA?$AA@ DB 't', 00H, 't', 00H
	DB	'-', 00H, 'R', 00H, 'U', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@NDGMJIMJ@?$AAu?$AAz?$AA?9?$AAU?$AAZ?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@NDGMJIMJ@?$AAu?$AAz?$AA?9?$AAU?$AAZ?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@ DB 'u'
	DB	00H, 'z', 00H, '-', 00H, 'U', 00H, 'Z', 00H, '-', 00H, 'L', 00H
	DB	'a', 00H, 't', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GIENNBFC@?$AAs?$AAw?$AA?9?$AAK?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GIENNBFC@?$AAs?$AAw?$AA?9?$AAK?$AAE?$AA?$AA@ DB 's', 00H, 'w', 00H
	DB	'-', 00H, 'K', 00H, 'E', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@NGJJLCGI@?$AAk?$AAy?$AA?9?$AAK?$AAG?$AA?$AA@
CONST	SEGMENT
??_C@_1M@NGJJLCGI@?$AAk?$AAy?$AA?9?$AAK?$AAG?$AA?$AA@ DB 'k', 00H, 'y', 00H
	DB	'-', 00H, 'K', 00H, 'G', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FHLBGMPP@?$AAk?$AAk?$AA?9?$AAK?$AAZ?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FHLBGMPP@?$AAk?$AAk?$AA?9?$AAK?$AAZ?$AA?$AA@ DB 'k', 00H, 'k', 00H
	DB	'-', 00H, 'K', 00H, 'Z', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@EIBJEEPA@?$AAm?$AAs?$AA?9?$AAM?$AAY?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EIBJEEPA@?$AAm?$AAs?$AA?9?$AAM?$AAY?$AA?$AA@ DB 'm', 00H, 's', 00H
	DB	'-', 00H, 'M', 00H, 'Y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HEGGPBFA@?$AAs?$AAe?$AA?9?$AAN?$AAO?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HEGGPBFA@?$AAs?$AAe?$AA?9?$AAN?$AAO?$AA?$AA@ DB 's', 00H, 'e', 00H
	DB	'-', 00H, 'N', 00H, 'O', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FIKPIHFE@?$AAm?$AAt?$AA?9?$AAM?$AAT?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FIKPIHFE@?$AAm?$AAt?$AA?9?$AAM?$AAT?$AA?$AA@ DB 'm', 00H, 't', 00H
	DB	'-', 00H, 'M', 00H, 'T', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LGGJAPPB@?$AAh?$AAi?$AA?9?$AAI?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LGGJAPPB@?$AAh?$AAi?$AA?9?$AAI?$AAN?$AA?$AA@ DB 'h', 00H, 'i', 00H
	DB	'-', 00H, 'I', 00H, 'N', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BLKMHJBI@?$AAf?$AAo?$AA?9?$AAF?$AAO?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BLKMHJBI@?$AAf?$AAo?$AA?9?$AAF?$AAO?$AA?$AA@ DB 'f', 00H, 'o', 00H
	DB	'-', 00H, 'F', 00H, 'O', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DPCLHLIE@?$AAk?$AAa?$AA?9?$AAG?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DPCLHLIE@?$AAk?$AAa?$AA?9?$AAG?$AAE?$AA?$AA@ DB 'k', 00H, 'a', 00H
	DB	'-', 00H, 'G', 00H, 'E', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HOKAOIO@?$AAa?$AAf?$AA?9?$AAZ?$AAA?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HOKAOIO@?$AAa?$AAf?$AA?9?$AAZ?$AAA?$AA?$AA@ DB 'a', 00H, 'f', 00H
	DB	'-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LGPJHNJH@?$AAz?$AAu?$AA?9?$AAZ?$AAA?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LGPJHNJH@?$AAz?$AAu?$AA?9?$AAZ?$AAA?$AA?$AA@ DB 'z', 00H, 'u', 00H
	DB	'-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IIJCOJFA@?$AAx?$AAh?$AA?9?$AAZ?$AAA?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IIJCOJFA@?$AAx?$AAh?$AA?9?$AAZ?$AAA?$AA?$AA@ DB 'x', 00H, 'h', 00H
	DB	'-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IAIGNEJG@?$AAt?$AAn?$AA?9?$AAZ?$AAA?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IAIGNEJG@?$AAt?$AAn?$AA?9?$AAZ?$AAA?$AA?$AA@ DB 't', 00H, 'n', 00H
	DB	'-', 00H, 'Z', 00H, 'A', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MCBFIDIC@atlTraceNotImpl?$AA@
CONST	SEGMENT
??_C@_0BA@MCBFIDIC@atlTraceNotImpl?$AA@ DB 'atlTraceNotImpl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IGHABKPI@?$AAm?$AAk?$AA?9?$AAM?$AAK?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IGHABKPI@?$AAm?$AAk?$AA?9?$AAM?$AAK?$AA?$AA@ DB 'm', 00H, 'k', 00H
	DB	'-', 00H, 'M', 00H, 'K', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MAOFCAEA@?$AAe?$AAu?$AA?9?$AAE?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MAOFCAEA@?$AAe?$AAu?$AA?9?$AAE?$AAS?$AA?$AA@ DB 'e', 00H, 'u', 00H
	DB	'-', 00H, 'E', 00H, 'S', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@BECMDDJB@?$AAa?$AAz?$AA?9?$AAA?$AAZ?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@BECMDDJB@?$AAa?$AAz?$AA?9?$AAA?$AAZ?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@ DB 'a'
	DB	00H, 'z', 00H, '-', 00H, 'A', 00H, 'Z', 00H, '-', 00H, 'L', 00H
	DB	'a', 00H, 't', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GPCBKDJK@?$AAh?$AAy?$AA?9?$AAA?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GPCBKDJK@?$AAh?$AAy?$AA?9?$AAA?$AAM?$AA?$AA@ DB 'h', 00H, 'y', 00H
	DB	'-', 00H, 'A', 00H, 'M', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KBMAIBFN@?$AAv?$AAi?$AA?9?$AAV?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KBMAIBFN@?$AAv?$AAi?$AA?9?$AAV?$AAN?$AA?$AA@ DB 'v', 00H, 'i', 00H
	DB	'-', 00H, 'V', 00H, 'N', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FGEAHEDM@?$AAf?$AAa?$AA?9?$AAI?$AAR?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FGEAHEDM@?$AAf?$AAa?$AA?9?$AAI?$AAR?$AA?$AA@ DB 'f', 00H, 'a', 00H
	DB	'-', 00H, 'I', 00H, 'R', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IFGBIJO@?$AAl?$AAt?$AA?9?$AAL?$AAT?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IFGBIJO@?$AAl?$AAt?$AA?9?$AAL?$AAT?$AA?$AA@ DB 'l', 00H, 't', 00H
	DB	'-', 00H, 'L', 00H, 'T', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KGKKAACI@?$AAl?$AAv?$AA?9?$AAL?$AAV?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KGKKAACI@?$AAl?$AAv?$AA?9?$AAL?$AAV?$AA?$AA@ DB 'l', 00H, 'v', 00H
	DB	'-', 00H, 'L', 00H, 'V', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FKFFEDDN@?$AAe?$AAt?$AA?9?$AAE?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FKFFEDDN@?$AAe?$AAt?$AA?9?$AAE?$AAE?$AA?$AA@ DB 'e', 00H, 't', 00H
	DB	'-', 00H, 'E', 00H, 'E', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BCFAJEAD@?$AAs?$AAl?$AA?9?$AAS?$AAI?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BCFAJEAD@?$AAs?$AAl?$AA?9?$AAS?$AAI?$AA?$AA@ DB 's', 00H, 'l', 00H
	DB	'-', 00H, 'S', 00H, 'I', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@OBGLJIPL@?$AAb?$AAe?$AA?9?$AAB?$AAY?$AA?$AA@
CONST	SEGMENT
??_C@_1M@OBGLJIPL@?$AAb?$AAe?$AA?9?$AAB?$AAY?$AA?$AA@ DB 'b', 00H, 'e', 00H
	DB	'-', 00H, 'B', 00H, 'Y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MFMOBGI@?$AAu?$AAk?$AA?9?$AAU?$AAA?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MFMOBGI@?$AAu?$AAk?$AA?9?$AAU?$AAA?$AA?$AA@ DB 'u', 00H, 'k', 00H
	DB	'-', 00H, 'U', 00H, 'A', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LHIPCIEK@?$AAi?$AAd?$AA?9?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LHIPCIEK@?$AAi?$AAd?$AA?9?$AAI?$AAD?$AA?$AA@ DB 'i', 00H, 'd', 00H
	DB	'-', 00H, 'I', 00H, 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@OIJHDKJN@?$AAu?$AAr?$AA?9?$AAP?$AAK?$AA?$AA@
CONST	SEGMENT
??_C@_1M@OIJHDKJN@?$AAu?$AAr?$AA?9?$AAP?$AAK?$AA?$AA@ DB 'u', 00H, 'r', 00H
	DB	'-', 00H, 'P', 00H, 'K', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MFLCCMPB@?$AAt?$AAr?$AA?9?$AAT?$AAR?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MFLCCMPB@?$AAt?$AAr?$AA?9?$AAT?$AAR?$AA?$AA@ DB 't', 00H, 'r', 00H
	DB	'-', 00H, 'T', 00H, 'R', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MKJKIKCL@?$AAt?$AAh?$AA?9?$AAT?$AAH?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MKJKIKCL@?$AAt?$AAh?$AA?9?$AAT?$AAH?$AA?$AA@ DB 't', 00H, 'h', 00H
	DB	'-', 00H, 'T', 00H, 'H', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GIAKDKJK@?$AAs?$AAv?$AA?9?$AAS?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GIAKDKJK@?$AAs?$AAv?$AA?9?$AAS?$AAE?$AA?$AA@ DB 's', 00H, 'v', 00H
	DB	'-', 00H, 'S', 00H, 'E', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LJMAMNPJ@?$AAs?$AAq?$AA?9?$AAA?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LJMAMNPJ@?$AAs?$AAq?$AA?9?$AAA?$AAL?$AA?$AA@ DB 's', 00H, 'q', 00H
	DB	'-', 00H, 'A', 00H, 'L', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FKIFEHPB@?$AAs?$AAk?$AA?9?$AAS?$AAK?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FKIFEHPB@?$AAs?$AAk?$AA?9?$AAS?$AAK?$AA?$AA@ DB 's', 00H, 'k', 00H
	DB	'-', 00H, 'S', 00H, 'K', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LILEEOGM@?$AAh?$AAr?$AA?9?$AAH?$AAR?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LILEEOGM@?$AAh?$AAr?$AA?9?$AAH?$AAR?$AA?$AA@ DB 'h', 00H, 'r', 00H
	DB	'-', 00H, 'H', 00H, 'R', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IDNNEJMM@?$AAr?$AAu?$AA?9?$AAR?$AAU?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IDNNEJMM@?$AAr?$AAu?$AA?9?$AAR?$AAU?$AA?$AA@ DB 'r', 00H, 'u', 00H
	DB	'-', 00H, 'R', 00H, 'U', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IMPFOPBG@?$AAr?$AAo?$AA?9?$AAR?$AAO?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IMPFOPBG@?$AAr?$AAo?$AA?9?$AAR?$AAO?$AA?$AA@ DB 'r', 00H, 'o', 00H
	DB	'-', 00H, 'R', 00H, 'O', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BOCFIGEP@?$AAp?$AAt?$AA?9?$AAB?$AAR?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BOCFIGEP@?$AAp?$AAt?$AA?9?$AAB?$AAR?$AA?$AA@ DB 'p', 00H, 't', 00H
	DB	'-', 00H, 'B', 00H, 'R', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@NEIEMEGP@?$AAp?$AAl?$AA?9?$AAP?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1M@NEIEMEGP@?$AAp?$AAl?$AA?9?$AAP?$AAL?$AA?$AA@ DB 'p', 00H, 'l', 00H
	DB	'-', 00H, 'P', 00H, 'L', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@EANAGDL@?$AAn?$AAb?$AA?9?$AAN?$AAO?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EANAGDL@?$AAn?$AAb?$AA?9?$AAN?$AAO?$AA?$AA@ DB 'n', 00H, 'b', 00H
	DB	'-', 00H, 'N', 00H, 'O', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IHBJJGG@?$AAn?$AAl?$AA?9?$AAN?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IHBJJGG@?$AAn?$AAl?$AA?9?$AAN?$AAL?$AA?$AA@ DB 'n', 00H, 'l', 00H
	DB	'-', 00H, 'N', 00H, 'L', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JLOOOEGK@?$AAk?$AAo?$AA?9?$AAK?$AAR?$AA?$AA@
CONST	SEGMENT
??_C@_1M@JLOOOEGK@?$AAk?$AAo?$AA?9?$AAK?$AAR?$AA?$AA@ DB 'k', 00H, 'o', 00H
	DB	'-', 00H, 'K', 00H, 'R', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HPNHIDJI@?$AAj?$AAa?$AA?9?$AAJ?$AAP?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HPNHIDJI@?$AAj?$AAa?$AA?9?$AAJ?$AAP?$AA?$AA@ DB 'j', 00H, 'a', 00H
	DB	'-', 00H, 'J', 00H, 'P', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MADIPODN@?$AAi?$AAt?$AA?9?$AAI?$AAT?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MADIPODN@?$AAi?$AAt?$AA?9?$AAI?$AAT?$AA?$AA@ DB 'i', 00H, 't', 00H
	DB	'-', 00H, 'I', 00H, 'T', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LPDDNNPN@?$AAi?$AAs?$AA?9?$AAI?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LPDDNNPN@?$AAi?$AAs?$AA?9?$AAI?$AAS?$AA?$AA@ DB 'i', 00H, 's', 00H
	DB	'-', 00H, 'I', 00H, 'S', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MHLPGNKM@?$AAh?$AAu?$AA?9?$AAH?$AAU?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MHLPGNKM@?$AAh?$AAu?$AA?9?$AAH?$AAU?$AA?$AA@ DB 'h', 00H, 'u', 00H
	DB	'-', 00H, 'H', 00H, 'U', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GFMCHPE@?$AAh?$AAe?$AA?9?$AAI?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GFMCHPE@?$AAh?$AAe?$AA?9?$AAI?$AAL?$AA?$AA@ DB 'h', 00H, 'e', 00H
	DB	'-', 00H, 'I', 00H, 'L', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GLIPPMAC@?$AAf?$AAr?$AA?9?$AAF?$AAR?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GLIPPMAC@?$AAf?$AAr?$AA?9?$AAF?$AAR?$AA?$AA@ DB 'f', 00H, 'r', 00H
	DB	'-', 00H, 'F', 00H, 'R', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DDNJFGID@?$AAf?$AAi?$AA?9?$AAF?$AAI?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DDNJFGID@?$AAf?$AAi?$AA?9?$AAF?$AAI?$AA?$AA@ DB 'f', 00H, 'i', 00H
	DB	'-', 00H, 'F', 00H, 'I', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BMHNFIME@?$AAe?$AAn?$AA?9?$AAU?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BMHNFIME@?$AAe?$AAn?$AA?9?$AAU?$AAS?$AA?$AA@ DB 'e', 00H, 'n', 00H
	DB	'-', 00H, 'U', 00H, 'S', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@OOCKEMAM@?$AAe?$AAl?$AA?9?$AAG?$AAR?$AA?$AA@
CONST	SEGMENT
??_C@_1M@OOCKEMAM@?$AAe?$AAl?$AA?9?$AAG?$AAR?$AA?$AA@ DB 'e', 00H, 'l', 00H
	DB	'-', 00H, 'G', 00H, 'R', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MCMADGCB@?$AAd?$AAe?$AA?9?$AAD?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MCMADGCB@?$AAd?$AAe?$AA?9?$AAD?$AAE?$AA?$AA@ DB 'd', 00H, 'e', 00H
	DB	'-', 00H, 'D', 00H, 'E', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CLPEOBGI@?$AAd?$AAa?$AA?9?$AAD?$AAK?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CLPEOBGI@?$AAd?$AAa?$AA?9?$AAD?$AAK?$AA?$AA@ DB 'd', 00H, 'a', 00H
	DB	'-', 00H, 'D', 00H, 'K', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IJJHFJHA@?$AAc?$AAs?$AA?9?$AAC?$AAZ?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IJJHFJHA@?$AAc?$AAs?$AA?9?$AAC?$AAZ?$AA?$AA@ DB 'c', 00H, 's', 00H
	DB	'-', 00H, 'C', 00H, 'Z', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CLNBBOPM@?$AAz?$AAh?$AA?9?$AAT?$AAW?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CLNBBOPM@?$AAz?$AAh?$AA?9?$AAT?$AAW?$AA?$AA@ DB 'z', 00H, 'h', 00H
	DB	'-', 00H, 'T', 00H, 'W', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BJNKEDC@?$AAc?$AAa?$AA?9?$AAE?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BJNKEDC@?$AAc?$AAa?$AA?9?$AAE?$AAS?$AA?$AA@ DB 'c', 00H, 'a', 00H
	DB	'-', 00H, 'E', 00H, 'S', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FFFIGIGK@?$AAb?$AAg?$AA?9?$AAB?$AAG?$AA?$AA@
CONST	SEGMENT
??_C@_1M@FFFIGIGK@?$AAb?$AAg?$AA?9?$AAB?$AAG?$AA?$AA@ DB 'b', 00H, 'g', 00H
	DB	'-', 00H, 'B', 00H, 'G', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@OKAHONE@?$AAa?$AAr?$AA?9?$AAS?$AAA?$AA?$AA@
CONST	SEGMENT
??_C@_1M@OKAHONE@?$AAa?$AAr?$AA?9?$AAS?$AAA?$AA?$AA@ DB 'a', 00H, 'r', 00H
	DB	'-', 00H, 'S', 00H, 'A', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_17KPNDCPAF@?$AAd?$AAi?$AAv?$AA?$AA@
CONST	SEGMENT
??_C@_17KPNDCPAF@?$AAd?$AAi?$AAv?$AA?$AA@ DB 'd', 00H, 'i', 00H, 'v', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_17FFBJICPL@?$AAs?$AAy?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_17FFBJICPL@?$AAs?$AAy?$AAr?$AA?$AA@ DB 's', 00H, 'y', 00H, 'r', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_17CNJFBPG@?$AAk?$AAo?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_17CNJFBPG@?$AAk?$AAo?$AAk?$AA?$AA@ DB 'k', 00H, 'o', 00H, 'k', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LNEGBOLO@atlTraceSnapin?$AA@
CONST	SEGMENT
??_C@_0P@LNEGBOLO@atlTraceSnapin?$AA@ DB 'atlTraceSnapin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15CKDMCJAF@?$AAg?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_15CKDMCJAF@?$AAg?$AAl?$AA?$AA@ DB 'g', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15CBKOMCOI@?$AAm?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_15CBKOMCOI@?$AAm?$AAn?$AA?$AA@ DB 'm', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15EABBLBFF@?$AAs?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_15EABBLBFF@?$AAs?$AAa?$AA?$AA@ DB 's', 00H, 'a', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15DLGBCKMP@?$AAm?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_15DLGBCKMP@?$AAm?$AAr?$AA?$AA@ DB 'm', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15PHPHCBPF@?$AAk?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_15PHPHCBPF@?$AAk?$AAn?$AA?$AA@ DB 'k', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15NCHGBGLK@?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_15NCHGBGLK@?$AAt?$AAe?$AA?$AA@ DB 't', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15FNBEIBON@?$AAt?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_15FNBEIBON@?$AAt?$AAa?$AA?$AA@ DB 't', 00H, 'a', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15HCNDBBA@?$AAg?$AAu?$AA?$AA@
CONST	SEGMENT
??_C@_15HCNDBBA@?$AAg?$AAu?$AA?$AA@ DB 'g', 00H, 'u', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15MGIFMDPL@?$AAp?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_15MGIFMDPL@?$AAp?$AAa?$AA?$AA@ DB 'p', 00H, 'a', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15DKNDCGEA@?$AAt?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_15DKNDCGEA@?$AAt?$AAt?$AA?$AA@ DB 't', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15BBFAICNG@?$AAu?$AAz?$AA?$AA@
CONST	SEGMENT
??_C@_15BBFAICNG@?$AAu?$AAz?$AA?$AA@ DB 'u', 00H, 'z', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15DFGDLJBG@?$AAs?$AAw?$AA?$AA@
CONST	SEGMENT
??_C@_15DFGDLJBG@?$AAs?$AAw?$AA?$AA@ DB 's', 00H, 'w', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15DKDJEOND@?$AAk?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_15DKDJEOND@?$AAk?$AAy?$AA?$AA@ DB 'k', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15MACJNBMH@?$AAk?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_15MACJNBMH@?$AAk?$AAk?$AA?$AA@ DB 'k', 00H, 'k', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15IDNNENKK@?$AAm?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_15IDNNENKK@?$AAm?$AAs?$AA?$AA@ DB 'm', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15OMLEGLOC@?$AAh?$AAi?$AA?$AA@
CONST	SEGMENT
??_C@_15OMLEGLOC@?$AAh?$AAi?$AA?$AA@ DB 'h', 00H, 'i', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15PDNFFFEO@?$AAf?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_15PDNFFFEO@?$AAf?$AAo?$AA?$AA@ DB 'f', 00H, 'o', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15KPJEDBKD@?$AAk?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_15KPJEDBKD@?$AAk?$AAa?$AA?$AA@ DB 'k', 00H, 'a', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15JDNICKHM@?$AAa?$AAf?$AA?$AA@
CONST	SEGMENT
??_C@_15JDNICKHM@?$AAa?$AAf?$AA?$AA@ DB 'a', 00H, 'f', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15BGHADCNK@?$AAm?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_15BGHADCNK@?$AAm?$AAk?$AA?$AA@ DB 'm', 00H, 'k', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15EKOFJABL@?$AAe?$AAu?$AA?$AA@
CONST	SEGMENT
??_C@_15EKOFJABL@?$AAe?$AAu?$AA?$AA@ DB 'e', 00H, 'u', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15IJBHMCFL@?$AAa?$AAz?$AA?$AA@
CONST	SEGMENT
??_C@_15IJBHMCFL@?$AAa?$AAz?$AA?$AA@ DB 'a', 00H, 'z', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15LMKNDMHN@?$AAh?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_15LMKNDMHN@?$AAh?$AAy?$AA?$AA@ DB 'h', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15NFGIAIAJ@?$AAv?$AAi?$AA?$AA@
CONST	SEGMENT
??_C@_15NFGIAIAJ@?$AAv?$AAi?$AA?$AA@ DB 'v', 00H, 'i', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15BDAKCCHN@?$AAf?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_15BDAKCCHN@?$AAf?$AAa?$AA?$AA@ DB 'f', 00H, 'a', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15NFFGKGLG@?$AAl?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_15NFFGKGLG@?$AAl?$AAt?$AA?$AA@ DB 'l', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15HPFPGODN@?$AAl?$AAv?$AA?$AA@
CONST	SEGMENT
??_C@_15HPFPGODN@?$AAl?$AAv?$AA?$AA@ DB 'l', 00H, 'v', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ??_C@_15PCFJPHHO@?$AAe?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_15PCFJPHHO@?$AAe?$AAt?$AA?$AA@ DB 'e', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15LCHLGJII@?$AAs?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_15LCHLGJII@?$AAs?$AAl?$AA?$AA@ DB 's', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15HPJPHDM@?$AAb?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_15HPJPHDM@?$AAb?$AAe?$AA?$AA@ DB 'b', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15PJPFLCCM@?$AAu?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_15PJPFLCCM@?$AAu?$AAk?$AA?$AA@ DB 'u', 00H, 'k', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15NFICGAJK@?$AAi?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_15NFICGAJK@?$AAi?$AAd?$AA?$AA@ DB 'i', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15NEOEKKDJ@?$AAu?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_15NEOEKKDJ@?$AAu?$AAr?$AA?$AA@ DB 'u', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15BPLIHJJM@?$AAt?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_15BPLIHJJM@?$AAt?$AAr?$AA?$AA@ DB 't', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15CABMMOGH@?$AAt?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_15CABMMOGH@?$AAt?$AAh?$AA?$AA@ DB 't', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15INNPNOHD@?$AAs?$AAv?$AA?$AA@
CONST	SEGMENT
??_C@_15INNPNOHD@?$AAs?$AAv?$AA?$AA@ DB 's', 00H, 'v', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15BAAIOGMK@?$AAs?$AAq?$AA?$AA@
CONST	SEGMENT
??_C@_15BAAIOGMK@?$AAs?$AAq?$AA?$AA@ DB 's', 00H, 'q', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15CPKMFBDB@?$AAs?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_15CPKMFBDB@?$AAs?$AAk?$AA?$AA@ DB 's', 00H, 'k', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15GLKMLLHM@?$AAh?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_15GLKMLLHM@?$AAh?$AAr?$AA?$AA@ DB 'h', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15FEDGKCDI@?$AAr?$AAu?$AA?$AA@
CONST	SEGMENT
??_C@_15FEDGKCDI@?$AAr?$AAu?$AA?$AA@ DB 'r', 00H, 'u', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15GLJCBFMD@?$AAr?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_15GLJCBFMD@?$AAr?$AAo?$AA?$AA@ DB 'r', 00H, 'o', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15KBECGEFG@?$AAp?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_15KBECGEFG@?$AAp?$AAt?$AA?$AA@ DB 'p', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15DEOPBLCG@?$AAp?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_15DEOPBLCG@?$AAp?$AAl?$AA?$AA@ DB 'p', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15BPIGNHCD@?$AAn?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_15BPIGNHCD@?$AAn?$AAo?$AA?$AA@ DB 'n', 00H, 'o', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15NDDHIMN@?$AAn?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_15NDDHIMN@?$AAn?$AAl?$AA?$AA@ DB 'n', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15EPELEGJA@?$AAk?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_15EPELEGJA@?$AAk?$AAo?$AA?$AA@ DB 'k', 00H, 'o', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15GEMIOCAG@?$AAj?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_15GEMIOCAG@?$AAj?$AAa?$AA?$AA@ DB 'j', 00H, 'a', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KOADKDIA@atlTraceDBProvider?$AA@
CONST	SEGMENT
??_C@_0BD@KOADKDIA@atlTraceDBProvider?$AA@ DB 'atlTraceDBProvider', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15IFJLDHAF@?$AAi?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_15IFJLDHAF@?$AAi?$AAt?$AA?$AA@ DB 'i', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15BIEMAPLM@?$AAi?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_15BIEMAPLM@?$AAi?$AAs?$AA?$AA@ DB 'i', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15PGHLIDMF@?$AAh?$AAu?$AA?$AA@
CONST	SEGMENT
??_C@_15PGHLIDMF@?$AAh?$AAu?$AA?$AA@ DB 'h', 00H, 'u', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15KGGCNEFK@?$AAh?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_15KGGCNEFK@?$AAh?$AAe?$AA?$AA@ DB 'h', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15FBKGNKAM@?$AAf?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_15FBKGNKAM@?$AAf?$AAr?$AA?$AA@ DB 'f', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15NGLOAKJC@?$AAf?$AAi?$AA?$AA@
CONST	SEGMENT
??_C@_15NGLOAKJC@?$AAf?$AAi?$AA?$AA@ DB 'f', 00H, 'i', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15GPIOMPMH@?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_15GPIOMPMH@?$AAe?$AAs?$AA?$AA@ DB 'e', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15MNPNEAIF@?$AAe?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_15MNPNEAIF@?$AAe?$AAn?$AA?$AA@ DB 'e', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15GHPEIIAO@?$AAe?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_15GHPEIIAO@?$AAe?$AAl?$AA?$AA@ DB 'e', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15NBKABECB@?$AAd?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_15NBKABECB@?$AAd?$AAe?$AA?$AA@ DB 'd', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15FOMCIDHG@?$AAd?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_15FOMCIDHG@?$AAd?$AAa?$AA?$AA@ DB 'd', 00H, 'a', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15LJNHCMNK@?$AAc?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_15LJNHCMNK@?$AAc?$AAs?$AA?$AA@ DB 'c', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@BPEAJADD@?$AAz?$AAh?$AA?9?$AAC?$AAH?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_1O@BPEAJADD@?$AAz?$AAh?$AA?9?$AAC?$AAH?$AAS?$AA?$AA@ DB 'z', 00H, 'h'
	DB	00H, '-', 00H, 'C', 00H, 'H', 00H, 'S', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15EDMHLDMO@?$AAc?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_15EDMHLDMO@?$AAc?$AAa?$AA?$AA@ DB 'c', 00H, 'a', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15KNPADPLH@?$AAb?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_15KNPADPLH@?$AAb?$AAg?$AA?$AA@ DB 'b', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15EMKDOKLE@?$AAa?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_15EMKDOKLE@?$AAa?$AAr?$AA?$AA@ DB 'a', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT __pAtlLcidToLocaleNameTable
CONST	SEGMENT
__pAtlLcidToLocaleNameTable DD 01H
	DD	FLAT:??_C@_15EMKDOKLE@?$AAa?$AAr?$AA?$AA@
	DD	02H
	DD	FLAT:??_C@_15KNPADPLH@?$AAb?$AAg?$AA?$AA@
	DD	03H
	DD	FLAT:??_C@_15EDMHLDMO@?$AAc?$AAa?$AA?$AA@
	DD	04H
	DD	FLAT:??_C@_1O@BPEAJADD@?$AAz?$AAh?$AA?9?$AAC?$AAH?$AAS?$AA?$AA@
	DD	05H
	DD	FLAT:??_C@_15LJNHCMNK@?$AAc?$AAs?$AA?$AA@
	DD	06H
	DD	FLAT:??_C@_15FOMCIDHG@?$AAd?$AAa?$AA?$AA@
	DD	07H
	DD	FLAT:??_C@_15NBKABECB@?$AAd?$AAe?$AA?$AA@
	DD	08H
	DD	FLAT:??_C@_15GHPEIIAO@?$AAe?$AAl?$AA?$AA@
	DD	09H
	DD	FLAT:??_C@_15MNPNEAIF@?$AAe?$AAn?$AA?$AA@
	DD	0aH
	DD	FLAT:??_C@_15GPIOMPMH@?$AAe?$AAs?$AA?$AA@
	DD	0bH
	DD	FLAT:??_C@_15NGLOAKJC@?$AAf?$AAi?$AA?$AA@
	DD	0cH
	DD	FLAT:??_C@_15FBKGNKAM@?$AAf?$AAr?$AA?$AA@
	DD	0dH
	DD	FLAT:??_C@_15KGGCNEFK@?$AAh?$AAe?$AA?$AA@
	DD	0eH
	DD	FLAT:??_C@_15PGHLIDMF@?$AAh?$AAu?$AA?$AA@
	DD	0fH
	DD	FLAT:??_C@_15BIEMAPLM@?$AAi?$AAs?$AA?$AA@
	DD	010H
	DD	FLAT:??_C@_15IFJLDHAF@?$AAi?$AAt?$AA?$AA@
	DD	011H
	DD	FLAT:??_C@_15GEMIOCAG@?$AAj?$AAa?$AA?$AA@
	DD	012H
	DD	FLAT:??_C@_15EPELEGJA@?$AAk?$AAo?$AA?$AA@
	DD	013H
	DD	FLAT:??_C@_15NDDHIMN@?$AAn?$AAl?$AA?$AA@
	DD	014H
	DD	FLAT:??_C@_15BPIGNHCD@?$AAn?$AAo?$AA?$AA@
	DD	015H
	DD	FLAT:??_C@_15DEOPBLCG@?$AAp?$AAl?$AA?$AA@
	DD	016H
	DD	FLAT:??_C@_15KBECGEFG@?$AAp?$AAt?$AA?$AA@
	DD	018H
	DD	FLAT:??_C@_15GLJCBFMD@?$AAr?$AAo?$AA?$AA@
	DD	019H
	DD	FLAT:??_C@_15FEDGKCDI@?$AAr?$AAu?$AA?$AA@
	DD	01aH
	DD	FLAT:??_C@_15GLKMLLHM@?$AAh?$AAr?$AA?$AA@
	DD	01bH
	DD	FLAT:??_C@_15CPKMFBDB@?$AAs?$AAk?$AA?$AA@
	DD	01cH
	DD	FLAT:??_C@_15BAAIOGMK@?$AAs?$AAq?$AA?$AA@
	DD	01dH
	DD	FLAT:??_C@_15INNPNOHD@?$AAs?$AAv?$AA?$AA@
	DD	01eH
	DD	FLAT:??_C@_15CABMMOGH@?$AAt?$AAh?$AA?$AA@
	DD	01fH
	DD	FLAT:??_C@_15BPLIHJJM@?$AAt?$AAr?$AA?$AA@
	DD	020H
	DD	FLAT:??_C@_15NEOEKKDJ@?$AAu?$AAr?$AA?$AA@
	DD	021H
	DD	FLAT:??_C@_15NFICGAJK@?$AAi?$AAd?$AA?$AA@
	DD	022H
	DD	FLAT:??_C@_15PJPFLCCM@?$AAu?$AAk?$AA?$AA@
	DD	023H
	DD	FLAT:??_C@_15HPJPHDM@?$AAb?$AAe?$AA?$AA@
	DD	024H
	DD	FLAT:??_C@_15LCHLGJII@?$AAs?$AAl?$AA?$AA@
	DD	025H
	DD	FLAT:??_C@_15PCFJPHHO@?$AAe?$AAt?$AA?$AA@
	DD	026H
	DD	FLAT:??_C@_15HPFPGODN@?$AAl?$AAv?$AA?$AA@
	DD	027H
	DD	FLAT:??_C@_15NFFGKGLG@?$AAl?$AAt?$AA?$AA@
	DD	029H
	DD	FLAT:??_C@_15BDAKCCHN@?$AAf?$AAa?$AA?$AA@
	DD	02aH
	DD	FLAT:??_C@_15NFGIAIAJ@?$AAv?$AAi?$AA?$AA@
	DD	02bH
	DD	FLAT:??_C@_15LMKNDMHN@?$AAh?$AAy?$AA?$AA@
	DD	02cH
	DD	FLAT:??_C@_15IJBHMCFL@?$AAa?$AAz?$AA?$AA@
	DD	02dH
	DD	FLAT:??_C@_15EKOFJABL@?$AAe?$AAu?$AA?$AA@
	DD	02fH
	DD	FLAT:??_C@_15BGHADCNK@?$AAm?$AAk?$AA?$AA@
	DD	036H
	DD	FLAT:??_C@_15JDNICKHM@?$AAa?$AAf?$AA?$AA@
	DD	037H
	DD	FLAT:??_C@_15KPJEDBKD@?$AAk?$AAa?$AA?$AA@
	DD	038H
	DD	FLAT:??_C@_15PDNFFFEO@?$AAf?$AAo?$AA?$AA@
	DD	039H
	DD	FLAT:??_C@_15OMLEGLOC@?$AAh?$AAi?$AA?$AA@
	DD	03eH
	DD	FLAT:??_C@_15IDNNENKK@?$AAm?$AAs?$AA?$AA@
	DD	03fH
	DD	FLAT:??_C@_15MACJNBMH@?$AAk?$AAk?$AA?$AA@
	DD	040H
	DD	FLAT:??_C@_15DKDJEOND@?$AAk?$AAy?$AA?$AA@
	DD	041H
	DD	FLAT:??_C@_15DFGDLJBG@?$AAs?$AAw?$AA?$AA@
	DD	043H
	DD	FLAT:??_C@_15BBFAICNG@?$AAu?$AAz?$AA?$AA@
	DD	044H
	DD	FLAT:??_C@_15DKNDCGEA@?$AAt?$AAt?$AA?$AA@
	DD	046H
	DD	FLAT:??_C@_15MGIFMDPL@?$AAp?$AAa?$AA?$AA@
	DD	047H
	DD	FLAT:??_C@_15HCNDBBA@?$AAg?$AAu?$AA?$AA@
	DD	049H
	DD	FLAT:??_C@_15FNBEIBON@?$AAt?$AAa?$AA?$AA@
	DD	04aH
	DD	FLAT:??_C@_15NCHGBGLK@?$AAt?$AAe?$AA?$AA@
	DD	04bH
	DD	FLAT:??_C@_15PHPHCBPF@?$AAk?$AAn?$AA?$AA@
	DD	04eH
	DD	FLAT:??_C@_15DLGBCKMP@?$AAm?$AAr?$AA?$AA@
	DD	04fH
	DD	FLAT:??_C@_15EABBLBFF@?$AAs?$AAa?$AA?$AA@
	DD	050H
	DD	FLAT:??_C@_15CBKOMCOI@?$AAm?$AAn?$AA?$AA@
	DD	056H
	DD	FLAT:??_C@_15CKDMCJAF@?$AAg?$AAl?$AA?$AA@
	DD	057H
	DD	FLAT:??_C@_17CNJFBPG@?$AAk?$AAo?$AAk?$AA?$AA@
	DD	05aH
	DD	FLAT:??_C@_17FFBJICPL@?$AAs?$AAy?$AAr?$AA?$AA@
	DD	065H
	DD	FLAT:??_C@_17KPNDCPAF@?$AAd?$AAi?$AAv?$AA?$AA@
	DD	07fH
	DD	FLAT:??_C@_11LOCGONAA@?$AA?$AA@
	DD	0401H
	DD	FLAT:??_C@_1M@OKAHONE@?$AAa?$AAr?$AA?9?$AAS?$AAA?$AA?$AA@
	DD	0402H
	DD	FLAT:??_C@_1M@FFFIGIGK@?$AAb?$AAg?$AA?9?$AAB?$AAG?$AA?$AA@
	DD	0403H
	DD	FLAT:??_C@_1M@BJNKEDC@?$AAc?$AAa?$AA?9?$AAE?$AAS?$AA?$AA@
	DD	0404H
	DD	FLAT:??_C@_1M@CLNBBOPM@?$AAz?$AAh?$AA?9?$AAT?$AAW?$AA?$AA@
	DD	0405H
	DD	FLAT:??_C@_1M@IJJHFJHA@?$AAc?$AAs?$AA?9?$AAC?$AAZ?$AA?$AA@
	DD	0406H
	DD	FLAT:??_C@_1M@CLPEOBGI@?$AAd?$AAa?$AA?9?$AAD?$AAK?$AA?$AA@
	DD	0407H
	DD	FLAT:??_C@_1M@MCMADGCB@?$AAd?$AAe?$AA?9?$AAD?$AAE?$AA?$AA@
	DD	0408H
	DD	FLAT:??_C@_1M@OOCKEMAM@?$AAe?$AAl?$AA?9?$AAG?$AAR?$AA?$AA@
	DD	0409H
	DD	FLAT:??_C@_1M@BMHNFIME@?$AAe?$AAn?$AA?9?$AAU?$AAS?$AA?$AA@
	DD	040bH
	DD	FLAT:??_C@_1M@DDNJFGID@?$AAf?$AAi?$AA?9?$AAF?$AAI?$AA?$AA@
	DD	040cH
	DD	FLAT:??_C@_1M@GLIPPMAC@?$AAf?$AAr?$AA?9?$AAF?$AAR?$AA?$AA@
	DD	040dH
	DD	FLAT:??_C@_1M@GFMCHPE@?$AAh?$AAe?$AA?9?$AAI?$AAL?$AA?$AA@
	DD	040eH
	DD	FLAT:??_C@_1M@MHLPGNKM@?$AAh?$AAu?$AA?9?$AAH?$AAU?$AA?$AA@
	DD	040fH
	DD	FLAT:??_C@_1M@LPDDNNPN@?$AAi?$AAs?$AA?9?$AAI?$AAS?$AA?$AA@
	DD	0410H
	DD	FLAT:??_C@_1M@MADIPODN@?$AAi?$AAt?$AA?9?$AAI?$AAT?$AA?$AA@
	DD	0411H
	DD	FLAT:??_C@_1M@HPNHIDJI@?$AAj?$AAa?$AA?9?$AAJ?$AAP?$AA?$AA@
	DD	0412H
	DD	FLAT:??_C@_1M@JLOOOEGK@?$AAk?$AAo?$AA?9?$AAK?$AAR?$AA?$AA@
	DD	0413H
	DD	FLAT:??_C@_1M@IHBJJGG@?$AAn?$AAl?$AA?9?$AAN?$AAL?$AA?$AA@
	DD	0414H
	DD	FLAT:??_C@_1M@EANAGDL@?$AAn?$AAb?$AA?9?$AAN?$AAO?$AA?$AA@
	DD	0415H
	DD	FLAT:??_C@_1M@NEIEMEGP@?$AAp?$AAl?$AA?9?$AAP?$AAL?$AA?$AA@
	DD	0416H
	DD	FLAT:??_C@_1M@BOCFIGEP@?$AAp?$AAt?$AA?9?$AAB?$AAR?$AA?$AA@
	DD	0418H
	DD	FLAT:??_C@_1M@IMPFOPBG@?$AAr?$AAo?$AA?9?$AAR?$AAO?$AA?$AA@
	DD	0419H
	DD	FLAT:??_C@_1M@IDNNEJMM@?$AAr?$AAu?$AA?9?$AAR?$AAU?$AA?$AA@
	DD	041aH
	DD	FLAT:??_C@_1M@LILEEOGM@?$AAh?$AAr?$AA?9?$AAH?$AAR?$AA?$AA@
	DD	041bH
	DD	FLAT:??_C@_1M@FKIFEHPB@?$AAs?$AAk?$AA?9?$AAS?$AAK?$AA?$AA@
	DD	041cH
	DD	FLAT:??_C@_1M@LJMAMNPJ@?$AAs?$AAq?$AA?9?$AAA?$AAL?$AA?$AA@
	DD	041dH
	DD	FLAT:??_C@_1M@GIAKDKJK@?$AAs?$AAv?$AA?9?$AAS?$AAE?$AA?$AA@
	DD	041eH
	DD	FLAT:??_C@_1M@MKJKIKCL@?$AAt?$AAh?$AA?9?$AAT?$AAH?$AA?$AA@
	DD	041fH
	DD	FLAT:??_C@_1M@MFLCCMPB@?$AAt?$AAr?$AA?9?$AAT?$AAR?$AA?$AA@
	DD	0420H
	DD	FLAT:??_C@_1M@OIJHDKJN@?$AAu?$AAr?$AA?9?$AAP?$AAK?$AA?$AA@
	DD	0421H
	DD	FLAT:??_C@_1M@LHIPCIEK@?$AAi?$AAd?$AA?9?$AAI?$AAD?$AA?$AA@
	DD	0422H
	DD	FLAT:??_C@_1M@MFMOBGI@?$AAu?$AAk?$AA?9?$AAU?$AAA?$AA?$AA@
	DD	0423H
	DD	FLAT:??_C@_1M@OBGLJIPL@?$AAb?$AAe?$AA?9?$AAB?$AAY?$AA?$AA@
	DD	0424H
	DD	FLAT:??_C@_1M@BCFAJEAD@?$AAs?$AAl?$AA?9?$AAS?$AAI?$AA?$AA@
	DD	0425H
	DD	FLAT:??_C@_1M@FKFFEDDN@?$AAe?$AAt?$AA?9?$AAE?$AAE?$AA?$AA@
	DD	0426H
	DD	FLAT:??_C@_1M@KGKKAACI@?$AAl?$AAv?$AA?9?$AAL?$AAV?$AA?$AA@
	DD	0427H
	DD	FLAT:??_C@_1M@IFGBIJO@?$AAl?$AAt?$AA?9?$AAL?$AAT?$AA?$AA@
	DD	0429H
	DD	FLAT:??_C@_1M@FGEAHEDM@?$AAf?$AAa?$AA?9?$AAI?$AAR?$AA?$AA@
	DD	042aH
	DD	FLAT:??_C@_1M@KBMAIBFN@?$AAv?$AAi?$AA?9?$AAV?$AAN?$AA?$AA@
	DD	042bH
	DD	FLAT:??_C@_1M@GPCBKDJK@?$AAh?$AAy?$AA?9?$AAA?$AAM?$AA?$AA@
	DD	042cH
	DD	FLAT:??_C@_1BG@BECMDDJB@?$AAa?$AAz?$AA?9?$AAA?$AAZ?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@
	DD	042dH
	DD	FLAT:??_C@_1M@MAOFCAEA@?$AAe?$AAu?$AA?9?$AAE?$AAS?$AA?$AA@
	DD	042fH
	DD	FLAT:??_C@_1M@IGHABKPI@?$AAm?$AAk?$AA?9?$AAM?$AAK?$AA?$AA@
	DD	0432H
	DD	FLAT:??_C@_1M@IAIGNEJG@?$AAt?$AAn?$AA?9?$AAZ?$AAA?$AA?$AA@
	DD	0434H
	DD	FLAT:??_C@_1M@IIJCOJFA@?$AAx?$AAh?$AA?9?$AAZ?$AAA?$AA?$AA@
	DD	0435H
	DD	FLAT:??_C@_1M@LGPJHNJH@?$AAz?$AAu?$AA?9?$AAZ?$AAA?$AA?$AA@
	DD	0436H
	DD	FLAT:??_C@_1M@HOKAOIO@?$AAa?$AAf?$AA?9?$AAZ?$AAA?$AA?$AA@
	DD	0437H
	DD	FLAT:??_C@_1M@DPCLHLIE@?$AAk?$AAa?$AA?9?$AAG?$AAE?$AA?$AA@
	DD	0438H
	DD	FLAT:??_C@_1M@BLKMHJBI@?$AAf?$AAo?$AA?9?$AAF?$AAO?$AA?$AA@
	DD	0439H
	DD	FLAT:??_C@_1M@LGGJAPPB@?$AAh?$AAi?$AA?9?$AAI?$AAN?$AA?$AA@
	DD	043aH
	DD	FLAT:??_C@_1M@FIKPIHFE@?$AAm?$AAt?$AA?9?$AAM?$AAT?$AA?$AA@
	DD	043bH
	DD	FLAT:??_C@_1M@HEGGPBFA@?$AAs?$AAe?$AA?9?$AAN?$AAO?$AA?$AA@
	DD	043eH
	DD	FLAT:??_C@_1M@EIBJEEPA@?$AAm?$AAs?$AA?9?$AAM?$AAY?$AA?$AA@
	DD	043fH
	DD	FLAT:??_C@_1M@FHLBGMPP@?$AAk?$AAk?$AA?9?$AAK?$AAZ?$AA?$AA@
	DD	0440H
	DD	FLAT:??_C@_1M@NGJJLCGI@?$AAk?$AAy?$AA?9?$AAK?$AAG?$AA?$AA@
	DD	0441H
	DD	FLAT:??_C@_1M@GIENNBFC@?$AAs?$AAw?$AA?9?$AAK?$AAE?$AA?$AA@
	DD	0443H
	DD	FLAT:??_C@_1BG@NDGMJIMJ@?$AAu?$AAz?$AA?9?$AAU?$AAZ?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@
	DD	0444H
	DD	FLAT:??_C@_1M@IDCCIHBC@?$AAt?$AAt?$AA?9?$AAR?$AAU?$AA?$AA@
	DD	0445H
	DD	FLAT:??_C@_1M@LOICPMOJ@?$AAb?$AAn?$AA?9?$AAI?$AAN?$AA?$AA@
	DD	0446H
	DD	FLAT:??_C@_1M@KPKKNEAH@?$AAp?$AAa?$AA?9?$AAI?$AAN?$AA?$AA@
	DD	0447H
	DD	FLAT:??_C@_1M@PJGPPBOG@?$AAg?$AAu?$AA?9?$AAI?$AAN?$AA?$AA@
	DD	0449H
	DD	FLAT:??_C@_1M@KMKMOPHI@?$AAt?$AAa?$AA?9?$AAI?$AAN?$AA?$AA@
	DD	044aH
	DD	FLAT:??_C@_1M@KFEHEPAC@?$AAt?$AAe?$AA?9?$AAI?$AAN?$AA?$AA@
	DD	044bH
	DD	FLAT:??_C@_1M@CDCLMGHI@?$AAk?$AAn?$AA?9?$AAI?$AAN?$AA?$AA@
	DD	044cH
	DD	FLAT:??_C@_1M@MIODLDKF@?$AAm?$AAl?$AA?9?$AAI?$AAN?$AA?$AA@
	DD	044eH
	DD	FLAT:??_C@_1M@PBIEACPO@?$AAm?$AAr?$AA?9?$AAI?$AAN?$AA?$AA@
	DD	044fH
	DD	FLAT:??_C@_1M@NIDEAGPH@?$AAs?$AAa?$AA?9?$AAI?$AAN?$AA?$AA@
	DD	0450H
	DD	FLAT:??_C@_1M@FHIHCBIO@?$AAm?$AAn?$AA?9?$AAM?$AAN?$AA?$AA@
	DD	0452H
	DD	FLAT:??_C@_1M@JAIJPENP@?$AAc?$AAy?$AA?9?$AAG?$AAB?$AA?$AA@
	DD	0456H
	DD	FLAT:??_C@_1M@PHGFBEPN@?$AAg?$AAl?$AA?9?$AAE?$AAS?$AA?$AA@
	DD	0457H
	DD	FLAT:??_C@_1O@KPIPDNCP@?$AAk?$AAo?$AAk?$AA?9?$AAI?$AAN?$AA?$AA@
	DD	045aH
	DD	FLAT:??_C@_1O@KNHJLDJA@?$AAs?$AAy?$AAr?$AA?9?$AAS?$AAY?$AA?$AA@
	DD	0465H
	DD	FLAT:??_C@_1O@MKEKBLAH@?$AAd?$AAi?$AAv?$AA?9?$AAM?$AAV?$AA?$AA@
	DD	046bH
	DD	FLAT:??_C@_1O@OHDCKDDF@?$AAq?$AAu?$AAz?$AA?9?$AAB?$AAO?$AA?$AA@
	DD	046cH
	DD	FLAT:??_C@_1M@LEPJNLFD@?$AAn?$AAs?$AA?9?$AAZ?$AAA?$AA?$AA@
	DD	0481H
	DD	FLAT:??_C@_1M@OMLEIIJB@?$AAm?$AAi?$AA?9?$AAN?$AAZ?$AA?$AA@
	DD	0801H
	DD	FLAT:??_C@_1M@PMPEAILG@?$AAa?$AAr?$AA?9?$AAI?$AAQ?$AA?$AA@
	DD	0804H
	DD	FLAT:??_C@_1M@BIBDDEMK@?$AAz?$AAh?$AA?9?$AAC?$AAN?$AA?$AA@
	DD	0807H
	DD	FLAT:??_C@_1M@CNKPNOEE@?$AAd?$AAe?$AA?9?$AAC?$AAH?$AA?$AA@
	DD	0809H
	DD	FLAT:??_C@_1M@LKMGMLKO@?$AAe?$AAn?$AA?9?$AAG?$AAB?$AA?$AA@
	DD	080aH
	DD	FLAT:??_C@_1M@PGKJFFGL@?$AAe?$AAs?$AA?9?$AAM?$AAX?$AA?$AA@
	DD	080cH
	DD	FLAT:??_C@_1M@DNNANBDC@?$AAf?$AAr?$AA?9?$AAB?$AAE?$AA?$AA@
	DD	0810H
	DD	FLAT:??_C@_1M@HLGMDFHM@?$AAi?$AAt?$AA?9?$AAC?$AAH?$AA?$AA@
	DD	0813H
	DD	FLAT:??_C@_1M@CLLBGJH@?$AAn?$AAl?$AA?9?$AAB?$AAE?$AA?$AA@
	DD	0814H
	DD	FLAT:??_C@_1M@BODBOGLF@?$AAn?$AAn?$AA?9?$AAN?$AAO?$AA?$AA@
	DD	0816H
	DD	FLAT:??_C@_1M@HFFAHKAD@?$AAp?$AAt?$AA?9?$AAP?$AAT?$AA?$AA@
	DD	081aH
	DD	FLAT:??_C@_1BG@LNOAKHIE@?$AAs?$AAr?$AA?9?$AAS?$AAP?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@
	DD	081dH
	DD	FLAT:??_C@_1M@HBMHBGAK@?$AAs?$AAv?$AA?9?$AAF?$AAI?$AA?$AA@
	DD	082cH
	DD	FLAT:??_C@_1BG@DGCJGJBE@?$AAa?$AAz?$AA?9?$AAA?$AAZ?$AA?9?$AAC?$AAy?$AAr?$AAl?$AA?$AA@
	DD	083bH
	DD	FLAT:??_C@_1M@KEJDAAHB@?$AAs?$AAe?$AA?9?$AAS?$AAE?$AA?$AA@
	DD	083eH
	DD	FLAT:??_C@_1M@HEIBJJAD@?$AAm?$AAs?$AA?9?$AAB?$AAN?$AA?$AA@
	DD	0843H
	DD	FLAT:??_C@_1BG@PBGJMCEM@?$AAu?$AAz?$AA?9?$AAU?$AAZ?$AA?9?$AAC?$AAy?$AAr?$AAl?$AA?$AA@
	DD	086bH
	DD	FLAT:??_C@_1O@LAOBCMDF@?$AAq?$AAu?$AAz?$AA?9?$AAE?$AAC?$AA?$AA@
	DD	0c01H
	DD	FLAT:??_C@_1M@POEEMAIO@?$AAa?$AAr?$AA?9?$AAE?$AAG?$AA?$AA@
	DD	0c04H
	DD	FLAT:??_C@_1M@EFAKDEDL@?$AAz?$AAh?$AA?9?$AAH?$AAK?$AA?$AA@
	DD	0c07H
	DD	FLAT:??_C@_1M@HKKIJHGI@?$AAd?$AAe?$AA?9?$AAA?$AAT?$AA?$AA@
	DD	0c09H
	DD	FLAT:??_C@_1M@KBFBEHJF@?$AAe?$AAn?$AA?9?$AAA?$AAU?$AA?$AA@
	DD	0c0aH
	DD	FLAT:??_C@_1M@MNPLFAAH@?$AAe?$AAs?$AA?9?$AAE?$AAS?$AA?$AA@
	DD	0c0cH
	DD	FLAT:??_C@_1M@HJOOJFMA@?$AAf?$AAr?$AA?9?$AAC?$AAA?$AA?$AA@
	DD	0c1aH
	DD	FLAT:??_C@_1BG@JPOFPNAB@?$AAs?$AAr?$AA?9?$AAS?$AAP?$AA?9?$AAC?$AAy?$AAr?$AAl?$AA?$AA@
	DD	0c3bH
	DD	FLAT:??_C@_1M@LNFOCMOB@?$AAs?$AAe?$AA?9?$AAF?$AAI?$AA?$AA@
	DD	0c6bH
	DD	FLAT:??_C@_1O@MGJBOAMB@?$AAq?$AAu?$AAz?$AA?9?$AAP?$AAE?$AA?$AA@
	DD	01001H
	DD	FLAT:??_C@_1M@GJINLBOK@?$AAa?$AAr?$AA?9?$AAL?$AAY?$AA?$AA@
	DD	01004H
	DD	FLAT:??_C@_1M@GGMNHJNL@?$AAz?$AAh?$AA?9?$AAS?$AAG?$AA?$AA@
	DD	01007H
	DD	FLAT:??_C@_1M@HOIKODND@?$AAd?$AAe?$AA?9?$AAL?$AAU?$AA?$AA@
	DD	01009H
	DD	FLAT:??_C@_1M@DDOCCGFG@?$AAe?$AAn?$AA?9?$AAC?$AAA?$AA?$AA@
	DD	0100aH
	DD	FLAT:??_C@_1M@BNOEMJLF@?$AAe?$AAs?$AA?9?$AAG?$AAT?$AA?$AA@
	DD	0100cH
	DD	FLAT:??_C@_1M@EOGNKEK@?$AAf?$AAr?$AA?9?$AAC?$AAH?$AA?$AA@
	DD	0101aH
	DD	FLAT:??_C@_1M@FLIDJFHL@?$AAh?$AAr?$AA?9?$AAB?$AAA?$AA?$AA@
	DD	0103bH
	DD	FLAT:??_C@_1O@FMCELNAJ@?$AAs?$AAm?$AAj?$AA?9?$AAN?$AAO?$AA?$AA@
	DD	01401H
	DD	FLAT:??_C@_1M@JHGLJMGJ@?$AAa?$AAr?$AA?9?$AAD?$AAZ?$AA?$AA@
	DD	01404H
	DD	FLAT:??_C@_1M@JKKFDCNP@?$AAz?$AAh?$AA?9?$AAM?$AAO?$AA?$AA@
	DD	01407H
	DD	FLAT:??_C@_1M@GEEFALPE@?$AAd?$AAe?$AA?9?$AAL?$AAI?$AA?$AA@
	DD	01409H
	DD	FLAT:??_C@_1M@IGEOFBG@?$AAe?$AAn?$AA?9?$AAN?$AAZ?$AA?$AA@
	DD	0140aH
	DD	FLAT:??_C@_1M@KDBONEHP@?$AAe?$AAs?$AA?9?$AAC?$AAR?$AA?$AA@
	DD	0140cH
	DD	FLAT:??_C@_1M@FHMDOHNN@?$AAf?$AAr?$AA?9?$AAL?$AAU?$AA?$AA@
	DD	0141aH
	DD	FLAT:??_C@_1BG@NFKKMAFG@?$AAb?$AAs?$AA?9?$AAB?$AAA?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@
	DD	0143bH
	DD	FLAT:??_C@_1O@IMNBEMCI@?$AAs?$AAm?$AAj?$AA?9?$AAS?$AAE?$AA?$AA@
	DD	01801H
	DD	FLAT:??_C@_1M@DHHMBNDP@?$AAa?$AAr?$AA?9?$AAM?$AAA?$AA?$AA@
	DD	01809H
	DD	FLAT:??_C@_1M@BNBLJCGH@?$AAe?$AAn?$AA?9?$AAI?$AAE?$AA?$AA@
	DD	0180aH
	DD	FLAT:??_C@_1M@GEPAFMDL@?$AAe?$AAs?$AA?9?$AAP?$AAA?$AA?$AA@
	DD	0180cH
	DD	FLAT:??_C@_1M@OJONDMDL@?$AAf?$AAr?$AA?9?$AAM?$AAC?$AA?$AA@
	DD	0181aH
	DD	FLAT:??_C@_1BG@OBCNFJB@?$AAs?$AAr?$AA?9?$AAB?$AAA?$AA?9?$AAL?$AAa?$AAt?$AAn?$AA?$AA@
	DD	0183bH
	DD	FLAT:??_C@_1O@KEMEEGPO@?$AAs?$AAm?$AAa?$AA?9?$AAN?$AAO?$AA?$AA@
	DD	01c01H
	DD	FLAT:??_C@_1M@ELMGFODK@?$AAa?$AAr?$AA?9?$AAT?$AAN?$AA?$AA@
	DD	01c09H
	DD	FLAT:??_C@_1M@BHDLHFAF@?$AAe?$AAn?$AA?9?$AAZ?$AAA?$AA?$AA@
	DD	01c0aH
	DD	FLAT:??_C@_1M@BMGIGLIF@?$AAe?$AAs?$AA?9?$AAD?$AAO?$AA?$AA@
	DD	01c1aH
	DD	FLAT:??_C@_1BG@CMBHIPBE@?$AAs?$AAr?$AA?9?$AAB?$AAA?$AA?9?$AAC?$AAy?$AAr?$AAl?$AA?$AA@
	DD	01c3bH
	DD	FLAT:??_C@_1O@HEDBLHNP@?$AAs?$AAm?$AAa?$AA?9?$AAS?$AAE?$AA?$AA@
	DD	02001H
	DD	FLAT:??_C@_1M@DAGCADIM@?$AAa?$AAr?$AA?9?$AAO?$AAM?$AA?$AA@
	DD	02009H
	DD	FLAT:??_C@_1M@FODLMICG@?$AAe?$AAn?$AA?9?$AAJ?$AAM?$AA?$AA@
	DD	0200aH
	DD	FLAT:??_C@_1M@DNMLCIHB@?$AAe?$AAs?$AA?9?$AAV?$AAE?$AA?$AA@
	DD	0203bH
	DD	FLAT:??_C@_1O@EOKHMKJK@?$AAs?$AAm?$AAs?$AA?9?$AAF?$AAI?$AA?$AA@
	DD	02401H
	DD	FLAT:??_C@_1M@CAFJMKOF@?$AAa?$AAr?$AA?9?$AAY?$AAE?$AA?$AA@
	DD	02409H
	DD	FLAT:??_C@_1M@CBFHIJLI@?$AAe?$AAn?$AA?9?$AAC?$AAB?$AA?$AA@
	DD	0240aH
	DD	FLAT:??_C@_1M@BGNFLDN@?$AAe?$AAs?$AA?9?$AAC?$AAO?$AA?$AA@
	DD	0243bH
	DD	FLAT:??_C@_1O@JMPHMAMC@?$AAs?$AAm?$AAn?$AA?9?$AAF?$AAI?$AA?$AA@
	DD	02801H
	DD	FLAT:??_C@_1M@JLANABKE@?$AAa?$AAr?$AA?9?$AAS?$AAY?$AA?$AA@
	DD	02809H
	DD	FLAT:??_C@_1M@HPKGCFGN@?$AAe?$AAn?$AA?9?$AAB?$AAZ?$AA?$AA@
	DD	0280aH
	DD	FLAT:??_C@_1M@OLJCMLGM@?$AAe?$AAs?$AA?9?$AAP?$AAE?$AA?$AA@
	DD	02c01H
	DD	FLAT:??_C@_1M@MKKGFKLE@?$AAa?$AAr?$AA?9?$AAJ?$AAO?$AA?$AA@
	DD	02c09H
	DD	FLAT:??_C@_1M@EKPGLDNI@?$AAe?$AAn?$AA?9?$AAT?$AAT?$AA?$AA@
	DD	02c0aH
	DD	FLAT:??_C@_1M@OONGHFHE@?$AAe?$AAs?$AA?9?$AAA?$AAR?$AA?$AA@
	DD	03001H
	DD	FLAT:??_C@_1M@OOJFGBHE@?$AAa?$AAr?$AA?9?$AAL?$AAB?$AA?$AA@
	DD	03009H
	DD	FLAT:??_C@_1M@GCEJHNEG@?$AAe?$AAn?$AA?9?$AAZ?$AAW?$AA?$AA@
	DD	0300aH
	DD	FLAT:??_C@_1M@JNOCAHJI@?$AAe?$AAs?$AA?9?$AAE?$AAC?$AA?$AA@
	DD	03401H
	DD	FLAT:??_C@_1M@JEFHPGGB@?$AAa?$AAr?$AA?9?$AAK?$AAW?$AA?$AA@
	DD	03409H
	DD	FLAT:??_C@_1M@MLKIBJOJ@?$AAe?$AAn?$AA?9?$AAP?$AAH?$AA?$AA@
	DD	0340aH
	DD	FLAT:??_C@_1M@BDNIPEND@?$AAe?$AAs?$AA?9?$AAC?$AAL?$AA?$AA@
	DD	03801H
	DD	FLAT:??_C@_1M@MPNMEKBD@?$AAa?$AAr?$AA?9?$AAA?$AAE?$AA?$AA@
	DD	0380aH
	DD	FLAT:??_C@_1M@KBJALCPI@?$AAe?$AAs?$AA?9?$AAU?$AAY?$AA?$AA@
	DD	03c01H
	DD	FLAT:??_C@_1M@LLCCOAGA@?$AAa?$AAr?$AA?9?$AAB?$AAH?$AA?$AA@
	DD	03c0aH
	DD	FLAT:??_C@_1M@PBFNCDEL@?$AAe?$AAs?$AA?9?$AAP?$AAY?$AA?$AA@
	DD	04001H
	DD	FLAT:??_C@_1M@EDGINPNP@?$AAa?$AAr?$AA?9?$AAQ?$AAA?$AA?$AA@
	DD	0400aH
	DD	FLAT:??_C@_1M@MKDBIIJI@?$AAe?$AAs?$AA?9?$AAB?$AAO?$AA?$AA@
	DD	0440aH
	DD	FLAT:??_C@_1M@CPKKEBLD@?$AAe?$AAs?$AA?9?$AAS?$AAV?$AA?$AA@
	DD	0480aH
	DD	FLAT:??_C@_1M@NDBGMMJL@?$AAe?$AAs?$AA?9?$AAH?$AAN?$AA?$AA@
	DD	04c0aH
	DD	FLAT:??_C@_1M@JIJIBHDP@?$AAe?$AAs?$AA?9?$AAN?$AAI?$AA?$AA@
	DD	0500aH
	DD	FLAT:??_C@_1M@CGFMKEEK@?$AAe?$AAs?$AA?9?$AAP?$AAR?$AA?$AA@
	DD	07c04H
	DD	FLAT:??_C@_1O@ICJHKIIK@?$AAz?$AAh?$AA?9?$AAC?$AAH?$AAT?$AA?$AA@
	DD	07c1aH
	DD	FLAT:??_C@_15CLNEJCE@?$AAs?$AAr?$AA?$AA@
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ??_C@_0BB@BEBMGMDO@atlTraceDBClient?$AA@
CONST	SEGMENT
??_C@_0BB@BEBMGMDO@atlTraceDBClient?$AA@ DB 'atlTraceDBClient', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DKOAAGGM@atlTraceHosting?$AA@
CONST	SEGMENT
??_C@_0BA@DKOAAGGM@atlTraceHosting?$AA@ DB 'atlTraceHosting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GHKJKKIE@atlTraceControls?$AA@
CONST	SEGMENT
??_C@_0BB@GHKJKKIE@atlTraceControls?$AA@ DB 'atlTraceControls', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DGHHNKDC@atlTraceWindowing?$AA@
CONST	SEGMENT
??_C@_0BC@DGHHNKDC@atlTraceWindowing?$AA@ DB 'atlTraceWindowing', 00H ; `string'
CONST	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT ??_C@_0BB@ILPPDKFL@atlTraceRefcount?$AA@
CONST	SEGMENT
??_C@_0BB@ILPPDKFL@atlTraceRefcount?$AA@ DB 'atlTraceRefcount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MALHFBAO@atlTraceRegistrar?$AA@
CONST	SEGMENT
??_C@_0BC@MALHFBAO@atlTraceRegistrar?$AA@ DB 'atlTraceRegistrar', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LHELAKBP@atlTraceQI?$AA@
CONST	SEGMENT
??_C@_0L@LHELAKBP@atlTraceQI?$AA@ DB 'atlTraceQI', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DGPFJEBB@atlTraceCOM?$AA@
CONST	SEGMENT
??_C@_0M@DGPFJEBB@atlTraceCOM?$AA@ DB 'atlTraceCOM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MKMIKKJB@atlTraceGeneral?$AA@
CONST	SEGMENT
??_C@_0BA@MKMIKKJB@atlTraceGeneral?$AA@ DB 'atlTraceGeneral', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JBKGCNBB@Delete?$AA@
CONST	SEGMENT
??_C@_06JBKGCNBB@Delete?$AA@ DB 'Delete', 00H		; `string'
CONST	ENDS
;	COMDAT ?szDelete@ATL@@3QBDB
CONST	SEGMENT
?szDelete@ATL@@3QBDB DD FLAT:??_C@_06JBKGCNBB@Delete?$AA@ ; ATL::szDelete
CONST	ENDS
;	COMDAT ??_C@_08KAAPDIAN@NoRemove?$AA@
CONST	SEGMENT
??_C@_08KAAPDIAN@NoRemove?$AA@ DB 'NoRemove', 00H	; `string'
CONST	ENDS
;	COMDAT ?szNoRemove@ATL@@3QBDB
CONST	SEGMENT
?szNoRemove@ATL@@3QBDB DD FLAT:??_C@_08KAAPDIAN@NoRemove?$AA@ ; ATL::szNoRemove
CONST	ENDS
;	COMDAT ??_C@_0M@DBGDLGLL@ForceRemove?$AA@
CONST	SEGMENT
??_C@_0M@DBGDLGLL@ForceRemove?$AA@ DB 'ForceRemove', 00H ; `string'
CONST	ENDS
;	COMDAT ?szForceRemove@ATL@@3QBDB
CONST	SEGMENT
?szForceRemove@ATL@@3QBDB DD FLAT:??_C@_0M@DBGDLGLL@ForceRemove?$AA@ ; ATL::szForceRemove
CONST	ENDS
;	COMDAT ??_C@_0O@KHOBHOBJ@atlTraceISAPI?$AA@
CONST	SEGMENT
??_C@_0O@KHOBHOBJ@atlTraceISAPI?$AA@ DB 'atlTraceISAPI', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LAIAPFCB@Val?$AA@
CONST	SEGMENT
??_C@_03LAIAPFCB@Val?$AA@ DB 'Val', 00H			; `string'
CONST	ENDS
;	COMDAT ?szValToken@ATL@@3QBDB
CONST	SEGMENT
?szValToken@ATL@@3QBDB DD FLAT:??_C@_03LAIAPFCB@Val?$AA@ ; ATL::szValToken
CONST	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B?$AA@
CONST	SEGMENT
??_C@_01HMGJMAIH@B?$AA@ DB 'B', 00H			; `string'
CONST	ENDS
;	COMDAT ?szBinaryVal@ATL@@3QBDB
CONST	SEGMENT
?szBinaryVal@ATL@@3QBDB DD FLAT:??_C@_01HMGJMAIH@B?$AA@	; ATL::szBinaryVal
CONST	ENDS
;	COMDAT ??_C@_01CKDDGHAB@D?$AA@
CONST	SEGMENT
??_C@_01CKDDGHAB@D?$AA@ DB 'D', 00H			; `string'
CONST	ENDS
;	COMDAT ?szDwordVal@ATL@@3QBDB
CONST	SEGMENT
?szDwordVal@ATL@@3QBDB DD FLAT:??_C@_01CKDDGHAB@D?$AA@	; ATL::szDwordVal
CONST	ENDS
;	COMDAT ??_C@_01PLPBNMEI@M?$AA@
CONST	SEGMENT
??_C@_01PLPBNMEI@M?$AA@ DB 'M', 00H			; `string'
CONST	ENDS
;	COMDAT ?multiszStringVal@ATL@@3QBDB
CONST	SEGMENT
?multiszStringVal@ATL@@3QBDB DD FLAT:??_C@_01PLPBNMEI@M?$AA@ ; ATL::multiszStringVal
CONST	ENDS
;	COMDAT ??_C@_01CPLAODJH@S?$AA@
CONST	SEGMENT
??_C@_01CPLAODJH@S?$AA@ DB 'S', 00H			; `string'
CONST	ENDS
;	COMDAT ?szStringVal@ATL@@3QBDB
CONST	SEGMENT
?szStringVal@ATL@@3QBDB DD FLAT:??_C@_01CPLAODJH@S?$AA@	; ATL::szStringVal
CONST	ENDS
;	COMDAT ?chEquals@ATL@@3DB
CONST	SEGMENT
?chEquals@ATL@@3DB DB 03dH				; ATL::chEquals
CONST	ENDS
;	COMDAT ?chQuote@ATL@@3DB
CONST	SEGMENT
?chQuote@ATL@@3DB DB 027H				; ATL::chQuote
CONST	ENDS
;	COMDAT ?chLeftBracket@ATL@@3DB
CONST	SEGMENT
?chLeftBracket@ATL@@3DB DB 07bH				; ATL::chLeftBracket
CONST	ENDS
;	COMDAT ?chRightBracket@ATL@@3DB
CONST	SEGMENT
?chRightBracket@ATL@@3DB DB 07dH			; ATL::chRightBracket
CONST	ENDS
;	COMDAT ?chDirSep@ATL@@3DB
CONST	SEGMENT
?chDirSep@ATL@@3DB DB 05cH				; ATL::chDirSep
CONST	ENDS
;	COMDAT ??_C@_0N@KLPNCFEE@atlTraceSync?$AA@
CONST	SEGMENT
??_C@_0N@KLPNCFEE@atlTraceSync?$AA@ DB 'atlTraceSync', 00H ; `string'
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT ??_C@_0BB@DNJDADMG@atlTraceSecurity?$AA@
CONST	SEGMENT
??_C@_0BB@DNJDADMG@atlTraceSecurity?$AA@ DB 'atlTraceSecurity', 00H ; `string'
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT ??_C@_0N@FEAAACHD@atlTraceUtil?$AA@
CONST	SEGMENT
??_C@_0N@FEAAACHD@atlTraceUtil?$AA@ DB 'atlTraceUtil', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IOBBMAHG@atlTraceMap?$AA@
CONST	SEGMENT
??_C@_0M@IOBBMAHG@atlTraceMap?$AA@ DB 'atlTraceMap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MBNHGHMI@atlTraceString?$AA@
CONST	SEGMENT
??_C@_0P@MBNHGHMI@atlTraceString?$AA@ DB 'atlTraceString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BBGHNHJP@?$AAz?$AAu?$AA?9?$AAz?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BBGHNHJP@?$AAz?$AAu?$AA?9?$AAz?$AAa?$AA?$AA@ DB 'z', 00H, 'u', 00H
	DB	'-', 00H, 'z', 00H, 'a', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IMEPLEPE@?$AAz?$AAh?$AA?9?$AAt?$AAw?$AA?$AA@
CONST	SEGMENT
??_C@_1M@IMEPLEPE@?$AAz?$AAh?$AA?9?$AAt?$AAw?$AA?$AA@ DB 'z', 00H, 'h', 00H
	DB	'-', 00H, 't', 00H, 'w', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MBFDNDND@?$AAz?$AAh?$AA?9?$AAs?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MBFDNDND@?$AAz?$AAh?$AA?9?$AAs?$AAg?$AA?$AA@ DB 'z', 00H, 'h', 00H
	DB	'-', 00H, 's', 00H, 'g', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DNDLJINH@?$AAz?$AAh?$AA?9?$AAm?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DNDLJINH@?$AAz?$AAh?$AA?9?$AAm?$AAo?$AA?$AA@ DB 'z', 00H, 'h', 00H
	DB	'-', 00H, 'm', 00H, 'o', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@OCJEJODD@?$AAz?$AAh?$AA?9?$AAh?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_1M@OCJEJODD@?$AAz?$AAh?$AA?9?$AAh?$AAk?$AA?$AA@ DB 'z', 00H, 'h', 00H
	DB	'-', 00H, 'h', 00H, 'k', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LPINJOMC@?$AAz?$AAh?$AA?9?$AAc?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LPINJOMC@?$AAz?$AAh?$AA?9?$AAc?$AAn?$AA?$AA@ DB 'z', 00H, 'h', 00H
	DB	'-', 00H, 'c', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@NMHPGANE@?$AAz?$AAh?$AA?9?$AAc?$AAh?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1O@NMHPGANE@?$AAz?$AAh?$AA?9?$AAc?$AAh?$AAt?$AA?$AA@ DB 'z', 00H, 'h'
	DB	00H, '-', 00H, 'c', 00H, 'h', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@EBKIFIGN@?$AAz?$AAh?$AA?9?$AAc?$AAh?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1O@EBKIFIGN@?$AAz?$AAh?$AA?9?$AAc?$AAh?$AAs?$AA?$AA@ DB 'z', 00H, 'h'
	DB	00H, '-', 00H, 'c', 00H, 'h', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CPAMEDFI@?$AAx?$AAh?$AA?9?$AAz?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CPAMEDFI@?$AAx?$AAh?$AA?9?$AAz?$AAa?$AA?$AA@ DB 'x', 00H, 'h', 00H
	DB	'-', 00H, 'z', 00H, 'a', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GFOCLFF@?$AAv?$AAi?$AA?9?$AAv?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GFOCLFF@?$AAv?$AAi?$AA?9?$AAv?$AAn?$AA?$AA@ DB 'v', 00H, 'i', 00H
	DB	'-', 00H, 'v', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@EGGKJILM@?$AAu?$AAz?$AA?9?$AAu?$AAz?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@EGGKJILM@?$AAu?$AAz?$AA?9?$AAu?$AAz?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@ DB 'u'
	DB	00H, 'z', 00H, '-', 00H, 'u', 00H, 'z', 00H, '-', 00H, 'l', 00H
	DB	'a', 00H, 't', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@GEGPMCDJ@?$AAu?$AAz?$AA?9?$AAu?$AAz?$AA?9?$AAc?$AAy?$AAr?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@GEGPMCDJ@?$AAu?$AAz?$AA?9?$AAu?$AAz?$AA?9?$AAc?$AAy?$AAr?$AAl?$AA?$AA@ DB 'u'
	DB	00H, 'z', 00H, '-', 00H, 'u', 00H, 'z', 00H, '-', 00H, 'c', 00H
	DB	'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@EPAJJAJF@?$AAu?$AAr?$AA?9?$AAp?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EPAJJAJF@?$AAu?$AAr?$AA?9?$AAp?$AAk?$AA?$AA@ DB 'u', 00H, 'r', 00H
	DB	'-', 00H, 'p', 00H, 'k', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT ??_C@_1M@KLMCELGA@?$AAu?$AAk?$AA?9?$AAu?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KLMCELGA@?$AAu?$AAk?$AA?9?$AAu?$AAa?$AA?$AA@ DB 'u', 00H, 'k', 00H
	DB	'-', 00H, 'u', 00H, 'a', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CELMCNBK@?$AAt?$AAt?$AA?9?$AAr?$AAu?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CELMCNBK@?$AAt?$AAt?$AA?9?$AAr?$AAu?$AA?$AA@ DB 't', 00H, 't', 00H
	DB	'-', 00H, 'r', 00H, 'u', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GCCMIGPJ@?$AAt?$AAr?$AA?9?$AAt?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GCCMIGPJ@?$AAt?$AAr?$AA?9?$AAt?$AAr?$AA?$AA@ DB 't', 00H, 'r', 00H
	DB	'-', 00H, 't', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CHBIHOJO@?$AAt?$AAn?$AA?9?$AAz?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CHBIHOJO@?$AAt?$AAn?$AA?9?$AAz?$AAa?$AA?$AA@ DB 't', 00H, 'n', 00H
	DB	'-', 00H, 'z', 00H, 'a', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GNAECACD@?$AAt?$AAh?$AA?9?$AAt?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GNAECACD@?$AAt?$AAh?$AA?9?$AAt?$AAh?$AA?$AA@ DB 't', 00H, 'h', 00H
	DB	'-', 00H, 't', 00H, 'h', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CNJOFAK@?$AAt?$AAe?$AA?9?$AAi?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CNJOFAK@?$AAt?$AAe?$AA?9?$AAi?$AAn?$AA?$AA@ DB 't', 00H, 'e', 00H
	DB	'-', 00H, 'i', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LDCEFHA@?$AAt?$AAa?$AA?9?$AAi?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LDCEFHA@?$AAt?$AAa?$AA?9?$AAi?$AAn?$AA?$AA@ DB 't', 00H, 'a', 00H
	DB	'-', 00H, 'i', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@KOHBJJI@?$AAs?$AAy?$AAr?$AA?9?$AAs?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1O@KOHBJJI@?$AAs?$AAy?$AAr?$AA?9?$AAs?$AAy?$AA?$AA@ DB 's', 00H, 'y'
	DB	00H, 'r', 00H, '-', 00H, 's', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MPNDHLFK@?$AAs?$AAw?$AA?9?$AAk?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MPNDHLFK@?$AAs?$AAw?$AA?9?$AAk?$AAe?$AA?$AA@ DB 's', 00H, 'w', 00H
	DB	'-', 00H, 'k', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@MPJEJAJC@?$AAs?$AAv?$AA?9?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MPJEJAJC@?$AAs?$AAv?$AA?9?$AAs?$AAe?$AA?$AA@ DB 's', 00H, 'v', 00H
	DB	'-', 00H, 's', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@NGFJLMAC@?$AAs?$AAv?$AA?9?$AAf?$AAi?$AA?$AA@
CONST	SEGMENT
??_C@_1M@NGFJLMAC@?$AAs?$AAv?$AA?9?$AAf?$AAi?$AA?$AA@ DB 's', 00H, 'v', 00H
	DB	'-', 00H, 'f', 00H, 'i', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@CIOGKHPB@?$AAs?$AAr?$AA?9?$AAs?$AAp?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@CIOGKHPB@?$AAs?$AAr?$AA?9?$AAs?$AAp?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@ DB 's'
	DB	00H, 'r', 00H, '-', 00H, 's', 00H, 'p', 00H, '-', 00H, 'l', 00H
	DB	'a', 00H, 't', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@KODPNHE@?$AAs?$AAr?$AA?9?$AAs?$AAp?$AA?9?$AAc?$AAy?$AAr?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@KODPNHE@?$AAs?$AAr?$AA?9?$AAs?$AAp?$AA?9?$AAc?$AAy?$AAr?$AAl?$AA?$AA@ DB 's'
	DB	00H, 'r', 00H, '-', 00H, 's', 00H, 'p', 00H, '-', 00H, 'c', 00H
	DB	'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@JLBENFOE@?$AAs?$AAr?$AA?9?$AAb?$AAa?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@JLBENFOE@?$AAs?$AAr?$AA?9?$AAb?$AAa?$AA?9?$AAl?$AAa?$AAt?$AAn?$AA?$AA@ DB 's'
	DB	00H, 'r', 00H, '-', 00H, 'b', 00H, 'a', 00H, '-', 00H, 'l', 00H
	DB	'a', 00H, 't', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@LJBBIPGB@?$AAs?$AAr?$AA?9?$AAb?$AAa?$AA?9?$AAc?$AAy?$AAr?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@LJBBIPGB@?$AAs?$AAr?$AA?9?$AAb?$AAa?$AA?9?$AAc?$AAy?$AAr?$AAl?$AA?$AA@ DB 's'
	DB	00H, 'r', 00H, '-', 00H, 'b', 00H, 'a', 00H, '-', 00H, 'c', 00H
	DB	'y', 00H, 'r', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BOFOGHPB@?$AAs?$AAq?$AA?9?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BOFOGHPB@?$AAs?$AAq?$AA?9?$AAa?$AAl?$AA?$AA@ DB 's', 00H, 'q', 00H
	DB	'-', 00H, 'a', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@OJDJGAJC@?$AAs?$AAm?$AAs?$AA?9?$AAf?$AAi?$AA?$AA@
CONST	SEGMENT
??_C@_1O@OJDJGAJC@?$AAs?$AAm?$AAs?$AA?9?$AAf?$AAi?$AA?$AA@ DB 's', 00H, 'm'
	DB	00H, 's', 00H, '-', 00H, 'f', 00H, 'i', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@DLGJGKMK@?$AAs?$AAm?$AAn?$AA?9?$AAf?$AAi?$AA?$AA@
CONST	SEGMENT
??_C@_1O@DLGJGKMK@?$AAs?$AAm?$AAn?$AA?9?$AAf?$AAi?$AA?$AA@ DB 's', 00H, 'm'
	DB	00H, 'n', 00H, '-', 00H, 'f', 00H, 'i', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@CLEPOGCA@?$AAs?$AAm?$AAj?$AA?9?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1O@CLEPOGCA@?$AAs?$AAm?$AAj?$AA?9?$AAs?$AAe?$AA?$AA@ DB 's', 00H, 'm'
	DB	00H, 'j', 00H, '-', 00H, 's', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@PLLKBHAB@?$AAs?$AAm?$AAj?$AA?9?$AAn?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1O@PLLKBHAB@?$AAs?$AAm?$AAj?$AA?9?$AAn?$AAo?$AA?$AA@ DB 's', 00H, 'm'
	DB	00H, 'j', 00H, '-', 00H, 'n', 00H, 'o', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@NDKPBNNH@?$AAs?$AAm?$AAa?$AA?9?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1O@NDKPBNNH@?$AAs?$AAm?$AAa?$AA?9?$AAs?$AAe?$AA?$AA@ DB 's', 00H, 'm'
	DB	00H, 'a', 00H, '-', 00H, 's', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@DFKOMPG@?$AAs?$AAm?$AAa?$AA?9?$AAn?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1O@DFKOMPG@?$AAs?$AAm?$AAa?$AA?9?$AAn?$AAo?$AA?$AA@ DB 's', 00H, 'm'
	DB	00H, 'a', 00H, '-', 00H, 'n', 00H, 'o', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LFMODOAL@?$AAs?$AAl?$AA?9?$AAs?$AAi?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LFMODOAL@?$AAs?$AAl?$AA?9?$AAs?$AAi?$AA?$AA@ DB 's', 00H, 'l', 00H
	DB	'-', 00H, 's', 00H, 'i', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PNBLONPJ@?$AAs?$AAk?$AA?9?$AAs?$AAk?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PNBLONPJ@?$AAs?$AAk?$AA?9?$AAs?$AAk?$AA?$AA@ DB 's', 00H, 'k', 00H
	DB	'-', 00H, 's', 00H, 'k', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@DANKKHJ@?$AAs?$AAe?$AA?9?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@DANKKHJ@?$AAs?$AAe?$AA?9?$AAs?$AAe?$AA?$AA@ DB 's', 00H, 'e', 00H
	DB	'-', 00H, 's', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@NDPIFLFI@?$AAs?$AAe?$AA?9?$AAn?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1M@NDPIFLFI@?$AAs?$AAe?$AA?9?$AAn?$AAo?$AA?$AA@ DB 's', 00H, 'e', 00H
	DB	'-', 00H, 'n', 00H, 'o', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BKMAIGOJ@?$AAs?$AAe?$AA?9?$AAf?$AAi?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BKMAIGOJ@?$AAs?$AAe?$AA?9?$AAf?$AAi?$AA?$AA@ DB 's', 00H, 'e', 00H
	DB	'-', 00H, 'f', 00H, 'i', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HPKKKMPP@?$AAs?$AAa?$AA?9?$AAi?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HPKKKMPP@?$AAs?$AAa?$AA?9?$AAi?$AAn?$AA?$AA@ DB 's', 00H, 'a', 00H
	DB	'-', 00H, 'i', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CEEDODME@?$AAr?$AAu?$AA?9?$AAr?$AAu?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CEEDODME@?$AAr?$AAu?$AA?9?$AAr?$AAu?$AA?$AA@ DB 'r', 00H, 'u', 00H
	DB	'-', 00H, 'r', 00H, 'u', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CLGLEFBO@?$AAr?$AAo?$AA?9?$AAr?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CLGLEFBO@?$AAr?$AAo?$AA?9?$AAr?$AAo?$AA?$AA@ DB 'r', 00H, 'o', 00H
	DB	'-', 00H, 'r', 00H, 'o', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@GBAPEKMJ@?$AAq?$AAu?$AAz?$AA?9?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1O@GBAPEKMJ@?$AAq?$AAu?$AAz?$AA?9?$AAp?$AAe?$AA?$AA@ DB 'q', 00H, 'u'
	DB	00H, 'z', 00H, '-', 00H, 'p', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@BHHPIGDN@?$AAq?$AAu?$AAz?$AA?9?$AAe?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1O@BHHPIGDN@?$AAq?$AAu?$AAz?$AA?9?$AAe?$AAc?$AA?$AA@ DB 'q', 00H, 'u'
	DB	00H, 'z', 00H, '-', 00H, 'e', 00H, 'c', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IDBKCKK@atlTraceStencil?$AA@
CONST	SEGMENT
??_C@_0BA@IDBKCKK@atlTraceStencil?$AA@ DB 'atlTraceStencil', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@EAKMAJDN@?$AAq?$AAu?$AAz?$AA?9?$AAb?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1O@EAKMAJDN@?$AAq?$AAu?$AAz?$AA?9?$AAb?$AAo?$AA?$AA@ DB 'q', 00H, 'u'
	DB	00H, 'z', 00H, '-', 00H, 'b', 00H, 'o', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@NCMONAAL@?$AAp?$AAt?$AA?9?$AAp?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1M@NCMONAAL@?$AAp?$AAt?$AA?9?$AAp?$AAt?$AA?$AA@ DB 'p', 00H, 't', 00H
	DB	'-', 00H, 'p', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LJLLCMEH@?$AAp?$AAt?$AA?9?$AAb?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LJLLCMEH@?$AAp?$AAt?$AA?9?$AAb?$AAr?$AA?$AA@ DB 'p', 00H, 't', 00H
	DB	'-', 00H, 'b', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__snwprintf
PUBLIC	??$__vcrt_va_start_verify_argument_type@PB_W@@YAXXZ ; __vcrt_va_start_verify_argument_type<wchar_t const *>
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf_s
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
PUBLIC	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	??1?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	??1_Facet_base@std@@UAE@XZ			; std::_Facet_base::~_Facet_base
PUBLIC	??_G_Facet_base@std@@UAEPAXI@Z			; std::_Facet_base::`scalar deleting destructor'
PUBLIC	?_Incref@facet@locale@std@@UAEXXZ		; std::locale::facet::_Incref
PUBLIC	?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	??1facet@locale@std@@MAE@XZ			; std::locale::facet::~facet
PUBLIC	??_Gfacet@locale@std@@MAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??0?$ctype@_W@std@@QAE@ABV_Locinfo@1@I@Z	; std::ctype<wchar_t>::ctype<wchar_t>
PUBLIC	?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<wchar_t>::_Getcat
PUBLIC	??1?$ctype@_W@std@@MAE@XZ			; std::ctype<wchar_t>::~ctype<wchar_t>
PUBLIC	?do_is@?$ctype@_W@std@@MBE_NF_W@Z		; std::ctype<wchar_t>::do_is
PUBLIC	?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z	; std::ctype<wchar_t>::do_is
PUBLIC	?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z	; std::ctype<wchar_t>::do_scan_is
PUBLIC	?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z	; std::ctype<wchar_t>::do_scan_not
PUBLIC	?do_tolower@?$ctype@_W@std@@MBE_W_W@Z		; std::ctype<wchar_t>::do_tolower
PUBLIC	?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z	; std::ctype<wchar_t>::do_tolower
PUBLIC	?do_toupper@?$ctype@_W@std@@MBE_W_W@Z		; std::ctype<wchar_t>::do_toupper
PUBLIC	?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z	; std::ctype<wchar_t>::do_toupper
PUBLIC	?do_widen@?$ctype@_W@std@@MBE_WD@Z		; std::ctype<wchar_t>::do_widen
PUBLIC	?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z	; std::ctype<wchar_t>::do_widen
PUBLIC	?do_narrow@?$ctype@_W@std@@MBED_WD@Z		; std::ctype<wchar_t>::do_narrow
PUBLIC	?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z	; std::ctype<wchar_t>::do_narrow
PUBLIC	??_G?$ctype@_W@std@@MAEPAXI@Z			; std::ctype<wchar_t>::`scalar deleting destructor'
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
PUBLIC	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	??0_System_error@std@@QAE@ABV01@@Z		; std::_System_error::_System_error
PUBLIC	??_G_System_error@std@@UAEPAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QAE@Verror_code@1@PBD@Z	; std::system_error::system_error
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	??_Gsystem_error@std@@UAEPAXI@Z			; std::system_error::`scalar deleting destructor'
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	?clear@ios_base@std@@QAEXH@Z			; std::ios_base::clear
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	??1ios_base@std@@UAE@XZ				; std::ios_base::~ios_base
PUBLIC	?_Init@ios_base@std@@IAEXXZ			; std::ios_base::_Init
PUBLIC	??_Gios_base@std@@UAEPAXI@Z			; std::ios_base::`scalar deleting destructor'
PUBLIC	?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?allocate@?$allocator@_W@std@@QAEPA_WI@Z	; std::allocator<wchar_t>::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
PUBLIC	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
PUBLIC	?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
PUBLIC	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
PUBLIC	??1Container@ForEach@GostCrypt@@UAE@XZ		; GostCrypt::ForEach::Container::~Container
PUBLIC	??_GContainer@ForEach@GostCrypt@@UAEPAXI@Z	; GostCrypt::ForEach::Container::`scalar deleting destructor'
PUBLIC	?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z		; ATL::Checked::memcpy_s
PUBLIC	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
PUBLIC	?AtlCrtErrorCheck@ATL@@YAHH@Z			; ATL::AtlCrtErrorCheck
PUBLIC	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
PUBLIC	??1CComBSTR@ATL@@QAE@XZ				; ATL::CComBSTR::~CComBSTR
PUBLIC	?AppendBytes@CComBSTR@ATL@@QAEJPBDH@Z		; ATL::CComBSTR::AppendBytes
PUBLIC	??0CComBSTR@ATL@@QAE@PBD@Z			; ATL::CComBSTR::CComBSTR
PUBLIC	??1_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
PUBLIC	?Term@CAtlComModule@ATL@@QAEXXZ			; ATL::CAtlComModule::Term
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
PUBLIC	??0Exception@GostCrypt@@QAE@ABU01@@Z		; GostCrypt::Exception::Exception
PUBLIC	?Show@SystemException@GostCrypt@@UBEXPAUHWND__@@@Z ; GostCrypt::SystemException::Show
PUBLIC	??0SystemException@GostCrypt@@QAE@ABU01@@Z	; GostCrypt::SystemException::SystemException
PUBLIC	?Show@ErrorException@GostCrypt@@UBEXPAUHWND__@@@Z ; GostCrypt::ErrorException::Show
PUBLIC	??1ErrorException@GostCrypt@@QAE@XZ		; GostCrypt::ErrorException::~ErrorException
PUBLIC	??0ErrorException@GostCrypt@@QAE@ABU01@@Z	; GostCrypt::ErrorException::ErrorException
PUBLIC	?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z ; GostCrypt::ParameterIncorrect::Show
PUBLIC	??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z	; GostCrypt::ParameterIncorrect::ParameterIncorrect
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?Show@TimeOut@GostCrypt@@UBEXPAUHWND__@@@Z	; GostCrypt::TimeOut::Show
PUBLIC	??0TimeOut@GostCrypt@@QAE@ABU01@@Z		; GostCrypt::TimeOut::TimeOut
PUBLIC	?Show@UserAbort@GostCrypt@@UBEXPAUHWND__@@@Z	; GostCrypt::UserAbort::Show
PUBLIC	??0UserAbort@GostCrypt@@QAE@ABU01@@Z		; GostCrypt::UserAbort::UserAbort
PUBLIC	??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z ; GostCrypt::File::File
PUBLIC	??1File@GostCrypt@@QAE@XZ			; GostCrypt::File::~File
PUBLIC	?Close@File@GostCrypt@@QAEXXZ			; GostCrypt::File::Close
PUBLIC	?Read@File@GostCrypt@@QAEKPAEK@Z		; GostCrypt::File::Read
PUBLIC	?Write@File@GostCrypt@@QAEXPAEK@Z		; GostCrypt::File::Write
PUBLIC	?SeekAt@File@GostCrypt@@QAEX_J@Z		; GostCrypt::File::SeekAt
PUBLIC	??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device
PUBLIC	??1Device@GostCrypt@@QAE@XZ			; GostCrypt::Device::~Device
PUBLIC	??1Buffer@GostCrypt@@QAE@XZ			; GostCrypt::Buffer::~Buffer
PUBLIC	??1Partition@GostCrypt@@QAE@XZ			; GostCrypt::Partition::~Partition
PUBLIC	??0Partition@GostCrypt@@QAE@ABU01@@Z		; GostCrypt::Partition::Partition
PUBLIC	??4Partition@GostCrypt@@QAEAAU01@ABU01@@Z	; GostCrypt::Partition::operator=
PUBLIC	?deallocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::deallocate
PUBLIC	?_Buynode0@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Buynode0
PUBLIC	??1?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::~_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
PUBLIC	??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
PUBLIC	??1?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::~list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
PUBLIC	?_Unchecked_erase@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Unchecked_erase
PUBLIC	?erase@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@0@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::erase
PUBLIC	?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear
PUBLIC	??0SystemDriveConfiguration@GostCrypt@@QAE@XZ	; GostCrypt::SystemDriveConfiguration::SystemDriveConfiguration
PUBLIC	??1SystemDriveConfiguration@GostCrypt@@QAE@XZ	; GostCrypt::SystemDriveConfiguration::~SystemDriveConfiguration
PUBLIC	??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z ; GostCrypt::SystemDriveConfiguration::SystemDriveConfiguration
PUBLIC	??4SystemDriveConfiguration@GostCrypt@@QAEAAU01@ABU01@@Z ; GostCrypt::SystemDriveConfiguration::operator=
PUBLIC	??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z	; GostCrypt::BootEncryption::BootEncryption
PUBLIC	??1BootEncryption@GostCrypt@@QAE@XZ		; GostCrypt::BootEncryption::~BootEncryption
PUBLIC	?AbortDecoyOSWipe@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::AbortDecoyOSWipe
PUBLIC	?AbortSetup@BootEncryption@GostCrypt@@QAEXXZ	; GostCrypt::BootEncryption::AbortSetup
PUBLIC	?AbortSetupWait@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::AbortSetupWait
PUBLIC	?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver
PUBLIC	?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z ; GostCrypt::BootEncryption::ChangePassword
PUBLIC	?CheckDecoyOSWipeResult@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::CheckDecoyOSWipeResult
PUBLIC	?CheckEncryptionSetupResult@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::CheckEncryptionSetupResult
PUBLIC	?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::CheckRequirements
PUBLIC	?CheckRequirementsHiddenOS@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::CheckRequirementsHiddenOS
PUBLIC	?CopyFileAdmin@BootEncryption@GostCrypt@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; GostCrypt::BootEncryption::CopyFileAdmin
PUBLIC	?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GostCrypt::BootEncryption::CreateRescueIsoImage
PUBLIC	?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z	; GostCrypt::BootEncryption::Deinstall
PUBLIC	?DeleteFileAdmin@BootEncryption@GostCrypt@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GostCrypt::BootEncryption::DeleteFileAdmin
PUBLIC	?GetDecoyOSWipeStatus@BootEncryption@GostCrypt@@QAE?AUDecoySystemWipeStatus@@XZ ; GostCrypt::BootEncryption::GetDecoyOSWipeStatus
PUBLIC	?GetDriverServiceStartType@BootEncryption@GostCrypt@@QAEKXZ ; GostCrypt::BootEncryption::GetDriverServiceStartType
PUBLIC	?GetHiddenOSCreationPhase@BootEncryption@GostCrypt@@QAEIXZ ; GostCrypt::BootEncryption::GetHiddenOSCreationPhase
PUBLIC	?GetInstalledBootLoaderVersion@BootEncryption@GostCrypt@@QAEGXZ ; GostCrypt::BootEncryption::GetInstalledBootLoaderVersion
PUBLIC	?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ ; GostCrypt::BootEncryption::GetPartitionForHiddenOS
PUBLIC	?IsBootLoaderOnDrive@BootEncryption@GostCrypt@@QAE_NPAD@Z ; GostCrypt::BootEncryption::IsBootLoaderOnDrive
PUBLIC	?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ; GostCrypt::BootEncryption::GetStatus
PUBLIC	?GetTempPathA@BootEncryption@GostCrypt@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GostCrypt::BootEncryption::GetTempPathA
PUBLIC	?GetVolumeProperties@BootEncryption@GostCrypt@@QAEXPAUVOLUME_PROPERTIES_STRUCT@@@Z ; GostCrypt::BootEncryption::GetVolumeProperties
PUBLIC	?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
PUBLIC	?Install@BootEncryption@GostCrypt@@QAEX_N@Z	; GostCrypt::BootEncryption::Install
PUBLIC	?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z ; GostCrypt::BootEncryption::InstallBootLoader
PUBLIC	?InvalidateCachedSysDriveProperties@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::InvalidateCachedSysDriveProperties
PUBLIC	?IsCDDrivePresent@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::IsCDDrivePresent
PUBLIC	?IsHiddenSystemRunning@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::IsHiddenSystemRunning
PUBLIC	?IsPagingFileActive@BootEncryption@GostCrypt@@QAE_NH@Z ; GostCrypt::BootEncryption::IsPagingFileActive
PUBLIC	?PrepareHiddenOSCreation@BootEncryption@GostCrypt@@QAEXHHH@Z ; GostCrypt::BootEncryption::PrepareHiddenOSCreation
PUBLIC	?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GostCrypt::BootEncryption::PrepareInstallation
PUBLIC	?ProbeRealSystemDriveSize@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::ProbeRealSystemDriveSize
PUBLIC	?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z ; GostCrypt::BootEncryption::ReadBootSectorConfig
PUBLIC	?ReadDriverConfigurationFlags@BootEncryption@GostCrypt@@QAEIXZ ; GostCrypt::BootEncryption::ReadDriverConfigurationFlags
PUBLIC	?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z ; GostCrypt::BootEncryption::RegisterBootDriver
PUBLIC	?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z ; GostCrypt::BootEncryption::RegisterFilterDriver
PUBLIC	?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z ; GostCrypt::BootEncryption::RegisterSystemFavoritesService
PUBLIC	?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::RenameDeprecatedSystemLoaderBackup
PUBLIC	?RestartComputer@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::RestartComputer
PUBLIC	?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::InitialSecurityChecksForHiddenOS
PUBLIC	?RestrictPagingFilesToSystemPartition@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::RestrictPagingFilesToSystemPartition
PUBLIC	?SetDriverConfigurationFlag@BootEncryption@GostCrypt@@QAEXI_N@Z ; GostCrypt::BootEncryption::SetDriverConfigurationFlag
PUBLIC	?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z ; GostCrypt::BootEncryption::SetDriverServiceStartType
PUBLIC	?SetHiddenOSCreationPhase@BootEncryption@GostCrypt@@QAEXI@Z ; GostCrypt::BootEncryption::SetHiddenOSCreationPhase
PUBLIC	?StartDecryption@BootEncryption@GostCrypt@@QAEXH@Z ; GostCrypt::BootEncryption::StartDecryption
PUBLIC	?StartDecoyOSWipe@BootEncryption@GostCrypt@@QAEXW4WipeAlgorithmId@@@Z ; GostCrypt::BootEncryption::StartDecoyOSWipe
PUBLIC	?StartEncryption@BootEncryption@GostCrypt@@QAEXW4WipeAlgorithmId@@_N@Z ; GostCrypt::BootEncryption::StartEncryption
PUBLIC	?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z ; GostCrypt::BootEncryption::SystemDriveContainsPartitionType
PUBLIC	?SystemDriveContainsExtendedPartition@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::SystemDriveContainsExtendedPartition
PUBLIC	?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::SystemDriveContainsNonStandardPartitions
PUBLIC	?SystemPartitionCoversWholeDrive@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::SystemPartitionCoversWholeDrive
PUBLIC	?SystemDriveIsDynamic@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::SystemDriveIsDynamic
PUBLIC	?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::VerifyRescueDisk
PUBLIC	?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::WipeHiddenOSCreationConfig
PUBLIC	?WriteBootDriveSector@BootEncryption@GostCrypt@@QAEX_KPAE@Z ; GostCrypt::BootEncryption::WriteBootDriveSector
PUBLIC	?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z ; GostCrypt::BootEncryption::WriteBootSectorConfig
PUBLIC	?WriteBootSectorUserConfig@BootEncryption@GostCrypt@@QAEXEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GostCrypt::BootEncryption::WriteBootSectorUserConfig
PUBLIC	?WriteLocalMachineRegistryDwordValue@BootEncryption@GostCrypt@@QAEXPAD0K@Z ; GostCrypt::BootEncryption::WriteLocalMachineRegistryDwordValue
PUBLIC	?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ ; GostCrypt::BootEncryption::BackupSystemLoader
PUBLIC	?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z ; GostCrypt::BootEncryption::CreateBootLoaderInMemory
PUBLIC	?CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z ; GostCrypt::BootEncryption::CreateVolumeHeader
PUBLIC	?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GostCrypt::BootEncryption::GetSystemLoaderBackupPath
PUBLIC	?GetChecksum@BootEncryption@GostCrypt@@IAEIPAEI@Z ; GostCrypt::BootEncryption::GetChecksum
PUBLIC	?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z ; GostCrypt::BootEncryption::GetDriveGeometry
PUBLIC	?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z ; GostCrypt::BootEncryption::GetDrivePartitions
PUBLIC	?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; GostCrypt::BootEncryption::GetRemarksOnHiddenOS
PUBLIC	?GetWindowsDirectoryA@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GostCrypt::BootEncryption::GetWindowsDirectoryA
PUBLIC	?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
PUBLIC	?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ ; GostCrypt::BootEncryption::RestoreSystemLoader
PUBLIC	?InstallVolumeHeader@BootEncryption@GostCrypt@@IAEXXZ ; GostCrypt::BootEncryption::InstallVolumeHeader
PUBLIC	?CallDriver@Elevator@GostCrypt@@SAXKPAXK0K@Z	; GostCrypt::Elevator::CallDriver
PUBLIC	?CopyFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; GostCrypt::Elevator::CopyFileA
PUBLIC	?DeleteFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GostCrypt::Elevator::DeleteFileA
PUBLIC	?ReadWriteFile@Elevator@GostCrypt@@SAXHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE_KIPAK@Z ; GostCrypt::Elevator::ReadWriteFile
PUBLIC	?WriteLocalMachineRegistryDwordValue@Elevator@GostCrypt@@SAXPAD0K@Z ; GostCrypt::Elevator::WriteLocalMachineRegistryDwordValue
PUBLIC	?RegisterFilterDriver@Elevator@GostCrypt@@SAX_NW4FilterType@BootEncryption@2@@Z ; GostCrypt::Elevator::RegisterFilterDriver
PUBLIC	?RegisterSystemFavoritesService@Elevator@GostCrypt@@SAXH@Z ; GostCrypt::Elevator::RegisterSystemFavoritesService
PUBLIC	?SetDriverServiceStartType@Elevator@GostCrypt@@SAXK@Z ; GostCrypt::Elevator::SetDriverServiceStartType
PUBLIC	?Elevate@Elevator@GostCrypt@@KAXXZ		; GostCrypt::Elevator::Elevate
PUBLIC	?Show@GostCrypt@@YAXPAUHWND__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GostCrypt::Show
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
PUBLIC	?IsNotEnd@?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::IsNotEnd
PUBLIC	?Next@?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::Next
PUBLIC	??1?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::~ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
PUBLIC	??_G?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::`scalar deleting destructor'
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
PUBLIC	?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
PUBLIC	??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
PUBLIC	??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
PUBLIC	??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >
PUBLIC	??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
PUBLIC	??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_iostream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_iostream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
PUBLIC	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
PUBLIC	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
PUBLIC	?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
PUBLIC	?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::uflow
PUBLIC	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
PUBLIC	?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_streambuf<char,std::char_traits<char> >::imbue
PUBLIC	??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
PUBLIC	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init
PUBLIC	??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??1?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::~basic_ostream<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
PUBLIC	?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
PUBLIC	??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::basic_iostream<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::~basic_iostream<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??_G?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
PUBLIC	??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
PUBLIC	??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Lock
PUBLIC	?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Unlock
PUBLIC	?_Gnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gnavail
PUBLIC	?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pnavail
PUBLIC	?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::overflow
PUBLIC	?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbackfail
PUBLIC	?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::showmanyc
PUBLIC	?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::underflow
PUBLIC	?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::uflow
PUBLIC	?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsgetn
PUBLIC	?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsputn
PUBLIC	?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekoff
PUBLIC	?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekpos
PUBLIC	?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setbuf
PUBLIC	?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sync
PUBLIC	?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::imbue
PUBLIC	??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?str@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
PUBLIC	?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekpos
PUBLIC	?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
PUBLIC	??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor'
PUBLIC	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::assign<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > > >
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
PUBLIC	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
PUBLIC	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
PUBLIC	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
PUBLIC	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
PUBLIC	??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
PUBLIC	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
PUBLIC	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
PUBLIC	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
PUBLIC	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
PUBLIC	??1?$numpunct@D@std@@MAE@XZ			; std::numpunct<char>::~numpunct<char>
PUBLIC	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z	; std::numpunct<char>::_Init
PUBLIC	?do_decimal_point@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_grouping
PUBLIC	?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_falsename
PUBLIC	?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_truename
PUBLIC	?_Tidy@?$numpunct@D@std@@AAEXXZ			; std::numpunct<char>::_Tidy
PUBLIC	??_G?$numpunct@D@std@@MAEPAXI@Z			; std::numpunct<char>::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??__F_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ@YAXXZ ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::`dynamic atexit destructor for '_Static''
PUBLIC	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Buynode<GostCrypt::Partition const &>
PUBLIC	??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Reusenode<GostCrypt::Partition const &>
PUBLIC	??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > > >
PUBLIC	??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_iostream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
PUBLIC	??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
PUBLIC	??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception?$AA@	; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	__CTA2?AVruntime_error@std@@
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@	; `string'
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7?$ctype@_W@std@@6B@				; std::ctype<wchar_t>::`vftable'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_7ios_base@std@@6B@				; std::ios_base::`vftable'
PUBLIC	__TI5?AVfailure@ios_base@std@@
PUBLIC	__CTA5?AVfailure@ios_base@std@@
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ ; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@	; `string'
PUBLIC	??_7Container@ForEach@GostCrypt@@6B@		; GostCrypt::ForEach::Container::`vftable'
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
PUBLIC	?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
PUBLIC	?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
PUBLIC	?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
PUBLIC	?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
PUBLIC	?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
PUBLIC	?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
PUBLIC	?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
PUBLIC	?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
PUBLIC	?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
PUBLIC	?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
PUBLIC	?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
PUBLIC	?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
PUBLIC	?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
PUBLIC	?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
PUBLIC	?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
PUBLIC	?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
PUBLIC	?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
PUBLIC	__TI1?AVCAtlException@ATL@@
PUBLIC	__CTA1?AVCAtlException@ATL@@
PUBLIC	??_R0?AVCAtlException@ATL@@@8			; ATL::CAtlException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVCAtlException@ATL@@@84
PUBLIC	?_AtlComModule@ATL@@3VCAtlComModule@1@A		; ATL::_AtlComModule
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	??_7Exception@GostCrypt@@6B@			; GostCrypt::Exception::`vftable'
PUBLIC	??_7SystemException@GostCrypt@@6B@		; GostCrypt::SystemException::`vftable'
PUBLIC	??_7ErrorException@GostCrypt@@6B@		; GostCrypt::ErrorException::`vftable'
PUBLIC	??_7ParameterIncorrect@GostCrypt@@6B@		; GostCrypt::ParameterIncorrect::`vftable'
PUBLIC	??_C@_01PKGAHCOL@?$CJ?$AA@			; `string'
PUBLIC	??_C@_0IM@CKBKFPJM@Parameter?5incorrect?4?6?6?6?$CIIf?5you?5r@ ; `string'
PUBLIC	??_C@_09NKHKFHLH@GostCrypt?$AA@			; `string'
PUBLIC	??_7TimeOut@GostCrypt@@6B@			; GostCrypt::TimeOut::`vftable'
PUBLIC	??_C@_1BA@BKONPLFM@?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_7UserAbort@GostCrypt@@6B@			; GostCrypt::UserAbort::`vftable'
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	__TI2?AUParameterIncorrect@GostCrypt@@
PUBLIC	__CTA2?AUParameterIncorrect@GostCrypt@@
PUBLIC	??_R0?AUParameterIncorrect@GostCrypt@@@8	; GostCrypt::ParameterIncorrect `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUParameterIncorrect@GostCrypt@@@8??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z8
PUBLIC	??_R0?AUException@GostCrypt@@@8			; GostCrypt::Exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
PUBLIC	??_C@_0CD@HBGHDAEL@GostCrypt?3?3Elevator?3?3CallDriver?3@ ; `string'
PUBLIC	??_C@_0CD@BFALPFEP@GostCrypt?3?3Elevator?3?3CallDriver?3@ ; `string'
PUBLIC	__TI2?AUSystemException@GostCrypt@@
PUBLIC	__CTA2?AUSystemException@GostCrypt@@
PUBLIC	??_R0?AUSystemException@GostCrypt@@@8		; GostCrypt::SystemException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUSystemException@GostCrypt@@@8??0SystemException@GostCrypt@@QAE@ABU01@@Z8
PUBLIC	??_C@_0CH@HCJBBEHF@GostCrypt?3?3Elevator?3?3ReadWriteFi@ ; `string'
PUBLIC	??_C@_04GBDIODIA@?2?2?4?2?$AA@			; `string'
PUBLIC	??_7?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::`vftable'
PUBLIC	??_C@_0DH@EHEJHGNE@GostCrypt?3?3BootEncryption?3?3GetPa@ ; `string'
PUBLIC	__TI2?AUErrorException@GostCrypt@@
PUBLIC	__CTA2?AUErrorException@GostCrypt@@
PUBLIC	??_R0?AUErrorException@GostCrypt@@@8		; GostCrypt::ErrorException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUErrorException@GostCrypt@@@8??0ErrorException@GostCrypt@@QAE@ABU01@@Z32
PUBLIC	??_C@_0BM@FBNGAMD@SYSTEM_PARTITION_NOT_ACTIVE?$AA@ ; `string'
PUBLIC	??_C@_0CE@MAHFALCP@NO_PARTITION_FOLLOWS_BOOT_PARTIT@ ; `string'
PUBLIC	??_C@_0CH@NLNOGBOO@PARTITION_TOO_SMALL_FOR_HIDDEN_O@ ; `string'
PUBLIC	??_C@_0CC@PECBFKPM@PARTITION_TOO_SMALL_FOR_HIDDEN_O@ ; `string'
PUBLIC	??_C@_05FHMJPCKA@Start?$AA@			; `string'
PUBLIC	??_C@_0CM@LCJDGIOL@SYSTEM?2CurrentControlSet?2Service@ ; `string'
PUBLIC	??_C@_0BM@DMJIFPGL@FOR_MORE_INFO_ON_PARTITIONS?$AA@ ; `string'
PUBLIC	??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@		; `string'
PUBLIC	??_C@_0CE@LDACPNCN@TWO_SYSTEMS_IN_ONE_PARTITION_REM@ ; `string'
PUBLIC	??_C@_09JCILFBFB@gostcrypt?$AA@			; `string'
PUBLIC	??_C@_0BH@EJBOALFB@?2drivers?2gostcrypt?4sys?$AA@ ; `string'
PUBLIC	??_C@_01KICIPPFI@?2?$AA@			; `string'
PUBLIC	??_C@_06IBDJIBGI@Filter?$AA@			; `string'
PUBLIC	??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs?$AA?$AA@	; `string'
PUBLIC	__TI2?AUTimeOut@GostCrypt@@
PUBLIC	__CTA2?AUTimeOut@GostCrypt@@
PUBLIC	??_R0?AUTimeOut@GostCrypt@@@8			; GostCrypt::TimeOut `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUTimeOut@GostCrypt@@@8??0TimeOut@GostCrypt@@QAE@ABU01@@Z4
PUBLIC	??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_istream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_iostream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_istream@_WU?$char_traits@_W@std@@@std@@7B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
PUBLIC	??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_ostream@_WU?$char_traits@_W@std@@@std@@7B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
PUBLIC	??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
PUBLIC	??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
PUBLIC	??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
PUBLIC	??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
PUBLIC	??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
PUBLIC	??_C@_0L@DPPABKKK@?2Partition?$AA@		; `string'
PUBLIC	??_C@_0BB@EPPOJBJL@?2Device?2Harddisk?$AA@	; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_0M@OJHKIMBP@?2Partition0?$AA@		; `string'
PUBLIC	??_C@_0CN@FBLLBALE@GostCrypt?3?3BootEncryption?3?3GetTe@ ; `string'
PUBLIC	??_C@_0DE@OACJGKF@GostCrypt?3?3BootEncryption?3?3GetVo@ ; `string'
PUBLIC	??_C@_0EB@HMOPBABC@GostCrypt?3?3BootEncryption?3?3Syste@ ; `string'
PUBLIC	??_C@_08OINNAHG@?2bootmgr?$AA@			; `string'
PUBLIC	??_C@_06JLGNLLFE@?2ntldr?$AA@			; `string'
PUBLIC	??_C@_1BC@EONGMCPP@?$AA?2?$AAb?$AAo?$AAo?$AAt?$AAm?$AAg?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@MIGMNGND@?$AA?2?$AAn?$AAt?$AAl?$AAd?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_0O@ICNEBHDC@PhysicalDrive?$AA@		; `string'
PUBLIC	??_C@_0DM@OMHMHGFL@GostCrypt?3?3BootEncryption?3?3GetSy@ ; `string'
PUBLIC	??_C@_0DJ@BHABFNLC@GostCrypt?3?3BootEncryption?3?3Creat@ ; `string'
PUBLIC	??_C@_0DJ@HLLFALOF@GostCrypt?3?3BootEncryption?3?3Creat@ ; `string'
PUBLIC	??_C@_03POBHGEJB@BIN?$AA@			; `string'
PUBLIC	??_C@_0DJ@EIEBADFA@GostCrypt?3?3BootEncryption?3?3Creat@ ; `string'
PUBLIC	??_C@_0DJ@PCOOIHML@GostCrypt?3?3BootEncryption?3?3Creat@ ; `string'
PUBLIC	??_C@_0DJ@LNKPBBAM@GostCrypt?3?3BootEncryption?3?3Creat@ ; `string'
PUBLIC	??_C@_0DJ@PDCMONPM@GostCrypt?3?3BootEncryption?3?3Creat@ ; `string'
PUBLIC	??_C@_0DF@DPDHMAHA@GostCrypt?3?3BootEncryption?3?3ReadB@ ; `string'
PUBLIC	??_C@_0BE@GPJOEGCF@ERROR_MBR_PROTECTED?$AA@	; `string'
PUBLIC	??_C@_0DK@IOCENGCH@GostCrypt?3?3BootEncryption?3?3Write@ ; `string'
PUBLIC	??_C@_0DB@GOMJMIPK@GostCrypt?3?3BootEncryption?3?3Start@ ; `string'
PUBLIC	??_C@_0DB@KGBAECPC@GostCrypt?3?3BootEncryption?3?3Start@ ; `string'
PUBLIC	??_C@_0DB@BCHMFGII@GostCrypt?3?3BootEncryption?3?3Start@ ; `string'
PUBLIC	??_C@_0DL@OJIEGNGA@GostCrypt?3?3BootEncryption?3?3WipeH@ ; `string'
PUBLIC	??_C@_0DL@LMFKBOII@GostCrypt?3?3BootEncryption?3?3WipeH@ ; `string'
PUBLIC	??_C@_0L@CANDMBMO@?2GostCrypt?$AA@		; `string'
PUBLIC	??_C@_0BH@KENEBBHH@Original?5System?5Loader?$AA@ ; `string'
PUBLIC	??_C@_0BL@PPCBILBO@Original?5System?5Loader?4bak?$AA@ ; `string'
PUBLIC	??_C@_0DF@KLIDFACM@GostCrypt?3?3BootEncryption?3?3Creat@ ; `string'
PUBLIC	??_C@_07NKOFPJFH@?$ABCD001?$AB?$AA@		; `string'
PUBLIC	??_C@_0CB@MBJIJKGC@GostCrypt?5Rescue?5Disk?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0BO@DHOJLLGB@CD001?$ABEL?5TORITO?5SPECIFICATION?$AA@ ; `string'
PUBLIC	??_C@_07DAAEPPCP@?$PPCD001?$AB?$AA@		; `string'
PUBLIC	??_C@_0DF@NJKAADBI@GostCrypt?3?3BootEncryption?3?3Creat@ ; `string'
PUBLIC	??_C@_0CH@FHEPLLOO@SYS_LOADER_UNAVAILABLE_FOR_RESCU@ ; `string'
PUBLIC	??_C@_03OPPAHFLA@X?3?2?$AA@			; `string'
PUBLIC	??_C@_0DB@MFFJFGID@GostCrypt?3?3BootEncryption?3?3Verif@ ; `string'
PUBLIC	??_C@_02EHLIIHJM@X?3?$AA@			; `string'
PUBLIC	??_C@_0DD@EBKOHCHJ@GostCrypt?3?3BootEncryption?3?3Creat@ ; `string'
PUBLIC	??_C@_0DD@COJOPAEA@GostCrypt?3?3BootEncryption?3?3Creat@ ; `string'
PUBLIC	??_C@_0DE@FGBLJEP@GostCrypt?3?3BootEncryption?3?3Insta@ ; `string'
PUBLIC	??_C@_0CC@HLAJAJLP@GST_BOOT_LOADER_ALREADY_INSTALLE@ ; `string'
PUBLIC	__TI2?AUUserAbort@GostCrypt@@
PUBLIC	__CTA2?AUUserAbort@GostCrypt@@
PUBLIC	??_R0?AUUserAbort@GostCrypt@@@8			; GostCrypt::UserAbort `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUUserAbort@GostCrypt@@@8??0UserAbort@GostCrypt@@QAE@ABU01@@Z4
PUBLIC	??_C@_0DE@DNAHMIJK@GostCrypt?3?3BootEncryption?3?3Resto@ ; `string'
PUBLIC	??_C@_0N@KPKBADH@UpperFilters?$AA@		; `string'
PUBLIC	??_C@_0O@IAPAHIFF@gostcrypt?4sys?$AA@		; `string'
PUBLIC	??_C@_0M@DBKHNNPD@DumpFilters?$AA@		; `string'
PUBLIC	??_C@_0CO@FIPMIJLN@SYSTEM?2CurrentControlSet?2Control@ ; `string'
PUBLIC	??_C@_0CP@OJIEODCG@GostCrypt?3?3BootEncryption?3?3Regis@ ; `string'
PUBLIC	??_C@_0BM@CLKNIPKP@?2gostcrypt_driver_setup?4inf?$AA@ ; `string'
PUBLIC	??_C@_03CGLHDMIP@?$CC?$AN?6?$AA@		; `string'
PUBLIC	??_C@_02JGFLNPEJ@?0?$CC?$AA@			; `string'
PUBLIC	??_C@_04FLCDBBKO@0008?$AA@			; `string'
PUBLIC	??_C@_04JBLMLCOF@8002?$AA@			; `string'
PUBLIC	??_C@_08OHAGLOJG@?$CC?00x0001?$AA@		; `string'
PUBLIC	??_C@_0CN@EJNJANKE@Reg?$DNgostcrypt_reg?$AN?6?$AN?6?$FLgostcrypt_@ ; `string'
PUBLIC	??_C@_03LDFMNCOE@Add?$AA@			; `string'
PUBLIC	??_C@_03ENJJMCOJ@Del?$AA@			; `string'
PUBLIC	??_C@_0O@MJBIBBDL@?$FLgostcrypt?$FN?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0DF@LDCHKMLL@GostCrypt?3?3BootEncryption?3?3Regis@ ; `string'
PUBLIC	??_C@_0O@GKOBNEPO@GostCrypt?4exe?$AA@		; `string'
PUBLIC	??_C@_09ENFKIOHO@Event?5Log?$AA@		; `string'
PUBLIC	??_C@_0BK@KLJIEDOC@?$CC?5?1systemFavoritesService?$AA@ ; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC?$AA@			; `string'
PUBLIC	??_C@_0BL@LDDPDLLO@GostCrypt?5System?5Favorites?$AA@ ; `string'
PUBLIC	??_C@_0BJ@IIGMOCCE@GostCryptSystemFavorites?$AA@ ; `string'
PUBLIC	??_C@_0CK@KHOKHPEC@Mounts?5GostCrypt?5system?5favorite@ ; `string'
PUBLIC	??_C@_07LMLHFMEG@Service?$AA@			; `string'
PUBLIC	??_C@_0EL@MKLMKGDH@SYSTEM?2CurrentControlSet?2Control@ ; `string'
PUBLIC	??_C@_0EL@ELDIGJGM@SYSTEM?2CurrentControlSet?2Control@ ; `string'
PUBLIC	??_C@_0DC@DDPDEKGA@SYSTEM?2CurrentControlSet?2Control@ ; `string'
PUBLIC	??_C@_0DC@PMGJGMIM@SYSTEM?2CurrentControlSet?2Control@ ; `string'
PUBLIC	??_C@_0CJ@BKBFFPJL@SYS_ENCRYPTION_UNSUPPORTED_ON_CU@ ; `string'
PUBLIC	??_C@_0CI@OBNNMOKO@SYS_ENCRYPTION_UNSUPPORTED_ON_VI@ ; `string'
PUBLIC	??_C@_0BO@EPIDJGMK@FEATURE_REQUIRES_INSTALLATION?$AA@ ; `string'
PUBLIC	??_C@_0BL@CEKJKLIB@GPT_BOOT_DRIVE_UNSUPPORTED?$AA@ ; `string'
PUBLIC	??_C@_0CE@HGBKLHHD@SYSENC_UNSUPPORTED_FOR_DYNAMIC_D@ ; `string'
PUBLIC	??_C@_0BJ@HICFFOOK@NO_SPACE_FOR_BOOT_LOADER?$AA@ ; `string'
PUBLIC	??_C@_0CE@NNOADDIE@SYSENC_UNSUPPORTED_SECTOR_SIZE_B@ ; `string'
PUBLIC	??_C@_0CA@PKMHCFDK@WINDOWS_NOT_ON_BOOT_DRIVE_ERROR?$AA@ ; `string'
PUBLIC	??_C@_0M@BHFNFFHI@PagingFiles?$AA@		; `string'
PUBLIC	??_C@_0ED@FMLJHJOD@System?2CurrentControlSet?2Control@ ; `string'
PUBLIC	??_C@_0CH@FJCBOPJI@RESTRICT_PAGING_FILES_TO_SYS_PAR@ ; `string'
PUBLIC	??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@	; `string'
PUBLIC	??_C@_0CM@BBEONPDF@LEAKS_OUTSIDE_SYSPART_UNIVERSAL_@ ; `string'
PUBLIC	??_C@_0CB@KMEGGAHA@PAGING_FILE_NOT_ON_SYS_PARTITION@ ; `string'
PUBLIC	??_C@_05JLNEMJLN@dummy?$AA@			; `string'
PUBLIC	??_C@_0CC@GBKHKMEM@USER_PROFILE_NOT_ON_SYS_PARTITIO@ ; `string'
PUBLIC	??_C@_0BK@HBDIJMEI@TEMP_NOT_ON_SYS_PARTITION?$AA@ ; `string'
PUBLIC	??_C@_0CK@JKIDFDHF@GostCrypt?3?3BootEncryption?3?3Deins@ ; `string'
PUBLIC	??_C@_0CK@HMMKEFKJ@GostCrypt?3?3BootEncryption?3?3Deins@ ; `string'
PUBLIC	??_C@_0BK@DNPPNAJB@SYS_LOADER_RESTORE_FAILED?$AA@ ; `string'
PUBLIC	??_C@_0CP@GALNFEGF@GostCrypt?3?3BootEncryption?3?3Chang@ ; `string'
PUBLIC	??_C@_0CP@HIGEAPBD@GostCrypt?3?3BootEncryption?3?3Chang@ ; `string'
PUBLIC	??_C@_0CP@HCPKCCBJ@GostCrypt?3?3BootEncryption?3?3Chang@ ; `string'
PUBLIC	??_C@_0CI@DLMOLIMI@GostCrypt?3?3BootEncryption?3?3Insta@ ; `string'
PUBLIC	??_C@_0DI@OHOEDBDC@GostCrypt?3?3BootEncryption?3?3Prepa@ ; `string'
PUBLIC	??_C@_0DE@NDCLNHEC@GostCrypt?3?3BootEncryption?3?3Prepa@ ; `string'
PUBLIC	??_C@_0CM@NPKCCOOP@WHOLE_DRIVE_ENCRYPTION_PREVENTED@ ; `string'
PUBLIC	??_C@_0BE@GGLBNJIB@X?3?2pagefile?4sys?50?50?$AA@ ; `string'
PUBLIC	??_C@_0BA@NANEHOFP@GostCryptConfig?$AA@		; `string'
PUBLIC	??_C@_0DA@BMPPEFPA@GostCrypt?3?3BootEncryption?3?3Start@ ; `string'
PUBLIC	??_C@_0DA@BCJAFCLE@GostCrypt?3?3BootEncryption?3?3Start@ ; `string'
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	??_C@_02BBAHNLBA@?$CFp?$AA@			; `string'
PUBLIC	??_C@_02CLHGNPPK@Lu?$AA@			; `string'
PUBLIC	??_C@_02HIKPPMOK@Ld?$AA@			; `string'
PUBLIC	??_C@_02BDDLJJBK@lu?$AA@			; `string'
PUBLIC	??_C@_02EAOCLKAK@ld?$AA@			; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	??_7?$numpunct@D@std@@6B@			; std::numpunct<char>::`vftable'
PUBLIC	??_C@_02MDKMJEGG@eE?$AA@			; `string'
PUBLIC	??_C@_02OOPEBDOJ@pP?$AA@			; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Static
PUBLIC	?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ios_base@std@@6B@				; std::ios_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R4?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@_W@std@@6B@			; std::ctype<wchar_t>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@_W@std@@@8			; std::ctype<wchar_t> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@_W@std@@8				; std::ctype<wchar_t>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@_W@std@@8				; std::ctype<wchar_t>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@_W@std@@8			; std::ctype<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Container@ForEach@GostCrypt@@6B@		; GostCrypt::ForEach::Container::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUContainer@ForEach@GostCrypt@@@8		; GostCrypt::ForEach::Container `RTTI Type Descriptor'
PUBLIC	??_R3Container@ForEach@GostCrypt@@8		; GostCrypt::ForEach::Container::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Container@ForEach@GostCrypt@@8		; GostCrypt::ForEach::Container::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8	; GostCrypt::ForEach::Container::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Exception@GostCrypt@@6B@			; GostCrypt::Exception::`RTTI Complete Object Locator'
PUBLIC	??_R3Exception@GostCrypt@@8			; GostCrypt::Exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Exception@GostCrypt@@8			; GostCrypt::Exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Exception@GostCrypt@@8		; GostCrypt::Exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4SystemException@GostCrypt@@6B@		; GostCrypt::SystemException::`RTTI Complete Object Locator'
PUBLIC	??_R3SystemException@GostCrypt@@8		; GostCrypt::SystemException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SystemException@GostCrypt@@8		; GostCrypt::SystemException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SystemException@GostCrypt@@8	; GostCrypt::SystemException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ErrorException@GostCrypt@@6B@		; GostCrypt::ErrorException::`RTTI Complete Object Locator'
PUBLIC	??_R3ErrorException@GostCrypt@@8		; GostCrypt::ErrorException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ErrorException@GostCrypt@@8		; GostCrypt::ErrorException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ErrorException@GostCrypt@@8	; GostCrypt::ErrorException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ParameterIncorrect@GostCrypt@@6B@		; GostCrypt::ParameterIncorrect::`RTTI Complete Object Locator'
PUBLIC	??_R3ParameterIncorrect@GostCrypt@@8		; GostCrypt::ParameterIncorrect::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ParameterIncorrect@GostCrypt@@8		; GostCrypt::ParameterIncorrect::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ParameterIncorrect@GostCrypt@@8	; GostCrypt::ParameterIncorrect::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4TimeOut@GostCrypt@@6B@			; GostCrypt::TimeOut::`RTTI Complete Object Locator'
PUBLIC	??_R3TimeOut@GostCrypt@@8			; GostCrypt::TimeOut::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TimeOut@GostCrypt@@8			; GostCrypt::TimeOut::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TimeOut@GostCrypt@@8		; GostCrypt::TimeOut::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4UserAbort@GostCrypt@@6B@			; GostCrypt::UserAbort::`RTTI Complete Object Locator'
PUBLIC	??_R3UserAbort@GostCrypt@@8			; GostCrypt::UserAbort::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2UserAbort@GostCrypt@@8			; GostCrypt::UserAbort::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@UserAbort@GostCrypt@@8		; GostCrypt::UserAbort::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$numpunct@D@std@@6B@			; std::numpunct<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$numpunct@D@std@@@8			; std::numpunct<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@D@std@@8		; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3ff0cccccccccccd
PUBLIC	__real@4000cccccccccccd
PUBLIC	__real@4202a05f20000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_toupper:PROC
EXTRN	__errno:PROC
EXTRN	_memchr:PROC
EXTRN	_memmove:PROC
EXTRN	_strcspn:PROC
EXTRN	_strncpy:PROC
EXTRN	__imp__CreateDirectoryA@8:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__DeleteFileA@4:PROC
EXTRN	__imp__FindFirstVolumeW@8:PROC
EXTRN	__imp__FindNextVolumeW@12:PROC
EXTRN	__imp__FindVolumeClose@4:PROC
EXTRN	__imp__GetDriveTypeA@4:PROC
EXTRN	__imp__QueryDosDeviceW@12:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__imp__SetFilePointerEx@20:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__DecodePointer@4:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__RaiseException@16:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__InitializeCriticalSectionAndSpinCount@8:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp__GetSystemDirectoryA@8:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__GetShortPathNameA@12:PROC
EXTRN	__imp__GetTempPathA@8:PROC
EXTRN	__imp__CopyFileA@12:PROC
EXTRN	__imp__GetVolumeInformationA@32:PROC
EXTRN	__imp__GetVolumePathNameA@12:PROC
EXTRN	__imp__UnregisterClassA@8:PROC
EXTRN	__imp__GetActiveWindow@0:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	__imp__RegSetValueExA@24:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	__imp__CoUninitialize@0:PROC
EXTRN	__imp__CoInitialize@4:PROC
EXTRN	__imp__SysAllocStringLen@8:PROC
EXTRN	__imp__SysFreeString@4:PROC
EXTRN	__imp__SysStringByteLen@4:PROC
EXTRN	__imp__SysAllocStringByteLen@8:PROC
EXTRN	__imp__ChangeServiceConfigA@44:PROC
EXTRN	__imp__ChangeServiceConfig2A@12:PROC
EXTRN	__imp__CloseServiceHandle@4:PROC
EXTRN	__imp__CreateServiceA@52:PROC
EXTRN	__imp__DeleteService@4:PROC
EXTRN	__imp__OpenSCManagerA@12:PROC
EXTRN	__imp__OpenServiceA@12:PROC
EXTRN	_frexp:PROC
EXTRN	___stdio_common_vswprintf:PROC
EXTRN	_rename:PROC
EXTRN	___stdio_common_vsprintf_s:PROC
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	__waccess:PROC
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	_localeconv:PROC
EXTRN	__Getctype:PROC
EXTRN	__Getcvt:PROC
EXTRN	__Mbrtowc:PROC
EXTRN	__Tolower:PROC
EXTRN	__Toupper:PROC
EXTRN	__Wcrtomb:PROC
EXTRN	__Getwctype:PROC
EXTRN	__Getwctypes:PROC
EXTRN	__Towlower:PROC
EXTRN	__Towupper:PROC
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_E_Facet_base@std@@UAEPAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	??_Efacet@locale@std@@MAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	?_Init@locale@std@@CAPAV_Locimp@12@_N@Z:PROC	; std::locale::_Init
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	??_E?$ctype@_W@std@@MAEPAXI@Z:PROC		; std::ctype<wchar_t>::`vector deleting destructor'
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	??_E_System_error@std@@UAEPAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	?_Addstd@ios_base@std@@SAXPAV12@@Z:PROC		; std::ios_base::_Addstd
EXTRN	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z:PROC	; std::ios_base::_Ios_base_dtor
EXTRN	??_Eios_base@std@@UAEPAXI@Z:PROC		; std::ios_base::`vector deleting destructor'
EXTRN	??_EContainer@ForEach@GostCrypt@@UAEPAXI@Z:PROC	; GostCrypt::ForEach::Container::`vector deleting destructor'
EXTRN	__imp__SetupOpenInfFileA@16:PROC
EXTRN	__imp__SetupCloseInfFile@4:PROC
EXTRN	__imp__SetupInstallFromInfSectionA@44:PROC
EXTRN	__imp__SetupDiOpenClassRegKey@8:PROC
EXTRN	__access:PROC
EXTRN	__imp__SHGetFolderPathA@20:PROC
EXTRN	_crypto_close:PROC
EXTRN	_EncryptBuffer:PROC
EXTRN	_DecryptBuffer:PROC
EXTRN	_GetHeaderField32:PROC
EXTRN	_ReadVolumeHeader:PROC
EXTRN	_CreateVolumeHeaderInMemory:PROC
EXTRN	_AbortProcessSilent:PROC
EXTRN	_handleWin32Error:PROC
EXTRN	_DisplayStaticModelessWaitDlg:PROC
EXTRN	_CloseStaticModelessWaitDlg:PROC
EXTRN	_ToUNICODE:PROC
EXTRN	_WaitCursor:PROC
EXTRN	_NormalCursor:PROC
EXTRN	_UserEnrichRandomPool:PROC
EXTRN	_handleError:PROC
EXTRN	_IsAdmin:PROC
EXTRN	_IsUacSupported:PROC
EXTRN	_ResolveSymbolicLink:PROC
EXTRN	_GetDiskDeviceDriveLetter:PROC
EXTRN	_FileExists:PROC
EXTRN	_IsNonInstallMode:PROC
EXTRN	_GetConfigPath:PROC
EXTRN	_Warning:PROC
EXTRN	_Error:PROC
EXTRN	_ErrorDirect:PROC
EXTRN	_AskWarnYesNoString:PROC
EXTRN	_AskWarnNoYes:PROC
EXTRN	_IsOSAtLeast:PROC
EXTRN	_IsHiddenOSRunning:PROC
EXTRN	_RestartComputer:PROC
EXTRN	_MapResource:PROC
EXTRN	_GetDriveGeometry:PROC
EXTRN	_IsPagingFileActive:PROC
EXTRN	_BufferContainsString:PROC
EXTRN	?ToUpperCase@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z:PROC ; ToUpperCase
EXTRN	?GetServiceConfigPath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; GetServiceConfigPath
EXTRN	_GetCrc32:PROC
EXTRN	_MirrorBytes16:PROC
EXTRN	_MirrorBytes32:PROC
EXTRN	_GetString:PROC
EXTRN	_Randinit:PROC
EXTRN	_RandStop:PROC
EXTRN	_IsRandomNumberGeneratorStarted:PROC
EXTRN	_RandgetBytes:PROC
EXTRN	_ReadLocalMachineRegistryDword:PROC
EXTRN	_ReadLocalMachineRegistryMultiString:PROC
EXTRN	_WriteLocalMachineRegistryDword:PROC
EXTRN	_WriteLocalMachineRegistryMultiString:PROC
EXTRN	_WriteLocalMachineRegistryString:PROC
EXTRN	_DeleteLocalMachineRegistryKey:PROC
EXTRN	?GetElevatedInstance@@YAPAUIGostCryptMainCom@@PAUHWND__@@@Z:PROC ; GetElevatedInstance
EXTRN	??_E?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z:PROC ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::`vector deleting destructor'
EXTRN	??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ios<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_iostream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	??_E?$numpunct@D@std@@MAEPAXI@Z:PROC		; std::numpunct<char>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	__ltod3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	?_BADOFF@std@@3_JB:QWORD			; std::_BADOFF
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	?id@?$ctype@_W@std@@2V0locale@2@A:DWORD		; std::ctype<wchar_t>::id
EXTRN	_GUID_DEVCLASS_DISKDRIVE:BYTE
EXTRN	_GUID_DEVCLASS_FLOPPYDISK:BYTE
EXTRN	_GUID_DEVCLASS_VOLUME:BYTE
EXTRN	_MainDlg:DWORD
EXTRN	_nCurrentOS:DWORD
EXTRN	_CurrentOSMajor:DWORD
EXTRN	_CurrentOSMinor:DWORD
EXTRN	_CurrentOSServicePack:DWORD
EXTRN	_hDriver:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A
_BSS	SEGMENT
?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCOM
_BSS	ENDS
;	COMDAT ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A
_BSS	SEGMENT
?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceQI
_BSS	ENDS
;	COMDAT ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A
_BSS	SEGMENT
?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRegistrar
_BSS	ENDS
;	COMDAT ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A
_BSS	SEGMENT
?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRefcount
_BSS	ENDS
;	COMDAT ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A
_BSS	SEGMENT
?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceWindowing
_BSS	ENDS
;	COMDAT ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A
_BSS	SEGMENT
?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceControls
_BSS	ENDS
;	COMDAT ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A
_BSS	SEGMENT
?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceHosting
_BSS	ENDS
;	COMDAT ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBClient
_BSS	ENDS
;	COMDAT ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBProvider
_BSS	ENDS
;	COMDAT ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSnapin
_BSS	ENDS
;	COMDAT ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceNotImpl
_BSS	ENDS
;	COMDAT ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceAllocation
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceTime
_BSS	ENDS
;	COMDAT ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCache
_BSS	ENDS
;	COMDAT ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceStencil
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceMap
_BSS	ENDS
;	COMDAT ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceUtil
_BSS	ENDS
;	COMDAT ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSecurity
_BSS	ENDS
;	COMDAT ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSync
_BSS	ENDS
;	COMDAT ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceISAPI
_BSS	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
;	COMDAT ?confirmed@?BM@??CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ@4_NA
_BSS	SEGMENT
?confirmed@?BM@??CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ@4_NA DB 01H DUP (?) ; `GostCrypt::BootEncryption::CheckRequirements'::`28'::confirmed
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A
_BSS	SEGMENT
?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A DQ 01H DUP (?) ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Static
_BSS	ENDS
;	COMDAT ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA
_BSS	SEGMENT
?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlComModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlComModule@ATL@@YAXXZ ; ATL::_AtlComModule$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+10
CONST	ENDS
;	COMDAT __real@4000cccccccccccd
CONST	SEGMENT
__real@4000cccccccccccd DQ 04000cccccccccccdr	; 2.1
CONST	ENDS
;	COMDAT __real@3ff0cccccccccccd
CONST	SEGMENT
__real@3ff0cccccccccccd DQ 03ff0cccccccccccdr	; 1.05
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@D@std@@8 DD FLAT:??_R0?AV?$numpunct@D@std@@@8 ; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@D@std@@8 ; std::numpunct<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@D@std@@8 DD 00H				; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
data$r	SEGMENT
??_R0?AV?$numpunct@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::numpunct<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@D@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@D@std@@6B@ DD 00H			; std::numpunct<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@D@std@@@8
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 DD FLAT:??_R0?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R2?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R3?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8 DD 00H ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8
data$r	SEGMENT
??_R0?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$'
	DB	'allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCryp'
	DB	't@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ DD 00H ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@@8
	DD	FLAT:??_R3?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@UserAbort@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@UserAbort@GostCrypt@@8 DD FLAT:??_R0?AUUserAbort@GostCrypt@@@8 ; GostCrypt::UserAbort::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3UserAbort@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2UserAbort@GostCrypt@@8
rdata$r	SEGMENT
??_R2UserAbort@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@UserAbort@GostCrypt@@8 ; GostCrypt::UserAbort::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3UserAbort@GostCrypt@@8
rdata$r	SEGMENT
??_R3UserAbort@GostCrypt@@8 DD 00H			; GostCrypt::UserAbort::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2UserAbort@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R4UserAbort@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4UserAbort@GostCrypt@@6B@ DD 00H			; GostCrypt::UserAbort::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUUserAbort@GostCrypt@@@8
	DD	FLAT:??_R3UserAbort@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@TimeOut@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@TimeOut@GostCrypt@@8 DD FLAT:??_R0?AUTimeOut@GostCrypt@@@8 ; GostCrypt::TimeOut::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TimeOut@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2TimeOut@GostCrypt@@8
rdata$r	SEGMENT
??_R2TimeOut@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@TimeOut@GostCrypt@@8 ; GostCrypt::TimeOut::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3TimeOut@GostCrypt@@8
rdata$r	SEGMENT
??_R3TimeOut@GostCrypt@@8 DD 00H			; GostCrypt::TimeOut::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2TimeOut@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R4TimeOut@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4TimeOut@GostCrypt@@6B@ DD 00H			; GostCrypt::TimeOut::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUTimeOut@GostCrypt@@@8
	DD	FLAT:??_R3TimeOut@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ParameterIncorrect@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ParameterIncorrect@GostCrypt@@8 DD FLAT:??_R0?AUParameterIncorrect@GostCrypt@@@8 ; GostCrypt::ParameterIncorrect::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ParameterIncorrect@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2ParameterIncorrect@GostCrypt@@8
rdata$r	SEGMENT
??_R2ParameterIncorrect@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@ParameterIncorrect@GostCrypt@@8 ; GostCrypt::ParameterIncorrect::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3ParameterIncorrect@GostCrypt@@8
rdata$r	SEGMENT
??_R3ParameterIncorrect@GostCrypt@@8 DD 00H		; GostCrypt::ParameterIncorrect::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ParameterIncorrect@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R4ParameterIncorrect@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4ParameterIncorrect@GostCrypt@@6B@ DD 00H		; GostCrypt::ParameterIncorrect::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUParameterIncorrect@GostCrypt@@@8
	DD	FLAT:??_R3ParameterIncorrect@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ErrorException@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ErrorException@GostCrypt@@8 DD FLAT:??_R0?AUErrorException@GostCrypt@@@8 ; GostCrypt::ErrorException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ErrorException@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2ErrorException@GostCrypt@@8
rdata$r	SEGMENT
??_R2ErrorException@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@ErrorException@GostCrypt@@8 ; GostCrypt::ErrorException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3ErrorException@GostCrypt@@8
rdata$r	SEGMENT
??_R3ErrorException@GostCrypt@@8 DD 00H			; GostCrypt::ErrorException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ErrorException@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R4ErrorException@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4ErrorException@GostCrypt@@6B@ DD 00H		; GostCrypt::ErrorException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUErrorException@GostCrypt@@@8
	DD	FLAT:??_R3ErrorException@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SystemException@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SystemException@GostCrypt@@8 DD FLAT:??_R0?AUSystemException@GostCrypt@@@8 ; GostCrypt::SystemException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SystemException@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2SystemException@GostCrypt@@8
rdata$r	SEGMENT
??_R2SystemException@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@SystemException@GostCrypt@@8 ; GostCrypt::SystemException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R3SystemException@GostCrypt@@8
rdata$r	SEGMENT
??_R3SystemException@GostCrypt@@8 DD 00H		; GostCrypt::SystemException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2SystemException@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R4SystemException@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4SystemException@GostCrypt@@6B@ DD 00H		; GostCrypt::SystemException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUSystemException@GostCrypt@@@8
	DD	FLAT:??_R3SystemException@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Exception@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Exception@GostCrypt@@8 DD FLAT:??_R0?AUException@GostCrypt@@@8 ; GostCrypt::Exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2Exception@GostCrypt@@8
rdata$r	SEGMENT
??_R2Exception@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@Exception@GostCrypt@@8 ; GostCrypt::Exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Exception@GostCrypt@@8
rdata$r	SEGMENT
??_R3Exception@GostCrypt@@8 DD 00H			; GostCrypt::Exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R4Exception@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4Exception@GostCrypt@@6B@ DD 00H			; GostCrypt::Exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	FLAT:??_R3Exception@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8 DD FLAT:??_R0?AUContainer@ForEach@GostCrypt@@@8 ; GostCrypt::ForEach::Container::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2Container@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R2Container@ForEach@GostCrypt@@8 DD FLAT:??_R1A@?0A@EA@Container@ForEach@GostCrypt@@8 ; GostCrypt::ForEach::Container::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Container@ForEach@GostCrypt@@8
rdata$r	SEGMENT
??_R3Container@ForEach@GostCrypt@@8 DD 00H		; GostCrypt::ForEach::Container::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUContainer@ForEach@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUContainer@ForEach@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::ForEach::Container `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUContainer@ForEach@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT ??_R4Container@ForEach@GostCrypt@@6B@
rdata$r	SEGMENT
??_R4Container@ForEach@GostCrypt@@6B@ DD 00H		; GostCrypt::ForEach::Container::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUContainer@ForEach@GostCrypt@@@8
	DD	FLAT:??_R3Container@ForEach@GostCrypt@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD FLAT:??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 00H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@_W@std@@8 DD FLAT:??_R0?AV?$ctype@_W@std@@@8 ; std::ctype<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R2?$ctype@_W@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@_W@std@@8 ; std::ctype<wchar_t>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R3?$ctype@_W@std@@8 DD 00H				; std::ctype<wchar_t>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
data$r	SEGMENT
??_R0?AV?$ctype@_W@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<wchar_t> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@_W@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@_W@std@@6B@ DD 00H				; std::ctype<wchar_t>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@_W@std@@@8
	DD	FLAT:??_R3?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
data$r	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$r	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD FLAT:??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$r	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$r	ENDS
;	COMDAT ??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R13?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$r	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$r	SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Facet_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 00H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Facet_base@std@@@8
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	FLAT:??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$all'
	DB	'ocator@_W@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
	DD	068H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD 00H ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$alloca'
	DB	'tor@_W@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DD 00H ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	FLAT:??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	020H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	08H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	018H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	FLAT:??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$alloc'
	DB	'ator@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	068H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocato'
	DB	'r@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
	DD	FLAT:??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	FLAT:??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	020H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	08H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	018H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DD 00H ; std::basic_ios<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4ios_base@std@@6B@
rdata$r	SEGMENT
??_R4ios_base@std@@6B@ DD 00H				; std::ios_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVios_base@std@@@8
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OOPEBDOJ@pP?$AA@
CONST	SEGMENT
??_C@_02OOPEBDOJ@pP?$AA@ DB 'pP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDKMJEGG@eE?$AA@
CONST	SEGMENT
??_C@_02MDKMJEGG@eE?$AA@ DB 'eE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT
??_7?$numpunct@D@std@@6B@ DD FLAT:??_R4?$numpunct@D@std@@6B@ ; std::numpunct<char>::`vftable'
	DD	FLAT:??_E?$numpunct@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_decimal_point@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
CONST	SEGMENT
??_C@_02EAOCLKAK@ld?$AA@ DB 'ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
CONST	SEGMENT
??_C@_02BDDLJJBK@lu?$AA@ DB 'lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld?$AA@ DB 'Ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu?$AA@ DB 'Lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp?$AA@ DB '%p', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
CONST	ENDS
;	COMDAT ??_C@_0DA@BCJAFCLE@GostCrypt?3?3BootEncryption?3?3Start@
CONST	SEGMENT
??_C@_0DA@BCJAFCLE@GostCrypt?3?3BootEncryption?3?3Start@ DB 'GostCrypt::B'
	DB	'ootEncryption::StartEncryption:3067', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BMPPEFPA@GostCrypt?3?3BootEncryption?3?3Start@
CONST	SEGMENT
??_C@_0DA@BMPPEFPA@GostCrypt?3?3BootEncryption?3?3Start@ DB 'GostCrypt::B'
	DB	'ootEncryption::StartDecryption:3042', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NANEHOFP@GostCryptConfig?$AA@
CONST	SEGMENT
??_C@_0BA@NANEHOFP@GostCryptConfig?$AA@ DB 'GostCryptConfig', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GGLBNJIB@X?3?2pagefile?4sys?50?50?$AA@
CONST	SEGMENT
??_C@_0BE@GGLBNJIB@X?3?2pagefile?4sys?50?50?$AA@ DB 'X:\pagefile.sys 0 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NPKCCOOP@WHOLE_DRIVE_ENCRYPTION_PREVENTED@
CONST	SEGMENT
??_C@_0CM@NPKCCOOP@WHOLE_DRIVE_ENCRYPTION_PREVENTED@ DB 'WHOLE_DRIVE_ENCR'
	DB	'YPTION_PREVENTED_BY_DRIVERS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NDCLNHEC@GostCrypt?3?3BootEncryption?3?3Prepa@
CONST	SEGMENT
??_C@_0DE@NDCLNHEC@GostCrypt?3?3BootEncryption?3?3Prepa@ DB 'GostCrypt::B'
	DB	'ootEncryption::PrepareInstallation:2902', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@OHOEDBDC@GostCrypt?3?3BootEncryption?3?3Prepa@
CONST	SEGMENT
??_C@_0DI@OHOEDBDC@GostCrypt?3?3BootEncryption?3?3Prepa@ DB 'GostCrypt::B'
	DB	'ootEncryption::PrepareHiddenOSCreation:2876', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DLMOLIMI@GostCrypt?3?3BootEncryption?3?3Insta@
CONST	SEGMENT
??_C@_0CI@DLMOLIMI@GostCrypt?3?3BootEncryption?3?3Insta@ DB 'GostCrypt::B'
	DB	'ootEncryption::Install:2835', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HCPKCCBJ@GostCrypt?3?3BootEncryption?3?3Chang@
CONST	SEGMENT
??_C@_0CP@HCPKCCBJ@GostCrypt?3?3BootEncryption?3?3Chang@ DB 'GostCrypt::B'
	DB	'ootEncryption::ChangePassword:2694', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HIGEAPBD@GostCrypt?3?3BootEncryption?3?3Chang@
CONST	SEGMENT
??_C@_0CP@HIGEAPBD@GostCrypt?3?3BootEncryption?3?3Chang@ DB 'GostCrypt::B'
	DB	'ootEncryption::ChangePassword:2674', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GALNFEGF@GostCrypt?3?3BootEncryption?3?3Chang@
CONST	SEGMENT
??_C@_0CP@GALNFEGF@GostCrypt?3?3BootEncryption?3?3Chang@ DB 'GostCrypt::B'
	DB	'ootEncryption::ChangePassword:2665', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DNPPNAJB@SYS_LOADER_RESTORE_FAILED?$AA@
CONST	SEGMENT
??_C@_0BK@DNPPNAJB@SYS_LOADER_RESTORE_FAILED?$AA@ DB 'SYS_LOADER_RESTORE_'
	DB	'FAILED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@HMMKEFKJ@GostCrypt?3?3BootEncryption?3?3Deins@
CONST	SEGMENT
??_C@_0CK@HMMKEFKJ@GostCrypt?3?3BootEncryption?3?3Deins@ DB 'GostCrypt::B'
	DB	'ootEncryption::Deinstall:2603', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JKIDFDHF@GostCrypt?3?3BootEncryption?3?3Deins@
CONST	SEGMENT
??_C@_0CK@JKIDFDHF@GostCrypt?3?3BootEncryption?3?3Deins@ DB 'GostCrypt::B'
	DB	'ootEncryption::Deinstall:2589', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HBDIJMEI@TEMP_NOT_ON_SYS_PARTITION?$AA@
CONST	SEGMENT
??_C@_0BK@HBDIJMEI@TEMP_NOT_ON_SYS_PARTITION?$AA@ DB 'TEMP_NOT_ON_SYS_PAR'
	DB	'TITION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GBKHKMEM@USER_PROFILE_NOT_ON_SYS_PARTITIO@
CONST	SEGMENT
??_C@_0CC@GBKHKMEM@USER_PROFILE_NOT_ON_SYS_PARTITIO@ DB 'USER_PROFILE_NOT'
	DB	'_ON_SYS_PARTITION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05JLNEMJLN@dummy?$AA@
CONST	SEGMENT
??_C@_05JLNEMJLN@dummy?$AA@ DB 'dummy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KMEGGAHA@PAGING_FILE_NOT_ON_SYS_PARTITION@
CONST	SEGMENT
??_C@_0CB@KMEGGAHA@PAGING_FILE_NOT_ON_SYS_PARTITION@ DB 'PAGING_FILE_NOT_'
	DB	'ON_SYS_PARTITION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BBEONPDF@LEAKS_OUTSIDE_SYSPART_UNIVERSAL_@
CONST	SEGMENT
??_C@_0CM@BBEONPDF@LEAKS_OUTSIDE_SYSPART_UNIVERSAL_@ DB 'LEAKS_OUTSIDE_SY'
	DB	'SPART_UNIVERSAL_EXPLANATION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@ DB 0aH, 00H, 0aH, 00H, 0aH, 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FJCBOPJI@RESTRICT_PAGING_FILES_TO_SYS_PAR@
CONST	SEGMENT
??_C@_0CH@FJCBOPJI@RESTRICT_PAGING_FILES_TO_SYS_PAR@ DB 'RESTRICT_PAGING_'
	DB	'FILES_TO_SYS_PARTITION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@FMLJHJOD@System?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0ED@FMLJHJOD@System?2CurrentControlSet?2Control@ DB 'System\Current'
	DB	'ControlSet\Control\Session Manager\Memory Management', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BHFNFFHI@PagingFiles?$AA@
CONST	SEGMENT
??_C@_0M@BHFNFFHI@PagingFiles?$AA@ DB 'PagingFiles', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PKMHCFDK@WINDOWS_NOT_ON_BOOT_DRIVE_ERROR?$AA@
CONST	SEGMENT
??_C@_0CA@PKMHCFDK@WINDOWS_NOT_ON_BOOT_DRIVE_ERROR?$AA@ DB 'WINDOWS_NOT_O'
	DB	'N_BOOT_DRIVE_ERROR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NNOADDIE@SYSENC_UNSUPPORTED_SECTOR_SIZE_B@
CONST	SEGMENT
??_C@_0CE@NNOADDIE@SYSENC_UNSUPPORTED_SECTOR_SIZE_B@ DB 'SYSENC_UNSUPPORT'
	DB	'ED_SECTOR_SIZE_BIOS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HICFFOOK@NO_SPACE_FOR_BOOT_LOADER?$AA@
CONST	SEGMENT
??_C@_0BJ@HICFFOOK@NO_SPACE_FOR_BOOT_LOADER?$AA@ DB 'NO_SPACE_FOR_BOOT_LO'
	DB	'ADER', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HGBKLHHD@SYSENC_UNSUPPORTED_FOR_DYNAMIC_D@
CONST	SEGMENT
??_C@_0CE@HGBKLHHD@SYSENC_UNSUPPORTED_FOR_DYNAMIC_D@ DB 'SYSENC_UNSUPPORT'
	DB	'ED_FOR_DYNAMIC_DISK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CEKJKLIB@GPT_BOOT_DRIVE_UNSUPPORTED?$AA@
CONST	SEGMENT
??_C@_0BL@CEKJKLIB@GPT_BOOT_DRIVE_UNSUPPORTED?$AA@ DB 'GPT_BOOT_DRIVE_UNS'
	DB	'UPPORTED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EPIDJGMK@FEATURE_REQUIRES_INSTALLATION?$AA@
CONST	SEGMENT
??_C@_0BO@EPIDJGMK@FEATURE_REQUIRES_INSTALLATION?$AA@ DB 'FEATURE_REQUIRE'
	DB	'S_INSTALLATION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@OBNNMOKO@SYS_ENCRYPTION_UNSUPPORTED_ON_VI@
CONST	SEGMENT
??_C@_0CI@OBNNMOKO@SYS_ENCRYPTION_UNSUPPORTED_ON_VI@ DB 'SYS_ENCRYPTION_U'
	DB	'NSUPPORTED_ON_VISTA_SP0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BKBFFPJL@SYS_ENCRYPTION_UNSUPPORTED_ON_CU@
CONST	SEGMENT
??_C@_0CJ@BKBFFPJL@SYS_ENCRYPTION_UNSUPPORTED_ON_CU@ DB 'SYS_ENCRYPTION_U'
	DB	'NSUPPORTED_ON_CURRENT_OS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@PMGJGMIM@SYSTEM?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0DC@PMGJGMIM@SYSTEM?2CurrentControlSet?2Control@ DB 'SYSTEM\Current'
	DB	'ControlSet\Control\SafeBoot\Network', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DDPDEKGA@SYSTEM?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0DC@DDPDEKGA@SYSTEM?2CurrentControlSet?2Control@ DB 'SYSTEM\Current'
	DB	'ControlSet\Control\SafeBoot\Minimal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@ELDIGJGM@SYSTEM?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0EL@ELDIGJGM@SYSTEM?2CurrentControlSet?2Control@ DB 'SYSTEM\Current'
	DB	'ControlSet\Control\SafeBoot\Network\GostCryptSystemFavorites', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@MKLMKGDH@SYSTEM?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0EL@MKLMKGDH@SYSTEM?2CurrentControlSet?2Control@ DB 'SYSTEM\Current'
	DB	'ControlSet\Control\SafeBoot\Minimal\GostCryptSystemFavorites', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LMLHFMEG@Service?$AA@
CONST	SEGMENT
??_C@_07LMLHFMEG@Service?$AA@ DB 'Service', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KHOKHPEC@Mounts?5GostCrypt?5system?5favorite@
CONST	SEGMENT
??_C@_0CK@KHOKHPEC@Mounts?5GostCrypt?5system?5favorite@ DB 'Mounts GostCr'
	DB	'ypt system favorite volumes.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IIGMOCCE@GostCryptSystemFavorites?$AA@
CONST	SEGMENT
??_C@_0BJ@IIGMOCCE@GostCryptSystemFavorites?$AA@ DB 'GostCryptSystemFavor'
	DB	'ites', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LDDPDLLO@GostCrypt?5System?5Favorites?$AA@
CONST	SEGMENT
??_C@_0BL@LDDPDLLO@GostCrypt?5System?5Favorites?$AA@ DB 'GostCrypt System'
	DB	' Favorites', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC?$AA@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC?$AA@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KLJIEDOC@?$CC?5?1systemFavoritesService?$AA@
CONST	SEGMENT
??_C@_0BK@KLJIEDOC@?$CC?5?1systemFavoritesService?$AA@ DB '" /systemFavor'
	DB	'itesService', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09ENFKIOHO@Event?5Log?$AA@
CONST	SEGMENT
??_C@_09ENFKIOHO@Event?5Log?$AA@ DB 'Event Log', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GKOBNEPO@GostCrypt?4exe?$AA@
CONST	SEGMENT
??_C@_0O@GKOBNEPO@GostCrypt?4exe?$AA@ DB 'GostCrypt.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LDCHKMLL@GostCrypt?3?3BootEncryption?3?3Regis@
CONST	SEGMENT
??_C@_0DF@LDCHKMLL@GostCrypt?3?3BootEncryption?3?3Regis@ DB 'GostCrypt::B'
	DB	'ootEncryption::RegisterFilterDriver:2335', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MJBIBBDL@?$FLgostcrypt?$FN?$AN?6?$AA@
CONST	SEGMENT
??_C@_0O@MJBIBBDL@?$FLgostcrypt?$FN?$AN?6?$AA@ DB '[gostcrypt]', 0dH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03ENJJMCOJ@Del?$AA@
CONST	SEGMENT
??_C@_03ENJJMCOJ@Del?$AA@ DB 'Del', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LDFMNCOE@Add?$AA@
CONST	SEGMENT
??_C@_03LDFMNCOE@Add?$AA@ DB 'Add', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EJNJANKE@Reg?$DNgostcrypt_reg?$AN?6?$AN?6?$FLgostcrypt_@
CONST	SEGMENT
??_C@_0CN@EJNJANKE@Reg?$DNgostcrypt_reg?$AN?6?$AN?6?$FLgostcrypt_@ DB 'Re'
	DB	'g=gostcrypt_reg', 0dH, 0aH, 0dH, 0aH, '[gostcrypt_reg]', 0dH, 0aH
	DB	'HKR,,"', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08OHAGLOJG@?$CC?00x0001?$AA@
CONST	SEGMENT
??_C@_08OHAGLOJG@?$CC?00x0001?$AA@ DB '",0x0001', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04JBLMLCOF@8002?$AA@
CONST	SEGMENT
??_C@_04JBLMLCOF@8002?$AA@ DB '8002', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FLCDBBKO@0008?$AA@
CONST	SEGMENT
??_C@_04FLCDBBKO@0008?$AA@ DB '0008', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02JGFLNPEJ@?0?$CC?$AA@
CONST	SEGMENT
??_C@_02JGFLNPEJ@?0?$CC?$AA@ DB ',"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CGLHDMIP@?$CC?$AN?6?$AA@
CONST	SEGMENT
??_C@_03CGLHDMIP@?$CC?$AN?6?$AA@ DB '"', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CLKNIPKP@?2gostcrypt_driver_setup?4inf?$AA@
CONST	SEGMENT
??_C@_0BM@CLKNIPKP@?2gostcrypt_driver_setup?4inf?$AA@ DB '\gostcrypt_driv'
	DB	'er_setup.inf', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OJIEODCG@GostCrypt?3?3BootEncryption?3?3Regis@
CONST	SEGMENT
??_C@_0CP@OJIEODCG@GostCrypt?3?3BootEncryption?3?3Regis@ DB 'GostCrypt::B'
	DB	'ootEncryption::RegisterFilter:2257', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FIPMIJLN@SYSTEM?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0CO@FIPMIJLN@SYSTEM?2CurrentControlSet?2Control@ DB 'SYSTEM\Current'
	DB	'ControlSet\Control\CrashControl', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DBKHNNPD@DumpFilters?$AA@
CONST	SEGMENT
??_C@_0M@DBKHNNPD@DumpFilters?$AA@ DB 'DumpFilters', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IAPAHIFF@gostcrypt?4sys?$AA@
CONST	SEGMENT
??_C@_0O@IAPAHIFF@gostcrypt?4sys?$AA@ DB 'gostcrypt.sys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KPKBADH@UpperFilters?$AA@
CONST	SEGMENT
??_C@_0N@KPKBADH@UpperFilters?$AA@ DB 'UpperFilters', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@DNAHMIJK@GostCrypt?3?3BootEncryption?3?3Resto@
CONST	SEGMENT
??_C@_0DE@DNAHMIJK@GostCrypt?3?3BootEncryption?3?3Resto@ DB 'GostCrypt::B'
	DB	'ootEncryption::RestoreSystemLoader:2202', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AUUserAbort@GostCrypt@@@8??0UserAbort@GostCrypt@@QAE@ABU01@@Z4
xdata$x	SEGMENT
__CT??_R0?AUUserAbort@GostCrypt@@@8??0UserAbort@GostCrypt@@QAE@ABU01@@Z4 DD 00H
	DD	FLAT:??_R0?AUUserAbort@GostCrypt@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	FLAT:??0UserAbort@GostCrypt@@QAE@ABU01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUUserAbort@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUUserAbort@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::UserAbort `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUUserAbort@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AUUserAbort@GostCrypt@@
xdata$x	SEGMENT
__CTA2?AUUserAbort@GostCrypt@@ DD 02H
	DD	FLAT:__CT??_R0?AUUserAbort@GostCrypt@@@8??0UserAbort@GostCrypt@@QAE@ABU01@@Z4
	DD	FLAT:__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
xdata$x	ENDS
;	COMDAT __TI2?AUUserAbort@GostCrypt@@
xdata$x	SEGMENT
__TI2?AUUserAbort@GostCrypt@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2?AUUserAbort@GostCrypt@@
xdata$x	ENDS
;	COMDAT ??_C@_0CC@HLAJAJLP@GST_BOOT_LOADER_ALREADY_INSTALLE@
CONST	SEGMENT
??_C@_0CC@HLAJAJLP@GST_BOOT_LOADER_ALREADY_INSTALLE@ DB 'GST_BOOT_LOADER_'
	DB	'ALREADY_INSTALLED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FGBLJEP@GostCrypt?3?3BootEncryption?3?3Insta@
CONST	SEGMENT
??_C@_0DE@FGBLJEP@GostCrypt?3?3BootEncryption?3?3Insta@ DB 'GostCrypt::Bo'
	DB	'otEncryption::InstallVolumeHeader:2113', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@COJOPAEA@GostCrypt?3?3BootEncryption?3?3Creat@
CONST	SEGMENT
??_C@_0DD@COJOPAEA@GostCrypt?3?3BootEncryption?3?3Creat@ DB 'GostCrypt::B'
	DB	'ootEncryption::CreateVolumeHeader:2086', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EBKOHCHJ@GostCrypt?3?3BootEncryption?3?3Creat@
CONST	SEGMENT
??_C@_0DD@EBKOHCHJ@GostCrypt?3?3BootEncryption?3?3Creat@ DB 'GostCrypt::B'
	DB	'ootEncryption::CreateVolumeHeader:2072', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02EHLIIHJM@X?3?$AA@
CONST	SEGMENT
??_C@_02EHLIIHJM@X?3?$AA@ DB 'X:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MFFJFGID@GostCrypt?3?3BootEncryption?3?3Verif@
CONST	SEGMENT
??_C@_0DB@MFFJFGID@GostCrypt?3?3BootEncryption?3?3Verif@ DB 'GostCrypt::B'
	DB	'ootEncryption::VerifyRescueDisk:2025', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03OPPAHFLA@X?3?2?$AA@
CONST	SEGMENT
??_C@_03OPPAHFLA@X?3?2?$AA@ DB 'X:\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FHEPLLOO@SYS_LOADER_UNAVAILABLE_FOR_RESCU@
CONST	SEGMENT
??_C@_0CH@FHEPLLOO@SYS_LOADER_UNAVAILABLE_FOR_RESCU@ DB 'SYS_LOADER_UNAVA'
	DB	'ILABLE_FOR_RESCUE_DISK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@NJKAADBI@GostCrypt?3?3BootEncryption?3?3Creat@
CONST	SEGMENT
??_C@_0DF@NJKAADBI@GostCrypt?3?3BootEncryption?3?3Creat@ DB 'GostCrypt::B'
	DB	'ootEncryption::CreateRescueIsoImage:1949', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DAAEPPCP@?$PPCD001?$AB?$AA@
CONST	SEGMENT
??_C@_07DAAEPPCP@?$PPCD001?$AB?$AA@ DB 0ffH, 'CD001', 01H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DHOJLLGB@CD001?$ABEL?5TORITO?5SPECIFICATION?$AA@
CONST	SEGMENT
??_C@_0BO@DHOJLLGB@CD001?$ABEL?5TORITO?5SPECIFICATION?$AA@ DB 'CD001', 01H
	DB	'EL TORITO SPECIFICATION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MBJIJKGC@GostCrypt?5Rescue?5Disk?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CB@MBJIJKGC@GostCrypt?5Rescue?5Disk?5?5?5?5?5?5?5?5?5?5?5@ DB 'Gos'
	DB	'tCrypt Rescue Disk           ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NKOFPJFH@?$ABCD001?$AB?$AA@
CONST	SEGMENT
??_C@_07NKOFPJFH@?$ABCD001?$AB?$AA@ DB 01H, 'CD001', 01H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KLIDFACM@GostCrypt?3?3BootEncryption?3?3Creat@
CONST	SEGMENT
??_C@_0DF@KLIDFACM@GostCrypt?3?3BootEncryption?3?3Creat@ DB 'GostCrypt::B'
	DB	'ootEncryption::CreateRescueIsoImage:1871', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PPCBILBO@Original?5System?5Loader?4bak?$AA@
CONST	SEGMENT
??_C@_0BL@PPCBILBO@Original?5System?5Loader?4bak?$AA@ DB 'Original System'
	DB	' Loader.bak', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KENEBBHH@Original?5System?5Loader?$AA@
CONST	SEGMENT
??_C@_0BH@KENEBBHH@Original?5System?5Loader?$AA@ DB 'Original System Load'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CANDMBMO@?2GostCrypt?$AA@
CONST	SEGMENT
??_C@_0L@CANDMBMO@?2GostCrypt?$AA@ DB '\GostCrypt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@LMFKBOII@GostCrypt?3?3BootEncryption?3?3WipeH@
CONST	SEGMENT
??_C@_0DL@LMFKBOII@GostCrypt?3?3BootEncryption?3?3WipeH@ DB 'GostCrypt::B'
	DB	'ootEncryption::WipeHiddenOSCreationConfig:1735', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@OJIEGNGA@GostCrypt?3?3BootEncryption?3?3WipeH@
CONST	SEGMENT
??_C@_0DL@OJIEGNGA@GostCrypt?3?3BootEncryption?3?3WipeH@ DB 'GostCrypt::B'
	DB	'ootEncryption::WipeHiddenOSCreationConfig:1713', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@BCHMFGII@GostCrypt?3?3BootEncryption?3?3Start@
CONST	SEGMENT
??_C@_0DB@BCHMFGII@GostCrypt?3?3BootEncryption?3?3Start@ DB 'GostCrypt::B'
	DB	'ootEncryption::StartDecoyOSWipe:1654', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KGBAECPC@GostCrypt?3?3BootEncryption?3?3Start@
CONST	SEGMENT
??_C@_0DB@KGBAECPC@GostCrypt?3?3BootEncryption?3?3Start@ DB 'GostCrypt::B'
	DB	'ootEncryption::StartDecoyOSWipe:1649', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GOMJMIPK@GostCrypt?3?3BootEncryption?3?3Start@
CONST	SEGMENT
??_C@_0DB@GOMJMIPK@GostCrypt?3?3BootEncryption?3?3Start@ DB 'GostCrypt::B'
	DB	'ootEncryption::StartDecoyOSWipe:1641', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@IOCENGCH@GostCrypt?3?3BootEncryption?3?3Write@
CONST	SEGMENT
??_C@_0DK@IOCENGCH@GostCrypt?3?3BootEncryption?3?3Write@ DB 'GostCrypt::B'
	DB	'ootEncryption::WriteBootSectorUserConfig:1569', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GPJOEGCF@ERROR_MBR_PROTECTED?$AA@
CONST	SEGMENT
??_C@_0BE@GPJOEGCF@ERROR_MBR_PROTECTED?$AA@ DB 'ERROR_MBR_PROTECTED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@DPDHMAHA@GostCrypt?3?3BootEncryption?3?3ReadB@
CONST	SEGMENT
??_C@_0DF@DPDHMAHA@GostCrypt?3?3BootEncryption?3?3ReadB@ DB 'GostCrypt::B'
	DB	'ootEncryption::ReadBootSectorConfig:1469', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@PDCMONPM@GostCrypt?3?3BootEncryption?3?3Creat@
CONST	SEGMENT
??_C@_0DJ@PDCMONPM@GostCrypt?3?3BootEncryption?3?3Creat@ DB 'GostCrypt::B'
	DB	'ootEncryption::CreateBootLoaderInMemory:1430', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@LNKPBBAM@GostCrypt?3?3BootEncryption?3?3Creat@
CONST	SEGMENT
??_C@_0DJ@LNKPBBAM@GostCrypt?3?3BootEncryption?3?3Creat@ DB 'GostCrypt::B'
	DB	'ootEncryption::CreateBootLoaderInMemory:1427', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@PCOOIHML@GostCrypt?3?3BootEncryption?3?3Creat@
CONST	SEGMENT
??_C@_0DJ@PCOOIHML@GostCrypt?3?3BootEncryption?3?3Creat@ DB 'GostCrypt::B'
	DB	'ootEncryption::CreateBootLoaderInMemory:1420', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@EIEBADFA@GostCrypt?3?3BootEncryption?3?3Creat@
CONST	SEGMENT
??_C@_0DJ@EIEBADFA@GostCrypt?3?3BootEncryption?3?3Creat@ DB 'GostCrypt::B'
	DB	'ootEncryption::CreateBootLoaderInMemory:1393', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03POBHGEJB@BIN?$AA@
CONST	SEGMENT
??_C@_03POBHGEJB@BIN?$AA@ DB 'BIN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@HLLFALOF@GostCrypt?3?3BootEncryption?3?3Creat@
CONST	SEGMENT
??_C@_0DJ@HLLFALOF@GostCrypt?3?3BootEncryption?3?3Creat@ DB 'GostCrypt::B'
	DB	'ootEncryption::CreateBootLoaderInMemory:1381', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@BHABFNLC@GostCrypt?3?3BootEncryption?3?3Creat@
CONST	SEGMENT
??_C@_0DJ@BHABFNLC@GostCrypt?3?3BootEncryption?3?3Creat@ DB 'GostCrypt::B'
	DB	'ootEncryption::CreateBootLoaderInMemory:1355', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@OMHMHGFL@GostCrypt?3?3BootEncryption?3?3GetSy@
CONST	SEGMENT
??_C@_0DM@OMHMHGFL@GostCrypt?3?3BootEncryption?3?3GetSy@ DB 'GostCrypt::B'
	DB	'ootEncryption::GetSystemDriveConfiguration:1289', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ICNEBHDC@PhysicalDrive?$AA@
CONST	SEGMENT
??_C@_0O@ICNEBHDC@PhysicalDrive?$AA@ DB 'PhysicalDrive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@MIGMNGND@?$AA?2?$AAn?$AAt?$AAl?$AAd?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1O@MIGMNGND@?$AA?2?$AAn?$AAt?$AAl?$AAd?$AAr?$AA?$AA@ DB '\', 00H, 'n'
	DB	00H, 't', 00H, 'l', 00H, 'd', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@EONGMCPP@?$AA?2?$AAb?$AAo?$AAo?$AAt?$AAm?$AAg?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@EONGMCPP@?$AA?2?$AAb?$AAo?$AAo?$AAt?$AAm?$AAg?$AAr?$AA?$AA@ DB '\'
	DB	00H, 'b', 00H, 'o', 00H, 'o', 00H, 't', 00H, 'm', 00H, 'g', 00H
	DB	'r', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06JLGNLLFE@?2ntldr?$AA@
CONST	SEGMENT
??_C@_06JLGNLLFE@?2ntldr?$AA@ DB '\ntldr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OINNAHG@?2bootmgr?$AA@
CONST	SEGMENT
??_C@_08OINNAHG@?2bootmgr?$AA@ DB '\bootmgr', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@HMOPBABC@GostCrypt?3?3BootEncryption?3?3Syste@
CONST	SEGMENT
??_C@_0EB@HMOPBABC@GostCrypt?3?3BootEncryption?3?3Syste@ DB 'GostCrypt::B'
	DB	'ootEncryption::SystemDriveContainsPartitionType:1126', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@OACJGKF@GostCrypt?3?3BootEncryption?3?3GetVo@
CONST	SEGMENT
??_C@_0DE@OACJGKF@GostCrypt?3?3BootEncryption?3?3GetVo@ DB 'GostCrypt::Bo'
	DB	'otEncryption::GetVolumeProperties:1085', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FBLLBALE@GostCrypt?3?3BootEncryption?3?3GetTe@
CONST	SEGMENT
??_C@_0CN@FBLLBALE@GostCrypt?3?3BootEncryption?3?3GetTe@ DB 'GostCrypt::B'
	DB	'ootEncryption::GetTempPathA:1001', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OJHKIMBP@?2Partition0?$AA@
CONST	SEGMENT
??_C@_0M@OJHKIMBP@?2Partition0?$AA@ DB '\Partition0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EPPOJBJL@?2Device?2Harddisk?$AA@
CONST	SEGMENT
??_C@_0BB@EPPOJBJL@?2Device?2Harddisk?$AA@ DB '\Device\Harddisk', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DPPABKKK@?2Partition?$AA@
CONST	SEGMENT
??_C@_0L@DPPABKKK@?2Partition?$AA@ DB '\Partition', 00H	; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@ DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
	DD	058H
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@ DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
	DD	068H
CONST	ENDS
;	COMDAT ??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DD FLAT:??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DD FLAT:??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z
	DD	FLAT:?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGXZ
	DD	FLAT:?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z
	DD	FLAT:?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z
	DD	FLAT:?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
	DD	FLAT:?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	FLAT:?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z
	DD	FLAT:?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z
	DD	FLAT:?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
CONST	SEGMENT
??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@ DD 00H ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
	DD	010H
CONST	ENDS
;	COMDAT ??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
CONST	SEGMENT
??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@ DD 00H ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
	DD	020H
CONST	ENDS
;	COMDAT ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_8?$basic_ostream@_WU?$char_traits@_W@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ostream@_WU?$char_traits@_W@std@@@std@@7B@ DD 00H ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
	DD	08H
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_8?$basic_istream@_WU?$char_traits@_W@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_istream@_WU?$char_traits@_W@std@@@std@@7B@ DD 00H ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
	DD	018H
CONST	ENDS
;	COMDAT ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	058H
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	068H
CONST	ENDS
;	COMDAT ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
	DD	010H
CONST	ENDS
;	COMDAT ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`vbtable'
	DD	020H
CONST	ENDS
;	COMDAT ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_iostream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`vbtable'
	DD	08H
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_istream<char,std::char_traits<char> >::`vbtable'
	DD	018H
CONST	ENDS
;	COMDAT ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_istream<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
	DD	FLAT:??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT __CT??_R0?AUTimeOut@GostCrypt@@@8??0TimeOut@GostCrypt@@QAE@ABU01@@Z4
xdata$x	SEGMENT
__CT??_R0?AUTimeOut@GostCrypt@@@8??0TimeOut@GostCrypt@@QAE@ABU01@@Z4 DD 00H
	DD	FLAT:??_R0?AUTimeOut@GostCrypt@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	FLAT:??0TimeOut@GostCrypt@@QAE@ABU01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUTimeOut@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUTimeOut@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::TimeOut `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUTimeOut@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AUTimeOut@GostCrypt@@
xdata$x	SEGMENT
__CTA2?AUTimeOut@GostCrypt@@ DD 02H
	DD	FLAT:__CT??_R0?AUTimeOut@GostCrypt@@@8??0TimeOut@GostCrypt@@QAE@ABU01@@Z4
	DD	FLAT:__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
xdata$x	ENDS
;	COMDAT __TI2?AUTimeOut@GostCrypt@@
xdata$x	SEGMENT
__TI2?AUTimeOut@GostCrypt@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2?AUTimeOut@GostCrypt@@
xdata$x	ENDS
;	COMDAT ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs?$AA?$AA@ DB '%', 00H, 'h', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06IBDJIBGI@Filter?$AA@
CONST	SEGMENT
??_C@_06IBDJIBGI@Filter?$AA@ DB 'Filter', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2?$AA@
CONST	SEGMENT
??_C@_01KICIPPFI@?2?$AA@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EJBOALFB@?2drivers?2gostcrypt?4sys?$AA@
CONST	SEGMENT
??_C@_0BH@EJBOALFB@?2drivers?2gostcrypt?4sys?$AA@ DB '\drivers\gostcrypt.'
	DB	'sys', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCILFBFB@gostcrypt?$AA@
CONST	SEGMENT
??_C@_09JCILFBFB@gostcrypt?$AA@ DB 'gostcrypt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LDACPNCN@TWO_SYSTEMS_IN_ONE_PARTITION_REM@
CONST	SEGMENT
??_C@_0CE@LDACPNCN@TWO_SYSTEMS_IN_ONE_PARTITION_REM@ DB 'TWO_SYSTEMS_IN_O'
	DB	'NE_PARTITION_REMARK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@ DB 0aH, 00H, 0aH, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DMJIFPGL@FOR_MORE_INFO_ON_PARTITIONS?$AA@
CONST	SEGMENT
??_C@_0BM@DMJIFPGL@FOR_MORE_INFO_ON_PARTITIONS?$AA@ DB 'FOR_MORE_INFO_ON_'
	DB	'PARTITIONS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LCJDGIOL@SYSTEM?2CurrentControlSet?2Service@
CONST	SEGMENT
??_C@_0CM@LCJDGIOL@SYSTEM?2CurrentControlSet?2Service@ DB 'SYSTEM\Current'
	DB	'ControlSet\Services\gostcrypt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FHMJPCKA@Start?$AA@
CONST	SEGMENT
??_C@_05FHMJPCKA@Start?$AA@ DB 'Start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PECBFKPM@PARTITION_TOO_SMALL_FOR_HIDDEN_O@
CONST	SEGMENT
??_C@_0CC@PECBFKPM@PARTITION_TOO_SMALL_FOR_HIDDEN_O@ DB 'PARTITION_TOO_SM'
	DB	'ALL_FOR_HIDDEN_OS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NLNOGBOO@PARTITION_TOO_SMALL_FOR_HIDDEN_O@
CONST	SEGMENT
??_C@_0CH@NLNOGBOO@PARTITION_TOO_SMALL_FOR_HIDDEN_O@ DB 'PARTITION_TOO_SM'
	DB	'ALL_FOR_HIDDEN_OS_NTFS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MAHFALCP@NO_PARTITION_FOLLOWS_BOOT_PARTIT@
CONST	SEGMENT
??_C@_0CE@MAHFALCP@NO_PARTITION_FOLLOWS_BOOT_PARTIT@ DB 'NO_PARTITION_FOL'
	DB	'LOWS_BOOT_PARTITION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FBNGAMD@SYSTEM_PARTITION_NOT_ACTIVE?$AA@
CONST	SEGMENT
??_C@_0BM@FBNGAMD@SYSTEM_PARTITION_NOT_ACTIVE?$AA@ DB 'SYSTEM_PARTITION_N'
	DB	'OT_ACTIVE', 00H				; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AUErrorException@GostCrypt@@@8??0ErrorException@GostCrypt@@QAE@ABU01@@Z32
xdata$x	SEGMENT
__CT??_R0?AUErrorException@GostCrypt@@@8??0ErrorException@GostCrypt@@QAE@ABU01@@Z32 DD 00H
	DD	FLAT:??_R0?AUErrorException@GostCrypt@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	020H
	DD	FLAT:??0ErrorException@GostCrypt@@QAE@ABU01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUErrorException@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUErrorException@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::ErrorException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUErrorException@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AUErrorException@GostCrypt@@
xdata$x	SEGMENT
__CTA2?AUErrorException@GostCrypt@@ DD 02H
	DD	FLAT:__CT??_R0?AUErrorException@GostCrypt@@@8??0ErrorException@GostCrypt@@QAE@ABU01@@Z32
	DD	FLAT:__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
xdata$x	ENDS
;	COMDAT __TI2?AUErrorException@GostCrypt@@
xdata$x	SEGMENT
__TI2?AUErrorException@GostCrypt@@ DD 00H
	DD	FLAT:??1ErrorException@GostCrypt@@QAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AUErrorException@GostCrypt@@
xdata$x	ENDS
;	COMDAT ??_C@_0DH@EHEJHGNE@GostCrypt?3?3BootEncryption?3?3GetPa@
CONST	SEGMENT
??_C@_0DH@EHEJHGNE@GostCrypt?3?3BootEncryption?3?3GetPa@ DB 'GostCrypt::B'
	DB	'ootEncryption::GetPartitionForHiddenOS:643', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@
CONST	SEGMENT
??_7?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ DD FLAT:??_R4?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::`vftable'
	DD	FLAT:??_E?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z
	DD	FLAT:?IsNotEnd@?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ
	DD	FLAT:?Next@?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ
CONST	ENDS
;	COMDAT ??_C@_04GBDIODIA@?2?2?4?2?$AA@
CONST	SEGMENT
??_C@_04GBDIODIA@?2?2?4?2?$AA@ DB '\\.\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HCJBBEHF@GostCrypt?3?3Elevator?3?3ReadWriteFi@
CONST	SEGMENT
??_C@_0CH@HCJBBEHF@GostCrypt?3?3Elevator?3?3ReadWriteFi@ DB 'GostCrypt::E'
	DB	'levator::ReadWriteFile:172', 00H		; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AUSystemException@GostCrypt@@@8??0SystemException@GostCrypt@@QAE@ABU01@@Z8
xdata$x	SEGMENT
__CT??_R0?AUSystemException@GostCrypt@@@8??0SystemException@GostCrypt@@QAE@ABU01@@Z8 DD 00H
	DD	FLAT:??_R0?AUSystemException@GostCrypt@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	08H
	DD	FLAT:??0SystemException@GostCrypt@@QAE@ABU01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUSystemException@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUSystemException@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::SystemException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUSystemException@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AUSystemException@GostCrypt@@
xdata$x	SEGMENT
__CTA2?AUSystemException@GostCrypt@@ DD 02H
	DD	FLAT:__CT??_R0?AUSystemException@GostCrypt@@@8??0SystemException@GostCrypt@@QAE@ABU01@@Z8
	DD	FLAT:__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
xdata$x	ENDS
;	COMDAT __TI2?AUSystemException@GostCrypt@@
xdata$x	SEGMENT
__TI2?AUSystemException@GostCrypt@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2?AUSystemException@GostCrypt@@
xdata$x	ENDS
;	COMDAT ??_C@_0CD@BFALPFEP@GostCrypt?3?3Elevator?3?3CallDriver?3@
CONST	SEGMENT
??_C@_0CD@BFALPFEP@GostCrypt?3?3Elevator?3?3CallDriver?3@ DB 'GostCrypt::'
	DB	'Elevator::CallDriver:95', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HBGHDAEL@GostCrypt?3?3Elevator?3?3CallDriver?3@
CONST	SEGMENT
??_C@_0CD@HBGHDAEL@GostCrypt?3?3Elevator?3?3CallDriver?3@ DB 'GostCrypt::'
	DB	'Elevator::CallDriver:91', 00H		; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
xdata$x	SEGMENT
__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4 DD 00H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	FLAT:??0Exception@GostCrypt@@QAE@ABU01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUException@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUException@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::Exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUException@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AUParameterIncorrect@GostCrypt@@@8??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z8
xdata$x	SEGMENT
__CT??_R0?AUParameterIncorrect@GostCrypt@@@8??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z8 DD 00H
	DD	FLAT:??_R0?AUParameterIncorrect@GostCrypt@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	08H
	DD	FLAT:??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUParameterIncorrect@GostCrypt@@@8
data$r	SEGMENT
??_R0?AUParameterIncorrect@GostCrypt@@@8 DD FLAT:??_7type_info@@6B@ ; GostCrypt::ParameterIncorrect `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUParameterIncorrect@GostCrypt@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AUParameterIncorrect@GostCrypt@@
xdata$x	SEGMENT
__CTA2?AUParameterIncorrect@GostCrypt@@ DD 02H
	DD	FLAT:__CT??_R0?AUParameterIncorrect@GostCrypt@@@8??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z8
	DD	FLAT:__CT??_R0?AUException@GostCrypt@@@8??0Exception@GostCrypt@@QAE@ABU01@@Z4
xdata$x	ENDS
;	COMDAT __TI2?AUParameterIncorrect@GostCrypt@@
xdata$x	SEGMENT
__TI2?AUParameterIncorrect@GostCrypt@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2?AUParameterIncorrect@GostCrypt@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7UserAbort@GostCrypt@@6B@
CONST	SEGMENT
??_7UserAbort@GostCrypt@@6B@ DD FLAT:??_R4UserAbort@GostCrypt@@6B@ ; GostCrypt::UserAbort::`vftable'
	DD	FLAT:?Show@UserAbort@GostCrypt@@UBEXPAUHWND__@@@Z
CONST	ENDS
;	COMDAT ??_C@_1BA@BKONPLFM@?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@BKONPLFM@?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@ DB 'T', 00H
	DB	'i', 00H, 'm', 00H, 'e', 00H, 'o', 00H, 'u', 00H, 't', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_7TimeOut@GostCrypt@@6B@
CONST	SEGMENT
??_7TimeOut@GostCrypt@@6B@ DD FLAT:??_R4TimeOut@GostCrypt@@6B@ ; GostCrypt::TimeOut::`vftable'
	DD	FLAT:?Show@TimeOut@GostCrypt@@UBEXPAUHWND__@@@Z
CONST	ENDS
;	COMDAT ??_C@_09NKHKFHLH@GostCrypt?$AA@
CONST	SEGMENT
??_C@_09NKHKFHLH@GostCrypt?$AA@ DB 'GostCrypt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0IM@CKBKFPJM@Parameter?5incorrect?4?6?6?6?$CIIf?5you?5r@
CONST	SEGMENT
??_C@_0IM@CKBKFPJM@Parameter?5incorrect?4?6?6?6?$CIIf?5you?5r@ DB 'Parame'
	DB	'ter incorrect.', 0aH, 0aH, 0aH, '(If you report a bug in conn'
	DB	'ection with this, please include the following technical info'
	DB	'rmation in the bug report:', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ?$AA@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ?$AA@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7ParameterIncorrect@GostCrypt@@6B@
CONST	SEGMENT
??_7ParameterIncorrect@GostCrypt@@6B@ DD FLAT:??_R4ParameterIncorrect@GostCrypt@@6B@ ; GostCrypt::ParameterIncorrect::`vftable'
	DD	FLAT:?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z
CONST	ENDS
;	COMDAT ??_7ErrorException@GostCrypt@@6B@
CONST	SEGMENT
??_7ErrorException@GostCrypt@@6B@ DD FLAT:??_R4ErrorException@GostCrypt@@6B@ ; GostCrypt::ErrorException::`vftable'
	DD	FLAT:?Show@ErrorException@GostCrypt@@UBEXPAUHWND__@@@Z
CONST	ENDS
;	COMDAT ??_7SystemException@GostCrypt@@6B@
CONST	SEGMENT
??_7SystemException@GostCrypt@@6B@ DD FLAT:??_R4SystemException@GostCrypt@@6B@ ; GostCrypt::SystemException::`vftable'
	DD	FLAT:?Show@SystemException@GostCrypt@@UBEXPAUHWND__@@@Z
CONST	ENDS
;	COMDAT ??_7Exception@GostCrypt@@6B@
CONST	SEGMENT
??_7Exception@GostCrypt@@6B@ DD FLAT:??_R4Exception@GostCrypt@@6B@ ; GostCrypt::Exception::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ?_AtlComModule@ATL@@3VCAtlComModule@1@A
_DATA	SEGMENT
?_AtlComModule@ATL@@3VCAtlComModule@1@A DB 04H DUP (?)
	DD	FLAT:___ImageBase			; ATL::_AtlComModule
	DD	FLAT:___pobjMapEntryFirst+4
	DD	FLAT:___pobjMapEntryLast
_DATA	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT
__CT??_R0?AVCAtlException@ATL@@@84 DD 00H
	DD	FLAT:??_R0?AVCAtlException@ATL@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
data$r	SEGMENT
??_R0?AVCAtlException@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlException@ATL@@', 00H
data$r	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__CTA1?AVCAtlException@ATL@@ DD 01H
	DD	FLAT:__CT??_R0?AVCAtlException@ATL@@@84
xdata$x	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__TI1?AVCAtlException@ATL@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCAtlException@ATL@@
xdata$x	ENDS
;	COMDAT ??_7Container@ForEach@GostCrypt@@6B@
CONST	SEGMENT
??_7Container@ForEach@GostCrypt@@6B@ DD FLAT:??_R4Container@ForEach@GostCrypt@@6B@ ; GostCrypt::ForEach::Container::`vftable'
	DD	FLAT:??_EContainer@ForEach@GostCrypt@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ DB 'ios_base::failbit se'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0_System_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
data$r	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
data$r	ENDS
;	COMDAT __CTA5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA5?AVfailure@ios_base@std@@ DD 05H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI5?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA5?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_7ios_base@std@@6B@
CONST	SEGMENT
??_7ios_base@std@@6B@ DD FLAT:??_R4ios_base@std@@6B@	; std::ios_base::`vftable'
	DD	FLAT:??_Eios_base@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DD FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DD	FLAT:??_E_System_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7?$ctype@_W@std@@6B@
CONST	SEGMENT
??_7?$ctype@_W@std@@6B@ DD FLAT:??_R4?$ctype@_W@std@@6B@ ; std::ctype<wchar_t>::`vftable'
	DD	FLAT:??_E?$ctype@_W@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z
	DD	FLAT:?do_is@?$ctype@_W@std@@MBE_NF_W@Z
	DD	FLAT:?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
	DD	FLAT:?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
	DD	FLAT:?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
	DD	FLAT:?do_tolower@?$ctype@_W@std@@MBE_W_W@Z
	DD	FLAT:?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
	DD	FLAT:?do_toupper@?$ctype@_W@std@@MBE_W_W@Z
	DD	FLAT:?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z
	DD	FLAT:?do_widen@?$ctype@_W@std@@MBE_WD@Z
	DD	FLAT:?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@_W@std@@MBED_WD@Z
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DD FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DD	FLAT:??_E_Facet_base@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception?$AA@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UPartition@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UPartition@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z$0
__ehfuncinfo$??$construct@UPartition@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UPartition@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UPartition@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@ABU34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UPartition@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@ABU34@@Z$1
__ehfuncinfo$??$construct@UPartition@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@ABU34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UPartition@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@ABU34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@UPartition@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@UPartition@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z$2
__ehfuncinfo$??$construct@UPartition@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@UPartition@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$15 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$0
__unwindtable$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$15
__ehfuncinfo$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z$25 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z$0
__tryblocktable$??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z$25
__unwindtable$??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z$12
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z$12 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z$0
__tryblocktable$??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z$12
__unwindtable$??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z$8
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0
__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$2
__ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0
__ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$33
	DD	02H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$33
	DD	02H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z$0
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z$0
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$32
	DD	02H
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$134
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z$38 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z$0
__unwindtable$??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z$38
__ehfuncinfo$??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__ehfuncinfo$??0Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z$0
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ$2
__catchsym$??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ$0
__unwindtable$??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ DD 0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ
	DD	02H
	DD	FLAT:__tryblocktable$??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__tryblocktable$??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ$4
	DD	00H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$212 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z DD 02H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$212
__ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$5
	DD	01H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$37
	DD	01H
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$96
	DD	01H
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$155
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$210
	DD	09H
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$211
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ$1
__ehfuncinfo$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z$2
__ehfuncinfo$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z$3
__ehfuncinfo$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ$2
__ehfuncinfo$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$0
__ehfuncinfo$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$2
__ehfuncinfo$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ$1
__ehfuncinfo$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ$0
__ehfuncinfo$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ$3
__ehfuncinfo$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$3
__ehfuncinfo$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$4
__ehfuncinfo$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z$0
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z$1
	DD	02H
	DD	00H
__ehfuncinfo$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$2
__ehfuncinfo$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$3
__ehfuncinfo$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$14
	DD	01H
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$15
__ehfuncinfo$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$14 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$14
__ehfuncinfo$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z$0
__ehfuncinfo$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$2
__ehfuncinfo$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$3
__ehfuncinfo$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z$0
__ehfuncinfo$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$1
__ehfuncinfo$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z$1
__ehfuncinfo$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z$1
__ehfuncinfo$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ$0
__ehfuncinfo$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$38 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$38
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$36
	DD	04H
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$37
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ$1
__ehfuncinfo$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z$2
__ehfuncinfo$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z$3
__ehfuncinfo$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ$2
__ehfuncinfo$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
__ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$2
__ehfuncinfo$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ$1
__ehfuncinfo$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ$0
__ehfuncinfo$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ$3
__ehfuncinfo$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$3
__ehfuncinfo$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ$4
__ehfuncinfo$??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$0
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$1
	DD	02H
	DD	00H
__ehfuncinfo$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
__ehfuncinfo$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$3
__ehfuncinfo$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$14
	DD	01H
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$15
__ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$34 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z DD 04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$34
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$5
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$32
	DD	06H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$33
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$14 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$14
__ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z$0
__ehfuncinfo$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
__ehfuncinfo$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$3
__ehfuncinfo$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z$0
__ehfuncinfo$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$1
__ehfuncinfo$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z$1
__ehfuncinfo$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$1
__ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ$0
__ehfuncinfo$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z$0
__ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z$0
__ehfuncinfo$??0?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z$1
__ehfuncinfo$??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?WriteLocalMachineRegistryDwordValue@Elevator@GostCrypt@@SAXPAD0K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?WriteLocalMachineRegistryDwordValue@Elevator@GostCrypt@@SAXPAD0K@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?WriteLocalMachineRegistryDwordValue@Elevator@GostCrypt@@SAXPAD0K@Z$1
__ehfuncinfo$?WriteLocalMachineRegistryDwordValue@Elevator@GostCrypt@@SAXPAD0K@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?WriteLocalMachineRegistryDwordValue@Elevator@GostCrypt@@SAXPAD0K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ReadWriteFile@Elevator@GostCrypt@@SAXHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE_KIPAK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadWriteFile@Elevator@GostCrypt@@SAXHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE_KIPAK@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ReadWriteFile@Elevator@GostCrypt@@SAXHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE_KIPAK@Z$1
__ehfuncinfo$?ReadWriteFile@Elevator@GostCrypt@@SAXHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE_KIPAK@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ReadWriteFile@Elevator@GostCrypt@@SAXHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE_KIPAK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DeleteFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DeleteFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__ehfuncinfo$?DeleteFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DeleteFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CopyFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CopyFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CopyFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z$1
__ehfuncinfo$?CopyFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CopyFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CallDriver@Elevator@GostCrypt@@SAXKPAXK0K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CallDriver@Elevator@GostCrypt@@SAXKPAXK0K@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CallDriver@Elevator@GostCrypt@@SAXKPAXK0K@Z$1
__ehfuncinfo$?CallDriver@Elevator@GostCrypt@@SAXKPAXK0K@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CallDriver@Elevator@GostCrypt@@SAXKPAXK0K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?InstallVolumeHeader@BootEncryption@GostCrypt@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InstallVolumeHeader@BootEncryption@GostCrypt@@IAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?InstallVolumeHeader@BootEncryption@GostCrypt@@IAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InstallVolumeHeader@BootEncryption@GostCrypt@@IAEXXZ$2
__ehfuncinfo$?InstallVolumeHeader@BootEncryption@GostCrypt@@IAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?InstallVolumeHeader@BootEncryption@GostCrypt@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ$4
__ehfuncinfo$?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z DD 019930522H
	DD	01cH
	DD	FLAT:__unwindtable$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$4
	DD	05H
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$8
	DD	07H
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$9
	DD	08H
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$10
	DD	09H
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$11
	DD	0aH
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$12
	DD	0bH
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$13
	DD	0cH
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$14
	DD	0dH
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$15
	DD	0eH
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$16
	DD	0fH
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$17
	DD	010H
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$18
	DD	0fH
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$18
	DD	0eH
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$18
	DD	0dH
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$18
	DD	0cH
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$18
	DD	0bH
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$18
	DD	0aH
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$18
	DD	09H
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$18
	DD	08H
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$18
	DD	07H
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$18
	DD	01aH
	DD	FLAT:__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$19
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$2
__ehfuncinfo$?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$480 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$0
__tryblocktable$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z DD 09H
	DD	09H
	DD	0aH
	DD	01H
	DD	FLAT:__catchsym$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$480
__ehfuncinfo$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z DD 019930522H
	DD	015H
	DD	FLAT:__unwindtable$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z
	DD	01H
	DD	FLAT:__tryblocktable$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$18
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$22
	DD	04H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$19
	DD	06H
	DD	FLAT:__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$26
	DD	00H
	DD	FLAT:__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$3
	DD	08H
	DD	00H
	DD	08H
	DD	00H
	DD	08H
	DD	FLAT:__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$5
	DD	0bH
	DD	FLAT:__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$140
	DD	0bH
	DD	FLAT:__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$300
	DD	0dH
	DD	FLAT:__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$301
	DD	0eH
	DD	FLAT:__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$303
	DD	0bH
	DD	FLAT:__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$7
	DD	010H
	DD	FLAT:__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$8
	DD	010H
	DD	FLAT:__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$476
	DD	00H
	DD	FLAT:__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$479
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z$2
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z$6
	DD	03H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z$3
	DD	05H
	DD	FLAT:__unwindfunclet$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z$45
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$2
__ehfuncinfo$?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z$0
__ehfuncinfo$?CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z$48 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z$0
__catchsym$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z$47 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z$1
__ehfuncinfo$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z
	DD	02H
	DD	FLAT:__tryblocktable$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z$47
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z$48
__unwindtable$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ$4
__ehfuncinfo$?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?WriteBootSectorUserConfig@BootEncryption@GostCrypt@@QAEXEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?WriteBootSectorUserConfig@BootEncryption@GostCrypt@@QAEXEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?WriteBootSectorUserConfig@BootEncryption@GostCrypt@@QAEXEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?WriteBootSectorUserConfig@BootEncryption@GostCrypt@@QAEXEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
__ehfuncinfo$?WriteBootSectorUserConfig@BootEncryption@GostCrypt@@QAEXEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?WriteBootSectorUserConfig@BootEncryption@GostCrypt@@QAEXEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z$2
__ehfuncinfo$?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ$3
__ehfuncinfo$?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ$237 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ$0
__tryblocktable$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ DD 00H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ$237
__ehfuncinfo$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ
	DD	01H
	DD	FLAT:__tryblocktable$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ$4
	DD	02H
	DD	FLAT:__unwindfunclet$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ$5
	DD	0ffffffffH
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ$2
__ehfuncinfo$?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z$2
__ehfuncinfo$?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z$3
__ehfuncinfo$?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$5
	DD	03H
	DD	FLAT:__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$7
	DD	05H
	DD	FLAT:__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$10
	DD	07H
	DD	FLAT:__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$11
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$27 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$2
__catchsym$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$26 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$3
__catchsym$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$25 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$0
__ehfuncinfo$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z
	DD	03H
	DD	FLAT:__tryblocktable$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$25
	DD	07H
	DD	07H
	DD	08H
	DD	01H
	DD	FLAT:__catchsym$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$26
	DD	05H
	DD	05H
	DD	08H
	DD	01H
	DD	FLAT:__catchsym$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$27
__unwindtable$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$6
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$7
	DD	03H
	DD	FLAT:__unwindfunclet$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$8
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	06H
	DD	00H
	DD	06H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$31 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$2
__catchsym$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$30 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$9
__catchsym$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$29 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$7
__catchsym$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$28 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$5
__catchsym$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$27 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$3
__catchsym$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$26 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$0
__ehfuncinfo$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z
	DD	06H
	DD	FLAT:__tryblocktable$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
__tryblocktable$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$26
	DD	04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$27
	DD	06H
	DD	06H
	DD	07H
	DD	01H
	DD	FLAT:__catchsym$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$28
	DD	08H
	DD	08H
	DD	09H
	DD	01H
	DD	FLAT:__catchsym$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$29
	DD	0aH
	DD	0aH
	DD	0bH
	DD	01H
	DD	FLAT:__catchsym$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$30
	DD	02H
	DD	02H
	DD	0bH
	DD	01H
	DD	FLAT:__catchsym$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$31
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z$0
__unwindtable$?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z$7
__ehfuncinfo$?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z
	DD	01H
	DD	FLAT:__tryblocktable$?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$44 DD 08H
	DD	FLAT:??_R0?AUSystemException@GostCrypt@@@8
	DD	0fffffdccH
	DD	FLAT:__catch$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__tryblocktable$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$44
__ehfuncinfo$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$5
	DD	02H
	DD	00H
	DD	02H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z$2
__ehfuncinfo$?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?Install@BootEncryption@GostCrypt@@QAEX_N@Z$6 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	00H
	DD	FLAT:__catch$?Install@BootEncryption@GostCrypt@@QAEX_N@Z$0
__catchsym$?Install@BootEncryption@GostCrypt@@QAEX_N@Z$5 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0ffffff7cH
	DD	FLAT:__catch$?Install@BootEncryption@GostCrypt@@QAEX_N@Z$1
__unwindtable$?Install@BootEncryption@GostCrypt@@QAEX_N@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?Install@BootEncryption@GostCrypt@@QAEX_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?Install@BootEncryption@GostCrypt@@QAEX_N@Z
	DD	02H
	DD	FLAT:__tryblocktable$?Install@BootEncryption@GostCrypt@@QAEX_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?Install@BootEncryption@GostCrypt@@QAEX_N@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?Install@BootEncryption@GostCrypt@@QAEX_N@Z$5
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?Install@BootEncryption@GostCrypt@@QAEX_N@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ DD 019930522H
	DD	011H
	DD	FLAT:__unwindtable$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$5
	DD	03H
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$7
	DD	03H
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$9
	DD	02H
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$364
	DD	07H
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$365
	DD	08H
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$367
	DD	02H
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$11
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$369
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$13
	DD	0cH
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$464
	DD	0cH
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$15
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$628
	DD	02H
	DD	FLAT:__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$631
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ DD 019930522H
	DD	013H
	DD	FLAT:__unwindtable$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$5
	DD	02H
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$8
	DD	01H
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$9
	DD	01H
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$12
	DD	01H
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$14
	DD	0eH
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$15
	DD	01H
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$16
	DD	010H
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$17
	DD	011H
	DD	FLAT:__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$18
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$82 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffbc4H
	DD	FLAT:__catch$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$6
__catchsym$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$81 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$4
__catchsym$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$80 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$0
__catchsym$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$79 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$1
__ehfuncinfo$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z
	DD	04H
	DD	FLAT:__tryblocktable$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z DD 04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$79
	DD	02H
	DD	02H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$80
	DD	06H
	DD	06H
	DD	07H
	DD	01H
	DD	FLAT:__catchsym$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$81
	DD	08H
	DD	09H
	DD	0aH
	DD	01H
	DD	FLAT:__catchsym$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$82
__unwindtable$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$10
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	08H
	DD	FLAT:__unwindfunclet$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$11
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$81 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffdd8H
	DD	FLAT:__catch$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__tryblocktable$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 04H
	DD	05H
	DD	06H
	DD	01H
	DD	FLAT:__catchsym$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$81
__ehfuncinfo$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$5
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:__unwindfunclet$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$7
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ$1
__ehfuncinfo$?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z$120 DD 08H
	DD	FLAT:??_R0?AUException@GostCrypt@@@8
	DD	0fffffb58H
	DD	FLAT:__catch$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z$0
__tryblocktable$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z DD 05H
	DD	05H
	DD	06H
	DD	01H
	DD	FLAT:__catchsym$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z$120
__ehfuncinfo$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z
	DD	01H
	DD	FLAT:__tryblocktable$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z$6
	DD	03H
	DD	FLAT:__unwindfunclet$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z$7
	DD	04H
	DD	00H
	DD	04H
	DD	00H
	DD	04H
	DD	FLAT:__unwindfunclet$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z$8
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z$3 DD 08H
	DD	FLAT:??_R0?AUSystemException@GostCrypt@@@8
	DD	00H
	DD	FLAT:__catch$?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z$0
__unwindtable$?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z$3
__ehfuncinfo$?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z
	DD	01H
	DD	FLAT:__tryblocktable$?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1BootEncryption@GostCrypt@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z$3
__ehfuncinfo$??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0SystemDriveConfiguration@GostCrypt@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SystemDriveConfiguration@GostCrypt@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SystemDriveConfiguration@GostCrypt@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0SystemDriveConfiguration@GostCrypt@@QAE@XZ$2
__ehfuncinfo$??0SystemDriveConfiguration@GostCrypt@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0SystemDriveConfiguration@GostCrypt@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$46 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$46
__unwindtable$??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Partition@GostCrypt@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Partition@GostCrypt@@QAE@ABU01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Partition@GostCrypt@@QAE@ABU01@@Z$1
__ehfuncinfo$??0Partition@GostCrypt@@QAE@ABU01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Partition@GostCrypt@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$179 DD 08H
	DD	FLAT:??_R0?AUSystemException@GostCrypt@@@8
	DD	00H
	DD	FLAT:__catch$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$0
__tryblocktable$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z DD 03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$179
__ehfuncinfo$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$4
	DD	01H
	DD	00H
	DD	01H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?Write@File@GostCrypt@@QAEXPAEK@Z$5 DD 08H
	DD	FLAT:??_R0?AUSystemException@GostCrypt@@@8
	DD	0fffffa04H
	DD	FLAT:__catch$?Write@File@GostCrypt@@QAEXPAEK@Z$0
__tryblocktable$?Write@File@GostCrypt@@QAEXPAEK@Z DD 00H
	DD	00H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?Write@File@GostCrypt@@QAEXPAEK@Z$5
__unwindtable$?Write@File@GostCrypt@@QAEXPAEK@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?Write@File@GostCrypt@@QAEXPAEK@Z$2
__ehfuncinfo$?Write@File@GostCrypt@@QAEXPAEK@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?Write@File@GostCrypt@@QAEXPAEK@Z
	DD	01H
	DD	FLAT:__tryblocktable$?Write@File@GostCrypt@@QAEXPAEK@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z$97 DD 08H
	DD	FLAT:??_R0?AUSystemException@GostCrypt@@@8
	DD	00H
	DD	FLAT:__catch$??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z$0
__tryblocktable$??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z$97
__unwindtable$??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z$3
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z$0
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z$1
__ehfuncinfo$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__F_AtlComModule@ATL@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__F_AtlComModule@ATL@@YAXXZ$0
__ehfuncinfo$??__F_AtlComModule@ATL@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__F_AtlComModule@ATL@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$111
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gios_base@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gios_base@std@@UAEPAXI@Z$0
__ehfuncinfo$??_Gios_base@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Gios_base@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Init@ios_base@std@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Init@ios_base@std@@IAEXXZ$0
__ehfuncinfo$?_Init@ios_base@std@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Init@ios_base@std@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1ios_base@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getloc@ios_base@std@@QBE?AVlocale@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getloc@ios_base@std@@QBE?AVlocale@2@XZ$1
__ehfuncinfo$?getloc@ios_base@std@@QBE?AVlocale@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getloc@ios_base@std@@QBE?AVlocale@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0
__ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1
__ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Glocale@std@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Glocale@std@@QAEPAXI@Z$0
__ehfuncinfo$??_Glocale@std@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Glocale@std@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1locale@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0locale@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0locale@std@@QAE@ABV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlWinModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlWinModule@ATL@@YAXXZ ; ATL::_AtlWinModule$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
??_E?$basic_iostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
??_E?$basic_ostream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_iostream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_iostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_iostream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
??_E?$basic_istream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartition@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UPartition@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z PROC ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::construct<GostCrypt::Partition,GostCrypt::Partition const &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UPartition@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN3@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0Partition@GostCrypt@@QAE@ABU01@@Z
$LN3@construct:

; 738  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UPartition@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UPartition@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UPartition@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UPartition@GostCrypt@@ABU12@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::construct<GostCrypt::Partition,GostCrypt::Partition const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartition@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@ABU34@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UPartition@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@ABU34@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::construct<GostCrypt::Partition,GostCrypt::Partition const &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UPartition@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@ABU34@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN8@construct
  00034	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0Partition@GostCrypt@@QAE@ABU01@@Z
$LN8@construct:

; 858  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UPartition@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@ABU34@@Z$1:
  00000	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UPartition@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@ABU34@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UPartition@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@ABU34@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UPartition@GostCrypt@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@ABU34@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::construct<GostCrypt::Partition,GostCrypt::Partition const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::construct<std::_List_node<GostCrypt::Partition,void *> *,std::_List_node<GostCrypt::Partition,void *> * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::construct<std::_List_node<GostCrypt::Partition,void *> *,std::_List_node<GostCrypt::Partition,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UPartition@GostCrypt@@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UPartition@GostCrypt@@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@@Z PROC ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::destroy<GostCrypt::Partition>, COMDAT
; _this$ = ecx

; 743  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 744  : 		_Ptr->~_Uty();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ

; 745  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??$destroy@UPartition@GostCrypt@@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAUPartition@GostCrypt@@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::destroy<GostCrypt::Partition>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z PROC ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::destroy<std::_List_node<GostCrypt::Partition,void *> *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::destroy<std::_List_node<GostCrypt::Partition,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABV?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> const &>, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0ABV?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z PROC	; std::allocator<wchar_t>::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ENDP	; std::allocator<wchar_t>::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 290  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPartition@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UPartition@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::construct<GostCrypt::Partition,GostCrypt::Partition const &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@UPartition@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN13@construct
  00034	ff 75 0c	 push	 DWORD PTR _<_Args_0>$[ebp]
  00037	e8 00 00 00 00	 call	 ??0Partition@GostCrypt@@QAE@ABU01@@Z
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00046	59		 pop	 ecx
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@UPartition@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z$2:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@UPartition@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@UPartition@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@UPartition@GostCrypt@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@ABU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::construct<GostCrypt::Partition,GostCrypt::Partition const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAPAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@YA$$QAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@YA$$QAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@AAPAU10@@Z PROC ; std::move<std::_List_node<GostCrypt::Partition,void *> * &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAPAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@YA$$QAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@AAPAU10@@Z ENDP ; std::move<std::_List_node<GostCrypt::Partition,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Ptr$ = 12						; size = 4
__Cvt$ = 16						; size = 44
??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z PROC ; std::numpunct<char>::_Getvals<char>, COMDAT
; _this$ = ecx

; 189  : 		{	// get values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 190  : 		_Dp = _MAKLOCCHR(_Elem2, _Ptr->decimal_point[0], _Cvt);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0000b	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 191  : 		_Kseparator = _MAKLOCCHR(_Elem2, _Ptr->thousands_sep[0], _Cvt);

  0000e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00011	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00014	88 41 0d	 mov	 BYTE PTR [ecx+13], al

; 192  : 		}

  00017	5d		 pop	 ebp
  00018	c2 34 00	 ret	 52			; 00000034H
??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z ENDP ; std::numpunct<char>::_Getvals<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z PROC		; std::_Maklocchr<char>, COMDAT

; 686  : 	{	// convert char to _Elem using _Cvtvec

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 687  : 	return ((_Elem)(unsigned char)_Byte);

  00003	8a 45 08	 mov	 al, BYTE PTR __Byte$[ebp]

; 688  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ENDP		; std::_Maklocchr<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 719  : 	{	// convert C string to _Elem sequence using _Cvtvec

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 720  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	57		 push	 edi
  00008	8b fe		 mov	 edi, esi
  0000a	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0000d	0f 1f 00	 npad	 3
$LL11@Maklocstr:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL11@Maklocstr
  00017	2b f9		 sub	 edi, ecx
  00019	47		 inc	 edi

; 721  : 
; 722  : 	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),

  0001a	6a 01		 push	 1
  0001c	57		 push	 edi
  0001d	e8 00 00 00 00	 call	 _calloc
  00022	8b d0		 mov	 edx, eax
  00024	83 c4 08	 add	 esp, 8

; 723  : 		_CRT_BLOCK, __FILE__, __LINE__);
; 724  : 
; 725  : 	if (!_Ptrdest)

  00027	85 d2		 test	 edx, edx
  00029	74 1c		 je	 SHORT $LN13@Maklocstr

; 727  : 
; 728  :  #pragma warning(push)
; 729  :  #pragma warning(disable: 6011)	/* quiet prefast noise */
; 730  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

  0002b	85 ff		 test	 edi, edi
  0002d	74 12		 je	 SHORT $LN3@Maklocstr
  0002f	8b ca		 mov	 ecx, edx
  00031	2b ce		 sub	 ecx, esi
$LL4@Maklocstr:

; 731  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

  00033	8a 06		 mov	 al, BYTE PTR [esi]
  00035	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00038	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  0003c	83 ef 01	 sub	 edi, 1
  0003f	75 f2		 jne	 SHORT $LL4@Maklocstr
$LN3@Maklocstr:
  00041	5f		 pop	 edi

; 732  :  #pragma warning(pop)
; 733  : 
; 734  : 	return (_Ptrdest);

  00042	8b c2		 mov	 eax, edx
  00044	5e		 pop	 esi

; 735  : 	}

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN13@Maklocstr:

; 726  : 		_Xbad_alloc();

  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN15@Maklocstr:
$LN12@Maklocstr:
  0004c	cc		 int	 3
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::construct<std::_List_node<GostCrypt::Partition,void *> *,std::_List_node<GostCrypt::Partition,void *> * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::construct<std::_List_node<GostCrypt::Partition,void *> *,std::_List_node<GostCrypt::Partition,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@YAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@YAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<GostCrypt::Partition,void *> * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@YAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<GostCrypt::Partition,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UPartition@GostCrypt@@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@UPartition@GostCrypt@@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::destroy<GostCrypt::Partition>, COMDAT

; 863  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 864  : 		_Al.destroy(_Ptr);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 865  : 		}

  00006	5d		 pop	 ebp

; 864  : 		_Al.destroy(_Ptr);

  00007	e9 00 00 00 00	 jmp	 ??1Partition@GostCrypt@@QAE@XZ
??$destroy@UPartition@GostCrypt@@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAUPartition@GostCrypt@@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::destroy<GostCrypt::Partition>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::destroy<std::_List_node<GostCrypt::Partition,void *> *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@PAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::destroy<std::_List_node<GostCrypt::Partition,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z PROC ; std::forward<std::allocator<wchar_t> const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z ENDP ; std::forward<std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 858  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z PROC		; std::forward<wchar_t * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ENDP		; std::forward<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

  00000	c3		 ret	 0
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1039 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1052 : 	_Left = _STD move(_Right);
; 1053 : 	}

  00000	c3		 ret	 0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1039 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z PROC ; std::forward<std::allocator<wchar_t> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ENDP ; std::forward<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAI@std@@YA$$QAIAAI@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAI@std@@YA$$QAIAAI@Z PROC			; std::move<unsigned int &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAI@std@@YA$$QAIAAI@Z ENDP			; std::move<unsigned int &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > > >, COMDAT

; 1039 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@0@AAV10@@Z PROC ; std::forward<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator==<char,char>, COMDAT

; 796  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 797  : 	}

  00002	c3		 ret	 0
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator==<char,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator==<std::allocator<char>,std::allocator<char> >, COMDAT

; 1017 : 	return (static_cast<const _Ty&>(_Left)

  00000	b0 01		 mov	 al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator==<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 290  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 08 00	 ret	 8
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z PROC		; std::operator==<wchar_t,wchar_t>, COMDAT

; 796  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 797  : 	}

  00002	c3		 ret	 0
??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z ENDP		; std::operator==<wchar_t,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 1017 : 	return (static_cast<const _Ty&>(_Left)

  00000	b0 01		 mov	 al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > > >, COMDAT
; _this$ = ecx

; 1426 : 		{	// insert [_First, _Last) at _Where, forward iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d e8	 mov	 DWORD PTR _this$[ebp], edi

; 1427 : 		_DEBUG_RANGE(_First, _Last);
; 1428 : 		_Iter _Next = _First;

  00030	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00033	89 45 ec	 mov	 DWORD PTR __Next$[ebp], eax

; 1429 : 
; 1430 : 		_TRY_BEGIN

  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003d	0f 1f 00	 npad	 3
$LL4@Insert_ran:

; 1431 : 		for (; _First != _Last; ++_First)

  00040	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  00043	74 6b		 je	 SHORT $LN3@Insert_ran

; 1432 : 			_Insert(_Where, *_First);

  00045	8b 75 08	 mov	 esi, DWORD PTR __Where$[ebp]
  00048	83 c0 08	 add	 eax, 8
  0004b	50		 push	 eax
  0004c	8b cf		 mov	 ecx, edi
  0004e	ff 76 04	 push	 DWORD PTR [esi+4]
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Buynode<GostCrypt::Partition const &>
  00057	8b d0		 mov	 edx, eax
  00059	b9 21 22 22 02	 mov	 ecx, 35791393		; 02222221H
  0005e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00061	2b c8		 sub	 ecx, eax
  00063	83 f9 01	 cmp	 ecx, 1
  00066	73 0a		 jae	 SHORT $LN38@Insert_ran
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0006d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN111@Insert_ran:
$LN38@Insert_ran:
  00072	40		 inc	 eax
  00073	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00076	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00079	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007c	89 10		 mov	 DWORD PTR [eax], edx
  0007e	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00081	8b 00		 mov	 eax, DWORD PTR [eax]
  00083	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
  00086	eb b8		 jmp	 SHORT $LL4@Insert_ran
__catch$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z$0:

; 1433 : 		_CATCH_ALL
; 1434 : 		for (; _Next != _First; ++_Next)

  00088	8b 75 ec	 mov	 esi, DWORD PTR __Next$[ebp]
  0008b	3b 75 0c	 cmp	 esi, DWORD PTR __First$[ebp]
  0008e	74 17		 je	 SHORT $LN6@Insert_ran
  00090	8b 7d e8	 mov	 edi, DWORD PTR _this$[ebp]
$LL7@Insert_ran:

; 1435 : 			{	// undo inserts
; 1436 : 			_Unchecked_const_iterator _Before = _Where;
; 1437 : 			_Unchecked_erase(--_Before);

  00093	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00096	8b cf		 mov	 ecx, edi
  00098	ff 70 04	 push	 DWORD PTR [eax+4]
  0009b	e8 00 00 00 00	 call	 ?_Unchecked_erase@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Unchecked_erase
  000a0	8b 36		 mov	 esi, DWORD PTR [esi]
  000a2	3b 75 0c	 cmp	 esi, DWORD PTR __First$[ebp]
  000a5	75 ec		 jne	 SHORT $LL7@Insert_ran
$LN6@Insert_ran:

; 1438 : 			}
; 1439 : 		_RERAISE;

  000a7	6a 00		 push	 0
  000a9	6a 00		 push	 0
  000ab	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN112@Insert_ran:
$LN3@Insert_ran:

; 1440 : 		_CATCH_END
; 1441 : 		}

  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 10 00	 ret	 16			; 00000010H
$LN110@Insert_ran:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@1@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > ><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,void>, COMDAT
; _this$ = ecx

; 611  : 		{	// construct head node, allocator from _Al

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 612  : 		_Myhead() = _Buyheadnode();

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Buynode0
  00019	89 06		 mov	 DWORD PTR [esi], eax

; 613  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@1@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > ><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Arg$ = 12						; size = 4
??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Reusenode<GostCrypt::Partition const &>, COMDAT
; _this$ = ecx

; 1321 : 		{	// destroy the element at _Where and reconstruct from _Arg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1322 : 		_TRY_BEGIN
; 1323 : 		this->_Getal().destroy(

  0002e	8b 75 08	 mov	 esi, DWORD PTR __Where$[ebp]
  00031	83 c6 08	 add	 esi, 8
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003b	8b ce		 mov	 ecx, esi
  0003d	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ

; 1324 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1325 : 		this->_Getal().construct(

  00042	89 75 e8	 mov	 DWORD PTR $T3[ebp], esi
  00045	89 75 e4	 mov	 DWORD PTR $T2[ebp], esi
  00048	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0004c	85 f6		 test	 esi, esi
  0004e	74 0a		 je	 SHORT $LN59@Reusenode
  00050	ff 75 0c	 push	 DWORD PTR __Arg$[ebp]
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ??0Partition@GostCrypt@@QAE@ABU01@@Z
$LN59@Reusenode:

; 1336 : 		_CATCH_END
; 1337 : 		}

  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 08 00	 ret	 8
__catch$??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z$0:

; 1326 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1327 : 			_STD forward<_TArg>(_Arg));
; 1328 : 		_CATCH_ALL
; 1329 : 		_Unlinknode(_Where);

  0006e	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00071	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00074	8b 02		 mov	 eax, DWORD PTR [edx]
  00076	89 01		 mov	 DWORD PTR [ecx], eax
  00078	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0007a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00080	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]

; 1330 : 		this->_Getal().destroy(
; 1331 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1332 : 		this->_Getal().destroy(
; 1333 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1334 : 		this->_Getal().deallocate(_Where._Ptr, 1);

  00083	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  00086	ff 48 04	 dec	 DWORD PTR [eax+4]
  00089	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0008e	83 c4 04	 add	 esp, 4

; 1335 : 		_RERAISE;

  00091	6a 00		 push	 0
  00093	6a 00		 push	 0
  00095	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN153@Reusenode:
$LN152@Reusenode:
  0009a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z$12:
  00000	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  00003	50		 push	 eax
  00004	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Reusenode<GostCrypt::Partition const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8U?$_List_node@UPartition@GostCrypt@@PAX@std@@U01@@std@@YA_NABV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8U?$_List_node@UPartition@GostCrypt@@PAX@std@@U01@@std@@YA_NABV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@0@0@Z PROC ; std::operator==<std::_List_node<GostCrypt::Partition,void *>,std::_List_node<GostCrypt::Partition,void *> >, COMDAT

; 796  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 797  : 	}

  00002	c3		 ret	 0
??$?8U?$_List_node@UPartition@GostCrypt@@PAX@std@@U01@@std@@YA_NABV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@0@0@Z ENDP ; std::operator==<std::_List_node<GostCrypt::Partition,void *>,std::_List_node<GostCrypt::Partition,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@0@Z PROC ; std::operator==<std::allocator<std::_List_node<GostCrypt::Partition,void *> >,std::allocator<std::_List_node<GostCrypt::Partition,void *> > >, COMDAT

; 1017 : 	return (static_cast<const _Ty&>(_Left)

  00000	b0 01		 mov	 al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@0@Z ENDP ; std::operator==<std::allocator<std::_List_node<GostCrypt::Partition,void *> >,std::allocator<std::_List_node<GostCrypt::Partition,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z
_TEXT	SEGMENT
$T2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T3 = 8							; size = 4
__Next$ = 8						; size = 4
__Pnode$ = 12						; size = 4
__Prev$ = 12						; size = 4
_<_Val_0>$ = 16						; size = 4
??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z PROC ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Buynode<GostCrypt::Partition const &>, COMDAT
; _this$ = ecx

; 831  : 		{	// allocate a node and set links and value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 832  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);

  0002b	ff 75 0c	 push	 DWORD PTR __Prev$[ebp]
  0002e	ff 75 08	 push	 DWORD PTR __Next$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Buynode0
  00036	8b f0		 mov	 esi, eax

; 833  : 
; 834  : 		_TRY_BEGIN

  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003f	89 75 0c	 mov	 DWORD PTR __Pnode$[ebp], esi

; 835  : 		this->_Getal().construct(

  00042	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00045	89 4d 08	 mov	 DWORD PTR $T3[ebp], ecx
  00048	89 4d ec	 mov	 DWORD PTR $T2[ebp], ecx
  0004b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0004f	85 c9		 test	 ecx, ecx
  00051	74 08		 je	 SHORT $LN36@Buynode
  00053	ff 75 10	 push	 DWORD PTR _<_Val_0>$[ebp]
  00056	e8 00 00 00 00	 call	 ??0Partition@GostCrypt@@QAE@ABU01@@Z
$LN36@Buynode:

; 841  : 		_CATCH_END
; 842  : 
; 843  : 		return (_Pnode);

  0005b	8b c6		 mov	 eax, esi

; 844  : 		}

  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00060	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00067	59		 pop	 ecx
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 0c 00	 ret	 12			; 0000000cH
__catch$??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z$0:

; 836  : 			_STD addressof(this->_Myval(_Pnode)),
; 837  : 				_STD forward<_Valty>(_Val)...);
; 838  : 		_CATCH_ALL
; 839  : 		this->_Getal().deallocate(_Pnode, 1);

  00071	ff 75 0c	 push	 DWORD PTR __Pnode$[ebp]
  00074	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00079	83 c4 04	 add	 esp, 4

; 840  : 		_RERAISE;

  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN67@Buynode:
$LN66@Buynode:
  00085	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z$8:
  00000	8b 45 08	 mov	 eax, DWORD PTR $T3[ebp]
  00003	50		 push	 eax
  00004	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z ENDP ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Buynode<GostCrypt::Partition const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABUPartition@GostCrypt@@@std@@YAABUPartition@GostCrypt@@ABU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUPartition@GostCrypt@@@std@@YAABUPartition@GostCrypt@@ABU12@@Z PROC ; std::forward<GostCrypt::Partition const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUPartition@GostCrypt@@@std@@YAABUPartition@GostCrypt@@ABU12@@Z ENDP ; std::forward<GostCrypt::Partition const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 142  : 			return (_Ok);

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 143  : 			}

  00003	c3		 ret	 0
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 130  : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

  00025	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  0002a	84 c0		 test	 al, al
  0002c	75 07		 jne	 SHORT $LN2@sentry

; 133  : 				this->_Myostr._Osfx();

  0002e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00030	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN2@sentry:

; 134  : 
; 135  :  #else /* _HAS_EXCEPTIONS */
; 136  : 			this->_Myostr._Osfx();
; 137  :  #endif /* _HAS_EXCEPTIONS */
; 138  : 			}

  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00040	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00043	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  00047	85 c9		 test	 ecx, ecx
  00049	74 05		 je	 SHORT $LN5@sentry
  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@sentry:
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 123  : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi

; 122  : 			: _Sentry_base(_Ostr)

  0002a	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  0002d	89 37		 mov	 DWORD PTR [edi], esi
  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00038	85 c9		 test	 ecx, ecx
  0003a	74 05		 je	 SHORT $LN6@sentry
  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	ff 50 04	 call	 DWORD PTR [eax+4]
$LN6@sentry:

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00041	8b 06		 mov	 eax, DWORD PTR [esi]
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004d	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  00052	75 11		 jne	 SHORT $LN2@sentry
  00054	8b 4c 30 3c	 mov	 ecx, DWORD PTR [eax+esi+60]
  00058	85 c9		 test	 ecx, ecx
  0005a	74 09		 je	 SHORT $LN2@sentry
  0005c	3b ce		 cmp	 ecx, esi
  0005e	74 05		 je	 SHORT $LN2@sentry

; 125  : 				_Ostr.tie()->flush();

  00060	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
$LN2@sentry:

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006a	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  0006f	0f 94 c0	 sete	 al
  00072	88 47 04	 mov	 BYTE PTR [edi+4], al

; 127  : 			}

  00075	8b c7		 mov	 eax, edi
  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 106  : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 107  : 			if (_Myostr.rdbuf() != 0)

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 05		 je	 SHORT $LN2@Sentry_bas

; 108  : 				_Myostr.rdbuf()->_Unlock();

  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 109  : 			}

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 100  : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   : 			: _Myostr(_Ostr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00006	56		 push	 esi

; 100  : 			{	// lock the stream buffer, if there

  00007	8b f1		 mov	 esi, ecx
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 101  : 			if (_Myostr.rdbuf() != 0)

  0000b	8b 02		 mov	 eax, DWORD PTR [edx]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  00014	85 c9		 test	 ecx, ecx
  00016	74 05		 je	 SHORT $LN8@Sentry_bas

; 102  : 				_Myostr.rdbuf()->_Lock();

  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	ff 50 04	 call	 DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 103  : 			}

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ@YAXXZ
text$yd	SEGMENT
??__F_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ@YAXXZ PROC ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::`dynamic atexit destructor for '_Static'', COMDAT
  00000	c3		 ret	 0
??__F_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ@YAXXZ ENDP ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::`dynamic atexit destructor for '_Static''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??1?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ PROC ; std::_Immortalizer<std::_Iostream_error_category>::~_Immortalizer<std::_Iostream_error_category>, COMDAT
; _this$ = ecx

; 687  : 		}

  00000	c3		 ret	 0
??1?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ ENDP ; std::_Immortalizer<std::_Iostream_error_category>::~_Immortalizer<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ PROC ; std::_Immortalizer<std::_Iostream_error_category>::_Immortalizer<std::_Iostream_error_category>, COMDAT
; _this$ = ecx

; 683  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	85 c9		 test	 ecx, ecx
  00004	74 0d		 je	 SHORT $LN3@Immortaliz

; 681  : 		{	// construct _Ty inside _Storage
; 682  : 		::new (static_cast<void *>(&_Storage)) _Ty();

  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Iostream_error_category@std@@6B@
  0000c	c7 41 04 05 00
	00 00		 mov	 DWORD PTR [ecx+4], 5
$LN3@Immortaliz:

; 683  : 		}

  00013	c3		 ret	 0
??0?$_Immortalizer@V_Iostream_error_category@std@@@std@@QAE@XZ ENDP ; std::_Immortalizer<std::_Iostream_error_category>::_Immortalizer<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<wchar_t> >, COMDAT

; 553  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 554  :  #if _NO_LOCALES
; 555  : 	static _Wrap_facet<_Facet> _Wfac;
; 556  : 	return (*(_Facet *)&_Wfac);
; 557  : 
; 558  :  #else /* _NO_LOCALES */
; 559  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 560  : 		const locale::facet *_Psave =
; 561  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 562  : 
; 563  : 		size_t _Id = _Facet::id;

  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$ctype@_W@std@@2V0locale@2@A ; std::ctype<wchar_t>::id
  00038	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	89 5d f0	 mov	 DWORD PTR __Psave$5[ebp], ebx
  00048	85 ff		 test	 edi, edi
  0004a	75 2f		 jne	 SHORT $LN11@use_facet
  0004c	57		 push	 edi
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$ctype@_W@std@@2V0locale@2@A, edi ; std::ctype<wchar_t>::id
  0005b	75 10		 jne	 SHORT $LN12@use_facet
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00062	40		 inc	 eax
  00063	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$ctype@_W@std@@2V0locale@2@A, eax ; std::ctype<wchar_t>::id
$LN12@use_facet:
  0006d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00070	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00075	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$ctype@_W@std@@2V0locale@2@A ; std::ctype<wchar_t>::id
$LN11@use_facet:

; 564  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0007e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00081	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00084	73 0c		 jae	 SHORT $LN20@use_facet
  00086	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00089	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  0008c	85 f6		 test	 esi, esi
  0008e	75 77		 jne	 SHORT $LN7@use_facet
  00090	eb 02		 jmp	 SHORT $LN28@use_facet
$LN20@use_facet:
  00092	33 f6		 xor	 esi, esi
$LN28@use_facet:
  00094	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00098	74 10		 je	 SHORT $LN17@use_facet
  0009a	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009f	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000a2	73 0a		 jae	 SHORT $LN29@use_facet
  000a4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a7	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN17@use_facet:

; 565  : 
; 566  : 		if (_Pf != 0)

  000aa	85 f6		 test	 esi, esi
  000ac	75 59		 jne	 SHORT $LN7@use_facet
$LN29@use_facet:

; 567  : 			;	// got facet from locale
; 568  : 		else if (_Psave != 0)

  000ae	85 db		 test	 ebx, ebx
  000b0	74 04		 je	 SHORT $LN4@use_facet

; 569  : 			_Pf = _Psave;	// lazy facet already allocated

  000b2	8b f3		 mov	 esi, ebx
  000b4	eb 51		 jmp	 SHORT $LN7@use_facet
$LN4@use_facet:

; 570  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000b6	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  000b9	8d 45 f0	 lea	 eax, DWORD PTR __Psave$5[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<wchar_t>::_Getcat
  000c2	83 c4 08	 add	 esp, 8
  000c5	83 f8 ff	 cmp	 eax, -1
  000c8	75 24		 jne	 SHORT $LN6@use_facet

; 571  : 
; 572  :  #if _HAS_EXCEPTIONS
; 573  : 
; 574  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000ca	0f 57 c0	 xorps	 xmm0, xmm0
  000cd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7bad_cast@std@@6B@
  000d4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000d9	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  000dc	66 0f d6 45 e0	 movq	 QWORD PTR $T2[ebp+4], xmm0
  000e1	50		 push	 eax
  000e2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@use_facet:
$LN6@use_facet:

; 575  : 
; 576  :  #else /* _HAS_EXCEPTIONS */
; 577  : 			abort();	// lazy disallowed
; 578  :  #endif /* _HAS_EXCEPTIONS */
; 579  : 
; 580  : 		else
; 581  : 			{	// queue up lazy facet for destruction
; 582  : 			_Pf = _Psave;

  000ee	8b 75 f0	 mov	 esi, DWORD PTR __Psave$5[ebp]

; 583  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 584  : 
; 585  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 586  : 			_Pfmod->_Incref();

  000f1	8b ce		 mov	 ecx, esi
  000f3	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
  000f9	8b 16		 mov	 edx, DWORD PTR [esi]
  000fb	ff 52 04	 call	 DWORD PTR [edx+4]

; 587  : 
; 588  :  #if defined(_M_CEE)
; 589  : 			_Facet_Register_m(_Pfmod);
; 590  : 
; 591  :  #else /* defined(_M_CEE) */
; 592  : 			_Facet_Register(_Pfmod);

  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  00104	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 593  :  #endif /* defined(_M_CEE) */
; 594  : 			}
; 595  : 
; 596  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00107	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0010a	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0010f	8b c6		 mov	 eax, esi

; 597  : 	_END_LOCK()
; 598  :  #endif /* _NO_LOCALES */
; 599  : 	}	// end of use_facet body

  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN31@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::construct<std::_List_node<GostCrypt::Partition,void *> *,std::_List_node<GostCrypt::Partition,void *> * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::construct<std::_List_node<GostCrypt::Partition,void *> *,std::_List_node<GostCrypt::Partition,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z PROC	; std::pointer_traits<char *>::pointer_to, COMDAT

; 279  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 		return (_STD addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 281  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ENDP	; std::pointer_traits<char *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@UPartition@GostCrypt@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@UPartition@GostCrypt@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::destroy<GostCrypt::Partition>, COMDAT
; _this$ = ecx

; 1002 : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1003 : 		_Mytraits::destroy(*this, _Ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ

; 1004 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??$destroy@UPartition@GostCrypt@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAUPartition@GostCrypt@@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::destroy<GostCrypt::Partition>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@UPartition@GostCrypt@@@std@@YAPAUPartition@GostCrypt@@AAU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UPartition@GostCrypt@@@std@@YAPAUPartition@GostCrypt@@AAU12@@Z PROC ; std::addressof<GostCrypt::Partition>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UPartition@GostCrypt@@@std@@YAPAUPartition@GostCrypt@@AAU12@@Z ENDP ; std::addressof<GostCrypt::Partition>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 281  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::destroy<std::_List_node<GostCrypt::Partition,void *> *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@UPartition@GostCrypt@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::destroy<std::_List_node<GostCrypt::Partition,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@YAPAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@YAPAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<GostCrypt::Partition,void *> *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@YAPAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<GostCrypt::Partition,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0ABV?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0ABV?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::allocator<wchar_t> const &,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0ABV?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::allocator<wchar_t> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 995  : 		_Mytraits::construct(*this, _Ptr,

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@_W@std@@YAPA_WPA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 739  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 740  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@_W@std@@YAPA_WPA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z PROC		; std::addressof<wchar_t *>, COMDAT

; 724  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 726  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z ENDP		; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 281  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1044 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1045 : 	_Pocca(_Left, _Right, _Tag);
; 1046 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1063 : 	typename _Alty::propagate_on_container_move_assignment _Tag;
; 1064 : 	_Pocma(_Left, _Right, _Tag);
; 1065 : 	}

  00000	c3		 ret	 0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT
; _this$ = ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 281  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1044 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1045 : 	_Pocca(_Left, _Right, _Tag);
; 1046 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAV?$allocator@_W@1@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAV?$allocator@_W@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$swap@IX@std@@YAXAAI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@IX@std@@YAXAAI0@Z PROC				; std::swap<unsigned int,void>, COMDAT

; 48   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_Ty _Tmp = _STD move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 50   : 	_Left = _STD move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 51   : 	_Right = _STD move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 52   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@IX@std@@YAXAAI0@Z ENDP				; std::swap<unsigned int,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$swap@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@X@std@@YAXAAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@X@std@@YAXAAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@0@Z PROC ; std::swap<std::_List_node<GostCrypt::Partition,void *> *,void>, COMDAT

; 48   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	_Ty _Tmp = _STD move(_Left);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 50   : 	_Left = _STD move(_Right);

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax

; 51   : 	_Right = _STD move(_Tmp);

  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 52   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@X@std@@YAXAAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@0@Z ENDP ; std::swap<std::_List_node<GostCrypt::Partition,void *> *,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$_Swap_adl@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@YAXAAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@YAXAAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@0@Z PROC ; std::_Swap_adl<std::_List_node<GostCrypt::Partition,void *> *>, COMDAT

; 58   : 	{	// exchange values stored at _Left and _Right, using ADL

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 59   : 	swap(_Left, _Right);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	89 02		 mov	 DWORD PTR [edx], eax
  00010	89 31		 mov	 DWORD PTR [ecx], esi
  00012	5e		 pop	 esi

; 60   : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Swap_adl@PAU?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@YAXAAPAU?$_List_node@UPartition@GostCrypt@@PAX@0@0@Z ENDP ; std::_Swap_adl<std::_List_node<GostCrypt::Partition,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > > >, COMDAT

; 1044 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1045 : 	_Pocca(_Left, _Right, _Tag);
; 1046 : 	}

  00000	c3		 ret	 0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAE@$$QAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAE@$$QAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > ><std::allocator<std::_List_node<GostCrypt::Partition,void *> > >, COMDAT
; _this$ = ecx

; 953  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAE@$$QAV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > ><std::allocator<std::_List_node<GostCrypt::Partition,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$numpunct@D@std@@MAEPAXI@Z PROC			; std::numpunct<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 76 08	 push	 DWORD PTR [esi+8]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
  0000f	e8 00 00 00 00	 call	 _free
  00014	ff 76 10	 push	 DWORD PTR [esi+16]
  00017	e8 00 00 00 00	 call	 _free
  0001c	ff 76 14	 push	 DWORD PTR [esi+20]
  0001f	e8 00 00 00 00	 call	 _free
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00031	74 0b		 je	 SHORT $LN15@scalar
  00033	6a 18		 push	 24			; 00000018H
  00035	56		 push	 esi
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	83 c4 08	 add	 esp, 8
$LN15@scalar:
  0003e	8b c6		 mov	 eax, esi
  00040	5e		 pop	 esi
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
??_G?$numpunct@D@std@@MAEPAXI@Z ENDP			; std::numpunct<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Tidy@?$numpunct@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$numpunct@D@std@@AAEXXZ PROC			; std::numpunct<char>::_Tidy, COMDAT
; _this$ = ecx

; 257  : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 258  : 		_CSTD free((void *)_Grouping);

  00003	ff 76 08	 push	 DWORD PTR [esi+8]
  00006	e8 00 00 00 00	 call	 _free

; 259  : 		_CSTD free((void *)_Falsename);

  0000b	ff 76 10	 push	 DWORD PTR [esi+16]
  0000e	e8 00 00 00 00	 call	 _free

; 260  : 		_CSTD free((void *)_Truename);

  00013	ff 76 14	 push	 DWORD PTR [esi+20]
  00016	e8 00 00 00 00	 call	 _free
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001e	5e		 pop	 esi

; 261  : 		}

  0001f	c3		 ret	 0
?_Tidy@?$numpunct@D@std@@AAEXXZ ENDP			; std::numpunct<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_truename, COMDAT
; _this$ = ecx

; 251  : 		{	// return name for true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 252  : 		return (string_type(_Truename));

  00004	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00020	c6 06 00	 mov	 BYTE PTR [esi], 0
  00023	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00026	75 14		 jne	 SHORT $LN115@do_truenam
  00028	33 c9		 xor	 ecx, ecx
  0002a	51		 push	 ecx
  0002b	52		 push	 edx
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi

; 253  : 		}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4

; 252  : 		return (string_type(_Truename));

$LN115@do_truenam:
  0003c	8b ca		 mov	 ecx, edx
  0003e	57		 push	 edi
  0003f	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL117@do_truenam:
  00042	8a 01		 mov	 al, BYTE PTR [ecx]
  00044	41		 inc	 ecx
  00045	84 c0		 test	 al, al
  00047	75 f9		 jne	 SHORT $LL117@do_truenam
  00049	2b cf		 sub	 ecx, edi
  0004b	5f		 pop	 edi
  0004c	51		 push	 ecx
  0004d	52		 push	 edx
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi

; 253  : 		}

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_truename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_falsename, COMDAT
; _this$ = ecx

; 246  : 		{	// return name for false

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 247  : 		return (string_type(_Falsename));

  00004	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00020	c6 06 00	 mov	 BYTE PTR [esi], 0
  00023	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00026	75 14		 jne	 SHORT $LN115@do_falsena
  00028	33 c9		 xor	 ecx, ecx
  0002a	51		 push	 ecx
  0002b	52		 push	 edx
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi

; 248  : 		}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4

; 247  : 		return (string_type(_Falsename));

$LN115@do_falsena:
  0003c	8b ca		 mov	 ecx, edx
  0003e	57		 push	 edi
  0003f	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL117@do_falsena:
  00042	8a 01		 mov	 al, BYTE PTR [ecx]
  00044	41		 inc	 ecx
  00045	84 c0		 test	 al, al
  00047	75 f9		 jne	 SHORT $LL117@do_falsena
  00049	2b cf		 sub	 ecx, edi
  0004b	5f		 pop	 edi
  0004c	51		 push	 ecx
  0004d	52		 push	 edx
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi

; 248  : 		}

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_falsename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_grouping, COMDAT
; _this$ = ecx

; 241  : 		{	// return grouping string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 242  : 		return (string(_Grouping));

  00004	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00019	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00020	c6 06 00	 mov	 BYTE PTR [esi], 0
  00023	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00026	75 14		 jne	 SHORT $LN115@do_groupin
  00028	33 c9		 xor	 ecx, ecx
  0002a	51		 push	 ecx
  0002b	52		 push	 edx
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi

; 243  : 		}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4

; 242  : 		return (string(_Grouping));

$LN115@do_groupin:
  0003c	8b ca		 mov	 ecx, edx
  0003e	57		 push	 edi
  0003f	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL117@do_groupin:
  00042	8a 01		 mov	 al, BYTE PTR [ecx]
  00044	41		 inc	 ecx
  00045	84 c0		 test	 al, al
  00047	75 f9		 jne	 SHORT $LL117@do_groupin
  00049	2b cf		 sub	 ecx, edi
  0004b	5f		 pop	 edi
  0004c	51		 push	 ecx
  0004d	52		 push	 edx
  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi

; 243  : 		}

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_grouping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_thousands_sep, COMDAT
; _this$ = ecx

; 237  : 		return (_Kseparator);

  00000	8a 41 0d	 mov	 al, BYTE PTR [ecx+13]

; 238  : 		}

  00003	c3		 ret	 0
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_decimal_point@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_decimal_point, COMDAT
; _this$ = ecx

; 232  : 		return (_Dp);

  00000	8a 41 0c	 mov	 al, BYTE PTR [ecx+12]

; 233  : 		}

  00003	c3		 ret	 0
?do_decimal_point@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
_TEXT	SEGMENT
$T2 = -68						; size = 44
$T3 = -68						; size = 44
__Ptr$1$ = -24						; size = 4
_this$GSCopy$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Lobj$ = 8						; size = 4
__Isdef$ = 12						; size = 1
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z PROC	; std::numpunct<char>::_Init, COMDAT
; _this$ = ecx

; 202  : 		{	// initialize from _Lobj

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d ec	 mov	 DWORD PTR _this$GSCopy$[ebp], ebx

; 203  : 		const lconv *_Ptr = _Lobj._Getlconv();

  00030	e8 00 00 00 00	 call	 _localeconv
  00035	8b f0		 mov	 esi, eax

; 204  : 		_Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();	// conversion information

  00037	8d 45 bc	 lea	 eax, DWORD PTR $T3[ebp]
  0003a	50		 push	 eax
  0003b	89 75 e8	 mov	 DWORD PTR __Ptr$1$[ebp], esi
  0003e	e8 00 00 00 00	 call	 __Getcvt
  00043	83 c4 04	 add	 esp, 4

; 205  : 
; 206  : 		_Grouping = 0;

  00046	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 207  : 		_Falsename = 0;
; 208  : 		_Truename = 0;
; 209  : 
; 210  : 		_TRY_BEGIN
; 211  : 		_Grouping = _MAKLOCSTR(char, _Isdef ? "" : _Ptr->grouping,

  0004d	80 7d 0c 00	 cmp	 BYTE PTR __Isdef$[ebp], 0
  00051	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
  00058	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0
  0005f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00066	74 07		 je	 SHORT $LN6@Init
  00068	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0006d	eb 03		 jmp	 SHORT $LN7@Init
$LN6@Init:
  0006f	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
$LN7@Init:
  00072	8d 45 bc	 lea	 eax, DWORD PTR $T2[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 __Getcvt
  0007b	8b fe		 mov	 edi, esi
  0007d	83 c4 04	 add	 esp, 4
  00080	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL63@Init:
  00083	8a 07		 mov	 al, BYTE PTR [edi]
  00085	47		 inc	 edi
  00086	84 c0		 test	 al, al
  00088	75 f9		 jne	 SHORT $LL63@Init
  0008a	2b f9		 sub	 edi, ecx
  0008c	47		 inc	 edi
  0008d	6a 01		 push	 1
  0008f	57		 push	 edi
  00090	e8 00 00 00 00	 call	 _calloc
  00095	8b d0		 mov	 edx, eax
  00097	83 c4 08	 add	 esp, 8
  0009a	85 d2		 test	 edx, edx
  0009c	75 05		 jne	 SHORT $LN22@Init
  0009e	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN66@Init:
$LN22@Init:
  000a3	85 ff		 test	 edi, edi
  000a5	74 17		 je	 SHORT $LN20@Init
  000a7	8b ca		 mov	 ecx, edx
  000a9	2b ce		 sub	 ecx, esi
  000ab	0f 1f 44 00 00	 npad	 5
$LL21@Init:
  000b0	8a 06		 mov	 al, BYTE PTR [esi]
  000b2	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  000b5	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  000b9	83 ef 01	 sub	 edi, 1
  000bc	75 f2		 jne	 SHORT $LL21@Init
$LN20@Init:

; 212  : 			_Lobj._Getcvt());
; 213  : 		_Falsename = _MAKLOCSTR(_Elem, _Lobj._Getfalse(), _Cvt);

  000be	bf 06 00 00 00	 mov	 edi, 6
  000c3	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  000c6	6a 01		 push	 1
  000c8	57		 push	 edi
  000c9	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_05LAPONLG@false?$AA@
  000ce	e8 00 00 00 00	 call	 _calloc
  000d3	8b d0		 mov	 edx, eax
  000d5	83 c4 08	 add	 esp, 8
  000d8	85 d2		 test	 edx, edx
  000da	75 05		 jne	 SHORT $LN31@Init
  000dc	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN67@Init:
$LN31@Init:
  000e1	8b ca		 mov	 ecx, edx
  000e3	81 e9 00 00 00
	00		 sub	 ecx, OFFSET ??_C@_05LAPONLG@false?$AA@
  000e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL30@Init:
  000f0	8a 06		 mov	 al, BYTE PTR [esi]
  000f2	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  000f5	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  000f9	83 ef 01	 sub	 edi, 1
  000fc	75 f2		 jne	 SHORT $LL30@Init

; 214  : 		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Cvt);

  000fe	bf 05 00 00 00	 mov	 edi, 5
  00103	89 53 10	 mov	 DWORD PTR [ebx+16], edx
  00106	6a 01		 push	 1
  00108	57		 push	 edi
  00109	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_04LOAJBDKD@true?$AA@
  0010e	e8 00 00 00 00	 call	 _calloc
  00113	8b d0		 mov	 edx, eax
  00115	83 c4 08	 add	 esp, 8
  00118	85 d2		 test	 edx, edx
  0011a	75 16		 jne	 SHORT $LN39@Init
  0011c	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN68@Init:
__catch$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0:

; 215  : 		_CATCH_ALL
; 216  : 		_Tidy();

  00121	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00124	e8 00 00 00 00	 call	 ?_Tidy@?$numpunct@D@std@@AAEXXZ ; std::numpunct<char>::_Tidy

; 217  : 		_RERAISE;

  00129	6a 00		 push	 0
  0012b	6a 00		 push	 0
  0012d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN69@Init:

; 214  : 		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Cvt);

$LN39@Init:
  00132	8b ca		 mov	 ecx, edx
  00134	81 e9 00 00 00
	00		 sub	 ecx, OFFSET ??_C@_04LOAJBDKD@true?$AA@
  0013a	66 0f 1f 44 00
	00		 npad	 6
$LL38@Init:
  00140	8a 06		 mov	 al, BYTE PTR [esi]
  00142	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00145	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  00149	83 ef 01	 sub	 edi, 1
  0014c	75 f2		 jne	 SHORT $LL38@Init

; 218  : 		_CATCH_END
; 219  : 
; 220  : 		if (_Isdef)

  0014e	80 7d 0c 00	 cmp	 BYTE PTR __Isdef$[ebp], 0
  00152	89 53 14	 mov	 DWORD PTR [ebx+20], edx
  00155	74 1a		 je	 SHORT $LN3@Init

; 221  : 			{	// apply defaults for required facets
; 222  : //			_Grouping = _MAKLOCSTR(char, "", _Cvt);
; 223  : 			_Dp = _MAKLOCCHR(_Elem, '.', _Cvt);

  00157	66 c7 43 0c 2e
	2c		 mov	 WORD PTR [ebx+12], 11310 ; 00002c2eH

; 228  : 		}

  0015d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00160	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00167	59		 pop	 ecx
  00168	5f		 pop	 edi
  00169	5e		 pop	 esi
  0016a	5b		 pop	 ebx
  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c2 08 00	 ret	 8
$LN3@Init:

; 224  : 			_Kseparator = _MAKLOCCHR(_Elem, ',', _Cvt);
; 225  : 			}
; 226  : 		else
; 227  : 			_Getvals((_Elem)0, _Ptr, _Cvt);

  00171	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$1$[ebp]
  00174	8b 01		 mov	 eax, DWORD PTR [ecx]
  00176	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00179	88 43 0c	 mov	 BYTE PTR [ebx+12], al
  0017c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0017f	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00182	88 43 0d	 mov	 BYTE PTR [ebx+13], al

; 228  : 		}

  00185	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00188	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0018f	59		 pop	 ecx
  00190	5f		 pop	 edi
  00191	5e		 pop	 esi
  00192	5b		 pop	 ebx
  00193	8b e5		 mov	 esp, ebp
  00195	5d		 pop	 ebp
  00196	c2 08 00	 ret	 8
$LN65@Init:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ENDP	; std::numpunct<char>::_Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$numpunct@D@std@@MAE@XZ PROC			; std::numpunct<char>::~numpunct<char>, COMDAT
; _this$ = ecx

; 175  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 176  : 		_Tidy();

  00003	ff 76 08	 push	 DWORD PTR [esi+8]
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
  0000c	e8 00 00 00 00	 call	 _free
  00011	ff 76 10	 push	 DWORD PTR [esi+16]
  00014	e8 00 00 00 00	 call	 _free
  00019	ff 76 14	 push	 DWORD PTR [esi+20]
  0001c	e8 00 00 00 00	 call	 _free
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 177  : 		}

  00024	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002a	5e		 pop	 esi
  0002b	c3		 ret	 0
??1?$numpunct@D@std@@MAE@XZ ENDP			; std::numpunct<char>::~numpunct<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 52
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::numpunct<char>::_Getcat, COMDAT

; 166  : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	33 db		 xor	 ebx, ebx
  0002a	89 5d f0	 mov	 DWORD PTR $T3[ebp], ebx

; 167  : 		if (_Ppf != 0 && *_Ppf == 0)

  0002d	8b 7d 08	 mov	 edi, DWORD PTR __Ppf$[ebp]
  00030	85 ff		 test	 edi, edi
  00032	74 76		 je	 SHORT $LN29@Getcat
  00034	39 1f		 cmp	 DWORD PTR [edi], ebx
  00036	75 72		 jne	 SHORT $LN29@Getcat

; 168  : 			*_Ppf = new numpunct<_Elem>(

  00038	6a 18		 push	 24			; 00000018H
  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	8b f0		 mov	 esi, eax
  00041	83 c4 04	 add	 esp, 4
  00044	89 75 08	 mov	 DWORD PTR $T4[ebp], esi
  00047	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0004a	85 f6		 test	 esi, esi
  0004c	74 4b		 je	 SHORT $LN4@Getcat
  0004e	8b 45 0c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00051	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00054	85 c9		 test	 ecx, ecx
  00056	75 07		 jne	 SHORT $LN12@Getcat
  00058	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0005d	eb 0a		 jmp	 SHORT $LN17@Getcat
$LN12@Getcat:
  0005f	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00062	85 c0		 test	 eax, eax
  00064	75 03		 jne	 SHORT $LN17@Getcat
  00066	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
$LN17@Getcat:
  00069	50		 push	 eax
  0006a	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0006d	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00072	bb 01 00 00 00	 mov	 ebx, 1
  00077	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0007e	89 5d f0	 mov	 DWORD PTR $T3[ebp], ebx
  00081	53		 push	 ebx
  00082	50		 push	 eax
  00083	8b ce		 mov	 ecx, esi
  00085	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0008c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
  00092	e8 00 00 00 00	 call	 ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<char>::_Init
  00097	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00099	33 f6		 xor	 esi, esi
$LN5@Getcat:
  0009b	89 37		 mov	 DWORD PTR [edi], esi
  0009d	f6 c3 01	 test	 bl, 1
  000a0	74 08		 je	 SHORT $LN29@Getcat
  000a2	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  000a5	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN29@Getcat:

; 169  : 				_Locinfo(_Ploc->c_str()), 0, true);
; 170  : 		return (_X_NUMERIC);

  000aa	b8 04 00 00 00	 mov	 eax, 4

; 171  : 		}

  000af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b9	59		 pop	 ecx
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 18		 push	 24			; 00000018H
  00002	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	0f 84 0c 00 00
	00		 je	 $LN8@Getcat
  0001b	83 65 f0 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  0001f	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  00022	e9 00 00 00 00	 jmp	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN8@Getcat:
  00027	c3		 ret	 0
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2:
  00028	8b 4d 08	 mov	 ecx, DWORD PTR $T4[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  00030	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00034	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00037	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0003a	33 c8		 xor	 ecx, eax
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00046	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::numpunct<char>::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
__Isdef$ = 16						; size = 1
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z PROC	; std::numpunct<char>::numpunct<char>, COMDAT
; _this$ = ecx

; 160  : 		{	// construct from specified locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 159  : 		: locale::facet(_Refs)

  00029	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  0002c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 161  : 		_Init(_Lobj, _Isdef);

  0002f	ff 75 10	 push	 DWORD PTR __Isdef$[ebp]
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00039	ff 75 08	 push	 DWORD PTR __Lobj$[ebp]
  0003c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
  00042	e8 00 00 00 00	 call	 ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<char>::_Init

; 162  : 		}

  00047	8b c6		 mov	 eax, esi
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	5e		 pop	 esi
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
__ehhandler$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z ENDP	; std::numpunct<char>::numpunct<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::truename, COMDAT
; _this$ = ecx

; 143  : 		{	// return name for true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 144  : 		return (do_truename());

  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00010	ff 52 1c	 call	 DWORD PTR [edx+28]
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 145  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::truename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::falsename, COMDAT
; _this$ = ecx

; 138  : 		{	// return name for false

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 139  : 		return (do_falsename());

  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00010	ff 52 18	 call	 DWORD PTR [edx+24]
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 140  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::falsename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::grouping, COMDAT
; _this$ = ecx

; 133  : 		{	// return grouping string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 134  : 		return (do_grouping());

  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00010	ff 52 14	 call	 DWORD PTR [edx+20]
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 135  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::grouping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?thousands_sep@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?thousands_sep@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::thousands_sep, COMDAT
; _this$ = ecx

; 129  : 		return (do_thousands_sep());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00005	ff e0		 jmp	 eax
?thousands_sep@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?decimal_point@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?decimal_point@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::decimal_point, COMDAT
; _this$ = ecx

; 124  : 		return (do_decimal_point());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00005	ff e0		 jmp	 eax
?decimal_point@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<char> >, COMDAT

; 553  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 554  :  #if _NO_LOCALES
; 555  : 	static _Wrap_facet<_Facet> _Wfac;
; 556  : 	return (*(_Facet *)&_Wfac);
; 557  : 
; 558  :  #else /* _NO_LOCALES */
; 559  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 560  : 		const locale::facet *_Psave =
; 561  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 562  : 
; 563  : 		size_t _Id = _Facet::id;

  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
  00038	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	89 5d f0	 mov	 DWORD PTR __Psave$5[ebp], ebx
  00048	85 ff		 test	 edi, edi
  0004a	75 2f		 jne	 SHORT $LN11@use_facet
  0004c	57		 push	 edi
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, edi ; std::numpunct<char>::id
  0005b	75 10		 jne	 SHORT $LN12@use_facet
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00062	40		 inc	 eax
  00063	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, eax ; std::numpunct<char>::id
$LN12@use_facet:
  0006d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00070	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00075	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
$LN11@use_facet:

; 564  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0007e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00081	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00084	73 0c		 jae	 SHORT $LN20@use_facet
  00086	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00089	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  0008c	85 f6		 test	 esi, esi
  0008e	75 77		 jne	 SHORT $LN7@use_facet
  00090	eb 02		 jmp	 SHORT $LN28@use_facet
$LN20@use_facet:
  00092	33 f6		 xor	 esi, esi
$LN28@use_facet:
  00094	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00098	74 10		 je	 SHORT $LN17@use_facet
  0009a	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009f	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000a2	73 0a		 jae	 SHORT $LN29@use_facet
  000a4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a7	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN17@use_facet:

; 565  : 
; 566  : 		if (_Pf != 0)

  000aa	85 f6		 test	 esi, esi
  000ac	75 59		 jne	 SHORT $LN7@use_facet
$LN29@use_facet:

; 567  : 			;	// got facet from locale
; 568  : 		else if (_Psave != 0)

  000ae	85 db		 test	 ebx, ebx
  000b0	74 04		 je	 SHORT $LN4@use_facet

; 569  : 			_Pf = _Psave;	// lazy facet already allocated

  000b2	8b f3		 mov	 esi, ebx
  000b4	eb 51		 jmp	 SHORT $LN7@use_facet
$LN4@use_facet:

; 570  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000b6	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  000b9	8d 45 f0	 lea	 eax, DWORD PTR __Psave$5[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
  000c2	83 c4 08	 add	 esp, 8
  000c5	83 f8 ff	 cmp	 eax, -1
  000c8	75 24		 jne	 SHORT $LN6@use_facet

; 571  : 
; 572  :  #if _HAS_EXCEPTIONS
; 573  : 
; 574  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000ca	0f 57 c0	 xorps	 xmm0, xmm0
  000cd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7bad_cast@std@@6B@
  000d4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000d9	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  000dc	66 0f d6 45 e0	 movq	 QWORD PTR $T2[ebp+4], xmm0
  000e1	50		 push	 eax
  000e2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@use_facet:
$LN6@use_facet:

; 575  : 
; 576  :  #else /* _HAS_EXCEPTIONS */
; 577  : 			abort();	// lazy disallowed
; 578  :  #endif /* _HAS_EXCEPTIONS */
; 579  : 
; 580  : 		else
; 581  : 			{	// queue up lazy facet for destruction
; 582  : 			_Pf = _Psave;

  000ee	8b 75 f0	 mov	 esi, DWORD PTR __Psave$5[ebp]

; 583  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 584  : 
; 585  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 586  : 			_Pfmod->_Incref();

  000f1	8b ce		 mov	 ecx, esi
  000f3	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::numpunct<char> >::_Psave
  000f9	8b 16		 mov	 edx, DWORD PTR [esi]
  000fb	ff 52 04	 call	 DWORD PTR [edx+4]

; 587  : 
; 588  :  #if defined(_M_CEE)
; 589  : 			_Facet_Register_m(_Pfmod);
; 590  : 
; 591  :  #else /* defined(_M_CEE) */
; 592  : 			_Facet_Register(_Pfmod);

  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  00104	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 593  :  #endif /* defined(_M_CEE) */
; 594  : 			}
; 595  : 
; 596  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00107	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0010a	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0010f	8b c6		 mov	 eax, esi

; 597  : 	_END_LOCK()
; 598  :  #endif /* _NO_LOCALES */
; 599  : 	}	// end of use_facet body

  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN31@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed, COMDAT
; _this$ = ecx

; 662  : 		return (_Failed);

  00000	8a 01		 mov	 al, BYTE PTR [ecx]

; 663  : 		}

  00002	c3		 ret	 0
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 652  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 653  : 		}

  00002	c3		 ret	 0
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 647  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 648  : 		}

  00002	c3		 ret	 0
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 1
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=, COMDAT
; _this$ = ecx

; 637  : 		{	// store element and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 638  : 		if (_Strbuf == 0
; 639  : 			|| traits_type::eq_int_type(_Traits::eof(),

  00006	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00009	85 c9		 test	 ecx, ecx
  0000b	74 37		 je	 SHORT $LN3@operator
  0000d	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00010	83 38 00	 cmp	 DWORD PTR [eax], 0
  00013	74 20		 je	 SHORT $LN7@operator
  00015	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	85 c0		 test	 eax, eax
  0001c	7e 17		 jle	 SHORT $LN7@operator
  0001e	48		 dec	 eax
  0001f	89 02		 mov	 DWORD PTR [edx], eax
  00021	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00024	8b 11		 mov	 edx, DWORD PTR [ecx]
  00026	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00029	89 01		 mov	 DWORD PTR [ecx], eax
  0002b	8a 45 08	 mov	 al, BYTE PTR __Right$[ebp]
  0002e	88 02		 mov	 BYTE PTR [edx], al
  00030	0f b6 c0	 movzx	 eax, al
  00033	eb 0a		 jmp	 SHORT $LN8@operator
$LN7@operator:
  00035	8b 11		 mov	 edx, DWORD PTR [ecx]
  00037	0f b6 45 08	 movzx	 eax, BYTE PTR __Right$[ebp]
  0003b	50		 push	 eax
  0003c	ff 52 0c	 call	 DWORD PTR [edx+12]
$LN8@operator:
  0003f	83 f8 ff	 cmp	 eax, -1
  00042	75 03		 jne	 SHORT $LN28@operator
$LN3@operator:

; 640  : 				_Strbuf->sputc(_Right)))
; 641  : 			_Failed = true;

  00044	c6 06 01	 mov	 BYTE PTR [esi], 1
$LN28@operator:

; 642  : 		return (*this);

  00047	8b c6		 mov	 eax, esi
  00049	5e		 pop	 esi

; 643  : 		}

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
__Sb$ = 8						; size = 4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 628  : 		{	// construct from stream buffer _Sb

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 		: _Failed(false), _Strbuf(_Sb)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Sb$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 629  : 		}

  00009	8b c1		 mov	 eax, ecx
  0000b	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN13@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN13@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ch$ = 24						; size = 1
__Count$ = 28						; size = 4
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep, COMDAT

; 1583 : 		{	// put _Count * _Ch to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1584 : 		for (; 0 < _Count; --_Count, (void)++_Dest)

  00004	8b 75 14	 mov	 esi, DWORD PTR __Dest$[ebp+4]
  00007	57		 push	 edi
  00008	8b 7d 1c	 mov	 edi, DWORD PTR __Count$[ebp]
  0000b	85 ff		 test	 edi, edi
  0000d	74 4a		 je	 SHORT $LN3@Rep
  0000f	53		 push	 ebx
  00010	8a 5d 18	 mov	 bl, BYTE PTR __Ch$[ebp]
$LL4@Rep:

; 1585 : 			*_Dest = _Ch;

  00013	85 f6		 test	 esi, esi
  00015	74 38		 je	 SHORT $LN12@Rep
  00017	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0001a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001d	74 1d		 je	 SHORT $LN16@Rep
  0001f	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	85 c0		 test	 eax, eax
  00026	7e 14		 jle	 SHORT $LN16@Rep
  00028	48		 dec	 eax
  00029	89 01		 mov	 DWORD PTR [ecx], eax
  0002b	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00030	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00033	89 01		 mov	 DWORD PTR [ecx], eax
  00035	88 1a		 mov	 BYTE PTR [edx], bl
  00037	0f b6 c3	 movzx	 eax, bl
  0003a	eb 0b		 jmp	 SHORT $LN17@Rep
$LN16@Rep:
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	8b ce		 mov	 ecx, esi
  00040	0f b6 c3	 movzx	 eax, bl
  00043	50		 push	 eax
  00044	ff 52 0c	 call	 DWORD PTR [edx+12]
$LN17@Rep:
  00047	8b 75 14	 mov	 esi, DWORD PTR __Dest$[ebp+4]
  0004a	83 f8 ff	 cmp	 eax, -1
  0004d	75 04		 jne	 SHORT $LN2@Rep
$LN12@Rep:
  0004f	c6 45 10 01	 mov	 BYTE PTR __Dest$[ebp], 1
$LN2@Rep:

; 1584 : 		for (; 0 < _Count; --_Count, (void)++_Dest)

  00053	83 ef 01	 sub	 edi, 1
  00056	75 bb		 jne	 SHORT $LL4@Rep
  00058	5b		 pop	 ebx
$LN3@Rep:

; 1586 : 		return (_Dest);

  00059	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005c	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005f	5f		 pop	 edi
  00060	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00063	89 08		 mov	 DWORD PTR [eax], ecx
  00065	5e		 pop	 esi

; 1587 : 		}

  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
__Ch$1$ = 31						; size = 1
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put, COMDAT

; 1575 : 		{	// put [_Ptr, _Ptr + _Count) to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1576 : 		for (; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)

  00004	8b 75 1c	 mov	 esi, DWORD PTR __Count$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 14	 mov	 edi, DWORD PTR __Dest$[ebp+4]
  0000b	85 f6		 test	 esi, esi
  0000d	74 53		 je	 SHORT $LN3@Put
  0000f	53		 push	 ebx
  00010	8b 5d 18	 mov	 ebx, DWORD PTR __Ptr$[ebp]
$LL4@Put:

; 1577 : 			*_Dest = *_Ptr;

  00013	85 ff		 test	 edi, edi
  00015	74 40		 je	 SHORT $LN12@Put
  00017	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0001a	8a 0b		 mov	 cl, BYTE PTR [ebx]
  0001c	88 4d 1f	 mov	 BYTE PTR __Ch$1$[ebp], cl
  0001f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00022	74 20		 je	 SHORT $LN16@Put
  00024	8b 57 30	 mov	 edx, DWORD PTR [edi+48]
  00027	8b 02		 mov	 eax, DWORD PTR [edx]
  00029	85 c0		 test	 eax, eax
  0002b	7e 17		 jle	 SHORT $LN16@Put
  0002d	48		 dec	 eax
  0002e	89 02		 mov	 DWORD PTR [edx], eax
  00030	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00038	89 01		 mov	 DWORD PTR [ecx], eax
  0003a	8a 45 1f	 mov	 al, BYTE PTR __Ch$1$[ebp]
  0003d	88 02		 mov	 BYTE PTR [edx], al
  0003f	0f b6 c0	 movzx	 eax, al
  00042	eb 0b		 jmp	 SHORT $LN17@Put
$LN16@Put:
  00044	8b 17		 mov	 edx, DWORD PTR [edi]
  00046	0f b6 c1	 movzx	 eax, cl
  00049	8b cf		 mov	 ecx, edi
  0004b	50		 push	 eax
  0004c	ff 52 0c	 call	 DWORD PTR [edx+12]
$LN17@Put:
  0004f	8b 7d 14	 mov	 edi, DWORD PTR __Dest$[ebp+4]
  00052	83 f8 ff	 cmp	 eax, -1
  00055	75 04		 jne	 SHORT $LN2@Put
$LN12@Put:
  00057	c6 45 10 01	 mov	 BYTE PTR __Dest$[ebp], 1
$LN2@Put:

; 1576 : 		for (; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)

  0005b	43		 inc	 ebx
  0005c	83 ee 01	 sub	 esi, 1
  0005f	75 b2		 jne	 SHORT $LL4@Put
  00061	5b		 pop	 ebx
$LN3@Put:

; 1578 : 		return (_Dest);

  00062	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00065	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00068	89 78 04	 mov	 DWORD PTR [eax+4], edi
  0006b	5f		 pop	 edi
  0006c	89 08		 mov	 DWORD PTR [eax], ecx
  0006e	5e		 pop	 esi

; 1579 : 		}

  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT
$T2 = -92						; size = 8
__Iosbase$GSCopy$1$ = -88				; size = 4
___$ReturnUdt$GSCopy$1$ = -84				; size = 4
$T3 = -80						; size = 8
$T4 = -80						; size = 8
$T5 = -80						; size = 8
$T6 = -80						; size = 8
$T7 = -80						; size = 8
$T8 = -80						; size = 8
$T9 = -80						; size = 8
__Dest$3$ = -72						; size = 4
__Ctype_fac$1$ = -72					; size = 4
__Count$GSCopy$2$ = -68					; size = 4
__Buf$GSCopy$1$ = -68					; size = 4
__Punct_fac$1$ = -68					; size = 4
__Kseparator$10 = -68					; size = 1
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput, COMDAT

; 1515 : 		{	// put formatted integer to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 7d 24	 mov	 edi, DWORD PTR __Count$[ebp]
  0002e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00031	8b 75 18	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00034	8b 4d 20	 mov	 ecx, DWORD PTR __Buf$[ebp]
  00037	89 45 ac	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003a	89 75 a8	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], esi
  0003d	89 4d bc	 mov	 DWORD PTR __Buf$GSCopy$1$[ebp], ecx

; 1516 : 		_DEBUG_POINTER(_Dest);
; 1517 : 		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')

  00040	85 ff		 test	 edi, edi
  00042	74 11		 je	 SHORT $LN14@Iput
  00044	8a 01		 mov	 al, BYTE PTR [ecx]
  00046	3c 2b		 cmp	 al, 43			; 0000002bH
  00048	74 04		 je	 SHORT $LN13@Iput
  0004a	3c 2d		 cmp	 al, 45			; 0000002dH
  0004c	75 07		 jne	 SHORT $LN14@Iput
$LN13@Iput:
  0004e	bb 01 00 00 00	 mov	 ebx, 1
  00053	eb 02		 jmp	 SHORT $LN15@Iput
$LN14@Iput:
  00055	33 db		 xor	 ebx, ebx
$LN15@Iput:

; 1518 : 			? 1 : 0;
; 1519 : 		if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
; 1520 : 			&& _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1521 : 			&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))

  00057	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0005a	25 00 0e 00 00	 and	 eax, 3584		; 00000e00H
  0005f	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00064	75 1d		 jne	 SHORT $LN4@Iput
  00066	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  00069	3b c7		 cmp	 eax, edi
  0006b	77 16		 ja	 SHORT $LN4@Iput
  0006d	80 3c 19 30	 cmp	 BYTE PTR [ecx+ebx], 48	; 00000030H
  00071	75 10		 jne	 SHORT $LN4@Iput
  00073	8a 4c 19 01	 mov	 cl, BYTE PTR [ecx+ebx+1]
  00077	80 f9 78	 cmp	 cl, 120			; 00000078H
  0007a	74 05		 je	 SHORT $LN5@Iput
  0007c	80 f9 58	 cmp	 cl, 88			; 00000058H
  0007f	75 02		 jne	 SHORT $LN4@Iput
$LN5@Iput:

; 1522 : 			_Prefix += 2;

  00081	8b d8		 mov	 ebx, eax
$LN4@Iput:

; 1523 : 
; 1524 : 		const ctype<_Elem>& _Ctype_fac =

  00083	8d 45 b0	 lea	 eax, DWORD PTR $T9[ebp]
  00086	8b ce		 mov	 ecx, esi
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  0008e	50		 push	 eax
  0008f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00096	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 b8	 mov	 DWORD PTR __Ctype_fac$1$[ebp], eax
  000a1	8b 4d b4	 mov	 ecx, DWORD PTR $T9[ebp+4]
  000a4	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000ab	85 c9		 test	 ecx, ecx
  000ad	74 11		 je	 SHORT $LN27@Iput
  000af	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b1	ff 50 08	 call	 DWORD PTR [eax+8]
  000b4	85 c0		 test	 eax, eax
  000b6	74 08		 je	 SHORT $LN27@Iput
  000b8	8b 10		 mov	 edx, DWORD PTR [eax]
  000ba	8b c8		 mov	 ecx, eax
  000bc	6a 01		 push	 1
  000be	ff 12		 call	 DWORD PTR [edx]
$LN27@Iput:

; 1525 : 			_USE(_Iosbase.getloc(), ctype<_Elem>);
; 1526 : 		_Mystr _Groupstring(_Count, _Elem(0));	// reserve space

  000c0	6a 00		 push	 0
  000c2	57		 push	 edi
  000c3	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  000c6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cd	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __Groupstring$[ebp+20], 15 ; 0000000fH
  000d4	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Groupstring$[ebp+16], 0
  000db	c6 45 d8 00	 mov	 BYTE PTR __Groupstring$[ebp], 0
  000df	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1527 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

  000e4	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  000e8	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  000eb	8b 4d bc	 mov	 ecx, DWORD PTR __Buf$GSCopy$1$[ebp]
  000ee	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  000f2	8b 55 b8	 mov	 edx, DWORD PTR __Ctype_fac$1$[ebp]
  000f5	50		 push	 eax
  000f6	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  000f9	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00100	50		 push	 eax
  00101	8b 12		 mov	 edx, DWORD PTR [edx]
  00103	51		 push	 ecx
  00104	8b 4d b8	 mov	 ecx, DWORD PTR __Ctype_fac$1$[ebp]
  00107	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1528 : 
; 1529 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

  0010a	8d 45 b0	 lea	 eax, DWORD PTR $T8[ebp]
  0010d	8b ce		 mov	 ecx, esi
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00115	50		 push	 eax
  00116	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0011a	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
  0011f	8b f0		 mov	 esi, eax
  00121	83 c4 04	 add	 esp, 4
  00124	89 75 bc	 mov	 DWORD PTR __Punct_fac$1$[ebp], esi
  00127	8b 4d b4	 mov	 ecx, DWORD PTR $T8[ebp+4]
  0012a	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0012e	85 c9		 test	 ecx, ecx
  00130	74 11		 je	 SHORT $LN157@Iput
  00132	8b 01		 mov	 eax, DWORD PTR [ecx]
  00134	ff 50 08	 call	 DWORD PTR [eax+8]
  00137	85 c0		 test	 eax, eax
  00139	74 08		 je	 SHORT $LN157@Iput
  0013b	8b 10		 mov	 edx, DWORD PTR [eax]
  0013d	8b c8		 mov	 ecx, eax
  0013f	6a 01		 push	 1
  00141	ff 12		 call	 DWORD PTR [edx]
$LN157@Iput:

; 1530 : 		const string _Grouping = _Punct_fac.grouping();

  00143	8d 45 c0	 lea	 eax, DWORD PTR __Grouping$[ebp]
  00146	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0014a	50		 push	 eax
  0014b	8b ce		 mov	 ecx, esi
  0014d	e8 00 00 00 00	 call	 ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping

; 1531 : 		const char *_Pg = &_Grouping[0];

  00152	83 7d d4 10	 cmp	 DWORD PTR __Grouping$[ebp+20], 16 ; 00000010H
  00156	8d 75 c0	 lea	 esi, DWORD PTR __Grouping$[ebp]
  00159	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0015d	0f 43 75 c0	 cmovae	 esi, DWORD PTR __Grouping$[ebp]

; 1532 : 		if (*_Pg != CHAR_MAX && '\0' < *_Pg)

  00161	8a 06		 mov	 al, BYTE PTR [esi]
  00163	3c 7f		 cmp	 al, 127			; 0000007fH
  00165	74 4b		 je	 SHORT $LN3@Iput
  00167	84 c0		 test	 al, al
  00169	7e 47		 jle	 SHORT $LN3@Iput

; 1533 : 			{	// grouping specified, add thousands separators
; 1534 : 			const _Elem _Kseparator = _Punct_fac.thousands_sep();

  0016b	8b 4d bc	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
  0016e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00170	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00173	ff d0		 call	 eax

; 1535 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1536 : 				&& (size_t)*_Pg < _Count - _Prefix)

  00175	80 3e 7f	 cmp	 BYTE PTR [esi], 127	; 0000007fH
  00178	88 45 bc	 mov	 BYTE PTR __Kseparator$10[ebp], al
  0017b	74 35		 je	 SHORT $LN3@Iput
  0017d	0f 1f 00	 npad	 3
$LL2@Iput:
  00180	8a 06		 mov	 al, BYTE PTR [esi]
  00182	84 c0		 test	 al, al
  00184	7e 2c		 jle	 SHORT $LN3@Iput
  00186	0f be c8	 movsx	 ecx, al
  00189	8b c7		 mov	 eax, edi
  0018b	2b c3		 sub	 eax, ebx
  0018d	3b c8		 cmp	 ecx, eax
  0018f	73 21		 jae	 SHORT $LN3@Iput

; 1537 : 				{	// insert thousands separator
; 1538 : 				_Count -= *_Pg;
; 1539 : 				_Groupstring.insert(_Count, 1, _Kseparator);

  00191	ff 75 bc	 push	 DWORD PTR __Kseparator$10[ebp]
  00194	2b f9		 sub	 edi, ecx
  00196	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00199	6a 01		 push	 1
  0019b	57		 push	 edi
  0019c	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  001a1	80 7e 01 00	 cmp	 BYTE PTR [esi+1], 0

; 1540 : 				if ('\0' < _Pg[1])

  001a5	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  001a8	0f 4e c6	 cmovle	 eax, esi
  001ab	8b f0		 mov	 esi, eax
  001ad	80 3e 7f	 cmp	 BYTE PTR [esi], 127	; 0000007fH
  001b0	75 ce		 jne	 SHORT $LL2@Iput
$LN3@Iput:

; 1541 : 					++_Pg;	// not last group, advance
; 1542 : 				}
; 1543 : 			}
; 1544 : 
; 1545 : 		_Count = _Groupstring.size();
; 1546 : 		size_t _Fillcount = _Iosbase.width() <= 0
; 1547 : 			|| (size_t)_Iosbase.width() <= _Count

  001b2	8b 75 a8	 mov	 esi, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  001b5	8b 45 e8	 mov	 eax, DWORD PTR __Groupstring$[ebp+16]
  001b8	89 45 bc	 mov	 DWORD PTR __Count$GSCopy$2$[ebp], eax
  001bb	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  001bf	7c 13		 jl	 SHORT $LN16@Iput
  001c1	7f 06		 jg	 SHORT $LN470@Iput
  001c3	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  001c7	76 0b		 jbe	 SHORT $LN16@Iput
$LN470@Iput:
  001c9	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  001cc	3b f8		 cmp	 edi, eax
  001ce	76 04		 jbe	 SHORT $LN16@Iput
  001d0	2b f8		 sub	 edi, eax
  001d2	eb 02		 jmp	 SHORT $LN17@Iput
$LN16@Iput:
  001d4	33 ff		 xor	 edi, edi
$LN17@Iput:

; 1548 : 				? 0 : (size_t)_Iosbase.width() - _Count;
; 1549 : 
; 1550 : 		ios_base::fmtflags _Adjustfield =
; 1551 : 			_Iosbase.flags() & ios_base::adjustfield;

  001d6	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001d9	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  001de	83 f8 40	 cmp	 eax, 64			; 00000040H

; 1552 : 		if (_Adjustfield != ios_base::left
; 1553 : 			&& _Adjustfield != ios_base::internal)

  001e1	0f 84 97 00 00
	00		 je	 $LN10@Iput
  001e7	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  001ec	74 48		 je	 SHORT $LN469@Iput

; 1554 : 			{	// put leading fill
; 1555 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

  001ee	57		 push	 edi
  001ef	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  001f2	8d 45 b0	 lea	 eax, DWORD PTR $T7[ebp]
  001f5	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  001f8	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  001fb	50		 push	 eax
  001fc	ff 75 08	 push	 DWORD PTR _this$[ebp]
  001ff	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  00204	8b d0		 mov	 edx, eax

; 1556 : 			_Fillcount = 0;
; 1557 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00206	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00209	33 ff		 xor	 edi, edi
  0020b	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  0020f	53		 push	 ebx
  00210	0f 43 4d d8	 cmovae	 ecx, DWORD PTR __Groupstring$[ebp]
  00214	8b 02		 mov	 eax, DWORD PTR [edx]
  00216	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00219	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0021c	51		 push	 ecx
  0021d	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00220	8d 45 b0	 lea	 eax, DWORD PTR $T6[ebp]
  00223	ff 72 04	 push	 DWORD PTR [edx+4]
  00226	ff 32		 push	 DWORD PTR [edx]
  00228	50		 push	 eax
  00229	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0022c	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  00231	83 c4 30	 add	 esp, 48			; 00000030H
  00234	eb 6a		 jmp	 SHORT $LN474@Iput
$LN469@Iput:

; 1558 : 			}
; 1559 : 		else if (_Adjustfield == ios_base::internal)
; 1560 : 			{	// put internal fill
; 1561 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00236	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  0023a	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0023d	53		 push	 ebx
  0023e	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  00242	50		 push	 eax
  00243	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  00246	8d 45 b0	 lea	 eax, DWORD PTR $T5[ebp]
  00249	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0024c	50		 push	 eax
  0024d	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00250	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  00255	8b c8		 mov	 ecx, eax

; 1562 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

  00257	57		 push	 edi
  00258	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  0025b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0025d	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00260	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00263	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00266	8d 45 b0	 lea	 eax, DWORD PTR $T4[ebp]
  00269	ff 71 04	 push	 DWORD PTR [ecx+4]
  0026c	ff 31		 push	 DWORD PTR [ecx]
  0026e	50		 push	 eax
  0026f	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00272	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  00277	83 c4 30	 add	 esp, 48			; 00000030H

; 1563 : 			_Fillcount = 0;

  0027a	33 ff		 xor	 edi, edi

; 1564 : 			}
; 1565 : 		else

  0027c	eb 22		 jmp	 SHORT $LN474@Iput
$LN10@Iput:

; 1566 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  0027e	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  00282	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  00285	53		 push	 ebx
  00286	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  0028a	50		 push	 eax
  0028b	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  0028e	8d 45 b0	 lea	 eax, DWORD PTR $T3[ebp]
  00291	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00294	50		 push	 eax
  00295	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00298	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  0029d	83 c4 18	 add	 esp, 24			; 00000018H
$LN474@Iput:
  002a0	8b 10		 mov	 edx, DWORD PTR [eax]

; 1567 : 
; 1568 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  002a2	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  002a6	8b 4d bc	 mov	 ecx, DWORD PTR __Count$GSCopy$2$[ebp]
  002a9	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  002ac	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002af	89 45 b8	 mov	 DWORD PTR __Dest$3$[ebp], eax
  002b2	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  002b5	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  002b8	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  002bc	2b cb		 sub	 ecx, ebx
  002be	51		 push	 ecx
  002bf	03 c3		 add	 eax, ebx
  002c1	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  002c4	50		 push	 eax
  002c5	ff 75 b8	 push	 DWORD PTR __Dest$3$[ebp]
  002c8	8d 45 a4	 lea	 eax, DWORD PTR $T2[ebp]
  002cb	52		 push	 edx
  002cc	50		 push	 eax
  002cd	53		 push	 ebx
  002ce	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1569 : 		_Iosbase.width(0);
; 1570 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

  002d3	57		 push	 edi
  002d4	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  002d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d9	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  002dc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002df	50		 push	 eax
  002e0	51		 push	 ecx
  002e1	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  002e8	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  002ef	8b 75 ac	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  002f2	56		 push	 esi
  002f3	53		 push	 ebx
  002f4	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  002f7	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  002fc	8b 45 d4	 mov	 eax, DWORD PTR __Grouping$[ebp+20]
  002ff	83 c4 30	 add	 esp, 48			; 00000030H
  00302	83 f8 10	 cmp	 eax, 16			; 00000010H
  00305	72 0d		 jb	 SHORT $LN270@Iput
  00307	40		 inc	 eax
  00308	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  0030b	50		 push	 eax
  0030c	ff 75 c0	 push	 DWORD PTR __Grouping$[ebp]
  0030f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN270@Iput:
  00314	8b 4d ec	 mov	 ecx, DWORD PTR __Groupstring$[ebp+20]
  00317	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+20], 15 ; 0000000fH
  0031e	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+16], 0
  00325	c6 45 c0 00	 mov	 BYTE PTR __Grouping$[ebp], 0
  00329	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0032c	72 0d		 jb	 SHORT $LN471@Iput
  0032e	41		 inc	 ecx
  0032f	51		 push	 ecx
  00330	ff 75 d8	 push	 DWORD PTR __Groupstring$[ebp]
  00333	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00336	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN471@Iput:
  0033b	8b c6		 mov	 eax, esi

; 1571 : 		}

  0033d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00340	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00347	59		 pop	 ecx
  00348	5f		 pop	 edi
  00349	5e		 pop	 esi
  0034a	5b		 pop	 ebx
  0034b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0034e	33 cd		 xor	 ecx, ebp
  00350	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00355	8b e5		 mov	 esp, ebp
  00357	5d		 pop	 ebp
  00358	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T9[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$4:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1:
  0000e	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$2:
  00016	8d 4d b0	 lea	 ecx, DWORD PTR $T8[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$33:
  0001e	e8 00 00 00 00	 call	 ___std_terminate
  00023	c3		 ret	 0
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$3:
  00024	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00040	33 c8		 xor	 ecx, eax
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
  0004c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 4
__Flags$ = 20						; size = 4
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt, COMDAT

; 1487 : 		{	// generate sprintf format for integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1488 : 		char *_Ptr = _Fmt;
; 1489 : 		*_Ptr++ = '%';
; 1490 : 
; 1491 : 		if (_Flags & ios_base::showpos)

  00003	8b 4d 14	 mov	 ecx, DWORD PTR __Flags$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Fmt$[ebp]
  0000a	57		 push	 edi
  0000b	c6 06 25	 mov	 BYTE PTR [esi], 37	; 00000025H
  0000e	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00011	f6 c1 20	 test	 cl, 32			; 00000020H
  00014	74 04		 je	 SHORT $LN2@Ifmt

; 1492 : 			*_Ptr++ = '+';

  00016	c6 00 2b	 mov	 BYTE PTR [eax], 43	; 0000002bH
  00019	40		 inc	 eax
$LN2@Ifmt:

; 1493 : 		if (_Flags & ios_base::showbase)

  0001a	f6 c1 08	 test	 cl, 8
  0001d	74 04		 je	 SHORT $LN3@Ifmt

; 1494 : 			*_Ptr++ = '#';

  0001f	c6 00 23	 mov	 BYTE PTR [eax], 35	; 00000023H
  00022	40		 inc	 eax
$LN3@Ifmt:

; 1495 : 		if (_Spec[0] != 'L')

  00023	8b 7d 10	 mov	 edi, DWORD PTR __Spec$[ebp]
  00026	8a 17		 mov	 dl, BYTE PTR [edi]
  00028	80 fa 4c	 cmp	 dl, 76			; 0000004cH
  0002b	74 04		 je	 SHORT $LN4@Ifmt

; 1496 : 			*_Ptr++ = _Spec[0];	// qualifier

  0002d	88 10		 mov	 BYTE PTR [eax], dl

; 1497 : 		else

  0002f	eb 0b		 jmp	 SHORT $LN5@Ifmt
$LN4@Ifmt:

; 1498 : 
; 1499 : 			{	/* change L to I64 */
; 1500 : 			*_Ptr++ = 'I';

  00031	66 c7 00 49 36	 mov	 WORD PTR [eax], 13897	; 00003649H

; 1501 : 			*_Ptr++ = '6';

  00036	83 c0 02	 add	 eax, 2

; 1502 : 			*_Ptr++ = '4';

  00039	c6 00 34	 mov	 BYTE PTR [eax], 52	; 00000034H
$LN5@Ifmt:

; 1503 : 			}
; 1504 : 
; 1505 : 		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

  0003c	8b d1		 mov	 edx, ecx
  0003e	81 e2 00 0e 00
	00		 and	 edx, 3584		; 00000e00H
  00044	81 fa 00 04 00
	00		 cmp	 edx, 1024		; 00000400H

; 1506 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'

  0004a	75 0f		 jne	 SHORT $LN9@Ifmt
  0004c	b1 6f		 mov	 cl, 111			; 0000006fH
  0004e	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 1507 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1508 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';
; 1509 : 		*_Ptr = '\0';

  00051	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 1510 : 		return (_Fmt);

  00055	8b c6		 mov	 eax, esi
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi

; 1511 : 		}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN9@Ifmt:
  0005b	81 fa 00 08 00
	00		 cmp	 edx, 2048		; 00000800H

; 1506 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'

  00061	74 10		 je	 SHORT $LN7@Ifmt
  00063	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00066	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 1507 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1508 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';
; 1509 : 		*_Ptr = '\0';

  00069	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 1510 : 		return (_Fmt);

  0006d	8b c6		 mov	 eax, esi
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi

; 1511 : 		}

  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
$LN7@Ifmt:

; 1506 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'

  00073	c0 e1 03	 shl	 cl, 3
  00076	f6 d1		 not	 cl
  00078	80 e1 20	 and	 cl, 32			; 00000020H
  0007b	80 c9 58	 or	 cl, 88			; 00000058H
  0007e	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 1507 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1508 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';
; 1509 : 		*_Ptr = '\0';

  00081	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 1510 : 		return (_Fmt);

  00085	8b c6		 mov	 eax, esi
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 1511 : 		}

  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
_TEXT	SEGMENT
$T2 = -104						; size = 8
__Iosbase$GSCopy$1$ = -100				; size = 4
___$ReturnUdt$GSCopy$1$ = -96				; size = 4
__Count$GSCopy$2$ = -92					; size = 4
__Eoff$1$ = -92						; size = 4
__Buf$GSCopy$1$ = -88					; size = 4
__Punct_fac$1$ = -88					; size = 4
$T3 = -84						; size = 8
$T4 = -84						; size = 8
$T5 = -84						; size = 8
$T6 = -84						; size = 8
$T7 = -84						; size = 8
$T8 = -84						; size = 8
$T9 = -84						; size = 8
__Ctype_fac$1$ = -76					; size = 4
__Kseparator$ = -76					; size = 1
__Dp$ = -72						; size = 2
__Dest$3$ = -68						; size = 4
__Count$GSCopy$1$ = -68					; size = 4
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput, COMDAT

; 1413 : 		{	// put formatted floating-point to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 4d 24	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00031	8b 75 18	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00034	8b 7d 20	 mov	 edi, DWORD PTR __Buf$[ebp]
  00037	89 45 a0	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003a	89 75 9c	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], esi
  0003d	89 7d a8	 mov	 DWORD PTR __Buf$GSCopy$1$[ebp], edi
  00040	89 4d bc	 mov	 DWORD PTR __Count$GSCopy$1$[ebp], ecx

; 1414 : 		_DEBUG_POINTER(_Dest);
; 1415 : 		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')

  00043	85 c9		 test	 ecx, ecx
  00045	74 11		 je	 SHORT $LN16@Fput
  00047	8a 07		 mov	 al, BYTE PTR [edi]
  00049	3c 2b		 cmp	 al, 43			; 0000002bH
  0004b	74 04		 je	 SHORT $LN15@Fput
  0004d	3c 2d		 cmp	 al, 45			; 0000002dH
  0004f	75 07		 jne	 SHORT $LN16@Fput
$LN15@Fput:
  00051	bb 01 00 00 00	 mov	 ebx, 1
  00056	eb 02		 jmp	 SHORT $LN17@Fput
$LN16@Fput:
  00058	33 db		 xor	 ebx, ebx
$LN17@Fput:

; 1416 : 			? 1 : 0;
; 1417 : 
; 1418 : 		const char *_Exps;
; 1419 : 		if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)

  0005a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0005d	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  00062	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  00067	74 07		 je	 SHORT $LN4@Fput

; 1420 : 			_Exps = "eE";

  00069	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02MDKMJEGG@eE?$AA@

; 1421 : 		else

  0006e	eb 22		 jmp	 SHORT $LN6@Fput
$LN4@Fput:

; 1422 : 			{	// correct for hexadecimal floating-point
; 1423 : 			_Exps = "pP";
; 1424 : 			if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1425 : 				&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))

  00070	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
  00073	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02OOPEBDOJ@pP?$AA@
  00078	3b c1		 cmp	 eax, ecx
  0007a	77 16		 ja	 SHORT $LN6@Fput
  0007c	80 3c 1f 30	 cmp	 BYTE PTR [edi+ebx], 48	; 00000030H
  00080	75 10		 jne	 SHORT $LN6@Fput
  00082	8a 4c 1f 01	 mov	 cl, BYTE PTR [edi+ebx+1]
  00086	80 f9 78	 cmp	 cl, 120			; 00000078H
  00089	74 05		 je	 SHORT $LN7@Fput
  0008b	80 f9 58	 cmp	 cl, 88			; 00000058H
  0008e	75 02		 jne	 SHORT $LN6@Fput
$LN7@Fput:

; 1426 : 				_Prefix += 2;

  00090	8b d8		 mov	 ebx, eax
$LN6@Fput:

; 1427 : 			}
; 1428 : 		const size_t _Eoff =
; 1429 : 			_CSTD strcspn(&_Buf[0], _Exps);	// find exponent

  00092	52		 push	 edx
  00093	57		 push	 edi
  00094	e8 00 00 00 00	 call	 _strcspn
  00099	89 45 a4	 mov	 DWORD PTR __Eoff$1$[ebp], eax

; 1430 : 		char _Dp[2] = {"."};

  0009c	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  000a1	66 89 45 b8	 mov	 WORD PTR __Dp$[ebp], ax

; 1431 : 		_Dp[0] = _CSTD localeconv()->decimal_point[0];

  000a5	e8 00 00 00 00	 call	 _localeconv
  000aa	8b 00		 mov	 eax, DWORD PTR [eax]
  000ac	8a 00		 mov	 al, BYTE PTR [eax]
  000ae	88 45 b8	 mov	 BYTE PTR __Dp$[ebp], al

; 1432 : 		const size_t _Poff =
; 1433 : 			_CSTD strcspn(&_Buf[0], &_Dp[0]);	// find decimal point

  000b1	8d 45 b8	 lea	 eax, DWORD PTR __Dp$[ebp]
  000b4	50		 push	 eax
  000b5	57		 push	 edi
  000b6	e8 00 00 00 00	 call	 _strcspn
  000bb	83 c4 10	 add	 esp, 16			; 00000010H
  000be	8b f8		 mov	 edi, eax

; 1434 : 
; 1435 : 		const ctype<_Elem>& _Ctype_fac =

  000c0	8d 45 ac	 lea	 eax, DWORD PTR $T9[ebp]
  000c3	8b ce		 mov	 ecx, esi
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  000cb	50		 push	 eax
  000cc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000d3	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  000d8	83 c4 04	 add	 esp, 4
  000db	89 45 b4	 mov	 DWORD PTR __Ctype_fac$1$[ebp], eax
  000de	8b 4d b0	 mov	 ecx, DWORD PTR $T9[ebp+4]
  000e1	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000e8	85 c9		 test	 ecx, ecx
  000ea	74 11		 je	 SHORT $LN29@Fput
  000ec	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ee	ff 50 08	 call	 DWORD PTR [eax+8]
  000f1	8b c8		 mov	 ecx, eax
  000f3	85 c9		 test	 ecx, ecx
  000f5	74 06		 je	 SHORT $LN29@Fput
  000f7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f9	6a 01		 push	 1
  000fb	ff 10		 call	 DWORD PTR [eax]
$LN29@Fput:

; 1436 : 			_USE(_Iosbase.getloc(), ctype<_Elem>);
; 1437 : 		_Mystr _Groupstring(_Count, _Elem(0));	// reserve space

  000fd	6a 00		 push	 0
  000ff	ff 75 bc	 push	 DWORD PTR __Count$GSCopy$1$[ebp]
  00102	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00105	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0010c	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __Groupstring$[ebp+20], 15 ; 0000000fH
  00113	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Groupstring$[ebp+16], 0
  0011a	c6 45 d8 00	 mov	 BYTE PTR __Groupstring$[ebp], 0
  0011e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1438 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

  00123	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  00127	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0012a	8b 55 b4	 mov	 edx, DWORD PTR __Ctype_fac$1$[ebp]
  0012d	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  00131	8b 4d a8	 mov	 ecx, DWORD PTR __Buf$GSCopy$1$[ebp]
  00134	50		 push	 eax
  00135	8b 45 bc	 mov	 eax, DWORD PTR __Count$GSCopy$1$[ebp]
  00138	8b 12		 mov	 edx, DWORD PTR [edx]
  0013a	03 c1		 add	 eax, ecx
  0013c	50		 push	 eax
  0013d	51		 push	 ecx
  0013e	8b 4d b4	 mov	 ecx, DWORD PTR __Ctype_fac$1$[ebp]
  00141	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00148	ff 52 1c	 call	 DWORD PTR [edx+28]

; 1439 : 
; 1440 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

  0014b	8d 45 ac	 lea	 eax, DWORD PTR $T8[ebp]
  0014e	8b ce		 mov	 ecx, esi
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00156	50		 push	 eax
  00157	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0015b	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
  00160	8b f0		 mov	 esi, eax
  00162	83 c4 04	 add	 esp, 4
  00165	89 75 a8	 mov	 DWORD PTR __Punct_fac$1$[ebp], esi
  00168	8b 4d b0	 mov	 ecx, DWORD PTR $T8[ebp+4]
  0016b	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0016f	85 c9		 test	 ecx, ecx
  00171	74 11		 je	 SHORT $LN159@Fput
  00173	8b 01		 mov	 eax, DWORD PTR [ecx]
  00175	ff 50 08	 call	 DWORD PTR [eax+8]
  00178	8b c8		 mov	 ecx, eax
  0017a	85 c9		 test	 ecx, ecx
  0017c	74 06		 je	 SHORT $LN159@Fput
  0017e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00180	6a 01		 push	 1
  00182	ff 10		 call	 DWORD PTR [eax]
$LN159@Fput:

; 1441 : 		const string _Grouping = _Punct_fac.grouping();

  00184	8d 45 c0	 lea	 eax, DWORD PTR __Grouping$[ebp]
  00187	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0018b	50		 push	 eax
  0018c	8b ce		 mov	 ecx, esi
  0018e	e8 00 00 00 00	 call	 ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping

; 1442 : 		const _Elem _Kseparator = _Punct_fac.thousands_sep();

  00193	8b 06		 mov	 eax, DWORD PTR [esi]
  00195	8b ce		 mov	 ecx, esi
  00197	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0019b	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0019e	ff d0		 call	 eax

; 1443 : 
; 1444 : 		if (_Poff != _Count)

  001a0	8b 75 bc	 mov	 esi, DWORD PTR __Count$GSCopy$1$[ebp]
  001a3	88 45 b4	 mov	 BYTE PTR __Kseparator$[ebp], al
  001a6	3b fe		 cmp	 edi, esi
  001a8	74 1c		 je	 SHORT $LN494@Fput

; 1445 : 			_Groupstring[_Poff] = _Punct_fac.decimal_point();

  001aa	8b 4d a8	 mov	 ecx, DWORD PTR __Punct_fac$1$[ebp]
  001ad	8b 01		 mov	 eax, DWORD PTR [ecx]
  001af	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001b2	ff d0		 call	 eax
  001b4	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  001b8	8a c8		 mov	 cl, al
  001ba	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  001bd	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]

; 1446 : 
; 1447 : 		size_t _Off = _Poff == _Count ? _Eoff : _Poff;

  001c1	3b fe		 cmp	 edi, esi
  001c3	88 0c 38	 mov	 BYTE PTR [eax+edi], cl
$LN494@Fput:
  001c6	0f 44 7d a4	 cmove	 edi, DWORD PTR __Eoff$1$[ebp]

; 1448 : 		const char *_Pg = &_Grouping[0];

  001ca	8d 75 c0	 lea	 esi, DWORD PTR __Grouping$[ebp]
  001cd	83 7d d4 10	 cmp	 DWORD PTR __Grouping$[ebp+20], 16 ; 00000010H
  001d1	0f 43 75 c0	 cmovae	 esi, DWORD PTR __Grouping$[ebp]

; 1449 : 		while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1450 : 			&& (size_t)*_Pg < _Off - _Prefix)

  001d5	80 3e 7f	 cmp	 BYTE PTR [esi], 127	; 0000007fH
  001d8	74 38		 je	 SHORT $LN3@Fput
  001da	66 0f 1f 44 00
	00		 npad	 6
$LL2@Fput:
  001e0	8a 06		 mov	 al, BYTE PTR [esi]
  001e2	84 c0		 test	 al, al
  001e4	7e 2c		 jle	 SHORT $LN3@Fput
  001e6	0f be c8	 movsx	 ecx, al
  001e9	8b c7		 mov	 eax, edi
  001eb	2b c3		 sub	 eax, ebx
  001ed	3b c8		 cmp	 ecx, eax
  001ef	73 21		 jae	 SHORT $LN3@Fput

; 1451 : 			{	// add thousands separator
; 1452 : 			_Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);

  001f1	ff 75 b4	 push	 DWORD PTR __Kseparator$[ebp]
  001f4	2b f9		 sub	 edi, ecx
  001f6	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  001f9	6a 01		 push	 1
  001fb	57		 push	 edi
  001fc	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00201	80 7e 01 00	 cmp	 BYTE PTR [esi+1], 0

; 1453 : 			if ('\0' < _Pg[1])

  00205	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00208	0f 4e c6	 cmovle	 eax, esi
  0020b	8b f0		 mov	 esi, eax
  0020d	80 3e 7f	 cmp	 BYTE PTR [esi], 127	; 0000007fH
  00210	75 ce		 jne	 SHORT $LL2@Fput
$LN3@Fput:

; 1454 : 				++_Pg;	// not last group, advance
; 1455 : 			}
; 1456 : 
; 1457 : 		_Count = _Groupstring.size();
; 1458 : 		size_t _Fillcount = _Iosbase.width() <= 0
; 1459 : 			|| (size_t)_Iosbase.width() <= _Count

  00212	8b 7d 9c	 mov	 edi, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00215	8b 45 e8	 mov	 eax, DWORD PTR __Groupstring$[ebp+16]
  00218	89 45 a4	 mov	 DWORD PTR __Count$GSCopy$2$[ebp], eax
  0021b	83 7f 24 00	 cmp	 DWORD PTR [edi+36], 0
  0021f	7c 13		 jl	 SHORT $LN18@Fput
  00221	7f 06		 jg	 SHORT $LN490@Fput
  00223	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00227	76 0b		 jbe	 SHORT $LN18@Fput
$LN490@Fput:
  00229	8b 77 20	 mov	 esi, DWORD PTR [edi+32]
  0022c	3b f0		 cmp	 esi, eax
  0022e	76 04		 jbe	 SHORT $LN18@Fput
  00230	2b f0		 sub	 esi, eax
  00232	eb 02		 jmp	 SHORT $LN19@Fput
$LN18@Fput:
  00234	33 f6		 xor	 esi, esi
$LN19@Fput:

; 1460 : 				? 0 : (size_t)_Iosbase.width() - _Count;
; 1461 : 
; 1462 : 		ios_base::fmtflags _Adjustfield =
; 1463 : 			_Iosbase.flags() & ios_base::adjustfield;

  00236	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00239	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  0023e	83 f8 40	 cmp	 eax, 64			; 00000040H

; 1464 : 		if (_Adjustfield != ios_base::left
; 1465 : 			&& _Adjustfield != ios_base::internal)

  00241	0f 84 97 00 00
	00		 je	 $LN12@Fput
  00247	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0024c	74 48		 je	 SHORT $LN489@Fput

; 1466 : 			{	// put leading fill
; 1467 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

  0024e	56		 push	 esi
  0024f	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  00252	8d 45 ac	 lea	 eax, DWORD PTR $T7[ebp]
  00255	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  00258	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0025b	50		 push	 eax
  0025c	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0025f	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  00264	8b c8		 mov	 ecx, eax

; 1468 : 			_Fillcount = 0;

  00266	33 f6		 xor	 esi, esi

; 1469 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00268	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  0026c	53		 push	 ebx
  0026d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0026f	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  00272	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00275	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00278	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0027b	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  0027f	50		 push	 eax
  00280	ff 71 04	 push	 DWORD PTR [ecx+4]
  00283	8d 45 ac	 lea	 eax, DWORD PTR $T6[ebp]
  00286	ff 31		 push	 DWORD PTR [ecx]
  00288	50		 push	 eax
  00289	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0028c	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  00291	83 c4 30	 add	 esp, 48			; 00000030H
  00294	eb 6a		 jmp	 SHORT $LN495@Fput
$LN489@Fput:

; 1470 : 			}
; 1471 : 		else if (_Adjustfield == ios_base::internal)
; 1472 : 			{	// put internal fill
; 1473 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00296	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  0029a	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  0029d	53		 push	 ebx
  0029e	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  002a2	50		 push	 eax
  002a3	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  002a6	8d 45 ac	 lea	 eax, DWORD PTR $T5[ebp]
  002a9	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  002ac	50		 push	 eax
  002ad	ff 75 08	 push	 DWORD PTR _this$[ebp]
  002b0	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  002b5	8b c8		 mov	 ecx, eax

; 1474 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

  002b7	56		 push	 esi
  002b8	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  002bb	8b 01		 mov	 eax, DWORD PTR [ecx]
  002bd	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  002c0	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  002c3	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  002c6	8d 45 ac	 lea	 eax, DWORD PTR $T4[ebp]
  002c9	ff 71 04	 push	 DWORD PTR [ecx+4]
  002cc	ff 31		 push	 DWORD PTR [ecx]
  002ce	50		 push	 eax
  002cf	ff 75 08	 push	 DWORD PTR _this$[ebp]
  002d2	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  002d7	83 c4 30	 add	 esp, 48			; 00000030H

; 1475 : 			_Fillcount = 0;

  002da	33 f6		 xor	 esi, esi

; 1476 : 			}
; 1477 : 		else

  002dc	eb 22		 jmp	 SHORT $LN495@Fput
$LN12@Fput:

; 1478 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  002de	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  002e2	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  002e5	53		 push	 ebx
  002e6	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  002ea	50		 push	 eax
  002eb	ff 75 14	 push	 DWORD PTR __Dest$[ebp+4]
  002ee	8d 45 ac	 lea	 eax, DWORD PTR $T3[ebp]
  002f1	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  002f4	50		 push	 eax
  002f5	ff 75 08	 push	 DWORD PTR _this$[ebp]
  002f8	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  002fd	83 c4 18	 add	 esp, 24			; 00000018H
$LN495@Fput:
  00300	8b 10		 mov	 edx, DWORD PTR [eax]

; 1479 : 
; 1480 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  00302	83 7d ec 10	 cmp	 DWORD PTR __Groupstring$[ebp+20], 16 ; 00000010H
  00306	8b 4d a4	 mov	 ecx, DWORD PTR __Count$GSCopy$2$[ebp]
  00309	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  0030c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0030f	89 45 bc	 mov	 DWORD PTR __Dest$3$[ebp], eax
  00312	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00315	8d 45 d8	 lea	 eax, DWORD PTR __Groupstring$[ebp]
  00318	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Groupstring$[ebp]
  0031c	2b cb		 sub	 ecx, ebx
  0031e	51		 push	 ecx
  0031f	03 c3		 add	 eax, ebx
  00321	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00324	50		 push	 eax
  00325	ff 75 bc	 push	 DWORD PTR __Dest$3$[ebp]
  00328	8d 45 98	 lea	 eax, DWORD PTR $T2[ebp]
  0032b	52		 push	 edx
  0032c	50		 push	 eax
  0032d	53		 push	 ebx
  0032e	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1481 : 		_Iosbase.width(0);
; 1482 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

  00333	56		 push	 esi
  00334	ff 75 1c	 push	 DWORD PTR __Fill$[ebp]
  00337	8b 75 a0	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  0033a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0033c	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  0033f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00342	50		 push	 eax
  00343	51		 push	 ecx
  00344	56		 push	 esi
  00345	53		 push	 ebx
  00346	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00349	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
  00350	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], 0
  00357	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  0035c	8b 45 d4	 mov	 eax, DWORD PTR __Grouping$[ebp+20]
  0035f	83 c4 30	 add	 esp, 48			; 00000030H
  00362	83 f8 10	 cmp	 eax, 16			; 00000010H
  00365	72 0d		 jb	 SHORT $LN290@Fput
  00367	40		 inc	 eax
  00368	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  0036b	50		 push	 eax
  0036c	ff 75 c0	 push	 DWORD PTR __Grouping$[ebp]
  0036f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN290@Fput:
  00374	8b 4d ec	 mov	 ecx, DWORD PTR __Groupstring$[ebp+20]
  00377	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+20], 15 ; 0000000fH
  0037e	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR __Grouping$[ebp+16], 0
  00385	c6 45 c0 00	 mov	 BYTE PTR __Grouping$[ebp], 0
  00389	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0038c	72 0d		 jb	 SHORT $LN491@Fput
  0038e	41		 inc	 ecx
  0038f	51		 push	 ecx
  00390	ff 75 d8	 push	 DWORD PTR __Groupstring$[ebp]
  00393	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00396	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN491@Fput:
  0039b	8b c6		 mov	 eax, esi

; 1483 : 		}

  0039d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003a0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003a7	59		 pop	 ecx
  003a8	5f		 pop	 edi
  003a9	5e		 pop	 esi
  003aa	5b		 pop	 ebx
  003ab	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ae	33 cd		 xor	 ecx, ebp
  003b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b5	8b e5		 mov	 esp, ebp
  003b7	5d		 pop	 ebp
  003b8	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$0:
  00000	8d 4d ac	 lea	 ecx, DWORD PTR $T9[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$4:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$1:
  0000e	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$2:
  00016	8d 4d ac	 lea	 ecx, DWORD PTR $T8[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$33:
  0001e	e8 00 00 00 00	 call	 ___std_terminate
  00023	c3		 ret	 0
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$3:
  00024	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 4a 94	 mov	 ecx, DWORD PTR [edx-108]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00040	33 c8		 xor	 ecx, eax
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
  0004c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 1
__Flags$ = 20						; size = 4
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt, COMDAT

; 1383 : 		{	// generate sprintf format for floating-point

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1384 : 		char *_Ptr = _Fmt;
; 1385 : 		*_Ptr++ = '%';
; 1386 : 
; 1387 : 		if (_Flags & ios_base::showpos)

  00003	8b 55 14	 mov	 edx, DWORD PTR __Flags$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Fmt$[ebp]
  0000a	c6 06 25	 mov	 BYTE PTR [esi], 37	; 00000025H
  0000d	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00010	f6 c2 20	 test	 dl, 32			; 00000020H
  00013	74 04		 je	 SHORT $LN2@Ffmt

; 1388 : 			*_Ptr++ = '+';

  00015	c6 00 2b	 mov	 BYTE PTR [eax], 43	; 0000002bH
  00018	40		 inc	 eax
$LN2@Ffmt:

; 1389 : 		if (_Flags & ios_base::showpoint)

  00019	f6 c2 10	 test	 dl, 16			; 00000010H
  0001c	74 04		 je	 SHORT $LN3@Ffmt

; 1390 : 			*_Ptr++ = '#';

  0001e	c6 00 23	 mov	 BYTE PTR [eax], 35	; 00000023H
  00021	40		 inc	 eax
$LN3@Ffmt:

; 1391 : 		*_Ptr++ = '.';
; 1392 : 		*_Ptr++ = '*';	// for precision argument
; 1393 : 		if (_Spec != '\0')

  00022	8a 4d 10	 mov	 cl, BYTE PTR __Spec$[ebp]
  00025	66 c7 00 2e 2a	 mov	 WORD PTR [eax], 10798	; 00002a2eH
  0002a	83 c0 02	 add	 eax, 2
  0002d	84 c9		 test	 cl, cl
  0002f	74 03		 je	 SHORT $LN4@Ffmt

; 1394 : 			*_Ptr++ = _Spec;	// 'L' qualifier for long double only

  00031	88 08		 mov	 BYTE PTR [eax], cl
  00033	40		 inc	 eax
$LN4@Ffmt:

; 1395 : 
; 1396 : 		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

  00034	8b ca		 mov	 ecx, edx
  00036	81 e1 00 30 00
	00		 and	 ecx, 12288		; 00003000H

; 1397 : 		if (_Flags & ios_base::uppercase)

  0003c	f6 c2 04	 test	 dl, 4
  0003f	74 38		 je	 SHORT $LN5@Ffmt
  00041	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H

; 1398 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  00047	74 38		 je	 SHORT $LN16@Ffmt
  00049	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H
  0004f	75 0d		 jne	 SHORT $LN8@Ffmt
  00051	b1 41		 mov	 cl, 65			; 00000041H

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  00053	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  00055	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi

; 1408 : 		}

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN8@Ffmt:
  0005e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H

; 1398 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  00064	0f 95 c1	 setne	 cl
  00067	8d 0c 4d 45 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+69]

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  0006e	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  00070	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  00074	8b c6		 mov	 eax, esi
  00076	5e		 pop	 esi

; 1408 : 		}

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN5@Ffmt:
  00079	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  0007f	75 0d		 jne	 SHORT $LN14@Ffmt
$LN16@Ffmt:
  00081	b1 66		 mov	 cl, 102			; 00000066H
  00083	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  00085	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  00089	8b c6		 mov	 eax, esi
  0008b	5e		 pop	 esi

; 1408 : 		}

  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
$LN14@Ffmt:
  0008e	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  00094	75 0d		 jne	 SHORT $LN12@Ffmt
  00096	b1 61		 mov	 cl, 97			; 00000061H
  00098	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  0009a	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  0009e	8b c6		 mov	 eax, esi
  000a0	5e		 pop	 esi

; 1408 : 		}

  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
$LN12@Ffmt:
  000a3	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H

; 1399 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1400 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1401 : 		else
; 1402 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

  000a9	0f 95 c1	 setne	 cl
  000ac	8d 0c 4d 65 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+101]
  000b3	88 08		 mov	 BYTE PTR [eax], cl

; 1403 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1404 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1405 : 
; 1406 : 		*_Ptr = '\0';

  000b5	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 1407 : 		return (_Fmt);

  000b9	8b c6		 mov	 eax, esi
  000bb	5e		 pop	 esi

; 1408 : 		}

  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
_TEXT	SEGMENT
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1373 : 		{	// put formatted void pointer to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 1c	 mov	 eax, DWORD PTR __Val$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi

; 1374 : 		char _Buf[2 * _MAX_INT_DIG];
; 1375 : 
; 1376 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  0001c	50		 push	 eax
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp?$AA@
  00022	8d 45 bc	 lea	 eax, DWORD PTR __Buf$[ebp]
  00025	8b f9		 mov	 edi, ecx
  00027	6a 40		 push	 64			; 00000040H
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _sprintf_s
  0002f	50		 push	 eax
  00030	8d 45 bc	 lea	 eax, DWORD PTR __Buf$[ebp]
  00033	50		 push	 eax
  00034	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00037	56		 push	 esi
  00038	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0003b	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0003e	53		 push	 ebx
  0003f	57		 push	 edi
  00040	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1377 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), "%p", _Val)));
; 1378 : 		}

  00045	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00048	83 c4 30	 add	 esp, 48			; 00000030H
  0004b	8b c3		 mov	 eax, ebx
  0004d	33 cd		 xor	 ecx, ebp
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
_TEXT	SEGMENT
__Precision$ = -72					; size = 8
__Ptwo$2 = -68						; size = 4
___$ReturnUdt$GSCopy$1$ = -64				; size = 4
_this$GSCopy$1$ = -60					; size = 4
__Iosbase$GSCopy$1$ = -56				; size = 4
__Precision$1$ = -52					; size = 4
__Buf$ = -48						; size = 24
__Fmt$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1349 : 		{	// put formatted long double to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d c4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1350 : 		string _Buf;

  00030	33 d2		 xor	 edx, edx
  00032	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00035	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
  0003a	89 45 c0	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003d	89 4d c8	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], ecx
  00040	89 7d e4	 mov	 DWORD PTR __Buf$[ebp+20], edi
  00043	89 55 e0	 mov	 DWORD PTR __Buf$[ebp+16], edx
  00046	88 55 d0	 mov	 BYTE PTR __Buf$[ebp], dl

; 1351 : 		char _Fmt[8];
; 1352 : 		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
; 1353 : 			== ios_base::fixed;

  00049	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1354 : 		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed

  0004c	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  0004f	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  00054	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00057	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx
  0005a	89 75 cc	 mov	 DWORD PTR __Precision$1$[ebp], esi
  0005d	85 c9		 test	 ecx, ecx
  0005f	7f 17		 jg	 SHORT $LN4@do_put
  00061	7c 04		 jl	 SHORT $LN314@do_put
  00063	85 f6		 test	 esi, esi
  00065	75 11		 jne	 SHORT $LN4@do_put
$LN314@do_put:
  00067	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  0006c	74 0a		 je	 SHORT $LN4@do_put
  0006e	be 06 00 00 00	 mov	 esi, 6
  00073	33 c9		 xor	 ecx, ecx
  00075	89 75 cc	 mov	 DWORD PTR __Precision$1$[ebp], esi
$LN4@do_put:
  00078	89 4d bc	 mov	 DWORD PTR __Precision$[ebp+4], ecx

; 1355 : 			? 6 : _Iosbase.precision();	// desired precision
; 1356 : 		size_t _Bufsize = (size_t)_Precision;

  0007b	8b ce		 mov	 ecx, esi
  0007d	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H

; 1357 : 		if (_Isfixed && 1e10 < _CSTD fabsl(_Val))

  00082	75 56		 jne	 SHORT $LN2@do_put
  00084	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR __Val$[ebp]
  00089	0f 28 c1	 movaps	 xmm0, xmm1
  0008c	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00093	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4202a05f20000000
  0009b	76 3d		 jbe	 SHORT $LN2@do_put

; 1358 : 			{	// f or F format
; 1359 : 			int _Ptwo;
; 1360 : 			(void)_CSTD frexpl(_Val, &_Ptwo);

  0009d	8d 45 bc	 lea	 eax, DWORD PTR __Ptwo$2[ebp]
  000a0	50		 push	 eax
  000a1	83 ec 08	 sub	 esp, 8
  000a4	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  000a9	e8 00 00 00 00	 call	 _frexp

; 1361 : 			_Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  000ae	8b 45 bc	 mov	 eax, DWORD PTR __Ptwo$2[ebp]
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	8b 7d e4	 mov	 edi, DWORD PTR __Buf$[ebp+20]
  000b7	dd d8		 fstp	 ST(0)
  000b9	99		 cdq
  000ba	33 c2		 xor	 eax, edx
  000bc	2b c2		 sub	 eax, edx
  000be	69 c8 97 75 00
	00		 imul	 ecx, eax, 30103
  000c4	b8 89 b5 f8 14	 mov	 eax, 351843721		; 14f8b589H
  000c9	f7 e9		 imul	 ecx
  000cb	c1 fa 0d	 sar	 edx, 13			; 0000000dH
  000ce	8b ca		 mov	 ecx, edx
  000d0	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000d3	03 ca		 add	 ecx, edx
  000d5	8b 55 e0	 mov	 edx, DWORD PTR __Buf$[ebp+16]
  000d8	03 ce		 add	 ecx, esi
$LN2@do_put:

; 1362 : 			}
; 1363 : 		_Buf.resize(_Bufsize + 50);	// add fudge factor

  000da	83 c1 32	 add	 ecx, 50			; 00000032H
  000dd	3b ca		 cmp	 ecx, edx
  000df	77 13		 ja	 SHORT $LN127@do_put
  000e1	83 ff 10	 cmp	 edi, 16			; 00000010H
  000e4	89 4d e0	 mov	 DWORD PTR __Buf$[ebp+16], ecx
  000e7	8d 45 d0	 lea	 eax, DWORD PTR __Buf$[ebp]
  000ea	0f 43 45 d0	 cmovae	 eax, DWORD PTR __Buf$[ebp]
  000ee	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  000f2	eb 0d		 jmp	 SHORT $LN128@do_put
$LN127@do_put:
  000f4	2b ca		 sub	 ecx, edx
  000f6	6a 00		 push	 0
  000f8	51		 push	 ecx
  000f9	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  000fc	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN128@do_put:

; 1364 : 
; 1365 : 		int _Ngen = _CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),

  00101	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H
  00105	8d 7d d0	 lea	 edi, DWORD PTR __Buf$[ebp]
  00108	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  0010d	0f 43 7d d0	 cmovae	 edi, DWORD PTR __Buf$[ebp]
  00111	83 ec 08	 sub	 esp, 8
  00114	8b 45 c8	 mov	 eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00117	8b 75 e0	 mov	 esi, DWORD PTR __Buf$[ebp+16]
  0011a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0011f	ff 75 cc	 push	 DWORD PTR __Precision$1$[ebp]
  00122	ff 70 14	 push	 DWORD PTR [eax+20]
  00125	8d 45 e8	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00128	6a 4c		 push	 76			; 0000004cH
  0012a	50		 push	 eax
  0012b	ff 75 c4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0012e	e8 00 00 00 00	 call	 ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
  00133	83 c4 10	 add	 esp, 16			; 00000010H
  00136	50		 push	 eax
  00137	56		 push	 esi
  00138	57		 push	 edi
  00139	e8 00 00 00 00	 call	 _sprintf_s

; 1366 : 			_Ffmt(_Fmt, 'L', _Iosbase.flags()), (int)_Precision, _Val);
; 1367 : 
; 1368 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

  0013e	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H
  00142	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00145	8b 75 c0	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  00148	0f 43 4d d0	 cmovae	 ecx, DWORD PTR __Buf$[ebp]
  0014c	50		 push	 eax
  0014d	51		 push	 ecx
  0014e	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00151	ff 75 c8	 push	 DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00154	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00157	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0015a	56		 push	 esi
  0015b	ff 75 c4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0015e	e8 00 00 00 00	 call	 ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
  00163	8b 4d e4	 mov	 ecx, DWORD PTR __Buf$[ebp+20]
  00166	83 c4 38	 add	 esp, 56			; 00000038H
  00169	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0016c	72 0d		 jb	 SHORT $LN315@do_put
  0016e	41		 inc	 ecx
  0016f	51		 push	 ecx
  00170	ff 75 d0	 push	 DWORD PTR __Buf$[ebp]
  00173	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00176	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN315@do_put:
  0017b	8b c6		 mov	 eax, esi

; 1369 : 		}

  0017d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00180	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00187	59		 pop	 ecx
  00188	5f		 pop	 edi
  00189	5e		 pop	 esi
  0018a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018d	33 cd		 xor	 ecx, ebp
  0018f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00194	8b e5		 mov	 esp, ebp
  00196	5d		 pop	 ebp
  00197	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
__Precision$ = -72					; size = 8
__Ptwo$2 = -68						; size = 4
___$ReturnUdt$GSCopy$1$ = -64				; size = 4
_this$GSCopy$1$ = -60					; size = 4
__Iosbase$GSCopy$1$ = -56				; size = 4
__Precision$1$ = -52					; size = 4
__Buf$ = -48						; size = 24
__Fmt$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1325 : 		{	// put formatted double to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d c4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1326 : 		string _Buf;

  00030	33 d2		 xor	 edx, edx
  00032	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00035	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
  0003a	89 45 c0	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
  0003d	89 4d c8	 mov	 DWORD PTR __Iosbase$GSCopy$1$[ebp], ecx
  00040	89 7d e4	 mov	 DWORD PTR __Buf$[ebp+20], edi
  00043	89 55 e0	 mov	 DWORD PTR __Buf$[ebp+16], edx
  00046	88 55 d0	 mov	 BYTE PTR __Buf$[ebp], dl

; 1327 : 		char _Fmt[8];
; 1328 : 		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
; 1329 : 			== ios_base::fixed;

  00049	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1330 : 		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed

  0004c	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
  0004f	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  00054	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00057	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx
  0005a	89 75 cc	 mov	 DWORD PTR __Precision$1$[ebp], esi
  0005d	85 c9		 test	 ecx, ecx
  0005f	7f 17		 jg	 SHORT $LN4@do_put
  00061	7c 04		 jl	 SHORT $LN310@do_put
  00063	85 f6		 test	 esi, esi
  00065	75 11		 jne	 SHORT $LN4@do_put
$LN310@do_put:
  00067	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  0006c	74 0a		 je	 SHORT $LN4@do_put
  0006e	be 06 00 00 00	 mov	 esi, 6
  00073	33 c9		 xor	 ecx, ecx
  00075	89 75 cc	 mov	 DWORD PTR __Precision$1$[ebp], esi
$LN4@do_put:
  00078	89 4d bc	 mov	 DWORD PTR __Precision$[ebp+4], ecx

; 1331 : 			? 6 : _Iosbase.precision();	// desired precision
; 1332 : 		size_t _Bufsize = (size_t)_Precision;

  0007b	8b ce		 mov	 ecx, esi
  0007d	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H

; 1333 : 		if (_Isfixed && 1e10 < _CSTD fabs(_Val))

  00082	75 56		 jne	 SHORT $LN2@do_put
  00084	f2 0f 10 4d 1c	 movsd	 xmm1, QWORD PTR __Val$[ebp]
  00089	0f 28 c1	 movaps	 xmm0, xmm1
  0008c	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00093	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4202a05f20000000
  0009b	76 3d		 jbe	 SHORT $LN2@do_put

; 1334 : 			{	// f or F format
; 1335 : 			int _Ptwo;
; 1336 : 			(void)_CSTD frexp(_Val, &_Ptwo);

  0009d	8d 45 bc	 lea	 eax, DWORD PTR __Ptwo$2[ebp]
  000a0	50		 push	 eax
  000a1	83 ec 08	 sub	 esp, 8
  000a4	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  000a9	e8 00 00 00 00	 call	 _frexp

; 1337 : 			_Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  000ae	8b 45 bc	 mov	 eax, DWORD PTR __Ptwo$2[ebp]
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	8b 7d e4	 mov	 edi, DWORD PTR __Buf$[ebp+20]
  000b7	dd d8		 fstp	 ST(0)
  000b9	99		 cdq
  000ba	33 c2		 xor	 eax, edx
  000bc	2b c2		 sub	 eax, edx
  000be	69 c8 97 75 00
	00		 imul	 ecx, eax, 30103
  000c4	b8 89 b5 f8 14	 mov	 eax, 351843721		; 14f8b589H
  000c9	f7 e9		 imul	 ecx
  000cb	c1 fa 0d	 sar	 edx, 13			; 0000000dH
  000ce	8b ca		 mov	 ecx, edx
  000d0	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000d3	03 ca		 add	 ecx, edx
  000d5	8b 55 e0	 mov	 edx, DWORD PTR __Buf$[ebp+16]
  000d8	03 ce		 add	 ecx, esi
$LN2@do_put:

; 1338 : 			}
; 1339 : 		_Buf.resize(_Bufsize + 50);	// add fudge factor

  000da	83 c1 32	 add	 ecx, 50			; 00000032H
  000dd	3b ca		 cmp	 ecx, edx
  000df	77 13		 ja	 SHORT $LN123@do_put
  000e1	83 ff 10	 cmp	 edi, 16			; 00000010H
  000e4	89 4d e0	 mov	 DWORD PTR __Buf$[ebp+16], ecx
  000e7	8d 45 d0	 lea	 eax, DWORD PTR __Buf$[ebp]
  000ea	0f 43 45 d0	 cmovae	 eax, DWORD PTR __Buf$[ebp]
  000ee	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  000f2	eb 0d		 jmp	 SHORT $LN124@do_put
$LN123@do_put:
  000f4	2b ca		 sub	 ecx, edx
  000f6	6a 00		 push	 0
  000f8	51		 push	 ecx
  000f9	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  000fc	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN124@do_put:

; 1340 : 
; 1341 : 		int _Ngen = _CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),

  00101	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H
  00105	8d 7d d0	 lea	 edi, DWORD PTR __Buf$[ebp]
  00108	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  0010d	0f 43 7d d0	 cmovae	 edi, DWORD PTR __Buf$[ebp]
  00111	83 ec 08	 sub	 esp, 8
  00114	8b 45 c8	 mov	 eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00117	8b 75 e0	 mov	 esi, DWORD PTR __Buf$[ebp+16]
  0011a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0011f	ff 75 cc	 push	 DWORD PTR __Precision$1$[ebp]
  00122	ff 70 14	 push	 DWORD PTR [eax+20]
  00125	8d 45 e8	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00128	6a 00		 push	 0
  0012a	50		 push	 eax
  0012b	ff 75 c4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0012e	e8 00 00 00 00	 call	 ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
  00133	83 c4 10	 add	 esp, 16			; 00000010H
  00136	50		 push	 eax
  00137	56		 push	 esi
  00138	57		 push	 edi
  00139	e8 00 00 00 00	 call	 _sprintf_s

; 1342 : 			_Ffmt(_Fmt, 0, _Iosbase.flags()), (int)_Precision, _Val);
; 1343 : 
; 1344 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

  0013e	83 7d e4 10	 cmp	 DWORD PTR __Buf$[ebp+20], 16 ; 00000010H
  00142	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00145	8b 75 c0	 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  00148	0f 43 4d d0	 cmovae	 ecx, DWORD PTR __Buf$[ebp]
  0014c	50		 push	 eax
  0014d	51		 push	 ecx
  0014e	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00151	ff 75 c8	 push	 DWORD PTR __Iosbase$GSCopy$1$[ebp]
  00154	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00157	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0015a	56		 push	 esi
  0015b	ff 75 c4	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0015e	e8 00 00 00 00	 call	 ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
  00163	8b 4d e4	 mov	 ecx, DWORD PTR __Buf$[ebp+20]
  00166	83 c4 38	 add	 esp, 56			; 00000038H
  00169	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0016c	72 0d		 jb	 SHORT $LN311@do_put
  0016e	41		 inc	 ecx
  0016f	51		 push	 ecx
  00170	ff 75 d0	 push	 DWORD PTR __Buf$[ebp]
  00173	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00176	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN311@do_put:
  0017b	8b c6		 mov	 eax, esi

; 1345 : 		}

  0017d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00180	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00187	59		 pop	 ecx
  00188	5f		 pop	 edi
  00189	5e		 pop	 esi
  0018a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018d	33 cd		 xor	 ecx, ebp
  0018f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00194	8b e5		 mov	 esp, ebp
  00196	5d		 pop	 ebp
  00197	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1315 : 		{	// put formatted unsigned long long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1316 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1317 : 
; 1318 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  00014	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi
  0001c	ff 75 20	 push	 DWORD PTR __Val$[ebp+4]
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  00024	ff 76 14	 push	 DWORD PTR [esi+20]
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_02CLHGNPPK@Lu?$AA@
  0002c	50		 push	 eax
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	50		 push	 eax
  00037	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0003a	6a 40		 push	 64			; 00000040H
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _sprintf_s
  00042	50		 push	 eax
  00043	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00046	50		 push	 eax
  00047	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0004a	56		 push	 esi
  0004b	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0004e	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00051	53		 push	 ebx
  00052	57		 push	 edi
  00053	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1319 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
; 1320 : 				_Iosbase.flags()), _Val)));
; 1321 : 		}

  00058	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005b	83 c4 34	 add	 esp, 52			; 00000034H
  0005e	8b c3		 mov	 eax, ebx
  00060	33 cd		 xor	 ecx, ebp
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 1c 00	 ret	 28			; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1305 : 		{	// put formatted long long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1306 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1307 : 
; 1308 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  00014	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi
  0001c	ff 75 20	 push	 DWORD PTR __Val$[ebp+4]
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  00024	ff 76 14	 push	 DWORD PTR [esi+20]
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_02HIKPPMOK@Ld?$AA@
  0002c	50		 push	 eax
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	50		 push	 eax
  00037	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0003a	6a 40		 push	 64			; 00000040H
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _sprintf_s
  00042	50		 push	 eax
  00043	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00046	50		 push	 eax
  00047	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0004a	56		 push	 esi
  0004b	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0004e	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00051	53		 push	 ebx
  00052	57		 push	 edi
  00053	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1309 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
; 1310 : 				_Iosbase.flags()), _Val)));
; 1311 : 		}

  00058	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005b	83 c4 34	 add	 esp, 52			; 00000034H
  0005e	8b c3		 mov	 eax, ebx
  00060	33 cd		 xor	 ecx, ebp
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 1c 00	 ret	 28			; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1295 : 		{	// put formatted unsigned long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1296 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1297 : 
; 1298 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  00014	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi
  0001c	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 76 14	 push	 DWORD PTR [esi+20]
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_02BDDLJJBK@lu?$AA@
  00029	50		 push	 eax
  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	50		 push	 eax
  00034	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00037	6a 40		 push	 64			; 00000040H
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _sprintf_s
  0003f	50		 push	 eax
  00040	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00043	50		 push	 eax
  00044	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00047	56		 push	 esi
  00048	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0004b	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0004e	53		 push	 ebx
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1299 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
; 1300 : 				_Iosbase.flags()), _Val)));
; 1301 : 		}

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	83 c4 30	 add	 esp, 48			; 00000030H
  0005b	8b c3		 mov	 eax, ebx
  0005d	33 cd		 xor	 ecx, ebp
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1285 : 		{	// put formatted long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1286 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1287 : 
; 1288 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

  00014	8d 45 f4	 lea	 eax, DWORD PTR __Fmt$[ebp]
  00017	56		 push	 esi
  00018	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  0001b	57		 push	 edi
  0001c	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  0001f	8b f9		 mov	 edi, ecx
  00021	ff 76 14	 push	 DWORD PTR [esi+20]
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_02EAOCLKAK@ld?$AA@
  00029	50		 push	 eax
  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	50		 push	 eax
  00034	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00037	6a 40		 push	 64			; 00000040H
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _sprintf_s
  0003f	50		 push	 eax
  00040	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00043	50		 push	 eax
  00044	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  00047	56		 push	 esi
  00048	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  0004b	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  0004e	53		 push	 ebx
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1289 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
; 1290 : 				_Iosbase.flags()), _Val)));
; 1291 : 		}

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	83 c4 30	 add	 esp, 48			; 00000030H
  0005b	8b c3		 mov	 eax, ebx
  0005d	33 cd		 xor	 ecx, ebp
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT
$T2 = -88						; size = 8
$T3 = -80						; size = 8
$T4 = -80						; size = 8
__Dest$3$ = -76						; size = 4
_this$GSCopy$1$ = -72					; size = 4
__Fill$GSCopy$ = -68					; size = 1
$T5 = -64						; size = 24
$T6 = -64						; size = 24
__Str$7 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 1
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1255 : 		{	// put formatted bool to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 4d b8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0002e	8b 75 14	 mov	 esi, DWORD PTR __Iosbase$[ebp]
  00031	8a 45 18	 mov	 al, BYTE PTR __Fill$[ebp]
  00034	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00037	88 45 bc	 mov	 BYTE PTR __Fill$GSCopy$[ebp], al

; 1256 : 		_DEBUG_POINTER(_Dest);
; 1257 : 		if (!(_Iosbase.flags() & ios_base::boolalpha))

  0003a	f7 46 14 00 40
	00 00		 test	 DWORD PTR [esi+20], 16384 ; 00004000H
  00041	75 1a		 jne	 SHORT $LN2@do_put

; 1258 : 			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));

  00043	0f b6 45 1c	 movzx	 eax, BYTE PTR __Val$[ebp]
  00047	8b 11		 mov	 edx, DWORD PTR [ecx]
  00049	50		 push	 eax
  0004a	ff 75 bc	 push	 DWORD PTR __Fill$GSCopy$[ebp]
  0004d	56		 push	 esi
  0004e	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00051	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00054	53		 push	 ebx
  00055	ff 52 24	 call	 DWORD PTR [edx+36]
  00058	e9 7d 01 00 00	 jmp	 $LN950@do_put
$LN2@do_put:

; 1259 : 		else
; 1260 : 			{	// put "false" or "true"
; 1261 : 			const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

  0005d	8d 45 b0	 lea	 eax, DWORD PTR $T4[ebp]
  00060	8b ce		 mov	 ecx, esi
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00068	50		 push	 eax
  00069	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00070	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
  00075	83 c4 04	 add	 esp, 4
  00078	8b f8		 mov	 edi, eax
  0007a	8b 4d b4	 mov	 ecx, DWORD PTR $T4[ebp+4]
  0007d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00084	85 c9		 test	 ecx, ecx
  00086	74 11		 je	 SHORT $LN19@do_put
  00088	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008a	ff 52 08	 call	 DWORD PTR [edx+8]
  0008d	85 c0		 test	 eax, eax
  0008f	74 08		 je	 SHORT $LN19@do_put
  00091	8b 10		 mov	 edx, DWORD PTR [eax]
  00093	8b c8		 mov	 ecx, eax
  00095	6a 01		 push	 1
  00097	ff 12		 call	 DWORD PTR [edx]
$LN19@do_put:

; 1262 : 			_Mystr _Str;

  00099	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __Str$7[ebp+20], 15 ; 0000000fH
  000a0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Str$7[ebp+16], 0
  000a7	c6 45 d8 00	 mov	 BYTE PTR __Str$7[ebp], 0

; 1263 : 			if (_Val)

  000ab	80 7d 1c 00	 cmp	 BYTE PTR __Val$[ebp], 0

; 1264 : 				_Str.assign(_Punct_fac.truename());

  000af	8d 45 c0	 lea	 eax, DWORD PTR $T6[ebp]
  000b2	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  000b9	8b cf		 mov	 ecx, edi
  000bb	50		 push	 eax
  000bc	74 09		 je	 SHORT $LN4@do_put
  000be	e8 00 00 00 00	 call	 ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
  000c3	8b f8		 mov	 edi, eax

; 1265 : 			else

  000c5	eb 07		 jmp	 SHORT $LN1052@do_put
$LN4@do_put:

; 1266 : 				_Str.assign(_Punct_fac.falsename());

  000c7	e8 00 00 00 00	 call	 ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
  000cc	8b f8		 mov	 edi, eax
$LN1052@do_put:
  000ce	8d 45 d8	 lea	 eax, DWORD PTR __Str$7[ebp]
  000d1	3b c7		 cmp	 eax, edi
  000d3	74 30		 je	 SHORT $LN509@do_put
  000d5	8b 45 ec	 mov	 eax, DWORD PTR __Str$7[ebp+20]
  000d8	83 f8 10	 cmp	 eax, 16			; 00000010H
  000db	72 0d		 jb	 SHORT $LN682@do_put
  000dd	40		 inc	 eax
  000de	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  000e1	50		 push	 eax
  000e2	ff 75 d8	 push	 DWORD PTR __Str$7[ebp]
  000e5	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN682@do_put:
  000ea	57		 push	 edi
  000eb	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  000ee	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __Str$7[ebp+20], 15 ; 0000000fH
  000f5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Str$7[ebp+16], 0
  000fc	c6 45 d8 00	 mov	 BYTE PTR __Str$7[ebp], 0
  00100	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN509@do_put:
  00105	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp+20]
  00108	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0010c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0010f	72 0d		 jb	 SHORT $LN786@do_put
  00111	40		 inc	 eax
  00112	8d 4d c0	 lea	 ecx, DWORD PTR $T5[ebp]
  00115	50		 push	 eax
  00116	ff 75 c0	 push	 DWORD PTR $T5[ebp]
  00119	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN786@do_put:

; 1267 : 
; 1268 : 			size_t _Fillcount = _Iosbase.width() <= 0
; 1269 : 				|| (size_t)_Iosbase.width() <= _Str.size()

  0011e	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00122	8b 4d e8	 mov	 ecx, DWORD PTR __Str$7[ebp+16]
  00125	7c 13		 jl	 SHORT $LN8@do_put
  00127	7f 06		 jg	 SHORT $LN1045@do_put
  00129	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0012d	76 0b		 jbe	 SHORT $LN8@do_put
$LN1045@do_put:
  0012f	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  00132	3b f9		 cmp	 edi, ecx
  00134	76 04		 jbe	 SHORT $LN8@do_put
  00136	2b f9		 sub	 edi, ecx
  00138	eb 02		 jmp	 SHORT $LN9@do_put
$LN8@do_put:
  0013a	33 ff		 xor	 edi, edi
$LN9@do_put:

; 1270 : 					? 0 : (size_t)_Iosbase.width() - _Str.size();
; 1271 : 
; 1272 : 			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)

  0013c	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0013f	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00144	83 f8 40	 cmp	 eax, 64			; 00000040H
  00147	74 2b		 je	 SHORT $LN1046@do_put

; 1273 : 				{	// put leading fill
; 1274 : 				_Dest = _Rep(_Dest, _Fill, _Fillcount);

  00149	57		 push	 edi
  0014a	ff 75 bc	 push	 DWORD PTR __Fill$GSCopy$[ebp]
  0014d	8d 45 b0	 lea	 eax, DWORD PTR $T3[ebp]
  00150	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00153	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00156	50		 push	 eax
  00157	ff 75 b8	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  0015a	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep

; 1275 : 				_Fillcount = 0;

  0015f	8b 4d e8	 mov	 ecx, DWORD PTR __Str$7[ebp+16]
  00162	83 c4 18	 add	 esp, 24			; 00000018H
  00165	33 ff		 xor	 edi, edi
  00167	8b 10		 mov	 edx, DWORD PTR [eax]
  00169	89 55 0c	 mov	 DWORD PTR __Dest$[ebp], edx
  0016c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0016f	89 45 10	 mov	 DWORD PTR __Dest$[ebp+4], eax
  00172	eb 06		 jmp	 SHORT $LN1053@do_put
$LN1046@do_put:
  00174	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp+4]
  00177	8b 55 0c	 mov	 edx, DWORD PTR __Dest$[ebp]
$LN1053@do_put:

; 1276 : 				}
; 1277 : 			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field

  0017a	83 7d ec 10	 cmp	 DWORD PTR __Str$7[ebp+20], 16 ; 00000010H
  0017e	89 45 b4	 mov	 DWORD PTR __Dest$3$[ebp], eax
  00181	8d 45 d8	 lea	 eax, DWORD PTR __Str$7[ebp]
  00184	0f 43 45 d8	 cmovae	 eax, DWORD PTR __Str$7[ebp]
  00188	51		 push	 ecx
  00189	50		 push	 eax
  0018a	ff 75 b4	 push	 DWORD PTR __Dest$3$[ebp]
  0018d	8d 45 a8	 lea	 eax, DWORD PTR $T2[ebp]
  00190	52		 push	 edx
  00191	50		 push	 eax
  00192	ff 75 b8	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  00195	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1278 : 			_Iosbase.width(0);
; 1279 : 			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

  0019a	57		 push	 edi
  0019b	ff 75 bc	 push	 DWORD PTR __Fill$GSCopy$[ebp]
  0019e	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a0	89 4d 0c	 mov	 DWORD PTR __Dest$[ebp], ecx
  001a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a6	50		 push	 eax
  001a7	51		 push	 ecx
  001a8	53		 push	 ebx
  001a9	ff 75 b8	 push	 DWORD PTR _this$GSCopy$1$[ebp]
  001ac	89 45 10	 mov	 DWORD PTR __Dest$[ebp+4], eax
  001af	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  001b6	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  001bd	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  001c2	8b 45 ec	 mov	 eax, DWORD PTR __Str$7[ebp+20]
  001c5	83 c4 30	 add	 esp, 48			; 00000030H
  001c8	83 f8 10	 cmp	 eax, 16			; 00000010H
  001cb	72 0d		 jb	 SHORT $LN950@do_put
  001cd	40		 inc	 eax
  001ce	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  001d1	50		 push	 eax
  001d2	ff 75 d8	 push	 DWORD PTR __Str$7[ebp]
  001d5	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN950@do_put:
  001da	8b c3		 mov	 eax, ebx

; 1280 : 			}
; 1281 : 		}

  001dc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001df	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e6	59		 pop	 ecx
  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi
  001e9	5b		 pop	 ebx
  001ea	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ed	33 cd		 xor	 ecx, ebp
  001ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f4	8b e5		 mov	 esp, ebp
  001f6	5d		 pop	 ebp
  001f7	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$4:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1:
  0000e	8d 4d d8	 lea	 ecx, DWORD PTR __Str$7[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$32:
  00016	e8 00 00 00 00	 call	 ___std_terminate
  0001b	c3		 ret	 0
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$134:
  0001c	e8 00 00 00 00	 call	 ___std_terminate
  00021	c3		 ret	 0
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z:
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
  00042	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx

; 1212 : 		{	// put formatted long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1213 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

  00003	ff 75 1c	 push	 DWORD PTR __Val$[ebp]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	ff 75 18	 push	 DWORD PTR __Fill$[ebp]
  0000b	ff 75 14	 push	 DWORD PTR __Iosbase$[ebp]
  0000e	ff 75 10	 push	 DWORD PTR __Dest$[ebp+4]
  00011	ff 75 0c	 push	 DWORD PTR __Dest$[ebp]
  00014	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00017	ff 50 24	 call	 DWORD PTR [eax+36]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1214 : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 18 00	 ret	 24			; 00000018H
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 1197 : 		{	// construct from specified locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1196 : 		: locale::facet(_Refs)

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  00007	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1198 : 		_Init(_Lobj);
; 1199 : 		}

  0000a	8b c1		 mov	 eax, ecx
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = ecx

; 1184 : 		}

  00000	c2 04 00	 ret	 4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 1180 : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocnum
;	COMDAT ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 52
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 1168 : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1169 : 		if (_Ppf != 0 && *_Ppf == 0)

  00028	8b 7d 08	 mov	 edi, DWORD PTR __Ppf$[ebp]
  0002b	33 db		 xor	 ebx, ebx
  0002d	89 5d f0	 mov	 DWORD PTR $T3[ebp], ebx
  00030	85 ff		 test	 edi, edi
  00032	74 63		 je	 SHORT $LN30@Getcat
  00034	39 1f		 cmp	 DWORD PTR [edi], ebx
  00036	75 5f		 jne	 SHORT $LN30@Getcat

; 1170 : 			*_Ppf = new num_put<_Elem, _OutIt>(

  00038	6a 08		 push	 8
  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	8b f0		 mov	 esi, eax
  00041	83 c4 04	 add	 esp, 4
  00044	89 75 08	 mov	 DWORD PTR $T4[ebp], esi
  00047	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0004a	85 f6		 test	 esi, esi
  0004c	74 38		 je	 SHORT $LN4@Getcat
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR __Ploc$[ebp]
  00051	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00054	85 c9		 test	 ecx, ecx
  00056	75 07		 jne	 SHORT $LN12@Getcat
  00058	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0005d	eb 0a		 jmp	 SHORT $LN17@Getcat
$LN12@Getcat:
  0005f	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00062	85 c0		 test	 eax, eax
  00064	75 03		 jne	 SHORT $LN17@Getcat
  00066	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
$LN17@Getcat:
  00069	50		 push	 eax
  0006a	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0006d	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00072	bb 01 00 00 00	 mov	 ebx, 1
  00077	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0007e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
  00084	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00086	33 f6		 xor	 esi, esi
$LN5@Getcat:
  00088	89 37		 mov	 DWORD PTR [edi], esi
  0008a	f6 c3 01	 test	 bl, 1
  0008d	74 08		 je	 SHORT $LN30@Getcat
  0008f	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  00092	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN30@Getcat:

; 1171 : 				_Locinfo(_Ploc->c_str()));
; 1172 : 		return (_X_NUMERIC);

  00097	b8 04 00 00 00	 mov	 eax, 4

; 1173 : 		}

  0009c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a6	59		 pop	 ecx
  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 08		 push	 8
  00002	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 553  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 554  :  #if _NO_LOCALES
; 555  : 	static _Wrap_facet<_Facet> _Wfac;
; 556  : 	return (*(_Facet *)&_Wfac);
; 557  : 
; 558  :  #else /* _NO_LOCALES */
; 559  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 560  : 		const locale::facet *_Psave =
; 561  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 562  : 
; 563  : 		size_t _Id = _Facet::id;

  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
  00038	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	89 5d f0	 mov	 DWORD PTR __Psave$5[ebp], ebx
  00048	85 ff		 test	 edi, edi
  0004a	75 2f		 jne	 SHORT $LN11@use_facet
  0004c	57		 push	 edi
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, edi ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
  0005b	75 10		 jne	 SHORT $LN12@use_facet
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00062	40		 inc	 eax
  00063	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN12@use_facet:
  0006d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00070	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00075	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN11@use_facet:

; 564  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0007e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00081	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00084	73 0c		 jae	 SHORT $LN20@use_facet
  00086	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00089	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  0008c	85 f6		 test	 esi, esi
  0008e	75 77		 jne	 SHORT $LN7@use_facet
  00090	eb 02		 jmp	 SHORT $LN28@use_facet
$LN20@use_facet:
  00092	33 f6		 xor	 esi, esi
$LN28@use_facet:
  00094	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00098	74 10		 je	 SHORT $LN17@use_facet
  0009a	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009f	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000a2	73 0a		 jae	 SHORT $LN29@use_facet
  000a4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a7	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN17@use_facet:

; 565  : 
; 566  : 		if (_Pf != 0)

  000aa	85 f6		 test	 esi, esi
  000ac	75 59		 jne	 SHORT $LN7@use_facet
$LN29@use_facet:

; 567  : 			;	// got facet from locale
; 568  : 		else if (_Psave != 0)

  000ae	85 db		 test	 ebx, ebx
  000b0	74 04		 je	 SHORT $LN4@use_facet

; 569  : 			_Pf = _Psave;	// lazy facet already allocated

  000b2	8b f3		 mov	 esi, ebx
  000b4	eb 51		 jmp	 SHORT $LN7@use_facet
$LN4@use_facet:

; 570  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000b6	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  000b9	8d 45 f0	 lea	 eax, DWORD PTR __Psave$5[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
  000c2	83 c4 08	 add	 esp, 8
  000c5	83 f8 ff	 cmp	 eax, -1
  000c8	75 24		 jne	 SHORT $LN6@use_facet

; 571  : 
; 572  :  #if _HAS_EXCEPTIONS
; 573  : 
; 574  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000ca	0f 57 c0	 xorps	 xmm0, xmm0
  000cd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7bad_cast@std@@6B@
  000d4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000d9	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  000dc	66 0f d6 45 e0	 movq	 QWORD PTR $T2[ebp+4], xmm0
  000e1	50		 push	 eax
  000e2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@use_facet:
$LN6@use_facet:

; 575  : 
; 576  :  #else /* _HAS_EXCEPTIONS */
; 577  : 			abort();	// lazy disallowed
; 578  :  #endif /* _HAS_EXCEPTIONS */
; 579  : 
; 580  : 		else
; 581  : 			{	// queue up lazy facet for destruction
; 582  : 			_Pf = _Psave;

  000ee	8b 75 f0	 mov	 esi, DWORD PTR __Psave$5[ebp]

; 583  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 584  : 
; 585  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 586  : 			_Pfmod->_Incref();

  000f1	8b ce		 mov	 ecx, esi
  000f3	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
  000f9	8b 16		 mov	 edx, DWORD PTR [esi]
  000fb	ff 52 04	 call	 DWORD PTR [edx+4]

; 587  : 
; 588  :  #if defined(_M_CEE)
; 589  : 			_Facet_Register_m(_Pfmod);
; 590  : 
; 591  :  #else /* defined(_M_CEE) */
; 592  : 			_Facet_Register(_Pfmod);

  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  00104	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 593  :  #endif /* defined(_M_CEE) */
; 594  : 			}
; 595  : 
; 596  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00107	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0010a	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0010f	8b c6		 mov	 eax, esi

; 597  : 	_END_LOCK()
; 598  :  #endif /* _NO_LOCALES */
; 599  : 	}	// end of use_facet body

  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN31@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 142  : 			return (_Ok);

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 143  : 			}

  00003	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 130  : 			{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

  00025	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  0002a	84 c0		 test	 al, al
  0002c	75 07		 jne	 SHORT $LN2@sentry

; 133  : 				this->_Myostr._Osfx();

  0002e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00030	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN2@sentry:

; 134  : 
; 135  :  #else /* _HAS_EXCEPTIONS */
; 136  : 			this->_Myostr._Osfx();
; 137  :  #endif /* _HAS_EXCEPTIONS */
; 138  : 			}

  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00040	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00043	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  00047	85 c9		 test	 ecx, ecx
  00049	74 05		 je	 SHORT $LN5@sentry
  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@sentry:
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 123  : 			{	// construct locking and testing stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi

; 122  : 			: _Sentry_base(_Ostr)

  0002a	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  0002d	89 37		 mov	 DWORD PTR [edi], esi
  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00038	85 c9		 test	 ecx, ecx
  0003a	74 05		 je	 SHORT $LN6@sentry
  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	ff 50 04	 call	 DWORD PTR [eax+4]
$LN6@sentry:

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00041	8b 06		 mov	 eax, DWORD PTR [esi]
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004d	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  00052	75 11		 jne	 SHORT $LN2@sentry
  00054	8b 4c 30 3c	 mov	 ecx, DWORD PTR [eax+esi+60]
  00058	85 c9		 test	 ecx, ecx
  0005a	74 09		 je	 SHORT $LN2@sentry
  0005c	3b ce		 cmp	 ecx, esi
  0005e	74 05		 je	 SHORT $LN2@sentry

; 125  : 				_Ostr.tie()->flush();

  00060	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN2@sentry:

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006a	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  0006f	0f 94 c0	 sete	 al
  00072	88 47 04	 mov	 BYTE PTR [edi+4], al

; 127  : 			}

  00075	8b c7		 mov	 eax, edi
  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 106  : 			{	// destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 107  : 			if (_Myostr.rdbuf() != 0)

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  0002d	85 c9		 test	 ecx, ecx
  0002f	74 05		 je	 SHORT $LN2@Sentry_bas

; 108  : 				_Myostr.rdbuf()->_Unlock();

  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 109  : 			}

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 100  : 			{	// lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   : 			: _Myostr(_Ostr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00006	56		 push	 esi

; 100  : 			{	// lock the stream buffer, if there

  00007	8b f1		 mov	 esi, ecx
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 101  : 			if (_Myostr.rdbuf() != 0)

  0000b	8b 02		 mov	 eax, DWORD PTR [edx]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
  00014	85 c9		 test	 ecx, ecx
  00016	74 05		 je	 SHORT $LN8@Sentry_bas

; 102  : 				_Myostr.rdbuf()->_Lock();

  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	ff 50 04	 call	 DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 103  : 			}

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ
_TEXT	SEGMENT
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT
; _this$ = ecx

; 68   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	03 01		 add	 eax, DWORD PTR [ecx]
  00005	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00008	13 51 04	 adc	 edx, DWORD PTR [ecx+4]

; 69   : 		}

  0000b	c3		 ret	 0
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with stream offset

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	89 01		 mov	 DWORD PTR [ecx], eax
  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp+4]
  0000e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 44   : 		}

  00011	8b c1		 mov	 eax, ecx
  00013	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001a	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00021	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >, COMDAT
; _this$ = ecx

; 1202 : 		{	// assign [_First, _Last), input iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1203 : 		return (replace(begin(), end(), _First, _Last));

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	72 04		 jb	 SHORT $LN14@assign
  00009	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000b	eb 02		 jmp	 SHORT $LN15@assign
$LN14@assign:
  0000d	8b d1		 mov	 edx, ecx
$LN15@assign:
  0000f	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00012	03 c2		 add	 eax, edx
  00014	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00018	72 13		 jb	 SHORT $LN48@assign
  0001a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00022	50		 push	 eax
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace

; 1204 : 		}

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8

; 1203 : 		return (replace(begin(), end(), _First, _Last));

$LN48@assign:
  0002d	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00030	8b d1		 mov	 edx, ecx
  00032	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace

; 1204 : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 398  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 399  : 		return (*(_Mybase *)this - _Right);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]

; 400  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ
_TEXT	SEGMENT
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 340  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 341  : 		}

  00002	c3		 ret	 0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 322  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 321  : 		: _Mybase(_Parg, _Pstring)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 323  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator!=<char,char>, COMDAT

; 804  : 	return (false);

  00000	32 c0		 xor	 al, al

; 805  : 	}

  00002	c3		 ret	 0
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator!=<char,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator!=<std::allocator<char>,std::allocator<char> >, COMDAT

; 1026 : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 1027 : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat, COMDAT
; _this$ = ecx

; 270  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==, COMDAT
; _this$ = ecx

; 220  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 221  : 		_Compat(_Right);
; 222  : 		return (_Ptr == _Right._Ptr);
; 223  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 209  : 		{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 210  : 		_Compat(_Right);
; 211  : 		return (_Ptr - _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	2b 01		 sub	 eax, DWORD PTR [ecx]

; 212  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 68   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 69   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 70   : 		const auto _Contptr = _Mycont ? _Mycont->_Myptr() : 0;
; 71   : 		if (_Mycont == 0
; 72   : 			|| _Ptr == nullptr_t{}
; 73   : 			|| _Unfancy(_Ptr) < _Contptr
; 74   : 			|| _Contptr + _Mycont->_Mysize <= _Unfancy(_Ptr))
; 75   : 			{	// report error
; 76   : 			_DEBUG_ERROR("string iterator not dereferencable");
; 77   : 			_SCL_SECURE_OUT_OF_RANGE;
; 78   : 			}
; 79   : 
; 80   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 81   : 		_SCL_SECURE_VALIDATE(_Ptr != nullptr_t{});
; 82   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 83   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 84   : 		const auto _Contptr = _Mycont->_Myptr();
; 85   : 		_SCL_SECURE_VALIDATE_RANGE(_Contptr <= _Unfancy(_Ptr) && _Unfancy(_Ptr) < _Contptr + _Mycont->_Mysize);
; 86   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 87   : 
; 88   : 		_Analysis_assume_(_Ptr != nullptr_t{});
; 89   : 
; 90   : 		return (*_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 91   : 		}

  00002	c3		 ret	 0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 49   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 48   : 		: _Ptr(_Parg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 50   : 		this->_Adopt(_Pstring);
; 51   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>, COMDAT
; _this$ = ecx

; 595  : 		: _Mypair(_One_then_variadic_args_t(),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 598  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 1026 : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 1027 : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$insert@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
$T2 = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
??$insert@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@00@Z PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::insert<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > > >, COMDAT
; _this$ = ecx

; 1382 : 		{	// insert [_First, _Last) at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1383 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1384 : 		if (_Where._Getcont() != &this->_Get_data())
; 1385 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1386 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1387 : 
; 1388 : 		iterator _Prev = _Make_iter(_Where);
; 1389 : 		if (_Prev == begin())

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 1390 : 			{	// insert sequence at beginning
; 1391 : 			_Insert_range(_Where._Unchecked(), _First, _Last,

  0000a	c6 45 fc 00	 mov	 BYTE PTR $T2[ebp], 0
  0000e	8b 17		 mov	 edx, DWORD PTR [edi]
  00010	3b 02		 cmp	 eax, DWORD PTR [edx]
  00012	75 1f		 jne	 SHORT $LN2@insert
  00014	ff 75 fc	 push	 DWORD PTR $T2[ebp]
  00017	ff 75 14	 push	 DWORD PTR __Last$[ebp]
  0001a	ff 75 10	 push	 DWORD PTR __First$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > > >

; 1392 : 				_Iter_cat_t<_Iter>());
; 1393 : 			return (begin());

  00023	8b 07		 mov	 eax, DWORD PTR [edi]
  00025	5f		 pop	 edi
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1399 : 				_Iter_cat_t<_Iter>());
; 1400 : 			return (++_Prev);

  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 1401 : 			}
; 1402 : 		}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 10 00	 ret	 16			; 00000010H
$LN2@insert:
  00033	56		 push	 esi

; 1394 : 			}
; 1395 : 		else
; 1396 : 			{	// insert sequence not at beginning
; 1397 : 			--_Prev;
; 1398 : 			_Insert_range(_Where._Unchecked(), _First, _Last,

  00034	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00037	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0003a	ff 75 14	 push	 DWORD PTR __Last$[ebp]
  0003d	ff 75 10	 push	 DWORD PTR __First$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > > >

; 1399 : 				_Iter_cat_t<_Iter>());
; 1400 : 			return (++_Prev);

  00046	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00049	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0004b	5e		 pop	 esi
  0004c	5f		 pop	 edi
  0004d	89 08		 mov	 DWORD PTR [eax], ecx

; 1401 : 			}
; 1402 : 		}

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 10 00	 ret	 16			; 00000010H
??$insert@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@00@Z ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::insert<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@YA$$QAV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@YA$$QAV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@0@AAV10@@Z PROC ; std::forward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@YA$$QAV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@1@@Z PROC ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> ><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,void>, COMDAT
; _this$ = ecx

; 825  : 		{	// construct from allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Buynode0
  00020	89 06		 mov	 DWORD PTR [esi], eax

; 826  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@X@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@1@@Z ENDP ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> ><std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
$T2 = -20						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::assign<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > > >, COMDAT
; _this$ = ecx

; 1305 : 		{	// assign [_First, _Last), input iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d ec	 mov	 DWORD PTR _this$[ebp], ebx

; 1306 : 		iterator _Old = begin();

  00030	8b 33		 mov	 esi, DWORD PTR [ebx]

; 1307 : 		_TRY_BEGIN

  00032	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN230@assign:

; 1308 : 		for (; _First != _Last && _Old != end(); ++_First, (void)++_Old)

  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0003f	8b 36		 mov	 esi, DWORD PTR [esi]
  00041	3b c1		 cmp	 eax, ecx
  00043	74 75		 je	 SHORT $LN6@assign
  00045	3b 33		 cmp	 esi, DWORD PTR [ebx]
  00047	74 17		 je	 SHORT $LL226@assign

; 1309 : 			_Reusenode(_Old, *_First);

  00049	83 c0 08	 add	 eax, 8
  0004c	8b cb		 mov	 ecx, ebx
  0004e	50		 push	 eax
  0004f	56		 push	 esi
  00050	e8 00 00 00 00	 call	 ??$_Reusenode@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@ABUPartition@GostCrypt@@@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Reusenode<GostCrypt::Partition const &>
  00055	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
  0005d	eb dd		 jmp	 SHORT $LN230@assign
  0005f	90		 npad	 1
$LL226@assign:

; 1310 : 		for (; _First != _Last; ++_First)

  00060	3b c1		 cmp	 eax, ecx
  00062	74 56		 je	 SHORT $LN6@assign

; 1311 : 			_Insert(_Unchecked_end(), *_First);

  00064	8b 3b		 mov	 edi, DWORD PTR [ebx]
  00066	83 c0 08	 add	 eax, 8
  00069	50		 push	 eax
  0006a	8b cb		 mov	 ecx, ebx
  0006c	ff 77 04	 push	 DWORD PTR [edi+4]
  0006f	57		 push	 edi
  00070	e8 00 00 00 00	 call	 ??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Buynode<GostCrypt::Partition const &>
  00075	8b d0		 mov	 edx, eax
  00077	b9 21 22 22 02	 mov	 ecx, 35791393		; 02222221H
  0007c	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0007f	2b c8		 sub	 ecx, eax
  00081	83 f9 01	 cmp	 ecx, 1
  00084	73 0a		 jae	 SHORT $LN139@assign
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0008b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN231@assign:
$LN139@assign:
  00090	40		 inc	 eax
  00091	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00094	89 57 04	 mov	 DWORD PTR [edi+4], edx
  00097	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0009a	89 10		 mov	 DWORD PTR [eax], edx
  0009c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0009f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
  000a4	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
  000a7	eb b7		 jmp	 SHORT $LL226@assign
__catch$??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z$0:

; 1312 : 		_CATCH_ALL
; 1313 : 		clear();

  000a9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	e8 00 00 00 00	 call	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear

; 1314 : 		_RERAISE;

  000b1	6a 00		 push	 0
  000b3	6a 00		 push	 0
  000b5	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN232@assign:
$LN6@assign:

; 1315 : 		_CATCH_END
; 1316 : 		erase(_Old, end());

  000ba	ff 33		 push	 DWORD PTR [ebx]
  000bc	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  000bf	8b cb		 mov	 ecx, ebx
  000c1	56		 push	 esi
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 ?erase@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@0@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::erase

; 1317 : 		}

  000c8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000cb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d2	59		 pop	 ecx
  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 08 00	 ret	 8
$LN229@assign:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::assign<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@0@Z PROC ; std::operator!=<std::allocator<std::_List_node<GostCrypt::Partition,void *> >,std::allocator<std::_List_node<GostCrypt::Partition,void *> > >, COMDAT

; 1026 : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 1027 : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<std::_List_node<GostCrypt::Partition,void *> >,std::allocator<std::_List_node<GostCrypt::Partition,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??F?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator--, COMDAT
; _this$ = ecx

; 389  : 		--(*(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00005	89 01		 mov	 DWORD PTR [ecx], eax

; 390  : 		return (*this);

  00007	8b c1		 mov	 eax, ecx

; 391  : 		}

  00009	c3		 ret	 0
??F?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator++, COMDAT
; _this$ = ecx

; 376  : 		++(*(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 377  : 		return (*this);

  00006	8b c1		 mov	 eax, ecx

; 378  : 		}

  00008	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QBEAAUPartition@GostCrypt@@XZ
_TEXT	SEGMENT
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QBEAAUPartition@GostCrypt@@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator*, COMDAT
; _this$ = ecx

; 366  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 367  : 		}

  00005	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QBEAAUPartition@GostCrypt@@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UPartition@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UPartition@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >, COMDAT
; _this$ = ecx

; 348  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 347  : 		: _Mybase(_Pnode, _Plist)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 349  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UPartition@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::_List_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$_Insert@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@ABUPartition@GostCrypt@@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Insert@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@ABUPartition@GostCrypt@@@Z PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Insert<GostCrypt::Partition const &>, COMDAT
; _this$ = ecx

; 1061 : 		{	// insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1062 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1063 : 		_Nodeptr _Newnode =
; 1064 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

  00004	8b 75 08	 mov	 esi, DWORD PTR __Where$[ebp]
  00007	57		 push	 edi
  00008	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
  0000b	8b f9		 mov	 edi, ecx
  0000d	ff 76 04	 push	 DWORD PTR [esi+4]
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Buynode<GostCrypt::Partition const &>
  00016	8b d0		 mov	 edx, eax

; 1065 : 				_STD forward<_Valty>(_Val)...);
; 1066 : 		_Incsize(1);

  00018	b9 21 22 22 02	 mov	 ecx, 35791393		; 02222221H
  0001d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00020	2b c8		 sub	 ecx, eax
  00022	83 f9 01	 cmp	 ecx, 1
  00025	72 12		 jb	 SHORT $LN65@Insert
  00027	40		 inc	 eax
  00028	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1067 : 		this->_Prevnode(_Pnode) = _Newnode;

  0002b	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1068 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  0002e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	89 10		 mov	 DWORD PTR [eax], edx

; 1069 : 		}

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
$LN65@Insert:

; 1065 : 				_STD forward<_Valty>(_Val)...);
; 1066 : 		_Incsize(1);

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0003e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN67@Insert:
$LN64@Insert:
  00043	cc		 int	 3
??$_Insert@ABUPartition@GostCrypt@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@ABUPartition@GostCrypt@@@Z ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Insert<GostCrypt::Partition const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UPartition@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UPartition@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >, COMDAT
; _this$ = ecx

; 124  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 123  : 		: _Mybase(_Pnode, _Plist)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 125  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UPartition@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??1Finally2801@?CL@??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ
_TEXT	SEGMENT
??1Finally2801@?CL@??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ PROC ; `GostCrypt::BootEncryption::ChangePassword'::`43'::Finally2801::~Finally2801, COMDAT
; _this$ = ecx

; 2801 : 			finally_do_arg (ReopenBootVolumeHeaderRequest*, &reopenRequest, { burn (finally_arg, sizeof (*finally_arg)); });

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b d0		 mov	 edx, eax
  0000c	0f 1f 40 00	 npad	 4
$LL14@Finally280:
  00010	c6 02 00	 mov	 BYTE PTR [edx], 0
  00013	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00016	83 ee 01	 sub	 esi, 1
  00019	75 f5		 jne	 SHORT $LL14@Finally280
  0001b	5e		 pop	 esi
  0001c	0f 1f 40 00	 npad	 4
$LL5@Finally280:
  00020	c6 00 00	 mov	 BYTE PTR [eax], 0
  00023	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00026	83 e9 01	 sub	 ecx, 1
  00029	75 f5		 jne	 SHORT $LL5@Finally280
  0002b	c3		 ret	 0
??1Finally2801@?CL@??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ ENDP ; `GostCrypt::BootEncryption::ChangePassword'::`43'::Finally2801::~Finally2801
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??0Finally2801@?CL@??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@PAUReopenBootVolumeHeaderRequest@@@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
??0Finally2801@?CL@??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@PAUReopenBootVolumeHeaderRequest@@@Z PROC ; `GostCrypt::BootEncryption::ChangePassword'::`43'::Finally2801::Finally2801, COMDAT
; _this$ = ecx

; 2801 : 			finally_do_arg (ReopenBootVolumeHeaderRequest*, &reopenRequest, { burn (finally_arg, sizeof (*finally_arg)); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0Finally2801@?CL@??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@PAUReopenBootVolumeHeaderRequest@@@Z ENDP ; `GostCrypt::BootEncryption::ChangePassword'::`43'::Finally2801::Finally2801
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??1Finally2719@?1??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ
_TEXT	SEGMENT
??1Finally2719@?1??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ PROC ; `GostCrypt::BootEncryption::ChangePassword'::`2'::Finally2719::~Finally2719, COMDAT
; _this$ = ecx

; 2719 : 		finally_do ({ RandStop (FALSE); });

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 _RandStop
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1Finally2719@?1??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ ENDP ; `GostCrypt::BootEncryption::ChangePassword'::`2'::Finally2719::~Finally2719
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??1Finally2703@?1??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ
_TEXT	SEGMENT
??1Finally2703@?1??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ PROC ; `GostCrypt::BootEncryption::ChangePassword'::`2'::Finally2703::~Finally2703, COMDAT
; _this$ = ecx

; 2703 : 		finally_do_arg (PCRYPTO_INFO, cryptoInfo, { if (finally_arg) crypto_close (finally_arg); });

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	74 07		 je	 SHORT $LN3@Finally270
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _crypto_close
  0000c	59		 pop	 ecx
$LN3@Finally270:
  0000d	c3		 ret	 0
??1Finally2703@?1??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ ENDP ; `GostCrypt::BootEncryption::ChangePassword'::`2'::Finally2703::~Finally2703
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??0Finally2703@?1??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@PAUCRYPTO_INFO_t@@@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
??0Finally2703@?1??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@PAUCRYPTO_INFO_t@@@Z PROC ; `GostCrypt::BootEncryption::ChangePassword'::`2'::Finally2703::Finally2703, COMDAT
; _this$ = ecx

; 2703 : 		finally_do_arg (PCRYPTO_INFO, cryptoInfo, { if (finally_arg) crypto_close (finally_arg); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0Finally2703@?1??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@PAUCRYPTO_INFO_t@@@Z ENDP ; `GostCrypt::BootEncryption::ChangePassword'::`2'::Finally2703::Finally2703
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??1Finally2637@?BA@??Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z@QAE@XZ
_TEXT	SEGMENT
??1Finally2637@?BA@??Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z@QAE@XZ PROC ; `GostCrypt::BootEncryption::Deinstall'::`16'::Finally2637::~Finally2637, COMDAT
; _this$ = ecx

; 2637 : 			finally_do_arg (bool, displayWaitDialog, { if (finally_arg) CloseStaticModelessWaitDlg(); });

  00000	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00003	0f 85 00 00 00
	00		 jne	 _CloseStaticModelessWaitDlg
  00009	c3		 ret	 0
??1Finally2637@?BA@??Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z@QAE@XZ ENDP ; `GostCrypt::BootEncryption::Deinstall'::`16'::Finally2637::~Finally2637
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??0Finally2637@?BA@??Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z@QAE@0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 1
??0Finally2637@?BA@??Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z@QAE@0@Z PROC ; `GostCrypt::BootEncryption::Deinstall'::`16'::Finally2637::Finally2637, COMDAT
; _this$ = ecx

; 2637 : 			finally_do_arg (bool, displayWaitDialog, { if (finally_arg) CloseStaticModelessWaitDlg(); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8a 45 08	 mov	 al, BYTE PTR _a$[ebp]
  00006	88 01		 mov	 BYTE PTR [ecx], al
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0Finally2637@?BA@??Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z@QAE@0@Z ENDP ; `GostCrypt::BootEncryption::Deinstall'::`16'::Finally2637::Finally2637
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??1Finally2296@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@XZ
_TEXT	SEGMENT
??1Finally2296@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@XZ PROC ; `GostCrypt::BootEncryption::RegisterFilter'::`25'::Finally2296::~Finally2296, COMDAT
; _this$ = ecx

; 2296 : 			finally_do_arg (HINF, hInf, { SetupCloseInfFile (finally_arg); });

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetupCloseInfFile@4
  00008	c3		 ret	 0
??1Finally2296@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@XZ ENDP ; `GostCrypt::BootEncryption::RegisterFilter'::`25'::Finally2296::~Finally2296
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??0Finally2296@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@PAX@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
??0Finally2296@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@PAX@Z PROC ; `GostCrypt::BootEncryption::RegisterFilter'::`25'::Finally2296::Finally2296, COMDAT
; _this$ = ecx

; 2296 : 			finally_do_arg (HINF, hInf, { SetupCloseInfFile (finally_arg); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0Finally2296@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@PAX@Z ENDP ; `GostCrypt::BootEncryption::RegisterFilter'::`25'::Finally2296::Finally2296
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??1Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@XZ PROC ; `GostCrypt::BootEncryption::RegisterFilter'::`25'::Finally2284::~Finally2284, COMDAT
; _this$ = ecx

; 2284 : 			finally_do_arg (string, infFileName, { DeleteFile (finally_arg.c_str()); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000a	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0000e	72 04		 jb	 SHORT $LN22@Finally228
  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	eb 02		 jmp	 SHORT $LN23@Finally228
$LN22@Finally228:
  00014	8b c6		 mov	 eax, esi
$LN23@Finally228:
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4
  0001d	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00020	83 f8 10	 cmp	 eax, 16			; 00000010H
  00023	72 0b		 jb	 SHORT $LN32@Finally228
  00025	40		 inc	 eax
  00026	8b ce		 mov	 ecx, esi
  00028	50		 push	 eax
  00029	ff 36		 push	 DWORD PTR [esi]
  0002b	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN32@Finally228:
  00030	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00037	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0003b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00042	72 0a		 jb	 SHORT $LN120@Finally228
  00044	8b 06		 mov	 eax, DWORD PTR [esi]
  00046	5e		 pop	 esi
  00047	c6 00 00	 mov	 BYTE PTR [eax], 0
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN120@Finally228:
  0004e	c6 06 00	 mov	 BYTE PTR [esi], 0
  00051	5e		 pop	 esi
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??1Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@XZ ENDP ; `GostCrypt::BootEncryption::RegisterFilter'::`25'::Finally2284::~Finally2284
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??0Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_a$ = 8							; size = 24
??0Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; `GostCrypt::BootEncryption::RegisterFilter'::`25'::Finally2284::Finally2284, COMDAT
; _this$ = ecx

; 2284 : 			finally_do_arg (string, infFileName, { DeleteFile (finally_arg.c_str()); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	6a ff		 push	 -1
  0002b	6a 00		 push	 0
  0002d	8d 45 08	 lea	 eax, DWORD PTR _a$[ebp]
  00030	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00037	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0003e	50		 push	 eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	c6 06 00	 mov	 BYTE PTR [esi], 0
  00049	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004e	8b 4d 1c	 mov	 ecx, DWORD PTR _a$[ebp+20]
  00051	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00054	72 0d		 jb	 SHORT $LN231@Finally228
  00056	41		 inc	 ecx
  00057	51		 push	 ecx
  00058	ff 75 08	 push	 DWORD PTR _a$[ebp]
  0005b	8d 4d 08	 lea	 ecx, DWORD PTR _a$[ebp]
  0005e	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN231@Finally228:
  00063	8b c6		 mov	 eax, esi
  00065	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00068	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006f	59		 pop	 ecx
  00070	5e		 pop	 esi
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _a$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; `GostCrypt::BootEncryption::RegisterFilter'::`25'::Finally2284::Finally2284
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??1Finally2260@?1??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@XZ
_TEXT	SEGMENT
??1Finally2260@?1??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@XZ PROC ; `GostCrypt::BootEncryption::RegisterFilter'::`2'::Finally2260::~Finally2260, COMDAT
; _this$ = ecx

; 2260 : 		finally_do_arg (HKEY, regKey, { RegCloseKey (finally_arg); });

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00008	c3		 ret	 0
??1Finally2260@?1??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@XZ ENDP ; `GostCrypt::BootEncryption::RegisterFilter'::`2'::Finally2260::~Finally2260
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??0Finally2260@?1??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@PAUHKEY__@@@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
??0Finally2260@?1??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@PAUHKEY__@@@Z PROC ; `GostCrypt::BootEncryption::RegisterFilter'::`2'::Finally2260::Finally2260, COMDAT
; _this$ = ecx

; 2260 : 		finally_do_arg (HKEY, regKey, { RegCloseKey (finally_arg); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0Finally2260@?1??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@PAUHKEY__@@@Z ENDP ; `GostCrypt::BootEncryption::RegisterFilter'::`2'::Finally2260::Finally2260
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??1Finally2077@?1??CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z@QAE@XZ
_TEXT	SEGMENT
??1Finally2077@?1??CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z@QAE@XZ PROC ; `GostCrypt::BootEncryption::CreateVolumeHeader'::`2'::Finally2077::~Finally2077, COMDAT
; _this$ = ecx

; 2077 : 		finally_do_arg (PCRYPTO_INFO*, &cryptoInfo, { crypto_close (*finally_arg); });

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 30		 push	 DWORD PTR [eax]
  00004	e8 00 00 00 00	 call	 _crypto_close
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
??1Finally2077@?1??CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z@QAE@XZ ENDP ; `GostCrypt::BootEncryption::CreateVolumeHeader'::`2'::Finally2077::~Finally2077
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??0Finally2077@?1??CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z@QAE@PAPAUCRYPTO_INFO_t@@@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
??0Finally2077@?1??CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z@QAE@PAPAUCRYPTO_INFO_t@@@Z PROC ; `GostCrypt::BootEncryption::CreateVolumeHeader'::`2'::Finally2077::Finally2077, COMDAT
; _this$ = ecx

; 2077 : 		finally_do_arg (PCRYPTO_INFO*, &cryptoInfo, { crypto_close (*finally_arg); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0Finally2077@?1??CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z@QAE@PAPAUCRYPTO_INFO_t@@@Z ENDP ; `GostCrypt::BootEncryption::CreateVolumeHeader'::`2'::Finally2077::Finally2077
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 1
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2369 : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 2370 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;

  0002d	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00030	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00037	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0003e	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00045	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00049	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00050	72 04		 jb	 SHORT $LN105@operator
  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	eb 02		 jmp	 SHORT $LN106@operator
$LN105@operator:
  00056	8b c6		 mov	 eax, esi
$LN106@operator:
  00058	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2374 : 	return (_Ans);

  0005b	8b 5d 0c	 mov	 ebx, DWORD PTR __Left$[ebp]
  0005e	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00061	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  0006f	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00072	40		 inc	 eax
  00073	3b f8		 cmp	 edi, eax
  00075	77 26		 ja	 SHORT $LN170@operator

; 2371 : 	_Ans.reserve(_Left.size() + 1);

  00077	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  0007a	74 21		 je	 SHORT $LN170@operator
  0007c	6a 01		 push	 1
  0007e	50		 push	 eax
  0007f	8b ce		 mov	 ecx, esi
  00081	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00086	84 c0		 test	 al, al
  00088	74 13		 je	 SHORT $LN170@operator
  0008a	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0008e	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00091	72 04		 jb	 SHORT $LN165@operator
  00093	8b 06		 mov	 eax, DWORD PTR [esi]
  00095	eb 02		 jmp	 SHORT $LN166@operator
$LN165@operator:
  00097	8b c6		 mov	 eax, esi
$LN166@operator:
  00099	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN170@operator:

; 2372 : 	_Ans += _Left;

  0009d	6a ff		 push	 -1
  0009f	6a 00		 push	 0
  000a1	53		 push	 ebx
  000a2	8b ce		 mov	 ecx, esi
  000a4	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2373 : 	_Ans += _Right;

  000a9	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  000ac	8b ce		 mov	 ecx, esi
  000ae	6a 01		 push	 1
  000b0	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2374 : 	return (_Ans);

  000b5	8b c6		 mov	 eax, esi

; 2375 : 	}

  000b7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ba	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c1	59		 pop	 ecx
  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@operator:
  00018	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 1
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2449 : 	{	// return string + character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2450 : 	return (_STD move(_Left.append(1, _Right)));

  00004	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00007	56		 push	 esi
  00008	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	6a 01		 push	 1
  00014	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00019	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b ce		 mov	 ecx, esi
  0001e	50		 push	 eax
  0001f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00026	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002d	c6 06 00	 mov	 BYTE PTR [esi], 0
  00030	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi

; 2451 : 	}

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ
_TEXT	SEGMENT
_configFlags$2 = -17					; size = 1
__$EHRec$ = -16						; size = 16
??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ PROC ; `GostCrypt::BootEncryption::WipeHiddenOSCreationConfig'::`2'::Finally1727::~Finally1727, COMDAT
; _this$ = ecx

; 1727 : 		});

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1721 : 		finally_do_arg (BootEncryption *, this,

  0002b	8b 31		 mov	 esi, DWORD PTR [ecx]
  0002d	8d 45 ef	 lea	 eax, DWORD PTR _configFlags$2[ebp]
  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	6a 01		 push	 1
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003f	8b ce		 mov	 ecx, esi
  00041	50		 push	 eax
  00042	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00046	e8 00 00 00 00	 call	 ?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z ; GostCrypt::BootEncryption::ReadBootSectorConfig
  0004b	80 65 ef 3f	 and	 BYTE PTR _configFlags$2[ebp], 63 ; 0000003fH
  0004f	8d 45 ef	 lea	 eax, DWORD PTR _configFlags$2[ebp]
  00052	50		 push	 eax
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z ; GostCrypt::BootEncryption::WriteBootSectorConfig
$LN12@Finally172:
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
__catch$??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ$0:
  0006c	b8 00 00 00 00	 mov	 eax, $LN12@Finally172
  00071	c3		 ret	 0
__catch$??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ$2:
  00072	b8 00 00 00 00	 mov	 eax, $LN12@Finally172
  00077	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ ENDP ; `GostCrypt::BootEncryption::WipeHiddenOSCreationConfig'::`2'::Finally1727::~Finally1727
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??0Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@PAV23@@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
??0Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@PAV23@@Z PROC ; `GostCrypt::BootEncryption::WipeHiddenOSCreationConfig'::`2'::Finally1727::Finally1727, COMDAT
; _this$ = ecx

; 1727 : 		});

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1721 : 		finally_do_arg (BootEncryption *, this,

  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@PAV23@@Z ENDP ; `GostCrypt::BootEncryption::WipeHiddenOSCreationConfig'::`2'::Finally1727::Finally1727
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
$T2 = -152						; size = 20
$T3 = -132						; size = 20
$T4 = -112						; size = 20
$T5 = -92						; size = 8
__Ostr$GSCopy$ = -84					; size = 4
__Ok$ = -80						; size = 8
__Pad$ = -80						; size = 8
tv3152 = -72						; size = 4
__Ctype_fac$1$ = -72					; size = 4
__State$ = -68						; size = 4
__Val$GSCopy$1$ = -64					; size = 4
__Count$2$ = -60					; size = 4
__Count$1$ = -56					; size = 4
$T6 = -52						; size = 4
$T7 = -52						; size = 4
__Byte$ = -52						; size = 1
__Pad$2$ = -48						; size = 4
$T8 = -44						; size = 24
$T9 = -44						; size = 24
$T10 = -44						; size = 24
__$ArrayPad$11 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 694  : 	{	// insert NTBS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$11[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]

; 695  : 	ios_base::iostate _State = ios_base::goodbit;

  00034	33 f6		 xor	 esi, esi
  00036	8b 7d 08	 mov	 edi, DWORD PTR __Ostr$[ebp]

; 696  : 	streamsize _Count = (streamsize)_CSTD strlen(_Val);	// may overflow

  00039	8b c8		 mov	 ecx, eax
  0003b	89 7d ac	 mov	 DWORD PTR __Ostr$GSCopy$[ebp], edi
  0003e	89 45 c0	 mov	 DWORD PTR __Val$GSCopy$1$[ebp], eax
  00041	89 75 bc	 mov	 DWORD PTR __State$[ebp], esi
  00044	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL1070@operator:
  00047	8a 01		 mov	 al, BYTE PTR [ecx]
  00049	41		 inc	 ecx
  0004a	84 c0		 test	 al, al
  0004c	75 f9		 jne	 SHORT $LL1070@operator

; 697  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  0004e	8b 07		 mov	 eax, DWORD PTR [edi]
  00050	2b ca		 sub	 ecx, edx
  00052	89 4d c8	 mov	 DWORD PTR __Count$1$[ebp], ecx
  00055	89 75 c4	 mov	 DWORD PTR __Count$2$[ebp], esi
  00058	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005b	8b 44 3a 24	 mov	 eax, DWORD PTR [edx+edi+36]
  0005f	8b 5c 3a 20	 mov	 ebx, DWORD PTR [edx+edi+32]
  00063	85 c0		 test	 eax, eax
  00065	7c 17		 jl	 SHORT $LN20@operator
  00067	7f 0e		 jg	 SHORT $LN1072@operator
  00069	85 db		 test	 ebx, ebx
  0006b	74 11		 je	 SHORT $LN20@operator
  0006d	85 c0		 test	 eax, eax
  0006f	7c 0d		 jl	 SHORT $LN20@operator
  00071	7f 04		 jg	 SHORT $LN1072@operator
  00073	3b d9		 cmp	 ebx, ecx
  00075	76 07		 jbe	 SHORT $LN20@operator
$LN1072@operator:
  00077	2b d9		 sub	 ebx, ecx
  00079	83 d8 00	 sbb	 eax, 0
  0007c	eb 0e		 jmp	 SHORT $LN1085@operator
$LN20@operator:
  0007e	0f 57 c0	 xorps	 xmm0, xmm0
  00081	66 0f 13 45 b0	 movlpd	 QWORD PTR __Pad$[ebp], xmm0
  00086	8b 45 b4	 mov	 eax, DWORD PTR __Pad$[ebp+4]
  00089	8b 5d b0	 mov	 ebx, DWORD PTR __Pad$[ebp]
$LN1085@operator:

; 698  : 		? 0 : _Ostr.width() - _Count;
; 699  : 	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

  0008c	8b 4c 3a 38	 mov	 ecx, DWORD PTR [edx+edi+56]
  00090	89 45 d0	 mov	 DWORD PTR __Pad$2$[ebp], eax
  00093	89 7d b0	 mov	 DWORD PTR __Ok$[ebp], edi
  00096	85 c9		 test	 ecx, ecx
  00098	74 05		 je	 SHORT $LN39@operator
  0009a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009c	ff 50 04	 call	 DWORD PTR [eax+4]
$LN39@operator:
  0009f	8b 07		 mov	 eax, DWORD PTR [edi]
  000a1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000a8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ab	83 7c 38 0c 00	 cmp	 DWORD PTR [eax+edi+12], 0
  000b0	75 11		 jne	 SHORT $LN35@operator
  000b2	8b 4c 38 3c	 mov	 ecx, DWORD PTR [eax+edi+60]
  000b6	85 c9		 test	 ecx, ecx
  000b8	74 09		 je	 SHORT $LN35@operator
  000ba	3b cf		 cmp	 ecx, edi
  000bc	74 05		 je	 SHORT $LN35@operator
  000be	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
$LN35@operator:
  000c3	8b 07		 mov	 eax, DWORD PTR [edi]
  000c5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c8	03 cf		 add	 ecx, edi
  000ca	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  000ce	0f 94 c0	 sete	 al
  000d1	88 45 b4	 mov	 BYTE PTR __Ok$[ebp+4], al
  000d4	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 700  : 
; 701  : 	if (!_Ok)

  000db	84 c0		 test	 al, al
  000dd	75 0a		 jne	 SHORT $LN11@operator

; 702  : 		_State |= ios_base::badbit;

  000df	be 04 00 00 00	 mov	 esi, 4

; 703  : 	else

  000e4	e9 22 02 00 00	 jmp	 $LN26@operator
$LN11@operator:

; 704  : 		{	// state okay, insert characters
; 705  : 		_TRY_IO_BEGIN
; 706  : 		const ctype<_Elem>& _Ctype_fac = _USE(_Ostr.getloc(), ctype<_Elem>);

  000e9	8d 45 a4	 lea	 eax, DWORD PTR $T5[ebp]
  000ec	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  000f6	50		 push	 eax
  000f7	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  000fb	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  00100	83 c4 04	 add	 esp, 4
  00103	89 45 b8	 mov	 DWORD PTR __Ctype_fac$1$[ebp], eax
  00106	8b 4d a8	 mov	 ecx, DWORD PTR $T5[ebp+4]
  00109	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  0010d	85 c9		 test	 ecx, ecx
  0010f	74 11		 je	 SHORT $LN64@operator
  00111	8b 01		 mov	 eax, DWORD PTR [ecx]
  00113	ff 50 08	 call	 DWORD PTR [eax+8]
  00116	8b c8		 mov	 ecx, eax
  00118	85 c9		 test	 ecx, ecx
  0011a	74 06		 je	 SHORT $LN64@operator
  0011c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0011e	6a 01		 push	 1
  00120	ff 10		 call	 DWORD PTR [eax]
$LN64@operator:

; 707  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  00122	8b 07		 mov	 eax, DWORD PTR [edi]
  00124	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00128	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0012b	8b 44 38 14	 mov	 eax, DWORD PTR [eax+edi+20]
  0012f	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00134	83 f8 40	 cmp	 eax, 64			; 00000040H
  00137	74 65		 je	 SHORT $LN1076@operator
  00139	8b 45 d0	 mov	 eax, DWORD PTR __Pad$2$[ebp]
  0013c	0f 1f 40 00	 npad	 4
$LL4@operator:

; 708  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  00140	85 c0		 test	 eax, eax
  00142	7c 5a		 jl	 SHORT $LN1076@operator
  00144	7f 04		 jg	 SHORT $LN1073@operator
  00146	85 db		 test	 ebx, ebx
  00148	74 54		 je	 SHORT $LN1076@operator
$LN1073@operator:

; 709  : 				if (_Traits::eq_int_type(_Traits::eof(),

  0014a	8b 07		 mov	 eax, DWORD PTR [edi]
  0014c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0014f	0f b7 4c 38 40	 movzx	 ecx, WORD PTR [eax+edi+64]
  00154	89 4d cc	 mov	 DWORD PTR $T7[ebp], ecx
  00157	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
  0015b	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0015e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00161	74 1e		 je	 SHORT $LN75@operator
  00163	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00166	8b 02		 mov	 eax, DWORD PTR [edx]
  00168	85 c0		 test	 eax, eax
  0016a	7e 15		 jle	 SHORT $LN75@operator
  0016c	48		 dec	 eax
  0016d	89 02		 mov	 DWORD PTR [edx], eax
  0016f	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00172	8b 11		 mov	 edx, DWORD PTR [ecx]
  00174	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00177	89 01		 mov	 DWORD PTR [ecx], eax
  00179	8b 45 cc	 mov	 eax, DWORD PTR $T7[ebp]
  0017c	66 89 02	 mov	 WORD PTR [edx], ax
  0017f	eb 08		 jmp	 SHORT $LN1086@operator
$LN75@operator:
  00181	8b 01		 mov	 eax, DWORD PTR [ecx]
  00183	ff 75 cc	 push	 DWORD PTR $T7[ebp]
  00186	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN1086@operator:
  00189	0f b7 c0	 movzx	 eax, ax
  0018c	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00191	66 3b c8	 cmp	 cx, ax
  00194	75 6c		 jne	 SHORT $LN2@operator

; 710  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 711  : 					{	// insertion failed, quit
; 712  : 					_State |= ios_base::badbit;

  00196	be 04 00 00 00	 mov	 esi, 4
  0019b	89 75 bc	 mov	 DWORD PTR __State$[ebp], esi
$LN1076@operator:
  0019e	8b 45 c8	 mov	 eax, DWORD PTR __Count$1$[ebp]
$LL1068@operator:

; 713  : 					break;
; 714  : 					}
; 715  : 
; 716  : 		for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)

  001a1	85 f6		 test	 esi, esi
  001a3	0f 85 01 01 00
	00		 jne	 $LN9@operator
  001a9	39 75 c4	 cmp	 DWORD PTR __Count$2$[ebp], esi
  001ac	0f 8c 99 00 00
	00		 jl	 $LN1079@operator
  001b2	7f 08		 jg	 SHORT $LN1074@operator
  001b4	85 c0		 test	 eax, eax
  001b6	0f 84 8f 00 00
	00		 je	 $LN1079@operator
$LN1074@operator:

; 717  : 			if (_Traits::eq_int_type(_Traits::eof(),

  001bc	8b 45 c0	 mov	 eax, DWORD PTR __Val$GSCopy$1$[ebp]
  001bf	8b 4d b8	 mov	 ecx, DWORD PTR __Ctype_fac$1$[ebp]
  001c2	8a 00		 mov	 al, BYTE PTR [eax]
  001c4	88 45 cc	 mov	 BYTE PTR __Byte$[ebp], al
  001c7	8b 01		 mov	 eax, DWORD PTR [ecx]
  001c9	ff 75 cc	 push	 DWORD PTR __Byte$[ebp]
  001cc	ff 50 30	 call	 DWORD PTR [eax+48]
  001cf	0f b7 d0	 movzx	 edx, ax
  001d2	8b 07		 mov	 eax, DWORD PTR [edi]
  001d4	8b f2		 mov	 esi, edx
  001d6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d9	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
  001dd	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  001e0	83 38 00	 cmp	 DWORD PTR [eax], 0
  001e3	74 2e		 je	 SHORT $LN101@operator
  001e5	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  001e8	8b 02		 mov	 eax, DWORD PTR [edx]
  001ea	85 c0		 test	 eax, eax
  001ec	7e 25		 jle	 SHORT $LN101@operator
  001ee	48		 dec	 eax
  001ef	89 02		 mov	 DWORD PTR [edx], eax
  001f1	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  001f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  001f6	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  001f9	89 01		 mov	 DWORD PTR [ecx], eax
  001fb	8b ce		 mov	 ecx, esi
  001fd	66 89 32	 mov	 WORD PTR [edx], si
  00200	eb 1c		 jmp	 SHORT $LN5@operator
$LN2@operator:

; 708  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  00202	8b 45 d0	 mov	 eax, DWORD PTR __Pad$2$[ebp]
  00205	83 c3 ff	 add	 ebx, -1
  00208	83 d0 ff	 adc	 eax, -1
  0020b	89 45 d0	 mov	 DWORD PTR __Pad$2$[ebp], eax
  0020e	e9 2d ff ff ff	 jmp	 $LL4@operator

; 717  : 			if (_Traits::eq_int_type(_Traits::eof(),

$LN101@operator:
  00213	8b 01		 mov	 eax, DWORD PTR [ecx]
  00215	56		 push	 esi
  00216	ff 50 0c	 call	 DWORD PTR [eax+12]
  00219	0f b7 c0	 movzx	 eax, ax
  0021c	8b c8		 mov	 ecx, eax
$LN5@operator:

; 713  : 					break;
; 714  : 					}
; 715  : 
; 716  : 		for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)

  0021e	8b 45 c8	 mov	 eax, DWORD PTR __Count$1$[ebp]
  00221	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00226	83 c0 ff	 add	 eax, -1
  00229	be 04 00 00 00	 mov	 esi, 4
  0022e	89 45 c8	 mov	 DWORD PTR __Count$1$[ebp], eax
  00231	83 55 c4 ff	 adc	 DWORD PTR __Count$2$[ebp], -1
  00235	ff 45 c0	 inc	 DWORD PTR __Val$GSCopy$1$[ebp]
  00238	66 3b d1	 cmp	 dx, cx
  0023b	b9 00 00 00 00	 mov	 ecx, 0
  00240	0f 45 f1	 cmovne	 esi, ecx
  00243	89 75 bc	 mov	 DWORD PTR __State$[ebp], esi
  00246	e9 56 ff ff ff	 jmp	 $LL1068@operator
$LN1079@operator:
  0024b	8b 45 d0	 mov	 eax, DWORD PTR __Pad$2$[ebp]
  0024e	66 90		 npad	 2
$LL1077@operator:

; 718  : 				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
; 719  : 					_State |= ios_base::badbit;
; 720  : 
; 721  : 		if (_State == ios_base::goodbit)
; 722  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00250	85 c0		 test	 eax, eax
  00252	7c 56		 jl	 SHORT $LN9@operator
  00254	7f 04		 jg	 SHORT $LN1075@operator
  00256	85 db		 test	 ebx, ebx
  00258	74 50		 je	 SHORT $LN9@operator
$LN1075@operator:

; 723  : 				if (_Traits::eq_int_type(_Traits::eof(),

  0025a	8b 07		 mov	 eax, DWORD PTR [edi]
  0025c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0025f	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
  00263	0f b7 54 38 40	 movzx	 edx, WORD PTR [eax+edi+64]
  00268	89 55 cc	 mov	 DWORD PTR $T6[ebp], edx
  0026b	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0026e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00271	74 21		 je	 SHORT $LN127@operator
  00273	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00276	8b 00		 mov	 eax, DWORD PTR [eax]
  00278	85 c0		 test	 eax, eax
  0027a	7e 18		 jle	 SHORT $LN127@operator
  0027c	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0027f	48		 dec	 eax
  00280	89 02		 mov	 DWORD PTR [edx], eax
  00282	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00285	8b 11		 mov	 edx, DWORD PTR [ecx]
  00287	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  0028a	89 01		 mov	 DWORD PTR [ecx], eax
  0028c	8b 45 cc	 mov	 eax, DWORD PTR $T6[ebp]
  0028f	66 89 02	 mov	 WORD PTR [edx], ax
  00292	eb 06		 jmp	 SHORT $LN1087@operator
$LN127@operator:
  00294	8b 01		 mov	 eax, DWORD PTR [ecx]
  00296	52		 push	 edx
  00297	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN1087@operator:
  0029a	0f b7 c0	 movzx	 eax, ax
  0029d	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  002a2	66 3b c8	 cmp	 cx, ax
  002a5	75 1a		 jne	 SHORT $LN8@operator

; 724  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 725  : 					{	// insertion failed, quit
; 726  : 					_State |= ios_base::badbit;

  002a7	83 ce 04	 or	 esi, 4
$LN9@operator:

; 727  : 					break;
; 728  : 					}
; 729  : 		_Ostr.width(0);

  002aa	8b 07		 mov	 eax, DWORD PTR [edi]
  002ac	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002af	c7 44 38 20 00
	00 00 00	 mov	 DWORD PTR [eax+edi+32], 0
  002b7	c7 44 38 24 00
	00 00 00	 mov	 DWORD PTR [eax+edi+36], 0
  002bf	eb 43		 jmp	 SHORT $LN1088@operator
$LN8@operator:

; 718  : 				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
; 719  : 					_State |= ios_base::badbit;
; 720  : 
; 721  : 		if (_State == ios_base::goodbit)
; 722  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  002c1	8b 45 d0	 mov	 eax, DWORD PTR __Pad$2$[ebp]
  002c4	83 c3 ff	 add	 ebx, -1
  002c7	83 d0 ff	 adc	 eax, -1
  002ca	89 45 d0	 mov	 DWORD PTR __Pad$2$[ebp], eax
  002cd	eb 81		 jmp	 SHORT $LL1077@operator
__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$0:

; 730  : 		_CATCH_IO_(_Ostr)

  002cf	8b 4d ac	 mov	 ecx, DWORD PTR __Ostr$GSCopy$[ebp]
  002d2	8b 01		 mov	 eax, DWORD PTR [ecx]
  002d4	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002d7	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  002db	03 d1		 add	 edx, ecx
  002dd	83 c8 04	 or	 eax, 4
  002e0	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  002e4	75 03		 jne	 SHORT $LN156@operator
  002e6	83 c8 04	 or	 eax, 4
$LN156@operator:
  002e9	83 e0 17	 and	 eax, 23			; 00000017H
  002ec	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  002ef	85 42 10	 test	 DWORD PTR [edx+16], eax
  002f2	0f 85 e8 02 00
	00		 jne	 $LN159@operator
  002f8	b8 00 00 00 00	 mov	 eax, $LN27@operator
  002fd	c3		 ret	 0
$LN27@operator:
  002fe	8b 75 bc	 mov	 esi, DWORD PTR __State$[ebp]
  00301	8b 7d ac	 mov	 edi, DWORD PTR __Ostr$GSCopy$[ebp]
$LN1088@operator:
  00304	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN26@operator:

; 731  : 		}
; 732  : 
; 733  : 	_Ostr.setstate(_State);

  0030b	8b 07		 mov	 eax, DWORD PTR [edi]
  0030d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00310	03 d7		 add	 edx, edi
  00312	85 f6		 test	 esi, esi
  00314	0f 84 78 02 00
	00		 je	 $LN224@operator
  0031a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0031d	0b c6		 or	 eax, esi
  0031f	8b c8		 mov	 ecx, eax
  00321	83 c9 04	 or	 ecx, 4
  00324	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00328	0f 45 c8	 cmovne	 ecx, eax
  0032b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0032e	83 e1 17	 and	 ecx, 23			; 00000017H
  00331	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00334	23 c1		 and	 eax, ecx
  00336	0f 84 56 02 00
	00		 je	 $LN224@operator
  0033c	a8 04		 test	 al, 4
  0033e	0f 84 f8 00 00
	00		 je	 $LN221@operator
  00344	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  0034a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __tls_index
  00350	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  00353	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
  00358	3b 81 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[ecx]
  0035e	7e 41		 jle	 SHORT $LN233@operator
  00360	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
  00365	e8 00 00 00 00	 call	 __Init_thread_header
  0036a	83 c4 04	 add	 esp, 4
  0036d	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA, -1 ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
  00374	75 2b		 jne	 SHORT $LN233@operator
  00376	68 00 00 00 00	 push	 OFFSET ??__F_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ@YAXXZ ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::`dynamic atexit destructor for '_Static''
  0037b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A, OFFSET ??_7_Iostream_error_category@std@@6B@
  00385	c7 05 04 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A+4, 5
  0038f	e8 00 00 00 00	 call	 _atexit
  00394	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
  00399	e8 00 00 00 00	 call	 __Init_thread_footer
  0039e	83 c4 08	 add	 esp, 8
$LN233@operator:
  003a1	6a 14		 push	 20			; 00000014H
  003a3	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  003a8	8d 4d d4	 lea	 ecx, DWORD PTR $T10[ebp]
  003ab	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR $T10[ebp+20], 15 ; 0000000fH
  003b2	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T10[ebp+16], 0
  003b9	c6 45 d4 00	 mov	 BYTE PTR $T10[ebp], 0
  003bd	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  003c2	8d 45 d4	 lea	 eax, DWORD PTR $T10[ebp]
  003c5	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  003c9	50		 push	 eax
  003ca	68 00 00 00 00	 push	 OFFSET ?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Static
  003cf	6a 01		 push	 1
  003d1	8d 4d 90	 lea	 ecx, DWORD PTR $T4[ebp]
  003d4	e8 00 00 00 00	 call	 ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
  003d9	8b 45 e8	 mov	 eax, DWORD PTR $T10[ebp+20]
  003dc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  003e0	83 f8 10	 cmp	 eax, 16			; 00000010H
  003e3	72 42		 jb	 SHORT $LN475@operator
  003e5	8b 4d d4	 mov	 ecx, DWORD PTR $T10[ebp]
  003e8	40		 inc	 eax
  003e9	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  003ee	72 2e		 jb	 SHORT $LN470@operator
  003f0	f6 c1 1f	 test	 cl, 31			; 0000001fH
  003f3	74 05		 je	 SHORT $LN471@operator
  003f5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1089@operator:
$LN471@operator:
  003fa	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  003fd	3b c1		 cmp	 eax, ecx
  003ff	72 05		 jb	 SHORT $LN472@operator
  00401	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1090@operator:
$LN472@operator:
  00406	2b c8		 sub	 ecx, eax
  00408	83 f9 04	 cmp	 ecx, 4
  0040b	73 05		 jae	 SHORT $LN473@operator
  0040d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1091@operator:
$LN473@operator:
  00412	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00415	76 05		 jbe	 SHORT $LN474@operator
  00417	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1092@operator:
$LN474@operator:
  0041c	8b c8		 mov	 ecx, eax
$LN470@operator:
  0041e	51		 push	 ecx
  0041f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00424	83 c4 04	 add	 esp, 4
$LN475@operator:
  00427	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  0042c	8d 45 90	 lea	 eax, DWORD PTR $T4[ebp]
  0042f	c7 45 90 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00436	50		 push	 eax
  00437	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1093@operator:
$LN221@operator:
  0043c	a8 02		 test	 al, 2
  0043e	0f 84 a7 00 00
	00		 je	 $LN223@operator
  00444	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00449	6a 15		 push	 21			; 00000015H
  0044b	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  00450	8d 4d d4	 lea	 ecx, DWORD PTR $T9[ebp]
  00453	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR $T9[ebp+20], 15 ; 0000000fH
  0045a	8b f0		 mov	 esi, eax
  0045c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T9[ebp+16], 0
  00463	c6 45 d4 00	 mov	 BYTE PTR $T9[ebp], 0
  00467	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0046c	8d 45 d4	 lea	 eax, DWORD PTR $T9[ebp]
  0046f	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+12], 7
  00473	50		 push	 eax
  00474	56		 push	 esi
  00475	6a 01		 push	 1
  00477	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0047d	e8 00 00 00 00	 call	 ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
  00482	8b 45 e8	 mov	 eax, DWORD PTR $T9[ebp+20]
  00485	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00489	83 f8 10	 cmp	 eax, 16			; 00000010H
  0048c	72 42		 jb	 SHORT $LN739@operator
  0048e	8b 4d d4	 mov	 ecx, DWORD PTR $T9[ebp]
  00491	40		 inc	 eax
  00492	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00497	72 2e		 jb	 SHORT $LN734@operator
  00499	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0049c	74 05		 je	 SHORT $LN735@operator
  0049e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1094@operator:
$LN735@operator:
  004a3	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  004a6	3b c1		 cmp	 eax, ecx
  004a8	72 05		 jb	 SHORT $LN736@operator
  004aa	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1095@operator:
$LN736@operator:
  004af	2b c8		 sub	 ecx, eax
  004b1	83 f9 04	 cmp	 ecx, 4
  004b4	73 05		 jae	 SHORT $LN737@operator
  004b6	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1096@operator:
$LN737@operator:
  004bb	83 f9 23	 cmp	 ecx, 35			; 00000023H
  004be	76 05		 jbe	 SHORT $LN738@operator
  004c0	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1097@operator:
$LN738@operator:
  004c5	8b c8		 mov	 ecx, eax
$LN734@operator:
  004c7	51		 push	 ecx
  004c8	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  004cd	83 c4 04	 add	 esp, 4
$LN739@operator:
  004d0	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  004d5	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  004db	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  004e5	50		 push	 eax
  004e6	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1098@operator:
$LN223@operator:
  004eb	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  004f0	6a 14		 push	 20			; 00000014H
  004f2	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  004f7	8d 4d d4	 lea	 ecx, DWORD PTR $T8[ebp]
  004fa	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR $T8[ebp+20], 15 ; 0000000fH
  00501	8b f0		 mov	 esi, eax
  00503	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T8[ebp+16], 0
  0050a	c6 45 d4 00	 mov	 BYTE PTR $T8[ebp], 0
  0050e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00513	8d 45 d4	 lea	 eax, DWORD PTR $T8[ebp]
  00516	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+12], 8
  0051a	50		 push	 eax
  0051b	56		 push	 esi
  0051c	6a 01		 push	 1
  0051e	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00524	e8 00 00 00 00	 call	 ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
  00529	8b 45 e8	 mov	 eax, DWORD PTR $T8[ebp+20]
  0052c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00530	83 f8 10	 cmp	 eax, 16			; 00000010H
  00533	72 42		 jb	 SHORT $LN1002@operator
  00535	8b 4d d4	 mov	 ecx, DWORD PTR $T8[ebp]
  00538	40		 inc	 eax
  00539	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0053e	72 2e		 jb	 SHORT $LN997@operator
  00540	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00543	74 05		 je	 SHORT $LN998@operator
  00545	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1099@operator:
$LN998@operator:
  0054a	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0054d	3b c1		 cmp	 eax, ecx
  0054f	72 05		 jb	 SHORT $LN999@operator
  00551	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1100@operator:
$LN999@operator:
  00556	2b c8		 sub	 ecx, eax
  00558	83 f9 04	 cmp	 ecx, 4
  0055b	73 05		 jae	 SHORT $LN1000@operator
  0055d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1101@operator:
$LN1000@operator:
  00562	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00565	76 05		 jbe	 SHORT $LN1001@operator
  00567	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1102@operator:
$LN1001@operator:
  0056c	8b c8		 mov	 ecx, eax
$LN997@operator:
  0056e	51		 push	 ecx
  0056f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00574	83 c4 04	 add	 esp, 4
$LN1002@operator:
  00577	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  0057c	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00582	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  0058c	50		 push	 eax
  0058d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1103@operator:
$LN224@operator:

; 734  : 	return (_Ostr);

  00592	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 9
  00599	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  0059e	8b 75 b0	 mov	 esi, DWORD PTR __Ok$[ebp]
  005a1	84 c0		 test	 al, al
  005a3	75 07		 jne	 SHORT $LN1037@operator
  005a5	8b ce		 mov	 ecx, esi
  005a7	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN1037@operator:
  005ac	8b 06		 mov	 eax, DWORD PTR [esi]
  005ae	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  005b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  005b5	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  005b9	85 c9		 test	 ecx, ecx
  005bb	74 05		 je	 SHORT $LN1041@operator
  005bd	8b 11		 mov	 edx, DWORD PTR [ecx]
  005bf	ff 52 08	 call	 DWORD PTR [edx+8]
$LN1041@operator:
  005c2	8b c7		 mov	 eax, edi

; 735  : 	}

  005c4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  005c7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005ce	59		 pop	 ecx
  005cf	5f		 pop	 edi
  005d0	5e		 pop	 esi
  005d1	5b		 pop	 ebx
  005d2	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$11[ebp]
  005d5	33 cd		 xor	 ecx, ebp
  005d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005dc	8b e5		 mov	 esp, ebp
  005de	5d		 pop	 ebp
  005df	c3		 ret	 0

; 730  : 		_CATCH_IO_(_Ostr)

$LN159@operator:
  005e0	6a 00		 push	 0
  005e2	6a 00		 push	 0
  005e4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1104@operator:
$LN1082@operator:
  005e9	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$4:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$2:
  00008	8d 4d b0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$3:
  00010	8d 4d a4	 lea	 ecx, DWORD PTR $T5[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$5:
  00018	e8 00 00 00 00	 call	 ___std_terminate
  0001d	c3		 ret	 0
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$37:
  0001e	8d 4d d4	 lea	 ecx, DWORD PTR $T10[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$96:
  00026	8d 4d d4	 lea	 ecx, DWORD PTR $T9[ebp]
  00029	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$155:
  0002e	8d 4d d4	 lea	 ecx, DWORD PTR $T8[ebp]
  00031	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$210:
  00036	e8 00 00 00 00	 call	 ___std_terminate
  0003b	c3		 ret	 0
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$211:
  0003c	e8 00 00 00 00	 call	 ___std_terminate
  00041	c3		 ret	 0
__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z:
  00042	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00046	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00049	8b 8a 64 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-156]
  0004f	33 c8		 xor	 ecx, eax
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00059	33 c8		 xor	 ecx, eax
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
  00065	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8d 71 68	 lea	 esi, DWORD PTR [ecx+104]
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0002d	56		 push	 esi
  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  0003b	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00040	83 c4 04	 add	 esp, 4
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	5e		 pop	 esi
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8d 71 98	 lea	 esi, DWORD PTR [ecx-104]
  00026	e8 00 00 00 00	 call	 ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0002b	8d 46 68	 lea	 eax, DWORD PTR [esi+104]
  0002e	50		 push	 eax
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00036	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  0003c	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00041	83 c4 04	 add	 esp, 4
  00044	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00048	74 0e		 je	 SHORT $LN13@scalar
  0004a	68 b0 00 00 00	 push	 176			; 000000b0H
  0004f	56		 push	 esi
  00050	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00055	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00058	8b c6		 mov	 eax, esi
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5e		 pop	 esi
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  0002c	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
  00031	8b 7e 34	 mov	 edi, DWORD PTR [esi+52]
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  0003a	85 ff		 test	 edi, edi
  0003c	74 2a		 je	 SHORT $LN13@scalar
  0003e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00048	85 c9		 test	 ecx, ecx
  0004a	74 11		 je	 SHORT $LN19@scalar
  0004c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004e	ff 50 08	 call	 DWORD PTR [eax+8]
  00051	85 c0		 test	 eax, eax
  00053	74 08		 je	 SHORT $LN19@scalar
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b c8		 mov	 ecx, eax
  00059	6a 01		 push	 1
  0005b	ff 12		 call	 DWORD PTR [edx]
$LN19@scalar:
  0005d	6a 08		 push	 8
  0005f	57		 push	 edi
  00060	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00065	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00068	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0006c	74 0b		 je	 SHORT $LN22@scalar
  0006e	6a 44		 push	 68			; 00000044H
  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00076	83 c4 08	 add	 esp, 8
$LN22@scalar:
  00079	8b c6		 mov	 eax, esi
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEHH@Z
_TEXT	SEGMENT
__Mode$ = 8						; size = 4
?_Getstate@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEHH@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getstate, COMDAT
; _this$ = ecx

; 354  : 		{	// convert open mode to stream state bits

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Mode$[ebp]

; 355  : 		_Strstate _State = (_Strstate)0;
; 356  : 		if (!(_Mode & ios_base::in))
; 357  : 			_State |= _Noread;
; 358  : 		if (!(_Mode & ios_base::out))

  00007	8b c3		 mov	 eax, ebx
  00009	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  00010	f7 d1		 not	 ecx
  00012	83 e1 04	 and	 ecx, 4
  00015	8b d1		 mov	 edx, ecx
  00017	83 ca 02	 or	 edx, 2
  0001a	24 02		 and	 al, 2

; 359  : 			_State |= _Constant;
; 360  : 		if (_Mode & ios_base::app)

  0001c	8b c3		 mov	 eax, ebx
  0001e	0f 45 d1	 cmovne	 edx, ecx
  00021	8b ca		 mov	 ecx, edx
  00023	83 c9 08	 or	 ecx, 8
  00026	24 08		 and	 al, 8
  00028	0f 44 ca	 cmove	 ecx, edx
  0002b	8b c1		 mov	 eax, ecx
  0002d	83 c8 10	 or	 eax, 16			; 00000010H

; 361  : 			_State |= _Append;
; 362  : 		if (_Mode & ios_base::ate)

  00030	80 e3 04	 and	 bl, 4
  00033	5b		 pop	 ebx
  00034	0f 44 c1	 cmove	 eax, ecx

; 363  : 			_State |= _Atend;
; 364  : 		return (_State);
; 365  : 		}

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_Getstate@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEHH@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy, COMDAT
; _this$ = ecx

; 337  : 		{	// discard any allocated buffer and clear pointers

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 338  : 		if (_Mystate & _Allocated)

  00003	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  00007	74 33		 je	 SHORT $LN2@Tidy

; 339  : 			_Al.deallocate(_Mysb::eback(),

  00009	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	85 c9		 test	 ecx, ecx
  00010	74 0a		 je	 SHORT $LN4@Tidy
  00012	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00015	8b 00		 mov	 eax, DWORD PTR [eax]
  00017	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  0001a	eb 0d		 jmp	 SHORT $LN5@Tidy
$LN4@Tidy:
  0001c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
$LN5@Tidy:
  00029	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	2b c8		 sub	 ecx, eax
  00030	d1 f9		 sar	 ecx, 1
  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  00037	e8 00 00 00 00	 call	 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate
$LN2@Tidy:

; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);

  0003c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00045	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00048	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0004e	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 343  : 		_Mysb::setp(0, 0);

  00057	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0005a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00060	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00063	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00069	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0006c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;

  00072	83 66 3c fe	 and	 DWORD PTR [esi+60], -2	; fffffffeH
  00076	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  0007d	5e		 pop	 esi

; 346  : 		}

  0007e	c3		 ret	 0
?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXPB_WIH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
tv270 = 16						; size = 4
__State$ = 16						; size = 4
?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXPB_WIH@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Init, COMDAT
; _this$ = ecx

; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 311  : 		_Seekhigh = 0;
; 312  : 		_Mystate = _State;

  00003	8b 45 10	 mov	 eax, DWORD PTR __State$[ebp]
  00006	53		 push	 ebx

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00014	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00017	85 db		 test	 ebx, ebx
  00019	0f 84 8e 00 00
	00		 je	 $LN2@Init
  0001f	83 e0 06	 and	 eax, 6
  00022	3c 06		 cmp	 al, 6
  00024	0f 84 83 00 00
	00		 je	 $LN2@Init

; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Al.allocate(_Count);

  0002a	57		 push	 edi
  0002b	53		 push	 ebx
  0002c	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  0002f	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  00034	8b f8		 mov	 edi, eax

; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);

  00036	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  00039	50		 push	 eax
  0003a	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0003d	57		 push	 edi
  0003e	e8 00 00 00 00	 call	 _memcpy

; 319  : 			_Seekhigh = _Pnew + _Count;

  00043	8d 14 1b	 lea	 edx, DWORD PTR [ebx+ebx]
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 320  : 
; 321  : 			if (!(_Mystate & _Noread))

  00049	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  0004d	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  00050	89 45 10	 mov	 DWORD PTR tv270[ebp], eax
  00053	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00056	75 0f		 jne	 SHORT $LN3@Init

; 322  : 				_Mysb::setg(_Pnew, _Pnew,

  00058	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0005b	89 38		 mov	 DWORD PTR [eax], edi
  0005d	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00060	89 38		 mov	 DWORD PTR [eax], edi
  00062	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00065	89 18		 mov	 DWORD PTR [eax], ebx
$LN3@Init:

; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))

  00067	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0006a	a8 02		 test	 al, 2
  0006c	75 3a		 jne	 SHORT $LN5@Init

; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,

  0006e	a8 18		 test	 al, 24			; 00000018H
  00070	8b cf		 mov	 ecx, edi
  00072	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00075	0f 45 4d 10	 cmovne	 ecx, DWORD PTR tv270[ebp]
  00079	2b d1		 sub	 edx, ecx
  0007b	03 d7		 add	 edx, edi
  0007d	89 38		 mov	 DWORD PTR [eax], edi
  0007f	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00082	d1 fa		 sar	 edx, 1
  00084	89 08		 mov	 DWORD PTR [eax], ecx
  00086	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00089	89 10		 mov	 DWORD PTR [eax], edx

; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)

  0008b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0008e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00091	75 15		 jne	 SHORT $LN5@Init

; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);

  00093	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00096	89 38		 mov	 DWORD PTR [eax], edi
  00098	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0009b	d1 ff		 sar	 edi, 1
  0009d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000a3	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000a6	89 38		 mov	 DWORD PTR [eax], edi
$LN5@Init:

; 331  : 				}
; 332  : 			_Mystate |= _Allocated;

  000a8	83 4e 3c 01	 or	 DWORD PTR [esi+60], 1
  000ac	5f		 pop	 edi
$LN2@Init:
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx

; 333  : 			}
; 334  : 		}

  000af	5d		 pop	 ebp
  000b0	c2 0c 00	 ret	 12			; 0000000cH
?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXPB_WIH@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
__Off$1$ = -4						; size = 4
tv286 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Ptr$ = 12						; size = 24
__Off$1$ = 36						; size = 4
tv324 = 36						; size = 4
tv297 = 36						; size = 4
__Mode$ = 36						; size = 4
?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekpos, COMDAT
; _this$ = ecx

; 276  : 		{	// change position to _Pos, according to _Mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 277  : 		streamoff _Off = (streamoff)_Ptr;

  00005	8b 5d 18	 mov	 ebx, DWORD PTR __Ptr$[ebp+12]
  00008	56		 push	 esi
  00009	8b 75 14	 mov	 esi, DWORD PTR __Ptr$[ebp+8]
  0000c	03 75 0c	 add	 esi, DWORD PTR __Ptr$[ebp]
  0000f	57		 push	 edi
  00010	13 5d 10	 adc	 ebx, DWORD PTR __Ptr$[ebp+4]
  00013	8b f9		 mov	 edi, ecx

; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  00015	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	85 c0		 test	 eax, eax
  0001c	74 08		 je	 SHORT $LN2@seekpos
  0001e	39 47 38	 cmp	 DWORD PTR [edi+56], eax
  00021	73 03		 jae	 SHORT $LN2@seekpos

; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  00023	89 47 38	 mov	 DWORD PTR [edi+56], eax
$LN2@seekpos:

; 280  : 
; 281  : 		if (_Off == _BADOFF)

  00026	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB+4
  0002b	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  00031	75 08		 jne	 SHORT $LN55@seekpos
  00033	3b d8		 cmp	 ebx, eax
  00035	0f 84 e1 00 00
	00		 je	 $LN11@seekpos
$LN55@seekpos:

; 282  : 			;
; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

  0003b	8b 4d 24	 mov	 ecx, DWORD PTR __Mode$[ebp]
  0003e	f6 c1 01	 test	 cl, 1
  00041	0f 84 83 00 00
	00		 je	 $LN5@seekpos
  00047	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]
  0004c	89 45 fc	 mov	 DWORD PTR tv286[ebp], eax
  0004f	85 c0		 test	 eax, eax
  00051	74 72		 je	 SHORT $LN60@seekpos

; 284  : 			{	// position within read buffer
; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00053	85 db		 test	 ebx, ebx
  00055	7c 66		 jl	 SHORT $LN7@seekpos
  00057	7f 04		 jg	 SHORT $LN56@seekpos
  00059	85 f6		 test	 esi, esi
  0005b	72 60		 jb	 SHORT $LN7@seekpos
$LN56@seekpos:
  0005d	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00065	2b c1		 sub	 eax, ecx
  00067	d1 f8		 sar	 eax, 1
  00069	99		 cdq
  0006a	3b da		 cmp	 ebx, edx
  0006c	7f 4f		 jg	 SHORT $LN7@seekpos
  0006e	7c 04		 jl	 SHORT $LN57@seekpos
  00070	3b f0		 cmp	 esi, eax
  00072	77 49		 ja	 SHORT $LN7@seekpos
$LN57@seekpos:

; 286  : 				{	// change read position
; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  00074	2b 4d fc	 sub	 ecx, DWORD PTR tv286[ebp]
  00077	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0007a	d1 f9		 sar	 ecx, 1
  0007c	03 ce		 add	 ecx, esi
  0007e	89 4d fc	 mov	 DWORD PTR __Off$1$[ebp], ecx
  00081	29 08		 sub	 DWORD PTR [eax], ecx
  00083	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00086	8b 45 fc	 mov	 eax, DWORD PTR __Off$1$[ebp]
  00089	03 c0		 add	 eax, eax
  0008b	01 01		 add	 DWORD PTR [ecx], eax

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  0008d	f6 45 24 02	 test	 BYTE PTR __Mode$[ebp], 2
  00091	0f 84 85 00 00
	00		 je	 $LN11@seekpos
  00097	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	85 c9		 test	 ecx, ecx
  0009e	74 7c		 je	 SHORT $LN11@seekpos

; 289  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),

  000a0	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  000a3	8b 10		 mov	 edx, DWORD PTR [eax]
  000a5	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000a8	8b 00		 mov	 eax, DWORD PTR [eax]
  000aa	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  000ad	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  000b0	2b ca		 sub	 ecx, edx
  000b2	d1 f9		 sar	 ecx, 1
  000b4	89 10		 mov	 DWORD PTR [eax], edx
  000b6	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000b9	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 						_Mysb::epptr());	// change write position to match
; 291  : 				}
; 292  : 			else

  000bb	eb 5f		 jmp	 SHORT $LN11@seekpos
$LN7@seekpos:

; 293  : 				_Off = _BADOFF;

  000bd	8b 1d 04 00 00
	00		 mov	 ebx, DWORD PTR ?_BADOFF@std@@3_JB+4
  000c3	eb 51		 jmp	 SHORT $LN61@seekpos
$LN60@seekpos:
  000c5	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB+4
$LN5@seekpos:

; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  000ca	f6 c1 02	 test	 cl, 2
  000cd	74 45		 je	 SHORT $LN10@seekpos
  000cf	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000d1	89 4d 24	 mov	 DWORD PTR tv297[ebp], ecx
  000d4	85 c9		 test	 ecx, ecx
  000d6	74 3c		 je	 SHORT $LN10@seekpos

; 296  : 			{	// position within write buffer
; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  000d8	85 db		 test	 ebx, ebx
  000da	7c e1		 jl	 SHORT $LN7@seekpos
  000dc	7f 04		 jg	 SHORT $LN58@seekpos
  000de	85 f6		 test	 esi, esi
  000e0	72 db		 jb	 SHORT $LN7@seekpos
$LN58@seekpos:
  000e2	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e7	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  000ea	2b c1		 sub	 eax, ecx
  000ec	d1 f8		 sar	 eax, 1
  000ee	99		 cdq
  000ef	3b da		 cmp	 ebx, edx
  000f1	7f ca		 jg	 SHORT $LN7@seekpos
  000f3	7c 04		 jl	 SHORT $LN59@seekpos
  000f5	3b f0		 cmp	 esi, eax
  000f7	77 c4		 ja	 SHORT $LN7@seekpos
$LN59@seekpos:

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

  000f9	2b 4d 24	 sub	 ecx, DWORD PTR tv297[ebp]
  000fc	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000ff	d1 f9		 sar	 ecx, 1
  00101	03 ce		 add	 ecx, esi
  00103	89 4d 24	 mov	 DWORD PTR __Off$1$[ebp], ecx
  00106	29 08		 sub	 DWORD PTR [eax], ecx
  00108	8b 4f 20	 mov	 ecx, DWORD PTR [edi+32]
  0010b	8b 45 24	 mov	 eax, DWORD PTR __Off$1$[ebp]
  0010e	03 c0		 add	 eax, eax
  00110	01 01		 add	 DWORD PTR [ecx], eax

; 299  : 					- _Mysb::pptr() + _Off));	// change write position
; 300  : 			else

  00112	eb 08		 jmp	 SHORT $LN11@seekpos
$LN10@seekpos:

; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  00114	8b d8		 mov	 ebx, eax
$LN61@seekpos:
  00116	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
$LN11@seekpos:

; 305  : 		return (streampos(_Off));

  0011c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0011f	0f 57 c0	 xorps	 xmm0, xmm0
  00122	5f		 pop	 edi
  00123	89 30		 mov	 DWORD PTR [eax], esi
  00125	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00128	5e		 pop	 esi
  00129	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00130	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00137	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  0013c	5b		 pop	 ebx

; 306  : 		}

  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
tv281 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Off$1$ = 20						; size = 4
__Way$ = 20						; size = 4
__Off$1$ = 24						; size = 4
tv292 = 24						; size = 4
tv287 = 24						; size = 4
__Which$ = 24						; size = 4
?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekoff, COMDAT
; _this$ = ecx

; 227  : 		{	// change position by _Off, according to _Way, _Mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  00009	8b 53 20	 mov	 edx, DWORD PTR [ebx+32]
  0000c	8b 02		 mov	 eax, DWORD PTR [edx]
  0000e	85 c0		 test	 eax, eax
  00010	74 08		 je	 SHORT $LN2@seekoff
  00012	39 43 38	 cmp	 DWORD PTR [ebx+56], eax
  00015	73 03		 jae	 SHORT $LN2@seekoff

; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  00017	89 43 38	 mov	 DWORD PTR [ebx+56], eax
$LN2@seekoff:

; 230  : 
; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

  0001a	8b 4d 18	 mov	 ecx, DWORD PTR __Which$[ebp]
  0001d	f6 c1 01	 test	 cl, 1
  00020	0f 84 e8 00 00
	00		 je	 $LN3@seekoff
  00026	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00029	8b 30		 mov	 esi, DWORD PTR [eax]
  0002b	89 75 fc	 mov	 DWORD PTR tv281[ebp], esi
  0002e	85 f6		 test	 esi, esi
  00030	0f 84 d8 00 00
	00		 je	 $LN3@seekoff

; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)

  00036	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  00039	83 f8 02	 cmp	 eax, 2
  0003c	75 17		 jne	 SHORT $LN5@seekoff

; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  0003e	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00041	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00044	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00047	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0004a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0004c	d1 f8		 sar	 eax, 1
  0004e	99		 cdq
  0004f	03 f0		 add	 esi, eax
  00051	13 fa		 adc	 edi, edx

; 235  : 			else if (_Way == ios_base::cur

  00053	eb 38		 jmp	 SHORT $LN9@seekoff
$LN5@seekoff:

; 236  : 				&& (_Which & ios_base::out) == 0)

  00055	83 f8 01	 cmp	 eax, 1
  00058	75 1b		 jne	 SHORT $LN7@seekoff
  0005a	f6 c1 02	 test	 cl, 2
  0005d	75 1a		 jne	 SHORT $LN74@seekoff

; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());

  0005f	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00062	8b c6		 mov	 eax, esi
  00064	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00067	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0006a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006c	d1 f8		 sar	 eax, 1
  0006e	99		 cdq
  0006f	03 f0		 add	 esi, eax
  00071	13 fa		 adc	 edi, edx
  00073	eb 18		 jmp	 SHORT $LN9@seekoff
$LN7@seekoff:

; 238  : 			else if (_Way != ios_base::beg)

  00075	85 c0		 test	 eax, eax
  00077	74 0e		 je	 SHORT $LN79@seekoff
$LN74@seekoff:

; 239  : 				_Off = _BADOFF;

  00079	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  0007f	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_BADOFF@std@@3_JB+4
  00085	eb 06		 jmp	 SHORT $LN9@seekoff
$LN79@seekoff:
  00087	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0008a	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
$LN9@seekoff:

; 240  : 
; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0008d	85 ff		 test	 edi, edi
  0008f	0f 8c 29 01 00
	00		 jl	 $LN10@seekoff
  00095	7f 08		 jg	 SHORT $LN75@seekoff
  00097	85 f6		 test	 esi, esi
  00099	0f 82 1f 01 00
	00		 jb	 $LN10@seekoff
$LN75@seekoff:
  0009f	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a4	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  000a7	2b c1		 sub	 eax, ecx
  000a9	d1 f8		 sar	 eax, 1
  000ab	99		 cdq
  000ac	3b fa		 cmp	 edi, edx
  000ae	0f 8f 0a 01 00
	00		 jg	 $LN10@seekoff
  000b4	7c 08		 jl	 SHORT $LN76@seekoff
  000b6	3b f0		 cmp	 esi, eax
  000b8	0f 87 00 01 00
	00		 ja	 $LN10@seekoff
$LN76@seekoff:

; 242  : 				{	// change read position
; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  000be	2b 4d fc	 sub	 ecx, DWORD PTR tv281[ebp]
  000c1	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  000c4	d1 f9		 sar	 ecx, 1
  000c6	03 ce		 add	 ecx, esi
  000c8	89 4d 14	 mov	 DWORD PTR __Off$1$[ebp], ecx
  000cb	29 08		 sub	 DWORD PTR [eax], ecx
  000cd	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  000d0	8b 45 14	 mov	 eax, DWORD PTR __Off$1$[ebp]
  000d3	03 c0		 add	 eax, eax
  000d5	01 01		 add	 DWORD PTR [ecx], eax

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000d7	f6 45 18 02	 test	 BYTE PTR __Which$[ebp], 2
  000db	0f 84 e9 00 00
	00		 je	 $LN22@seekoff
  000e1	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  000e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e6	85 c9		 test	 ecx, ecx
  000e8	0f 84 dc 00 00
	00		 je	 $LN22@seekoff

; 245  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),

  000ee	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  000f1	8b 10		 mov	 edx, DWORD PTR [eax]
  000f3	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  000f6	8b 00		 mov	 eax, DWORD PTR [eax]
  000f8	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  000fb	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  000fe	2b ca		 sub	 ecx, edx
  00100	d1 f9		 sar	 ecx, 1
  00102	89 10		 mov	 DWORD PTR [eax], edx
  00104	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  00107	89 08		 mov	 DWORD PTR [eax], ecx

; 246  : 						_Mysb::epptr());	// change write position to match
; 247  : 				}
; 248  : 			else

  00109	e9 bc 00 00 00	 jmp	 $LN22@seekoff
$LN3@seekoff:

; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)

  0010e	f6 c1 02	 test	 cl, 2
  00111	0f 84 9b 00 00
	00		 je	 $LN13@seekoff
  00117	8b 12		 mov	 edx, DWORD PTR [edx]
  00119	89 55 18	 mov	 DWORD PTR tv287[ebp], edx
  0011c	85 d2		 test	 edx, edx
  0011e	0f 84 8e 00 00
	00		 je	 $LN13@seekoff

; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)

  00124	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  00127	83 f8 02	 cmp	 eax, 2
  0012a	75 17		 jne	 SHORT $LN15@seekoff

; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  0012c	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0012f	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00132	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00135	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00138	2b 01		 sub	 eax, DWORD PTR [ecx]
  0013a	d1 f8		 sar	 eax, 1
  0013c	99		 cdq
  0013d	03 f0		 add	 esi, eax
  0013f	13 fa		 adc	 edi, edx
  00141	eb 33		 jmp	 SHORT $LN19@seekoff
$LN15@seekoff:

; 255  : 			else if (_Way == ios_base::cur)

  00143	83 f8 01	 cmp	 eax, 1
  00146	75 16		 jne	 SHORT $LN17@seekoff

; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());

  00148	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0014b	8b c2		 mov	 eax, edx
  0014d	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00150	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00153	2b 01		 sub	 eax, DWORD PTR [ecx]
  00155	d1 f8		 sar	 eax, 1
  00157	99		 cdq
  00158	03 f0		 add	 esi, eax
  0015a	13 fa		 adc	 edi, edx
  0015c	eb 18		 jmp	 SHORT $LN19@seekoff
$LN17@seekoff:

; 257  : 			else if (_Way != ios_base::beg)

  0015e	85 c0		 test	 eax, eax
  00160	74 0e		 je	 SHORT $LN80@seekoff

; 258  : 				_Off = _BADOFF;

  00162	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  00168	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_BADOFF@std@@3_JB+4
  0016e	eb 06		 jmp	 SHORT $LN19@seekoff
$LN80@seekoff:
  00170	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00173	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
$LN19@seekoff:

; 259  : 
; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00176	85 ff		 test	 edi, edi
  00178	7c 44		 jl	 SHORT $LN10@seekoff
  0017a	7f 04		 jg	 SHORT $LN77@seekoff
  0017c	85 f6		 test	 esi, esi
  0017e	72 3e		 jb	 SHORT $LN10@seekoff
$LN77@seekoff:
  00180	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00183	8b 08		 mov	 ecx, DWORD PTR [eax]
  00185	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00188	2b c1		 sub	 eax, ecx
  0018a	d1 f8		 sar	 eax, 1
  0018c	99		 cdq
  0018d	3b fa		 cmp	 edi, edx
  0018f	7f 2d		 jg	 SHORT $LN10@seekoff
  00191	7c 04		 jl	 SHORT $LN78@seekoff
  00193	3b f0		 cmp	 esi, eax
  00195	77 27		 ja	 SHORT $LN10@seekoff
$LN78@seekoff:

; 261  : 				_Mysb::pbump((int)(_Mysb::eback()

  00197	2b 4d 18	 sub	 ecx, DWORD PTR tv287[ebp]
  0019a	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  0019d	d1 f9		 sar	 ecx, 1
  0019f	03 ce		 add	 ecx, esi
  001a1	89 4d 18	 mov	 DWORD PTR __Off$1$[ebp], ecx
  001a4	29 08		 sub	 DWORD PTR [eax], ecx
  001a6	8b 4b 20	 mov	 ecx, DWORD PTR [ebx+32]
  001a9	8b 45 18	 mov	 eax, DWORD PTR __Off$1$[ebp]
  001ac	03 c0		 add	 eax, eax
  001ae	01 01		 add	 DWORD PTR [ecx], eax

; 262  : 					- _Mysb::pptr() + _Off));	// change write position
; 263  : 			else

  001b0	eb 18		 jmp	 SHORT $LN22@seekoff
$LN13@seekoff:

; 264  : 				_Off = _BADOFF;
; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)

  001b2	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  001b5	8b c6		 mov	 eax, esi
  001b7	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  001ba	0b c7		 or	 eax, edi
  001bc	74 0c		 je	 SHORT $LN22@seekoff
$LN10@seekoff:

; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  001be	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  001c4	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_BADOFF@std@@3_JB+4
$LN22@seekoff:

; 271  : 		return (pos_type(_Off));

  001ca	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001cd	0f 57 c0	 xorps	 xmm0, xmm0
  001d0	89 78 04	 mov	 DWORD PTR [eax+4], edi
  001d3	5f		 pop	 edi
  001d4	89 30		 mov	 DWORD PTR [eax], esi
  001d6	5e		 pop	 esi
  001d7	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  001de	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  001e5	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  001ea	5b		 pop	 ebx

; 272  : 		}

  001eb	8b e5		 mov	 esp, ebp
  001ed	5d		 pop	 ebp
  001ee	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGXZ
_TEXT	SEGMENT
?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGXZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::underflow, COMDAT
; _this$ = ecx

; 207  : 		{	// get an element from stream, but don't point past it

  00000	8b d1		 mov	 edx, ecx
  00002	56		 push	 esi
  00003	57		 push	 edi

; 208  : 		if (_Mysb::gptr() == 0)

  00004	8b 7a 1c	 mov	 edi, DWORD PTR [edx+28]
  00007	8b 37		 mov	 esi, DWORD PTR [edi]
  00009	85 f6		 test	 esi, esi
  0000b	75 08		 jne	 SHORT $LN2@underflow

; 209  : 			return (_Traits::eof());	// no character buffer, fail

  0000d	5f		 pop	 edi
  0000e	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00013	5e		 pop	 esi

; 221  : 			}
; 222  : 		}

  00014	c3		 ret	 0
$LN2@underflow:
  00015	53		 push	 ebx

; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())

  00016	8b 5a 2c	 mov	 ebx, DWORD PTR [edx+44]
  00019	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0001b	8d 0c 4e	 lea	 ecx, DWORD PTR [esi+ecx*2]
  0001e	3b f1		 cmp	 esi, ecx
  00020	73 07		 jae	 SHORT $LN4@underflow

; 211  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered

  00022	66 8b 06	 mov	 ax, WORD PTR [esi]
  00025	5b		 pop	 ebx
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 221  : 			}
; 222  : 		}

  00028	c3		 ret	 0
$LN4@underflow:

; 212  : 		else if (_Mystate & _Noread || _Mysb::pptr() == 0
; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

  00029	f6 42 3c 04	 test	 BYTE PTR [edx+60], 4
  0002d	75 2f		 jne	 SHORT $LN8@underflow
  0002f	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	85 c0		 test	 eax, eax
  00036	74 26		 je	 SHORT $LN8@underflow
  00038	3b c6		 cmp	 eax, esi
  0003a	77 05		 ja	 SHORT $LN6@underflow
  0003c	39 72 38	 cmp	 DWORD PTR [edx+56], esi
  0003f	76 1d		 jbe	 SHORT $LN8@underflow
$LN6@underflow:

; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())

  00041	39 42 38	 cmp	 DWORD PTR [edx+56], eax
  00044	73 03		 jae	 SHORT $LN9@underflow

; 218  : 				_Seekhigh = _Mysb::pptr();

  00046	89 42 38	 mov	 DWORD PTR [edx+56], eax
$LN9@underflow:

; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);

  00049	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  0004c	2b 07		 sub	 eax, DWORD PTR [edi]
  0004e	d1 f8		 sar	 eax, 1
  00050	89 03		 mov	 DWORD PTR [ebx], eax

; 220  : 			return (_Traits::to_int_type(*_Mysb::gptr()));

  00052	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00055	5b		 pop	 ebx
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	66 8b 00	 mov	 ax, WORD PTR [eax]

; 221  : 			}
; 222  : 		}

  0005d	c3		 ret	 0
$LN8@underflow:
  0005e	5b		 pop	 ebx
  0005f	5f		 pop	 edi

; 214  : 			return (_Traits::eof());	// can't read, fail

  00060	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00065	5e		 pop	 esi

; 221  : 			}
; 222  : 		}

  00066	c3		 ret	 0
?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGXZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 2
?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::pbackfail, COMDAT
; _this$ = ecx

; 190  : 		{	// put an element back to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 191  : 		if (_Mysb::gptr() == 0
; 192  : 			|| _Mysb::gptr() <= _Mysb::eback()
; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  00003	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	bf ff ff 00 00	 mov	 edi, 65535		; 0000ffffH
  0000d	8b 30		 mov	 esi, DWORD PTR [eax]
  0000f	85 f6		 test	 esi, esi
  00011	74 45		 je	 SHORT $LN4@pbackfail
  00013	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00016	3b 30		 cmp	 esi, DWORD PTR [eax]
  00018	76 3e		 jbe	 SHORT $LN4@pbackfail
  0001a	66 8b 55 08	 mov	 dx, WORD PTR __Meta$[ebp]
  0001e	66 3b fa	 cmp	 di, dx
  00021	74 0c		 je	 SHORT $LN2@pbackfail
  00023	66 3b 56 fe	 cmp	 dx, WORD PTR [esi-2]
  00027	74 06		 je	 SHORT $LN2@pbackfail
  00029	f6 41 3c 02	 test	 BYTE PTR [ecx+60], 2
  0002d	75 29		 jne	 SHORT $LN4@pbackfail
$LN2@pbackfail:

; 197  : 		else
; 198  : 			{	// back up one position and store put-back character
; 199  : 			_Mysb::gbump(-1);

  0002f	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00032	ff 00		 inc	 DWORD PTR [eax]
  00034	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00037	83 00 fe	 add	 DWORD PTR [eax], -2	; fffffffeH

; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))

  0003a	66 3b fa	 cmp	 di, dx
  0003d	74 08		 je	 SHORT $LN45@pbackfail

; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);

  0003f	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00042	8b 00		 mov	 eax, DWORD PTR [eax]
  00044	66 89 10	 mov	 WORD PTR [eax], dx

; 202  : 			return (_Traits::not_eof(_Meta));

$LN45@pbackfail:
  00047	33 c9		 xor	 ecx, ecx
  00049	0f b7 c2	 movzx	 eax, dx
  0004c	66 3b d7	 cmp	 dx, di
  0004f	5f		 pop	 edi
  00050	0f 44 c1	 cmove	 eax, ecx
  00053	5e		 pop	 esi

; 203  : 			}
; 204  : 		}

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN4@pbackfail:

; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail

  00058	66 8b c7	 mov	 ax, di
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi

; 203  : 			}
; 204  : 		}

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z
_TEXT	SEGMENT
__Newsize$1$ = -8					; size = 4
__Oldptr$1$ = -4					; size = 4
__Meta$ = 8						; size = 2
?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::overflow, COMDAT
; _this$ = ecx

; 120  : 		{	// put an element to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 121  : 		if (_Mystate & _Constant)

  00009	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0000c	a8 02		 test	 al, 2
  0000e	74 0c		 je	 SHORT $LN4@overflow

; 122  : 			return (_Traits::eof());	// array nonmutable, fail

  00010	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00015	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN4@overflow:
  0001c	53		 push	 ebx

; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  0001d	66 8b 5d 08	 mov	 bx, WORD PTR __Meta$[ebp]
  00021	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00026	66 3b cb	 cmp	 cx, bx
  00029	75 0a		 jne	 SHORT $LN6@overflow

; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  0002b	5b		 pop	 ebx
  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN6@overflow:
  00035	57		 push	 edi

; 125  : 
; 126  : 		if (_Mystate & _Append
; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

  00036	a8 08		 test	 al, 8
  00038	74 23		 je	 SHORT $LN7@overflow
  0003a	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  0003d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0003f	85 c9		 test	 ecx, ecx
  00041	74 1a		 je	 SHORT $LN7@overflow
  00043	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  00046	3b ca		 cmp	 ecx, edx
  00048	73 13		 jae	 SHORT $LN7@overflow

; 128  : 			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());

  0004a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0004d	8b 00		 mov	 eax, DWORD PTR [eax]
  0004f	89 17		 mov	 DWORD PTR [edi], edx
  00051	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  00054	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00057	2b ca		 sub	 ecx, edx
  00059	d1 f9		 sar	 ecx, 1
  0005b	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@overflow:

; 129  : 
; 130  : 		if (_Mysb::pptr() != 0
; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

  0005d	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	85 c9		 test	 ecx, ecx
  00064	74 2e		 je	 SHORT $LN121@overflow
  00066	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00069	8b 3a		 mov	 edi, DWORD PTR [edx]
  0006b	8d 04 79	 lea	 eax, DWORD PTR [ecx+edi*2]
  0006e	3b c8		 cmp	 ecx, eax
  00070	73 1e		 jae	 SHORT $LN8@overflow

; 132  : 			{	// room in buffer, store it
; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  00072	8d 4f ff	 lea	 ecx, DWORD PTR [edi-1]

; 134  : 			return (_Meta);

  00075	66 8b c3	 mov	 ax, bx
  00078	89 0a		 mov	 DWORD PTR [edx], ecx
  0007a	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  0007d	5f		 pop	 edi
  0007e	8b 32		 mov	 esi, DWORD PTR [edx]
  00080	8d 4e 02	 lea	 ecx, DWORD PTR [esi+2]
  00083	89 0a		 mov	 DWORD PTR [edx], ecx
  00085	66 89 1e	 mov	 WORD PTR [esi], bx
  00088	5b		 pop	 ebx
  00089	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
$LN8@overflow:

; 135  : 			}
; 136  : 		else
; 137  : 			{	// grow buffer and store element
; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

  00090	85 c9		 test	 ecx, ecx
  00092	75 04		 jne	 SHORT $LN20@overflow
$LN121@overflow:
  00094	33 ff		 xor	 edi, edi
  00096	eb 10		 jmp	 SHORT $LN21@overflow
$LN20@overflow:
  00098	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0009b	8b 38		 mov	 edi, DWORD PTR [eax]
  0009d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000a0	03 ff		 add	 edi, edi
  000a2	2b 38		 sub	 edi, DWORD PTR [eax]
  000a4	03 f9		 add	 edi, ecx
  000a6	d1 ff		 sar	 edi, 1
$LN21@overflow:

; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE

  000a8	8b cf		 mov	 ecx, edi
  000aa	d1 e9		 shr	 ecx, 1
  000ac	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000af	73 07		 jae	 SHORT $LN22@overflow
  000b1	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000b6	eb 08		 jmp	 SHORT $LL2@overflow
$LN22@overflow:

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  000b8	85 c9		 test	 ecx, ecx
  000ba	74 17		 je	 SHORT $LN123@overflow
  000bc	0f 1f 40 00	 npad	 4
$LL2@overflow:
  000c0	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000c5	2b c1		 sub	 eax, ecx
  000c7	3b c7		 cmp	 eax, edi
  000c9	73 04		 jae	 SHORT $LN116@overflow

; 145  : 				_Inc /= 2;	// increment causes overflow, halve it

  000cb	d1 e9		 shr	 ecx, 1

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  000cd	75 f1		 jne	 SHORT $LL2@overflow
$LN116@overflow:

; 146  : 			if (_Inc == 0)

  000cf	85 c9		 test	 ecx, ecx
  000d1	75 0e		 jne	 SHORT $LN10@overflow
$LN123@overflow:
  000d3	5f		 pop	 edi
  000d4	5b		 pop	 ebx

; 147  : 				return (_Traits::eof());	// buffer can't grow, fail

  000d5	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  000da	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c2 04 00	 ret	 4
$LN10@overflow:

; 148  : 
; 149  : 			_Newsize += _Inc;

  000e1	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]

; 150  : 
; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);

  000e4	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  000e7	89 45 f8	 mov	 DWORD PTR __Newsize$1$[ebp], eax
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate

; 152  : 			_Elem *_Oldptr = _Mysb::eback();

  000f0	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  000f3	8b d8		 mov	 ebx, eax
  000f5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f7	89 55 fc	 mov	 DWORD PTR __Oldptr$1$[ebp], edx

; 153  : 
; 154  : 			if (0 < _Oldsize)

  000fa	85 ff		 test	 edi, edi
  000fc	74 15		 je	 SHORT $LN125@overflow

; 155  : 				_Traits::copy(_Newptr, _Oldptr, _Oldsize);

  000fe	8d 0c 3f	 lea	 ecx, DWORD PTR [edi+edi]
  00101	51		 push	 ecx
  00102	52		 push	 edx
  00103	53		 push	 ebx
  00104	e8 00 00 00 00	 call	 _memcpy
  00109	8b 55 fc	 mov	 edx, DWORD PTR __Oldptr$1$[ebp]
  0010c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 156  : 
; 157  : 			if (_Oldsize == 0)

  0010f	85 ff		 test	 edi, edi
  00111	75 45		 jne	 SHORT $LN12@overflow
$LN125@overflow:

; 158  : 				{	// first growth, set up pointers
; 159  : 				_Seekhigh = _Newptr;
; 160  : 				_Mysb::setp(_Newptr, _Newptr + _Newsize);

  00113	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00116	8b 4d f8	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]
  00119	89 5e 38	 mov	 DWORD PTR [esi+56], ebx
  0011c	89 18		 mov	 DWORD PTR [eax], ebx
  0011e	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00121	89 18		 mov	 DWORD PTR [eax], ebx
  00123	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00126	89 08		 mov	 DWORD PTR [eax], ecx

; 161  : 				if (_Mystate & _Noread)
; 162  : 					_Mysb::setg(_Newptr, 0, _Newptr);

  00128	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0012b	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  0012f	89 18		 mov	 DWORD PTR [eax], ebx
  00131	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00134	74 12		 je	 SHORT $LN14@overflow
  00136	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0013c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0013f	d1 fb		 sar	 ebx, 1
  00141	89 18		 mov	 DWORD PTR [eax], ebx

; 163  : 				else

  00143	e9 92 00 00 00	 jmp	 $LN17@overflow
$LN14@overflow:

; 164  : 					_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);

  00148	89 18		 mov	 DWORD PTR [eax], ebx
  0014a	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0014d	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 165  : 				}
; 166  : 			else

  00153	e9 82 00 00 00	 jmp	 $LN17@overflow
$LN12@overflow:

; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);

  00158	8b 46 38	 mov	 eax, DWORD PTR [esi+56]

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

  0015b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0015e	2b c2		 sub	 eax, edx
  00160	d1 f8		 sar	 eax, 1
  00162	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  00165	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00168	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0016b	8b 00		 mov	 eax, DWORD PTR [eax]
  0016d	2b c2		 sub	 eax, edx
  0016f	d1 f8		 sar	 eax, 1
  00171	8d 14 43	 lea	 edx, DWORD PTR [ebx+eax*2]
  00174	8b 01		 mov	 eax, DWORD PTR [ecx]
  00176	2b 45 fc	 sub	 eax, DWORD PTR __Oldptr$1$[ebp]
  00179	d1 f8		 sar	 eax, 1
  0017b	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  0017e	89 01		 mov	 DWORD PTR [ecx], eax
  00180	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00183	8b 4d f8	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]
  00186	03 c9		 add	 ecx, ecx
  00188	2b ca		 sub	 ecx, edx
  0018a	89 10		 mov	 DWORD PTR [eax], edx
  0018c	03 cb		 add	 ecx, ebx
  0018e	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00191	d1 f9		 sar	 ecx, 1
  00193	89 08		 mov	 DWORD PTR [eax], ecx

; 170  : 					_Newptr + (_Mysb::pptr() - _Oldptr),
; 171  : 					_Newptr + _Newsize);
; 172  : 				if (_Mystate & _Noread)

  00195	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  00199	74 17		 je	 SHORT $LN16@overflow

; 173  : 					_Mysb::setg(_Newptr, 0, _Newptr);

  0019b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0019e	89 18		 mov	 DWORD PTR [eax], ebx
  001a0	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001a3	d1 fb		 sar	 ebx, 1
  001a5	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  001ab	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  001ae	89 18		 mov	 DWORD PTR [eax], ebx

; 174  : 				else

  001b0	eb 28		 jmp	 SHORT $LN17@overflow
$LN16@overflow:

; 175  : 					_Mysb::setg(_Newptr,

  001b2	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  001b5	8b 10		 mov	 edx, DWORD PTR [eax]
  001b7	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001ba	8b 00		 mov	 eax, DWORD PTR [eax]
  001bc	2b 45 fc	 sub	 eax, DWORD PTR __Oldptr$1$[ebp]
  001bf	d1 f8		 sar	 eax, 1
  001c1	8d 0c 43	 lea	 ecx, DWORD PTR [ebx+eax*2]
  001c4	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  001c7	2b d1		 sub	 edx, ecx
  001c9	83 c2 02	 add	 edx, 2
  001cc	d1 fa		 sar	 edx, 1
  001ce	89 18		 mov	 DWORD PTR [eax], ebx
  001d0	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001d3	89 08		 mov	 DWORD PTR [eax], ecx
  001d5	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  001d8	89 10		 mov	 DWORD PTR [eax], edx
$LN17@overflow:

; 176  : 						_Newptr + (_Mysb::gptr() - _Oldptr),
; 177  : 						_Mysb::pptr() + 1);
; 178  : 				}
; 179  : 
; 180  : 			if (_Mystate & _Allocated)

  001da	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  001de	74 0c		 je	 SHORT $LN18@overflow

; 181  : 				_Al.deallocate(_Oldptr, _Oldsize);

  001e0	57		 push	 edi
  001e1	ff 75 fc	 push	 DWORD PTR __Oldptr$1$[ebp]
  001e4	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  001e7	e8 00 00 00 00	 call	 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate
$LN18@overflow:

; 182  : 			_Mystate |= _Allocated;
; 183  : 
; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  001ec	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  001ef	83 4e 3c 01	 or	 DWORD PTR [esi+60], 1
  001f3	5f		 pop	 edi
  001f4	5b		 pop	 ebx
  001f5	ff 08		 dec	 DWORD PTR [eax]
  001f7	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  001fa	5e		 pop	 esi
  001fb	8b 11		 mov	 edx, DWORD PTR [ecx]
  001fd	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00200	89 01		 mov	 DWORD PTR [ecx], eax
  00202	66 8b 45 08	 mov	 ax, WORD PTR __Meta$[ebp]
  00206	66 89 02	 mov	 WORD PTR [edx], ax

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  00209	8b e5		 mov	 esp, ebp
  0020b	5d		 pop	 ebp
  0020c	c2 04 00	 ret	 4
?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MAEGG@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?str@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
$T1 = -32						; size = 4
__Nul$2 = -28						; size = 24
__Str$3 = -28						; size = 24
__Str$4 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str, COMDAT
; _this$ = ecx

; 93   : 		{	// return string copy of character array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b d1		 mov	 edx, ecx
  00012	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00019	56		 push	 esi
  0001a	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  0001d	8b 4a 3c	 mov	 ecx, DWORD PTR [edx+60]
  00020	f6 c1 02	 test	 cl, 2
  00023	75 66		 jne	 SHORT $LN2@str
  00025	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	85 c0		 test	 eax, eax
  0002c	74 5d		 je	 SHORT $LN2@str

; 95   : 			{	// writable, make string from write buffer
; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  0002e	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  00031	3b c8		 cmp	 ecx, eax
  00033	0f 42 c8	 cmovb	 ecx, eax
  00036	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00039	33 d2		 xor	 edx, edx
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	2b c8		 sub	 ecx, eax
  0003f	d1 f9		 sar	 ecx, 1
  00041	51		 push	 ecx
  00042	50		 push	 eax
  00043	8d 4d e4	 lea	 ecx, DWORD PTR __Str$4[ebp]
  00046	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR __Str$4[ebp+20], 7
  0004d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Str$4[ebp+16], 0
  00054	66 89 55 e4	 mov	 WORD PTR __Str$4[ebp], dx
  00058	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
; 98   : 			return (_Str);

  0005d	33 c0		 xor	 eax, eax
  0005f	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00066	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0006d	8b ce		 mov	 ecx, esi
  0006f	66 89 06	 mov	 WORD PTR [esi], ax
  00072	8d 45 e4	 lea	 eax, DWORD PTR __Str$4[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  0007b	8b 4d f8	 mov	 ecx, DWORD PTR __Str$4[ebp+20]
  0007e	83 f9 08	 cmp	 ecx, 8
  00081	0f 82 8d 00 00
	00		 jb	 $LN950@str
  00087	41		 inc	 ecx
  00088	51		 push	 ecx
  00089	eb 7e		 jmp	 SHORT $LN1047@str
$LN2@str:

; 99   : 			}
; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  0008b	f6 c1 04	 test	 cl, 4
  0008e	75 41		 jne	 SHORT $LN4@str
  00090	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00093	8b 08		 mov	 ecx, DWORD PTR [eax]
  00095	85 c9		 test	 ecx, ecx
  00097	74 38		 je	 SHORT $LN4@str

; 101  : 			{	// readable, make string from read buffer
; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());

  00099	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0009c	8b 00		 mov	 eax, DWORD PTR [eax]
  0009e	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  000a1	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000a4	33 d2		 xor	 edx, edx
  000a6	8b 00		 mov	 eax, DWORD PTR [eax]
  000a8	2b c8		 sub	 ecx, eax
  000aa	d1 f9		 sar	 ecx, 1
  000ac	51		 push	 ecx
  000ad	50		 push	 eax
  000ae	8d 4d e4	 lea	 ecx, DWORD PTR __Str$3[ebp]
  000b1	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR __Str$3[ebp+20], 7
  000b8	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Str$3[ebp+16], 0
  000bf	66 89 55 e4	 mov	 WORD PTR __Str$3[ebp], dx
  000c3	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 103  : 			return (_Str);

  000c8	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000cf	eb 17		 jmp	 SHORT $LN1050@str
$LN4@str:

; 104  : 			}
; 105  : 		else
; 106  : 			{	// inaccessible, return empty string
; 107  : 			_Mystr _Nul;

  000d1	33 c0		 xor	 eax, eax
  000d3	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR __Nul$2[ebp+20], 7
  000da	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Nul$2[ebp+16], 0
  000e1	66 89 45 e4	 mov	 WORD PTR __Nul$2[ebp], ax

; 108  : 			return (_Nul);

  000e5	89 46 10	 mov	 DWORD PTR [esi+16], eax
$LN1050@str:
  000e8	33 c0		 xor	 eax, eax
  000ea	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  000f1	66 89 06	 mov	 WORD PTR [esi], ax
  000f4	8b ce		 mov	 ecx, esi
  000f6	8d 45 e4	 lea	 eax, DWORD PTR __Nul$2[ebp]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  000ff	8b 45 f8	 mov	 eax, DWORD PTR __Nul$2[ebp+20]
  00102	83 f8 08	 cmp	 eax, 8
  00105	72 0d		 jb	 SHORT $LN950@str
  00107	40		 inc	 eax
  00108	50		 push	 eax
$LN1047@str:
  00109	ff 75 e4	 push	 DWORD PTR __Nul$2[ebp]
  0010c	8d 4d e4	 lea	 ecx, DWORD PTR __Nul$2[ebp]
  0010f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN950@str:

; 109  : 			}
; 110  : 		}

  00114	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00117	8b c6		 mov	 eax, esi
  00119	33 cd		 xor	 ecx, ebp
  0011b	5e		 pop	 esi
  0011c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 04 00	 ret	 4
?str@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 75   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@

; 76   : 		_Tidy();

  0002b	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy

; 77   : 		}

  00030	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  00036	8b 76 34	 mov	 esi, DWORD PTR [esi+52]
  00039	85 f6		 test	 esi, esi
  0003b	74 2a		 je	 SHORT $LN9@basic_stri
  0003d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	85 c9		 test	 ecx, ecx
  00049	74 11		 je	 SHORT $LN15@basic_stri
  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	ff 50 08	 call	 DWORD PTR [eax+8]
  00050	85 c0		 test	 eax, eax
  00052	74 08		 je	 SHORT $LN15@basic_stri
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	8b c8		 mov	 ecx, eax
  00058	6a 01		 push	 1
  0005a	ff 12		 call	 DWORD PTR [edx]
$LN15@basic_stri:
  0005c	6a 08		 push	 8
  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00064	83 c4 08	 add	 esp, 8
$LN9@basic_stri:
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00071	59		 pop	 ecx
  00072	5e		 pop	 esi
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$ = 8						; size = 4
??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 28   : 	explicit basic_stringbuf(ios_base::openmode _Mode =

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode

  0002a	e8 00 00 00 00	 call	 ??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
  0002f	8b 5d 08	 mov	 ebx, DWORD PTR __Mode$[ebp]

; 31   : 		_Init(0, 0, _Getstate(_Mode));

  00032	8b c3		 mov	 eax, ebx
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  0003a	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00041	8d 14 9d 00 00
	00 00		 lea	 edx, DWORD PTR [ebx*4]
  00048	f7 d2		 not	 edx
  0004a	83 e2 04	 and	 edx, 4
  0004d	8b ca		 mov	 ecx, edx
  0004f	83 c9 02	 or	 ecx, 2
  00052	24 02		 and	 al, 2
  00054	8b c3		 mov	 eax, ebx
  00056	0f 45 ca	 cmovne	 ecx, edx
  00059	8b d1		 mov	 edx, ecx
  0005b	83 ca 08	 or	 edx, 8
  0005e	24 08		 and	 al, 8
  00060	0f 44 d1	 cmove	 edx, ecx
  00063	8b c2		 mov	 eax, edx
  00065	83 c8 10	 or	 eax, 16			; 00000010H
  00068	80 e3 04	 and	 bl, 4
  0006b	0f 44 c2	 cmove	 eax, edx
  0006e	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 32   : 		}

  00071	8b c6		 mov	 eax, esi
  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
__ehhandler$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	8b 7e 34	 mov	 edi, DWORD PTR [esi+52]
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  0002f	85 ff		 test	 edi, edi
  00031	74 2a		 je	 SHORT $LN10@scalar
  00033	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	85 c9		 test	 ecx, ecx
  0003f	74 11		 je	 SHORT $LN16@scalar
  00041	8b 01		 mov	 eax, DWORD PTR [ecx]
  00043	ff 50 08	 call	 DWORD PTR [eax+8]
  00046	85 c0		 test	 eax, eax
  00048	74 08		 je	 SHORT $LN16@scalar
  0004a	8b 10		 mov	 edx, DWORD PTR [eax]
  0004c	8b c8		 mov	 ecx, eax
  0004e	6a 01		 push	 1
  00050	ff 12		 call	 DWORD PTR [edx]
$LN16@scalar:
  00052	6a 08		 push	 8
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0005a	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0005d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00061	74 0b		 je	 SHORT $LN19@scalar
  00063	6a 38		 push	 56			; 00000038H
  00065	56		 push	 esi
  00066	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006b	83 c4 08	 add	 esp, 8
$LN19@scalar:
  0006e	8b c6		 mov	 eax, esi
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::imbue, COMDAT
; _this$ = ecx

; 449  : 		}

  00000	c2 04 00	 ret	 4
?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sync, COMDAT
; _this$ = ecx

; 444  : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 445  : 		}

  00002	c3		 ret	 0
?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setbuf, COMDAT
; _this$ = ecx

; 439  : 		return (this);

  00000	8b c1		 mov	 eax, ecx

; 440  : 		}

  00002	c2 0c 00	 ret	 12			; 0000000cH
?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekpos, COMDAT
; _this$ = ecx

; 433  : 		{	// change to specified position, according to mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 434  : 		return (streampos(_BADOFF));

  00003	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB
  0000e	89 02		 mov	 DWORD PTR [edx], eax
  00010	8b c2		 mov	 eax, edx
  00012	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3_JB+4
  00018	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0001b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00022	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  00029	66 0f d6 42 10	 movq	 QWORD PTR [edx+16], xmm0

; 435  : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 8
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekoff, COMDAT
; _this$ = ecx

; 427  : 		{	// change position by offset, according to way and mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  : 		return (streampos(_BADOFF));

  00003	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB
  0000e	89 02		 mov	 DWORD PTR [edx], eax
  00010	8b c2		 mov	 eax, edx
  00012	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3_JB+4
  00018	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0001b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00022	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  00029	66 0f d6 42 10	 movq	 QWORD PTR [edx+16], xmm0

; 429  : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z
_TEXT	SEGMENT
__Copied$ = -16						; size = 8
__Size$2$ = -12						; size = 4
_this$1$ = -8						; size = 4
__Copied$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
__Copied$2$ = 16					; size = 4
?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsputn, COMDAT
; _this$ = ecx

; 397  : 		{	// put _Count characters to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 398  : 		streamsize _Size, _Copied;
; 399  : 
; 400  : 		for (_Copied = 0; 0 < _Count; )

  00007	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp+4]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  00010	66 0f 13 45 f0	 movlpd	 QWORD PTR __Copied$[ebp], xmm0
  00015	57		 push	 edi
  00016	85 db		 test	 ebx, ebx
  00018	0f 8c cd 00 00
	00		 jl	 $LN40@xsputn
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00021	7f 08		 jg	 SHORT $LN39@xsputn
  00023	85 ff		 test	 edi, edi
  00025	0f 84 c0 00 00
	00		 je	 $LN40@xsputn
$LN39@xsputn:
  0002b	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  00031	89 55 10	 mov	 DWORD PTR __Copied$2$[ebp], edx
  00034	89 45 fc	 mov	 DWORD PTR __Copied$1$[ebp], eax
  00037	56		 push	 esi
$LL2@xsputn:

; 401  : 			if (0 < (_Size = _Pnavail()))

  00038	e8 00 00 00 00	 call	 ?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pnavail
  0003d	8b f0		 mov	 esi, eax
  0003f	8b c2		 mov	 eax, edx
  00041	89 45 f4	 mov	 DWORD PTR __Size$2$[ebp], eax
  00044	85 c0		 test	 eax, eax
  00046	7c 50		 jl	 SHORT $LN5@xsputn
  00048	7f 04		 jg	 SHORT $LN35@xsputn
  0004a	85 f6		 test	 esi, esi
  0004c	74 4a		 je	 SHORT $LN5@xsputn
$LN35@xsputn:

; 402  : 				{	// copy to write buffer
; 403  : 				if (_Count < _Size)

  0004e	3b d8		 cmp	 ebx, eax
  00050	7f 0b		 jg	 SHORT $LN7@xsputn
  00052	7c 04		 jl	 SHORT $LN36@xsputn
  00054	3b fe		 cmp	 edi, esi
  00056	73 05		 jae	 SHORT $LN7@xsputn
$LN36@xsputn:

; 404  : 					_Size = _Count;

  00058	8b f7		 mov	 esi, edi
  0005a	89 5d f4	 mov	 DWORD PTR __Size$2$[ebp], ebx
$LN7@xsputn:

; 405  : 				_Traits::copy(pptr(), _Ptr, (size_t)_Size);

  0005d	85 f6		 test	 esi, esi
  0005f	74 18		 je	 SHORT $LN16@xsputn
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00064	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  00067	50		 push	 eax
  00068	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	50		 push	 eax
  0006c	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0006f	ff 30		 push	 DWORD PTR [eax]
  00071	e8 00 00 00 00	 call	 _memcpy
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@xsputn:

; 406  : 				_Ptr += _Size;
; 407  : 				_Copied += _Size;

  00079	01 75 fc	 add	 DWORD PTR __Copied$1$[ebp], esi
  0007c	8d 14 36	 lea	 edx, DWORD PTR [esi+esi]
  0007f	8b 45 f4	 mov	 eax, DWORD PTR __Size$2$[ebp]
  00082	11 45 10	 adc	 DWORD PTR __Copied$2$[ebp], eax

; 408  : 				_Count -= _Size;

  00085	2b fe		 sub	 edi, esi

; 409  : 				pbump((int)_Size);

  00087	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0008a	1b d8		 sbb	 ebx, eax
  0008c	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0008f	29 30		 sub	 DWORD PTR [eax], esi
  00091	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00094	01 10		 add	 DWORD PTR [eax], edx
  00096	eb 2f		 jmp	 SHORT $LN9@xsputn
$LN5@xsputn:

; 410  : 				}
; 411  : 			else if (_Traits::eq_int_type(_Traits::eof(),

  00098	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0009b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0009e	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a0	0f b7 00	 movzx	 eax, WORD PTR [eax]
  000a3	50		 push	 eax
  000a4	ff 52 0c	 call	 DWORD PTR [edx+12]
  000a7	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  000ac	66 3b c8	 cmp	 cx, ax
  000af	74 2b		 je	 SHORT $LN42@xsputn

; 412  : 				overflow(_Traits::to_int_type(*_Ptr))))
; 413  : 				break;	// single character put failed, quit
; 414  : 			else
; 415  : 				{	// count character successfully put
; 416  : 				++_Ptr;
; 417  : 				++_Copied;

  000b1	83 45 fc 01	 add	 DWORD PTR __Copied$1$[ebp], 1

; 418  : 				--_Count;

  000b5	ba 02 00 00 00	 mov	 edx, 2
  000ba	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000bd	83 55 10 00	 adc	 DWORD PTR __Copied$2$[ebp], 0
  000c1	83 c7 ff	 add	 edi, -1
  000c4	83 d3 ff	 adc	 ebx, -1
$LN9@xsputn:

; 398  : 		streamsize _Size, _Copied;
; 399  : 
; 400  : 		for (_Copied = 0; 0 < _Count; )

  000c7	01 55 08	 add	 DWORD PTR __Ptr$[ebp], edx
  000ca	85 db		 test	 ebx, ebx
  000cc	0f 8f 66 ff ff
	ff		 jg	 $LL2@xsputn
  000d2	7c 08		 jl	 SHORT $LN42@xsputn
  000d4	85 ff		 test	 edi, edi
  000d6	0f 85 5c ff ff
	ff		 jne	 $LL2@xsputn
$LN42@xsputn:
  000dc	8b 55 10	 mov	 edx, DWORD PTR __Copied$2$[ebp]
  000df	8b 45 fc	 mov	 eax, DWORD PTR __Copied$1$[ebp]
  000e2	5e		 pop	 esi
  000e3	5f		 pop	 edi
  000e4	5b		 pop	 ebx

; 419  : 				}
; 420  : 
; 421  : 		return (_Copied);
; 422  : 		}

  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 0c 00	 ret	 12			; 0000000cH
$LN40@xsputn:

; 398  : 		streamsize _Size, _Copied;
; 399  : 
; 400  : 		for (_Copied = 0; 0 < _Count; )

  000eb	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  000ee	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  000f1	5f		 pop	 edi
  000f2	5b		 pop	 ebx

; 419  : 				}
; 420  : 
; 421  : 		return (_Copied);
; 422  : 		}

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 0c 00	 ret	 12			; 0000000cH
?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsputn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z
_TEXT	SEGMENT
__Copied$ = -16						; size = 8
__Size$2$ = -12						; size = 4
_this$1$ = -8						; size = 4
__Copied$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
__Copied$2$ = 16					; size = 4
?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsgetn, COMDAT
; _this$ = ecx

; 368  : 		{	// get _Count characters from stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 369  : 		int_type _Meta;
; 370  : 		streamsize _Size, _Copied;
; 371  : 
; 372  : 		for (_Copied = 0; 0 < _Count; )

  00007	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp+4]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  00010	66 0f 13 45 f0	 movlpd	 QWORD PTR __Copied$[ebp], xmm0
  00015	57		 push	 edi
  00016	85 db		 test	 ebx, ebx
  00018	0f 8c d3 00 00
	00		 jl	 $LN40@xsgetn
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00021	7f 08		 jg	 SHORT $LN39@xsgetn
  00023	85 ff		 test	 edi, edi
  00025	0f 84 c6 00 00
	00		 je	 $LN40@xsgetn
$LN39@xsgetn:
  0002b	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  00031	89 55 10	 mov	 DWORD PTR __Copied$2$[ebp], edx
  00034	89 45 fc	 mov	 DWORD PTR __Copied$1$[ebp], eax
  00037	56		 push	 esi
$LL2@xsgetn:

; 373  : 			if (0 < (_Size = _Gnavail()))

  00038	e8 00 00 00 00	 call	 ?_Gnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gnavail
  0003d	8b f0		 mov	 esi, eax
  0003f	8b c2		 mov	 eax, edx
  00041	89 45 f4	 mov	 DWORD PTR __Size$2$[ebp], eax
  00044	85 c0		 test	 eax, eax
  00046	7c 52		 jl	 SHORT $LN5@xsgetn
  00048	7f 04		 jg	 SHORT $LN35@xsgetn
  0004a	85 f6		 test	 esi, esi
  0004c	74 4c		 je	 SHORT $LN5@xsgetn
$LN35@xsgetn:

; 374  : 				{	// copy from read buffer
; 375  : 				if (_Count < _Size)

  0004e	3b d8		 cmp	 ebx, eax
  00050	7f 0b		 jg	 SHORT $LN7@xsgetn
  00052	7c 04		 jl	 SHORT $LN36@xsgetn
  00054	3b fe		 cmp	 edi, esi
  00056	73 05		 jae	 SHORT $LN7@xsgetn
$LN36@xsgetn:

; 376  : 					_Size = _Count;

  00058	8b f7		 mov	 esi, edi
  0005a	89 5d f4	 mov	 DWORD PTR __Size$2$[ebp], ebx
$LN7@xsgetn:

; 377  : 				_Traits::copy(_Ptr, gptr(), (size_t)_Size);

  0005d	85 f6		 test	 esi, esi
  0005f	74 17		 je	 SHORT $LN16@xsgetn
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00064	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  00067	50		 push	 eax
  00068	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0006b	ff 30		 push	 DWORD PTR [eax]
  0006d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00070	e8 00 00 00 00	 call	 _memcpy
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@xsgetn:

; 378  : 				_Ptr += _Size;
; 379  : 				_Copied += _Size;

  00078	01 75 fc	 add	 DWORD PTR __Copied$1$[ebp], esi
  0007b	8d 14 36	 lea	 edx, DWORD PTR [esi+esi]
  0007e	8b 45 f4	 mov	 eax, DWORD PTR __Size$2$[ebp]
  00081	11 45 10	 adc	 DWORD PTR __Copied$2$[ebp], eax

; 380  : 				_Count -= _Size;

  00084	2b fe		 sub	 edi, esi

; 381  : 				gbump((int)_Size);

  00086	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00089	1b d8		 sbb	 ebx, eax
  0008b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0008e	29 30		 sub	 DWORD PTR [eax], esi
  00090	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00093	01 10		 add	 DWORD PTR [eax], edx
  00095	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00098	eb 31		 jmp	 SHORT $LN9@xsgetn
$LN5@xsgetn:

; 382  : 				}
; 383  : 			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0009d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009f	ff 50 1c	 call	 DWORD PTR [eax+28]
  000a2	0f b7 c8	 movzx	 ecx, ax
  000a5	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  000aa	66 3b c1	 cmp	 ax, cx
  000ad	74 33		 je	 SHORT $LN42@xsgetn

; 384  : 				break;	// end of file, quit
; 385  : 			else
; 386  : 				{	// get a single character
; 387  : 				*_Ptr++ = _Traits::to_char_type(_Meta);
; 388  : 				++_Copied;

  000af	83 45 fc 01	 add	 DWORD PTR __Copied$1$[ebp], 1

; 389  : 				--_Count;

  000b3	ba 02 00 00 00	 mov	 edx, 2
  000b8	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000bb	83 55 10 00	 adc	 DWORD PTR __Copied$2$[ebp], 0
  000bf	83 c7 ff	 add	 edi, -1
  000c2	83 d3 ff	 adc	 ebx, -1
  000c5	66 89 08	 mov	 WORD PTR [eax], cx
  000c8	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
$LN9@xsgetn:

; 369  : 		int_type _Meta;
; 370  : 		streamsize _Size, _Copied;
; 371  : 
; 372  : 		for (_Copied = 0; 0 < _Count; )

  000cb	03 c2		 add	 eax, edx
  000cd	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax
  000d0	85 db		 test	 ebx, ebx
  000d2	0f 8f 60 ff ff
	ff		 jg	 $LL2@xsgetn
  000d8	7c 08		 jl	 SHORT $LN42@xsgetn
  000da	85 ff		 test	 edi, edi
  000dc	0f 85 56 ff ff
	ff		 jne	 $LL2@xsgetn
$LN42@xsgetn:
  000e2	8b 55 10	 mov	 edx, DWORD PTR __Copied$2$[ebp]
  000e5	8b 45 fc	 mov	 eax, DWORD PTR __Copied$1$[ebp]
  000e8	5e		 pop	 esi
  000e9	5f		 pop	 edi
  000ea	5b		 pop	 ebx

; 390  : 				}
; 391  : 
; 392  : 		return (_Copied);
; 393  : 		}

  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c2 0c 00	 ret	 12			; 0000000cH
$LN40@xsgetn:

; 369  : 		int_type _Meta;
; 370  : 		streamsize _Size, _Copied;
; 371  : 
; 372  : 		for (_Copied = 0; 0 < _Count; )

  000f1	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  000f4	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  000f7	5f		 pop	 edi
  000f8	5b		 pop	 ebx

; 390  : 				}
; 391  : 
; 392  : 		return (_Copied);
; 393  : 		}

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 0c 00	 ret	 12			; 0000000cH
?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
_TEXT	SEGMENT
?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::uflow, COMDAT
; _this$ = ecx

; 361  : 		{	// get a character from stream, point past it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 362  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 50 18	 call	 DWORD PTR [eax+24]
  00008	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0000d	66 3b c8	 cmp	 cx, ax
  00010	75 04		 jne	 SHORT $LN3@uflow
  00012	8b c1		 mov	 eax, ecx
  00014	5e		 pop	 esi

; 363  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
; 364  : 		}

  00015	c3		 ret	 0
$LN3@uflow:

; 362  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())

  00016	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00019	ff 08		 dec	 DWORD PTR [eax]
  0001b	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0001e	5e		 pop	 esi
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00024	89 01		 mov	 DWORD PTR [ecx], eax
  00026	0f b7 02	 movzx	 eax, WORD PTR [edx]

; 363  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
; 364  : 		}

  00029	c3		 ret	 0
?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::uflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
_TEXT	SEGMENT
?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::underflow, COMDAT
; _this$ = ecx

; 357  : 		return (_Traits::eof());

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 358  : 		}

  00005	c3		 ret	 0
?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ
_TEXT	SEGMENT
?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::showmanyc, COMDAT
; _this$ = ecx

; 352  : 		return (0);

  00000	33 c0		 xor	 eax, eax
  00002	33 d2		 xor	 edx, edx

; 353  : 		}

  00004	c3		 ret	 0
?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::showmanyc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 2
?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbackfail, COMDAT
; _this$ = ecx

; 347  : 		return (_Traits::eof());

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 348  : 		}

  00005	c2 04 00	 ret	 4
?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 2
?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::overflow, COMDAT
; _this$ = ecx

; 342  : 		return (_Traits::eof());

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 343  : 		}

  00005	c2 04 00	 ret	 4
?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Init, COMDAT
; _this$ = ecx

; 319  : 		_IGfirst = &_Gfirst;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 320  : 		_IPfirst = &_Pfirst;

  00006	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]

; 321  : 		_IGnext = &_Gnext;

  00009	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]
  0000c	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000f	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 322  : 		_IPnext = &_Pnext;

  00012	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00015	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 323  : 		_IGcount = &_Gcount;

  00018	8d 41 24	 lea	 eax, DWORD PTR [ecx+36]
  0001b	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 324  : 		_IPcount = &_Pcount;

  0001e	8d 41 28	 lea	 eax, DWORD PTR [ecx+40]
  00021	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 325  : 		setp(0, 0);

  00024	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0002a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00033	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00036	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 326  : 		setg(0, 0, 0);

  0003c	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00045	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00048	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0004e	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 327  : 		}

  00057	c3		 ret	 0
?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pnavail, COMDAT
; _this$ = ecx

; 314  : 		return (*_IPnext != 0 ? *_IPcount : 0);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 07		 je	 SHORT $LN3@Pnavail
  00008	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	99		 cdq

; 315  : 		}

  0000e	c3		 ret	 0
$LN3@Pnavail:

; 314  : 		return (*_IPnext != 0 ? *_IPcount : 0);

  0000f	33 c0		 xor	 eax, eax
  00011	99		 cdq

; 315  : 		}

  00012	c3		 ret	 0
?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pnavail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ
_TEXT	SEGMENT
?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pninc, COMDAT
; _this$ = ecx

; 308  : 		--*_IPcount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 309  : 		return ((*_IPnext)++);

  00005	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00008	8b 02		 mov	 eax, DWORD PTR [edx]
  0000a	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  0000d	89 0a		 mov	 DWORD PTR [edx], ecx

; 310  : 		}

  0000f	c3		 ret	 0
?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Next$ = 12						; size = 4
__Last$ = 16						; size = 4
?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setp, COMDAT
; _this$ = ecx

; 300  : 		{	// set pointers for write buffer, extended version

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 301  : 		*_IPfirst = _First;

  00003	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi

; 302  : 		*_IPnext = _Next;
; 303  : 		*_IPcount = (int)(_Last - _Next);

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	89 02		 mov	 DWORD PTR [edx], eax
  0000f	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00012	8b 55 0c	 mov	 edx, DWORD PTR __Next$[ebp]
  00015	2b f2		 sub	 esi, edx
  00017	d1 fe		 sar	 esi, 1
  00019	89 10		 mov	 DWORD PTR [eax], edx
  0001b	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0001e	89 30		 mov	 DWORD PTR [eax], esi
  00020	5e		 pop	 esi

; 304  : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W0@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setp, COMDAT
; _this$ = ecx

; 293  : 		{	// set pointers for write buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 294  : 		*_IPfirst = _First;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 295  : 		*_IPnext = _First;
; 296  : 		*_IPcount = (int)(_Last - _First);

  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b d6		 sub	 edx, esi
  0000f	89 30		 mov	 DWORD PTR [eax], esi
  00011	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00014	d1 fa		 sar	 edx, 1
  00016	89 30		 mov	 DWORD PTR [eax], esi
  00018	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0001b	5e		 pop	 esi
  0001c	89 10		 mov	 DWORD PTR [eax], edx

; 297  : 		}

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?setp@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W0@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?pbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbump, COMDAT
; _this$ = ecx

; 287  : 		{	// alter current position in write buffer by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 288  : 		*_IPcount -= _Off;

  00003	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00009	29 10		 sub	 DWORD PTR [eax], edx

; 289  : 		*_IPnext += _Off;

  0000b	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0000e	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  00011	01 01		 add	 DWORD PTR [ecx], eax

; 290  : 		}

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?pbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Gnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Gnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gnavail, COMDAT
; _this$ = ecx

; 283  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 07		 je	 SHORT $LN3@Gnavail
  00008	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	99		 cdq

; 284  : 		}

  0000e	c3		 ret	 0
$LN3@Gnavail:

; 283  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  0000f	33 c0		 xor	 eax, eax
  00011	99		 cdq

; 284  : 		}

  00012	c3		 ret	 0
?_Gnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gnavail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Gninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ
_TEXT	SEGMENT
?_Gninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gninc, COMDAT
; _this$ = ecx

; 271  : 		--*_IGcount;

  00000	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 272  : 		return ((*_IGnext)++);

  00005	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00008	8b 02		 mov	 eax, DWORD PTR [edx]
  0000a	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  0000d	89 0a		 mov	 DWORD PTR [edx], ecx

; 273  : 		}

  0000f	c3		 ret	 0
?_Gninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gninc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?epptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?epptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::epptr, COMDAT
; _this$ = ecx

; 260  : 		return (*_IPnext + *_IPcount);

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]

; 261  : 		}

  0000d	c3		 ret	 0
?epptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::epptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setg@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Next$ = 12						; size = 4
__Last$ = 16						; size = 4
?setg@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setg, COMDAT
; _this$ = ecx

; 252  : 		{	// set pointers for read buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 253  : 		*_IGfirst = _First;

  00003	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi

; 254  : 		*_IGnext = _Next;
; 255  : 		*_IGcount = (int)(_Last - _Next);

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	89 02		 mov	 DWORD PTR [edx], eax
  0000f	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00012	8b 55 0c	 mov	 edx, DWORD PTR __Next$[ebp]
  00015	2b f2		 sub	 esi, edx
  00017	d1 fe		 sar	 esi, 1
  00019	89 10		 mov	 DWORD PTR [eax], edx
  0001b	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0001e	89 30		 mov	 DWORD PTR [eax], esi
  00020	5e		 pop	 esi

; 256  : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
?setg@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXPA_W00@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?gbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?gbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::gbump, COMDAT
; _this$ = ecx

; 246  : 		{	// alter current position in read buffer by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 247  : 		*_IGcount -= _Off;

  00003	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00009	29 10		 sub	 DWORD PTR [eax], edx

; 248  : 		*_IGnext += _Off;

  0000b	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0000e	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  00011	01 01		 add	 DWORD PTR [ecx], eax

; 249  : 		}

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?gbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::gbump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?egptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?egptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::egptr, COMDAT
; _this$ = ecx

; 242  : 		return (*_IGnext + *_IGcount);

  00000	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]

; 243  : 		}

  0000d	c3		 ret	 0
?egptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::egptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?pptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pptr, COMDAT
; _this$ = ecx

; 237  : 		return (*_IPnext);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 238  : 		}

  00005	c3		 ret	 0
?pptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pbase@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?pbase@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbase, COMDAT
; _this$ = ecx

; 232  : 		return (*_IPfirst);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 233  : 		}

  00005	c3		 ret	 0
?pbase@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?gptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?gptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::gptr, COMDAT
; _this$ = ecx

; 227  : 		return (*_IGnext);

  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 228  : 		}

  00005	c3		 ret	 0
?gptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::gptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?eback@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT
?eback@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::eback, COMDAT
; _this$ = ecx

; 222  : 		return (*_IGfirst);

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 223  : 		}

  00005	c3		 ret	 0
?eback@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::eback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Unlock, COMDAT
; _this$ = ecx

; 217  : 		}

  00000	c3		 ret	 0
?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Lock, COMDAT
; _this$ = ecx

; 213  : 		}

  00000	c3		 ret	 0
?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc, COMDAT
; _this$ = ecx

; 199  : 		{	// put a character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 200  : 		return (0 < _Pnavail()

  00003	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00006	83 38 00	 cmp	 DWORD PTR [eax], 0
  00009	74 23		 je	 SHORT $LN3@sputc
  0000b	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0000e	8b 02		 mov	 eax, DWORD PTR [edx]
  00010	85 c0		 test	 eax, eax
  00012	7e 1a		 jle	 SHORT $LN3@sputc
  00014	48		 dec	 eax
  00015	89 02		 mov	 DWORD PTR [edx], eax
  00017	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  0001f	89 01		 mov	 DWORD PTR [ecx], eax
  00021	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00024	66 89 02	 mov	 WORD PTR [edx], ax
  00027	0f b7 c0	 movzx	 eax, ax

; 201  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 202  : 			: overflow(_Traits::to_int_type(_Ch)));
; 203  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN3@sputc:

; 200  : 		return (0 < _Pnavail()

  0002e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00030	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00033	ff 50 0c	 call	 DWORD PTR [eax+12]
  00036	0f b7 c0	 movzx	 eax, ax

; 201  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 202  : 			: overflow(_Traits::to_int_type(_Ch)));
; 203  : 		}

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pubsync, COMDAT
; _this$ = ecx

; 145  : 		return (sync());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 34	 jmp	 DWORD PTR [eax+52]
?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pubsync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 79   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 80   : 		delete _Plocale;

  00023	8b 71 34	 mov	 esi, DWORD PTR [ecx+52]
  00026	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  0002c	85 f6		 test	 esi, esi
  0002e	74 2a		 je	 SHORT $LN6@basic_stre
  00030	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	85 c9		 test	 ecx, ecx
  0003c	74 11		 je	 SHORT $LN12@basic_stre
  0003e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00040	ff 50 08	 call	 DWORD PTR [eax+8]
  00043	85 c0		 test	 eax, eax
  00045	74 08		 je	 SHORT $LN12@basic_stre
  00047	8b 10		 mov	 edx, DWORD PTR [eax]
  00049	8b c8		 mov	 ecx, eax
  0004b	6a 01		 push	 1
  0004d	ff 12		 call	 DWORD PTR [edx]
$LN12@basic_stre:
  0004f	6a 08		 push	 8
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00057	83 c4 08	 add	 esp, 8
$LN6@basic_stre:

; 81   : 		}

  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5e		 pop	 esi
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 26   : 		{	// construct with no buffers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 25   : 		: _Plocale(new locale)

  00026	6a 08		 push	 8

; 26   : 		{	// construct with no buffers

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	8b f8		 mov	 edi, eax
  00035	83 c4 04	 add	 esp, 4
  00038	85 ff		 test	 edi, edi
  0003a	74 16		 je	 SHORT $LN3@basic_stre

; 25   : 		: _Plocale(new locale)

  0003c	6a 01		 push	 1
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00050	eb 02		 jmp	 SHORT $LN4@basic_stre
$LN3@basic_stre:
  00052	33 ff		 xor	 edi, edi
$LN4@basic_stre:

; 27   : 		_Init();

  00054	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00057	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  0005a	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0005d	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00060	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00063	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00066	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00069	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  0006c	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0006f	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  00072	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  00075	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  00078	89 46 30	 mov	 DWORD PTR [esi+48], eax
  0007b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00081	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00084	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0008a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0008d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00093	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00096	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0009c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0009f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000a5	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000a8	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 28   : 		}

  000ae	8b c6		 mov	 eax, esi
  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str, COMDAT
; _this$ = ecx

; 644  : 		{	// return string copy of character array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 645  : 		return (_Stringbuffer.str());

  00004	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00007	83 c1 18	 add	 ecx, 24			; 00000018H
  0000a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00011	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 646  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 635  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx
  00026	8b 47 98	 mov	 eax, DWORD PTR [edi-104]

; 636  : 		}

  00029	8d 4f b0	 lea	 ecx, DWORD PTR [edi-80]
  0002c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002f	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  00037	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  0003a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003d	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  00040	89 44 3a 94	 mov	 DWORD PTR [edx+edi-108], eax
  00044	c7 47 b0 00 00
	00 00		 mov	 DWORD PTR [edi-80], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  0004b	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
  00050	8b 77 e4	 mov	 esi, DWORD PTR [edi-28]
  00053	c7 47 b0 00 00
	00 00		 mov	 DWORD PTR [edi-80], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  0005a	85 f6		 test	 esi, esi
  0005c	74 2a		 je	 SHORT $LN12@basic_stri
  0005e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00061	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	85 c9		 test	 ecx, ecx
  0006a	74 11		 je	 SHORT $LN18@basic_stri
  0006c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006e	ff 50 08	 call	 DWORD PTR [eax+8]
  00071	85 c0		 test	 eax, eax
  00073	74 08		 je	 SHORT $LN18@basic_stri
  00075	8b 10		 mov	 edx, DWORD PTR [eax]
  00077	8b c8		 mov	 ecx, eax
  00079	6a 01		 push	 1
  0007b	ff 12		 call	 DWORD PTR [edx]
$LN18@basic_stri:
  0007d	6a 08		 push	 8
  0007f	56		 push	 esi
  00080	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00085	83 c4 08	 add	 esp, 8
$LN12@basic_stri:
  00088	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  0008b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008e	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
  00096	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  00099	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009c	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  0009f	89 44 39 94	 mov	 DWORD PTR [ecx+edi-108], eax
  000a3	8b 47 a8	 mov	 eax, DWORD PTR [edi-88]
  000a6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a9	c7 44 38 a8 00
	00 00 00	 mov	 DWORD PTR [eax+edi-88], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  000b1	8b 47 a8	 mov	 eax, DWORD PTR [edi-88]
  000b4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b7	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  000ba	89 44 39 a4	 mov	 DWORD PTR [ecx+edi-92], eax
  000be	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  000c1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c4	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  000cc	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  000cf	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d2	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  000d5	89 44 39 94	 mov	 DWORD PTR [ecx+edi-108], eax
  000d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e3	59		 pop	 ecx
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$ = 8						; size = 4
_this$ = 12						; size = 4
_$initVBases$ = 12					; size = 4
??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 591  : 		{	// construct empty character buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00034	83 7d 0c 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  00038	74 22		 je	 SHORT $LN2@basic_stri
  0003a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
  00040	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], OFFSET ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
  00047	c7 47 68 00 00
	00 00		 mov	 DWORD PTR [edi+104], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00055	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_stri:

; 589  : 		: _Mybase(&_Stringbuffer),

  0005c	6a 00		 push	 0
  0005e	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  00061	8b cf		 mov	 ecx, edi
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 ??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::basic_iostream<wchar_t,std::char_traits<wchar_t> >

; 591  : 		{	// construct empty character buffer

  00069	8b 07		 mov	 eax, DWORD PTR [edi]
  0006b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00072	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00075	c7 04 07 00 00
	00 00		 mov	 DWORD PTR [edi+eax], OFFSET ??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  0007c	8b 07		 mov	 eax, DWORD PTR [edi]
  0007e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00081	89 75 0c	 mov	 DWORD PTR _this$[ebp], esi
  00084	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00087	89 44 39 fc	 mov	 DWORD PTR [ecx+edi-4], eax
  0008b	8b ce		 mov	 ecx, esi
  0008d	e8 00 00 00 00	 call	 ??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
  00092	8b 5d 08	 mov	 ebx, DWORD PTR __Mode$[ebp]
  00095	8b c3		 mov	 eax, ebx
  00097	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  0009d	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  000a4	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  000ab	f7 d1		 not	 ecx
  000ad	83 e1 04	 and	 ecx, 4
  000b0	8b d1		 mov	 edx, ecx
  000b2	83 ca 02	 or	 edx, 2
  000b5	24 02		 and	 al, 2
  000b7	8b c3		 mov	 eax, ebx
  000b9	0f 45 d1	 cmovne	 edx, ecx
  000bc	8b ca		 mov	 ecx, edx
  000be	83 c9 08	 or	 ecx, 8
  000c1	24 08		 and	 al, 8
  000c3	0f 44 ca	 cmove	 ecx, edx
  000c6	8b c1		 mov	 eax, ecx
  000c8	83 c8 10	 or	 eax, 16			; 00000010H
  000cb	80 e3 04	 and	 bl, 4
  000ce	0f 44 c1	 cmove	 eax, ecx
  000d1	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 592  : 		}

  000d4	8b c7		 mov	 eax, edi
  000d6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e0	59		 pop	 ecx
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_stri
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 68	 add	 ecx, 104		; 00000068H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN5@basic_stri:
  0001b	c3		 ret	 0
__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$1:
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 20	 add	 ecx, 32			; 00000020H
  00022	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::~basic_iostream<wchar_t,std::char_traits<wchar_t> >
__unwindfunclet$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z$3:
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
__ehhandler$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z:
  0002f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00033	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00036	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
  00045	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8d 51 20	 lea	 edx, DWORD PTR [ecx+32]
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	c7 44 10 e0 00
	00 00 00	 mov	 DWORD PTR [eax+edx-32], OFFSET ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
  00032	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  0003b	89 44 11 dc	 mov	 DWORD PTR [ecx+edx-36], eax
  0003f	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  00042	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00045	c7 44 10 f0 00
	00 00 00	 mov	 DWORD PTR [eax+edx-16], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  0004d	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  00050	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00053	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  00056	89 44 11 ec	 mov	 DWORD PTR [ecx+edx-20], eax
  0005a	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	c7 44 10 e0 00
	00 00 00	 mov	 DWORD PTR [eax+edx-32], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00068	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  0006b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006e	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00071	89 44 11 dc	 mov	 DWORD PTR [ecx+edx-36], eax
  00075	52		 push	 edx
  00076	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007d	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00083	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00088	83 c4 04	 add	 esp, 4
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00095	59		 pop	 ecx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$4:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 71 e0	 lea	 esi, DWORD PTR [ecx-32]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00012	74 0b		 je	 SHORT $LN4@scalar
  00014	6a 68		 push	 104			; 00000068H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_G?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::~basic_iostream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 983  : 		{	// destroy the object

  00000	8b 41 e0	 mov	 eax, DWORD PTR [ecx-32]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 e0 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-32], OFFSET ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
  0000e	8b 41 e0	 mov	 eax, DWORD PTR [ecx-32]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 e0	 lea	 eax, DWORD PTR [edx-32]
  00017	89 44 0a dc	 mov	 DWORD PTR [edx+ecx-36], eax

; 984  : 		}

  0001b	8d 51 f8	 lea	 edx, DWORD PTR [ecx-8]
  0001e	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	c7 44 10 f8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-8], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  0002c	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  0002f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00032	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  00035	89 44 11 f4	 mov	 DWORD PTR [ecx+edx-12], eax
  00039	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  0003c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003f	c7 44 10 e8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-24], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00047	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  0004a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004d	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00050	89 44 11 e4	 mov	 DWORD PTR [ecx+edx-28], eax
  00054	c3		 ret	 0
??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::~basic_iostream<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
_this$ = 12						; size = 4
_$initVBases$ = 12					; size = 4
??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z PROC ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::basic_iostream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 954  : 		{	// construct from stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00032	83 7d 0c 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  00036	74 22		 je	 SHORT $LN2@basic_iost
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
  0003e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], OFFSET ??_8?$basic_iostream@_WU?$char_traits@_W@std@@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
  00045	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00053	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_iost:

; 952  : 		: _Myis(_Strbuf, false),

  0005a	8b 06		 mov	 eax, DWORD PTR [esi]
  0005c	6a 00		 push	 0
  0005e	ff 75 08	 push	 DWORD PTR __Strbuf$[ebp]
  00061	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00064	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  0006b	8b 06		 mov	 eax, DWORD PTR [esi]
  0006d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00070	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00073	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax
  00077	8b 06		 mov	 eax, DWORD PTR [esi]
  00079	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00080	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00087	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008a	03 ce		 add	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init

; 953  : 			_Myos(_Noinit, false)

  00091	8d 56 10	 lea	 edx, DWORD PTR [esi+16]
  00094	89 55 0c	 mov	 DWORD PTR _this$[ebp], edx
  00097	8b 02		 mov	 eax, DWORD PTR [edx]
  00099	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0009c	c7 04 02 00 00
	00 00		 mov	 DWORD PTR [edx+eax], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  000a3	8b 02		 mov	 eax, DWORD PTR [edx]
  000a5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a8	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  000ab	89 44 11 fc	 mov	 DWORD PTR [ecx+edx-4], eax

; 954  : 		{	// construct from stream buffer pointer

  000af	8b 06		 mov	 eax, DWORD PTR [esi]
  000b1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b4	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_iostream@_WU?$char_traits@_W@std@@@std@@6B@
  000bb	8b 06		 mov	 eax, DWORD PTR [esi]
  000bd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c0	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  000c3	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax

; 955  : 		}

  000c7	8b c6		 mov	 eax, esi
  000c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5e		 pop	 esi
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_iost
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 20	 add	 ecx, 32			; 00000020H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN5@basic_iost:
  0001b	c3		 ret	 0
__unwindfunclet$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z$1:
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 18	 add	 ecx, 24			; 00000018H
  00022	e9 00 00 00 00	 jmp	 ??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >
__ehhandler$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z:
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z ENDP ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::basic_iostream<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	c7 44 10 f8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-8], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  00032	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0003b	89 44 11 f4	 mov	 DWORD PTR [ecx+edx-12], eax
  0003f	52		 push	 edx
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  0004d	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00052	83 c4 04	 add	 esp, 4
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b d1		 mov	 edx, ecx
  00025	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00028	8d 72 f8	 lea	 esi, DWORD PTR [edx-8]
  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002e	c7 44 10 f8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-8], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0003e	89 44 11 f4	 mov	 DWORD PTR [ecx+edx-12], eax
  00042	52		 push	 edx
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00050	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00055	83 c4 04	 add	 esp, 4
  00058	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005c	74 0b		 je	 SHORT $LN16@scalar
  0005e	6a 50		 push	 80			; 00000050H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00066	83 c4 08	 add	 esp, 8
$LN16@scalar:
  00069	8b c6		 mov	 eax, esi
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
$T2 = -40						; size = 20
__Ok$3 = -20						; size = 8
__$EHRec$ = -12						; size = 12
?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush, COMDAT
; _this$ = ecx

; 574  : 		{	// flush output stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx

; 575  : 		if (_Myios::rdbuf() != 0)

  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	83 7c 30 38 00	 cmp	 DWORD PTR [eax+esi+56], 0
  00032	0f 84 ce 00 00
	00		 je	 $LN102@flush

; 576  : 			{	// buffer exists, flush it
; 577  : 			const sentry _Ok(*this);

  00038	56		 push	 esi
  00039	8d 4d ec	 lea	 ecx, DWORD PTR __Ok$3[ebp]
  0003c	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry

; 578  : 
; 579  : 			if (_Ok && _Myios::rdbuf()->pubsync() == -1)

  00041	80 7d f0 00	 cmp	 BYTE PTR __Ok$3[ebp+4], 0
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	0f 84 83 00 00
	00		 je	 $LN56@flush
  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00057	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  0005b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005d	ff 50 34	 call	 DWORD PTR [eax+52]
  00060	83 f8 ff	 cmp	 eax, -1
  00063	75 70		 jne	 SHORT $LN56@flush

; 580  : 				_Myios::setstate(ios_base::badbit);	// sync failed

  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0006a	8b 44 32 10	 mov	 eax, DWORD PTR [edx+esi+16]
  0006e	03 d6		 add	 edx, esi
  00070	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00073	83 c9 04	 or	 ecx, 4
  00076	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0007a	0f 45 4a 0c	 cmovne	 ecx, DWORD PTR [edx+12]
  0007e	83 e1 13	 and	 ecx, 19			; 00000013H
  00081	83 c9 04	 or	 ecx, 4
  00084	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00087	23 c1		 and	 eax, ecx
  00089	74 4a		 je	 SHORT $LN56@flush
  0008b	a8 04		 test	 al, 4
  0008d	74 2a		 je	 SHORT $LN53@flush
  0008f	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN111@flush:
  00099	50		 push	 eax
  0009a	6a 01		 push	 1
  0009c	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0009f	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000a4	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000a9	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  000ac	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN112@flush:
$LN53@flush:
  000b9	a8 02		 test	 al, 2
  000bb	74 0c		 je	 SHORT $LN55@flush
  000bd	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  000c7	eb d0		 jmp	 SHORT $LN111@flush
$LN55@flush:
  000c9	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000d3	eb c4		 jmp	 SHORT $LN111@flush
$LN56@flush:

; 581  : 			}

  000d5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000dc	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  000e1	84 c0		 test	 al, al
  000e3	75 08		 jne	 SHORT $LN98@flush
  000e5	8b 4d ec	 mov	 ecx, DWORD PTR __Ok$3[ebp]
  000e8	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN98@flush:
  000ed	8b 4d ec	 mov	 ecx, DWORD PTR __Ok$3[ebp]
  000f0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000f4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f9	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  000fd	85 c9		 test	 ecx, ecx
  000ff	74 05		 je	 SHORT $LN102@flush
  00101	8b 01		 mov	 eax, DWORD PTR [ecx]
  00103	ff 50 08	 call	 DWORD PTR [eax+8]
$LN102@flush:

; 582  : 		return (*this);

  00106	8b c6		 mov	 eax, esi

; 583  : 		}

  00108	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0010b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00112	59		 pop	 ecx
  00113	5e		 pop	 esi
  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c3		 ret	 0
$LN110@flush:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Ok$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$14:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$15:
  0000e	e8 00 00 00 00	 call	 ___std_terminate
  00013	c3		 ret	 0
__ehhandler$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ:
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T2 = -76						; size = 20
$T3 = -56						; size = 20
$T4 = -36						; size = 20
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx, COMDAT
; _this$ = ecx

; 165  : 		{	// perform any wrapup

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 166  : 		_TRY_BEGIN
; 167  : 		if (this->good() && this->flags() & ios_base::unitbuf)

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00036	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00039	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  0003e	0f 85 d3 00 00
	00		 jne	 $LN9@Osfx
  00044	f6 44 30 14 02	 test	 BYTE PTR [eax+esi+20], 2
  00049	0f 84 c8 00 00
	00		 je	 $LN9@Osfx

; 168  : 			if (_Myios::rdbuf()->pubsync() == -1)	// flush stream as needed

  0004f	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00053	8b 01		 mov	 eax, DWORD PTR [ecx]
  00055	ff 50 34	 call	 DWORD PTR [eax+52]
  00058	83 f8 ff	 cmp	 eax, -1
  0005b	0f 85 b6 00 00
	00		 jne	 $LN9@Osfx

; 169  : 				_Myios::setstate(ios_base::badbit);

  00061	8b 06		 mov	 eax, DWORD PTR [esi]
  00063	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00066	8b 44 32 10	 mov	 eax, DWORD PTR [edx+esi+16]
  0006a	03 d6		 add	 edx, esi
  0006c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0006f	83 c9 04	 or	 ecx, 4
  00072	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00076	0f 45 4a 0c	 cmovne	 ecx, DWORD PTR [edx+12]
  0007a	83 e1 13	 and	 ecx, 19			; 00000013H
  0007d	83 c9 04	 or	 ecx, 4
  00080	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00083	23 c1		 and	 eax, ecx
  00085	0f 84 8c 00 00
	00		 je	 $LN9@Osfx
  0008b	a8 04		 test	 al, 4
  0008d	74 2a		 je	 SHORT $LN34@Osfx
  0008f	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  00099	50		 push	 eax
  0009a	6a 01		 push	 1
  0009c	8d 4d dc	 lea	 ecx, DWORD PTR $T4[ebp]
  0009f	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000a4	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000a9	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  000ac	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN80@Osfx:
$LN34@Osfx:
  000b9	a8 02		 test	 al, 2
  000bb	74 2a		 je	 SHORT $LN36@Osfx
  000bd	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  000c7	50		 push	 eax
  000c8	6a 01		 push	 1
  000ca	8d 4d c8	 lea	 ecx, DWORD PTR $T3[ebp]
  000cd	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000d2	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000d7	8d 45 c8	 lea	 eax, DWORD PTR $T3[ebp]
  000da	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN81@Osfx:
$LN36@Osfx:
  000e7	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000f1	50		 push	 eax
  000f2	6a 01		 push	 1
  000f4	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp]
  000f7	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000fc	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00101	8d 45 b4	 lea	 eax, DWORD PTR $T2[ebp]
  00104	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN82@Osfx:
__catch$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$0:

; 170  : 		_CATCH_ALL
; 171  : 		_CATCH_END

  00111	b8 00 00 00 00	 mov	 eax, $LN9@Osfx
  00116	c3		 ret	 0
$LN9@Osfx:

; 172  : 		}

  00117	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0011a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00121	59		 pop	 ecx
  00122	5f		 pop	 edi
  00123	5e		 pop	 esi
  00124	5b		 pop	 ebx
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
$LN79@Osfx:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::~basic_ostream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 88   : 		{	// destroy the object

  00000	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 f8 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-8], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  0000e	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00017	89 44 0a f4	 mov	 DWORD PTR [edx+ecx-12], eax

; 89   : 		}

  0001b	c3		 ret	 0
??1?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::~basic_ostream<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
__Addit$ = 12						; size = 1
_$initVBases$ = 16					; size = 4
??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::basic_ostream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 58   : 	__CLR_OR_THIS_CALL basic_ostream(_Uninitialized, bool _Addit = true)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 59   : 		{	// construct uninitialized

  0002b	83 7d 10 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00036	74 1b		 je	 SHORT $LN2@basic_ostr
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_ostream@_WU?$char_traits@_W@std@@@std@@7B@
  0003e	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_ostr:

; 60   : 		if (_Addit)

  00053	80 7d 0c 00	 cmp	 BYTE PTR __Addit$[ebp], 0
  00057	8b 06		 mov	 eax, DWORD PTR [esi]
  00059	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005c	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_ostream@_WU?$char_traits@_W@std@@@std@@6B@
  00063	8b 06		 mov	 eax, DWORD PTR [esi]
  00065	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00068	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0006b	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax
  0006f	74 10		 je	 SHORT $LN13@basic_ostr

; 61   : 			this->_Addstd(this);	// suppress for basic_iostream

  00071	8b 06		 mov	 eax, DWORD PTR [esi]
  00073	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00076	03 c6		 add	 eax, esi
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  0007e	83 c4 04	 add	 esp, 4
$LN13@basic_ostr:

; 62   : 		}

  00081	8b c6		 mov	 eax, esi
  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	5e		 pop	 esi
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN8@basic_ostr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 08	 add	 ecx, 8
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN8@basic_ostr:
  0001b	c3		 ret	 0
__ehhandler$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@W4_Uninitialized@1@_N@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::basic_ostream<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8d 51 18	 lea	 edx, DWORD PTR [ecx+24]
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	c7 44 10 e8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-24], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00032	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0003b	89 44 11 e4	 mov	 DWORD PTR [ecx+edx-28], eax
  0003f	52		 push	 edx
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  0004d	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00052	83 c4 04	 add	 esp, 4
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b d1		 mov	 edx, ecx
  00025	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  00028	8d 72 e8	 lea	 esi, DWORD PTR [edx-24]
  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002e	c7 44 10 e8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-24], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0003e	89 44 11 e4	 mov	 DWORD PTR [ecx+edx-28], eax
  00042	52		 push	 edx
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00050	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00055	83 c4 04	 add	 esp, 4
  00058	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005c	74 0b		 je	 SHORT $LN16@scalar
  0005e	6a 60		 push	 96			; 00000060H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00066	83 c4 08	 add	 esp, 8
$LN16@scalar:
  00069	8b c6		 mov	 eax, esi
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 81   : 		{	// destroy the object

  00000	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 e8 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-24], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  0000e	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 e8	 lea	 eax, DWORD PTR [edx-24]
  00017	89 44 0a e4	 mov	 DWORD PTR [edx+ecx-28], eax

; 82   : 		}

  0001b	c3		 ret	 0
??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
_$initVBases$ = 16					; size = 4
??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::basic_istream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 46   : 		{	// construct from stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002b	83 7d 10 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00036	74 1b		 je	 SHORT $LN2@basic_istr
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_istream@_WU?$char_traits@_W@std@@@std@@7B@
  0003e	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_istr:
  00053	8b 06		 mov	 eax, DWORD PTR [esi]

; 47   : 		_Myios::init(_Strbuf, _Isstd);

  00055	ff 75 0c	 push	 DWORD PTR __Isstd$[ebp]
  00058	ff 75 08	 push	 DWORD PTR __Strbuf$[ebp]
  0005b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005e	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006a	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0006d	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax
  00071	8b 06		 mov	 eax, DWORD PTR [esi]
  00073	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0007a	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00081	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00084	03 ce		 add	 ecx, esi
  00086	e8 00 00 00 00	 call	 ?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init

; 48   : 		}

  0008b	8b c6		 mov	 eax, esi
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	5e		 pop	 esi
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_istr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 18	 add	 ecx, 24			; 00000018H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN5@basic_istr:
  0001b	c3		 ret	 0
__ehhandler$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::basic_istream<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	56		 push	 esi
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00033	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00038	83 c4 04	 add	 esp, 4
  0003b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003f	74 0b		 je	 SHORT $LN10@scalar
  00041	6a 48		 push	 72			; 00000048H
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00049	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0004c	8b c6		 mov	 eax, esi
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00058	59		 pop	 ecx
  00059	5e		 pop	 esi
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAE@XZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::basic_ios<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 183  : 	__CLR_OR_THIS_CALL basic_ios()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  : 		{	// default constructor, do nothing
; 185  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAE@XZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::basic_ios<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z
_TEXT	SEGMENT
$T2 = -60						; size = 20
$T3 = -40						; size = 20
$T4 = -20						; size = 8
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init, COMDAT
; _this$ = ecx

; 170  : 		{	// initialize with stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx

; 171  : 		_Init();	// initialize ios_base

  00029	e8 00 00 00 00	 call	 ?_Init@ios_base@std@@IAEXXZ ; std::ios_base::_Init

; 172  : 		_Mystrbuf = _Strbuf;

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Strbuf$[ebp]

; 173  : 		_Tiestr = 0;
; 174  : 		_Fillch = widen(' ');

  00031	8b ce		 mov	 ecx, esi
  00033	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00036	8d 45 ec	 lea	 eax, DWORD PTR $T4[ebp]
  00039	50		 push	 eax
  0003a	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
  00041	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00046	50		 push	 eax
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004e	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  00053	83 c4 04	 add	 esp, 4
  00056	8b f8		 mov	 edi, eax
  00058	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp+4]
  0005b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00062	85 c9		 test	 ecx, ecx
  00064	74 11		 je	 SHORT $LN11@init
  00066	8b 11		 mov	 edx, DWORD PTR [ecx]
  00068	ff 52 08	 call	 DWORD PTR [edx+8]
  0006b	85 c0		 test	 eax, eax
  0006d	74 08		 je	 SHORT $LN11@init
  0006f	8b 10		 mov	 edx, DWORD PTR [eax]
  00071	8b c8		 mov	 ecx, eax
  00073	6a 01		 push	 1
  00075	ff 12		 call	 DWORD PTR [edx]
$LN11@init:
  00077	8b 07		 mov	 eax, DWORD PTR [edi]
  00079	8b cf		 mov	 ecx, edi
  0007b	6a 20		 push	 32			; 00000020H
  0007d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00084	ff 50 30	 call	 DWORD PTR [eax+48]

; 175  : 
; 176  : 		if (_Mystrbuf == 0)

  00087	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  0008b	66 89 46 40	 mov	 WORD PTR [esi+64], ax
  0008f	75 79		 jne	 SHORT $LN33@init

; 177  : 			setstate(badbit);

  00091	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00094	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00097	83 e0 13	 and	 eax, 19			; 00000013H
  0009a	83 c8 04	 or	 eax, 4
  0009d	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  000a0	23 c8		 and	 ecx, eax
  000a2	74 66		 je	 SHORT $LN33@init
  000a4	f6 c1 04	 test	 cl, 4
  000a7	74 2a		 je	 SHORT $LN30@init
  000a9	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN76@init:
  000b3	50		 push	 eax
  000b4	6a 01		 push	 1
  000b6	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  000b9	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000be	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000c5	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  000c8	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
$LN77@init:
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN78@init:
$LN30@init:
  000d3	f6 c1 02	 test	 cl, 2
  000d6	74 0c		 je	 SHORT $LN32@init
  000d8	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  000e2	eb cf		 jmp	 SHORT $LN76@init
$LN32@init:
  000e4	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000ee	50		 push	 eax
  000ef	6a 01		 push	 1
  000f1	8d 4d c4	 lea	 ecx, DWORD PTR $T2[ebp]
  000f4	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000f9	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00100	8d 45 c4	 lea	 eax, DWORD PTR $T2[ebp]
  00103	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00108	eb c3		 jmp	 SHORT $LN77@init
$LN33@init:

; 178  : 
; 179  : 		if (_Isstd)

  0010a	80 7d 0c 00	 cmp	 BYTE PTR __Isstd$[ebp], 0
  0010e	74 09		 je	 SHORT $LN3@init

; 180  : 			_Addstd(this);	// special handling for standard streams

  00110	56		 push	 esi
  00111	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  00116	83 c4 04	 add	 esp, 4
$LN3@init:

; 181  : 		}

  00119	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00123	59		 pop	 ecx
  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 08 00	 ret	 8
$LN75@init:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z$1:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__ehhandler$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
_TEXT	SEGMENT
$T2 = -20						; size = 8
__$EHRec$ = -12						; size = 12
__Byte$ = 8						; size = 1
?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::widen, COMDAT
; _this$ = ecx

; 130  : 		{	// convert _Byte to character using imbued locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 131  : 		const _Ctype& _Ctype_fac = _USE(getloc(), _Ctype);

  00026	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  0002f	50		 push	 eax
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00037	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  0003c	83 c4 04	 add	 esp, 4
  0003f	8b f0		 mov	 esi, eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp+4]
  00044	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0004b	85 c9		 test	 ecx, ecx
  0004d	74 11		 je	 SHORT $LN7@widen
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	ff 52 08	 call	 DWORD PTR [edx+8]
  00054	85 c0		 test	 eax, eax
  00056	74 08		 je	 SHORT $LN7@widen
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b c8		 mov	 ecx, eax
  0005c	6a 01		 push	 1
  0005e	ff 12		 call	 DWORD PTR [edx]
$LN7@widen:

; 132  : 		return (_Ctype_fac.widen(_Byte));

  00060	8b 06		 mov	 eax, DWORD PTR [esi]
  00062	8b ce		 mov	 ecx, esi
  00064	ff 75 08	 push	 DWORD PTR __Byte$[ebp]
  00067	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006e	ff 50 30	 call	 DWORD PTR [eax+48]

; 133  : 		}

  00071	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00074	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007b	59		 pop	 ecx
  0007c	5e		 pop	 esi
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z$1:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__ehhandler$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::widen
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
_TEXT	SEGMENT
?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::fill, COMDAT
; _this$ = ecx

; 113  : 		return (_Fillch);

  00000	66 8b 41 40	 mov	 ax, WORD PTR [ecx+64]

; 114  : 		}

  00004	c3		 ret	 0
?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::fill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf, COMDAT
; _this$ = ecx

; 92   : 		return (_Mystrbuf);

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]

; 93   : 		}

  00003	c3		 ret	 0
?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::tie, COMDAT
; _this$ = ecx

; 80   : 		return (_Tiestr);

  00000	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]

; 81   : 		}

  00003	c3		 ret	 0
?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::tie
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate, COMDAT
; _this$ = ecx

; 58   : 		{	// merge _State into state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 59   : 		if (_State != goodbit)

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 1a		 je	 SHORT $LN2@setstate

; 60   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

  0000a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0000d	ff 75 0c	 push	 DWORD PTR __Reraise$[ebp]
  00010	0b d0		 or	 edx, eax
  00012	8b c2		 mov	 eax, edx
  00014	83 c8 04	 or	 eax, 4
  00017	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0001b	0f 45 c2	 cmovne	 eax, edx
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN2@setstate:

; 61   : 		}

  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::clear, COMDAT
; _this$ = ecx

; 44   : 		{	// set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __State$[ebp]

; 45   : 		ios_base::clear((iostate)(_Mystrbuf == 0

  00006	ff 75 0c	 push	 DWORD PTR __Reraise$[ebp]
  00009	83 ca 04	 or	 edx, 4
  0000c	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00010	0f 45 55 08	 cmovne	 edx, DWORD PTR __State$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);
; 47   : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 39   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 40   : 		}

  00022	51		 push	 ecx
  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
  00030	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00035	83 c4 04	 add	 esp, 4
  00038	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00042	59		 pop	 ecx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
$T2 = -96						; size = 20
$T3 = -76						; size = 20
$T4 = -56						; size = 20
__Ok$ = -36						; size = 8
__Pad$ = -36						; size = 8
__State$ = -28						; size = 4
__Count$1$ = -24					; size = 4
tv1281 = -24						; size = 4
$T5 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
$T6 = 15						; size = 1
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 780  : 	{	// insert NTBS into char stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 781  : 	typedef char _Elem;
; 782  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 783  : 	ios_base::iostate _State = ios_base::goodbit;
; 784  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0002e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0
  00035	80 38 00	 cmp	 BYTE PTR [eax], 0
  00038	75 04		 jne	 SHORT $LN26@operator
  0003a	33 c9		 xor	 ecx, ecx
  0003c	eb 0e		 jmp	 SHORT $LN270@operator
$LN26@operator:
  0003e	8b c8		 mov	 ecx, eax
  00040	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL257@operator:
  00043	8a 01		 mov	 al, BYTE PTR [ecx]
  00045	41		 inc	 ecx
  00046	84 c0		 test	 al, al
  00048	75 f9		 jne	 SHORT $LL257@operator
  0004a	2b ca		 sub	 ecx, edx
$LN270@operator:

; 785  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  0004c	8b 5d 08	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  0004f	89 4d e8	 mov	 DWORD PTR __Count$1$[ebp], ecx
  00052	8b 03		 mov	 eax, DWORD PTR [ebx]
  00054	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00057	8b 7c 18 24	 mov	 edi, DWORD PTR [eax+ebx+36]
  0005b	8b 74 18 20	 mov	 esi, DWORD PTR [eax+ebx+32]
  0005f	85 ff		 test	 edi, edi
  00061	7c 17		 jl	 SHORT $LN17@operator
  00063	7f 0e		 jg	 SHORT $LN259@operator
  00065	85 f6		 test	 esi, esi
  00067	74 11		 je	 SHORT $LN17@operator
  00069	85 ff		 test	 edi, edi
  0006b	7c 0d		 jl	 SHORT $LN17@operator
  0006d	7f 04		 jg	 SHORT $LN259@operator
  0006f	3b f1		 cmp	 esi, ecx
  00071	76 07		 jbe	 SHORT $LN17@operator
$LN259@operator:
  00073	2b f1		 sub	 esi, ecx
  00075	83 df 00	 sbb	 edi, 0
  00078	eb 0e		 jmp	 SHORT $LN18@operator
$LN17@operator:
  0007a	0f 57 c0	 xorps	 xmm0, xmm0
  0007d	66 0f 13 45 dc	 movlpd	 QWORD PTR __Pad$[ebp], xmm0
  00082	8b 7d e0	 mov	 edi, DWORD PTR __Pad$[ebp+4]
  00085	8b 75 dc	 mov	 esi, DWORD PTR __Pad$[ebp]
$LN18@operator:

; 786  : 		? 0 : _Ostr.width() - _Count;
; 787  : 	const typename _Myos::sentry _Ok(_Ostr);

  00088	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  0008c	89 5d dc	 mov	 DWORD PTR __Ok$[ebp], ebx
  0008f	85 c9		 test	 ecx, ecx
  00091	74 05		 je	 SHORT $LN39@operator
  00093	8b 01		 mov	 eax, DWORD PTR [ecx]
  00095	ff 50 04	 call	 DWORD PTR [eax+4]
$LN39@operator:
  00098	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000a1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a4	83 7c 18 0c 00	 cmp	 DWORD PTR [eax+ebx+12], 0
  000a9	75 11		 jne	 SHORT $LN35@operator
  000ab	8b 4c 18 3c	 mov	 ecx, DWORD PTR [eax+ebx+60]
  000af	85 c9		 test	 ecx, ecx
  000b1	74 09		 je	 SHORT $LN35@operator
  000b3	3b cb		 cmp	 ecx, ebx
  000b5	74 05		 je	 SHORT $LN35@operator
  000b7	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN35@operator:
  000bc	8b 03		 mov	 eax, DWORD PTR [ebx]
  000be	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c1	83 7c 19 0c 00	 cmp	 DWORD PTR [ecx+ebx+12], 0
  000c6	0f 94 c0	 sete	 al
  000c9	88 45 e0	 mov	 BYTE PTR __Ok$[ebp+4], al
  000cc	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 788  : 
; 789  : 	if (!_Ok)

  000d3	84 c0		 test	 al, al
  000d5	75 0a		 jne	 SHORT $LN8@operator

; 790  : 		_State |= ios_base::badbit;

  000d7	b9 04 00 00 00	 mov	 ecx, 4

; 791  : 	else

  000dc	e9 56 01 00 00	 jmp	 $LN22@operator
$LN8@operator:

; 792  : 		{	// state okay, insert
; 793  : 		_TRY_IO_BEGIN
; 794  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000e1	8b 44 19 14	 mov	 eax, DWORD PTR [ecx+ebx+20]
  000e5	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000ea	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000ee	83 f8 40	 cmp	 eax, 64			; 00000040H
  000f1	74 6b		 je	 SHORT $LN254@operator
$LL4@operator:

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000f3	85 ff		 test	 edi, edi
  000f5	7c 5f		 jl	 SHORT $LN3@operator
  000f7	7f 04		 jg	 SHORT $LN260@operator
  000f9	85 f6		 test	 esi, esi
  000fb	74 59		 je	 SHORT $LN3@operator
$LN260@operator:

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

  000fd	8b 03		 mov	 eax, DWORD PTR [ebx]
  000ff	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00102	8a 4c 18 40	 mov	 cl, BYTE PTR [eax+ebx+64]
  00106	88 4d ef	 mov	 BYTE PTR $T5[ebp], cl
  00109	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  0010d	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00110	83 38 00	 cmp	 DWORD PTR [eax], 0
  00113	74 20		 je	 SHORT $LN69@operator
  00115	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00118	8b 02		 mov	 eax, DWORD PTR [edx]
  0011a	85 c0		 test	 eax, eax
  0011c	7e 17		 jle	 SHORT $LN69@operator
  0011e	48		 dec	 eax
  0011f	89 02		 mov	 DWORD PTR [edx], eax
  00121	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00124	8b 11		 mov	 edx, DWORD PTR [ecx]
  00126	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00129	89 01		 mov	 DWORD PTR [ecx], eax
  0012b	8a 45 ef	 mov	 al, BYTE PTR $T5[ebp]
  0012e	88 02		 mov	 BYTE PTR [edx], al
  00130	0f b6 c0	 movzx	 eax, al
  00133	eb 0a		 jmp	 SHORT $LN70@operator
$LN69@operator:
  00135	0f b6 45 ef	 movzx	 eax, BYTE PTR $T5[ebp]
  00139	8b 11		 mov	 edx, DWORD PTR [ecx]
  0013b	50		 push	 eax
  0013c	ff 52 0c	 call	 DWORD PTR [edx+12]
$LN70@operator:
  0013f	83 f8 ff	 cmp	 eax, -1
  00142	75 0a		 jne	 SHORT $LN2@operator
$LN261@operator:

; 797  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 798  : 					{	// insertion failed, quit
; 799  : 					_State |= ios_base::badbit;

  00144	b9 04 00 00 00	 mov	 ecx, 4

; 800  : 					break;

  00149	e9 96 00 00 00	 jmp	 $LN6@operator
$LN2@operator:

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  0014e	83 c6 ff	 add	 esi, -1
  00151	83 d7 ff	 adc	 edi, -1
  00154	eb 9d		 jmp	 SHORT $LL4@operator
$LN3@operator:
  00156	33 c9		 xor	 ecx, ecx

; 801  : 					}
; 802  : 
; 803  : 		if (_State == ios_base::goodbit
; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

  00158	0f 85 86 00 00
	00		 jne	 $LN6@operator
$LN254@operator:
  0015e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00160	6a 00		 push	 0
  00162	ff 75 e8	 push	 DWORD PTR __Count$1$[ebp]
  00165	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00168	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0016b	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  0016f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00171	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00174	ff d0		 call	 eax
  00176	3b 45 e8	 cmp	 eax, DWORD PTR __Count$1$[ebp]
  00179	75 c9		 jne	 SHORT $LN261@operator
  0017b	85 d2		 test	 edx, edx
  0017d	75 c5		 jne	 SHORT $LN261@operator
  0017f	90		 npad	 1
$LL263@operator:

; 805  : 			_State |= ios_base::badbit;
; 806  : 
; 807  : 		if (_State == ios_base::goodbit)
; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00180	85 ff		 test	 edi, edi
  00182	7c 5e		 jl	 SHORT $LN266@operator
  00184	7f 04		 jg	 SHORT $LN262@operator
  00186	85 f6		 test	 esi, esi
  00188	74 58		 je	 SHORT $LN266@operator
$LN262@operator:

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

  0018a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0018c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018f	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  00193	8a 54 18 40	 mov	 dl, BYTE PTR [eax+ebx+64]
  00197	88 55 0f	 mov	 BYTE PTR $T6[ebp], dl
  0019a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0019d	83 38 00	 cmp	 DWORD PTR [eax], 0
  001a0	74 23		 je	 SHORT $LN99@operator
  001a2	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  001a5	8b 00		 mov	 eax, DWORD PTR [eax]
  001a7	85 c0		 test	 eax, eax
  001a9	7e 1a		 jle	 SHORT $LN99@operator
  001ab	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  001ae	48		 dec	 eax
  001af	89 02		 mov	 DWORD PTR [edx], eax
  001b1	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  001b4	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b6	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  001b9	89 01		 mov	 DWORD PTR [ecx], eax
  001bb	8a 45 0f	 mov	 al, BYTE PTR $T6[ebp]
  001be	88 02		 mov	 BYTE PTR [edx], al
  001c0	0f b6 c0	 movzx	 eax, al
  001c3	eb 09		 jmp	 SHORT $LN100@operator
$LN99@operator:
  001c5	0f b6 c2	 movzx	 eax, dl
  001c8	8b 11		 mov	 edx, DWORD PTR [ecx]
  001ca	50		 push	 eax
  001cb	ff 52 0c	 call	 DWORD PTR [edx+12]
$LN100@operator:
  001ce	83 f8 ff	 cmp	 eax, -1
  001d1	75 07		 jne	 SHORT $LN5@operator

; 810  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 811  : 					{	// insertion failed, quit
; 812  : 					_State |= ios_base::badbit;

  001d3	33 c9		 xor	 ecx, ecx
  001d5	83 c9 04	 or	 ecx, 4

; 813  : 					break;

  001d8	eb 0a		 jmp	 SHORT $LN6@operator
$LN5@operator:

; 805  : 			_State |= ios_base::badbit;
; 806  : 
; 807  : 		if (_State == ios_base::goodbit)
; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  001da	83 c6 ff	 add	 esi, -1
  001dd	83 d7 ff	 adc	 edi, -1
  001e0	eb 9e		 jmp	 SHORT $LL263@operator
$LN266@operator:
  001e2	33 c9		 xor	 ecx, ecx
$LN6@operator:

; 814  : 					}
; 815  : 		_Ostr.width(0);

  001e4	8b 03		 mov	 eax, DWORD PTR [ebx]
  001e6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e9	c7 44 18 20 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+32], 0
  001f1	c7 44 18 24 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+36], 0
  001f9	eb 35		 jmp	 SHORT $LN273@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 816  : 		_CATCH_IO_(_Ostr)

  001fb	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001fe	8b 01		 mov	 eax, DWORD PTR [ecx]
  00200	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00203	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  00207	03 d1		 add	 edx, ecx
  00209	83 c8 04	 or	 eax, 4
  0020c	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00210	75 03		 jne	 SHORT $LN128@operator
  00212	83 c8 04	 or	 eax, 4
$LN128@operator:
  00215	83 e0 17	 and	 eax, 23			; 00000017H
  00218	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0021b	85 42 10	 test	 DWORD PTR [edx+16], eax
  0021e	0f 85 0e 01 00
	00		 jne	 $LN131@operator
  00224	b8 00 00 00 00	 mov	 eax, $LN23@operator
  00229	c3		 ret	 0
$LN23@operator:
  0022a	8b 5d 08	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  0022d	8b 4d e4	 mov	 ecx, DWORD PTR __State$[ebp]
$LN273@operator:
  00230	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:

; 817  : 		}
; 818  : 
; 819  : 	_Ostr.setstate(_State);

  00237	8b 03		 mov	 eax, DWORD PTR [ebx]
  00239	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0023c	03 d3		 add	 edx, ebx
  0023e	85 c9		 test	 ecx, ecx
  00240	0f 84 a8 00 00
	00		 je	 $LN196@operator
  00246	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00249	0b c1		 or	 eax, ecx
  0024b	8b c8		 mov	 ecx, eax
  0024d	83 c9 04	 or	 ecx, 4
  00250	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00254	0f 45 c8	 cmovne	 ecx, eax
  00257	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0025a	83 e1 17	 and	 ecx, 23			; 00000017H
  0025d	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00260	23 c1		 and	 eax, ecx
  00262	0f 84 86 00 00
	00		 je	 $LN196@operator
  00268	a8 04		 test	 al, 4
  0026a	74 2a		 je	 SHORT $LN193@operator
  0026c	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00271	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  00276	50		 push	 eax
  00277	6a 01		 push	 1
  00279	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  0027c	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00281	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00286	8d 45 c8	 lea	 eax, DWORD PTR $T4[ebp]
  00289	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00290	50		 push	 eax
  00291	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN274@operator:
$LN193@operator:
  00296	a8 02		 test	 al, 2
  00298	74 2a		 je	 SHORT $LN195@operator
  0029a	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  0029f	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  002a4	50		 push	 eax
  002a5	6a 01		 push	 1
  002a7	8d 4d b4	 lea	 ecx, DWORD PTR $T3[ebp]
  002aa	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  002af	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  002b4	8d 45 b4	 lea	 eax, DWORD PTR $T3[ebp]
  002b7	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  002be	50		 push	 eax
  002bf	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN275@operator:
$LN195@operator:
  002c4	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  002c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  002ce	50		 push	 eax
  002cf	6a 01		 push	 1
  002d1	8d 4d a0	 lea	 ecx, DWORD PTR $T2[ebp]
  002d4	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  002d9	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  002de	8d 45 a0	 lea	 eax, DWORD PTR $T2[ebp]
  002e1	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN276@operator:
$LN196@operator:

; 820  : 	return (_Ostr);

  002ee	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  002f5	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  002fa	8b 75 dc	 mov	 esi, DWORD PTR __Ok$[ebp]
  002fd	84 c0		 test	 al, al
  002ff	75 07		 jne	 SHORT $LN237@operator
  00301	8b ce		 mov	 ecx, esi
  00303	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN237@operator:
  00308	8b 06		 mov	 eax, DWORD PTR [esi]
  0030a	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  0030e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00311	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00315	85 c9		 test	 ecx, ecx
  00317	74 05		 je	 SHORT $LN241@operator
  00319	8b 11		 mov	 edx, DWORD PTR [ecx]
  0031b	ff 52 08	 call	 DWORD PTR [edx+8]
$LN241@operator:
  0031e	8b c3		 mov	 eax, ebx

; 821  : 	}

  00320	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00323	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0032a	59		 pop	 ecx
  0032b	5f		 pop	 edi
  0032c	5e		 pop	 esi
  0032d	5b		 pop	 ebx
  0032e	8b e5		 mov	 esp, ebp
  00330	5d		 pop	 ebp
  00331	c3		 ret	 0

; 816  : 		_CATCH_IO_(_Ostr)

$LN131@operator:
  00332	6a 00		 push	 0
  00334	6a 00		 push	 0
  00336	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN277@operator:
$LN269@operator:
  0033b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00008	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$36:
  00010	e8 00 00 00 00	 call	 ___std_terminate
  00015	c3		 ret	 0
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$37:
  00016	e8 00 00 00 00	 call	 ___std_terminate
  0001b	c3		 ret	 0
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8d 71 68	 lea	 esi, DWORD PTR [ecx+104]
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  0002d	56		 push	 esi
  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  0003b	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00040	83 c4 04	 add	 esp, 4
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	5e		 pop	 esi
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8d 71 98	 lea	 esi, DWORD PTR [ecx-104]
  00026	e8 00 00 00 00	 call	 ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  0002b	8d 46 68	 lea	 eax, DWORD PTR [esi+104]
  0002e	50		 push	 eax
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00036	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
  0003c	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00041	83 c4 04	 add	 esp, 4
  00044	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00048	74 0e		 je	 SHORT $LN13@scalar
  0004a	68 b0 00 00 00	 push	 176			; 000000b0H
  0004f	56		 push	 esi
  00050	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00055	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00058	8b c6		 mov	 eax, esi
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5e		 pop	 esi
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0002c	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00031	8b 7e 34	 mov	 edi, DWORD PTR [esi+52]
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  0003a	85 ff		 test	 edi, edi
  0003c	74 2a		 je	 SHORT $LN13@scalar
  0003e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00048	85 c9		 test	 ecx, ecx
  0004a	74 11		 je	 SHORT $LN19@scalar
  0004c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004e	ff 50 08	 call	 DWORD PTR [eax+8]
  00051	85 c0		 test	 eax, eax
  00053	74 08		 je	 SHORT $LN19@scalar
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	8b c8		 mov	 ecx, eax
  00059	6a 01		 push	 1
  0005b	ff 12		 call	 DWORD PTR [edx]
$LN19@scalar:
  0005d	6a 08		 push	 8
  0005f	57		 push	 edi
  00060	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00065	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00068	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0006c	74 0b		 je	 SHORT $LN22@scalar
  0006e	6a 44		 push	 68			; 00000044H
  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00076	83 c4 08	 add	 esp, 8
$LN22@scalar:
  00079	8b c6		 mov	 eax, esi
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z
_TEXT	SEGMENT
__Mode$ = 8						; size = 4
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate, COMDAT
; _this$ = ecx

; 354  : 		{	// convert open mode to stream state bits

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Mode$[ebp]

; 355  : 		_Strstate _State = (_Strstate)0;
; 356  : 		if (!(_Mode & ios_base::in))
; 357  : 			_State |= _Noread;
; 358  : 		if (!(_Mode & ios_base::out))

  00007	8b c3		 mov	 eax, ebx
  00009	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  00010	f7 d1		 not	 ecx
  00012	83 e1 04	 and	 ecx, 4
  00015	8b d1		 mov	 edx, ecx
  00017	83 ca 02	 or	 edx, 2
  0001a	24 02		 and	 al, 2

; 359  : 			_State |= _Constant;
; 360  : 		if (_Mode & ios_base::app)

  0001c	8b c3		 mov	 eax, ebx
  0001e	0f 45 d1	 cmovne	 edx, ecx
  00021	8b ca		 mov	 ecx, edx
  00023	83 c9 08	 or	 ecx, 8
  00026	24 08		 and	 al, 8
  00028	0f 44 ca	 cmove	 ecx, edx
  0002b	8b c1		 mov	 eax, ecx
  0002d	83 c8 10	 or	 eax, 16			; 00000010H

; 361  : 			_State |= _Append;
; 362  : 		if (_Mode & ios_base::ate)

  00030	80 e3 04	 and	 bl, 4
  00033	5b		 pop	 ebx
  00034	0f 44 c1	 cmove	 eax, ecx

; 363  : 			_State |= _Atend;
; 364  : 		return (_State);
; 365  : 		}

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 337  : 		{	// discard any allocated buffer and clear pointers

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 338  : 		if (_Mystate & _Allocated)

  00003	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  00007	74 4d		 je	 SHORT $LN25@Tidy

; 339  : 			_Al.deallocate(_Mysb::eback(),

  00009	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	85 c9		 test	 ecx, ecx
  00010	74 09		 je	 SHORT $LN4@Tidy
  00012	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00015	8b 10		 mov	 edx, DWORD PTR [eax]
  00017	03 d1		 add	 edx, ecx
  00019	eb 0a		 jmp	 SHORT $LN5@Tidy
$LN4@Tidy:
  0001b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0001e	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00021	8b 10		 mov	 edx, DWORD PTR [eax]
  00023	03 11		 add	 edx, DWORD PTR [ecx]
$LN5@Tidy:
  00025	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	2b d0		 sub	 edx, eax
  0002c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00032	72 19		 jb	 SHORT $LN20@Tidy
  00034	a8 1f		 test	 al, 31			; 0000001fH
  00036	75 61		 jne	 SHORT $LN33@Tidy
  00038	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0003b	3b c8		 cmp	 ecx, eax
  0003d	73 5f		 jae	 SHORT $LN35@Tidy
  0003f	2b c1		 sub	 eax, ecx
  00041	83 f8 04	 cmp	 eax, 4
  00044	72 5d		 jb	 SHORT $LN36@Tidy
  00046	83 f8 23	 cmp	 eax, 35			; 00000023H
  00049	77 5d		 ja	 SHORT $LN37@Tidy
  0004b	8b c1		 mov	 eax, ecx
$LN20@Tidy:
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00053	83 c4 04	 add	 esp, 4
$LN25@Tidy:

; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);

  00056	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00059	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0005f	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00062	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00068	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0006b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 343  : 		_Mysb::setp(0, 0);

  00071	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00074	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0007a	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0007d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00083	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00086	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;

  0008c	83 66 3c fe	 and	 DWORD PTR [esi+60], -2	; fffffffeH
  00090	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00097	5e		 pop	 esi

; 346  : 		}

  00098	c3		 ret	 0
$LN33@Tidy:

; 339  : 			_Al.deallocate(_Mysb::eback(),

  00099	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN38@Tidy:
$LN35@Tidy:
  0009e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN39@Tidy:
$LN36@Tidy:
  000a3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN40@Tidy:
$LN37@Tidy:
  000a8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN41@Tidy:
$LN32@Tidy:
  000ad	cc		 int	 3
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__State$ = 16						; size = 4
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init, COMDAT
; _this$ = ecx

; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 311  : 		_Seekhigh = 0;
; 312  : 		_Mystate = _State;

  00003	8b 45 10	 mov	 eax, DWORD PTR __State$[ebp]
  00006	53		 push	 ebx

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00014	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00017	85 db		 test	 ebx, ebx
  00019	74 7e		 je	 SHORT $LN2@Init
  0001b	83 e0 06	 and	 eax, 6
  0001e	3c 06		 cmp	 al, 6
  00020	74 77		 je	 SHORT $LN2@Init

; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Al.allocate(_Count);

  00022	57		 push	 edi
  00023	53		 push	 ebx
  00024	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  00027	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);

  0002c	53		 push	 ebx
  0002d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00030	8b f8		 mov	 edi, eax
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 _memcpy
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 319  : 			_Seekhigh = _Pnew + _Count;

  0003b	8d 0c 1f	 lea	 ecx, DWORD PTR [edi+ebx]

; 320  : 
; 321  : 			if (!(_Mystate & _Noread))

  0003e	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  00042	89 4e 38	 mov	 DWORD PTR [esi+56], ecx
  00045	75 0f		 jne	 SHORT $LN3@Init

; 322  : 				_Mysb::setg(_Pnew, _Pnew,

  00047	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0004a	89 38		 mov	 DWORD PTR [eax], edi
  0004c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0004f	89 38		 mov	 DWORD PTR [eax], edi
  00051	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00054	89 18		 mov	 DWORD PTR [eax], ebx
$LN3@Init:

; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))

  00056	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00059	a8 02		 test	 al, 2
  0005b	75 37		 jne	 SHORT $LN5@Init

; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,

  0005d	a8 18		 test	 al, 24			; 00000018H
  0005f	8b d7		 mov	 edx, edi
  00061	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00064	0f 45 d1	 cmovne	 edx, ecx
  00067	8b cf		 mov	 ecx, edi
  00069	2b ca		 sub	 ecx, edx
  0006b	03 cb		 add	 ecx, ebx
  0006d	89 38		 mov	 DWORD PTR [eax], edi
  0006f	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00072	89 10		 mov	 DWORD PTR [eax], edx
  00074	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00077	89 08		 mov	 DWORD PTR [eax], ecx

; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)

  00079	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0007c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0007f	75 13		 jne	 SHORT $LN5@Init

; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);

  00081	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00084	89 38		 mov	 DWORD PTR [eax], edi
  00086	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00089	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0008f	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00092	89 38		 mov	 DWORD PTR [eax], edi
$LN5@Init:

; 331  : 				}
; 332  : 			_Mystate |= _Allocated;

  00094	83 4e 3c 01	 or	 DWORD PTR [esi+60], 1
  00098	5f		 pop	 edi
$LN2@Init:
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx

; 333  : 			}
; 334  : 		}

  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
tv282 = -4						; size = 4
tv235 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Ptr$ = 12						; size = 24
tv278 = 36						; size = 4
__Mode$ = 36						; size = 4
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos, COMDAT
; _this$ = ecx

; 276  : 		{	// change position to _Pos, according to _Mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 277  : 		streamoff _Off = (streamoff)_Ptr;

  00005	8b 5d 18	 mov	 ebx, DWORD PTR __Ptr$[ebp+12]
  00008	56		 push	 esi
  00009	8b 75 14	 mov	 esi, DWORD PTR __Ptr$[ebp+8]
  0000c	03 75 0c	 add	 esi, DWORD PTR __Ptr$[ebp]
  0000f	57		 push	 edi
  00010	13 5d 10	 adc	 ebx, DWORD PTR __Ptr$[ebp+4]
  00013	8b f9		 mov	 edi, ecx

; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  00015	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	85 c0		 test	 eax, eax
  0001c	74 08		 je	 SHORT $LN2@seekpos
  0001e	39 47 38	 cmp	 DWORD PTR [edi+56], eax
  00021	73 03		 jae	 SHORT $LN2@seekpos

; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  00023	89 47 38	 mov	 DWORD PTR [edi+56], eax
$LN2@seekpos:

; 280  : 
; 281  : 		if (_Off == _BADOFF)

  00026	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB+4
  0002b	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  00031	75 08		 jne	 SHORT $LN55@seekpos
  00033	3b d8		 cmp	 ebx, eax
  00035	0f 84 c0 00 00
	00		 je	 $LN11@seekpos
$LN55@seekpos:

; 282  : 			;
; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

  0003b	8b 4d 24	 mov	 ecx, DWORD PTR __Mode$[ebp]
  0003e	f6 c1 01	 test	 cl, 1
  00041	74 74		 je	 SHORT $LN5@seekpos
  00043	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 45 fc	 mov	 DWORD PTR tv235[ebp], eax
  0004b	85 c0		 test	 eax, eax
  0004d	74 63		 je	 SHORT $LN60@seekpos

; 284  : 			{	// position within read buffer
; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0004f	85 db		 test	 ebx, ebx
  00051	7c 57		 jl	 SHORT $LN7@seekpos
  00053	7f 04		 jg	 SHORT $LN56@seekpos
  00055	85 f6		 test	 esi, esi
  00057	72 51		 jb	 SHORT $LN7@seekpos
$LN56@seekpos:
  00059	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00061	2b c1		 sub	 eax, ecx
  00063	99		 cdq
  00064	3b da		 cmp	 ebx, edx
  00066	7f 42		 jg	 SHORT $LN7@seekpos
  00068	7c 04		 jl	 SHORT $LN57@seekpos
  0006a	3b f0		 cmp	 esi, eax
  0006c	77 3c		 ja	 SHORT $LN7@seekpos
$LN57@seekpos:

; 286  : 				{	// change read position
; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  0006e	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00071	2b 4d fc	 sub	 ecx, DWORD PTR tv235[ebp]
  00074	03 ce		 add	 ecx, esi
  00076	29 08		 sub	 DWORD PTR [eax], ecx
  00078	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0007b	01 08		 add	 DWORD PTR [eax], ecx

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  0007d	f6 45 24 02	 test	 BYTE PTR __Mode$[ebp], 2
  00081	74 78		 je	 SHORT $LN11@seekpos
  00083	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00086	8b 00		 mov	 eax, DWORD PTR [eax]
  00088	89 45 24	 mov	 DWORD PTR tv278[ebp], eax
  0008b	85 c0		 test	 eax, eax
  0008d	74 6c		 je	 SHORT $LN11@seekpos

; 289  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),

  0008f	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00092	8b 10		 mov	 edx, DWORD PTR [eax]
  00094	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  00097	8b 08		 mov	 ecx, DWORD PTR [eax]
  00099	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0009c	03 4d 24	 add	 ecx, DWORD PTR tv278[ebp]
  0009f	2b ca		 sub	 ecx, edx
  000a1	89 10		 mov	 DWORD PTR [eax], edx
  000a3	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000a6	89 08		 mov	 DWORD PTR [eax], ecx

; 290  : 						_Mysb::epptr());	// change write position to match
; 291  : 				}
; 292  : 			else

  000a8	eb 51		 jmp	 SHORT $LN11@seekpos
$LN7@seekpos:

; 293  : 				_Off = _BADOFF;

  000aa	8b 1d 04 00 00
	00		 mov	 ebx, DWORD PTR ?_BADOFF@std@@3_JB+4
  000b0	eb 43		 jmp	 SHORT $LN61@seekpos
$LN60@seekpos:
  000b2	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB+4
$LN5@seekpos:

; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  000b7	f6 c1 02	 test	 cl, 2
  000ba	74 37		 je	 SHORT $LN10@seekpos
  000bc	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000bf	74 32		 je	 SHORT $LN10@seekpos

; 296  : 			{	// position within write buffer
; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  000c1	85 db		 test	 ebx, ebx
  000c3	7c e5		 jl	 SHORT $LN7@seekpos
  000c5	7f 04		 jg	 SHORT $LN58@seekpos
  000c7	85 f6		 test	 esi, esi
  000c9	72 df		 jb	 SHORT $LN7@seekpos
$LN58@seekpos:
  000cb	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d0	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  000d3	2b c1		 sub	 eax, ecx
  000d5	99		 cdq
  000d6	3b da		 cmp	 ebx, edx
  000d8	7f d0		 jg	 SHORT $LN7@seekpos
  000da	7c 04		 jl	 SHORT $LN59@seekpos
  000dc	3b f0		 cmp	 esi, eax
  000de	77 ca		 ja	 SHORT $LN7@seekpos
$LN59@seekpos:

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

  000e0	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  000e3	2b 08		 sub	 ecx, DWORD PTR [eax]
  000e5	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000e8	03 ce		 add	 ecx, esi
  000ea	29 08		 sub	 DWORD PTR [eax], ecx
  000ec	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  000ef	01 08		 add	 DWORD PTR [eax], ecx

; 299  : 					- _Mysb::pptr() + _Off));	// change write position
; 300  : 			else

  000f1	eb 08		 jmp	 SHORT $LN11@seekpos
$LN10@seekpos:

; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  000f3	8b d8		 mov	 ebx, eax
$LN61@seekpos:
  000f5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
$LN11@seekpos:

; 305  : 		return (streampos(_Off));

  000fb	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000fe	0f 57 c0	 xorps	 xmm0, xmm0
  00101	5f		 pop	 edi
  00102	89 30		 mov	 DWORD PTR [eax], esi
  00104	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00107	5e		 pop	 esi
  00108	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0010f	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00116	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  0011b	5b		 pop	 ebx

; 306  : 		}

  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
tv265 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
tv276 = 20						; size = 4
__Way$ = 20						; size = 4
tv271 = 24						; size = 4
tv270 = 24						; size = 4
__Which$ = 24						; size = 4
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff, COMDAT
; _this$ = ecx

; 227  : 		{	// change position by _Off, according to _Way, _Mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  00009	8b 53 20	 mov	 edx, DWORD PTR [ebx+32]
  0000c	8b 02		 mov	 eax, DWORD PTR [edx]
  0000e	85 c0		 test	 eax, eax
  00010	74 08		 je	 SHORT $LN2@seekoff
  00012	39 43 38	 cmp	 DWORD PTR [ebx+56], eax
  00015	73 03		 jae	 SHORT $LN2@seekoff

; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  00017	89 43 38	 mov	 DWORD PTR [ebx+56], eax
$LN2@seekoff:

; 230  : 
; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

  0001a	8b 4d 18	 mov	 ecx, DWORD PTR __Which$[ebp]
  0001d	f6 c1 01	 test	 cl, 1
  00020	0f 84 d9 00 00
	00		 je	 $LN3@seekoff
  00026	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00029	8b 30		 mov	 esi, DWORD PTR [eax]
  0002b	89 75 fc	 mov	 DWORD PTR tv265[ebp], esi
  0002e	85 f6		 test	 esi, esi
  00030	0f 84 c9 00 00
	00		 je	 $LN3@seekoff

; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)

  00036	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  00039	83 f8 02	 cmp	 eax, 2
  0003c	75 15		 jne	 SHORT $LN5@seekoff

; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  0003e	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00041	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00044	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00047	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0004a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0004c	99		 cdq
  0004d	03 f0		 add	 esi, eax
  0004f	13 fa		 adc	 edi, edx

; 235  : 			else if (_Way == ios_base::cur

  00051	eb 36		 jmp	 SHORT $LN9@seekoff
$LN5@seekoff:

; 236  : 				&& (_Which & ios_base::out) == 0)

  00053	83 f8 01	 cmp	 eax, 1
  00056	75 19		 jne	 SHORT $LN7@seekoff
  00058	f6 c1 02	 test	 cl, 2
  0005b	75 18		 jne	 SHORT $LN74@seekoff

; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());

  0005d	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00060	8b c6		 mov	 eax, esi
  00062	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00065	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00068	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006a	99		 cdq
  0006b	03 f0		 add	 esi, eax
  0006d	13 fa		 adc	 edi, edx
  0006f	eb 18		 jmp	 SHORT $LN9@seekoff
$LN7@seekoff:

; 238  : 			else if (_Way != ios_base::beg)

  00071	85 c0		 test	 eax, eax
  00073	74 0e		 je	 SHORT $LN79@seekoff
$LN74@seekoff:

; 239  : 				_Off = _BADOFF;

  00075	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  0007b	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_BADOFF@std@@3_JB+4
  00081	eb 06		 jmp	 SHORT $LN9@seekoff
$LN79@seekoff:
  00083	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00086	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
$LN9@seekoff:

; 240  : 
; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00089	85 ff		 test	 edi, edi
  0008b	0f 8c 0a 01 00
	00		 jl	 $LN10@seekoff
  00091	7f 08		 jg	 SHORT $LN75@seekoff
  00093	85 f6		 test	 esi, esi
  00095	0f 82 00 01 00
	00		 jb	 $LN10@seekoff
$LN75@seekoff:
  0009b	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  000a3	2b c1		 sub	 eax, ecx
  000a5	99		 cdq
  000a6	3b fa		 cmp	 edi, edx
  000a8	0f 8f ed 00 00
	00		 jg	 $LN10@seekoff
  000ae	7c 08		 jl	 SHORT $LN76@seekoff
  000b0	3b f0		 cmp	 esi, eax
  000b2	0f 87 e3 00 00
	00		 ja	 $LN10@seekoff
$LN76@seekoff:

; 242  : 				{	// change read position
; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  000b8	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  000bb	2b 4d fc	 sub	 ecx, DWORD PTR tv265[ebp]
  000be	03 ce		 add	 ecx, esi
  000c0	29 08		 sub	 DWORD PTR [eax], ecx
  000c2	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  000c5	01 08		 add	 DWORD PTR [eax], ecx

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000c7	f6 45 18 02	 test	 BYTE PTR __Which$[ebp], 2
  000cb	0f 84 d6 00 00
	00		 je	 $LN22@seekoff
  000d1	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  000d4	8b 00		 mov	 eax, DWORD PTR [eax]
  000d6	89 45 18	 mov	 DWORD PTR tv271[ebp], eax
  000d9	85 c0		 test	 eax, eax
  000db	0f 84 c6 00 00
	00		 je	 $LN22@seekoff

; 245  : 					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),

  000e1	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  000e4	8b 10		 mov	 edx, DWORD PTR [eax]
  000e6	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  000e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000eb	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  000ee	03 4d 18	 add	 ecx, DWORD PTR tv271[ebp]
  000f1	2b ca		 sub	 ecx, edx
  000f3	89 10		 mov	 DWORD PTR [eax], edx
  000f5	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  000f8	89 08		 mov	 DWORD PTR [eax], ecx

; 246  : 						_Mysb::epptr());	// change write position to match
; 247  : 				}
; 248  : 			else

  000fa	e9 a8 00 00 00	 jmp	 $LN22@seekoff
$LN3@seekoff:

; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000ff	f6 c1 02	 test	 cl, 2
  00102	0f 84 87 00 00
	00		 je	 $LN13@seekoff
  00108	8b 12		 mov	 edx, DWORD PTR [edx]
  0010a	89 55 18	 mov	 DWORD PTR tv270[ebp], edx
  0010d	85 d2		 test	 edx, edx
  0010f	74 7e		 je	 SHORT $LN13@seekoff

; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)

  00111	8b 45 14	 mov	 eax, DWORD PTR __Way$[ebp]
  00114	83 f8 02	 cmp	 eax, 2
  00117	75 15		 jne	 SHORT $LN15@seekoff

; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  00119	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0011c	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  0011f	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00122	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00125	2b 01		 sub	 eax, DWORD PTR [ecx]
  00127	99		 cdq
  00128	03 f0		 add	 esi, eax
  0012a	13 fa		 adc	 edi, edx
  0012c	eb 31		 jmp	 SHORT $LN19@seekoff
$LN15@seekoff:

; 255  : 			else if (_Way == ios_base::cur)

  0012e	83 f8 01	 cmp	 eax, 1
  00131	75 14		 jne	 SHORT $LN17@seekoff

; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());

  00133	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00136	8b c2		 mov	 eax, edx
  00138	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  0013b	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0013e	2b 01		 sub	 eax, DWORD PTR [ecx]
  00140	99		 cdq
  00141	03 f0		 add	 esi, eax
  00143	13 fa		 adc	 edi, edx
  00145	eb 18		 jmp	 SHORT $LN19@seekoff
$LN17@seekoff:

; 257  : 			else if (_Way != ios_base::beg)

  00147	85 c0		 test	 eax, eax
  00149	74 0e		 je	 SHORT $LN80@seekoff

; 258  : 				_Off = _BADOFF;

  0014b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  00151	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_BADOFF@std@@3_JB+4
  00157	eb 06		 jmp	 SHORT $LN19@seekoff
$LN80@seekoff:
  00159	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  0015c	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
$LN19@seekoff:

; 259  : 
; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0015f	85 ff		 test	 edi, edi
  00161	7c 38		 jl	 SHORT $LN10@seekoff
  00163	7f 04		 jg	 SHORT $LN77@seekoff
  00165	85 f6		 test	 esi, esi
  00167	72 32		 jb	 SHORT $LN10@seekoff
$LN77@seekoff:
  00169	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0016c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016e	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00171	2b c1		 sub	 eax, ecx
  00173	99		 cdq
  00174	3b fa		 cmp	 edi, edx
  00176	7f 23		 jg	 SHORT $LN10@seekoff
  00178	7c 04		 jl	 SHORT $LN78@seekoff
  0017a	3b f0		 cmp	 esi, eax
  0017c	77 1d		 ja	 SHORT $LN10@seekoff
$LN78@seekoff:

; 261  : 				_Mysb::pbump((int)(_Mysb::eback()

  0017e	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  00181	2b 4d 18	 sub	 ecx, DWORD PTR tv270[ebp]
  00184	03 ce		 add	 ecx, esi
  00186	29 08		 sub	 DWORD PTR [eax], ecx
  00188	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  0018b	01 08		 add	 DWORD PTR [eax], ecx

; 262  : 					- _Mysb::pptr() + _Off));	// change write position
; 263  : 			else

  0018d	eb 18		 jmp	 SHORT $LN22@seekoff
$LN13@seekoff:

; 264  : 				_Off = _BADOFF;
; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)

  0018f	8b 75 0c	 mov	 esi, DWORD PTR __Off$[ebp]
  00192	8b c6		 mov	 eax, esi
  00194	8b 7d 10	 mov	 edi, DWORD PTR __Off$[ebp+4]
  00197	0b c7		 or	 eax, edi
  00199	74 0c		 je	 SHORT $LN22@seekoff
$LN10@seekoff:

; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  0019b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?_BADOFF@std@@3_JB
  001a1	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_BADOFF@std@@3_JB+4
$LN22@seekoff:

; 271  : 		return (pos_type(_Off));

  001a7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001aa	0f 57 c0	 xorps	 xmm0, xmm0
  001ad	89 78 04	 mov	 DWORD PTR [eax+4], edi
  001b0	5f		 pop	 edi
  001b1	89 30		 mov	 DWORD PTR [eax], esi
  001b3	5e		 pop	 esi
  001b4	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  001bb	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  001c2	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  001c7	5b		 pop	 ebx

; 272  : 		}

  001c8	8b e5		 mov	 esp, ebp
  001ca	5d		 pop	 ebp
  001cb	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow, COMDAT
; _this$ = ecx

; 207  : 		{	// get an element from stream, but don't point past it

  00000	56		 push	 esi

; 208  : 		if (_Mysb::gptr() == 0)

  00001	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]
  00004	8b 16		 mov	 edx, DWORD PTR [esi]
  00006	85 d2		 test	 edx, edx
  00008	75 05		 jne	 SHORT $LN2@underflow

; 209  : 			return (_Traits::eof());	// no character buffer, fail

  0000a	83 c8 ff	 or	 eax, -1
  0000d	5e		 pop	 esi

; 221  : 			}
; 222  : 		}

  0000e	c3		 ret	 0
$LN2@underflow:
  0000f	57		 push	 edi

; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())

  00010	8b 79 2c	 mov	 edi, DWORD PTR [ecx+44]
  00013	8b 07		 mov	 eax, DWORD PTR [edi]
  00015	03 c2		 add	 eax, edx
  00017	3b d0		 cmp	 edx, eax
  00019	73 06		 jae	 SHORT $LN4@underflow

; 211  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered

  0001b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 221  : 			}
; 222  : 		}

  00020	c3		 ret	 0
$LN4@underflow:

; 212  : 		else if (_Mystate & _Noread || _Mysb::pptr() == 0
; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

  00021	f6 41 3c 04	 test	 BYTE PTR [ecx+60], 4
  00025	75 2c		 jne	 SHORT $LN8@underflow
  00027	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0002a	8b 00		 mov	 eax, DWORD PTR [eax]
  0002c	85 c0		 test	 eax, eax
  0002e	74 23		 je	 SHORT $LN8@underflow
  00030	3b c2		 cmp	 eax, edx
  00032	77 05		 ja	 SHORT $LN6@underflow
  00034	39 51 38	 cmp	 DWORD PTR [ecx+56], edx
  00037	76 1a		 jbe	 SHORT $LN8@underflow
$LN6@underflow:

; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())

  00039	39 41 38	 cmp	 DWORD PTR [ecx+56], eax
  0003c	73 03		 jae	 SHORT $LN9@underflow

; 218  : 				_Seekhigh = _Mysb::pptr();

  0003e	89 41 38	 mov	 DWORD PTR [ecx+56], eax
$LN9@underflow:

; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);

  00041	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00044	2b 06		 sub	 eax, DWORD PTR [esi]
  00046	89 07		 mov	 DWORD PTR [edi], eax

; 220  : 			return (_Traits::to_int_type(*_Mysb::gptr()));

  00048	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	8b 00		 mov	 eax, DWORD PTR [eax]
  0004f	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 221  : 			}
; 222  : 		}

  00052	c3		 ret	 0
$LN8@underflow:
  00053	5f		 pop	 edi

; 214  : 			return (_Traits::eof());	// can't read, fail

  00054	83 c8 ff	 or	 eax, -1
  00057	5e		 pop	 esi

; 221  : 			}
; 222  : 		}

  00058	c3		 ret	 0
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail, COMDAT
; _this$ = ecx

; 190  : 		{	// put an element back to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx
  00005	56		 push	 esi

; 191  : 		if (_Mysb::gptr() == 0
; 192  : 			|| _Mysb::gptr() <= _Mysb::eback()
; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  00006	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00009	8b 30		 mov	 esi, DWORD PTR [eax]
  0000b	85 f6		 test	 esi, esi
  0000d	74 40		 je	 SHORT $LN4@pbackfail
  0000f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00012	3b 30		 cmp	 esi, DWORD PTR [eax]
  00014	76 39		 jbe	 SHORT $LN4@pbackfail
  00016	8b 4d 08	 mov	 ecx, DWORD PTR __Meta$[ebp]
  00019	83 f9 ff	 cmp	 ecx, -1
  0001c	74 0b		 je	 SHORT $LN2@pbackfail
  0001e	3a 4e ff	 cmp	 cl, BYTE PTR [esi-1]
  00021	74 06		 je	 SHORT $LN2@pbackfail
  00023	f6 42 3c 02	 test	 BYTE PTR [edx+60], 2
  00027	75 26		 jne	 SHORT $LN4@pbackfail
$LN2@pbackfail:

; 197  : 		else
; 198  : 			{	// back up one position and store put-back character
; 199  : 			_Mysb::gbump(-1);

  00029	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0002c	ff 00		 inc	 DWORD PTR [eax]
  0002e	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00031	ff 08		 dec	 DWORD PTR [eax]

; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))

  00033	83 f9 ff	 cmp	 ecx, -1
  00036	74 0e		 je	 SHORT $LN45@pbackfail

; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);

  00038	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0003b	5e		 pop	 esi
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	88 08		 mov	 BYTE PTR [eax], cl

; 202  : 			return (_Traits::not_eof(_Meta));

  00040	8b c1		 mov	 eax, ecx

; 203  : 			}
; 204  : 		}

  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4

; 202  : 			return (_Traits::not_eof(_Meta));

$LN45@pbackfail:
  00046	33 c9		 xor	 ecx, ecx
  00048	8b c1		 mov	 eax, ecx
  0004a	5e		 pop	 esi

; 203  : 			}
; 204  : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
$LN4@pbackfail:

; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail

  0004f	83 c8 ff	 or	 eax, -1
  00052	5e		 pop	 esi

; 203  : 			}
; 204  : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
tv598 = -8						; size = 4
__Newsize$1$ = -8					; size = 4
__Oldptr$1$ = -4					; size = 4
__Meta$ = 8						; size = 4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow, COMDAT
; _this$ = ecx

; 120  : 		{	// put an element to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 121  : 		if (_Mystate & _Constant)

  00009	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0000c	a8 02		 test	 al, 2
  0000e	74 0a		 je	 SHORT $LN4@overflow

; 122  : 			return (_Traits::eof());	// array nonmutable, fail

  00010	83 c8 ff	 or	 eax, -1
  00013	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN4@overflow:
  0001a	53		 push	 ebx

; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  0001b	8b 5d 08	 mov	 ebx, DWORD PTR __Meta$[ebp]
  0001e	83 fb ff	 cmp	 ebx, -1
  00021	75 0a		 jne	 SHORT $LN6@overflow

; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  00023	5b		 pop	 ebx
  00024	33 c0		 xor	 eax, eax
  00026	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
$LN6@overflow:
  0002d	57		 push	 edi

; 125  : 
; 126  : 		if (_Mystate & _Append
; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

  0002e	a8 08		 test	 al, 8
  00030	74 23		 je	 SHORT $LN7@overflow
  00032	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00035	8b 10		 mov	 edx, DWORD PTR [eax]
  00037	85 d2		 test	 edx, edx
  00039	74 1a		 je	 SHORT $LN7@overflow
  0003b	8b 7e 38	 mov	 edi, DWORD PTR [esi+56]
  0003e	3b d7		 cmp	 edx, edi
  00040	73 13		 jae	 SHORT $LN7@overflow

; 128  : 			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());

  00042	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00045	8b 08		 mov	 ecx, DWORD PTR [eax]
  00047	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0004a	03 ca		 add	 ecx, edx
  0004c	2b cf		 sub	 ecx, edi
  0004e	89 38		 mov	 DWORD PTR [eax], edi
  00050	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00053	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@overflow:

; 129  : 
; 130  : 		if (_Mysb::pptr() != 0
; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

  00055	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	85 d2		 test	 edx, edx
  0005c	74 2a		 je	 SHORT $LN119@overflow
  0005e	8b 7e 30	 mov	 edi, DWORD PTR [esi+48]
  00061	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00063	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00066	3b d0		 cmp	 edx, eax
  00068	73 1a		 jae	 SHORT $LN8@overflow

; 132  : 			{	// room in buffer, store it
; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  0006a	49		 dec	 ecx

; 134  : 			return (_Meta);

  0006b	8b c3		 mov	 eax, ebx
  0006d	89 0f		 mov	 DWORD PTR [edi], ecx
  0006f	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00072	5f		 pop	 edi
  00073	8b 32		 mov	 esi, DWORD PTR [edx]
  00075	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00078	89 0a		 mov	 DWORD PTR [edx], ecx
  0007a	88 1e		 mov	 BYTE PTR [esi], bl
  0007c	5b		 pop	 ebx
  0007d	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
$LN8@overflow:

; 135  : 			}
; 136  : 		else
; 137  : 			{	// grow buffer and store element
; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

  00084	85 d2		 test	 edx, edx
  00086	75 04		 jne	 SHORT $LN20@overflow
$LN119@overflow:
  00088	33 ff		 xor	 edi, edi
  0008a	eb 0c		 jmp	 SHORT $LN21@overflow
$LN20@overflow:
  0008c	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0008f	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00092	8b 38		 mov	 edi, DWORD PTR [eax]
  00094	2b 39		 sub	 edi, DWORD PTR [ecx]
  00096	03 fa		 add	 edi, edx
$LN21@overflow:

; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE

  00098	8b cf		 mov	 ecx, edi
  0009a	d1 e9		 shr	 ecx, 1
  0009c	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0009f	73 07		 jae	 SHORT $LN22@overflow
  000a1	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000a6	eb 08		 jmp	 SHORT $LL2@overflow
$LN22@overflow:

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  000a8	85 c9		 test	 ecx, ecx
  000aa	74 17		 je	 SHORT $LN121@overflow
  000ac	0f 1f 40 00	 npad	 4
$LL2@overflow:
  000b0	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000b5	2b c1		 sub	 eax, ecx
  000b7	3b c7		 cmp	 eax, edi
  000b9	73 04		 jae	 SHORT $LN114@overflow

; 145  : 				_Inc /= 2;	// increment causes overflow, halve it

  000bb	d1 e9		 shr	 ecx, 1

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  000bd	75 f1		 jne	 SHORT $LL2@overflow
$LN114@overflow:

; 146  : 			if (_Inc == 0)

  000bf	85 c9		 test	 ecx, ecx
  000c1	75 0c		 jne	 SHORT $LN10@overflow
$LN121@overflow:
  000c3	5f		 pop	 edi
  000c4	5b		 pop	 ebx

; 147  : 				return (_Traits::eof());	// buffer can't grow, fail

  000c5	83 c8 ff	 or	 eax, -1
  000c8	5e		 pop	 esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 04 00	 ret	 4
$LN10@overflow:

; 148  : 
; 149  : 			_Newsize += _Inc;

  000cf	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]

; 150  : 
; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);

  000d2	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  000d5	89 45 f8	 mov	 DWORD PTR __Newsize$1$[ebp], eax
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 152  : 			_Elem *_Oldptr = _Mysb::eback();

  000de	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  000e1	8b d8		 mov	 ebx, eax
  000e3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000e5	89 4d fc	 mov	 DWORD PTR __Oldptr$1$[ebp], ecx

; 153  : 
; 154  : 			if (0 < _Oldsize)

  000e8	85 ff		 test	 edi, edi
  000ea	74 12		 je	 SHORT $LN123@overflow

; 155  : 				_Traits::copy(_Newptr, _Oldptr, _Oldsize);

  000ec	57		 push	 edi
  000ed	51		 push	 ecx
  000ee	53		 push	 ebx
  000ef	e8 00 00 00 00	 call	 _memcpy
  000f4	8b 4d fc	 mov	 ecx, DWORD PTR __Oldptr$1$[ebp]
  000f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 156  : 
; 157  : 			if (_Oldsize == 0)

  000fa	85 ff		 test	 edi, edi
  000fc	75 3d		 jne	 SHORT $LN12@overflow
$LN123@overflow:

; 158  : 				{	// first growth, set up pointers
; 159  : 				_Seekhigh = _Newptr;
; 160  : 				_Mysb::setp(_Newptr, _Newptr + _Newsize);

  000fe	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00101	8b 55 f8	 mov	 edx, DWORD PTR __Newsize$1$[ebp]
  00104	89 5e 38	 mov	 DWORD PTR [esi+56], ebx
  00107	89 18		 mov	 DWORD PTR [eax], ebx
  00109	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0010c	89 18		 mov	 DWORD PTR [eax], ebx
  0010e	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00111	89 10		 mov	 DWORD PTR [eax], edx

; 161  : 				if (_Mystate & _Noread)
; 162  : 					_Mysb::setg(_Newptr, 0, _Newptr);

  00113	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00116	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  0011a	89 18		 mov	 DWORD PTR [eax], ebx
  0011c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0011f	74 0d		 je	 SHORT $LN14@overflow
  00121	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00127	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0012a	89 18		 mov	 DWORD PTR [eax], ebx

; 163  : 				else

  0012c	eb 74		 jmp	 SHORT $LN17@overflow
$LN14@overflow:

; 164  : 					_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);

  0012e	89 18		 mov	 DWORD PTR [eax], ebx
  00130	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00133	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 165  : 				}
; 166  : 			else

  00139	eb 67		 jmp	 SHORT $LN17@overflow
$LN12@overflow:

; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);

  0013b	8b c3		 mov	 eax, ebx
  0013d	2b c1		 sub	 eax, ecx
  0013f	01 46 38	 add	 DWORD PTR [esi+56], eax

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

  00142	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00145	8b 10		 mov	 edx, DWORD PTR [eax]
  00147	8b c3		 mov	 eax, ebx
  00149	2b 45 fc	 sub	 eax, DWORD PTR __Oldptr$1$[ebp]
  0014c	2b d1		 sub	 edx, ecx
  0014e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00151	03 d3		 add	 edx, ebx
  00153	01 01		 add	 DWORD PTR [ecx], eax
  00155	8b cb		 mov	 ecx, ebx
  00157	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0015a	2b ca		 sub	 ecx, edx
  0015c	03 4d f8	 add	 ecx, DWORD PTR __Newsize$1$[ebp]
  0015f	89 10		 mov	 DWORD PTR [eax], edx
  00161	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00164	89 08		 mov	 DWORD PTR [eax], ecx

; 170  : 					_Newptr + (_Mysb::pptr() - _Oldptr),
; 171  : 					_Newptr + _Newsize);
; 172  : 				if (_Mystate & _Noread)

  00166	f6 46 3c 04	 test	 BYTE PTR [esi+60], 4
  0016a	74 15		 je	 SHORT $LN16@overflow

; 173  : 					_Mysb::setg(_Newptr, 0, _Newptr);

  0016c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0016f	89 18		 mov	 DWORD PTR [eax], ebx
  00171	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00174	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0017a	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0017d	89 18		 mov	 DWORD PTR [eax], ebx

; 174  : 				else

  0017f	eb 21		 jmp	 SHORT $LN17@overflow
$LN16@overflow:

; 175  : 					_Mysb::setg(_Newptr,

  00181	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00184	8b 10		 mov	 edx, DWORD PTR [eax]
  00186	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00189	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0018e	2b 4d fc	 sub	 ecx, DWORD PTR __Oldptr$1$[ebp]
  00191	03 cb		 add	 ecx, ebx
  00193	2b d1		 sub	 edx, ecx
  00195	89 18		 mov	 DWORD PTR [eax], ebx
  00197	42		 inc	 edx
  00198	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0019b	89 08		 mov	 DWORD PTR [eax], ecx
  0019d	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  001a0	89 10		 mov	 DWORD PTR [eax], edx
$LN17@overflow:

; 176  : 						_Newptr + (_Mysb::gptr() - _Oldptr),
; 177  : 						_Mysb::pptr() + 1);
; 178  : 				}
; 179  : 
; 180  : 			if (_Mystate & _Allocated)

  001a2	f6 46 3c 01	 test	 BYTE PTR [esi+60], 1
  001a6	74 0c		 je	 SHORT $LN18@overflow

; 181  : 				_Al.deallocate(_Oldptr, _Oldsize);

  001a8	57		 push	 edi
  001a9	ff 75 fc	 push	 DWORD PTR __Oldptr$1$[ebp]
  001ac	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
  001af	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate
$LN18@overflow:

; 182  : 			_Mystate |= _Allocated;
; 183  : 
; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  001b4	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  001b7	83 4e 3c 01	 or	 DWORD PTR [esi+60], 1
  001bb	5f		 pop	 edi
  001bc	5b		 pop	 ebx
  001bd	ff 08		 dec	 DWORD PTR [eax]
  001bf	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  001c2	5e		 pop	 esi
  001c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c5	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  001c8	89 01		 mov	 DWORD PTR [ecx], eax
  001ca	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  001cd	88 02		 mov	 BYTE PTR [edx], al

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

  001cf	8b e5		 mov	 esp, ebp
  001d1	5d		 pop	 ebp
  001d2	c2 04 00	 ret	 4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -32						; size = 4
__Nul$2 = -28						; size = 24
__Str$3 = -28						; size = 24
__Str$4 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT
; _this$ = ecx

; 93   : 		{	// return string copy of character array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b d1		 mov	 edx, ecx
  00012	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00019	56		 push	 esi
  0001a	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  0001d	8b 4a 3c	 mov	 ecx, DWORD PTR [edx+60]
  00020	f6 c1 02	 test	 cl, 2
  00023	75 7c		 jne	 SHORT $LN2@str
  00025	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	85 c0		 test	 eax, eax
  0002c	74 73		 je	 SHORT $LN2@str

; 95   : 			{	// writable, make string from write buffer
; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  0002e	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  00031	3b c8		 cmp	 ecx, eax
  00033	0f 42 c8	 cmovb	 ecx, eax
  00036	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	2b c8		 sub	 ecx, eax
  0003d	51		 push	 ecx
  0003e	50		 push	 eax
  0003f	8d 4d e4	 lea	 ecx, DWORD PTR __Str$4[ebp]
  00042	c7 45 f8 0f 00
	00 00		 mov	 DWORD PTR __Str$4[ebp+20], 15 ; 0000000fH
  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Str$4[ebp+16], 0
  00050	c6 45 e4 00	 mov	 BYTE PTR __Str$4[ebp], 0
  00054	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
; 98   : 			return (_Str);

  00059	8d 45 e4	 lea	 eax, DWORD PTR __Str$4[ebp]
  0005c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00063	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0006a	8b ce		 mov	 ecx, esi
  0006c	50		 push	 eax
  0006d	c6 06 00	 mov	 BYTE PTR [esi], 0
  00070	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00075	8b 4d f8	 mov	 ecx, DWORD PTR __Str$4[ebp+20]
  00078	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0007b	0f 82 9f 00 00
	00		 jb	 $LN261@str
  00081	41		 inc	 ecx
  00082	51		 push	 ecx
  00083	ff 75 e4	 push	 DWORD PTR __Str$4[ebp]
  00086	8d 4d e4	 lea	 ecx, DWORD PTR __Str$4[ebp]
  00089	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate

; 108  : 			return (_Nul);

  0008e	8b c6		 mov	 eax, esi
  00090	5e		 pop	 esi

; 109  : 			}
; 110  : 		}

  00091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00094	33 cd		 xor	 ecx, ebp
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 04 00	 ret	 4
$LN2@str:
  000a1	57		 push	 edi

; 99   : 			}
; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  000a2	f6 c1 04	 test	 cl, 4
  000a5	75 35		 jne	 SHORT $LN4@str
  000a7	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000aa	8b 38		 mov	 edi, DWORD PTR [eax]
  000ac	85 ff		 test	 edi, edi
  000ae	74 2c		 je	 SHORT $LN4@str

; 101  : 			{	// readable, make string from read buffer
; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());

  000b0	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000b8	03 cf		 add	 ecx, edi
  000ba	8b 00		 mov	 eax, DWORD PTR [eax]
  000bc	2b c8		 sub	 ecx, eax
  000be	51		 push	 ecx
  000bf	50		 push	 eax
  000c0	8d 4d e4	 lea	 ecx, DWORD PTR __Str$3[ebp]
  000c3	c7 45 f8 0f 00
	00 00		 mov	 DWORD PTR __Str$3[ebp+20], 15 ; 0000000fH
  000ca	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Str$3[ebp+16], 0
  000d1	c6 45 e4 00	 mov	 BYTE PTR __Str$3[ebp], 0
  000d5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 103  : 			return (_Str);

  000da	eb 12		 jmp	 SHORT $LN1032@str
$LN4@str:

; 104  : 			}
; 105  : 		else
; 106  : 			{	// inaccessible, return empty string
; 107  : 			_Mystr _Nul;

  000dc	c7 45 f8 0f 00
	00 00		 mov	 DWORD PTR __Nul$2[ebp+20], 15 ; 0000000fH
  000e3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Nul$2[ebp+16], 0
  000ea	c6 45 e4 00	 mov	 BYTE PTR __Nul$2[ebp], 0
$LN1032@str:

; 108  : 			return (_Nul);

  000ee	8d 45 e4	 lea	 eax, DWORD PTR __Nul$2[ebp]
  000f1	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  000f8	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000ff	8b ce		 mov	 ecx, esi
  00101	50		 push	 eax
  00102	c6 06 00	 mov	 BYTE PTR [esi], 0
  00105	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0010a	8b 45 f8	 mov	 eax, DWORD PTR __Nul$2[ebp+20]
  0010d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00110	72 0d		 jb	 SHORT $LN934@str
  00112	40		 inc	 eax
  00113	8d 4d e4	 lea	 ecx, DWORD PTR __Nul$2[ebp]
  00116	50		 push	 eax
  00117	ff 75 e4	 push	 DWORD PTR __Nul$2[ebp]
  0011a	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN934@str:
  0011f	5f		 pop	 edi

; 97   : 				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
; 98   : 			return (_Str);

$LN261@str:

; 109  : 			}
; 110  : 		}

  00120	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00123	8b c6		 mov	 eax, esi
  00125	33 cd		 xor	 ecx, ebp
  00127	5e		 pop	 esi
  00128	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c2 04 00	 ret	 4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 75   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 76   : 		_Tidy();

  0002b	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 77   : 		}

  00030	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  00036	8b 76 34	 mov	 esi, DWORD PTR [esi+52]
  00039	85 f6		 test	 esi, esi
  0003b	74 2a		 je	 SHORT $LN9@basic_stri
  0003d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	85 c9		 test	 ecx, ecx
  00049	74 11		 je	 SHORT $LN15@basic_stri
  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	ff 50 08	 call	 DWORD PTR [eax+8]
  00050	85 c0		 test	 eax, eax
  00052	74 08		 je	 SHORT $LN15@basic_stri
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	8b c8		 mov	 ecx, eax
  00058	6a 01		 push	 1
  0005a	ff 12		 call	 DWORD PTR [edx]
$LN15@basic_stri:
  0005c	6a 08		 push	 8
  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00064	83 c4 08	 add	 esp, 8
$LN9@basic_stri:
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00071	59		 pop	 ecx
  00072	5e		 pop	 esi
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$ = 8						; size = 4
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 28   : 	explicit basic_stringbuf(ios_base::openmode _Mode =

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode

  0002a	e8 00 00 00 00	 call	 ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
  0002f	8b 5d 08	 mov	 ebx, DWORD PTR __Mode$[ebp]

; 31   : 		_Init(0, 0, _Getstate(_Mode));

  00032	8b c3		 mov	 eax, ebx
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0003a	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00041	8d 14 9d 00 00
	00 00		 lea	 edx, DWORD PTR [ebx*4]
  00048	f7 d2		 not	 edx
  0004a	83 e2 04	 and	 edx, 4
  0004d	8b ca		 mov	 ecx, edx
  0004f	83 c9 02	 or	 ecx, 2
  00052	24 02		 and	 al, 2
  00054	8b c3		 mov	 eax, ebx
  00056	0f 45 ca	 cmovne	 ecx, edx
  00059	8b d1		 mov	 edx, ecx
  0005b	83 ca 08	 or	 edx, 8
  0005e	24 08		 and	 al, 8
  00060	0f 44 d1	 cmove	 edx, ecx
  00063	8b c2		 mov	 eax, edx
  00065	83 c8 10	 or	 eax, 16			; 00000010H
  00068	80 e3 04	 and	 bl, 4
  0006b	0f 44 c2	 cmove	 eax, edx
  0006e	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 32   : 		}

  00071	8b c6		 mov	 eax, esi
  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	8b 7e 34	 mov	 edi, DWORD PTR [esi+52]
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  0002f	85 ff		 test	 edi, edi
  00031	74 2a		 je	 SHORT $LN10@scalar
  00033	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	85 c9		 test	 ecx, ecx
  0003f	74 11		 je	 SHORT $LN16@scalar
  00041	8b 01		 mov	 eax, DWORD PTR [ecx]
  00043	ff 50 08	 call	 DWORD PTR [eax+8]
  00046	85 c0		 test	 eax, eax
  00048	74 08		 je	 SHORT $LN16@scalar
  0004a	8b 10		 mov	 edx, DWORD PTR [eax]
  0004c	8b c8		 mov	 ecx, eax
  0004e	6a 01		 push	 1
  00050	ff 12		 call	 DWORD PTR [edx]
$LN16@scalar:
  00052	6a 08		 push	 8
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0005a	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0005d	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00061	74 0b		 je	 SHORT $LN19@scalar
  00063	6a 38		 push	 56			; 00000038H
  00065	56		 push	 esi
  00066	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006b	83 c4 08	 add	 esp, 8
$LN19@scalar:
  0006e	8b c6		 mov	 eax, esi
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 449  : 		}

  00000	c2 04 00	 ret	 4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 444  : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 445  : 		}

  00002	c3		 ret	 0
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 439  : 		return (this);

  00000	8b c1		 mov	 eax, ecx

; 440  : 		}

  00002	c2 0c 00	 ret	 12			; 0000000cH
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 433  : 		{	// change to specified position, according to mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 434  : 		return (streampos(_BADOFF));

  00003	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB
  0000e	89 02		 mov	 DWORD PTR [edx], eax
  00010	8b c2		 mov	 eax, edx
  00012	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3_JB+4
  00018	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0001b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00022	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  00029	66 0f d6 42 10	 movq	 QWORD PTR [edx+16], xmm0

; 435  : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 8
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 427  : 		{	// change position by offset, according to way and mode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  : 		return (streampos(_BADOFF));

  00003	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_BADOFF@std@@3_JB
  0000e	89 02		 mov	 DWORD PTR [edx], eax
  00010	8b c2		 mov	 eax, edx
  00012	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_BADOFF@std@@3_JB+4
  00018	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0001b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00022	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  00029	66 0f d6 42 10	 movq	 QWORD PTR [edx+16], xmm0

; 429  : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
_TEXT	SEGMENT
__Copied$ = -16						; size = 8
__Size$2$ = -12						; size = 4
_this$1$ = -8						; size = 4
__Copied$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
__Copied$2$ = 16					; size = 4
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn, COMDAT
; _this$ = ecx

; 397  : 		{	// put _Count characters to stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 398  : 		streamsize _Size, _Copied;
; 399  : 
; 400  : 		for (_Copied = 0; 0 < _Count; )

  00007	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp+4]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  00010	66 0f 13 45 f0	 movlpd	 QWORD PTR __Copied$[ebp], xmm0
  00015	57		 push	 edi
  00016	85 db		 test	 ebx, ebx
  00018	0f 8c c0 00 00
	00		 jl	 $LN38@xsputn
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00021	7f 08		 jg	 SHORT $LN37@xsputn
  00023	85 ff		 test	 edi, edi
  00025	0f 84 b3 00 00
	00		 je	 $LN38@xsputn
$LN37@xsputn:
  0002b	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  00031	89 55 10	 mov	 DWORD PTR __Copied$2$[ebp], edx
  00034	89 45 fc	 mov	 DWORD PTR __Copied$1$[ebp], eax
  00037	56		 push	 esi
$LL2@xsputn:

; 401  : 			if (0 < (_Size = _Pnavail()))

  00038	e8 00 00 00 00	 call	 ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
  0003d	8b f0		 mov	 esi, eax
  0003f	8b c2		 mov	 eax, edx
  00041	89 45 f4	 mov	 DWORD PTR __Size$2$[ebp], eax
  00044	85 c0		 test	 eax, eax
  00046	7c 4c		 jl	 SHORT $LN5@xsputn
  00048	7f 04		 jg	 SHORT $LN33@xsputn
  0004a	85 f6		 test	 esi, esi
  0004c	74 46		 je	 SHORT $LN5@xsputn
$LN33@xsputn:

; 402  : 				{	// copy to write buffer
; 403  : 				if (_Count < _Size)

  0004e	3b d8		 cmp	 ebx, eax
  00050	7f 0b		 jg	 SHORT $LN7@xsputn
  00052	7c 04		 jl	 SHORT $LN34@xsputn
  00054	3b fe		 cmp	 edi, esi
  00056	73 05		 jae	 SHORT $LN7@xsputn
$LN34@xsputn:

; 404  : 					_Size = _Count;

  00058	8b f7		 mov	 esi, edi
  0005a	89 5d f4	 mov	 DWORD PTR __Size$2$[ebp], ebx
$LN7@xsputn:

; 405  : 				_Traits::copy(pptr(), _Ptr, (size_t)_Size);

  0005d	85 f6		 test	 esi, esi
  0005f	74 14		 je	 SHORT $LN16@xsputn
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00064	56		 push	 esi
  00065	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00068	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0006b	ff 30		 push	 DWORD PTR [eax]
  0006d	e8 00 00 00 00	 call	 _memcpy
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@xsputn:

; 406  : 				_Ptr += _Size;

  00075	01 75 08	 add	 DWORD PTR __Ptr$[ebp], esi

; 407  : 				_Copied += _Size;

  00078	01 75 fc	 add	 DWORD PTR __Copied$1$[ebp], esi
  0007b	8b 45 f4	 mov	 eax, DWORD PTR __Size$2$[ebp]
  0007e	11 45 10	 adc	 DWORD PTR __Copied$2$[ebp], eax

; 408  : 				_Count -= _Size;

  00081	2b fe		 sub	 edi, esi

; 409  : 				pbump((int)_Size);

  00083	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00086	1b d8		 sbb	 ebx, eax
  00088	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0008b	29 30		 sub	 DWORD PTR [eax], esi
  0008d	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00090	01 30		 add	 DWORD PTR [eax], esi
  00092	eb 29		 jmp	 SHORT $LN9@xsputn
$LN5@xsputn:

; 410  : 				}
; 411  : 			else if (_Traits::eq_int_type(_Traits::eof(),

  00094	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00097	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  0009a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009c	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0009f	50		 push	 eax
  000a0	ff 52 0c	 call	 DWORD PTR [edx+12]
  000a3	83 f8 ff	 cmp	 eax, -1
  000a6	74 27		 je	 SHORT $LN40@xsputn

; 412  : 				overflow(_Traits::to_int_type(*_Ptr))))
; 413  : 				break;	// single character put failed, quit
; 414  : 			else
; 415  : 				{	// count character successfully put
; 416  : 				++_Ptr;

  000a8	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000ab	46		 inc	 esi

; 417  : 				++_Copied;

  000ac	83 45 fc 01	 add	 DWORD PTR __Copied$1$[ebp], 1
  000b0	89 75 08	 mov	 DWORD PTR __Ptr$[ebp], esi
  000b3	83 55 10 00	 adc	 DWORD PTR __Copied$2$[ebp], 0

; 418  : 				--_Count;

  000b7	83 c7 ff	 add	 edi, -1
  000ba	83 d3 ff	 adc	 ebx, -1
$LN9@xsputn:

; 398  : 		streamsize _Size, _Copied;
; 399  : 
; 400  : 		for (_Copied = 0; 0 < _Count; )

  000bd	85 db		 test	 ebx, ebx
  000bf	0f 8f 73 ff ff
	ff		 jg	 $LL2@xsputn
  000c5	7c 08		 jl	 SHORT $LN40@xsputn
  000c7	85 ff		 test	 edi, edi
  000c9	0f 85 69 ff ff
	ff		 jne	 $LL2@xsputn
$LN40@xsputn:
  000cf	8b 55 10	 mov	 edx, DWORD PTR __Copied$2$[ebp]
  000d2	8b 45 fc	 mov	 eax, DWORD PTR __Copied$1$[ebp]
  000d5	5e		 pop	 esi
  000d6	5f		 pop	 edi
  000d7	5b		 pop	 ebx

; 419  : 				}
; 420  : 
; 421  : 		return (_Copied);
; 422  : 		}

  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c2 0c 00	 ret	 12			; 0000000cH
$LN38@xsputn:

; 398  : 		streamsize _Size, _Copied;
; 399  : 
; 400  : 		for (_Copied = 0; 0 < _Count; )

  000de	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  000e1	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  000e4	5f		 pop	 edi
  000e5	5b		 pop	 ebx

; 419  : 				}
; 420  : 
; 421  : 		return (_Copied);
; 422  : 		}

  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 0c 00	 ret	 12			; 0000000cH
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
_TEXT	SEGMENT
__Copied$ = -16						; size = 8
__Size$2$ = -12						; size = 4
_this$1$ = -8						; size = 4
__Copied$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
__Copied$2$ = 16					; size = 4
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn, COMDAT
; _this$ = ecx

; 368  : 		{	// get _Count characters from stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 369  : 		int_type _Meta;
; 370  : 		streamsize _Size, _Copied;
; 371  : 
; 372  : 		for (_Copied = 0; 0 < _Count; )

  00007	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp+4]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  00010	66 0f 13 45 f0	 movlpd	 QWORD PTR __Copied$[ebp], xmm0
  00015	57		 push	 edi
  00016	85 db		 test	 ebx, ebx
  00018	0f 8c be 00 00
	00		 jl	 $LN38@xsgetn
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00021	7f 08		 jg	 SHORT $LN37@xsgetn
  00023	85 ff		 test	 edi, edi
  00025	0f 84 b1 00 00
	00		 je	 $LN38@xsgetn
$LN37@xsgetn:
  0002b	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  0002e	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  00031	89 55 10	 mov	 DWORD PTR __Copied$2$[ebp], edx
  00034	89 45 fc	 mov	 DWORD PTR __Copied$1$[ebp], eax
  00037	56		 push	 esi
$LL2@xsgetn:

; 373  : 			if (0 < (_Size = _Gnavail()))

  00038	e8 00 00 00 00	 call	 ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
  0003d	8b f0		 mov	 esi, eax
  0003f	8b c2		 mov	 eax, edx
  00041	89 45 f4	 mov	 DWORD PTR __Size$2$[ebp], eax
  00044	85 c0		 test	 eax, eax
  00046	7c 4c		 jl	 SHORT $LN5@xsgetn
  00048	7f 04		 jg	 SHORT $LN33@xsgetn
  0004a	85 f6		 test	 esi, esi
  0004c	74 46		 je	 SHORT $LN5@xsgetn
$LN33@xsgetn:

; 374  : 				{	// copy from read buffer
; 375  : 				if (_Count < _Size)

  0004e	3b d8		 cmp	 ebx, eax
  00050	7f 0b		 jg	 SHORT $LN7@xsgetn
  00052	7c 04		 jl	 SHORT $LN34@xsgetn
  00054	3b fe		 cmp	 edi, esi
  00056	73 05		 jae	 SHORT $LN7@xsgetn
$LN34@xsgetn:

; 376  : 					_Size = _Count;

  00058	8b f7		 mov	 esi, edi
  0005a	89 5d f4	 mov	 DWORD PTR __Size$2$[ebp], ebx
$LN7@xsgetn:

; 377  : 				_Traits::copy(_Ptr, gptr(), (size_t)_Size);

  0005d	85 f6		 test	 esi, esi
  0005f	74 14		 je	 SHORT $LN16@xsgetn
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00064	56		 push	 esi
  00065	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00068	ff 30		 push	 DWORD PTR [eax]
  0006a	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0006d	e8 00 00 00 00	 call	 _memcpy
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@xsgetn:

; 378  : 				_Ptr += _Size;

  00075	01 75 08	 add	 DWORD PTR __Ptr$[ebp], esi

; 379  : 				_Copied += _Size;

  00078	01 75 fc	 add	 DWORD PTR __Copied$1$[ebp], esi
  0007b	8b 45 f4	 mov	 eax, DWORD PTR __Size$2$[ebp]
  0007e	11 45 10	 adc	 DWORD PTR __Copied$2$[ebp], eax

; 380  : 				_Count -= _Size;

  00081	2b fe		 sub	 edi, esi

; 381  : 				gbump((int)_Size);

  00083	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00086	1b d8		 sbb	 ebx, eax
  00088	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0008b	29 30		 sub	 DWORD PTR [eax], esi
  0008d	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00090	01 30		 add	 DWORD PTR [eax], esi
  00092	eb 27		 jmp	 SHORT $LN9@xsgetn
$LN5@xsgetn:

; 382  : 				}
; 383  : 			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  00094	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00097	8b 01		 mov	 eax, DWORD PTR [ecx]
  00099	ff 50 1c	 call	 DWORD PTR [eax+28]
  0009c	83 f8 ff	 cmp	 eax, -1
  0009f	74 2c		 je	 SHORT $LN40@xsgetn

; 384  : 				break;	// end of file, quit
; 385  : 			else
; 386  : 				{	// get a single character
; 387  : 				*_Ptr++ = _Traits::to_char_type(_Meta);

  000a1	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000a4	88 01		 mov	 BYTE PTR [ecx], al
  000a6	41		 inc	 ecx

; 388  : 				++_Copied;

  000a7	83 45 fc 01	 add	 DWORD PTR __Copied$1$[ebp], 1
  000ab	89 4d 08	 mov	 DWORD PTR __Ptr$[ebp], ecx
  000ae	83 55 10 00	 adc	 DWORD PTR __Copied$2$[ebp], 0

; 389  : 				--_Count;

  000b2	83 c7 ff	 add	 edi, -1
  000b5	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000b8	83 d3 ff	 adc	 ebx, -1
$LN9@xsgetn:

; 369  : 		int_type _Meta;
; 370  : 		streamsize _Size, _Copied;
; 371  : 
; 372  : 		for (_Copied = 0; 0 < _Count; )

  000bb	85 db		 test	 ebx, ebx
  000bd	0f 8f 75 ff ff
	ff		 jg	 $LL2@xsgetn
  000c3	7c 08		 jl	 SHORT $LN40@xsgetn
  000c5	85 ff		 test	 edi, edi
  000c7	0f 85 6b ff ff
	ff		 jne	 $LL2@xsgetn
$LN40@xsgetn:
  000cd	8b 55 10	 mov	 edx, DWORD PTR __Copied$2$[ebp]
  000d0	8b 45 fc	 mov	 eax, DWORD PTR __Copied$1$[ebp]
  000d3	5e		 pop	 esi
  000d4	5f		 pop	 edi
  000d5	5b		 pop	 ebx

; 390  : 				}
; 391  : 
; 392  : 		return (_Copied);
; 393  : 		}

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 0c 00	 ret	 12			; 0000000cH
$LN38@xsgetn:

; 369  : 		int_type _Meta;
; 370  : 		streamsize _Size, _Copied;
; 371  : 
; 372  : 		for (_Copied = 0; 0 < _Count; )

  000dc	8b 55 f4	 mov	 edx, DWORD PTR __Copied$[ebp+4]
  000df	8b 45 f0	 mov	 eax, DWORD PTR __Copied$[ebp]
  000e2	5f		 pop	 edi
  000e3	5b		 pop	 ebx

; 390  : 				}
; 391  : 
; 392  : 		return (_Copied);
; 393  : 		}

  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 0c 00	 ret	 12			; 0000000cH
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 361  : 		{	// get a character from stream, point past it

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 362  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 50 18	 call	 DWORD PTR [eax+24]
  00008	83 f8 ff	 cmp	 eax, -1
  0000b	75 04		 jne	 SHORT $LN3@uflow
  0000d	0b c0		 or	 eax, eax
  0000f	5e		 pop	 esi

; 363  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
; 364  : 		}

  00010	c3		 ret	 0
$LN3@uflow:

; 362  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())

  00011	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00014	ff 08		 dec	 DWORD PTR [eax]
  00016	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00019	5e		 pop	 esi
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0001f	89 01		 mov	 DWORD PTR [ecx], eax
  00021	0f b6 02	 movzx	 eax, BYTE PTR [edx]

; 363  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
; 364  : 		}

  00024	c3		 ret	 0
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::uflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 357  : 		return (_Traits::eof());

  00000	83 c8 ff	 or	 eax, -1

; 358  : 		}

  00003	c3		 ret	 0
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
_TEXT	SEGMENT
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc, COMDAT
; _this$ = ecx

; 352  : 		return (0);

  00000	33 c0		 xor	 eax, eax
  00002	33 d2		 xor	 edx, edx

; 353  : 		}

  00004	c3		 ret	 0
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 347  : 		return (_Traits::eof());

  00000	83 c8 ff	 or	 eax, -1

; 348  : 		}

  00003	c2 04 00	 ret	 4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 342  : 		return (_Traits::eof());

  00000	83 c8 ff	 or	 eax, -1

; 343  : 		}

  00003	c2 04 00	 ret	 4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 319  : 		_IGfirst = &_Gfirst;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 320  : 		_IPfirst = &_Pfirst;

  00006	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]

; 321  : 		_IGnext = &_Gnext;

  00009	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]
  0000c	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000f	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 322  : 		_IPnext = &_Pnext;

  00012	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00015	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 323  : 		_IGcount = &_Gcount;

  00018	8d 41 24	 lea	 eax, DWORD PTR [ecx+36]
  0001b	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 324  : 		_IPcount = &_Pcount;

  0001e	8d 41 28	 lea	 eax, DWORD PTR [ecx+40]
  00021	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 325  : 		setp(0, 0);

  00024	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0002a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00033	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00036	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 326  : 		setg(0, 0, 0);

  0003c	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00045	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00048	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0004e	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 327  : 		}

  00057	c3		 ret	 0
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT
; _this$ = ecx

; 314  : 		return (*_IPnext != 0 ? *_IPcount : 0);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 07		 je	 SHORT $LN3@Pnavail
  00008	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	99		 cdq

; 315  : 		}

  0000e	c3		 ret	 0
$LN3@Pnavail:

; 314  : 		return (*_IPnext != 0 ? *_IPcount : 0);

  0000f	33 c0		 xor	 eax, eax
  00011	99		 cdq

; 315  : 		}

  00012	c3		 ret	 0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 308  : 		--*_IPcount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 309  : 		return ((*_IPnext)++);

  00005	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00008	8b 02		 mov	 eax, DWORD PTR [edx]
  0000a	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0000d	89 0a		 mov	 DWORD PTR [edx], ecx

; 310  : 		}

  0000f	c3		 ret	 0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Next$ = 12						; size = 4
__Last$ = 16						; size = 4
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setp, COMDAT
; _this$ = ecx

; 300  : 		{	// set pointers for write buffer, extended version

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 301  : 		*_IPfirst = _First;

  00003	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi

; 302  : 		*_IPnext = _Next;
; 303  : 		*_IPcount = (int)(_Last - _Next);

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	89 02		 mov	 DWORD PTR [edx], eax
  0000f	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00012	8b 55 0c	 mov	 edx, DWORD PTR __Next$[ebp]
  00015	2b f2		 sub	 esi, edx
  00017	89 10		 mov	 DWORD PTR [eax], edx
  00019	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0001c	89 30		 mov	 DWORD PTR [eax], esi
  0001e	5e		 pop	 esi

; 304  : 		}

  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setp, COMDAT
; _this$ = ecx

; 293  : 		{	// set pointers for write buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 294  : 		*_IPfirst = _First;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 295  : 		*_IPnext = _First;
; 296  : 		*_IPcount = (int)(_Last - _First);

  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b d6		 sub	 edx, esi
  0000f	89 30		 mov	 DWORD PTR [eax], esi
  00011	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00014	89 30		 mov	 DWORD PTR [eax], esi
  00016	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00019	5e		 pop	 esi
  0001a	89 10		 mov	 DWORD PTR [eax], edx

; 297  : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbump, COMDAT
; _this$ = ecx

; 287  : 		{	// alter current position in write buffer by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 288  : 		*_IPcount -= _Off;

  00003	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00009	29 10		 sub	 DWORD PTR [eax], edx

; 289  : 		*_IPnext += _Off;

  0000b	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0000e	01 10		 add	 DWORD PTR [eax], edx

; 290  : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail, COMDAT
; _this$ = ecx

; 283  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00003	83 38 00	 cmp	 DWORD PTR [eax], 0
  00006	74 07		 je	 SHORT $LN3@Gnavail
  00008	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	99		 cdq

; 284  : 		}

  0000e	c3		 ret	 0
$LN3@Gnavail:

; 283  : 		return (*_IGnext != 0 ? *_IGcount : 0);

  0000f	33 c0		 xor	 eax, eax
  00011	99		 cdq

; 284  : 		}

  00012	c3		 ret	 0
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT
; _this$ = ecx

; 271  : 		--*_IGcount;

  00000	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00003	ff 08		 dec	 DWORD PTR [eax]

; 272  : 		return ((*_IGnext)++);

  00005	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00008	8b 02		 mov	 eax, DWORD PTR [edx]
  0000a	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0000d	89 0a		 mov	 DWORD PTR [edx], ecx

; 273  : 		}

  0000f	c3		 ret	 0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::epptr, COMDAT
; _this$ = ecx

; 260  : 		return (*_IPnext + *_IPcount);

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00003	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	03 01		 add	 eax, DWORD PTR [ecx]

; 261  : 		}

  0000a	c3		 ret	 0
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::epptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Next$ = 12						; size = 4
__Last$ = 16						; size = 4
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::setg, COMDAT
; _this$ = ecx

; 252  : 		{	// set pointers for read buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 253  : 		*_IGfirst = _First;

  00003	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	56		 push	 esi

; 254  : 		*_IGnext = _Next;
; 255  : 		*_IGcount = (int)(_Last - _Next);

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  0000d	89 02		 mov	 DWORD PTR [edx], eax
  0000f	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00012	8b 55 0c	 mov	 edx, DWORD PTR __Next$[ebp]
  00015	2b f2		 sub	 esi, edx
  00017	89 10		 mov	 DWORD PTR [eax], edx
  00019	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0001c	89 30		 mov	 DWORD PTR [eax], esi
  0001e	5e		 pop	 esi

; 256  : 		}

  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::gbump, COMDAT
; _this$ = ecx

; 246  : 		{	// alter current position in read buffer by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 247  : 		*_IGcount -= _Off;

  00003	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00009	29 10		 sub	 DWORD PTR [eax], edx

; 248  : 		*_IGnext += _Off;

  0000b	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0000e	01 10		 add	 DWORD PTR [eax], edx

; 249  : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gbump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::egptr, COMDAT
; _this$ = ecx

; 242  : 		return (*_IGnext + *_IGcount);

  00000	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00003	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	03 01		 add	 eax, DWORD PTR [ecx]

; 243  : 		}

  0000a	c3		 ret	 0
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::egptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pptr, COMDAT
; _this$ = ecx

; 237  : 		return (*_IPnext);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 238  : 		}

  00005	c3		 ret	 0
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pbase, COMDAT
; _this$ = ecx

; 232  : 		return (*_IPfirst);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 233  : 		}

  00005	c3		 ret	 0
?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT
; _this$ = ecx

; 227  : 		return (*_IGnext);

  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 228  : 		}

  00005	c3		 ret	 0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::eback, COMDAT
; _this$ = ecx

; 222  : 		return (*_IGfirst);

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]

; 223  : 		}

  00005	c3		 ret	 0
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::eback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 217  : 		}

  00000	c3		 ret	 0
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 213  : 		}

  00000	c3		 ret	 0
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputn, COMDAT
; _this$ = ecx

; 207  : 		{	// put _Count characters from array beginning at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (xsputn(_Ptr, _Count));

  00003	ff 75 10	 push	 DWORD PTR __Count$[ebp+4]
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0000b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000e	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00011	ff d0		 call	 eax

; 209  : 		}

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT
; _this$ = ecx

; 199  : 		{	// put a character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 200  : 		return (0 < _Pnavail()

  00003	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00006	83 38 00	 cmp	 DWORD PTR [eax], 0
  00009	74 22		 je	 SHORT $LN3@sputc
  0000b	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0000e	8b 02		 mov	 eax, DWORD PTR [edx]
  00010	85 c0		 test	 eax, eax
  00012	7e 19		 jle	 SHORT $LN3@sputc
  00014	48		 dec	 eax
  00015	89 02		 mov	 DWORD PTR [edx], eax
  00017	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0001f	89 01		 mov	 DWORD PTR [ecx], eax
  00021	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]
  00024	88 02		 mov	 BYTE PTR [edx], al
  00026	0f b6 c0	 movzx	 eax, al

; 201  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 202  : 			: overflow(_Traits::to_int_type(_Ch)));
; 203  : 		}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
$LN3@sputc:

; 200  : 		return (0 < _Pnavail()

  0002d	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00031	8b 11		 mov	 edx, DWORD PTR [ecx]
  00033	89 45 08	 mov	 DWORD PTR __Ch$[ebp], eax

; 201  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 202  : 			: overflow(_Traits::to_int_type(_Ch)));
; 203  : 		}

  00036	5d		 pop	 ebp

; 200  : 		return (0 < _Pnavail()

  00037	ff 62 0c	 jmp	 DWORD PTR [edx+12]
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 145  : 		return (sync());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 34	 jmp	 DWORD PTR [eax+52]
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 79   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 80   : 		delete _Plocale;

  00023	8b 71 34	 mov	 esi, DWORD PTR [ecx+52]
  00026	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  0002c	85 f6		 test	 esi, esi
  0002e	74 2a		 je	 SHORT $LN6@basic_stre
  00030	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	85 c9		 test	 ecx, ecx
  0003c	74 11		 je	 SHORT $LN12@basic_stre
  0003e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00040	ff 50 08	 call	 DWORD PTR [eax+8]
  00043	85 c0		 test	 eax, eax
  00045	74 08		 je	 SHORT $LN12@basic_stre
  00047	8b 10		 mov	 edx, DWORD PTR [eax]
  00049	8b c8		 mov	 ecx, eax
  0004b	6a 01		 push	 1
  0004d	ff 12		 call	 DWORD PTR [edx]
$LN12@basic_stre:
  0004f	6a 08		 push	 8
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00057	83 c4 08	 add	 esp, 8
$LN6@basic_stre:

; 81   : 		}

  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5e		 pop	 esi
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
;	COMDAT ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 26   : 		{	// construct with no buffers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 25   : 		: _Plocale(new locale)

  00026	6a 08		 push	 8

; 26   : 		{	// construct with no buffers

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	8b f8		 mov	 edi, eax
  00035	83 c4 04	 add	 esp, 4
  00038	85 ff		 test	 edi, edi
  0003a	74 16		 je	 SHORT $LN3@basic_stre

; 25   : 		: _Plocale(new locale)

  0003c	6a 01		 push	 1
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00050	eb 02		 jmp	 SHORT $LN4@basic_stre
$LN3@basic_stre:
  00052	33 ff		 xor	 edi, edi
$LN4@basic_stre:

; 27   : 		_Init();

  00054	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00057	89 7e 34	 mov	 DWORD PTR [esi+52], edi
  0005a	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0005d	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00060	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00063	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00066	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00069	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  0006c	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0006f	8d 46 24	 lea	 eax, DWORD PTR [esi+36]
  00072	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  00075	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  00078	89 46 30	 mov	 DWORD PTR [esi+48], eax
  0007b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00081	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00084	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0008a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0008d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00093	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00096	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0009c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0009f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000a5	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000a8	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 28   : 		}

  000ae	8b c6		 mov	 eax, esi
  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT
; _this$ = ecx

; 644  : 		{	// return string copy of character array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 645  : 		return (_Stringbuffer.str());

  00004	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00007	83 c1 18	 add	 ecx, 24			; 00000018H
  0000a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00011	e8 00 00 00 00	 call	 ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 646  : 		}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 635  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx
  00026	8b 47 98	 mov	 eax, DWORD PTR [edi-104]

; 636  : 		}

  00029	8d 4f b0	 lea	 ecx, DWORD PTR [edi-80]
  0002c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002f	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00037	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  0003a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003d	8d 42 98	 lea	 eax, DWORD PTR [edx-104]
  00040	89 44 3a 94	 mov	 DWORD PTR [edx+edi-108], eax
  00044	c7 47 b0 00 00
	00 00		 mov	 DWORD PTR [edi-80], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0004b	e8 00 00 00 00	 call	 ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00050	8b 77 e4	 mov	 esi, DWORD PTR [edi-28]
  00053	c7 47 b0 00 00
	00 00		 mov	 DWORD PTR [edi-80], OFFSET ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
  0005a	85 f6		 test	 esi, esi
  0005c	74 2a		 je	 SHORT $LN12@basic_stri
  0005e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00061	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	85 c9		 test	 ecx, ecx
  0006a	74 11		 je	 SHORT $LN18@basic_stri
  0006c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006e	ff 50 08	 call	 DWORD PTR [eax+8]
  00071	85 c0		 test	 eax, eax
  00073	74 08		 je	 SHORT $LN18@basic_stri
  00075	8b 10		 mov	 edx, DWORD PTR [eax]
  00077	8b c8		 mov	 ecx, eax
  00079	6a 01		 push	 1
  0007b	ff 12		 call	 DWORD PTR [edx]
$LN18@basic_stri:
  0007d	6a 08		 push	 8
  0007f	56		 push	 esi
  00080	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00085	83 c4 08	 add	 esp, 8
$LN12@basic_stri:
  00088	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  0008b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008e	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  00096	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  00099	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009c	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  0009f	89 44 39 94	 mov	 DWORD PTR [ecx+edi-108], eax
  000a3	8b 47 a8	 mov	 eax, DWORD PTR [edi-88]
  000a6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a9	c7 44 38 a8 00
	00 00 00	 mov	 DWORD PTR [eax+edi-88], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  000b1	8b 47 a8	 mov	 eax, DWORD PTR [edi-88]
  000b4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b7	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  000ba	89 44 39 a4	 mov	 DWORD PTR [ecx+edi-92], eax
  000be	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  000c1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c4	c7 44 38 98 00
	00 00 00	 mov	 DWORD PTR [eax+edi-104], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  000cc	8b 47 98	 mov	 eax, DWORD PTR [edi-104]
  000cf	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d2	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  000d5	89 44 39 94	 mov	 DWORD PTR [ecx+edi-108], eax
  000d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e3	59		 pop	 ecx
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$ = 8						; size = 4
_this$ = 12						; size = 4
_$initVBases$ = 12					; size = 4
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 591  : 		{	// construct empty character buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  0002d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00034	83 7d 0c 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  00038	74 22		 je	 SHORT $LN2@basic_stri
  0003a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  00040	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00047	c7 47 68 00 00
	00 00		 mov	 DWORD PTR [edi+104], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00055	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_stri:

; 589  : 		: _Mybase(&_Stringbuffer),

  0005c	6a 00		 push	 0
  0005e	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  00061	8b cf		 mov	 ecx, edi
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 ??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >

; 591  : 		{	// construct empty character buffer

  00069	8b 07		 mov	 eax, DWORD PTR [edi]
  0006b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00072	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00075	c7 04 07 00 00
	00 00		 mov	 DWORD PTR [edi+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0007c	8b 07		 mov	 eax, DWORD PTR [edi]
  0007e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00081	89 75 0c	 mov	 DWORD PTR _this$[ebp], esi
  00084	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00087	89 44 39 fc	 mov	 DWORD PTR [ecx+edi-4], eax
  0008b	8b ce		 mov	 ecx, esi
  0008d	e8 00 00 00 00	 call	 ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
  00092	8b 5d 08	 mov	 ebx, DWORD PTR __Mode$[ebp]
  00095	8b c3		 mov	 eax, ebx
  00097	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0009d	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  000a4	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  000ab	f7 d1		 not	 ecx
  000ad	83 e1 04	 and	 ecx, 4
  000b0	8b d1		 mov	 edx, ecx
  000b2	83 ca 02	 or	 edx, 2
  000b5	24 02		 and	 al, 2
  000b7	8b c3		 mov	 eax, ebx
  000b9	0f 45 d1	 cmovne	 edx, ecx
  000bc	8b ca		 mov	 ecx, edx
  000be	83 c9 08	 or	 ecx, 8
  000c1	24 08		 and	 al, 8
  000c3	0f 44 ca	 cmove	 ecx, edx
  000c6	8b c1		 mov	 eax, ecx
  000c8	83 c8 10	 or	 eax, 16			; 00000010H
  000cb	80 e3 04	 and	 bl, 4
  000ce	0f 44 c1	 cmove	 eax, ecx
  000d1	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 592  : 		}

  000d4	8b c7		 mov	 eax, edi
  000d6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e0	59		 pop	 ecx
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_stri
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 68	 add	 ecx, 104		; 00000068H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN5@basic_stri:
  0001b	c3		 ret	 0
__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1:
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 20	 add	 ecx, 32			; 00000020H
  00022	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
__unwindfunclet$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$3:
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__ehhandler$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:
  0002f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00033	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00036	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
  00045	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_iostream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8d 51 20	 lea	 edx, DWORD PTR [ecx+32]
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	c7 44 10 e0 00
	00 00 00	 mov	 DWORD PTR [eax+edx-32], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  00032	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  0003b	89 44 11 dc	 mov	 DWORD PTR [ecx+edx-36], eax
  0003f	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  00042	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00045	c7 44 10 f0 00
	00 00 00	 mov	 DWORD PTR [eax+edx-16], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  0004d	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  00050	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00053	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  00056	89 44 11 ec	 mov	 DWORD PTR [ecx+edx-20], eax
  0005a	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	c7 44 10 e0 00
	00 00 00	 mov	 DWORD PTR [eax+edx-32], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00068	8b 42 e0	 mov	 eax, DWORD PTR [edx-32]
  0006b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006e	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00071	89 44 11 dc	 mov	 DWORD PTR [ecx+edx-36], eax
  00075	52		 push	 edx
  00076	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007d	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00083	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00088	83 c4 04	 add	 esp, 4
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00095	59		 pop	 ecx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ$4:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_iostream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_iostream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 71 e0	 lea	 esi, DWORD PTR [ecx-32]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00012	74 0b		 je	 SHORT $LN4@scalar
  00014	6a 68		 push	 104			; 00000068H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_G?$basic_iostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_iostream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 983  : 		{	// destroy the object

  00000	8b 41 e0	 mov	 eax, DWORD PTR [ecx-32]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 e0 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-32], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  0000e	8b 41 e0	 mov	 eax, DWORD PTR [ecx-32]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 e0	 lea	 eax, DWORD PTR [edx-32]
  00017	89 44 0a dc	 mov	 DWORD PTR [edx+ecx-36], eax

; 984  : 		}

  0001b	8d 51 f8	 lea	 edx, DWORD PTR [ecx-8]
  0001e	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	c7 44 10 f8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  0002c	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  0002f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00032	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  00035	89 44 11 f4	 mov	 DWORD PTR [ecx+edx-12], eax
  00039	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  0003c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003f	c7 44 10 e8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00047	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  0004a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004d	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00050	89 44 11 e4	 mov	 DWORD PTR [ecx+edx-28], eax
  00054	c3		 ret	 0
??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
_this$ = 12						; size = 4
_$initVBases$ = 12					; size = 4
??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 954  : 		{	// construct from stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00032	83 7d 0c 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  00036	74 22		 je	 SHORT $LN2@basic_iost
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0003e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], OFFSET ??_8?$basic_iostream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00045	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00053	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_iost:

; 952  : 		: _Myis(_Strbuf, false),

  0005a	8b 06		 mov	 eax, DWORD PTR [esi]
  0005c	6a 00		 push	 0
  0005e	ff 75 08	 push	 DWORD PTR __Strbuf$[ebp]
  00061	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00064	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  0006b	8b 06		 mov	 eax, DWORD PTR [esi]
  0006d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00070	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  00073	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax
  00077	8b 06		 mov	 eax, DWORD PTR [esi]
  00079	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00080	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00087	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008a	03 ce		 add	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init

; 953  : 			_Myos(_Noinit, false)

  00091	8d 56 10	 lea	 edx, DWORD PTR [esi+16]
  00094	89 55 0c	 mov	 DWORD PTR _this$[ebp], edx
  00097	8b 02		 mov	 eax, DWORD PTR [edx]
  00099	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0009c	c7 04 02 00 00
	00 00		 mov	 DWORD PTR [edx+eax], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  000a3	8b 02		 mov	 eax, DWORD PTR [edx]
  000a5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a8	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  000ab	89 44 11 fc	 mov	 DWORD PTR [ecx+edx-4], eax

; 954  : 		{	// construct from stream buffer pointer

  000af	8b 06		 mov	 eax, DWORD PTR [esi]
  000b1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b4	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  000bb	8b 06		 mov	 eax, DWORD PTR [esi]
  000bd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c0	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  000c3	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax

; 955  : 		}

  000c7	8b c6		 mov	 eax, esi
  000c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5e		 pop	 esi
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_iost
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 20	 add	 ecx, 32			; 00000020H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN5@basic_iost:
  0001b	c3		 ret	 0
__unwindfunclet$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z$1:
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 18	 add	 ecx, 24			; 00000018H
  00022	e9 00 00 00 00	 jmp	 ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
__ehhandler$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	c7 44 10 f8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  00032	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0003b	89 44 11 f4	 mov	 DWORD PTR [ecx+edx-12], eax
  0003f	52		 push	 edx
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  0004d	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00052	83 c4 04	 add	 esp, 4
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b d1		 mov	 edx, ecx
  00025	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00028	8d 72 f8	 lea	 esi, DWORD PTR [edx-8]
  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002e	c7 44 10 f8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0003e	89 44 11 f4	 mov	 DWORD PTR [ecx+edx-12], eax
  00042	52		 push	 edx
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00050	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00055	83 c4 04	 add	 esp, 4
  00058	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005c	74 0b		 je	 SHORT $LN16@scalar
  0005e	6a 50		 push	 80			; 00000050H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00066	83 c4 08	 add	 esp, 8
$LN16@scalar:
  00069	8b c6		 mov	 eax, esi
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
$T2 = -40						; size = 20
__Ok$3 = -20						; size = 8
__$EHRec$ = -12						; size = 12
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 574  : 		{	// flush output stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx

; 575  : 		if (_Myios::rdbuf() != 0)

  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	83 7c 30 38 00	 cmp	 DWORD PTR [eax+esi+56], 0
  00032	0f 84 ce 00 00
	00		 je	 $LN102@flush

; 576  : 			{	// buffer exists, flush it
; 577  : 			const sentry _Ok(*this);

  00038	56		 push	 esi
  00039	8d 4d ec	 lea	 ecx, DWORD PTR __Ok$3[ebp]
  0003c	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 578  : 
; 579  : 			if (_Ok && _Myios::rdbuf()->pubsync() == -1)

  00041	80 7d f0 00	 cmp	 BYTE PTR __Ok$3[ebp+4], 0
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	0f 84 83 00 00
	00		 je	 $LN56@flush
  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00057	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  0005b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005d	ff 50 34	 call	 DWORD PTR [eax+52]
  00060	83 f8 ff	 cmp	 eax, -1
  00063	75 70		 jne	 SHORT $LN56@flush

; 580  : 				_Myios::setstate(ios_base::badbit);	// sync failed

  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0006a	8b 44 32 10	 mov	 eax, DWORD PTR [edx+esi+16]
  0006e	03 d6		 add	 edx, esi
  00070	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00073	83 c9 04	 or	 ecx, 4
  00076	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0007a	0f 45 4a 0c	 cmovne	 ecx, DWORD PTR [edx+12]
  0007e	83 e1 13	 and	 ecx, 19			; 00000013H
  00081	83 c9 04	 or	 ecx, 4
  00084	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00087	23 c1		 and	 eax, ecx
  00089	74 4a		 je	 SHORT $LN56@flush
  0008b	a8 04		 test	 al, 4
  0008d	74 2a		 je	 SHORT $LN53@flush
  0008f	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN111@flush:
  00099	50		 push	 eax
  0009a	6a 01		 push	 1
  0009c	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0009f	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000a4	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000a9	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  000ac	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN112@flush:
$LN53@flush:
  000b9	a8 02		 test	 al, 2
  000bb	74 0c		 je	 SHORT $LN55@flush
  000bd	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  000c7	eb d0		 jmp	 SHORT $LN111@flush
$LN55@flush:
  000c9	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000d3	eb c4		 jmp	 SHORT $LN111@flush
$LN56@flush:

; 581  : 			}

  000d5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000dc	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  000e1	84 c0		 test	 al, al
  000e3	75 08		 jne	 SHORT $LN98@flush
  000e5	8b 4d ec	 mov	 ecx, DWORD PTR __Ok$3[ebp]
  000e8	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN98@flush:
  000ed	8b 4d ec	 mov	 ecx, DWORD PTR __Ok$3[ebp]
  000f0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000f4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f9	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
  000fd	85 c9		 test	 ecx, ecx
  000ff	74 05		 je	 SHORT $LN102@flush
  00101	8b 01		 mov	 eax, DWORD PTR [ecx]
  00103	ff 50 08	 call	 DWORD PTR [eax+8]
$LN102@flush:

; 582  : 		return (*this);

  00106	8b c6		 mov	 eax, esi

; 583  : 		}

  00108	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0010b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00112	59		 pop	 ecx
  00113	5e		 pop	 esi
  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c3		 ret	 0
$LN110@flush:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Ok$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$14:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$15:
  0000e	e8 00 00 00 00	 call	 ___std_terminate
  00013	c3		 ret	 0
__ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
$T2 = -112						; size = 20
$T3 = -92						; size = 20
$T4 = -72						; size = 20
$T5 = -52						; size = 8
$T6 = -52						; size = 8
$T7 = -44						; size = 8
__Ok$ = -36						; size = 8
__State$ = -28						; size = 4
$T8 = -24						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 291  : 		{	// insert an int

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 64	 sub	 esp, 100		; 00000064H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 292  : 		ios_base::iostate _State = ios_base::goodbit;
; 293  : 		const sentry _Ok(*this);

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	33 ff		 xor	 edi, edi
  00034	89 7d e4	 mov	 DWORD PTR __State$[ebp], edi
  00037	89 75 dc	 mov	 DWORD PTR __Ok$[ebp], esi
  0003a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003d	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00041	85 c9		 test	 ecx, ecx
  00043	74 05		 je	 SHORT $LN21@operator
  00045	8b 01		 mov	 eax, DWORD PTR [ecx]
  00047	ff 50 04	 call	 DWORD PTR [eax+4]
$LN21@operator:
  0004a	8b 06		 mov	 eax, DWORD PTR [esi]
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00053	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00056	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  0005b	75 11		 jne	 SHORT $LN17@operator
  0005d	8b 4c 30 3c	 mov	 ecx, DWORD PTR [eax+esi+60]
  00061	85 c9		 test	 ecx, ecx
  00063	74 09		 je	 SHORT $LN17@operator
  00065	3b ce		 cmp	 ecx, esi
  00067	74 05		 je	 SHORT $LN17@operator
  00069	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN17@operator:
  0006e	8b 06		 mov	 eax, DWORD PTR [esi]
  00070	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00073	03 ce		 add	 ecx, esi
  00075	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00079	0f 94 c0	 sete	 al
  0007c	88 45 e0	 mov	 BYTE PTR __Ok$[ebp+4], al
  0007f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 294  : 
; 295  : 		if (_Ok)

  00086	84 c0		 test	 al, al
  00088	74 75		 je	 SHORT $LN14@operator

; 296  : 			{	// state okay, use facet to insert
; 297  : 			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

  0008a	8d 45 d4	 lea	 eax, DWORD PTR $T7[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00093	50		 push	 eax
  00094	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00098	e8 00 00 00 00	 call	 ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
  0009d	83 c4 04	 add	 esp, 4
  000a0	8b d8		 mov	 ebx, eax
  000a2	8b 4d d8	 mov	 ecx, DWORD PTR $T7[ebp+4]
  000a5	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  000a9	85 c9		 test	 ecx, ecx
  000ab	74 11		 je	 SHORT $LN46@operator
  000ad	8b 11		 mov	 edx, DWORD PTR [ecx]
  000af	ff 52 08	 call	 DWORD PTR [edx+8]
  000b2	85 c0		 test	 eax, eax
  000b4	74 08		 je	 SHORT $LN46@operator
  000b6	8b 10		 mov	 edx, DWORD PTR [eax]
  000b8	8b c8		 mov	 ecx, eax
  000ba	6a 01		 push	 1
  000bc	ff 12		 call	 DWORD PTR [edx]
$LN46@operator:

; 298  : 			ios_base::fmtflags _Bfl =
; 299  : 				this->flags() & ios_base::basefield;
; 300  : 			long _Tmp = (_Bfl == ios_base::oct
; 301  : 				|| _Bfl == ios_base::hex)
; 302  : 				? (long)(unsigned int)_Val : (long)_Val;
; 303  : 
; 304  : 			_TRY_IO_BEGIN
; 305  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 306  : 				_Myios::fill(), _Tmp).failed())

  000be	8b 06		 mov	 eax, DWORD PTR [esi]
  000c0	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  000c3	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  000c7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ca	8a 44 31 40	 mov	 al, BYTE PTR [ecx+esi+64]
  000ce	03 ce		 add	 ecx, esi
  000d0	88 45 e8	 mov	 BYTE PTR $T8[ebp], al
  000d3	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  000d6	8b 03		 mov	 eax, DWORD PTR [ebx]
  000d8	51		 push	 ecx
  000d9	c6 45 cc 00	 mov	 BYTE PTR $T6[ebp], 0
  000dd	ff 71 38	 push	 DWORD PTR [ecx+56]
  000e0	8d 4d cc	 lea	 ecx, DWORD PTR $T5[ebp]
  000e3	ff 75 cc	 push	 DWORD PTR $T6[ebp]
  000e6	51		 push	 ecx
  000e7	8b cb		 mov	 ecx, ebx
  000e9	ff 50 24	 call	 DWORD PTR [eax+36]
  000ec	80 7d cc 00	 cmp	 BYTE PTR $T5[ebp], 0
  000f0	b8 04 00 00 00	 mov	 eax, 4
  000f5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  000fc	0f 45 f8	 cmovne	 edi, eax
$LN14@operator:

; 309  : 			}
; 310  : 
; 311  : 		_Myios::setstate(_State);

  000ff	8b 06		 mov	 eax, DWORD PTR [esi]
  00101	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00104	03 d6		 add	 edx, esi
  00106	85 ff		 test	 edi, edi
  00108	0f 84 ee 00 00
	00		 je	 $LN138@operator
  0010e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00111	0b c7		 or	 eax, edi
  00113	8b c8		 mov	 ecx, eax
  00115	83 c9 04	 or	 ecx, 4
  00118	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0011c	0f 45 c8	 cmovne	 ecx, eax
  0011f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00122	83 e1 17	 and	 ecx, 23			; 00000017H
  00125	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00128	23 c1		 and	 eax, ecx
  0012a	0f 84 cc 00 00
	00		 je	 $LN138@operator
  00130	a8 04		 test	 al, 4
  00132	74 70		 je	 SHORT $LN135@operator
  00134	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00139	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  0013e	50		 push	 eax
  0013f	6a 01		 push	 1
  00141	8d 4d b8	 lea	 ecx, DWORD PTR $T4[ebp]
  00144	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00149	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  0014e	8d 45 b8	 lea	 eax, DWORD PTR $T4[ebp]
  00151	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN192@operator:
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$0:

; 307  : 				_State |= ios_base::badbit;
; 308  : 			_CATCH_IO_END

  0015e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	8b 01		 mov	 eax, DWORD PTR [ecx]
  00163	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00166	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  0016a	03 d1		 add	 edx, ecx
  0016c	83 c8 04	 or	 eax, 4
  0016f	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00173	75 03		 jne	 SHORT $LN70@operator
  00175	83 c8 04	 or	 eax, 4
$LN70@operator:
  00178	83 e0 17	 and	 eax, 23			; 00000017H
  0017b	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0017e	85 42 10	 test	 DWORD PTR [edx+16], eax
  00181	75 18		 jne	 SHORT $LN73@operator
  00183	b8 00 00 00 00	 mov	 eax, $LN15@operator
  00188	c3		 ret	 0
$LN15@operator:
  00189	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0018c	8b 7d e4	 mov	 edi, DWORD PTR __State$[ebp]
  0018f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00196	e9 64 ff ff ff	 jmp	 $LN14@operator
$LN73@operator:
  0019b	6a 00		 push	 0
  0019d	6a 00		 push	 0
  0019f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN193@operator:

; 309  : 			}
; 310  : 
; 311  : 		_Myios::setstate(_State);

$LN135@operator:
  001a4	a8 02		 test	 al, 2
  001a6	74 2a		 je	 SHORT $LN137@operator
  001a8	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  001b2	50		 push	 eax
  001b3	6a 01		 push	 1
  001b5	8d 4d a4	 lea	 ecx, DWORD PTR $T3[ebp]
  001b8	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  001bd	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  001c2	8d 45 a4	 lea	 eax, DWORD PTR $T3[ebp]
  001c5	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN194@operator:
$LN137@operator:
  001d2	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  001d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  001dc	50		 push	 eax
  001dd	6a 01		 push	 1
  001df	8d 4d 90	 lea	 ecx, DWORD PTR $T2[ebp]
  001e2	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  001e7	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  001ec	8d 45 90	 lea	 eax, DWORD PTR $T2[ebp]
  001ef	c7 45 90 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  001f6	50		 push	 eax
  001f7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN195@operator:
$LN138@operator:

; 312  : 		return (*this);

  001fc	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 6
  00203	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  00208	84 c0		 test	 al, al
  0020a	75 07		 jne	 SHORT $LN179@operator
  0020c	8b ce		 mov	 ecx, esi
  0020e	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN179@operator:
  00213	8b 06		 mov	 eax, DWORD PTR [esi]
  00215	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+12], 7
  00219	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0021c	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00220	85 c9		 test	 ecx, ecx
  00222	74 05		 je	 SHORT $LN183@operator
  00224	8b 01		 mov	 eax, DWORD PTR [ecx]
  00226	ff 50 08	 call	 DWORD PTR [eax+8]
$LN183@operator:
  00229	8b c6		 mov	 eax, esi

; 313  : 		}

  0022b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0022e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00235	59		 pop	 ecx
  00236	5f		 pop	 edi
  00237	5e		 pop	 esi
  00238	5b		 pop	 ebx
  00239	8b e5		 mov	 esp, ebp
  0023b	5d		 pop	 ebp
  0023c	c2 04 00	 ret	 4
$LN191@operator:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$4:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$2:
  00008	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$3:
  00010	8d 4d d4	 lea	 ecx, DWORD PTR $T7[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$5:
  00018	e8 00 00 00 00	 call	 ___std_terminate
  0001d	c3		 ret	 0
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$32:
  0001e	e8 00 00 00 00	 call	 ___std_terminate
  00023	c3		 ret	 0
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$33:
  00024	e8 00 00 00 00	 call	 ___std_terminate
  00029	c3		 ret	 0
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:
  0002a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00031	8b 4a 8c	 mov	 ecx, DWORD PTR [edx-116]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00040	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T2 = -76						; size = 20
$T3 = -56						; size = 20
$T4 = -36						; size = 20
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 165  : 		{	// perform any wrapup

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 166  : 		_TRY_BEGIN
; 167  : 		if (this->good() && this->flags() & ios_base::unitbuf)

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00036	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00039	83 7c 30 0c 00	 cmp	 DWORD PTR [eax+esi+12], 0
  0003e	0f 85 d3 00 00
	00		 jne	 $LN9@Osfx
  00044	f6 44 30 14 02	 test	 BYTE PTR [eax+esi+20], 2
  00049	0f 84 c8 00 00
	00		 je	 $LN9@Osfx

; 168  : 			if (_Myios::rdbuf()->pubsync() == -1)	// flush stream as needed

  0004f	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
  00053	8b 01		 mov	 eax, DWORD PTR [ecx]
  00055	ff 50 34	 call	 DWORD PTR [eax+52]
  00058	83 f8 ff	 cmp	 eax, -1
  0005b	0f 85 b6 00 00
	00		 jne	 $LN9@Osfx

; 169  : 				_Myios::setstate(ios_base::badbit);

  00061	8b 06		 mov	 eax, DWORD PTR [esi]
  00063	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00066	8b 44 32 10	 mov	 eax, DWORD PTR [edx+esi+16]
  0006a	03 d6		 add	 edx, esi
  0006c	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0006f	83 c9 04	 or	 ecx, 4
  00072	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00076	0f 45 4a 0c	 cmovne	 ecx, DWORD PTR [edx+12]
  0007a	83 e1 13	 and	 ecx, 19			; 00000013H
  0007d	83 c9 04	 or	 ecx, 4
  00080	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00083	23 c1		 and	 eax, ecx
  00085	0f 84 8c 00 00
	00		 je	 $LN9@Osfx
  0008b	a8 04		 test	 al, 4
  0008d	74 2a		 je	 SHORT $LN34@Osfx
  0008f	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
  00099	50		 push	 eax
  0009a	6a 01		 push	 1
  0009c	8d 4d dc	 lea	 ecx, DWORD PTR $T4[ebp]
  0009f	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000a4	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000a9	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  000ac	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN80@Osfx:
$LN34@Osfx:
  000b9	a8 02		 test	 al, 2
  000bb	74 2a		 je	 SHORT $LN36@Osfx
  000bd	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  000c7	50		 push	 eax
  000c8	6a 01		 push	 1
  000ca	8d 4d c8	 lea	 ecx, DWORD PTR $T3[ebp]
  000cd	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000d2	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  000d7	8d 45 c8	 lea	 eax, DWORD PTR $T3[ebp]
  000da	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN81@Osfx:
$LN36@Osfx:
  000e7	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000f1	50		 push	 eax
  000f2	6a 01		 push	 1
  000f4	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp]
  000f7	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000fc	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00101	8d 45 b4	 lea	 eax, DWORD PTR $T2[ebp]
  00104	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN82@Osfx:
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0:

; 170  : 		_CATCH_ALL
; 171  : 		_CATCH_END

  00111	b8 00 00 00 00	 mov	 eax, $LN9@Osfx
  00116	c3		 ret	 0
$LN9@Osfx:

; 172  : 		}

  00117	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0011a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00121	59		 pop	 ecx
  00122	5f		 pop	 edi
  00123	5e		 pop	 esi
  00124	5b		 pop	 ebx
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
$LN79@Osfx:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 88   : 		{	// destroy the object

  00000	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 f8 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-8], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  0000e	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00017	89 44 0a f4	 mov	 DWORD PTR [edx+ecx-12], eax

; 89   : 		}

  0001b	c3		 ret	 0
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
__Addit$ = 12						; size = 1
_$initVBases$ = 16					; size = 4
??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 58   : 	__CLR_OR_THIS_CALL basic_ostream(_Uninitialized, bool _Addit = true)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 59   : 		{	// construct uninitialized

  0002b	83 7d 10 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00036	74 1b		 je	 SHORT $LN2@basic_ostr
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@
  0003e	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_ostr:

; 60   : 		if (_Addit)

  00053	80 7d 0c 00	 cmp	 BYTE PTR __Addit$[ebp], 0
  00057	8b 06		 mov	 eax, DWORD PTR [esi]
  00059	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005c	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  00063	8b 06		 mov	 eax, DWORD PTR [esi]
  00065	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00068	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0006b	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax
  0006f	74 10		 je	 SHORT $LN13@basic_ostr

; 61   : 			this->_Addstd(this);	// suppress for basic_iostream

  00071	8b 06		 mov	 eax, DWORD PTR [esi]
  00073	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00076	03 c6		 add	 eax, esi
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  0007e	83 c4 04	 add	 esp, 4
$LN13@basic_ostr:

; 62   : 		}

  00081	8b c6		 mov	 eax, esi
  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	5e		 pop	 esi
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN8@basic_ostr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 08	 add	 ecx, 8
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN8@basic_ostr:
  0001b	c3		 ret	 0
__ehhandler$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@W4_Uninitialized@1@_N@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
;	COMDAT ??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	8d 51 18	 lea	 edx, DWORD PTR [ecx+24]
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	c7 44 10 e8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00032	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0003b	89 44 11 e4	 mov	 DWORD PTR [ecx+edx-28], eax
  0003f	52		 push	 edx
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  0004d	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00052	83 c4 04	 add	 esp, 4
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ$2:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b d1		 mov	 edx, ecx
  00025	8b 42 e8	 mov	 eax, DWORD PTR [edx-24]
  00028	8d 72 e8	 lea	 esi, DWORD PTR [edx-24]
  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002e	c7 44 10 e8 00
	00 00 00	 mov	 DWORD PTR [eax+edx-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0003e	89 44 11 e4	 mov	 DWORD PTR [ecx+edx-28], eax
  00042	52		 push	 edx
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ios_base@std@@6B@
  00050	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00055	83 c4 04	 add	 esp, 4
  00058	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0005c	74 0b		 je	 SHORT $LN16@scalar
  0005e	6a 60		 push	 96			; 00000060H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00066	83 c4 08	 add	 esp, 8
$LN16@scalar:
  00069	8b c6		 mov	 eax, esi
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$3:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 81   : 		{	// destroy the object

  00000	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  00003	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00006	c7 44 08 e8 00
	00 00 00	 mov	 DWORD PTR [eax+ecx-24], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  0000e	8b 41 e8	 mov	 eax, DWORD PTR [ecx-24]
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	8d 42 e8	 lea	 eax, DWORD PTR [edx-24]
  00017	89 44 0a e4	 mov	 DWORD PTR [edx+ecx-28], eax

; 82   : 		}

  0001b	c3		 ret	 0
??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
_$initVBases$ = 16					; size = 4
??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 46   : 		{	// construct from stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  0002b	83 7d 10 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00036	74 1b		 je	 SHORT $LN2@basic_istr
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@
  0003e	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
$LN2@basic_istr:
  00053	8b 06		 mov	 eax, DWORD PTR [esi]

; 47   : 		_Myios::init(_Strbuf, _Isstd);

  00055	ff 75 0c	 push	 DWORD PTR __Isstd$[ebp]
  00058	ff 75 08	 push	 DWORD PTR __Strbuf$[ebp]
  0005b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005e	c7 04 06 00 00
	00 00		 mov	 DWORD PTR [esi+eax], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006a	8d 41 e8	 lea	 eax, DWORD PTR [ecx-24]
  0006d	89 44 31 fc	 mov	 DWORD PTR [ecx+esi-4], eax
  00071	8b 06		 mov	 eax, DWORD PTR [esi]
  00073	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0007a	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00081	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00084	03 ce		 add	 ecx, esi
  00086	e8 00 00 00 00	 call	 ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init

; 48   : 		}

  0008b	8b c6		 mov	 eax, esi
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	5e		 pop	 esi
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_istr
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 18	 add	 ecx, 24			; 00000018H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN5@basic_istr:
  0001b	c3		 ret	 0
__ehhandler$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::basic_istream<char,std::char_traits<char> >
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	56		 push	 esi
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00033	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00038	83 c4 04	 add	 esp, 4
  0003b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003f	74 0b		 je	 SHORT $LN10@scalar
  00041	6a 48		 push	 72			; 00000048H
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00049	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0004c	8b c6		 mov	 eax, esi
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00058	59		 pop	 ecx
  00059	5e		 pop	 esi
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ PROC	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 183  : 	__CLR_OR_THIS_CALL basic_ios()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  : 		{	// default constructor, do nothing
; 185  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
_TEXT	SEGMENT
$T2 = -60						; size = 20
$T3 = -40						; size = 20
$T4 = -20						; size = 8
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::init, COMDAT
; _this$ = ecx

; 170  : 		{	// initialize with stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx

; 171  : 		_Init();	// initialize ios_base

  00029	e8 00 00 00 00	 call	 ?_Init@ios_base@std@@IAEXXZ ; std::ios_base::_Init

; 172  : 		_Mystrbuf = _Strbuf;

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Strbuf$[ebp]

; 173  : 		_Tiestr = 0;
; 174  : 		_Fillch = widen(' ');

  00031	8b ce		 mov	 ecx, esi
  00033	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00036	8d 45 ec	 lea	 eax, DWORD PTR $T4[ebp]
  00039	50		 push	 eax
  0003a	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
  00041	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00046	50		 push	 eax
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004e	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00053	83 c4 04	 add	 esp, 4
  00056	8b f8		 mov	 edi, eax
  00058	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp+4]
  0005b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00062	85 c9		 test	 ecx, ecx
  00064	74 11		 je	 SHORT $LN11@init
  00066	8b 11		 mov	 edx, DWORD PTR [ecx]
  00068	ff 52 08	 call	 DWORD PTR [edx+8]
  0006b	85 c0		 test	 eax, eax
  0006d	74 08		 je	 SHORT $LN11@init
  0006f	8b 10		 mov	 edx, DWORD PTR [eax]
  00071	8b c8		 mov	 ecx, eax
  00073	6a 01		 push	 1
  00075	ff 12		 call	 DWORD PTR [edx]
$LN11@init:
  00077	8b 07		 mov	 eax, DWORD PTR [edi]
  00079	8b cf		 mov	 ecx, edi
  0007b	6a 20		 push	 32			; 00000020H
  0007d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00084	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00087	ff d0		 call	 eax

; 175  : 
; 176  : 		if (_Mystrbuf == 0)

  00089	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  0008d	88 46 40	 mov	 BYTE PTR [esi+64], al
  00090	75 79		 jne	 SHORT $LN33@init

; 177  : 			setstate(badbit);

  00092	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00095	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00098	83 e0 13	 and	 eax, 19			; 00000013H
  0009b	83 c8 04	 or	 eax, 4
  0009e	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  000a1	23 c8		 and	 ecx, eax
  000a3	74 66		 je	 SHORT $LN33@init
  000a5	f6 c1 04	 test	 cl, 4
  000a8	74 2a		 je	 SHORT $LN30@init
  000aa	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN76@init:
  000b4	50		 push	 eax
  000b5	6a 01		 push	 1
  000b7	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  000ba	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000bf	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  000c6	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  000c9	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
$LN77@init:
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN78@init:
$LN30@init:
  000d4	f6 c1 02	 test	 cl, 2
  000d7	74 0c		 je	 SHORT $LN32@init
  000d9	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  000e3	eb cf		 jmp	 SHORT $LN76@init
$LN32@init:
  000e5	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  000ef	50		 push	 eax
  000f0	6a 01		 push	 1
  000f2	8d 4d c4	 lea	 ecx, DWORD PTR $T2[ebp]
  000f5	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  000fa	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00101	8d 45 c4	 lea	 eax, DWORD PTR $T2[ebp]
  00104	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00109	eb c3		 jmp	 SHORT $LN77@init
$LN33@init:

; 178  : 
; 179  : 		if (_Isstd)

  0010b	80 7d 0c 00	 cmp	 BYTE PTR __Isstd$[ebp], 0
  0010f	74 09		 je	 SHORT $LN3@init

; 180  : 			_Addstd(this);	// special handling for standard streams

  00111	56		 push	 esi
  00112	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  00117	83 c4 04	 add	 esp, 4
$LN3@init:

; 181  : 		}

  0011a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00124	59		 pop	 ecx
  00125	5f		 pop	 edi
  00126	5e		 pop	 esi
  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c2 08 00	 ret	 8
$LN75@init:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z$1:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__ehhandler$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
_TEXT	SEGMENT
$T2 = -20						; size = 8
__$EHRec$ = -12						; size = 12
__Byte$ = 8						; size = 1
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z PROC ; std::basic_ios<char,std::char_traits<char> >::widen, COMDAT
; _this$ = ecx

; 130  : 		{	// convert _Byte to character using imbued locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 131  : 		const _Ctype& _Ctype_fac = _USE(getloc(), _Ctype);

  00026	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  0002f	50		 push	 eax
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00037	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  0003c	83 c4 04	 add	 esp, 4
  0003f	8b f0		 mov	 esi, eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp+4]
  00044	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0004b	85 c9		 test	 ecx, ecx
  0004d	74 11		 je	 SHORT $LN7@widen
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	ff 52 08	 call	 DWORD PTR [edx+8]
  00054	85 c0		 test	 eax, eax
  00056	74 08		 je	 SHORT $LN7@widen
  00058	8b 10		 mov	 edx, DWORD PTR [eax]
  0005a	8b c8		 mov	 ecx, eax
  0005c	6a 01		 push	 1
  0005e	ff 12		 call	 DWORD PTR [edx]
$LN7@widen:

; 132  : 		return (_Ctype_fac.widen(_Byte));

  00060	8b 06		 mov	 eax, DWORD PTR [esi]
  00062	8b ce		 mov	 ecx, esi
  00064	ff 75 08	 push	 DWORD PTR __Byte$[ebp]
  00067	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006e	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00071	ff d0		 call	 eax

; 133  : 		}

  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5e		 pop	 esi
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$1:
  00008	e8 00 00 00 00	 call	 ___std_terminate
  0000d	c3		 ret	 0
__ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::widen
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT
; _this$ = ecx

; 113  : 		return (_Fillch);

  00000	8a 41 40	 mov	 al, BYTE PTR [ecx+64]

; 114  : 		}

  00003	c3		 ret	 0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 92   : 		return (_Mystrbuf);

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]

; 93   : 		}

  00003	c3		 ret	 0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 80   : 		return (_Tiestr);

  00000	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]

; 81   : 		}

  00003	c3		 ret	 0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 58   : 		{	// merge _State into state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 59   : 		if (_State != goodbit)

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 1a		 je	 SHORT $LN2@setstate

; 60   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

  0000a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0000d	ff 75 0c	 push	 DWORD PTR __Reraise$[ebp]
  00010	0b d0		 or	 edx, eax
  00012	8b c2		 mov	 eax, edx
  00014	83 c8 04	 or	 eax, 4
  00017	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0001b	0f 45 c2	 cmovne	 eax, edx
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN2@setstate:

; 61   : 		}

  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 44   : 		{	// set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __State$[ebp]

; 45   : 		ios_base::clear((iostate)(_Mystrbuf == 0

  00006	ff 75 0c	 push	 DWORD PTR __Reraise$[ebp]
  00009	83 ca 04	 or	 edx, 4
  0000c	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00010	0f 45 55 08	 cmovne	 edx, DWORD PTR __State$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);
; 47   : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ PROC	; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 39   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 40   : 		}

  00022	51		 push	 ecx
  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
  00030	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00035	83 c4 04	 add	 esp, 4
  00038	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00042	59		 pop	 ecx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??1Finally798@?1??SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z@QAE@XZ
_TEXT	SEGMENT
??1Finally798@?1??SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z@QAE@XZ PROC ; `GostCrypt::BootEncryption::SetDriverServiceStartType'::`2'::Finally798::~Finally798, COMDAT
; _this$ = ecx

; 798  : 		finally_do_arg (SC_HANDLE, service, { CloseServiceHandle (finally_arg); });

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseServiceHandle@4
  00008	c3		 ret	 0
??1Finally798@?1??SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z@QAE@XZ ENDP ; `GostCrypt::BootEncryption::SetDriverServiceStartType'::`2'::Finally798::~Finally798
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??0Finally798@?1??SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z@QAE@PAUSC_HANDLE__@@@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
??0Finally798@?1??SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z@QAE@PAUSC_HANDLE__@@@Z PROC ; `GostCrypt::BootEncryption::SetDriverServiceStartType'::`2'::Finally798::Finally798, COMDAT
; _this$ = ecx

; 798  : 		finally_do_arg (SC_HANDLE, service, { CloseServiceHandle (finally_arg); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0Finally798@?1??SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z@QAE@PAUSC_HANDLE__@@@Z ENDP ; `GostCrypt::BootEncryption::SetDriverServiceStartType'::`2'::Finally798::Finally798
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??1Finally793@?1??SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z@QAE@XZ
_TEXT	SEGMENT
??1Finally793@?1??SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z@QAE@XZ PROC ; `GostCrypt::BootEncryption::SetDriverServiceStartType'::`2'::Finally793::~Finally793, COMDAT
; _this$ = ecx

; 793  : 		finally_do_arg (SC_HANDLE, serviceManager, { CloseServiceHandle (finally_arg); });

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseServiceHandle@4
  00008	c3		 ret	 0
??1Finally793@?1??SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z@QAE@XZ ENDP ; `GostCrypt::BootEncryption::SetDriverServiceStartType'::`2'::Finally793::~Finally793
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??0Finally793@?1??SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z@QAE@PAUSC_HANDLE__@@@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
??0Finally793@?1??SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z@QAE@PAUSC_HANDLE__@@@Z PROC ; `GostCrypt::BootEncryption::SetDriverServiceStartType'::`2'::Finally793::Finally793, COMDAT
; _this$ = ecx

; 793  : 		finally_do_arg (SC_HANDLE, serviceManager, { CloseServiceHandle (finally_arg); });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0Finally793@?1??SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z@QAE@PAUSC_HANDLE__@@@Z ENDP ; `GostCrypt::BootEncryption::SetDriverServiceStartType'::`2'::Finally793::Finally793
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2355 : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 2356 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;

  0002d	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00030	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00037	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0003e	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00045	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00049	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00050	72 04		 jb	 SHORT $LN107@operator
  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	eb 02		 jmp	 SHORT $LN108@operator
$LN107@operator:
  00056	8b c6		 mov	 eax, esi
$LN108@operator:
  00058	33 c9		 xor	 ecx, ecx
  0005a	66 89 08	 mov	 WORD PTR [eax], cx

; 2360 : 	return (_Ans);

  0005d	8b 7d 10	 mov	 edi, DWORD PTR __Right$[ebp]
  00060	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00063	89 4d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ecx
  00066	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  0006d	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  00070	66 39 0f	 cmp	 WORD PTR [edi], cx
  00073	74 1a		 je	 SHORT $LN129@operator

; 2357 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));

$LN128@operator:
  00075	8b cf		 mov	 ecx, edi
  00077	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL190@operator:
  00080	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00083	83 c1 02	 add	 ecx, 2
  00086	66 85 c0	 test	 ax, ax
  00089	75 f5		 jne	 SHORT $LL190@operator
  0008b	2b ca		 sub	 ecx, edx
  0008d	d1 f9		 sar	 ecx, 1
$LN129@operator:
  0008f	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00092	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  00095	3b d8		 cmp	 ebx, eax
  00097	77 28		 ja	 SHORT $LN176@operator
  00099	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  0009c	74 23		 je	 SHORT $LN176@operator
  0009e	6a 01		 push	 1
  000a0	50		 push	 eax
  000a1	8b ce		 mov	 ecx, esi
  000a3	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
  000a8	84 c0		 test	 al, al
  000aa	74 15		 je	 SHORT $LN176@operator
  000ac	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000b0	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000b3	72 04		 jb	 SHORT $LN171@operator
  000b5	8b 06		 mov	 eax, DWORD PTR [esi]
  000b7	eb 02		 jmp	 SHORT $LN172@operator
$LN171@operator:
  000b9	8b c6		 mov	 eax, esi
$LN172@operator:
  000bb	33 c9		 xor	 ecx, ecx
  000bd	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx
$LN176@operator:

; 2358 : 	_Ans += _Left;

  000c1	6a ff		 push	 -1
  000c3	6a 00		 push	 0
  000c5	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  000c8	8b ce		 mov	 ecx, esi
  000ca	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 2359 : 	_Ans += _Right;

  000cf	66 83 3f 00	 cmp	 WORD PTR [edi], 0
  000d3	75 04		 jne	 SHORT $LN188@operator
  000d5	33 c9		 xor	 ecx, ecx
  000d7	eb 16		 jmp	 SHORT $LN189@operator
$LN188@operator:
  000d9	8b cf		 mov	 ecx, edi
  000db	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  000de	66 90		 npad	 2
$LL191@operator:
  000e0	66 8b 01	 mov	 ax, WORD PTR [ecx]
  000e3	83 c1 02	 add	 ecx, 2
  000e6	66 85 c0	 test	 ax, ax
  000e9	75 f5		 jne	 SHORT $LL191@operator
  000eb	2b ca		 sub	 ecx, edx
  000ed	d1 f9		 sar	 ecx, 1
$LN189@operator:
  000ef	51		 push	 ecx
  000f0	57		 push	 edi
  000f1	8b ce		 mov	 ecx, esi
  000f3	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 2360 : 	return (_Ans);

  000f8	8b c6		 mov	 eax, esi

; 2361 : 	}

  000fa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00104	59		 pop	 ecx
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN4@operator:
  00018	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2439 : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2440 : 	return (_STD move(_Left.append(_Right)));

  00004	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000f	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  00013	75 04		 jne	 SHORT $LN9@operator
  00015	33 c0		 xor	 eax, eax
  00017	eb 16		 jmp	 SHORT $LN10@operator
$LN9@operator:
  00019	8b c2		 mov	 eax, edx
  0001b	8d 70 02	 lea	 esi, DWORD PTR [eax+2]
  0001e	66 90		 npad	 2
$LL141@operator:
  00020	66 8b 08	 mov	 cx, WORD PTR [eax]
  00023	83 c0 02	 add	 eax, 2
  00026	66 85 c9	 test	 cx, cx
  00029	75 f5		 jne	 SHORT $LL141@operator
  0002b	2b c6		 sub	 eax, esi
  0002d	d1 f8		 sar	 eax, 1
$LN10@operator:
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00032	50		 push	 eax
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00039	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0003c	33 c9		 xor	 ecx, ecx
  0003e	50		 push	 eax
  0003f	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00046	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004d	66 89 0e	 mov	 WORD PTR [esi], cx
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  00057	8b c6		 mov	 eax, esi
  00059	5e		 pop	 esi

; 2441 : 	}

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@0@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2403 : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2404 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2405 : 		|| _Right.capacity() - _Right.size() < _Left.size())

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Left$[ebp]
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	56		 push	 esi
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00015	8b 72 10	 mov	 esi, DWORD PTR [edx+16]
  00018	2b c6		 sub	 eax, esi
  0001a	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  0001d	76 18		 jbe	 SHORT $LN4@operator
  0001f	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00022	2b 41 10	 sub	 eax, DWORD PTR [ecx+16]
  00025	3b c6		 cmp	 eax, esi
  00027	72 0e		 jb	 SHORT $LN4@operator

; 2407 : 	else
; 2408 : 		return (_STD move(_Right.insert(0, _Left)));

  00029	6a ff		 push	 -1
  0002b	6a 00		 push	 0
  0002d	52		 push	 edx
  0002e	6a 00		 push	 0
  00030	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
  00035	eb 0c		 jmp	 SHORT $LN344@operator
$LN4@operator:

; 2406 : 		return (_STD move(_Left.append(_Right)));

  00037	6a ff		 push	 -1
  00039	6a 00		 push	 0
  0003b	51		 push	 ecx
  0003c	8b ca		 mov	 ecx, edx
  0003e	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN344@operator:
  00043	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00046	33 c9		 xor	 ecx, ecx
  00048	50		 push	 eax
  00049	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00050	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00057	66 89 0e	 mov	 WORD PTR [esi], cx
  0005a	8b ce		 mov	 ecx, esi
  0005c	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  00061	8b c6		 mov	 eax, esi
  00063	5e		 pop	 esi

; 2409 : 	}

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@0@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@@Z
_TEXT	SEGMENT
_forEachContainer$ = 8					; size = 4
___formal$ = 12						; size = 4
??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@@Z PROC ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >, COMDAT

; 95   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 96   : 			return static_cast <const ContainerForward <T> &> (forEachContainer);

  00003	8b 45 08	 mov	 eax, DWORD PTR _forEachContainer$[ebp]

; 97   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SAABU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABUContainer@01@ABU?$TypeWrapper@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@@Z ENDP ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$?BV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@12@XZ PROC ; GostCrypt::ForEach::TypeWrapperDummy::operator<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > > GostCrypt::ForEach::TypeWrapper<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >, COMDAT
; _this$ = ecx

; 90   : 			operator TypeWrapper <T> () const { return TypeWrapper <T> (); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
??$?BV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@TypeWrapperDummy@ForEach@GostCrypt@@QBE?AU?$TypeWrapper@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@12@XZ ENDP ; GostCrypt::ForEach::TypeWrapperDummy::operator<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > > GostCrypt::ForEach::TypeWrapper<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$ToTypeWrapper@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
_x$ = 8							; size = 4
??$ToTypeWrapper@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z PROC ; GostCrypt::ForEach::ToTypeWrapper<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >, COMDAT

; 85   : 		static TypeWrapper <T> ToTypeWrapper (const T &x) { return TypeWrapper <T> (); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8a 45 ff	 mov	 al, BYTE PTR $T1[ebp]
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$ToTypeWrapper@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$TypeWrapper@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z ENDP ; GostCrypt::ForEach::ToTypeWrapper<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z PROC ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx
  00007	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0000a	e8 00 00 00 00	 call	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear
  0000f	ff 77 08	 push	 DWORD PTR [edi+8]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
  0001a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00020	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00024	74 0b		 je	 SHORT $LN84@scalar
  00026	6a 18		 push	 24			; 00000018H
  00028	57		 push	 edi
  00029	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002e	83 c4 08	 add	 esp, 8
$LN84@scalar:
  00031	8b c7		 mov	 eax, edi
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??_G?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAEPAXI@Z ENDP ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
_TEXT	SEGMENT
??1?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ PROC ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::~ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
  00004	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00007	e8 00 00 00 00	 call	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear
  0000c	ff 77 08	 push	 DWORD PTR [edi+8]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	83 c4 04	 add	 esp, 4
  00017	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	c3		 ret	 0
??1?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ ENDP ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::~ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator!=, COMDAT
; _this$ = ecx

; 305  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 95 c0	 setne	 al

; 306  : 		return (!(*this == _Right));
; 307  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator==, COMDAT
; _this$ = ecx

; 289  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 290  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 291  : 		if (this->_Getcont() != _Right._Getcont())
; 292  : 			{	// report error
; 293  : 			_DEBUG_ERROR("list iterators incompatible");
; 294  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 295  : 			}
; 296  : 
; 297  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 298  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 299  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 300  : 
; 301  : 		return (this->_Ptr == _Right._Ptr);
; 302  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??F?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator--, COMDAT
; _this$ = ecx

; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 259  : 		if (_Mycont == 0
; 260  : 			|| this->_Ptr == nullptr_t{}
; 261  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr)) == _Mycont->_Myhead)
; 262  : 			{	// report error
; 263  : 			_DEBUG_ERROR("list iterator not decrementable");
; 264  : 			_SCL_SECURE_OUT_OF_RANGE;
; 265  : 			}
; 266  : 
; 267  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 268  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 269  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 270  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 271  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 272  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 273  : 
; 274  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 275  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00005	89 01		 mov	 DWORD PTR [ecx], eax

; 276  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 277  : 
; 278  : 		return (*this);

  00007	8b c1		 mov	 eax, ecx

; 279  : 		}

  00009	c3		 ret	 0
??F?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator++, COMDAT
; _this$ = ecx

; 249  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 250  : 		_Myiter _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx

; 251  : 		++*this;

  0000a	8b 12		 mov	 edx, DWORD PTR [edx]
  0000c	89 11		 mov	 DWORD PTR [ecx], edx

; 252  : 		return (_Tmp);
; 253  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator++, COMDAT
; _this$ = ecx

; 227  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 228  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 229  : 		if (_Mycont == 0
; 230  : 			|| this->_Ptr == nullptr_t{}
; 231  : 			|| this->_Ptr == _Mycont->_Myhead)
; 232  : 			{	// report error
; 233  : 			_DEBUG_ERROR("list iterator not incrementable");
; 234  : 			_SCL_SECURE_OUT_OF_RANGE;
; 235  : 			}
; 236  : 
; 237  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 238  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 239  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 240  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 241  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 242  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 243  : 
; 244  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 245  : 		return (*this);

  00006	8b c1		 mov	 eax, ecx

; 246  : 		}

  00008	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QBEABUPartition@GostCrypt@@XZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QBEABUPartition@GostCrypt@@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator*, COMDAT
; _this$ = ecx

; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 207  : 		if (_Mycont == 0
; 208  : 			|| this->_Ptr == nullptr_t{}
; 209  : 			|| this->_Ptr == _Mycont->_Myhead)
; 210  : 			{	// report error
; 211  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 212  : 			_SCL_SECURE_OUT_OF_RANGE;
; 213  : 			}
; 214  : 
; 215  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 216  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 217  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 218  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 219  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 220  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 221  : 
; 222  : 		return (_Mylist::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 223  : 		}

  00005	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QBEABUPartition@GostCrypt@@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Unchecked@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::_Unchecked, COMDAT
; _this$ = ecx

; 199  : 		{	// make an unchecked iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 200  : 		return (_Unchecked_type(this->_Ptr, static_cast<const _Mylist *>(this->_Getcont())));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 201  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Unchecked@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UPartition@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UPartition@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >, COMDAT
; _this$ = ecx

; 187  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 186  : 		: _Mybase(_Pnode, _Plist)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 188  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@PAU?$_List_node@UPartition@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 96   : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 97   : 		}

  00002	c3		 ret	 0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00005	89 01		 mov	 DWORD PTR [ecx], eax

; 74   : 		return (*this);

  00007	8b c1		 mov	 eax, ecx

; 75   : 		}

  00009	c3		 ret	 0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UPartition@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UPartition@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		: _Ptr(_Pnode)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@UPartition@GostCrypt@@PAX@1@PBV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?Next@?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ
_TEXT	SEGMENT
?Next@?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ PROC ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::Next, COMDAT
; _this$ = ecx

; 39   : 			virtual void Next () const { ++Iterator; }

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	8b 00		 mov	 eax, DWORD PTR [eax]
  00005	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00008	c3		 ret	 0
?Next@?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBEXXZ ENDP ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::Next
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?IsNotEnd@?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ
_TEXT	SEGMENT
?IsNotEnd@?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ PROC ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::IsNotEnd, COMDAT
; _this$ = ecx

; 38   : 			virtual bool IsNotEnd () const { bool r = InnerContinue && Iterator != EndIterator; InnerContinue = false; return r; }

  00000	80 79 04 00	 cmp	 BYTE PTR [ecx+4], 0
  00004	74 0f		 je	 SHORT $LN3@IsNotEnd
  00006	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00009	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  0000c	74 07		 je	 SHORT $LN3@IsNotEnd
  0000e	b0 01		 mov	 al, 1
  00010	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00014	c3		 ret	 0
$LN3@IsNotEnd:
  00015	32 c0		 xor	 al, al
  00017	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0001a	c3		 ret	 0
?IsNotEnd@?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UBE_NXZ ENDP ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::IsNotEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??0?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_container$ = 8						; size = 4
??0?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z PROC ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >, COMDAT
; _this$ = ecx

; 36   : 				: ContainerCopy (container), EndIterator (ContainerCopy.end()), Iterator (ContainerCopy.begin()) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002a	66 c7 47 04 01
	00		 mov	 WORD PTR [edi+4], 1
  00030	ff 75 08	 push	 DWORD PTR _container$[ebp]
  00033	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@
  00043	e8 00 00 00 00	 call	 ??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
  00048	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0004b	89 47 10	 mov	 DWORD PTR [edi+16], eax
  0004e	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 47 14	 mov	 DWORD PTR [edi+20], eax
  00056	8b c7		 mov	 eax, edi
  00058	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00062	59		 pop	 ecx
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Container@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::Container::~Container
__ehhandler$??0?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@QAE@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z ENDP ; GostCrypt::ForEach::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::ContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_container$ = 12					; size = 4
??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z PROC ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >, COMDAT

; 69   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 70   : 			return ContainerForward <T> (container);

  00025	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00028	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0002f	66 c7 47 04 01
	00		 mov	 WORD PTR [edi+4], 1
  00035	ff 75 0c	 push	 DWORD PTR _container$[ebp]
  00038	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@6B@
  00048	e8 00 00 00 00	 call	 ??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
  0004d	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00050	8b c7		 mov	 eax, edi
  00052	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  00055	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00058	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0005a	89 4f 14	 mov	 DWORD PTR [edi+20], ecx

; 71   : 		}

  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00060	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00067	59		 pop	 ecx
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z$1:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Container@ForEach@GostCrypt@@UAE@XZ ; GostCrypt::ForEach::Container::~Container
__ehhandler$??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z ENDP ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2393 : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2394 : 	return (_STD move(_Left.append(_Right)));

  00004	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00007	56		 push	 esi
  00008	6a ff		 push	 -1
  0000a	6a 00		 push	 0
  0000c	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00016	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0001b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	8b ce		 mov	 ecx, esi
  00020	50		 push	 eax
  00021	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00028	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00032	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00037	8b c6		 mov	 eax, esi
  00039	5e		 pop	 esi

; 2395 : 	}

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2403 : 	{	// return string + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2404 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2405 : 		|| _Right.capacity() - _Right.size() < _Left.size())

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Left$[ebp]
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	56		 push	 esi
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00015	8b 72 10	 mov	 esi, DWORD PTR [edx+16]
  00018	2b c6		 sub	 eax, esi
  0001a	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  0001d	76 18		 jbe	 SHORT $LN4@operator
  0001f	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00022	2b 41 10	 sub	 eax, DWORD PTR [ecx+16]
  00025	3b c6		 cmp	 eax, esi
  00027	72 0e		 jb	 SHORT $LN4@operator

; 2407 : 	else
; 2408 : 		return (_STD move(_Right.insert(0, _Left)));

  00029	6a ff		 push	 -1
  0002b	6a 00		 push	 0
  0002d	52		 push	 edx
  0002e	6a 00		 push	 0
  00030	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00035	eb 0c		 jmp	 SHORT $LN340@operator
$LN4@operator:

; 2406 : 		return (_STD move(_Left.append(_Right)));

  00037	6a ff		 push	 -1
  00039	6a 00		 push	 0
  0003b	51		 push	 ecx
  0003c	8b ca		 mov	 ecx, edx
  0003e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN340@operator:
  00043	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00046	8b ce		 mov	 ecx, esi
  00048	50		 push	 eax
  00049	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00050	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00057	c6 06 00	 mov	 BYTE PTR [esi], 0
  0005a	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0005f	8b c6		 mov	 eax, esi
  00061	5e		 pop	 esi

; 2409 : 	}

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?Show@GostCrypt@@YAXPAUHWND__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_str$ = 12						; size = 4
?Show@GostCrypt@@YAXPAUHWND__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; GostCrypt::Show, COMDAT

; 511  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 512  : 		MessageBox (parent, str.c_str(), NULL, 0);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  00006	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0000a	72 02		 jb	 SHORT $LN17@Show
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN17@Show:
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	50		 push	 eax
  00013	ff 75 08	 push	 DWORD PTR _parent$[ebp]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 513  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?Show@GostCrypt@@YAXPAUHWND__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; GostCrypt::Show
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?Elevate@Elevator@GostCrypt@@KAXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 8
?Elevate@Elevator@GostCrypt@@KAXXZ PROC			; GostCrypt::Elevator::Elevate, COMDAT

; 311  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 312  : 			if (IsAdmin())

  00006	e8 00 00 00 00	 call	 _IsAdmin
  0000b	85 c0		 test	 eax, eax
  0000d	75 52		 jne	 SHORT $LN14@Elevate

; 316  : 			}
; 317  : 
; 318  : 			if (!ElevatedComInstance || ElevatedComInstanceThreadId != GetCurrentThreadId())

  0000f	39 05 00 00 00
	00		 cmp	 DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A, eax ; GostCrypt::Elevator::ElevatedComInstance
  00015	74 0e		 je	 SHORT $LN4@Elevate
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  0001d	39 05 00 00 00
	00		 cmp	 DWORD PTR ?ElevatedComInstanceThreadId@Elevator@GostCrypt@@1KA, eax ; GostCrypt::Elevator::ElevatedComInstanceThreadId
  00023	74 38		 je	 SHORT $LN3@Elevate
$LN4@Elevate:

; 319  : 			{
; 320  : 				CoInitialize (NULL);

  00025	6a 00		 push	 0
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoInitialize@4

; 321  : 				ElevatedComInstance = GetElevatedInstance (GetActiveWindow() ? GetActiveWindow() : MainDlg);

  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetActiveWindow@0
  00033	85 c0		 test	 eax, eax
  00035	74 08		 je	 SHORT $LN6@Elevate
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetActiveWindow@0
  0003d	eb 05		 jmp	 SHORT $LN7@Elevate
$LN6@Elevate:
  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR _MainDlg
$LN7@Elevate:
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?GetElevatedInstance@@YAPAUIGostCryptMainCom@@PAUHWND__@@@Z ; GetElevatedInstance
  0004a	83 c4 04	 add	 esp, 4
  0004d	a3 00 00 00 00	 mov	 DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A, eax ; GostCrypt::Elevator::ElevatedComInstance

; 322  : 				ElevatedComInstanceThreadId = GetCurrentThreadId();

  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  00058	a3 00 00 00 00	 mov	 DWORD PTR ?ElevatedComInstanceThreadId@Elevator@GostCrypt@@1KA, eax ; GostCrypt::Elevator::ElevatedComInstanceThreadId
$LN3@Elevate:

; 323  : 			}
; 324  : 		}

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
$LN14@Elevate:

; 313  : 			{
; 314  : 				SetLastError (ERROR_ACCESS_DENIED);

  00061	6a 05		 push	 5
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 315  : 				throw SystemException();

  00069	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00076	89 45 fc	 mov	 DWORD PTR $T1[ebp+4], eax
  00079	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  0007c	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN16@Elevate:
$LN13@Elevate:
  00087	cc		 int	 3
?Elevate@Elevator@GostCrypt@@KAXXZ ENDP			; GostCrypt::Elevator::Elevate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?SetDriverServiceStartType@Elevator@GostCrypt@@SAXK@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_startType$ = 8						; size = 4
?SetDriverServiceStartType@Elevator@GostCrypt@@SAXK@Z PROC ; GostCrypt::Elevator::SetDriverServiceStartType, COMDAT

; 290  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 291  : 			Elevate();

  00006	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate

; 292  : 
; 293  : 			DWORD result = ElevatedComInstance->SetDriverServiceStartType (startType);

  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  00010	ff 75 08	 push	 DWORD PTR _startType$[ebp]
  00013	50		 push	 eax
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	ff 51 38	 call	 DWORD PTR [ecx+56]

; 294  : 			if (result != ERROR_SUCCESS)

  00019	85 c0		 test	 eax, eax
  0001b	75 04		 jne	 SHORT $LN10@SetDriverS

; 298  : 			}
; 299  : 		}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN10@SetDriverS:

; 295  : 			{
; 296  : 				SetLastError (result);

  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 297  : 				throw SystemException();

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00035	89 45 fc	 mov	 DWORD PTR $T1[ebp+4], eax
  00038	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  0003b	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN12@SetDriverS:
$LN9@SetDriverS:
  00046	cc		 int	 3
?SetDriverServiceStartType@Elevator@GostCrypt@@SAXK@Z ENDP ; GostCrypt::Elevator::SetDriverServiceStartType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?Release@Elevator@GostCrypt@@SAXXZ
_TEXT	SEGMENT
?Release@Elevator@GostCrypt@@SAXXZ PROC			; GostCrypt::Elevator::Release, COMDAT

; 273  : 			if (--ReferenceCount == 0 && ElevatedComInstance)

  00000	83 2d 00 00 00
	00 01		 sub	 DWORD PTR ?ReferenceCount@Elevator@GostCrypt@@1HA, 1 ; GostCrypt::Elevator::ReferenceCount
  00007	75 20		 jne	 SHORT $LN2@Release
  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  0000f	85 c9		 test	 ecx, ecx
  00011	74 16		 je	 SHORT $LN2@Release

; 274  : 			{
; 275  : 				ElevatedComInstance->Release();

  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	51		 push	 ecx
  00016	ff 50 08	 call	 DWORD PTR [eax+8]

; 276  : 				ElevatedComInstance = nullptr;

  00019	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A, 0 ; GostCrypt::Elevator::ElevatedComInstance

; 277  : 				CoUninitialize ();

  00023	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__CoUninitialize@0
$LN2@Release:

; 278  : 			}
; 279  : 		}

  00029	c3		 ret	 0
?Release@Elevator@GostCrypt@@SAXXZ ENDP			; GostCrypt::Elevator::Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?RegisterSystemFavoritesService@Elevator@GostCrypt@@SAXH@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_registerService$ = 8					; size = 4
?RegisterSystemFavoritesService@Elevator@GostCrypt@@SAXH@Z PROC ; GostCrypt::Elevator::RegisterSystemFavoritesService, COMDAT

; 253  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 254  : 			Elevate();

  00006	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate

; 255  : 
; 256  : 			DWORD result = ElevatedComInstance->RegisterSystemFavoritesService (registerService);

  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  00010	ff 75 08	 push	 DWORD PTR _registerService$[ebp]
  00013	50		 push	 eax
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	ff 51 30	 call	 DWORD PTR [ecx+48]

; 257  : 			if (result != ERROR_SUCCESS)

  00019	85 c0		 test	 eax, eax
  0001b	75 04		 jne	 SHORT $LN10@RegisterSy

; 261  : 			}
; 262  : 		}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN10@RegisterSy:

; 258  : 			{
; 259  : 				SetLastError (result);

  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 260  : 				throw SystemException();

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00035	89 45 fc	 mov	 DWORD PTR $T1[ebp+4], eax
  00038	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  0003b	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN12@RegisterSy:
$LN9@RegisterSy:
  00046	cc		 int	 3
?RegisterSystemFavoritesService@Elevator@GostCrypt@@SAXH@Z ENDP ; GostCrypt::Elevator::RegisterSystemFavoritesService
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?RegisterFilterDriver@Elevator@GostCrypt@@SAX_NW4FilterType@BootEncryption@2@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_registerDriver$ = 8					; size = 1
_filterType$ = 12					; size = 4
?RegisterFilterDriver@Elevator@GostCrypt@@SAX_NW4FilterType@BootEncryption@2@@Z PROC ; GostCrypt::Elevator::RegisterFilterDriver, COMDAT

; 233  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 234  : 			Elevate();

  00006	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate

; 235  : 
; 236  : 			DWORD result = ElevatedComInstance->RegisterFilterDriver (registerDriver ? TRUE : FALSE, filterType);

  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  00011	33 c0		 xor	 eax, eax
  00013	38 45 08	 cmp	 BYTE PTR _registerDriver$[ebp], al
  00016	ff 75 0c	 push	 DWORD PTR _filterType$[ebp]
  00019	0f 95 c0	 setne	 al
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	50		 push	 eax
  0001f	51		 push	 ecx
  00020	ff 52 2c	 call	 DWORD PTR [edx+44]

; 237  : 			if (result != ERROR_SUCCESS)

  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN10@RegisterFi

; 241  : 			}
; 242  : 		}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN10@RegisterFi:

; 238  : 			{
; 239  : 				SetLastError (result);

  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 240  : 				throw SystemException();

  00032	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0003f	89 45 fc	 mov	 DWORD PTR $T1[ebp+4], eax
  00042	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  00045	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN12@RegisterFi:
$LN9@RegisterFi:
  00050	cc		 int	 3
?RegisterFilterDriver@Elevator@GostCrypt@@SAX_NW4FilterType@BootEncryption@2@@Z ENDP ; GostCrypt::Elevator::RegisterFilterDriver
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?WriteLocalMachineRegistryDwordValue@Elevator@GostCrypt@@SAXPAD0K@Z
_TEXT	SEGMENT
$T2 = -28						; size = 8
$T3 = -20						; size = 4
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_keyPath$ = 8						; size = 4
_valueName$ = 12					; size = 4
_value$ = 16						; size = 4
?WriteLocalMachineRegistryDwordValue@Elevator@GostCrypt@@SAXPAD0K@Z PROC ; GostCrypt::Elevator::WriteLocalMachineRegistryDwordValue, COMDAT

; 211  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?WriteLocalMachineRegistryDwordValue@Elevator@GostCrypt@@SAXPAD0K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 212  : 			Elevate();

  00027	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate

; 213  : 
; 214  : 			DWORD result = ElevatedComInstance->WriteLocalMachineRegistryDwordValue (CComBSTR (keyPath), CComBSTR (valueName), value);

  0002c	ff 75 0c	 push	 DWORD PTR _valueName$[ebp]
  0002f	8d 4d ec	 lea	 ecx, DWORD PTR $T3[ebp]
  00032	e8 00 00 00 00	 call	 ??0CComBSTR@ATL@@QAE@PBD@Z ; ATL::CComBSTR::CComBSTR
  00037	8b f0		 mov	 esi, eax
  00039	ff 75 08	 push	 DWORD PTR _keyPath$[ebp]
  0003c	8d 4d f0	 lea	 ecx, DWORD PTR $T4[ebp]
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	e8 00 00 00 00	 call	 ??0CComBSTR@ATL@@QAE@PBD@Z ; ATL::CComBSTR::CComBSTR
  0004b	ff 75 10	 push	 DWORD PTR _value$[ebp]
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  00054	ff 36		 push	 DWORD PTR [esi]
  00056	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0005a	ff 30		 push	 DWORD PTR [eax]
  0005c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005e	51		 push	 ecx
  0005f	ff 52 3c	 call	 DWORD PTR [edx+60]
  00062	ff 75 f0	 push	 DWORD PTR $T4[ebp]
  00065	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SysFreeString@4
  0006b	8b f8		 mov	 edi, eax
  0006d	ff d6		 call	 esi
  0006f	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00072	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00079	ff d6		 call	 esi

; 215  : 		
; 216  : 			if (result != ERROR_SUCCESS)

  0007b	85 ff		 test	 edi, edi
  0007d	74 25		 je	 SHORT $LN2@WriteLocal

; 217  : 			{
; 218  : 				SetLastError (result);

  0007f	57		 push	 edi
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 219  : 				throw SystemException();

  00086	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00093	89 45 e8	 mov	 DWORD PTR $T2[ebp+4], eax
  00096	8d 45 e4	 lea	 eax, DWORD PTR $T2[ebp]
  00099	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN21@WriteLocal:
$LN2@WriteLocal:

; 220  : 			}
; 221  : 		}

  000a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ae	59		 pop	 ecx
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
$LN20@WriteLocal:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?WriteLocalMachineRegistryDwordValue@Elevator@GostCrypt@@SAXPAD0K@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CComBSTR@ATL@@QAE@XZ	; ATL::CComBSTR::~CComBSTR
__unwindfunclet$?WriteLocalMachineRegistryDwordValue@Elevator@GostCrypt@@SAXPAD0K@Z$1:
  00008	8d 4d f0	 lea	 ecx, DWORD PTR $T4[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1CComBSTR@ATL@@QAE@XZ	; ATL::CComBSTR::~CComBSTR
__ehhandler$?WriteLocalMachineRegistryDwordValue@Elevator@GostCrypt@@SAXPAD0K@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?WriteLocalMachineRegistryDwordValue@Elevator@GostCrypt@@SAXPAD0K@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?WriteLocalMachineRegistryDwordValue@Elevator@GostCrypt@@SAXPAD0K@Z ENDP ; GostCrypt::Elevator::WriteLocalMachineRegistryDwordValue
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?IsPagingFileActive@Elevator@GostCrypt@@SAHH@Z
_TEXT	SEGMENT
_checkNonWindowsPartitionsOnly$ = 8			; size = 4
?IsPagingFileActive@Elevator@GostCrypt@@SAHH@Z PROC	; GostCrypt::Elevator::IsPagingFileActive, COMDAT

; 194  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 195  : 			Elevate();

  00003	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate

; 196  : 
; 197  : 			return ElevatedComInstance->IsPagingFileActive (checkNonWindowsPartitionsOnly);

  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  0000d	ff 75 08	 push	 DWORD PTR _checkNonWindowsPartitionsOnly$[ebp]
  00010	50		 push	 eax
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	ff 51 24	 call	 DWORD PTR [ecx+36]

; 198  : 		}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?IsPagingFileActive@Elevator@GostCrypt@@SAHH@Z ENDP	; GostCrypt::Elevator::IsPagingFileActive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?ReadWriteFile@Elevator@GostCrypt@@SAXHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE_KIPAK@Z
_TEXT	SEGMENT
$T2 = -24						; size = 8
$T3 = -24						; size = 8
$T4 = -20						; size = 4
_bufferBstr$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_write$ = 8						; size = 4
_device$ = 12						; size = 4
_filePath$ = 16						; size = 4
_buffer$ = 20						; size = 4
_offset$ = 24						; size = 8
_size$ = 32						; size = 4
_sizeDone$ = 36						; size = 4
?ReadWriteFile@Elevator@GostCrypt@@SAXHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE_KIPAK@Z PROC ; GostCrypt::Elevator::ReadWriteFile, COMDAT

; 167  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ReadWriteFile@Elevator@GostCrypt@@SAXHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE_KIPAK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 168  : 			Elevate();

  00027	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate

; 169  : 
; 170  : 			CComBSTR bufferBstr;

  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bufferBstr$[ebp], 0

; 171  : 			if (bufferBstr.AppendBytes ((const char *) buffer, size) != S_OK)

  00033	8b 7d 20	 mov	 edi, DWORD PTR _size$[ebp]
  00036	8d 4d f0	 lea	 ecx, DWORD PTR _bufferBstr$[ebp]
  00039	57		 push	 edi
  0003a	ff 75 14	 push	 DWORD PTR _buffer$[ebp]
  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	e8 00 00 00 00	 call	 ?AppendBytes@CComBSTR@ATL@@QAEJPBDH@Z ; ATL::CComBSTR::AppendBytes
  00049	85 c0		 test	 eax, eax
  0004b	74 1c		 je	 SHORT $LN2@ReadWriteF

; 172  : 				throw ParameterIncorrect (SRC_POS);

  0004d	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00052	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00055	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0005c	50		 push	 eax
  0005d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], OFFSET ??_C@_0CH@HCJBBEHF@GostCrypt?3?3Elevator?3?3ReadWriteFi@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN47@ReadWriteF:
$LN2@ReadWriteF:

; 173  : 			DWORD result = ElevatedComInstance->ReadWriteFile (write, device, CComBSTR (filePath.c_str()), &bufferBstr, offset, size, sizeDone);

  00069	8b 45 10	 mov	 eax, DWORD PTR _filePath$[ebp]
  0006c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00070	72 02		 jb	 SHORT $LN31@ReadWriteF
  00072	8b 00		 mov	 eax, DWORD PTR [eax]
$LN31@ReadWriteF:
  00074	50		 push	 eax
  00075	8d 4d ec	 lea	 ecx, DWORD PTR $T4[ebp]
  00078	e8 00 00 00 00	 call	 ??0CComBSTR@ATL@@QAE@PBD@Z ; ATL::CComBSTR::CComBSTR
  0007d	ff 75 24	 push	 DWORD PTR _sizeDone$[ebp]
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  00086	8d 75 f0	 lea	 esi, DWORD PTR _bufferBstr$[ebp]
  00089	57		 push	 edi
  0008a	ff 75 1c	 push	 DWORD PTR _offset$[ebp+4]
  0008d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00091	ff 75 18	 push	 DWORD PTR _offset$[ebp]
  00094	8b 11		 mov	 edx, DWORD PTR [ecx]
  00096	56		 push	 esi
  00097	ff 30		 push	 DWORD PTR [eax]
  00099	ff 75 0c	 push	 DWORD PTR _device$[ebp]
  0009c	ff 75 08	 push	 DWORD PTR _write$[ebp]
  0009f	51		 push	 ecx
  000a0	ff 52 28	 call	 DWORD PTR [edx+40]
  000a3	ff 75 ec	 push	 DWORD PTR $T4[ebp]
  000a6	8b f0		 mov	 esi, eax
  000a8	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4

; 174  : 
; 175  : 			if (result != ERROR_SUCCESS)

  000b2	85 f6		 test	 esi, esi
  000b4	74 25		 je	 SHORT $LN3@ReadWriteF

; 176  : 			{
; 177  : 				SetLastError (result);

  000b6	56		 push	 esi
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 178  : 				throw SystemException();

  000bd	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000ca	89 45 ec	 mov	 DWORD PTR $T2[ebp+4], eax
  000cd	8d 45 e8	 lea	 eax, DWORD PTR $T2[ebp]
  000d0	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN48@ReadWriteF:
$LN3@ReadWriteF:

; 179  : 			}
; 180  : 
; 181  : 			if (!write)

  000db	83 7d 08 00	 cmp	 DWORD PTR _write$[ebp], 0
  000df	8b 75 f0	 mov	 esi, DWORD PTR _bufferBstr$[ebp]
  000e2	75 0d		 jne	 SHORT $LN4@ReadWriteF

; 182  : 				memcpy (buffer, (BYTE *) bufferBstr.m_str, size);

  000e4	57		 push	 edi
  000e5	56		 push	 esi
  000e6	ff 75 14	 push	 DWORD PTR _buffer$[ebp]
  000e9	e8 00 00 00 00	 call	 _memcpy
  000ee	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@ReadWriteF:

; 183  : 		}

  000f1	56		 push	 esi
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
  000f8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000fb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00102	59		 pop	 ecx
  00103	5f		 pop	 edi
  00104	5e		 pop	 esi
  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c3		 ret	 0
$LN46@ReadWriteF:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReadWriteFile@Elevator@GostCrypt@@SAXHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE_KIPAK@Z$0:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _bufferBstr$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CComBSTR@ATL@@QAE@XZ	; ATL::CComBSTR::~CComBSTR
__unwindfunclet$?ReadWriteFile@Elevator@GostCrypt@@SAXHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE_KIPAK@Z$1:
  00008	8d 4d ec	 lea	 ecx, DWORD PTR $T4[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1CComBSTR@ATL@@QAE@XZ	; ATL::CComBSTR::~CComBSTR
__ehhandler$?ReadWriteFile@Elevator@GostCrypt@@SAXHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE_KIPAK@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ReadWriteFile@Elevator@GostCrypt@@SAXHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE_KIPAK@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ReadWriteFile@Elevator@GostCrypt@@SAXHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE_KIPAK@Z ENDP ; GostCrypt::Elevator::ReadWriteFile
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?DeleteFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T2 = -20						; size = 8
__$EHRec$ = -12						; size = 12
$T3 = 8							; size = 4
_file$ = 8						; size = 4
?DeleteFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; GostCrypt::Elevator::DeleteFileA, COMDAT

; 140  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DeleteFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 141  : 			Elevate();

  00026	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate

; 142  : 
; 143  : 			DWORD result = ElevatedComInstance->DeleteFile (CComBSTR (file.c_str()));

  0002b	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0002e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00032	72 02		 jb	 SHORT $LN19@DeleteFile
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
$LN19@DeleteFile:
  00036	50		 push	 eax
  00037	8d 4d 08	 lea	 ecx, DWORD PTR $T3[ebp]
  0003a	e8 00 00 00 00	 call	 ??0CComBSTR@ATL@@QAE@PBD@Z ; ATL::CComBSTR::CComBSTR
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  00045	ff 30		 push	 DWORD PTR [eax]
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004e	51		 push	 ecx
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	ff 52 20	 call	 DWORD PTR [edx+32]
  00054	ff 75 08	 push	 DWORD PTR $T3[ebp]
  00057	8b f0		 mov	 esi, eax
  00059	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4

; 144  : 
; 145  : 			if (result != ERROR_SUCCESS)

  00066	85 f6		 test	 esi, esi
  00068	74 25		 je	 SHORT $LN2@DeleteFile

; 146  : 			{
; 147  : 				SetLastError (result);

  0006a	56		 push	 esi
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 148  : 				throw SystemException();

  00071	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0007e	89 45 f0	 mov	 DWORD PTR $T2[ebp+4], eax
  00081	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00084	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@DeleteFile:
$LN2@DeleteFile:

; 149  : 			}
; 150  : 		}

  0008f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00092	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00099	59		 pop	 ecx
  0009a	5e		 pop	 esi
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
$LN32@DeleteFile:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DeleteFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CComBSTR@ATL@@QAE@XZ	; ATL::CComBSTR::~CComBSTR
__ehhandler$?DeleteFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DeleteFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DeleteFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; GostCrypt::Elevator::DeleteFileA
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?CopyFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
_TEXT	SEGMENT
$T2 = -24						; size = 8
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_sourceFile$ = 8					; size = 4
$T4 = 12						; size = 4
_destinationFile$ = 12					; size = 4
?CopyFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z PROC ; GostCrypt::Elevator::CopyFileA, COMDAT

; 119  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CopyFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 120  : 			Elevate();

  00027	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate

; 121  : 
; 122  : 			DWORD result = ElevatedComInstance->CopyFile (CComBSTR (sourceFile.c_str()), CComBSTR (destinationFile.c_str()));

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _destinationFile$[ebp]
  0002f	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00033	72 02		 jb	 SHORT $LN20@CopyFileA
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
$LN20@CopyFileA:
  00037	50		 push	 eax
  00038	8d 4d f0	 lea	 ecx, DWORD PTR $T3[ebp]
  0003b	e8 00 00 00 00	 call	 ??0CComBSTR@ATL@@QAE@PBD@Z ; ATL::CComBSTR::CComBSTR
  00040	8b f0		 mov	 esi, eax
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _sourceFile$[ebp]
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00050	72 02		 jb	 SHORT $LN39@CopyFileA
  00052	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN39@CopyFileA:
  00054	51		 push	 ecx
  00055	8d 4d 0c	 lea	 ecx, DWORD PTR $T4[ebp]
  00058	e8 00 00 00 00	 call	 ??0CComBSTR@ATL@@QAE@PBD@Z ; ATL::CComBSTR::CComBSTR
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  00063	ff 36		 push	 DWORD PTR [esi]
  00065	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00069	ff 30		 push	 DWORD PTR [eax]
  0006b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006d	51		 push	 ecx
  0006e	ff 52 1c	 call	 DWORD PTR [edx+28]
  00071	ff 75 0c	 push	 DWORD PTR $T4[ebp]
  00074	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SysFreeString@4
  0007a	8b f8		 mov	 edi, eax
  0007c	ff d6		 call	 esi
  0007e	ff 75 f0	 push	 DWORD PTR $T3[ebp]
  00081	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00088	ff d6		 call	 esi

; 123  : 
; 124  : 			if (result != ERROR_SUCCESS)

  0008a	85 ff		 test	 edi, edi
  0008c	74 25		 je	 SHORT $LN2@CopyFileA

; 125  : 			{
; 126  : 				SetLastError (result);

  0008e	57		 push	 edi
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 127  : 				throw SystemException();

  00095	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000a2	89 45 ec	 mov	 DWORD PTR $T2[ebp+4], eax
  000a5	8d 45 e8	 lea	 eax, DWORD PTR $T2[ebp]
  000a8	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN55@CopyFileA:
$LN2@CopyFileA:

; 128  : 			}
; 129  : 		}

  000b3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bd	59		 pop	 ecx
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
$LN54@CopyFileA:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CopyFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z$0:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CComBSTR@ATL@@QAE@XZ	; ATL::CComBSTR::~CComBSTR
__unwindfunclet$?CopyFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z$1:
  00008	8d 4d 0c	 lea	 ecx, DWORD PTR $T4[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1CComBSTR@ATL@@QAE@XZ	; ATL::CComBSTR::~CComBSTR
__ehhandler$?CopyFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CopyFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CopyFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ENDP ; GostCrypt::Elevator::CopyFileA
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?CallDriver@Elevator@GostCrypt@@SAXKPAXK0K@Z
_TEXT	SEGMENT
$T2 = -28						; size = 8
$T3 = -28						; size = 8
$T4 = -28						; size = 8
_inputBstr$ = -20					; size = 4
_outputBstr$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_ioctl$ = 8						; size = 4
_result$1$ = 12						; size = 4
_input$ = 12						; size = 4
_inputSize$ = 16					; size = 4
_output$ = 20						; size = 4
_outputSize$ = 24					; size = 4
?CallDriver@Elevator@GostCrypt@@SAXKPAXK0K@Z PROC	; GostCrypt::Elevator::CallDriver, COMDAT

; 86   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CallDriver@Elevator@GostCrypt@@SAXKPAXK0K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 87   : 			Elevate();

  00028	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate

; 88   : 
; 89   : 			CComBSTR inputBstr;

  0002d	33 f6		 xor	 esi, esi
  0002f	89 75 ec	 mov	 DWORD PTR _inputBstr$[ebp], esi

; 90   : 			if (input && inputBstr.AppendBytes ((const char *) input, inputSize) != S_OK)

  00032	8b 45 0c	 mov	 eax, DWORD PTR _input$[ebp]
  00035	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  00038	85 c0		 test	 eax, eax
  0003a	74 2f		 je	 SHORT $LN2@CallDriver
  0003c	ff 75 10	 push	 DWORD PTR _inputSize$[ebp]
  0003f	8d 4d ec	 lea	 ecx, DWORD PTR _inputBstr$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?AppendBytes@CComBSTR@ATL@@QAEJPBDH@Z ; ATL::CComBSTR::AppendBytes
  00048	85 c0		 test	 eax, eax
  0004a	74 1c		 je	 SHORT $LN38@CallDriver

; 91   : 				throw ParameterIncorrect (SRC_POS);

  0004c	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00051	8d 45 e4	 lea	 eax, DWORD PTR $T4[ebp]
  00054	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0005b	50		 push	 eax
  0005c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+4], OFFSET ??_C@_0CD@HBGHDAEL@GostCrypt?3?3Elevator?3?3CallDriver?3@
  00063	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN41@CallDriver:
$LN38@CallDriver:
  00068	8b 75 ec	 mov	 esi, DWORD PTR _inputBstr$[ebp]
$LN2@CallDriver:

; 92   : 
; 93   : 			CComBSTR outputBstr;

  0006b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _outputBstr$[ebp], 0

; 94   : 			if (output && outputBstr.AppendBytes ((const char *) output, outputSize) != S_OK)

  00072	8b 5d 14	 mov	 ebx, DWORD PTR _output$[ebp]
  00075	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00079	85 db		 test	 ebx, ebx
  0007b	74 2c		 je	 SHORT $LN3@CallDriver
  0007d	ff 75 18	 push	 DWORD PTR _outputSize$[ebp]
  00080	8d 4d f0	 lea	 ecx, DWORD PTR _outputBstr$[ebp]
  00083	53		 push	 ebx
  00084	e8 00 00 00 00	 call	 ?AppendBytes@CComBSTR@ATL@@QAEJPBDH@Z ; ATL::CComBSTR::AppendBytes
  00089	85 c0		 test	 eax, eax
  0008b	74 1c		 je	 SHORT $LN3@CallDriver

; 95   : 				throw ParameterIncorrect (SRC_POS);

  0008d	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00092	8d 45 e4	 lea	 eax, DWORD PTR $T3[ebp]
  00095	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0009c	50		 push	 eax
  0009d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], OFFSET ??_C@_0CD@BFALPFEP@GostCrypt?3?3Elevator?3?3CallDriver?3@
  000a4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN42@CallDriver:
$LN3@CallDriver:

; 96   : 
; 97   : 			DWORD result = ElevatedComInstance->CallDriver (ioctl, inputBstr, &outputBstr);

  000a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  000ae	8d 55 f0	 lea	 edx, DWORD PTR _outputBstr$[ebp]
  000b1	52		 push	 edx
  000b2	56		 push	 esi
  000b3	ff 75 08	 push	 DWORD PTR _ioctl$[ebp]
  000b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b8	50		 push	 eax
  000b9	ff 51 14	 call	 DWORD PTR [ecx+20]

; 98   : 
; 99   : 			if (output)

  000bc	8b 7d f0	 mov	 edi, DWORD PTR _outputBstr$[ebp]
  000bf	89 45 0c	 mov	 DWORD PTR _result$1$[ebp], eax
  000c2	85 db		 test	 ebx, ebx
  000c4	74 10		 je	 SHORT $LN4@CallDriver

; 100  : 				memcpy (output, *(void **) &outputBstr, outputSize);

  000c6	ff 75 18	 push	 DWORD PTR _outputSize$[ebp]
  000c9	57		 push	 edi
  000ca	53		 push	 ebx
  000cb	e8 00 00 00 00	 call	 _memcpy
  000d0	8b 45 0c	 mov	 eax, DWORD PTR _result$1$[ebp]
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@CallDriver:

; 101  : 
; 102  : 			if (result != ERROR_SUCCESS)

  000d6	85 c0		 test	 eax, eax
  000d8	74 25		 je	 SHORT $LN5@CallDriver

; 103  : 			{
; 104  : 				SetLastError (result);

  000da	50		 push	 eax
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 105  : 				throw SystemException();

  000e1	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000ee	89 45 e8	 mov	 DWORD PTR $T2[ebp+4], eax
  000f1	8d 45 e4	 lea	 eax, DWORD PTR $T2[ebp]
  000f4	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@CallDriver:
$LN5@CallDriver:

; 106  : 			}
; 107  : 		}

  000ff	57		 push	 edi
  00100	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SysFreeString@4
  00106	ff d7		 call	 edi
  00108	56		 push	 esi
  00109	ff d7		 call	 edi
  0010b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0010e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00115	59		 pop	 ecx
  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	5b		 pop	 ebx
  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c3		 ret	 0
$LN40@CallDriver:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CallDriver@Elevator@GostCrypt@@SAXKPAXK0K@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR _inputBstr$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CComBSTR@ATL@@QAE@XZ	; ATL::CComBSTR::~CComBSTR
__unwindfunclet$?CallDriver@Elevator@GostCrypt@@SAXKPAXK0K@Z$1:
  00008	8d 4d f0	 lea	 ecx, DWORD PTR _outputBstr$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1CComBSTR@ATL@@QAE@XZ	; ATL::CComBSTR::~CComBSTR
__ehhandler$?CallDriver@Elevator@GostCrypt@@SAXKPAXK0K@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CallDriver@Elevator@GostCrypt@@SAXKPAXK0K@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CallDriver@Elevator@GostCrypt@@SAXKPAXK0K@Z ENDP	; GostCrypt::Elevator::CallDriver
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?AddReference@Elevator@GostCrypt@@SAXXZ
_TEXT	SEGMENT
?AddReference@Elevator@GostCrypt@@SAXXZ PROC		; GostCrypt::Elevator::AddReference, COMDAT

; 69   : 			++ReferenceCount;

  00000	ff 05 00 00 00
	00		 inc	 DWORD PTR ?ReferenceCount@Elevator@GostCrypt@@1HA ; GostCrypt::Elevator::ReferenceCount

; 70   : 		}

  00006	c3		 ret	 0
?AddReference@Elevator@GostCrypt@@SAXXZ ENDP		; GostCrypt::Elevator::AddReference
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?InstallVolumeHeader@BootEncryption@GostCrypt@@IAEXXZ
_TEXT	SEGMENT
$T2 = -400						; size = 8
$T3 = -392						; size = 8
$T4 = -384						; size = 320
_device$ = -64						; size = 48
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?InstallVolumeHeader@BootEncryption@GostCrypt@@IAEXXZ PROC ; GostCrypt::BootEncryption::InstallVolumeHeader, COMDAT
; _this$ = ecx

; 2111 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?InstallVolumeHeader@BootEncryption@GostCrypt@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 84 01 00
	00		 sub	 esp, 388		; 00000184H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	8b f1		 mov	 esi, ecx

; 2112 : 		if (!VolumeHeaderValid)

  0002e	80 be c7 05 00
	00 00		 cmp	 BYTE PTR [esi+1479], 0
  00035	75 25		 jne	 SHORT $LN2@InstallVol

; 2113 : 			throw ParameterIncorrect (SRC_POS);

  00037	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  0003c	8d 85 78 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00042	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0004c	50		 push	 eax
  0004d	c7 85 7c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp+4], OFFSET ??_C@_0DE@FGBLJEP@GostCrypt?3?3BootEncryption?3?3Insta@
  00057	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN152@InstallVol:
$LN2@InstallVol:

; 2114 : 
; 2115 : 		Device device (GetSystemDriveConfiguration().DevicePath);

  0005c	6a 00		 push	 0
  0005e	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  0006a	83 ec 18	 sub	 esp, 24			; 00000018H
  0006d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00074	8b cc		 mov	 ecx, esp
  00076	8d 50 18	 lea	 edx, DWORD PTR [eax+24]
  00079	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00080	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00087	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0008b	72 04		 jb	 SHORT $LN127@InstallVol
  0008d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008f	eb 02		 jmp	 SHORT $LN128@InstallVol
$LN127@InstallVol:
  00091	8b c1		 mov	 eax, ecx
$LN128@InstallVol:
  00093	52		 push	 edx
  00094	c6 00 00	 mov	 BYTE PTR [eax], 0
  00097	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0009c	8d 4d c0	 lea	 ecx, DWORD PTR _device$[ebp]
  0009f	e8 00 00 00 00	 call	 ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device
  000a4	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  000aa	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000ae	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 2116 : 
; 2117 : 		device.SeekAt (GST_BOOT_VOLUME_HEADER_SECTOR_OFFSET);

  000b3	80 7d c0 00	 cmp	 BYTE PTR _device$[ebp], 0
  000b7	c7 45 c8 00 7c
	00 00		 mov	 DWORD PTR _device$[ebp+8], 31744 ; 00007c00H
  000be	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _device$[ebp+12], 0
  000c5	75 3f		 jne	 SHORT $LN139@InstallVol
  000c7	6a 00		 push	 0
  000c9	6a 00		 push	 0
  000cb	6a 00		 push	 0
  000cd	68 00 7c 00 00	 push	 31744			; 00007c00H
  000d2	ff 75 d0	 push	 DWORD PTR _device$[ebp+16]
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  000db	85 c0		 test	 eax, eax
  000dd	75 27		 jne	 SHORT $LN139@InstallVol
  000df	c7 85 70 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000ef	89 85 74 fe ff
	ff		 mov	 DWORD PTR $T2[ebp+4], eax
  000f5	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000fb	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN153@InstallVol:
$LN139@InstallVol:

; 2118 : 		device.Write ((byte *) VolumeHeader, sizeof (VolumeHeader));

  00106	68 00 02 00 00	 push	 512			; 00000200H
  0010b	8d 86 c4 03 00
	00		 lea	 eax, DWORD PTR [esi+964]
  00111	50		 push	 eax
  00112	8d 4d c0	 lea	 ecx, DWORD PTR _device$[ebp]
  00115	e8 00 00 00 00	 call	 ?Write@File@GostCrypt@@QAEXPAEK@Z ; GostCrypt::File::Write

; 2119 : 	}

  0011a	8d 4d c0	 lea	 ecx, DWORD PTR _device$[ebp]
  0011d	e8 00 00 00 00	 call	 ??1Device@GostCrypt@@QAE@XZ
  00122	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00125	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012c	59		 pop	 ecx
  0012d	5e		 pop	 esi
  0012e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00131	33 cd		 xor	 ecx, ebp
  00133	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00138	8b e5		 mov	 esp, ebp
  0013a	5d		 pop	 ebp
  0013b	c3		 ret	 0
$LN151@InstallVol:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InstallVolumeHeader@BootEncryption@GostCrypt@@IAEXXZ$0:
  00000	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?InstallVolumeHeader@BootEncryption@GostCrypt@@IAEXXZ$2:
  0000b	8d 4d c0	 lea	 ecx, DWORD PTR _device$[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1Device@GostCrypt@@QAE@XZ
__ehhandler$?InstallVolumeHeader@BootEncryption@GostCrypt@@IAEXXZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 8a 74 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-396]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?InstallVolumeHeader@BootEncryption@GostCrypt@@IAEXXZ
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?InstallVolumeHeader@BootEncryption@GostCrypt@@IAEXXZ ENDP ; GostCrypt::BootEncryption::InstallVolumeHeader
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ
_TEXT	SEGMENT
$T2 = -33216						; size = 8
_pos$3 = -33208						; size = 8
_pos$4 = -33208						; size = 8
$T5 = -33208						; size = 8
$T6 = -33208						; size = 8
$T7 = -33200						; size = 320
_backupFile$ = -32880					; size = 48
_device$ = -32832					; size = 48
_bootLoaderBuf$ = -32784				; size = 32256
_mbr$ = -528						; size = 512
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ PROC ; GostCrypt::BootEncryption::RestoreSystemLoader, COMDAT
; _this$ = ecx

; 2196 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 b4 81 00 00	 mov	 eax, 33204		; 000081b4H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	56		 push	 esi
  00026	50		 push	 eax
  00027	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	8b f1		 mov	 esi, ecx

; 2197 : 		byte bootLoaderBuf[GST_BOOT_LOADER_AREA_SECTOR_COUNT * GST_SECTOR_SIZE_BIOS];
; 2198 : 
; 2199 : 		File backupFile (GetSystemLoaderBackupPath(), true);

  00032	6a 00		 push	 0
  00034	6a 01		 push	 1
  00036	83 ec 18	 sub	 esp, 24			; 00000018H
  00039	54		 push	 esp
  0003a	e8 00 00 00 00	 call	 ?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GostCrypt::BootEncryption::GetSystemLoaderBackupPath
  0003f	8d 8d 90 7f ff
	ff		 lea	 ecx, DWORD PTR _backupFile$[ebp]
  00045	e8 00 00 00 00	 call	 ??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z ; GostCrypt::File::File

; 2200 : 		
; 2201 : 		if (backupFile.Read (bootLoaderBuf, sizeof (bootLoaderBuf)) != sizeof (bootLoaderBuf))

  0004a	68 00 7e 00 00	 push	 32256			; 00007e00H
  0004f	8d 85 f0 7f ff
	ff		 lea	 eax, DWORD PTR _bootLoaderBuf$[ebp]
  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005c	50		 push	 eax
  0005d	8d 8d 90 7f ff
	ff		 lea	 ecx, DWORD PTR _backupFile$[ebp]
  00063	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read
  00068	3d 00 7e 00 00	 cmp	 eax, 32256		; 00007e00H
  0006d	74 25		 je	 SHORT $LN2@RestoreSys

; 2202 : 			throw ParameterIncorrect (SRC_POS);

  0006f	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00074	8d 85 48 7e ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0007a	c7 85 48 7e ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00084	50		 push	 eax
  00085	c7 85 4c 7e ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+4], OFFSET ??_C@_0DE@DNAHMIJK@GostCrypt?3?3BootEncryption?3?3Resto@
  0008f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN166@RestoreSys:
$LN2@RestoreSys:

; 2203 : 
; 2204 : 		Device device (GetSystemDriveConfiguration().DevicePath);

  00094	6a 00		 push	 0
  00096	8d 85 50 7e ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  0009c	8b ce		 mov	 ecx, esi
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  000a4	83 ec 18	 sub	 esp, 24			; 00000018H
  000a7	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000ab	8b cc		 mov	 ecx, esp
  000ad	8d 50 18	 lea	 edx, DWORD PTR [eax+24]
  000b0	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  000b7	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  000be	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  000c2	72 04		 jb	 SHORT $LN129@RestoreSys
  000c4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c6	eb 02		 jmp	 SHORT $LN130@RestoreSys
$LN129@RestoreSys:
  000c8	8b c1		 mov	 eax, ecx
$LN130@RestoreSys:
  000ca	52		 push	 edx
  000cb	c6 00 00	 mov	 BYTE PTR [eax], 0
  000ce	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  000d3	8d 8d c0 7f ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  000d9	e8 00 00 00 00	 call	 ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device
  000de	8d 8d 50 7e ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  000e4	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000e8	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 2205 : 
; 2206 : 		// Preserve current partition table
; 2207 : 		byte mbr[GST_SECTOR_SIZE_BIOS];
; 2208 : 		device.SeekAt (0);

  000ed	80 bd c0 7f ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  000f4	0f 57 c0	 xorps	 xmm0, xmm0
  000f7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetFilePointerEx@20
  000fd	66 0f 13 85 c8
	7f ff ff	 movlpd	 QWORD PTR _device$[ebp+8], xmm0
  00105	75 4b		 jne	 SHORT $LN141@RestoreSys
  00107	6a 00		 push	 0
  00109	6a 00		 push	 0
  0010b	66 0f 13 85 48
	7e ff ff	 movlpd	 QWORD PTR _pos$4[ebp], xmm0
  00113	ff b5 4c 7e ff
	ff		 push	 DWORD PTR _pos$4[ebp+4]
  00119	ff b5 48 7e ff
	ff		 push	 DWORD PTR _pos$4[ebp]
  0011f	ff b5 d0 7f ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  00125	ff d6		 call	 esi
  00127	85 c0		 test	 eax, eax
  00129	75 27		 jne	 SHORT $LN141@RestoreSys
  0012b	c7 85 48 7e ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0013b	89 85 4c 7e ff
	ff		 mov	 DWORD PTR $T5[ebp+4], eax
  00141	8d 85 48 7e ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00147	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN167@RestoreSys:
$LN141@RestoreSys:

; 2209 : 		device.Read (mbr, sizeof (mbr));

  00152	68 00 02 00 00	 push	 512			; 00000200H
  00157	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _mbr$[ebp]
  0015d	50		 push	 eax
  0015e	8d 8d c0 7f ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00164	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read

; 2210 : 		memcpy (bootLoaderBuf + GST_MAX_MBR_BOOT_CODE_SIZE, mbr + GST_MAX_MBR_BOOT_CODE_SIZE, sizeof (mbr) - GST_MAX_MBR_BOOT_CODE_SIZE);
; 2211 : 
; 2212 : 		device.SeekAt (0);

  00169	80 bd c0 7f ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  00170	0f 10 45 a8	 movups	 xmm0, XMMWORD PTR _mbr$[ebp+440]
  00174	0f 11 85 a8 81
	ff ff		 movups	 XMMWORD PTR _bootLoaderBuf$[ebp+440], xmm0
  0017b	0f 10 45 b8	 movups	 xmm0, XMMWORD PTR _mbr$[ebp+456]
  0017f	0f 11 85 b8 81
	ff ff		 movups	 XMMWORD PTR _bootLoaderBuf$[ebp+456], xmm0
  00186	0f 10 45 c8	 movups	 xmm0, XMMWORD PTR _mbr$[ebp+472]
  0018a	0f 11 85 c8 81
	ff ff		 movups	 XMMWORD PTR _bootLoaderBuf$[ebp+472], xmm0
  00191	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR _mbr$[ebp+488]
  00195	0f 11 85 d8 81
	ff ff		 movups	 XMMWORD PTR _bootLoaderBuf$[ebp+488], xmm0
  0019c	f3 0f 7e 45 e8	 movq	 xmm0, QWORD PTR _mbr$[ebp+504]
  001a1	66 0f d6 85 e8
	81 ff ff	 movq	 QWORD PTR _bootLoaderBuf$[ebp+504], xmm0
  001a9	0f 57 c0	 xorps	 xmm0, xmm0
  001ac	66 0f 13 85 c8
	7f ff ff	 movlpd	 QWORD PTR _device$[ebp+8], xmm0
  001b4	75 4b		 jne	 SHORT $LN154@RestoreSys
  001b6	6a 00		 push	 0
  001b8	6a 00		 push	 0
  001ba	66 0f 13 85 48
	7e ff ff	 movlpd	 QWORD PTR _pos$3[ebp], xmm0
  001c2	ff b5 4c 7e ff
	ff		 push	 DWORD PTR _pos$3[ebp+4]
  001c8	ff b5 48 7e ff
	ff		 push	 DWORD PTR _pos$3[ebp]
  001ce	ff b5 d0 7f ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  001d4	ff d6		 call	 esi
  001d6	85 c0		 test	 eax, eax
  001d8	75 27		 jne	 SHORT $LN154@RestoreSys
  001da	c7 85 40 7e ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  001e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001ea	89 85 44 7e ff
	ff		 mov	 DWORD PTR $T2[ebp+4], eax
  001f0	8d 85 40 7e ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001f6	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  001fb	50		 push	 eax
  001fc	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN168@RestoreSys:
$LN154@RestoreSys:

; 2213 : 		device.Write (bootLoaderBuf, sizeof (bootLoaderBuf));

  00201	68 00 7e 00 00	 push	 32256			; 00007e00H
  00206	8d 85 f0 7f ff
	ff		 lea	 eax, DWORD PTR _bootLoaderBuf$[ebp]
  0020c	50		 push	 eax
  0020d	8d 8d c0 7f ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00213	e8 00 00 00 00	 call	 ?Write@File@GostCrypt@@QAEXPAEK@Z ; GostCrypt::File::Write

; 2214 : 	}

  00218	8d 8d c0 7f ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  0021e	e8 00 00 00 00	 call	 ??1Device@GostCrypt@@QAE@XZ
  00223	8d 8d 90 7f ff
	ff		 lea	 ecx, DWORD PTR _backupFile$[ebp]
  00229	e8 00 00 00 00	 call	 ??1File@GostCrypt@@QAE@XZ ; GostCrypt::File::~File
  0022e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00231	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00238	59		 pop	 ecx
  00239	5e		 pop	 esi
  0023a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0023d	33 cd		 xor	 ecx, ebp
  0023f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00244	8b e5		 mov	 esp, ebp
  00246	5d		 pop	 ebp
  00247	c3		 ret	 0
$LN165@RestoreSys:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ$1:
  00000	8d 8d 90 7f ff
	ff		 lea	 ecx, DWORD PTR _backupFile$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1File@GostCrypt@@QAE@XZ ; GostCrypt::File::~File
__unwindfunclet$?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ$2:
  0000b	8d 8d 50 7e ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ$4:
  00016	8d 8d c0 7f ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1Device@GostCrypt@@QAE@XZ
__ehhandler$?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 8a 44 7e ff
	ff		 mov	 ecx, DWORD PTR [edx-33212]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ
  00044	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ ENDP ; GostCrypt::BootEncryption::RestoreSystemLoader
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z
_TEXT	SEGMENT
$T2 = -65964						; size = 8
$T3 = -65964						; size = 8
_finally2260$ = -65960					; size = 4
$T4 = -65956						; size = 8
$T5 = -65956						; size = 8
$T6 = -65956						; size = 8
$T7 = -65956						; size = 8
_regKey$ = -65948					; size = 4
_deviceClassGuid$GSCopy$1$ = -65944			; size = 4
_finally2296$8 = -65944					; size = 4
_size$9 = -65944					; size = 4
_registerFilter$GSCopy$1$ = -65937			; size = 1
_finally2284$10 = -65936				; size = 24
$T11 = -65912						; size = 24
$T12 = -65888						; size = 24
$T13 = -65864						; size = 24
$T14 = -65840						; size = 24
$T15 = -65816						; size = 24
$T16 = -65792						; size = 24
$T17 = -65768						; size = 24
$T18 = -65744						; size = 24
_infFile$19 = -65720					; size = 48
$T20 = -65672						; size = 24
$T21 = -65672						; size = 24
_infTxt$22 = -65648					; size = 24
_infFileName$23 = -65624				; size = 24
_filter$ = -65600					; size = 24
_filterReg$ = -65576					; size = 24
_regKeyBuf$24 = -65552					; size = 65536
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_registerFilter$ = 8					; size = 1
_filterType$ = 12					; size = 4
_deviceClassGuid$ = 16					; size = 4
?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z PROC ; GostCrypt::BootEncryption::RegisterFilter, COMDAT
; _this$ = ecx

; 2229 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 a0 01 01 00	 mov	 eax, 65952		; 000101a0H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b d9		 mov	 ebx, ecx
  00034	8a 45 08	 mov	 al, BYTE PTR _registerFilter$[ebp]
  00037	88 85 6f fe fe
	ff		 mov	 BYTE PTR _registerFilter$GSCopy$1$[ebp], al
  0003d	8b 45 10	 mov	 eax, DWORD PTR _deviceClassGuid$[ebp]
  00040	89 85 68 fe fe
	ff		 mov	 DWORD PTR _deviceClassGuid$GSCopy$1$[ebp], eax

; 2230 : 		string filter;

  00046	c7 85 d4 ff fe
	ff 0f 00 00 00	 mov	 DWORD PTR _filter$[ebp+20], 15 ; 0000000fH
  00050	c7 85 d0 ff fe
	ff 00 00 00 00	 mov	 DWORD PTR _filter$[ebp+16], 0
  0005a	c6 85 c0 ff fe
	ff 00		 mov	 BYTE PTR _filter$[ebp], 0
  00061	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2231 : 		string filterReg;

  00068	c7 85 ec ff fe
	ff 0f 00 00 00	 mov	 DWORD PTR _filterReg$[ebp+20], 15 ; 0000000fH
  00072	c7 85 e8 ff fe
	ff 00 00 00 00	 mov	 DWORD PTR _filterReg$[ebp+16], 0
  0007c	c6 85 d8 ff fe
	ff 00		 mov	 BYTE PTR _filterReg$[ebp], 0

; 2232 : 		HKEY regKey;
; 2233 : 
; 2234 : 		switch (filterType)

  00083	8b 75 0c	 mov	 esi, DWORD PTR _filterType$[ebp]
  00086	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0008a	85 f6		 test	 esi, esi
  0008c	0f 88 91 05 00
	00		 js	 $LN24@RegisterFi
  00092	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetLastError@0
  00098	83 fe 01	 cmp	 esi, 1
  0009b	0f 8e 9b 01 00
	00		 jle	 $LN272@RegisterFi
  000a1	83 fe 02	 cmp	 esi, 2
  000a4	0f 85 79 05 00
	00		 jne	 $LN24@RegisterFi

; 2242 : 
; 2243 : 			break;
; 2244 : 
; 2245 : 		case DumpFilter:
; 2246 : 			if (!IsOSAtLeast (WIN_VISTA))

  000aa	6a 0b		 push	 11			; 0000000bH
  000ac	e8 00 00 00 00	 call	 _IsOSAtLeast
  000b1	83 c4 04	 add	 esp, 4
  000b4	85 c0		 test	 eax, eax
  000b6	0f 84 33 05 00
	00		 je	 $LN682@RegisterFi

; 2247 : 				return;
; 2248 : 
; 2249 : 			filter = "gostcrypt.sys";

  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0O@IAPAHIFF@gostcrypt?4sys?$AA@
  000c1	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _filter$[ebp]
  000c7	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 2250 : 			filterReg = "DumpFilters";

  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DBKHNNPD@DumpFilters?$AA@
  000d1	8d 8d d8 ff fe
	ff		 lea	 ecx, DWORD PTR _filterReg$[ebp]
  000d7	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 2251 : 			SetLastError (RegOpenKeyEx (HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Control\\CrashControl", 0, KEY_READ | KEY_WRITE, &regKey));

  000dc	8d 85 64 fe fe
	ff		 lea	 eax, DWORD PTR _regKey$[ebp]
  000e2	50		 push	 eax
  000e3	68 1f 00 02 00	 push	 131103			; 0002001fH
  000e8	6a 00		 push	 0
  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@FIPMIJLN@SYSTEM?2CurrentControlSet?2Control@
  000ef	68 02 00 00 80	 push	 -2147483646		; 80000002H
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  000fa	50		 push	 eax
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 2252 : 			throw_sys_if (GetLastError() != ERROR_SUCCESS);

  00101	ff d7		 call	 edi
  00103	85 c0		 test	 eax, eax
  00105	74 23		 je	 SHORT $LN679@RegisterFi
  00107	c7 85 54 fe fe
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00111	ff d7		 call	 edi
  00113	89 85 58 fe fe
	ff		 mov	 DWORD PTR $T2[ebp+4], eax
  00119	8d 85 54 fe fe
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0011f	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN683@RegisterFi:
$LN679@RegisterFi:

; 2241 : 			throw_sys_if (regKey == INVALID_HANDLE_VALUE);

  0012a	8b 85 64 fe fe
	ff		 mov	 eax, DWORD PTR _regKey$[ebp]
$LN4@RegisterFi:

; 2258 : 		}
; 2259 : 
; 2260 : 		finally_do_arg (HKEY, regKey, { RegCloseKey (finally_arg); });

  00130	89 85 58 fe fe
	ff		 mov	 DWORD PTR _finally2260$[ebp], eax

; 2261 : 
; 2262 : 		if (registerFilter && filterType != DumpFilter)

  00136	80 bd 6f fe fe
	ff 00		 cmp	 BYTE PTR _registerFilter$GSCopy$1$[ebp], 0
  0013d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00141	0f 84 60 01 00
	00		 je	 $LN25@RegisterFi
  00147	83 fe 02	 cmp	 esi, 2
  0014a	0f 84 57 01 00
	00		 je	 $LN25@RegisterFi

; 2263 : 		{
; 2264 : 			// Register class filter below all other filters in the stack
; 2265 : 
; 2266 : 			size_t strSize = filter.size() + 1;

  00150	8b b5 d0 ff fe
	ff		 mov	 esi, DWORD PTR _filter$[ebp+16]

; 2267 : 			byte regKeyBuf[65536];
; 2268 : 			DWORD size = sizeof (regKeyBuf) - strSize;

  00156	b8 00 00 01 00	 mov	 eax, 65536		; 00010000H
  0015b	46		 inc	 esi
  0015c	2b c6		 sub	 eax, esi

; 2269 : 
; 2270 : 			// SetupInstallFromInfSection() does not support prepending of values so we have to modify the registry directly
; 2271 : 			strncpy ((char *) regKeyBuf, filter.c_str(), sizeof (regKeyBuf));

  0015e	83 bd d4 ff fe
	ff 10		 cmp	 DWORD PTR _filter$[ebp+20], 16 ; 00000010H
  00165	89 85 68 fe fe
	ff		 mov	 DWORD PTR _size$9[ebp], eax
  0016b	8d 85 c0 ff fe
	ff		 lea	 eax, DWORD PTR _filter$[ebp]
  00171	0f 43 85 c0 ff
	fe ff		 cmovae	 eax, DWORD PTR _filter$[ebp]
  00178	68 00 00 01 00	 push	 65536			; 00010000H
  0017d	50		 push	 eax
  0017e	8d 85 f0 ff fe
	ff		 lea	 eax, DWORD PTR _regKeyBuf$24[ebp]
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 _strncpy
  0018a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2272 : 
; 2273 : 			if (RegQueryValueEx (regKey, filterReg.c_str(), NULL, NULL, regKeyBuf + strSize, &size) != ERROR_SUCCESS)

  0018d	8d 85 68 fe fe
	ff		 lea	 eax, DWORD PTR _size$9[ebp]
  00193	83 bd ec ff fe
	ff 10		 cmp	 DWORD PTR _filterReg$[ebp+20], 16 ; 00000010H
  0019a	8d 8d d8 ff fe
	ff		 lea	 ecx, DWORD PTR _filterReg$[ebp]
  001a0	0f 43 8d d8 ff
	fe ff		 cmovae	 ecx, DWORD PTR _filterReg$[ebp]
  001a7	50		 push	 eax
  001a8	8d 85 f0 ff fe
	ff		 lea	 eax, DWORD PTR _regKeyBuf$24[ebp]
  001ae	03 c6		 add	 eax, esi
  001b0	50		 push	 eax
  001b1	6a 00		 push	 0
  001b3	6a 00		 push	 0
  001b5	51		 push	 ecx
  001b6	ff b5 64 fe fe
	ff		 push	 DWORD PTR _regKey$[ebp]
  001bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  001c2	8b 8d 68 fe fe
	ff		 mov	 ecx, DWORD PTR _size$9[ebp]
  001c8	85 c0		 test	 eax, eax
  001ca	ba 01 00 00 00	 mov	 edx, 1
  001cf	0f 45 ca	 cmovne	 ecx, edx

; 2274 : 				size = 1;
; 2275 : 
; 2276 : 			SetLastError (RegSetValueEx (regKey, filterReg.c_str(), 0, REG_MULTI_SZ, regKeyBuf, strSize + size));

  001d2	83 bd ec ff fe
	ff 10		 cmp	 DWORD PTR _filterReg$[ebp+20], 16 ; 00000010H
  001d9	8d 95 d8 ff fe
	ff		 lea	 edx, DWORD PTR _filterReg$[ebp]
  001df	89 8d 68 fe fe
	ff		 mov	 DWORD PTR _size$9[ebp], ecx
  001e5	0f 43 95 d8 ff
	fe ff		 cmovae	 edx, DWORD PTR _filterReg$[ebp]
  001ec	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  001ef	50		 push	 eax
  001f0	8d 85 f0 ff fe
	ff		 lea	 eax, DWORD PTR _regKeyBuf$24[ebp]
  001f6	50		 push	 eax
  001f7	6a 07		 push	 7
  001f9	6a 00		 push	 0
  001fb	52		 push	 edx
  001fc	ff b5 64 fe fe
	ff		 push	 DWORD PTR _regKey$[ebp]
  00202	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExA@24
  00208	50		 push	 eax
  00209	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 2277 : 			throw_sys_if (GetLastError() != ERROR_SUCCESS);

  0020f	ff d7		 call	 edi
  00211	85 c0		 test	 eax, eax
  00213	0f 84 cb 03 00
	00		 je	 $LN26@RegisterFi
  00219	c7 85 5c fe fe
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00223	ff d7		 call	 edi
  00225	89 85 60 fe fe
	ff		 mov	 DWORD PTR $T6[ebp+4], eax
  0022b	8d 85 5c fe fe
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00231	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00236	50		 push	 eax
  00237	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN684@RegisterFi:

; 2235 : 		{
; 2236 : 		case DriveFilter:
; 2237 : 		case VolumeFilter:
; 2238 : 			filter = "gostcrypt";

$LN272@RegisterFi:
  0023c	6a 09		 push	 9
  0023e	68 00 00 00 00	 push	 OFFSET ??_C@_09JCILFBFB@gostcrypt?$AA@
  00243	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _filter$[ebp]
  00249	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2239 : 			filterReg = "UpperFilters";

  0024e	6a 0c		 push	 12			; 0000000cH
  00250	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KPKBADH@UpperFilters?$AA@
  00255	8d 8d d8 ff fe
	ff		 lea	 ecx, DWORD PTR _filterReg$[ebp]
  0025b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2240 : 			regKey = SetupDiOpenClassRegKey (deviceClassGuid, KEY_READ | KEY_WRITE);

  00260	68 1f 00 02 00	 push	 131103			; 0002001fH
  00265	ff b5 68 fe fe
	ff		 push	 DWORD PTR _deviceClassGuid$GSCopy$1$[ebp]
  0026b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetupDiOpenClassRegKey@8
  00271	89 85 64 fe fe
	ff		 mov	 DWORD PTR _regKey$[ebp], eax

; 2241 : 			throw_sys_if (regKey == INVALID_HANDLE_VALUE);

  00277	83 f8 ff	 cmp	 eax, -1
  0027a	0f 85 b0 fe ff
	ff		 jne	 $LN4@RegisterFi
  00280	c7 85 54 fe fe
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0028a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00290	89 85 58 fe fe
	ff		 mov	 DWORD PTR $T3[ebp+4], eax
  00296	8d 85 54 fe fe
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0029c	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  002a1	50		 push	 eax
  002a2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN685@RegisterFi:
$LN25@RegisterFi:

; 2278 : 		}
; 2279 : 		else
; 2280 : 		{
; 2281 : 			string infFileName = GetTempPath() + "\\gostcrypt_driver_setup.inf";

  002a7	8d 85 78 ff fe
	ff		 lea	 eax, DWORD PTR $T21[ebp]
  002ad	8b cb		 mov	 ecx, ebx
  002af	50		 push	 eax
  002b0	e8 00 00 00 00	 call	 ?GetTempPathA@BootEncryption@GostCrypt@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GostCrypt::BootEncryption::GetTempPathA
  002b5	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@CLKNIPKP@?2gostcrypt_driver_setup?4inf?$AA@
  002ba	50		 push	 eax
  002bb	8d 85 a8 ff fe
	ff		 lea	 eax, DWORD PTR _infFileName$23[ebp]
  002c1	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  002c5	50		 push	 eax
  002c6	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  002cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ce	8d 8d 78 ff fe
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  002d4	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  002d8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 2282 : 
; 2283 : 			File infFile (infFileName, false, true);

  002dd	6a 01		 push	 1
  002df	6a 00		 push	 0
  002e1	83 ec 18	 sub	 esp, 24			; 00000018H
  002e4	8b cc		 mov	 ecx, esp
  002e6	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  002ed	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  002f4	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  002f8	72 04		 jb	 SHORT $LN485@RegisterFi
  002fa	8b 01		 mov	 eax, DWORD PTR [ecx]
  002fc	eb 02		 jmp	 SHORT $LN486@RegisterFi
$LN485@RegisterFi:
  002fe	8b c1		 mov	 eax, ecx
$LN486@RegisterFi:
  00300	6a ff		 push	 -1
  00302	c6 00 00	 mov	 BYTE PTR [eax], 0
  00305	8d 85 a8 ff fe
	ff		 lea	 eax, DWORD PTR _infFileName$23[ebp]
  0030b	6a 00		 push	 0
  0030d	50		 push	 eax
  0030e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00313	8d 8d 48 ff fe
	ff		 lea	 ecx, DWORD PTR _infFile$19[ebp]
  00319	e8 00 00 00 00	 call	 ??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z ; GostCrypt::File::File

; 2284 : 			finally_do_arg (string, infFileName, { DeleteFile (finally_arg.c_str()); });

  0031e	83 ec 18	 sub	 esp, 24			; 00000018H
  00321	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00325	8b cc		 mov	 ecx, esp
  00327	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0032e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00335	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00339	72 04		 jb	 SHORT $LN610@RegisterFi
  0033b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0033d	eb 02		 jmp	 SHORT $LN611@RegisterFi
$LN610@RegisterFi:
  0033f	8b c1		 mov	 eax, ecx
$LN611@RegisterFi:
  00341	6a ff		 push	 -1
  00343	c6 00 00	 mov	 BYTE PTR [eax], 0
  00346	8d 85 a8 ff fe
	ff		 lea	 eax, DWORD PTR _infFileName$23[ebp]
  0034c	6a 00		 push	 0
  0034e	50		 push	 eax
  0034f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00354	8d 8d 70 fe fe
	ff		 lea	 ecx, DWORD PTR _finally2284$10[ebp]
  0035a	e8 00 00 00 00	 call	 ??0Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; `GostCrypt::BootEncryption::RegisterFilter'::`25'::Finally2284::Finally2284

; 2285 : 
; 2286 : 			string infTxt = "[gostcrypt]\r\n"
; 2287 : 							+ string (registerFilter ? "Add" : "Del") + "Reg=gostcrypt_reg\r\n\r\n"
; 2288 : 							"[gostcrypt_reg]\r\n"
; 2289 : 							"HKR,,\"" + filterReg + "\",0x0001" + string (registerFilter ? "0008" : "8002") + ",\"" + filter + "\"\r\n";

  0035f	80 bd 6f fe fe
	ff 00		 cmp	 BYTE PTR _registerFilter$GSCopy$1$[ebp], 0
  00366	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_04JBLMLCOF@8002?$AA@
  0036b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04FLCDBBKO@0008?$AA@
  00370	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00374	0f 44 c1	 cmove	 eax, ecx
  00377	8d 8d 88 fe fe
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  0037d	50		 push	 eax
  0037e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00383	8b f0		 mov	 esi, eax
  00385	80 bd 6f fe fe
	ff 00		 cmp	 BYTE PTR _registerFilter$GSCopy$1$[ebp], 0
  0038c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03ENJJMCOJ@Del?$AA@
  00391	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03LDFMNCOE@Add?$AA@
  00396	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0039a	0f 44 c8	 cmove	 ecx, eax
  0039d	51		 push	 ecx
  0039e	8d 8d a0 fe fe
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  003a4	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  003a9	50		 push	 eax
  003aa	8d 85 b8 fe fe
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  003b0	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  003b4	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MJBIBBDL@?$FLgostcrypt?$FN?$AN?6?$AA@
  003b9	50		 push	 eax
  003ba	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  003bf	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@EJNJANKE@Reg?$DNgostcrypt_reg?$AN?6?$AN?6?$FLgostcrypt_@
  003c4	50		 push	 eax
  003c5	8d 85 d0 fe fe
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  003cb	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  003cf	50		 push	 eax
  003d0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  003d5	8d 8d d8 ff fe
	ff		 lea	 ecx, DWORD PTR _filterReg$[ebp]
  003db	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  003df	51		 push	 ecx
  003e0	50		 push	 eax
  003e1	8d 85 e8 fe fe
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  003e7	50		 push	 eax
  003e8	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  003ed	68 00 00 00 00	 push	 OFFSET ??_C@_08OHAGLOJG@?$CC?00x0001?$AA@
  003f2	50		 push	 eax
  003f3	8d 85 00 ff fe
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  003f9	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  003fd	50		 push	 eax
  003fe	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00403	56		 push	 esi
  00404	50		 push	 eax
  00405	8d 85 18 ff fe
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  0040b	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  0040f	50		 push	 eax
  00410	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00415	68 00 00 00 00	 push	 OFFSET ??_C@_02JGFLNPEJ@?0?$CC?$AA@
  0041a	50		 push	 eax
  0041b	8d 85 30 ff fe
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  00421	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  00425	50		 push	 eax
  00426	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0042b	83 c4 48	 add	 esp, 72			; 00000048H
  0042e	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _filter$[ebp]
  00434	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  00438	51		 push	 ecx
  00439	50		 push	 eax
  0043a	8d 85 78 ff fe
	ff		 lea	 eax, DWORD PTR $T20[ebp]
  00440	50		 push	 eax
  00441	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00446	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  0044a	68 00 00 00 00	 push	 OFFSET ??_C@_03CGLHDMIP@?$CC?$AN?6?$AA@
  0044f	50		 push	 eax
  00450	8d 85 90 ff fe
	ff		 lea	 eax, DWORD PTR _infTxt$22[ebp]
  00456	50		 push	 eax
  00457	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0045c	83 c4 18	 add	 esp, 24			; 00000018H
  0045f	8d 8d 78 ff fe
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  00465	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0046a	8d 8d 30 ff fe
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  00470	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00475	8d 8d 18 ff fe
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  0047b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00480	8d 8d 00 ff fe
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  00486	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0048b	8d 8d e8 fe fe
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  00491	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00496	8d 8d d0 fe fe
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  0049c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  004a1	8d 8d b8 fe fe
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  004a7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  004ac	8d 8d a0 fe fe
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  004b2	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  004b7	8d 8d 88 fe fe
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  004bd	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+8], 26 ; 0000001aH
  004c1	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 2290 : 
; 2291 : 			infFile.Write ((byte *) infTxt.c_str(), infTxt.size());

  004c6	83 bd a4 ff fe
	ff 10		 cmp	 DWORD PTR _infTxt$22[ebp+20], 16 ; 00000010H
  004cd	8d 85 90 ff fe
	ff		 lea	 eax, DWORD PTR _infTxt$22[ebp]
  004d3	ff b5 a0 ff fe
	ff		 push	 DWORD PTR _infTxt$22[ebp+16]
  004d9	0f 43 85 90 ff
	fe ff		 cmovae	 eax, DWORD PTR _infTxt$22[ebp]
  004e0	8d 8d 48 ff fe
	ff		 lea	 ecx, DWORD PTR _infFile$19[ebp]
  004e6	50		 push	 eax
  004e7	e8 00 00 00 00	 call	 ?Write@File@GostCrypt@@QAEXPAEK@Z ; GostCrypt::File::Write

; 2292 : 			infFile.Close();

  004ec	80 bd 49 ff fe
	ff 00		 cmp	 BYTE PTR _infFile$19[ebp+1], 0
  004f3	74 1c		 je	 SHORT $LN647@RegisterFi
  004f5	80 bd 48 ff fe
	ff 00		 cmp	 BYTE PTR _infFile$19[ebp], 0
  004fc	75 0c		 jne	 SHORT $LN648@RegisterFi
  004fe	ff b5 58 ff fe
	ff		 push	 DWORD PTR _infFile$19[ebp+16]
  00504	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN648@RegisterFi:
  0050a	c6 85 49 ff fe
	ff 00		 mov	 BYTE PTR _infFile$19[ebp+1], 0
$LN647@RegisterFi:

; 2293 : 
; 2294 : 			HINF hInf = SetupOpenInfFile (infFileName.c_str(), NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);

  00511	83 bd bc ff fe
	ff 10		 cmp	 DWORD PTR _infFileName$23[ebp+20], 16 ; 00000010H
  00518	8d 85 a8 ff fe
	ff		 lea	 eax, DWORD PTR _infFileName$23[ebp]
  0051e	6a 00		 push	 0
  00520	0f 43 85 a8 ff
	fe ff		 cmovae	 eax, DWORD PTR _infFileName$23[ebp]
  00527	6a 03		 push	 3
  00529	6a 00		 push	 0
  0052b	50		 push	 eax
  0052c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetupOpenInfFileA@16

; 2295 : 			throw_sys_if (hInf == INVALID_HANDLE_VALUE);

  00532	83 f8 ff	 cmp	 eax, -1
  00535	75 23		 jne	 SHORT $LN13@RegisterFi
  00537	c7 85 5c fe fe
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00541	ff d7		 call	 edi
  00543	89 85 60 fe fe
	ff		 mov	 DWORD PTR $T5[ebp+4], eax
  00549	8d 85 5c fe fe
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0054f	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00554	50		 push	 eax
  00555	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN686@RegisterFi:
$LN13@RegisterFi:

; 2296 : 			finally_do_arg (HINF, hInf, { SetupCloseInfFile (finally_arg); });

  0055a	89 85 68 fe fe
	ff		 mov	 DWORD PTR _finally2296$8[ebp], eax

; 2297 : 
; 2298 : 			throw_sys_if (!SetupInstallFromInfSection (ParentWindow, hInf, "gostcrypt", SPINST_REGISTRY, regKey, NULL, 0, NULL, NULL, NULL, NULL));

  00560	6a 00		 push	 0
  00562	6a 00		 push	 0
  00564	6a 00		 push	 0
  00566	6a 00		 push	 0
  00568	6a 00		 push	 0
  0056a	6a 00		 push	 0
  0056c	ff b5 64 fe fe
	ff		 push	 DWORD PTR _regKey$[ebp]
  00572	c6 45 fc 1b	 mov	 BYTE PTR __$EHRec$[ebp+8], 27 ; 0000001bH
  00576	6a 04		 push	 4
  00578	68 00 00 00 00	 push	 OFFSET ??_C@_09JCILFBFB@gostcrypt?$AA@
  0057d	50		 push	 eax
  0057e	ff 33		 push	 DWORD PTR [ebx]
  00580	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetupInstallFromInfSectionA@44
  00586	85 c0		 test	 eax, eax
  00588	75 23		 jne	 SHORT $LN16@RegisterFi
  0058a	c7 85 5c fe fe
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00594	ff d7		 call	 edi
  00596	89 85 60 fe fe
	ff		 mov	 DWORD PTR $T4[ebp+4], eax
  0059c	8d 85 5c fe fe
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  005a2	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  005a7	50		 push	 eax
  005a8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN687@RegisterFi:
$LN16@RegisterFi:

; 2299 : 		}

  005ad	8d 8d 68 fe fe
	ff		 lea	 ecx, DWORD PTR _finally2296$8[ebp]
  005b3	e8 00 00 00 00	 call	 ??1Finally2296@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@XZ ; `GostCrypt::BootEncryption::RegisterFilter'::`25'::Finally2296::~Finally2296
  005b8	8d 8d 90 ff fe
	ff		 lea	 ecx, DWORD PTR _infTxt$22[ebp]
  005be	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  005c3	8d 8d 70 fe fe
	ff		 lea	 ecx, DWORD PTR _finally2284$10[ebp]
  005c9	e8 00 00 00 00	 call	 ??1Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@XZ ; `GostCrypt::BootEncryption::RegisterFilter'::`25'::Finally2284::~Finally2284
  005ce	8d 8d 48 ff fe
	ff		 lea	 ecx, DWORD PTR _infFile$19[ebp]
  005d4	e8 00 00 00 00	 call	 ??1File@GostCrypt@@QAE@XZ ; GostCrypt::File::~File
  005d9	8d 8d a8 ff fe
	ff		 lea	 ecx, DWORD PTR _infFileName$23[ebp]
  005df	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN26@RegisterFi:

; 2300 : 	}

  005e4	8d 8d 58 fe fe
	ff		 lea	 ecx, DWORD PTR _finally2260$[ebp]
  005ea	e8 00 00 00 00	 call	 ??1Finally2260@?1??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@XZ ; `GostCrypt::BootEncryption::RegisterFilter'::`2'::Finally2260::~Finally2260
$LN682@RegisterFi:
  005ef	8d 8d d8 ff fe
	ff		 lea	 ecx, DWORD PTR _filterReg$[ebp]
  005f5	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  005fa	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _filter$[ebp]
  00600	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00605	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00608	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0060f	59		 pop	 ecx
  00610	5f		 pop	 edi
  00611	5e		 pop	 esi
  00612	5b		 pop	 ebx
  00613	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00616	33 cd		 xor	 ecx, ebp
  00618	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0061d	8b e5		 mov	 esp, ebp
  0061f	5d		 pop	 ebp
  00620	c2 0c 00	 ret	 12			; 0000000cH
$LN24@RegisterFi:

; 2253 : 
; 2254 : 			break;
; 2255 : 
; 2256 : 		default:
; 2257 : 			throw ParameterIncorrect (SRC_POS);

  00623	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00628	8d 85 5c fe fe
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  0062e	c7 85 5c fe fe
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00638	50		 push	 eax
  00639	c7 85 60 fe fe
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+4], OFFSET ??_C@_0CP@OJIEODCG@GostCrypt?3?3BootEncryption?3?3Regis@
  00643	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN688@RegisterFi:
$LN681@RegisterFi:
  00648	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$0:
  00000	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR _filter$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$1:
  0000b	8d 8d d8 ff fe
	ff		 lea	 ecx, DWORD PTR _filterReg$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$2:
  00016	8d 8d 58 fe fe
	ff		 lea	 ecx, DWORD PTR _finally2260$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1Finally2260@?1??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@XZ ; `GostCrypt::BootEncryption::RegisterFilter'::`2'::Finally2260::~Finally2260
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$3:
  00021	8d 8d 78 ff fe
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$4:
  0002c	8d 8d a8 ff fe
	ff		 lea	 ecx, DWORD PTR _infFileName$23[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$6:
  00037	8d 8d 48 ff fe
	ff		 lea	 ecx, DWORD PTR _infFile$19[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1File@GostCrypt@@QAE@XZ ; GostCrypt::File::~File
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$8:
  00042	8d 8d 70 fe fe
	ff		 lea	 ecx, DWORD PTR _finally2284$10[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1Finally2284@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@XZ ; `GostCrypt::BootEncryption::RegisterFilter'::`25'::Finally2284::~Finally2284
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$9:
  0004d	8d 8d 88 fe fe
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$10:
  00058	8d 8d a0 fe fe
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  0005e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$11:
  00063	8d 8d b8 fe fe
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00069	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$12:
  0006e	8d 8d d0 fe fe
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  00074	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$13:
  00079	8d 8d e8 fe fe
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  0007f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$14:
  00084	8d 8d 00 ff fe
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  0008a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$15:
  0008f	8d 8d 18 ff fe
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  00095	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$16:
  0009a	8d 8d 30 ff fe
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  000a0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$17:
  000a5	8d 8d 78 ff fe
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  000ab	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$18:
  000b0	8d 8d 90 ff fe
	ff		 lea	 ecx, DWORD PTR _infTxt$22[ebp]
  000b6	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z$19:
  000bb	8d 8d 68 fe fe
	ff		 lea	 ecx, DWORD PTR _finally2296$8[ebp]
  000c1	e9 00 00 00 00	 jmp	 ??1Finally2296@?BJ@??RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@23@PBU_GUID@@@Z@QAE@XZ ; `GostCrypt::BootEncryption::RegisterFilter'::`25'::Finally2296::~Finally2296
__ehhandler$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z:
  000c6	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000ca	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000cd	8b 8a 50 fe fe
	ff		 mov	 ecx, DWORD PTR [edx-65968]
  000d3	33 c8		 xor	 ecx, eax
  000d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000da	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  000dd	33 c8		 xor	 ecx, eax
  000df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e4	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z
  000e9	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ENDP ; GostCrypt::BootEncryption::RegisterFilter
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?GetWindowsDirectoryA@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -276						; size = 4
$T2 = -272						; size = 8
_buf$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetWindowsDirectoryA@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; GostCrypt::BootEncryption::GetWindowsDirectoryA, COMDAT
; _this$ = ecx

; 981  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 982  : 		char buf[MAX_PATH];
; 983  : 		throw_sys_if (GetSystemDirectory (buf, sizeof (buf)) == 0);

  00017	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0001d	68 04 01 00 00	 push	 260			; 00000104H
  00022	50		 push	 eax
  00023	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemDirectoryA@8
  00033	85 c0		 test	 eax, eax
  00035	74 54		 je	 SHORT $LN128@GetWindows

; 984  : 		
; 985  : 		return string (buf);

  00037	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0003e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00045	c6 06 00	 mov	 BYTE PTR [esi], 0
  00048	80 bd f8 fe ff
	ff 00		 cmp	 BYTE PTR _buf$[ebp], 0
  0004f	75 04		 jne	 SHORT $LN124@GetWindows
  00051	33 c9		 xor	 ecx, ecx
  00053	eb 14		 jmp	 SHORT $LN125@GetWindows
$LN124@GetWindows:
  00055	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _buf$[ebp]
  0005b	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0005e	66 90		 npad	 2
$LL126@GetWindows:
  00060	8a 01		 mov	 al, BYTE PTR [ecx]
  00062	41		 inc	 ecx
  00063	84 c0		 test	 al, al
  00065	75 f9		 jne	 SHORT $LL126@GetWindows
  00067	2b ca		 sub	 ecx, edx
$LN125@GetWindows:
  00069	51		 push	 ecx
  0006a	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00070	8b ce		 mov	 ecx, esi
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 986  : 	}

  00078	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007b	8b c6		 mov	 eax, esi
  0007d	33 cd		 xor	 ecx, ebp
  0007f	5e		 pop	 esi
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
$LN128@GetWindows:

; 982  : 		char buf[MAX_PATH];
; 983  : 		throw_sys_if (GetSystemDirectory (buf, sizeof (buf)) == 0);

  0008b	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0009b	89 85 f4 fe ff
	ff		 mov	 DWORD PTR $T2[ebp+4], eax
  000a1	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000a7	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN130@GetWindows:
$LN127@GetWindows:
  000b2	cc		 int	 3
?GetWindowsDirectoryA@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; GostCrypt::BootEncryption::GetWindowsDirectoryA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
_TEXT	SEGMENT
$T2 = -92						; size = 4
$T3 = -88						; size = 24
$T4 = -64						; size = 24
$T5 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ PROC ; GostCrypt::BootEncryption::GetRemarksOnHiddenOS, COMDAT
; _this$ = ecx

; 764  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]

; 765  : 		return (wstring (L"\n\n")

  0002d	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  00030	6a 02		 push	 2
  00032	33 c0		 xor	 eax, eax
  00034	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  00040	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR $T5[ebp+20], 7
  00047	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+16], 0
  0004e	66 89 45 d8	 mov	 WORD PTR $T5[ebp], ax
  00052	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LDACPNCN@TWO_SYSTEMS_IN_ONE_PARTITION_REM@
  0005c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00063	e8 00 00 00 00	 call	 _GetString
  00068	50		 push	 eax
  00069	8d 45 d8	 lea	 eax, DWORD PTR $T5[ebp]
  0006c	50		 push	 eax
  0006d	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_15IABLJNFO@?$AA?6?$AA?6?$AA?$AA@
  0007b	50		 push	 eax
  0007c	8d 45 c0	 lea	 eax, DWORD PTR $T4[ebp]
  0007f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00089	8b f0		 mov	 esi, eax
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DMJIFPGL@FOR_MORE_INFO_ON_PARTITIONS?$AA@
  00090	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00094	e8 00 00 00 00	 call	 _GetString
  00099	50		 push	 eax
  0009a	56		 push	 esi
  0009b	57		 push	 edi
  0009c	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  000a1	8b 45 d4	 mov	 eax, DWORD PTR $T4[ebp+20]
  000a4	83 c4 2c	 add	 esp, 44			; 0000002cH
  000a7	83 f8 08	 cmp	 eax, 8
  000aa	72 0d		 jb	 SHORT $LN128@GetRemarks
  000ac	40		 inc	 eax
  000ad	8d 4d c0	 lea	 ecx, DWORD PTR $T4[ebp]
  000b0	50		 push	 eax
  000b1	ff 75 c0	 push	 DWORD PTR $T4[ebp]
  000b4	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN128@GetRemarks:
  000b9	33 c0		 xor	 eax, eax
  000bb	c7 45 d4 07 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 7
  000c2	66 89 45 c0	 mov	 WORD PTR $T4[ebp], ax
  000c6	8b 45 bc	 mov	 eax, DWORD PTR $T3[ebp+20]
  000c9	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+16], 0
  000d0	83 f8 08	 cmp	 eax, 8
  000d3	72 0d		 jb	 SHORT $LN231@GetRemarks
  000d5	40		 inc	 eax
  000d6	8d 4d a8	 lea	 ecx, DWORD PTR $T3[ebp]
  000d9	50		 push	 eax
  000da	ff 75 a8	 push	 DWORD PTR $T3[ebp]
  000dd	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN231@GetRemarks:
  000e2	8b 4d ec	 mov	 ecx, DWORD PTR $T5[ebp+20]
  000e5	33 c0		 xor	 eax, eax
  000e7	c7 45 bc 07 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 7
  000ee	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0
  000f5	66 89 45 a8	 mov	 WORD PTR $T3[ebp], ax
  000f9	83 f9 08	 cmp	 ecx, 8
  000fc	72 0d		 jb	 SHORT $LN431@GetRemarks
  000fe	41		 inc	 ecx
  000ff	51		 push	 ecx
  00100	ff 75 d8	 push	 DWORD PTR $T5[ebp]
  00103	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  00106	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN431@GetRemarks:
  0010b	8b c7		 mov	 eax, edi

; 766  : 				+ GetString ("TWO_SYSTEMS_IN_ONE_PARTITION_REMARK")
; 767  : 				+ L"\n\n"
; 768  : 				+ GetString ("FOR_MORE_INFO_ON_PARTITIONS"));
; 769  : 	}

  0010d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00110	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00117	59		 pop	 ecx
  00118	5f		 pop	 edi
  00119	5e		 pop	 esi
  0011a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011d	33 cd		 xor	 ecx, ebp
  0011f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$1:
  00008	8d 4d a8	 lea	 ecx, DWORD PTR $T3[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$2:
  00010	8d 4d c0	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ENDP ; GostCrypt::BootEncryption::GetRemarksOnHiddenOS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z
_TEXT	SEGMENT
_ws$2 = -2680						; size = 176
_partPath$3 = -2504					; size = 176
___$ReturnUdt$GSCopy$ = -2328				; size = 4
_this$ = -2324						; size = 4
_this$ = -2320						; size = 4
_this$4 = -2320						; size = 4
_this$ = -2320						; size = 4
_driveNumber$GSCopy$ = -2316				; size = 4
___$ReturnUdt$GSCopy$1$ = -2312				; size = 4
_partNumber$5 = -2308					; size = 4
$T6 = -2304						; size = 4
_diskPartInfo$7 = -2300					; size = 560
_part$8 = -1740						; size = 112
$T9 = -1628						; size = 24
$T10 = -1628						; size = 24
$T11 = -1628						; size = 24
_volumeNameStr$12 = -1604				; size = 24
$T13 = -1604						; size = 24
$T14 = -1604						; size = 24
$T15 = -1604						; size = 24
_volumePath$16 = -1580					; size = 520
_devicePath$17 = -1060					; size = 520
_volumeName$18 = -540					; size = 520
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_driveNumber$ = 12					; size = 4
?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z PROC ; GostCrypt::BootEncryption::GetDrivePartitions, COMDAT
; _this$ = ecx

; 884  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 6c 0a 00
	00		 sub	 esp, 2668		; 00000a6cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 8d ec f6 ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00037	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 885  : 		PartitionList partList;

  0003a	8b cb		 mov	 ecx, ebx
  0003c	8b 45 0c	 mov	 eax, DWORD PTR _driveNumber$[ebp]
  0003f	6a 00		 push	 0
  00041	c7 85 00 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], 0
  0004b	6a 00		 push	 0
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00054	89 9d f8 f6 ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], ebx
  0005a	89 9d e8 f6 ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], ebx
  00060	89 85 f4 f6 ff
	ff		 mov	 DWORD PTR _driveNumber$GSCopy$[ebp], eax
  00066	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  0006c	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  00073	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Buynode0
  00078	89 03		 mov	 DWORD PTR [ebx], eax

; 949  : 
; 950  : 		return partList;

  0007a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00081	bf 01 00 00 00	 mov	 edi, 1
  00086	33 f6		 xor	 esi, esi
$LN2107@GetDrivePa:

; 886  : 
; 887  : 		for (int partNumber = 0; partNumber < 64; ++partNumber)

  00088	89 b5 fc f6 ff
	ff		 mov	 DWORD PTR _partNumber$5[ebp], esi
  0008e	83 fe 40	 cmp	 esi, 64			; 00000040H
  00091	0f 8d a4 07 00
	00		 jge	 $LN3@GetDrivePa

; 888  : 		{
; 889  : 			stringstream partPath;

  00097	c7 85 38 f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR _partPath$3[ebp], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  000a1	c7 85 48 f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR _partPath$3[ebp+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  000ab	6a 00		 push	 0
  000ad	8d 85 50 f6 ff
	ff		 lea	 eax, DWORD PTR _partPath$3[ebp+24]
  000b3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  000ba	0f 57 c0	 xorps	 xmm0, xmm0
  000bd	c7 85 a0 f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR _partPath$3[ebp+104], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  000c7	83 cf 04	 or	 edi, 4
  000ca	c7 85 9c f6 ff
	ff 50 00 00 00	 mov	 DWORD PTR _partPath$3[ebp+100], 80 ; 00000050H
  000d4	50		 push	 eax
  000d5	8d 8d a0 f6 ff
	ff		 lea	 ecx, DWORD PTR _partPath$3[ebp+104]
  000db	89 bd 00 f7 ff
	ff		 mov	 DWORD PTR $T6[ebp], edi
  000e1	66 0f 13 85 40
	f6 ff ff	 movlpd	 QWORD PTR _partPath$3[ebp+8], xmm0
  000e9	e8 00 00 00 00	 call	 ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
  000ee	8d 85 48 f6 ff
	ff		 lea	 eax, DWORD PTR _partPath$3[ebp+16]
  000f4	89 85 f0 f6 ff
	ff		 mov	 DWORD PTR _this$4[ebp], eax
  000fa	8b 85 48 f6 ff
	ff		 mov	 eax, DWORD PTR _partPath$3[ebp+16]
  00100	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00103	c7 84 05 48 f6
	ff ff 00 00 00
	00		 mov	 DWORD PTR _partPath$3[ebp+eax+16], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  0010e	8b 85 48 f6 ff
	ff		 mov	 eax, DWORD PTR _partPath$3[ebp+16]
  00114	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00117	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  0011a	89 84 0d 44 f6
	ff ff		 mov	 DWORD PTR _partPath$3[ebp+ecx+12], eax
  00121	8b 85 38 f6 ff
	ff		 mov	 eax, DWORD PTR _partPath$3[ebp]
  00127	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0012a	c7 84 05 38 f6
	ff ff 00 00 00
	00		 mov	 DWORD PTR _partPath$3[ebp+eax], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  00135	8b 85 38 f6 ff
	ff		 mov	 eax, DWORD PTR _partPath$3[ebp]
  0013b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013e	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  00141	89 84 0d 34 f6
	ff ff		 mov	 DWORD PTR _partPath$3[ebp+ecx-4], eax
  00148	8b 85 38 f6 ff
	ff		 mov	 eax, DWORD PTR _partPath$3[ebp]
  0014e	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 6
  00155	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00158	c7 84 05 38 f6
	ff ff 00 00 00
	00		 mov	 DWORD PTR _partPath$3[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00163	8b 85 38 f6 ff
	ff		 mov	 eax, DWORD PTR _partPath$3[ebp]
  00169	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0016c	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  0016f	89 84 0d 34 f6
	ff ff		 mov	 DWORD PTR _partPath$3[ebp+ecx-4], eax
  00176	8d 85 50 f6 ff
	ff		 lea	 eax, DWORD PTR _partPath$3[ebp+24]
  0017c	8b c8		 mov	 ecx, eax
  0017e	89 85 f0 f6 ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
  00184	e8 00 00 00 00	 call	 ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
  00189	c7 85 50 f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR _partPath$3[ebp+24], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00193	c7 85 88 f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR _partPath$3[ebp+80], 0
  0019d	c7 85 8c f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR _partPath$3[ebp+84], 0

; 890  : 			partPath << "\\Device\\Harddisk" << driveNumber << "\\Partition" << partNumber;

  001a7	56		 push	 esi
  001a8	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DPPABKKK@?2Partition?$AA@
  001ad	ff b5 f4 f6 ff
	ff		 push	 DWORD PTR _driveNumber$GSCopy$[ebp]
  001b3	8d 85 48 f6 ff
	ff		 lea	 eax, DWORD PTR _partPath$3[ebp+16]
  001b9	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 8
  001c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EPPOJBJL@?2Device?2Harddisk?$AA@
  001c5	50		 push	 eax
  001c6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001cb	83 c4 08	 add	 esp, 8
  001ce	8b c8		 mov	 ecx, eax
  001d0	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  001d5	50		 push	 eax
  001d6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001db	83 c4 08	 add	 esp, 8
  001de	8b c8		 mov	 ecx, eax
  001e0	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 891  : 
; 892  : 			DISK_PARTITION_INFO_STRUCT diskPartInfo;
; 893  : 			_snwprintf (diskPartInfo.deviceName, array_capacity (diskPartInfo.deviceName), L"%hs", partPath.str().c_str());

  001e5	8d 85 a4 f9 ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  001eb	50		 push	 eax
  001ec	8d 8d 38 f6 ff
	ff		 lea	 ecx, DWORD PTR _partPath$3[ebp]
  001f2	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  001f7	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  001fb	72 02		 jb	 SHORT $LN168@GetDrivePa
  001fd	8b 00		 mov	 eax, DWORD PTR [eax]
$LN168@GetDrivePa:
  001ff	50		 push	 eax
  00200	68 00 00 00 00	 push	 OFFSET ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs?$AA?$AA@
  00205	8d 85 04 f7 ff
	ff		 lea	 eax, DWORD PTR _diskPartInfo$7[ebp]
  0020b	68 04 01 00 00	 push	 260			; 00000104H
  00210	50		 push	 eax
  00211	e8 00 00 00 00	 call	 __snwprintf
  00216	8b 85 b8 f9 ff
	ff		 mov	 eax, DWORD PTR $T11[ebp+20]
  0021c	83 c4 10	 add	 esp, 16			; 00000010H
  0021f	83 f8 10	 cmp	 eax, 16			; 00000010H
  00222	72 45		 jb	 SHORT $LN257@GetDrivePa
  00224	8b 8d a4 f9 ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  0022a	40		 inc	 eax
  0022b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00230	72 2e		 jb	 SHORT $LN252@GetDrivePa
  00232	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00235	74 05		 je	 SHORT $LN253@GetDrivePa
  00237	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2108@GetDrivePa:
$LN253@GetDrivePa:
  0023c	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0023f	3b c1		 cmp	 eax, ecx
  00241	72 05		 jb	 SHORT $LN254@GetDrivePa
  00243	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2109@GetDrivePa:
$LN254@GetDrivePa:
  00248	2b c8		 sub	 ecx, eax
  0024a	83 f9 04	 cmp	 ecx, 4
  0024d	73 05		 jae	 SHORT $LN255@GetDrivePa
  0024f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2110@GetDrivePa:
$LN255@GetDrivePa:
  00254	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00257	76 05		 jbe	 SHORT $LN256@GetDrivePa
  00259	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2111@GetDrivePa:
$LN256@GetDrivePa:
  0025e	8b c8		 mov	 ecx, eax
$LN252@GetDrivePa:
  00260	51		 push	 ecx
  00261	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00266	83 c4 04	 add	 esp, 4
$LN257@GetDrivePa:

; 894  : 
; 895  : 			try
; 896  : 			{
; 897  : 				CallDriver (GST_IOCTL_GET_DRIVE_PARTITION_INFO, &diskPartInfo, sizeof (diskPartInfo), &diskPartInfo, sizeof (diskPartInfo));

  00269	8b 8d ec f6 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0026f	8d 85 04 f7 ff
	ff		 lea	 eax, DWORD PTR _diskPartInfo$7[ebp]
  00275	68 30 02 00 00	 push	 560			; 00000230H
  0027a	50		 push	 eax
  0027b	68 30 02 00 00	 push	 560			; 00000230H
  00280	50		 push	 eax
  00281	68 38 20 22 00	 push	 2236472			; 00222038H
  00286	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+12], 9
  0028a	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 902  : 			}
; 903  : 
; 904  : 			Partition part;

  0028f	33 c0		 xor	 eax, eax
  00291	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 8
  00298	c7 85 48 f9 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _part$8[ebp+20], 15 ; 0000000fH
  002a2	c7 85 44 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _part$8[ebp+16], 0
  002ac	c6 85 34 f9 ff
	ff 00		 mov	 BYTE PTR _part$8[ebp], 0
  002b3	c7 85 80 f9 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _part$8[ebp+76], 15 ; 0000000fH
  002bd	c7 85 7c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _part$8[ebp+72], 0
  002c7	c6 85 6c f9 ff
	ff 00		 mov	 BYTE PTR _part$8[ebp+56], 0
  002ce	c7 85 a0 f9 ff
	ff 07 00 00 00	 mov	 DWORD PTR _part$8[ebp+108], 7
  002d8	c7 85 9c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _part$8[ebp+104], 0
  002e2	66 89 85 8c f9
	ff ff		 mov	 WORD PTR _part$8[ebp+88], ax
  002e9	8d 85 a4 f9 ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  002ef	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+12], 11 ; 0000000bH
  002f3	50		 push	 eax
  002f4	8d 8d 38 f6 ff
	ff		 lea	 ecx, DWORD PTR _partPath$3[ebp]
  002fa	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  002ff	8b f0		 mov	 esi, eax
  00301	8d 85 34 f9 ff
	ff		 lea	 eax, DWORD PTR _part$8[ebp]
  00307	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+12], 12 ; 0000000cH
  0030b	3b c6		 cmp	 eax, esi
  0030d	0f 84 c5 00 00
	00		 je	 $LN1204@GetDrivePa

; 905  : 			part.DevicePath = partPath.str();

  00313	8b 85 48 f9 ff
	ff		 mov	 eax, DWORD PTR _part$8[ebp+20]
  00319	83 f8 10	 cmp	 eax, 16			; 00000010H
  0031c	72 45		 jb	 SHORT $LN753@GetDrivePa
  0031e	8b 8d 34 f9 ff
	ff		 mov	 ecx, DWORD PTR _part$8[ebp]
  00324	40		 inc	 eax
  00325	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0032a	72 2e		 jb	 SHORT $LN748@GetDrivePa
  0032c	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0032f	74 05		 je	 SHORT $LN749@GetDrivePa
  00331	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2112@GetDrivePa:
$LN749@GetDrivePa:
  00336	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00339	3b c1		 cmp	 eax, ecx
  0033b	72 05		 jb	 SHORT $LN750@GetDrivePa
  0033d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2113@GetDrivePa:
$LN750@GetDrivePa:
  00342	2b c8		 sub	 ecx, eax
  00344	83 f9 04	 cmp	 ecx, 4
  00347	73 05		 jae	 SHORT $LN751@GetDrivePa
  00349	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2114@GetDrivePa:
$LN751@GetDrivePa:
  0034e	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00351	76 05		 jbe	 SHORT $LN752@GetDrivePa
  00353	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2115@GetDrivePa:
$LN752@GetDrivePa:
  00358	8b c8		 mov	 ecx, eax
$LN748@GetDrivePa:
  0035a	51		 push	 ecx
  0035b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00360	83 c4 04	 add	 esp, 4
$LN753@GetDrivePa:
  00363	c7 85 48 f9 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _part$8[ebp+20], 15 ; 0000000fH
  0036d	c7 85 44 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _part$8[ebp+16], 0
  00377	c6 85 34 f9 ff
	ff 00		 mov	 BYTE PTR _part$8[ebp], 0
  0037e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00382	73 1b		 jae	 SHORT $LN974@GetDrivePa
  00384	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00387	83 c0 01	 add	 eax, 1
  0038a	74 21		 je	 SHORT $LN975@GetDrivePa
  0038c	50		 push	 eax
  0038d	8d 85 34 f9 ff
	ff		 lea	 eax, DWORD PTR _part$8[ebp]
  00393	56		 push	 esi
  00394	50		 push	 eax
  00395	e8 00 00 00 00	 call	 _memmove
  0039a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0039d	eb 0e		 jmp	 SHORT $LN975@GetDrivePa
$LN974@GetDrivePa:
  0039f	8b 06		 mov	 eax, DWORD PTR [esi]
  003a1	89 85 34 f9 ff
	ff		 mov	 DWORD PTR _part$8[ebp], eax
  003a7	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN975@GetDrivePa:
  003ad	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  003b0	89 85 44 f9 ff
	ff		 mov	 DWORD PTR _part$8[ebp+16], eax
  003b6	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  003b9	89 85 48 f9 ff
	ff		 mov	 DWORD PTR _part$8[ebp+20], eax
  003bf	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  003c6	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  003ca	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  003d1	72 02		 jb	 SHORT $LN1200@GetDrivePa
  003d3	8b 36		 mov	 esi, DWORD PTR [esi]
$LN1200@GetDrivePa:
  003d5	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN1204@GetDrivePa:
  003d8	8b 85 b8 f9 ff
	ff		 mov	 eax, DWORD PTR $T10[ebp+20]
  003de	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+12], 11 ; 0000000bH
  003e2	83 f8 10	 cmp	 eax, 16			; 00000010H
  003e5	72 45		 jb	 SHORT $LN1292@GetDrivePa
  003e7	8b 8d a4 f9 ff
	ff		 mov	 ecx, DWORD PTR $T10[ebp]
  003ed	40		 inc	 eax
  003ee	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  003f3	72 2e		 jb	 SHORT $LN1287@GetDrivePa
  003f5	f6 c1 1f	 test	 cl, 31			; 0000001fH
  003f8	74 05		 je	 SHORT $LN1288@GetDrivePa
  003fa	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2116@GetDrivePa:
$LN1288@GetDrivePa:
  003ff	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00402	3b c1		 cmp	 eax, ecx
  00404	72 05		 jb	 SHORT $LN1289@GetDrivePa
  00406	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2117@GetDrivePa:
$LN1289@GetDrivePa:
  0040b	2b c8		 sub	 ecx, eax
  0040d	83 f9 04	 cmp	 ecx, 4
  00410	73 05		 jae	 SHORT $LN1290@GetDrivePa
  00412	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2118@GetDrivePa:
$LN1290@GetDrivePa:
  00417	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0041a	76 05		 jbe	 SHORT $LN1291@GetDrivePa
  0041c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2119@GetDrivePa:
$LN1291@GetDrivePa:
  00421	8b c8		 mov	 ecx, eax
$LN1287@GetDrivePa:
  00423	51		 push	 ecx
  00424	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00429	83 c4 04	 add	 esp, 4
$LN1292@GetDrivePa:

; 906  : 			part.Number = partNumber;
; 907  : 			part.Info = diskPartInfo.partInfo;

  0042c	0f 10 85 0c f9
	ff ff		 movups	 xmm0, XMMWORD PTR _diskPartInfo$7[ebp+520]
  00433	8b 85 fc f6 ff
	ff		 mov	 eax, DWORD PTR _partNumber$5[ebp]
  00439	89 85 84 f9 ff
	ff		 mov	 DWORD PTR _part$8[ebp+80], eax

; 908  : 			part.IsGPT = diskPartInfo.IsGPT;

  0043f	8b 85 2c f9 ff
	ff		 mov	 eax, DWORD PTR _diskPartInfo$7[ebp+552]
  00445	0f 11 85 4c f9
	ff ff		 movups	 XMMWORD PTR _part$8[ebp+24], xmm0
  0044c	89 85 88 f9 ff
	ff		 mov	 DWORD PTR _part$8[ebp+84], eax
  00452	0f 10 85 1c f9
	ff ff		 movups	 xmm0, XMMWORD PTR _diskPartInfo$7[ebp+536]

; 909  : 
; 910  : 			// Mount point
; 911  : 			wstringstream ws;

  00459	c7 85 88 f5 ff
	ff 00 00 00 00	 mov	 DWORD PTR _ws$2[ebp], OFFSET ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
  00463	c7 85 98 f5 ff
	ff 00 00 00 00	 mov	 DWORD PTR _ws$2[ebp+16], OFFSET ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
  0046d	0f 11 85 5c f9
	ff ff		 movups	 XMMWORD PTR _part$8[ebp+40], xmm0
  00474	c7 85 f0 f5 ff
	ff 00 00 00 00	 mov	 DWORD PTR _ws$2[ebp+104], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
  0047e	6a 00		 push	 0
  00480	8d 85 a0 f5 ff
	ff		 lea	 eax, DWORD PTR _ws$2[ebp+24]
  00486	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+12], 13 ; 0000000dH
  0048a	83 cf 40	 or	 edi, 64			; 00000040H
  0048d	8d 8d 88 f5 ff
	ff		 lea	 ecx, DWORD PTR _ws$2[ebp]
  00493	50		 push	 eax
  00494	89 bd 00 f7 ff
	ff		 mov	 DWORD PTR $T6[ebp], edi
  0049a	e8 00 00 00 00	 call	 ??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::basic_iostream<wchar_t,std::char_traits<wchar_t> >
  0049f	8b 85 88 f5 ff
	ff		 mov	 eax, DWORD PTR _ws$2[ebp]
  004a5	c7 45 fc 0e 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 14 ; 0000000eH
  004ac	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  004af	c7 84 05 88 f5
	ff ff 00 00 00
	00		 mov	 DWORD PTR _ws$2[ebp+eax], OFFSET ??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  004ba	8b 85 88 f5 ff
	ff		 mov	 eax, DWORD PTR _ws$2[ebp]
  004c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004c3	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  004c6	89 84 0d 84 f5
	ff ff		 mov	 DWORD PTR _ws$2[ebp+ecx-4], eax
  004cd	8d 85 a0 f5 ff
	ff		 lea	 eax, DWORD PTR _ws$2[ebp+24]
  004d3	8b c8		 mov	 ecx, eax
  004d5	89 85 f0 f6 ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
  004db	e8 00 00 00 00	 call	 ??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
  004e0	c7 85 a0 f5 ff
	ff 00 00 00 00	 mov	 DWORD PTR _ws$2[ebp+24], OFFSET ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
  004ea	c7 85 d8 f5 ff
	ff 00 00 00 00	 mov	 DWORD PTR _ws$2[ebp+80], 0
  004f4	c7 85 dc f5 ff
	ff 00 00 00 00	 mov	 DWORD PTR _ws$2[ebp+84], 0

; 912  : 			ws << partPath.str().c_str();

  004fe	8d 85 bc f9 ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  00504	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+12], 16 ; 00000010H
  00508	50		 push	 eax
  00509	8d 8d 38 f6 ff
	ff		 lea	 ecx, DWORD PTR _partPath$3[ebp]
  0050f	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  00514	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00518	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+12], 17 ; 00000011H
  0051c	72 02		 jb	 SHORT $LN1397@GetDrivePa
  0051e	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1397@GetDrivePa:
  00520	50		 push	 eax
  00521	8d 85 98 f5 ff
	ff		 lea	 eax, DWORD PTR _ws$2[ebp+16]
  00527	50		 push	 eax
  00528	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  0052d	8b 85 d0 f9 ff
	ff		 mov	 eax, DWORD PTR $T15[ebp+20]
  00533	83 c4 08	 add	 esp, 8
  00536	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+12], 16 ; 00000010H
  0053a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0053d	72 13		 jb	 SHORT $LN1406@GetDrivePa
  0053f	40		 inc	 eax
  00540	8d 8d bc f9 ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  00546	50		 push	 eax
  00547	ff b5 bc f9 ff
	ff		 push	 DWORD PTR $T15[ebp]
  0054d	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN1406@GetDrivePa:

; 913  : 			int driveNumber = GetDiskDeviceDriveLetter ((wchar_t *) ws.str().c_str());

  00552	8d 85 bc f9 ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  00558	50		 push	 eax
  00559	8d 8d 88 f5 ff
	ff		 lea	 ecx, DWORD PTR _ws$2[ebp]
  0055f	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
  00564	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00568	72 02		 jb	 SHORT $LN1515@GetDrivePa
  0056a	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1515@GetDrivePa:
  0056c	50		 push	 eax
  0056d	e8 00 00 00 00	 call	 _GetDiskDeviceDriveLetter
  00572	8b d8		 mov	 ebx, eax
  00574	83 c4 04	 add	 esp, 4
  00577	8b 85 d0 f9 ff
	ff		 mov	 eax, DWORD PTR $T14[ebp+20]
  0057d	83 f8 08	 cmp	 eax, 8
  00580	72 13		 jb	 SHORT $LN1524@GetDrivePa
  00582	40		 inc	 eax
  00583	8d 8d bc f9 ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  00589	50		 push	 eax
  0058a	ff b5 bc f9 ff
	ff		 push	 DWORD PTR $T14[ebp]
  00590	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN1524@GetDrivePa:

; 914  : 
; 915  : 			if (driveNumber >= 0)

  00595	85 db		 test	 ebx, ebx
  00597	78 26		 js	 SHORT $LN9@GetDrivePa

; 916  : 			{
; 917  : 				part.MountPoint += (char) (driveNumber + 'A');

  00599	80 c3 41	 add	 bl, 65			; 00000041H
  0059c	8d 8d 6c f9 ff
	ff		 lea	 ecx, DWORD PTR _part$8[ebp+56]
  005a2	0f b6 c3	 movzx	 eax, bl
  005a5	50		 push	 eax
  005a6	6a 01		 push	 1
  005a8	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 918  : 				part.MountPoint += ":";

  005ad	6a 01		 push	 1
  005af	68 00 00 00 00	 push	 OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
  005b4	8d 8d 6c f9 ff
	ff		 lea	 ecx, DWORD PTR _part$8[ebp+56]
  005ba	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN9@GetDrivePa:

; 919  : 			}
; 920  : 
; 921  : 			// Volume ID
; 922  : 			wchar_t volumePath[GST_MAX_PATH];
; 923  : 			if (ResolveSymbolicLink ((wchar_t *) ws.str().c_str(), volumePath))

  005bf	8d 85 bc f9 ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  005c5	50		 push	 eax
  005c6	8d 8d 88 f5 ff
	ff		 lea	 ecx, DWORD PTR _ws$2[ebp]
  005cc	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::str
  005d1	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  005d5	72 02		 jb	 SHORT $LN1645@GetDrivePa
  005d7	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1645@GetDrivePa:
  005d9	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR _volumePath$16[ebp]
  005df	51		 push	 ecx
  005e0	50		 push	 eax
  005e1	e8 00 00 00 00	 call	 _ResolveSymbolicLink
  005e6	8b f0		 mov	 esi, eax
  005e8	83 c4 08	 add	 esp, 8
  005eb	8b 85 d0 f9 ff
	ff		 mov	 eax, DWORD PTR $T13[ebp+20]
  005f1	83 f8 08	 cmp	 eax, 8
  005f4	72 13		 jb	 SHORT $LN1654@GetDrivePa
  005f6	40		 inc	 eax
  005f7	8d 8d bc f9 ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  005fd	50		 push	 eax
  005fe	ff b5 bc f9 ff
	ff		 push	 DWORD PTR $T13[ebp]
  00604	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN1654@GetDrivePa:
  00609	85 f6		 test	 esi, esi
  0060b	0f 84 48 01 00
	00		 je	 $LN11@GetDrivePa

; 924  : 			{
; 925  : 				wchar_t volumeName[GST_MAX_PATH];
; 926  : 				HANDLE fh = FindFirstVolumeW (volumeName, array_capacity (volumeName));

  00611	68 04 01 00 00	 push	 260			; 00000104H
  00616	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _volumeName$18[ebp]
  0061c	50		 push	 eax
  0061d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindFirstVolumeW@8
  00623	8b f0		 mov	 esi, eax

; 927  : 				if (fh != INVALID_HANDLE_VALUE)

  00625	83 fe ff	 cmp	 esi, -1
  00628	0f 84 2b 01 00
	00		 je	 $LN11@GetDrivePa
  0062e	66 90		 npad	 2
$LL7@GetDrivePa:

; 928  : 				{
; 929  : 					do
; 930  : 					{
; 931  : 						wstring volumeNameStr = volumeName;

  00630	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _volumeName$18[ebp]
  00636	50		 push	 eax
  00637	8d 8d bc f9 ff
	ff		 lea	 ecx, DWORD PTR _volumeNameStr$12[ebp]
  0063d	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 932  : 						wchar_t devicePath[GST_MAX_PATH];
; 933  : 
; 934  : 						if (QueryDosDeviceW (volumeNameStr.substr (4, volumeNameStr.size() - 1 - 4).c_str(), devicePath, array_capacity (devicePath)) != 0
; 935  : 							&& wcscmp (volumePath, devicePath) == 0)

  00642	8b 85 cc f9 ff
	ff		 mov	 eax, DWORD PTR _volumeNameStr$12[ebp+16]
  00648	8d 8d bc f9 ff
	ff		 lea	 ecx, DWORD PTR _volumeNameStr$12[ebp]
  0064e	83 c0 fb	 add	 eax, -5			; fffffffbH
  00651	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+12], 18 ; 00000012H
  00655	50		 push	 eax
  00656	6a 04		 push	 4
  00658	8d 85 a4 f9 ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  0065e	50		 push	 eax
  0065f	e8 00 00 00 00	 call	 ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
  00664	83 cf 02	 or	 edi, 2
  00667	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  0066b	72 02		 jb	 SHORT $LN1777@GetDrivePa
  0066d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1777@GetDrivePa:
  0066f	68 04 01 00 00	 push	 260			; 00000104H
  00674	8d 8d dc fb ff
	ff		 lea	 ecx, DWORD PTR _devicePath$17[ebp]
  0067a	51		 push	 ecx
  0067b	50		 push	 eax
  0067c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryDosDeviceW@12
  00682	85 c0		 test	 eax, eax
  00684	74 3f		 je	 SHORT $LN18@GetDrivePa
  00686	8d 85 dc fb ff
	ff		 lea	 eax, DWORD PTR _devicePath$17[ebp]
  0068c	8d 8d d4 f9 ff
	ff		 lea	 ecx, DWORD PTR _volumePath$16[ebp]
$LL2101@GetDrivePa:
  00692	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00695	66 3b 10	 cmp	 dx, WORD PTR [eax]
  00698	75 1e		 jne	 SHORT $LN2102@GetDrivePa
  0069a	66 85 d2	 test	 dx, dx
  0069d	74 15		 je	 SHORT $LN2103@GetDrivePa
  0069f	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  006a3	66 3b 50 02	 cmp	 dx, WORD PTR [eax+2]
  006a7	75 0f		 jne	 SHORT $LN2102@GetDrivePa
  006a9	83 c1 04	 add	 ecx, 4
  006ac	83 c0 04	 add	 eax, 4
  006af	66 85 d2	 test	 dx, dx
  006b2	75 de		 jne	 SHORT $LL2101@GetDrivePa
$LN2103@GetDrivePa:
  006b4	33 c0		 xor	 eax, eax
  006b6	eb 05		 jmp	 SHORT $LN2104@GetDrivePa
$LN2102@GetDrivePa:
  006b8	1b c0		 sbb	 eax, eax
  006ba	83 c8 01	 or	 eax, 1
$LN2104@GetDrivePa:
  006bd	85 c0		 test	 eax, eax
  006bf	75 04		 jne	 SHORT $LN18@GetDrivePa
  006c1	b3 01		 mov	 bl, 1
  006c3	eb 02		 jmp	 SHORT $LN19@GetDrivePa
$LN18@GetDrivePa:
  006c5	32 db		 xor	 bl, bl
$LN19@GetDrivePa:
  006c7	8b 85 b8 f9 ff
	ff		 mov	 eax, DWORD PTR $T9[ebp+20]
  006cd	83 e7 fd	 and	 edi, -3			; fffffffdH
  006d0	89 bd 00 f7 ff
	ff		 mov	 DWORD PTR $T6[ebp], edi
  006d6	83 f8 08	 cmp	 eax, 8
  006d9	72 13		 jb	 SHORT $LN1786@GetDrivePa
  006db	40		 inc	 eax
  006dc	8d 8d a4 f9 ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  006e2	50		 push	 eax
  006e3	ff b5 a4 f9 ff
	ff		 push	 DWORD PTR $T9[ebp]
  006e9	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN1786@GetDrivePa:
  006ee	84 db		 test	 bl, bl
  006f0	75 3f		 jne	 SHORT $LN2095@GetDrivePa

; 939  : 						}
; 940  : 
; 941  : 					} while (FindNextVolumeW (fh, volumeName, array_capacity (volumeName)));

  006f2	8b 85 d0 f9 ff
	ff		 mov	 eax, DWORD PTR _volumeNameStr$12[ebp+20]
  006f8	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+12], 16 ; 00000010H
  006fc	83 f8 08	 cmp	 eax, 8
  006ff	72 13		 jb	 SHORT $LN1889@GetDrivePa
  00701	40		 inc	 eax
  00702	8d 8d bc f9 ff
	ff		 lea	 ecx, DWORD PTR _volumeNameStr$12[ebp]
  00708	50		 push	 eax
  00709	ff b5 bc f9 ff
	ff		 push	 DWORD PTR _volumeNameStr$12[ebp]
  0070f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN1889@GetDrivePa:
  00714	68 04 01 00 00	 push	 260			; 00000104H
  00719	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _volumeName$18[ebp]
  0071f	50		 push	 eax
  00720	56		 push	 esi
  00721	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindNextVolumeW@12
  00727	85 c0		 test	 eax, eax
  00729	0f 85 01 ff ff
	ff		 jne	 $LL7@GetDrivePa
  0072f	eb 21		 jmp	 SHORT $LN6@GetDrivePa
$LN2095@GetDrivePa:

; 936  : 						{
; 937  : 							part.VolumeNameId = volumeName;

  00731	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _volumeName$18[ebp]
  00737	50		 push	 eax
  00738	8d 8d 8c f9 ff
	ff		 lea	 ecx, DWORD PTR _part$8[ebp+88]
  0073e	e8 00 00 00 00	 call	 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=

; 938  : 							break;

  00743	8d 8d bc f9 ff
	ff		 lea	 ecx, DWORD PTR _volumeNameStr$12[ebp]
  00749	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+12], 16 ; 00000010H
  0074d	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN6@GetDrivePa:

; 942  : 
; 943  : 					FindVolumeClose (fh);

  00752	56		 push	 esi
  00753	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindVolumeClose@4
$LN11@GetDrivePa:

; 944  : 				}
; 945  : 			}
; 946  : 
; 947  : 			partList.push_back (part);

  00759	8b 9d f8 f6 ff
	ff		 mov	 ebx, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  0075f	8d 85 34 f9 ff
	ff		 lea	 eax, DWORD PTR _part$8[ebp]
  00765	50		 push	 eax
  00766	8b cb		 mov	 ecx, ebx
  00768	8b 33		 mov	 esi, DWORD PTR [ebx]
  0076a	ff 76 04	 push	 DWORD PTR [esi+4]
  0076d	56		 push	 esi
  0076e	e8 00 00 00 00	 call	 ??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Buynode<GostCrypt::Partition const &>
  00773	8b c8		 mov	 ecx, eax
  00775	b8 21 22 22 02	 mov	 eax, 35791393		; 02222221H
  0077a	2b 43 04	 sub	 eax, DWORD PTR [ebx+4]
  0077d	83 f8 01	 cmp	 eax, 1
  00780	73 0a		 jae	 SHORT $LN2023@GetDrivePa
  00782	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00787	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2120@GetDrivePa:
$LN2023@GetDrivePa:
  0078c	ff 43 04	 inc	 DWORD PTR [ebx+4]
  0078f	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00792	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00795	89 08		 mov	 DWORD PTR [eax], ecx

; 948  : 		}

  00797	8d 8d f0 f5 ff
	ff		 lea	 ecx, DWORD PTR _ws$2[ebp+104]
  0079d	e8 00 00 00 00	 call	 ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UAE@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  007a2	8d 85 f0 f5 ff
	ff		 lea	 eax, DWORD PTR _ws$2[ebp+104]
  007a8	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+12], 19 ; 00000013H
  007ac	50		 push	 eax
  007ad	c7 85 f0 f5 ff
	ff 00 00 00 00	 mov	 DWORD PTR _ws$2[ebp+104], OFFSET ??_7ios_base@std@@6B@
  007b7	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  007bc	83 c4 04	 add	 esp, 4
  007bf	8d 8d 34 f9 ff
	ff		 lea	 ecx, DWORD PTR _part$8[ebp]
  007c5	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  007ca	8d 8d a0 f6 ff
	ff		 lea	 ecx, DWORD PTR _partPath$3[ebp+104]
  007d0	e8 00 00 00 00	 call	 ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  007d5	8d 85 a0 f6 ff
	ff		 lea	 eax, DWORD PTR _partPath$3[ebp+104]
  007db	c7 45 fc 14 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 20 ; 00000014H
  007e2	50		 push	 eax
  007e3	c7 85 a0 f6 ff
	ff 00 00 00 00	 mov	 DWORD PTR _partPath$3[ebp+104], OFFSET ??_7ios_base@std@@6B@
  007ed	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  007f2	8b b5 fc f6 ff
	ff		 mov	 esi, DWORD PTR _partNumber$5[ebp]
  007f8	83 c4 04	 add	 esp, 4
  007fb	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  007ff	46		 inc	 esi
  00800	e9 83 f8 ff ff	 jmp	 $LN2107@GetDrivePa
__catch$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$0:

; 898  : 			}
; 899  : 			catch (...)
; 900  : 			{
; 901  : 				continue;

  00805	b8 00 00 00 00	 mov	 eax, $LN37@GetDrivePa
  0080a	c3		 ret	 0
$LN37@GetDrivePa:
  0080b	8d 8d 38 f6 ff
	ff		 lea	 ecx, DWORD PTR _partPath$3[ebp]
  00811	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00818	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  0081d	8b b5 fc f6 ff
	ff		 mov	 esi, DWORD PTR _partNumber$5[ebp]
  00823	8b 9d e8 f6 ff
	ff		 mov	 ebx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  00829	46		 inc	 esi
  0082a	8b bd 00 f7 ff
	ff		 mov	 edi, DWORD PTR $T6[ebp]
  00830	89 9d f8 f6 ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], ebx
  00836	e9 4d f8 ff ff	 jmp	 $LN2107@GetDrivePa
$LN3@GetDrivePa:

; 949  : 
; 950  : 		return partList;

  0083b	8b c3		 mov	 eax, ebx

; 951  : 	}

  0083d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00840	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00847	59		 pop	 ecx
  00848	5f		 pop	 edi
  00849	5e		 pop	 esi
  0084a	5b		 pop	 ebx
  0084b	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0084e	33 cd		 xor	 ecx, ebp
  00850	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00855	8b e5		 mov	 esp, ebp
  00857	5d		 pop	 ebp
  00858	c2 08 00	 ret	 8
$LN2106@GetDrivePa:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$2:
  00000	8b 85 00 f7 ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  00006	83 e0 01	 and	 eax, 1
  00009	0f 84 12 00 00
	00		 je	 $LN23@GetDrivePa
  0000f	83 a5 00 f7 ff
	ff fe		 and	 DWORD PTR $T6[ebp], -2	; fffffffeH
  00016	8b 8d e8 f6 ff
	ff		 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::~list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
$LN23@GetDrivePa:
  00021	c3		 ret	 0
__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$18:
  00022	8b 85 00 f7 ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  00028	83 e0 04	 and	 eax, 4
  0002b	0f 84 12 00 00
	00		 je	 $LN67@GetDrivePa
  00031	83 a5 00 f7 ff
	ff fb		 and	 DWORD PTR $T6[ebp], -5	; fffffffbH
  00038	8d 8d a0 f6 ff
	ff		 lea	 ecx, DWORD PTR _partPath$3[ebp+104]
  0003e	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN67@GetDrivePa:
  00043	c3		 ret	 0
__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$22:
  00044	8d 8d 50 f6 ff
	ff		 lea	 ecx, DWORD PTR _partPath$3[ebp+24]
  0004a	e9 00 00 00 00	 jmp	 ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$19:
  0004f	8d 8d 58 f6 ff
	ff		 lea	 ecx, DWORD PTR _partPath$3[ebp+32]
  00055	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$26:
  0005a	8b 8d f0 f6 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$3:
  00065	8d 8d 38 f6 ff
	ff		 lea	 ecx, DWORD PTR _partPath$3[ebp]
  0006b	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$5:
  00070	8d 8d 34 f9 ff
	ff		 lea	 ecx, DWORD PTR _part$8[ebp]
  00076	e9 00 00 00 00	 jmp	 ??1Partition@GostCrypt@@QAE@XZ
__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$140:
  0007b	e8 00 00 00 00	 call	 ___std_terminate
  00080	c3		 ret	 0
__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$300:
  00081	8b 85 00 f7 ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  00087	83 e0 40	 and	 eax, 64			; 00000040H
  0008a	0f 84 12 00 00
	00		 je	 $LN1327@GetDrivePa
  00090	83 a5 00 f7 ff
	ff bf		 and	 DWORD PTR $T6[ebp], -65	; ffffffbfH
  00097	8d 8d f0 f5 ff
	ff		 lea	 ecx, DWORD PTR _ws$2[ebp+104]
  0009d	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN1327@GetDrivePa:
  000a2	c3		 ret	 0
__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$301:
  000a3	8d 8d a8 f5 ff
	ff		 lea	 ecx, DWORD PTR _ws$2[ebp+32]
  000a9	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::~basic_iostream<wchar_t,std::char_traits<wchar_t> >
__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$303:
  000ae	8b 8d f0 f6 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$7:
  000b9	8d 8d 88 f5 ff
	ff		 lea	 ecx, DWORD PTR _ws$2[ebp]
  000bf	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$8:
  000c4	8d 8d bc f9 ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  000ca	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$11:
  000cf	8d 8d bc f9 ff
	ff		 lea	 ecx, DWORD PTR _volumeNameStr$12[ebp]
  000d5	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$476:
  000da	e8 00 00 00 00	 call	 ___std_terminate
  000df	c3		 ret	 0
__unwindfunclet$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z$479:
  000e0	e8 00 00 00 00	 call	 ___std_terminate
  000e5	c3		 ret	 0
__ehhandler$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z:
  000e6	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000ea	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000ed	8b 8a 84 f5 ff
	ff		 mov	 ecx, DWORD PTR [edx-2684]
  000f3	33 c8		 xor	 ecx, eax
  000f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fa	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  000fd	33 c8		 xor	 ecx, eax
  000ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00104	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z
  00109	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z ENDP ; GostCrypt::BootEncryption::GetDrivePartitions
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z
_TEXT	SEGMENT
_devName$ = -228					; size = 176
$T2 = -52						; size = 4
$T3 = -48						; size = 8
_this$4 = -44						; size = 4
_this$ = -44						; size = 4
$T5 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_driveNumber$ = 12					; size = 4
?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z PROC ; GostCrypt::BootEncryption::GetDriveGeometry, COMDAT
; _this$ = ecx

; 963  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00031	8b 75 0c	 mov	 esi, DWORD PTR _driveNumber$[ebp]
  00034	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 964  : 		stringstream devName;

  0003b	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _devName$[ebp], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  00045	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _devName$[ebp+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  0004f	6a 00		 push	 0
  00051	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp+24]
  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005e	0f 57 c0	 xorps	 xmm0, xmm0
  00061	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  00068	50		 push	 eax
  00069	8d 4d 84	 lea	 ecx, DWORD PTR _devName$[ebp+104]
  0006c	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _devName$[ebp+104], OFFSET ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
  00073	c7 45 80 50 00
	00 00		 mov	 DWORD PTR _devName$[ebp+100], 80 ; 00000050H
  0007a	66 0f 13 85 24
	ff ff ff	 movlpd	 QWORD PTR _devName$[ebp+8], xmm0
  00082	e8 00 00 00 00	 call	 ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
  00087	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp+16]
  0008d	89 45 d4	 mov	 DWORD PTR _this$4[ebp], eax
  00090	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _devName$[ebp+16]
  00096	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00099	c7 84 05 2c ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _devName$[ebp+eax+16], OFFSET ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
  000a4	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _devName$[ebp+16]
  000aa	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ad	8d 41 f8	 lea	 eax, DWORD PTR [ecx-8]
  000b0	89 84 0d 28 ff
	ff ff		 mov	 DWORD PTR _devName$[ebp+ecx+12], eax
  000b7	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _devName$[ebp]
  000bd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c0	c7 84 05 1c ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _devName$[ebp+eax], OFFSET ??_7?$basic_iostream@DU?$char_traits@D@std@@@std@@6B@
  000cb	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _devName$[ebp]
  000d1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d4	8d 41 e0	 lea	 eax, DWORD PTR [ecx-32]
  000d7	89 84 0d 18 ff
	ff ff		 mov	 DWORD PTR _devName$[ebp+ecx-4], eax
  000de	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _devName$[ebp]
  000e4	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  000eb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ee	c7 84 05 1c ff
	ff ff 00 00 00
	00		 mov	 DWORD PTR _devName$[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  000f9	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _devName$[ebp]
  000ff	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00102	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00105	89 84 0d 18 ff
	ff ff		 mov	 DWORD PTR _devName$[ebp+ecx-4], eax
  0010c	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp+24]
  00112	8b c8		 mov	 ecx, eax
  00114	89 45 d4	 mov	 DWORD PTR _this$[ebp], eax
  00117	e8 00 00 00 00	 call	 ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
  0011c	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _devName$[ebp+24], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00126	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _devName$[ebp+80], 0
  00130	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _devName$[ebp+84], 0

; 965  : 		devName << "\\Device\\Harddisk" << driveNumber << "\\Partition0";

  0013a	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OJHKIMBP@?2Partition0?$AA@
  0013f	56		 push	 esi
  00140	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR _devName$[ebp+16]
  00146	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7
  0014d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EPPOJBJL@?2Device?2Harddisk?$AA@
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00158	83 c4 08	 add	 esp, 8
  0015b	8b c8		 mov	 ecx, eax
  0015d	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  00162	50		 push	 eax
  00163	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00168	83 c4 08	 add	 esp, 8

; 966  : 
; 967  : 		DISK_GEOMETRY geometry;
; 968  : 		throw_sys_if (!::GetDriveGeometry ((char *) devName.str().c_str(), &geometry));

  0016b	8d 45 d8	 lea	 eax, DWORD PTR $T5[ebp]
  0016e	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _devName$[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  0017a	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0017e	72 02		 jb	 SHORT $LN100@GetDriveGe
  00180	8b 00		 mov	 eax, DWORD PTR [eax]
$LN100@GetDriveGe:
  00182	57		 push	 edi
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 _GetDriveGeometry
  00189	83 c4 08	 add	 esp, 8
  0018c	85 c0		 test	 eax, eax
  0018e	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp+20]
  00191	0f 94 c3	 sete	 bl
  00194	83 f8 10	 cmp	 eax, 16			; 00000010H
  00197	72 42		 jb	 SHORT $LN189@GetDriveGe
  00199	8b 4d d8	 mov	 ecx, DWORD PTR $T5[ebp]
  0019c	40		 inc	 eax
  0019d	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  001a2	72 2e		 jb	 SHORT $LN184@GetDriveGe
  001a4	f6 c1 1f	 test	 cl, 31			; 0000001fH
  001a7	74 05		 je	 SHORT $LN185@GetDriveGe
  001a9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN238@GetDriveGe:
$LN185@GetDriveGe:
  001ae	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  001b1	3b c1		 cmp	 eax, ecx
  001b3	72 05		 jb	 SHORT $LN186@GetDriveGe
  001b5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN239@GetDriveGe:
$LN186@GetDriveGe:
  001ba	2b c8		 sub	 ecx, eax
  001bc	83 f9 04	 cmp	 ecx, 4
  001bf	73 05		 jae	 SHORT $LN187@GetDriveGe
  001c1	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN240@GetDriveGe:
$LN187@GetDriveGe:
  001c6	83 f9 23	 cmp	 ecx, 35			; 00000023H
  001c9	76 05		 jbe	 SHORT $LN188@GetDriveGe
  001cb	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN241@GetDriveGe:
$LN188@GetDriveGe:
  001d0	8b c8		 mov	 ecx, eax
$LN184@GetDriveGe:
  001d2	51		 push	 ecx
  001d3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001d8	83 c4 04	 add	 esp, 4
$LN189@GetDriveGe:
  001db	84 db		 test	 bl, bl
  001dd	74 1e		 je	 SHORT $LN2@GetDriveGe
  001df	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001ec	89 45 d4	 mov	 DWORD PTR $T3[ebp+4], eax
  001ef	8d 45 d0	 lea	 eax, DWORD PTR $T3[ebp]
  001f2	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  001f7	50		 push	 eax
  001f8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN242@GetDriveGe:
$LN2@GetDriveGe:

; 969  : 		return geometry;

  001fd	8d 4d 84	 lea	 ecx, DWORD PTR _devName$[ebp+104]
  00200	e8 00 00 00 00	 call	 ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  00205	8d 45 84	 lea	 eax, DWORD PTR _devName$[ebp+104]
  00208	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 8
  0020f	50		 push	 eax
  00210	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _devName$[ebp+104], OFFSET ??_7ios_base@std@@6B@
  00217	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0021c	83 c4 04	 add	 esp, 4
  0021f	8b c7		 mov	 eax, edi

; 970  : 	}

  00221	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00224	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0022b	59		 pop	 ecx
  0022c	5f		 pop	 edi
  0022d	5e		 pop	 esi
  0022e	5b		 pop	 ebx
  0022f	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00232	33 cd		 xor	 ecx, ebp
  00234	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00239	8b e5		 mov	 esp, ebp
  0023b	5d		 pop	 ebp
  0023c	c2 08 00	 ret	 8
$LN237@GetDriveGe:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z$2:
  00000	8b 45 cc	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN15@GetDriveGe
  0000c	83 65 cc fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8d 4d 84	 lea	 ecx, DWORD PTR _devName$[ebp+104]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN15@GetDriveGe:
  00018	c3		 ret	 0
__unwindfunclet$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z$6:
  00019	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _devName$[ebp+24]
  0001f	e9 00 00 00 00	 jmp	 ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_istream<char,std::char_traits<char> >::~basic_istream<char,std::char_traits<char> >
__unwindfunclet$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z$3:
  00024	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _devName$[ebp+32]
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
__unwindfunclet$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z$10:
  0002f	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__unwindfunclet$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z$0:
  00037	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR _devName$[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z$45:
  00042	e8 00 00 00 00	 call	 ___std_terminate
  00047	c3		 ret	 0
__ehhandler$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z:
  00048	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0004f	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  00055	33 c8		 xor	 ecx, eax
  00057	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0005f	33 c8		 xor	 ecx, eax
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z
  0006b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z ENDP ; GostCrypt::BootEncryption::GetDriveGeometry
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?GetChecksum@BootEncryption@GostCrypt@@IAEIPAEI@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
_size$ = 12						; size = 4
?GetChecksum@BootEncryption@GostCrypt@@IAEIPAEI@Z PROC	; GostCrypt::BootEncryption::GetChecksum, COMDAT
; _this$ = ecx

; 1328 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1329 : 		uint32 sum = 0;
; 1330 : 
; 1331 : 		while (size-- > 0)

  00003	8b 55 0c	 mov	 edx, DWORD PTR _size$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 d2		 test	 edx, edx
  0000a	74 14		 je	 SHORT $LN6@GetChecksu
  0000c	56		 push	 esi
  0000d	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]
$LL2@GetChecksu:

; 1332 : 		{
; 1333 : 			sum += *data++;

  00010	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  00013	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00016	03 c1		 add	 eax, ecx

; 1334 : 			sum = _rotl (sum, 1);

  00018	d1 c0		 rol	 eax, 1
  0001a	83 ea 01	 sub	 edx, 1
  0001d	75 f1		 jne	 SHORT $LL2@GetChecksu
  0001f	5e		 pop	 esi
$LN6@GetChecksu:

; 1335 : 		}
; 1336 : 
; 1337 : 		return sum;
; 1338 : 	}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?GetChecksum@BootEncryption@GostCrypt@@IAEIPAEI@Z ENDP	; GostCrypt::BootEncryption::GetChecksum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T2 = -360						; size = 4
$T3 = -356						; size = 8
$T4 = -348						; size = 24
_path$ = -324						; size = 24
$T5 = -300						; size = 24
_pathBuf$ = -276					; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; GostCrypt::BootEncryption::GetSystemLoaderBackupPath, COMDAT
; _this$ = ecx

; 1824 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 1825 : 		char pathBuf[MAX_PATH];
; 1826 : 
; 1827 : 		throw_sys_if (!SUCCEEDED (SHGetFolderPath (NULL, CSIDL_COMMON_APPDATA | CSIDL_FLAG_CREATE, NULL, 0, pathBuf)));

  0002f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pathBuf$[ebp]
  00035	50		 push	 eax
  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	68 23 80 00 00	 push	 32803			; 00008023H
  0003f	6a 00		 push	 0
  00041	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetFolderPathA@20
  00051	85 c0		 test	 eax, eax
  00053	79 27		 jns	 SHORT $LN2@GetSystemL
  00055	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00065	89 85 a0 fe ff
	ff		 mov	 DWORD PTR $T3[ebp+4], eax
  0006b	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00071	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN452@GetSystemL:
$LN2@GetSystemL:

; 1828 : 		
; 1829 : 		string path = string (pathBuf) + "\\" GST_APP_NAME;

  0007c	80 bd ec fe ff
	ff 00		 cmp	 BYTE PTR _pathBuf$[ebp], 0
  00083	c7 85 e8 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH
  0008d	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+16], 0
  00097	c6 85 d4 fe ff
	ff 00		 mov	 BYTE PTR $T5[ebp], 0
  0009e	75 04		 jne	 SHORT $LN127@GetSystemL
  000a0	33 c9		 xor	 ecx, ecx
  000a2	eb 15		 jmp	 SHORT $LN128@GetSystemL
$LN127@GetSystemL:
  000a4	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pathBuf$[ebp]
  000aa	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  000ad	0f 1f 00	 npad	 3
$LL449@GetSystemL:
  000b0	8a 01		 mov	 al, BYTE PTR [ecx]
  000b2	41		 inc	 ecx
  000b3	84 c0		 test	 al, al
  000b5	75 f9		 jne	 SHORT $LL449@GetSystemL
  000b7	2b ca		 sub	 ecx, edx
$LN128@GetSystemL:
  000b9	51		 push	 ecx
  000ba	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pathBuf$[ebp]
  000c0	50		 push	 eax
  000c1	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  000c7	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CANDMBMO@?2GostCrypt?$AA@
  000d1	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  000d7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000de	50		 push	 eax
  000df	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ee	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR $T5[ebp+20]
  000f4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000f8	83 f8 10	 cmp	 eax, 16			; 00000010H
  000fb	72 13		 jb	 SHORT $LN135@GetSystemL
  000fd	40		 inc	 eax
  000fe	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00104	50		 push	 eax
  00105	ff b5 d4 fe ff
	ff		 push	 DWORD PTR $T5[ebp]
  0010b	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN135@GetSystemL:

; 1830 : 		CreateDirectory (path.c_str(), NULL);

  00110	83 bd d0 fe ff
	ff 10		 cmp	 DWORD PTR _path$[ebp+20], 16 ; 00000010H
  00117	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  0011d	6a 00		 push	 0
  0011f	0f 43 85 bc fe
	ff ff		 cmovae	 eax, DWORD PTR _path$[ebp]
  00126	50		 push	 eax
  00127	c7 85 e8 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH
  00131	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+16], 0
  0013b	c6 85 d4 fe ff
	ff 00		 mov	 BYTE PTR $T5[ebp], 0
  00142	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDirectoryA@8

; 1831 : 
; 1832 : 		return path + '\\' + GST_SYS_BOOT_LOADER_BACKUP_NAME;

  00148	6a 5c		 push	 92			; 0000005cH
  0014a	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00150	50		 push	 eax
  00151	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0015d	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@KENEBBHH@Original?5System?5Loader?$AA@
  00162	50		 push	 eax
  00163	56		 push	 esi
  00164	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00168	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0016d	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR $T4[ebp+20]
  00173	83 c4 18	 add	 esp, 24			; 00000018H
  00176	83 f8 10	 cmp	 eax, 16			; 00000010H
  00179	72 13		 jb	 SHORT $LN253@GetSystemL
  0017b	40		 inc	 eax
  0017c	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00182	50		 push	 eax
  00183	ff b5 a4 fe ff
	ff		 push	 DWORD PTR $T4[ebp]
  00189	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN253@GetSystemL:
  0018e	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _path$[ebp+20]
  00194	c7 85 b8 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH
  0019e	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+16], 0
  001a8	c6 85 a4 fe ff
	ff 00		 mov	 BYTE PTR $T4[ebp], 0
  001af	83 f9 10	 cmp	 ecx, 16			; 00000010H
  001b2	72 13		 jb	 SHORT $LN354@GetSystemL
  001b4	41		 inc	 ecx
  001b5	51		 push	 ecx
  001b6	ff b5 bc fe ff
	ff		 push	 DWORD PTR _path$[ebp]
  001bc	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  001c2	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN354@GetSystemL:
  001c7	8b c6		 mov	 eax, esi

; 1833 : 	}

  001c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d3	59		 pop	 ecx
  001d4	5e		 pop	 esi
  001d5	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d8	33 cd		 xor	 ecx, ebp
  001da	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001df	8b e5		 mov	 esp, ebp
  001e1	5d		 pop	 ebp
  001e2	c2 04 00	 ret	 4
$LN451@GetSystemL:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0:
  00000	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1:
  0000b	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$2:
  00016	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 8a 9c fe ff
	ff		 mov	 ecx, DWORD PTR [edx-356]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
  00044	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; GostCrypt::BootEncryption::GetSystemLoaderBackupPath
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z
_TEXT	SEGMENT
_this$1$ = -20						; size = 4
_cryptoInfo$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
$T2 = 8							; size = 8
$T3 = 8							; size = 8
_volumeSize$ = 8					; size = 8
$T4 = 16						; size = 8
_encryptedAreaStart$ = 16				; size = 8
_password$ = 24						; size = 4
_ea$ = 28						; size = 4
_mode$ = 32						; size = 4
_finally2077$ = 36					; size = 4
_pkcs5$ = 36						; size = 4
?CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z PROC ; GostCrypt::BootEncryption::CreateVolumeHeader, COMDAT
; _this$ = ecx

; 2068 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx
  0002a	89 5d ec	 mov	 DWORD PTR _this$1$[ebp], ebx

; 2069 : 		PCRYPTO_INFO cryptoInfo = NULL;

  0002d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _cryptoInfo$[ebp], 0

; 2070 : 
; 2071 : 		if (!IsRandomNumberGeneratorStarted())

  00034	e8 00 00 00 00	 call	 _IsRandomNumberGeneratorStarted
  00039	85 c0		 test	 eax, eax
  0003b	75 1c		 jne	 SHORT $LN4@CreateVolu

; 2072 : 			throw ParameterIncorrect (SRC_POS);

  0003d	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00042	8d 45 08	 lea	 eax, DWORD PTR $T3[ebp]
  00045	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0004c	50		 push	 eax
  0004d	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], OFFSET ??_C@_0DD@EBKOHCHJ@GostCrypt?3?3BootEncryption?3?3Creat@
  00054	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN29@CreateVolu:
$LN4@CreateVolu:

; 2073 : 
; 2074 : 		throw_sys_if (CreateVolumeHeaderInMemory (TRUE, (char *) VolumeHeader, ea, mode, password, pkcs5, NULL, &cryptoInfo,

  00059	6a 00		 push	 0
  0005b	68 00 02 00 00	 push	 512			; 00000200H
  00060	6a 01		 push	 1
  00062	68 00 13 00 00	 push	 4864			; 00001300H
  00067	6a 00		 push	 0
  00069	6a 00		 push	 0
  0006b	ff 75 14	 push	 DWORD PTR _encryptedAreaStart$[ebp+4]
  0006e	8d 45 f0	 lea	 eax, DWORD PTR _cryptoInfo$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _encryptedAreaStart$[ebp]
  00074	8d b3 c4 03 00
	00		 lea	 esi, DWORD PTR [ebx+964]
  0007a	6a 00		 push	 0
  0007c	6a 00		 push	 0
  0007e	ff 75 0c	 push	 DWORD PTR _volumeSize$[ebp+4]
  00081	ff 75 08	 push	 DWORD PTR _volumeSize$[ebp]
  00084	50		 push	 eax
  00085	6a 00		 push	 0
  00087	ff 75 24	 push	 DWORD PTR _pkcs5$[ebp]
  0008a	ff 75 18	 push	 DWORD PTR _password$[ebp]
  0008d	ff 75 20	 push	 DWORD PTR _mode$[ebp]
  00090	ff 75 1c	 push	 DWORD PTR _ea$[ebp]
  00093	56		 push	 esi
  00094	6a 01		 push	 1
  00096	e8 00 00 00 00	 call	 _CreateVolumeHeaderInMemory
  0009b	83 c4 50	 add	 esp, 80			; 00000050H
  0009e	85 c0		 test	 eax, eax
  000a0	74 1e		 je	 SHORT $LN2@CreateVolu
  000a2	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000af	89 45 0c	 mov	 DWORD PTR $T2[ebp+4], eax
  000b2	8d 45 08	 lea	 eax, DWORD PTR $T2[ebp]
  000b5	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN30@CreateVolu:
$LN2@CreateVolu:

; 2075 : 			volumeSize, 0, encryptedAreaStart, 0, GST_SYSENC_KEYSCOPE_MIN_REQ_PROG_VERSION, GST_HEADER_FLAG_ENCRYPTED_SYSTEM, GST_SECTOR_SIZE_BIOS, FALSE) != 0);
; 2076 : 
; 2077 : 		finally_do_arg (PCRYPTO_INFO*, &cryptoInfo, { crypto_close (*finally_arg); });

  000c0	8d 45 f0	 lea	 eax, DWORD PTR _cryptoInfo$[ebp]
  000c3	89 45 24	 mov	 DWORD PTR _finally2077$[ebp], eax

; 2078 : 
; 2079 : 		// Initial rescue disk assumes encryption of the drive has been completed (EncryptedAreaLength == volumeSize)
; 2080 : 		memcpy (RescueVolumeHeader, VolumeHeader, sizeof (RescueVolumeHeader));
; 2081 : 		ReadVolumeHeader (TRUE, (char *) RescueVolumeHeader, password, NULL, cryptoInfo);

  000c6	ff 75 f0	 push	 DWORD PTR _cryptoInfo$[ebp]
  000c9	81 c3 c4 01 00
	00		 add	 ebx, 452		; 000001c4H
  000cf	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000d6	6a 00		 push	 0
  000d8	ff 75 18	 push	 DWORD PTR _password$[ebp]
  000db	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  000e0	8b fb		 mov	 edi, ebx
  000e2	53		 push	 ebx
  000e3	f3 a5		 rep movsd
  000e5	6a 01		 push	 1
  000e7	e8 00 00 00 00	 call	 _ReadVolumeHeader

; 2082 : 
; 2083 : 		DecryptBuffer (RescueVolumeHeader + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);

  000ec	ff 75 f0	 push	 DWORD PTR _cryptoInfo$[ebp]
  000ef	8b 75 ec	 mov	 esi, DWORD PTR _this$1$[ebp]
  000f2	6a 00		 push	 0
  000f4	68 c0 01 00 00	 push	 448			; 000001c0H
  000f9	8d 86 04 02 00
	00		 lea	 eax, DWORD PTR [esi+516]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _DecryptBuffer

; 2084 : 
; 2085 : 		if (GetHeaderField32 (RescueVolumeHeader, GST_HEADER_OFFSET_MAGIC) != 0x54525545)

  00105	6a 40		 push	 64			; 00000040H
  00107	53		 push	 ebx
  00108	e8 00 00 00 00	 call	 _GetHeaderField32
  0010d	83 c4 2c	 add	 esp, 44			; 0000002cH
  00110	3d 45 55 52 54	 cmp	 eax, 1414681925		; 54525545H
  00115	74 1c		 je	 SHORT $LN7@CreateVolu

; 2086 : 			throw ParameterIncorrect (SRC_POS);

  00117	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  0011c	8d 45 10	 lea	 eax, DWORD PTR $T4[ebp]
  0011f	c7 45 10 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00126	50		 push	 eax
  00127	c7 45 14 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+4], OFFSET ??_C@_0DD@COJOPAEA@GostCrypt?3?3BootEncryption?3?3Creat@
  0012e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN31@CreateVolu:
$LN7@CreateVolu:

; 2087 : 
; 2088 : 		byte *fieldPos = RescueVolumeHeader + GST_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH;
; 2089 : 		mputInt64 (fieldPos, volumeSize);

  00133	8b 5d 0c	 mov	 ebx, DWORD PTR _volumeSize$[ebp+4]
  00136	8d 96 38 02 00
	00		 lea	 edx, DWORD PTR [esi+568]
  0013c	8b 4d 08	 mov	 ecx, DWORD PTR _volumeSize$[ebp]

; 2090 : 
; 2091 : 		// CRC of the header fields
; 2092 : 		uint32 crc = GetCrc32 (RescueVolumeHeader + GST_HEADER_OFFSET_MAGIC, GST_HEADER_OFFSET_HEADER_CRC - GST_HEADER_OFFSET_MAGIC);

  0013f	8d be 04 02 00
	00		 lea	 edi, DWORD PTR [esi+516]
  00145	8b c3		 mov	 eax, ebx
  00147	c1 e8 18	 shr	 eax, 24			; 00000018H
  0014a	88 02		 mov	 BYTE PTR [edx], al
  0014c	8b c3		 mov	 eax, ebx
  0014e	c1 e8 10	 shr	 eax, 16			; 00000010H
  00151	88 42 01	 mov	 BYTE PTR [edx+1], al
  00154	8b c3		 mov	 eax, ebx
  00156	c1 e8 08	 shr	 eax, 8
  00159	88 42 02	 mov	 BYTE PTR [edx+2], al
  0015c	8b c3		 mov	 eax, ebx
  0015e	0f ac c1 18	 shrd	 ecx, eax, 24
  00162	88 5a 03	 mov	 BYTE PTR [edx+3], bl
  00165	c1 e8 18	 shr	 eax, 24			; 00000018H
  00168	88 4a 04	 mov	 BYTE PTR [edx+4], cl
  0016b	8b c3		 mov	 eax, ebx
  0016d	8b 4d 08	 mov	 ecx, DWORD PTR _volumeSize$[ebp]
  00170	0f ac c1 10	 shrd	 ecx, eax, 16
  00174	68 bc 00 00 00	 push	 188			; 000000bcH
  00179	88 4a 05	 mov	 BYTE PTR [edx+5], cl
  0017c	8b 4d 08	 mov	 ecx, DWORD PTR _volumeSize$[ebp]
  0017f	c1 e8 10	 shr	 eax, 16			; 00000010H
  00182	8b c1		 mov	 eax, ecx
  00184	0f ac d8 08	 shrd	 eax, ebx, 8
  00188	57		 push	 edi
  00189	88 42 06	 mov	 BYTE PTR [edx+6], al
  0018c	c1 eb 08	 shr	 ebx, 8
  0018f	88 4a 07	 mov	 BYTE PTR [edx+7], cl
  00192	e8 00 00 00 00	 call	 _GetCrc32

; 2093 : 		fieldPos = RescueVolumeHeader + GST_HEADER_OFFSET_HEADER_CRC;
; 2094 : 		mputLong (fieldPos, crc);
; 2095 : 
; 2096 : 		EncryptBuffer (RescueVolumeHeader + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, cryptoInfo);

  00197	ff 75 f0	 push	 DWORD PTR _cryptoInfo$[ebp]
  0019a	8b d8		 mov	 ebx, eax
  0019c	c1 e8 08	 shr	 eax, 8
  0019f	8b cb		 mov	 ecx, ebx
  001a1	c1 e9 18	 shr	 ecx, 24			; 00000018H
  001a4	88 8e c0 02 00
	00		 mov	 BYTE PTR [esi+704], cl
  001aa	8b cb		 mov	 ecx, ebx
  001ac	6a 00		 push	 0
  001ae	c1 e9 10	 shr	 ecx, 16			; 00000010H
  001b1	88 8e c1 02 00
	00		 mov	 BYTE PTR [esi+705], cl
  001b7	68 c0 01 00 00	 push	 448			; 000001c0H
  001bc	88 86 c2 02 00
	00		 mov	 BYTE PTR [esi+706], al
  001c2	57		 push	 edi
  001c3	88 9e c3 02 00
	00		 mov	 BYTE PTR [esi+707], bl
  001c9	e8 00 00 00 00	 call	 _EncryptBuffer
  001ce	83 c4 18	 add	 esp, 24			; 00000018H

; 2097 : 
; 2098 : 		VolumeHeaderValid = true;
; 2099 : 		RescueVolumeHeaderValid = true;

  001d1	66 c7 86 c6 05
	00 00 01 01	 mov	 WORD PTR [esi+1478], 257 ; 00000101H

; 2100 : 	}

  001da	8d 4d 24	 lea	 ecx, DWORD PTR _finally2077$[ebp]
  001dd	e8 00 00 00 00	 call	 ??1Finally2077@?1??CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z@QAE@XZ ; `GostCrypt::BootEncryption::CreateVolumeHeader'::`2'::Finally2077::~Finally2077
  001e2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001e5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001ec	59		 pop	 ecx
  001ed	5f		 pop	 edi
  001ee	5e		 pop	 esi
  001ef	5b		 pop	 ebx
  001f0	8b e5		 mov	 esp, ebp
  001f2	5d		 pop	 ebp
  001f3	c2 20 00	 ret	 32			; 00000020H
$LN28@CreateVolu:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z$0:
  00000	8d 4d 24	 lea	 ecx, DWORD PTR _finally2077$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Finally2077@?1??CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z@QAE@XZ ; `GostCrypt::BootEncryption::CreateVolumeHeader'::`2'::Finally2077::~Finally2077
__ehhandler$?CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z ENDP ; GostCrypt::BootEncryption::CreateVolumeHeader
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z
_TEXT	SEGMENT
$T2 = -1092						; size = 8
$T3 = -1084						; size = 8
$T4 = -1076						; size = 8
$T5 = -1068						; size = 8
$T6 = -1060						; size = 8
$T7 = -1052						; size = 8
_bootLoaderId$1$ = -1044				; size = 4
_buffer$GSCopy$ = -1044					; size = 4
_this$GSCopy$ = -1040					; size = 4
_size$ = -1036						; size = 4
_properties$8 = -1032					; size = 596
_headerSector$9 = -948					; size = 512
$T10 = -436						; size = 320
_request$11 = -372					; size = 256
$T12 = -116						; size = 94
_device$13 = -72					; size = 48
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_buffer$ = 8						; size = 4
_bufferSize$ = 12					; size = 4
_rescueDisk$ = 16					; size = 1
_hiddenOSCreation$ = 20					; size = 1
?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z PROC ; GostCrypt::BootEncryption::CreateBootLoaderInMemory, COMDAT
; _this$ = ecx

; 1353 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 38 04 00
	00		 sub	 esp, 1080		; 00000438H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b d9		 mov	 ebx, ecx

; 1354 : 		if (bufferSize < GST_BOOT_LOADER_AREA_SIZE - GST_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE)

  00033	8b 45 0c	 mov	 eax, DWORD PTR _bufferSize$[ebp]
  00036	8b 7d 08	 mov	 edi, DWORD PTR _buffer$[ebp]
  00039	89 9d f0 fb ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ebx
  0003f	89 bd ec fb ff
	ff		 mov	 DWORD PTR _buffer$GSCopy$[ebp], edi
  00045	3d 00 7c 00 00	 cmp	 eax, 31744		; 00007c00H
  0004a	73 25		 jae	 SHORT $LN2@CreateBoot

; 1355 : 			throw ParameterIncorrect (SRC_POS);

  0004c	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00051	8d 85 e4 fb ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00057	c7 85 e4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00061	50		 push	 eax
  00062	c7 85 e8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+4], OFFSET ??_C@_0DJ@BHABFNLC@GostCrypt?3?3BootEncryption?3?3Creat@
  0006c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN196@CreateBoot:
$LN2@CreateBoot:

; 1356 : 
; 1357 : 		ZeroMemory (buffer, bufferSize);

  00071	50		 push	 eax
  00072	6a 00		 push	 0
  00074	57		 push	 edi
  00075	e8 00 00 00 00	 call	 _memset
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1358 : 
; 1359 : 		int ea = 0;
; 1360 : 		if (GetStatus().DriveMounted)

  0007d	8d 45 8c	 lea	 eax, DWORD PTR $T12[ebp]
  00080	8b cb		 mov	 ecx, ebx
  00082	6a 5e		 push	 94			; 0000005eH
  00084	50		 push	 eax
  00085	6a 00		 push	 0
  00087	6a 00		 push	 0
  00089	68 48 20 22 00	 push	 2236488			; 00222048H
  0008e	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver
  00093	83 7d 92 00	 cmp	 DWORD PTR $T12[ebp+6], 0
  00097	0f 84 45 01 00
	00		 je	 $LN3@CreateBoot

; 1361 : 		{
; 1362 : 			try
; 1363 : 			{
; 1364 : 				GetBootEncryptionAlgorithmNameRequest request;
; 1365 : 				CallDriver (GST_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME, NULL, 0, &request, sizeof (request));

  0009d	68 00 01 00 00	 push	 256			; 00000100H
  000a2	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR _request$11[ebp]
  000a8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000af	50		 push	 eax
  000b0	6a 00		 push	 0
  000b2	6a 00		 push	 0
  000b4	68 60 20 22 00	 push	 2236512			; 00222060H
  000b9	8b cb		 mov	 ecx, ebx
  000bb	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver
  000c0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN7@CreateBoot:

; 1382 : 
; 1383 : 			ea = SelectedEncryptionAlgorithmId;
; 1384 : 		}
; 1385 : 
; 1386 : 		int bootSectorId = rescueDisk ? IDR_RESCUE_BOOT_SECTOR : IDR_BOOT_SECTOR;

  000c7	8a 55 10	 mov	 dl, BYTE PTR _rescueDisk$[ebp]
  000ca	b9 11 02 00 00	 mov	 ecx, 529		; 00000211H
  000cf	84 d2		 test	 dl, dl
  000d1	b8 08 02 00 00	 mov	 eax, 520		; 00000208H
  000d6	0f 45 c1	 cmovne	 eax, ecx

; 1387 : 		int bootLoaderId = rescueDisk ? IDR_RESCUE_LOADER : IDR_BOOT_LOADER;

  000d9	33 c9		 xor	 ecx, ecx
  000db	84 d2		 test	 dl, dl
  000dd	0f 95 c1	 setne	 cl
  000e0	8d 0c cd 0d 02
	00 00		 lea	 ecx, DWORD PTR [ecx*8+525]
  000e7	89 8d ec fb ff
	ff		 mov	 DWORD PTR _bootLoaderId$1$[ebp], ecx

; 1388 : 
; 1389 : 		// Boot sector
; 1390 : 		DWORD size;
; 1391 : 		byte *bootSecResourceImg = MapResource ("BIN", bootSectorId, &size);

  000ed	8d 8d f4 fb ff
	ff		 lea	 ecx, DWORD PTR _size$[ebp]
  000f3	51		 push	 ecx
  000f4	50		 push	 eax
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_03POBHGEJB@BIN?$AA@
  000fa	e8 00 00 00 00	 call	 _MapResource
  000ff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1392 : 		if (!bootSecResourceImg || size != GST_SECTOR_SIZE_BIOS)

  00102	85 c0		 test	 eax, eax
  00104	0f 84 ed 02 00
	00		 je	 $LN9@CreateBoot
  0010a	81 bd f4 fb ff
	ff 00 02 00 00	 cmp	 DWORD PTR _size$[ebp], 512 ; 00000200H
  00114	0f 85 dd 02 00
	00		 jne	 $LN9@CreateBoot

; 1394 : 
; 1395 : 		memcpy (buffer, bootSecResourceImg, size);

  0011a	68 00 02 00 00	 push	 512			; 00000200H
  0011f	50		 push	 eax
  00120	57		 push	 edi
  00121	e8 00 00 00 00	 call	 _memcpy

; 1396 : 
; 1397 : 		*(uint16 *) (buffer + GST_BOOT_SECTOR_VERSION_OFFSET) = BE16 (VERSION_NUM);

  00126	68 00 13 00 00	 push	 4864			; 00001300H
  0012b	e8 00 00 00 00	 call	 _MirrorBytes16

; 1398 : 
; 1399 : 		if (IsOSAtLeast (WIN_VISTA))

  00130	6a 0b		 push	 11			; 0000000bH
  00132	66 89 87 ae 01
	00 00		 mov	 WORD PTR [edi+430], ax
  00139	e8 00 00 00 00	 call	 _IsOSAtLeast
  0013e	83 c4 14	 add	 esp, 20			; 00000014H
  00141	85 c0		 test	 eax, eax
  00143	74 07		 je	 SHORT $LN10@CreateBoot

; 1400 : 			buffer[GST_BOOT_SECTOR_CONFIG_OFFSET] |= GST_BOOT_CFG_FLAG_WINDOWS_VISTA_OR_LATER;

  00145	80 8f b7 01 00
	00 04		 or	 BYTE PTR [edi+439], 4
$LN10@CreateBoot:

; 1401 : 
; 1402 : 		if (rescueDisk && (ReadDriverConfigurationFlags() & GST_DRIVER_CONFIG_DISABLE_HARDWARE_ENCRYPTION))

  0014c	80 7d 10 00	 cmp	 BYTE PTR _rescueDisk$[ebp], 0
  00150	74 12		 je	 SHORT $LN11@CreateBoot
  00152	8b cb		 mov	 ecx, ebx
  00154	e8 00 00 00 00	 call	 ?ReadDriverConfigurationFlags@BootEncryption@GostCrypt@@QAEIXZ ; GostCrypt::BootEncryption::ReadDriverConfigurationFlags
  00159	a8 08		 test	 al, 8
  0015b	74 07		 je	 SHORT $LN11@CreateBoot

; 1403 : 			buffer[GST_BOOT_SECTOR_CONFIG_OFFSET] |= GST_BOOT_CFG_FLAG_RESCUE_DISABLE_HW_ENCRYPTION;

  0015d	80 8f b7 01 00
	00 10		 or	 BYTE PTR [edi+439], 16	; 00000010H
$LN11@CreateBoot:

; 1404 : 
; 1405 : 		// Checksum of the backup header of the outer volume for the hidden system
; 1406 : 		if (hiddenOSCreation)

  00164	80 7d 14 00	 cmp	 BYTE PTR _hiddenOSCreation$[ebp], 0
  00168	0f 84 30 01 00
	00		 je	 $LN12@CreateBoot

; 1407 : 		{
; 1408 : 			Device device (GetSystemDriveConfiguration().DevicePath);

  0016e	6a 00		 push	 0
  00170	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  00176	8b cb		 mov	 ecx, ebx
  00178	50		 push	 eax
  00179	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  0017e	83 ec 18	 sub	 esp, 24			; 00000018H
  00181	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4
  00188	8b cc		 mov	 ecx, esp
  0018a	8d 50 18	 lea	 edx, DWORD PTR [eax+24]
  0018d	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00194	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0019b	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0019f	72 73		 jb	 SHORT $LN164@CreateBoot
  001a1	8b 01		 mov	 eax, DWORD PTR [ecx]
  001a3	eb 71		 jmp	 SHORT $LN165@CreateBoot
__catch$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z$0:

; 1366 : 			}
; 1367 : 			catch (...)
; 1368 : 			{
; 1369 : 				try
; 1370 : 				{
; 1371 : 					VOLUME_PROPERTIES_STRUCT properties;
; 1372 : 					GetVolumeProperties (&properties);

  001a5	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001ab	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _properties$8[ebp]
  001b1	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  001b4	50		 push	 eax
  001b5	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  001b9	e8 00 00 00 00	 call	 ?GetVolumeProperties@BootEncryption@GostCrypt@@QAEXPAUVOLUME_PROPERTIES_STRUCT@@@Z ; GostCrypt::BootEncryption::GetVolumeProperties
$LN29@CreateBoot:

; 1376 : 			}

  001be	b8 00 00 00 00	 mov	 eax, $LN31@CreateBoot
  001c3	c3		 ret	 0
__catch$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z$1:

; 1373 : 					ea = properties.ea;
; 1374 : 				}
; 1375 : 				catch (...) { }

  001c4	b8 00 00 00 00	 mov	 eax, $LN29@CreateBoot
  001c9	c3		 ret	 0
$LN31@CreateBoot:

; 1377 : 		}
; 1378 : 		else

  001ca	8b bd ec fb ff
	ff		 mov	 edi, DWORD PTR _buffer$GSCopy$[ebp]
  001d0	8b 9d f0 fb ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$[ebp]
  001d6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001dd	e9 e5 fe ff ff	 jmp	 $LN7@CreateBoot
$LN3@CreateBoot:

; 1379 : 		{
; 1380 : 			if (SelectedEncryptionAlgorithmId == 0)

  001e2	83 bb 48 01 00
	00 00		 cmp	 DWORD PTR [ebx+328], 0
  001e9	0f 85 d8 fe ff
	ff		 jne	 $LN7@CreateBoot

; 1381 : 				throw ParameterIncorrect (SRC_POS);

  001ef	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  001f4	8d 85 dc fb ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  001fa	c7 85 dc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00204	50		 push	 eax
  00205	c7 85 e0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+4], OFFSET ??_C@_0DJ@HLLFALOF@GostCrypt?3?3BootEncryption?3?3Creat@
  0020f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN197@CreateBoot:

; 1407 : 		{
; 1408 : 			Device device (GetSystemDriveConfiguration().DevicePath);

$LN164@CreateBoot:
  00214	8b c1		 mov	 eax, ecx
$LN165@CreateBoot:
  00216	52		 push	 edx
  00217	c6 00 00	 mov	 BYTE PTR [eax], 0
  0021a	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0021f	8d 4d b8	 lea	 ecx, DWORD PTR _device$13[ebp]
  00222	e8 00 00 00 00	 call	 ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device
  00227	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  0022d	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  00231	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 1409 : 			byte headerSector[GST_SECTOR_SIZE_BIOS];
; 1410 : 
; 1411 : 			device.SeekAt (HiddenOSCandidatePartition.Info.StartingOffset.QuadPart + HiddenOSCandidatePartition.Info.PartitionLength.QuadPart - GST_VOLUME_HEADER_GROUP_SIZE + GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  00236	8b 8b 70 01 00
	00		 mov	 ecx, DWORD PTR [ebx+368]
  0023c	03 8b 68 01 00
	00		 add	 ecx, DWORD PTR [ebx+360]
  00242	8b 83 74 01 00
	00		 mov	 eax, DWORD PTR [ebx+372]
  00248	13 83 6c 01 00
	00		 adc	 eax, DWORD PTR [ebx+364]
  0024e	81 e9 00 fe 01
	00		 sub	 ecx, 130560		; 0001fe00H
  00254	83 d8 00	 sbb	 eax, 0
  00257	50		 push	 eax
  00258	51		 push	 ecx
  00259	8d 4d b8	 lea	 ecx, DWORD PTR _device$13[ebp]
  0025c	e8 00 00 00 00	 call	 ?SeekAt@File@GostCrypt@@QAEX_J@Z ; GostCrypt::File::SeekAt

; 1412 : 			device.Read (headerSector, sizeof (headerSector));

  00261	68 00 02 00 00	 push	 512			; 00000200H
  00266	8d 85 4c fc ff
	ff		 lea	 eax, DWORD PTR _headerSector$9[ebp]
  0026c	50		 push	 eax
  0026d	8d 4d b8	 lea	 ecx, DWORD PTR _device$13[ebp]
  00270	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read

; 1413 : 
; 1414 : 			*(uint32 *) (buffer + GST_BOOT_SECTOR_OUTER_VOLUME_BAK_HEADER_CRC_OFFSET) = GetCrc32 (headerSector, sizeof (headerSector));

  00275	8d 85 4c fc ff
	ff		 lea	 eax, DWORD PTR _headerSector$9[ebp]
  0027b	68 00 02 00 00	 push	 512			; 00000200H
  00280	50		 push	 eax
  00281	e8 00 00 00 00	 call	 _GetCrc32
  00286	83 c4 08	 add	 esp, 8
  00289	89 87 92 01 00
	00		 mov	 DWORD PTR [edi+402], eax

; 1415 : 		}

  0028f	8d 4d b8	 lea	 ecx, DWORD PTR _device$13[ebp]
  00292	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00299	e8 00 00 00 00	 call	 ??1Device@GostCrypt@@QAE@XZ
$LN12@CreateBoot:

; 1416 : 
; 1417 : 		// Decompressor
; 1418 : 		byte *decompressor = MapResource ("BIN", IDR_BOOT_LOADER_DECOMPRESSOR, &size);

  0029e	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _size$[ebp]
  002a4	50		 push	 eax
  002a5	68 0c 02 00 00	 push	 524			; 0000020cH
  002aa	68 00 00 00 00	 push	 OFFSET ??_C@_03POBHGEJB@BIN?$AA@
  002af	e8 00 00 00 00	 call	 _MapResource
  002b4	8b d0		 mov	 edx, eax
  002b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1419 : 		if (!decompressor || size > GST_BOOT_LOADER_DECOMPRESSOR_SECTOR_COUNT * GST_SECTOR_SIZE_BIOS)

  002b9	85 d2		 test	 edx, edx
  002bb	0f 84 11 01 00
	00		 je	 $LN14@CreateBoot
  002c1	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _size$[ebp]
  002c7	81 f9 00 08 00
	00		 cmp	 ecx, 2048		; 00000800H
  002cd	0f 87 ff 00 00
	00		 ja	 $LN14@CreateBoot

; 1421 : 
; 1422 : 		memcpy (buffer + GST_SECTOR_SIZE_BIOS, decompressor, size);

  002d3	51		 push	 ecx
  002d4	8d 87 00 02 00
	00		 lea	 eax, DWORD PTR [edi+512]
  002da	52		 push	 edx
  002db	50		 push	 eax
  002dc	e8 00 00 00 00	 call	 _memcpy

; 1423 : 
; 1424 : 		// Compressed boot loader
; 1425 : 		byte *bootLoader = MapResource ("BIN", bootLoaderId, &size);

  002e1	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _size$[ebp]
  002e7	50		 push	 eax
  002e8	ff b5 ec fb ff
	ff		 push	 DWORD PTR _bootLoaderId$1$[ebp]
  002ee	68 00 00 00 00	 push	 OFFSET ??_C@_03POBHGEJB@BIN?$AA@
  002f3	e8 00 00 00 00	 call	 _MapResource
  002f8	83 c4 18	 add	 esp, 24			; 00000018H

; 1426 : 		if (!bootLoader)

  002fb	85 c0		 test	 eax, eax
  002fd	75 25		 jne	 SHORT $LN15@CreateBoot

; 1427 : 			throw ParameterIncorrect (SRC_POS);

  002ff	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00304	8d 85 d4 fb ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0030a	c7 85 d4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00314	50		 push	 eax
  00315	c7 85 d8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+4], OFFSET ??_C@_0DJ@LNKPBBAM@GostCrypt?3?3BootEncryption?3?3Creat@
  0031f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN198@CreateBoot:
$LN15@CreateBoot:

; 1428 : 
; 1429 : 		if (size > GST_MAX_BOOT_LOADER_SECTOR_COUNT * GST_SECTOR_SIZE_BIOS)

  00324	8b b5 f4 fb ff
	ff		 mov	 esi, DWORD PTR _size$[ebp]
  0032a	81 fe 00 72 00
	00		 cmp	 esi, 29184		; 00007200H
  00330	76 25		 jbe	 SHORT $LN16@CreateBoot

; 1430 : 			throw ParameterIncorrect (SRC_POS);

  00332	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00337	8d 85 cc fb ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  0033d	c7 85 cc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00347	50		 push	 eax
  00348	c7 85 d0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+4], OFFSET ??_C@_0DJ@PDCMONPM@GostCrypt?3?3BootEncryption?3?3Creat@
  00352	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN199@CreateBoot:
$LN16@CreateBoot:

; 1431 : 
; 1432 : 		memcpy (buffer + GST_SECTOR_SIZE_BIOS + GST_BOOT_LOADER_DECOMPRESSOR_SECTOR_COUNT * GST_SECTOR_SIZE_BIOS, bootLoader, size);

  00357	56		 push	 esi
  00358	50		 push	 eax
  00359	8d 87 00 0a 00
	00		 lea	 eax, DWORD PTR [edi+2560]
  0035f	50		 push	 eax
  00360	e8 00 00 00 00	 call	 _memcpy
  00365	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1433 : 
; 1434 : 		// Boot loader and decompressor checksum
; 1435 : 		*(uint16 *) (buffer + GST_BOOT_SECTOR_LOADER_LENGTH_OFFSET) = static_cast <uint16> (size);

  00368	66 89 b7 b0 01
	00 00		 mov	 WORD PTR [edi+432], si

; 1436 : 		*(uint32 *) (buffer + GST_BOOT_SECTOR_LOADER_CHECKSUM_OFFSET) = GetChecksum (buffer + GST_SECTOR_SIZE_BIOS,

  0036f	81 c6 00 08 00
	00		 add	 esi, 2048		; 00000800H
  00375	8d 87 00 02 00
	00		 lea	 eax, DWORD PTR [edi+512]
  0037b	8b cb		 mov	 ecx, ebx
  0037d	56		 push	 esi
  0037e	50		 push	 eax
  0037f	e8 00 00 00 00	 call	 ?GetChecksum@BootEncryption@GostCrypt@@IAEIPAEI@Z ; GostCrypt::BootEncryption::GetChecksum
  00384	89 87 b2 01 00
	00		 mov	 DWORD PTR [edi+434], eax

; 1437 : 			GST_BOOT_LOADER_DECOMPRESSOR_SECTOR_COUNT * GST_SECTOR_SIZE_BIOS + size);
; 1438 : 
; 1439 : 		// Backup of decompressor and boot loader
; 1440 : 		if (size + GST_BOOT_LOADER_DECOMPRESSOR_SECTOR_COUNT * GST_SECTOR_SIZE_BIOS <= GST_BOOT_LOADER_BACKUP_SECTOR_COUNT * GST_SECTOR_SIZE_BIOS)

  0038a	81 fe 00 3c 00
	00		 cmp	 esi, 15360		; 00003c00H
  00390	77 22		 ja	 SHORT $LN19@CreateBoot

; 1441 : 		{
; 1442 : 			memcpy (buffer + GST_SECTOR_SIZE_BIOS + GST_BOOT_LOADER_BACKUP_SECTOR_COUNT * GST_SECTOR_SIZE_BIOS,

  00392	68 00 3c 00 00	 push	 15360			; 00003c00H
  00397	8d 87 00 02 00
	00		 lea	 eax, DWORD PTR [edi+512]
  0039d	50		 push	 eax
  0039e	8d 87 00 3e 00
	00		 lea	 eax, DWORD PTR [edi+15872]
  003a4	50		 push	 eax
  003a5	e8 00 00 00 00	 call	 _memcpy
  003aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1443 : 				buffer + GST_SECTOR_SIZE_BIOS, GST_BOOT_LOADER_BACKUP_SECTOR_COUNT * GST_SECTOR_SIZE_BIOS);
; 1444 : 
; 1445 : 			buffer[GST_BOOT_SECTOR_CONFIG_OFFSET] |= GST_BOOT_CFG_FLAG_BACKUP_LOADER_AVAILABLE;

  003ad	80 8f b7 01 00
	00 02		 or	 BYTE PTR [edi+439], 2
$LN19@CreateBoot:

; 1446 : 		}
; 1447 : 		else if (!rescueDisk && bootLoaderId != IDR_BOOT_LOADER)
; 1448 : 		{
; 1449 : 			throw ParameterIncorrect (SRC_POS);
; 1450 : 		}
; 1451 : 	}

  003b4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  003b7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003be	59		 pop	 ecx
  003bf	5f		 pop	 edi
  003c0	5e		 pop	 esi
  003c1	5b		 pop	 ebx
  003c2	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c5	33 cd		 xor	 ecx, ebp
  003c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003cc	8b e5		 mov	 esp, ebp
  003ce	5d		 pop	 ebp
  003cf	c2 10 00	 ret	 16			; 00000010H
$LN14@CreateBoot:

; 1420 : 			throw ParameterIncorrect (SRC_POS);

  003d2	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  003d7	8d 85 c4 fb ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  003dd	c7 85 c4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  003e7	50		 push	 eax
  003e8	c7 85 c8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp+4], OFFSET ??_C@_0DJ@PCOOIHML@GostCrypt?3?3BootEncryption?3?3Creat@
  003f2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN200@CreateBoot:
$LN9@CreateBoot:

; 1393 : 			throw ParameterIncorrect (SRC_POS);

  003f7	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  003fc	8d 85 bc fb ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00402	c7 85 bc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0040c	50		 push	 eax
  0040d	c7 85 c0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_0DJ@EIEBADFA@GostCrypt?3?3BootEncryption?3?3Creat@
  00417	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN201@CreateBoot:
$LN195@CreateBoot:
  0041c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z$4:
  00000	8d 8d 4c fe ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z$6:
  0000b	8d 4d b8	 lea	 ecx, DWORD PTR _device$13[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1Device@GostCrypt@@QAE@XZ
__ehhandler$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 8a b8 fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1096]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z ENDP ; GostCrypt::BootEncryption::CreateBootLoaderInMemory
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ
_TEXT	SEGMENT
_pos$2 = -32696						; size = 8
$T3 = -32696						; size = 8
$T4 = -32692						; size = 4
$T5 = -32688						; size = 320
_backupFile$ = -32368					; size = 48
_device$ = -32320					; size = 48
_bootLoaderBuf$ = -32272				; size = 32256
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ PROC ; GostCrypt::BootEncryption::BackupSystemLoader, COMDAT
; _this$ = ecx

; 2164 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 ac 7f 00 00	 mov	 eax, 32684		; 00007facH
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	56		 push	 esi
  00026	50		 push	 eax
  00027	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	8b f1		 mov	 esi, ecx

; 2165 : 		Device device (GetSystemDriveConfiguration().DevicePath, true);

  00032	6a 01		 push	 1
  00034	8d 85 50 80 ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  00040	83 ec 18	 sub	 esp, 24			; 00000018H
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	8b cc		 mov	 ecx, esp
  0004c	8d 50 18	 lea	 edx, DWORD PTR [eax+24]
  0004f	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00056	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0005d	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00061	72 04		 jb	 SHORT $LN128@BackupSyst
  00063	8b 01		 mov	 eax, DWORD PTR [ecx]
  00065	eb 02		 jmp	 SHORT $LN129@BackupSyst
$LN128@BackupSyst:
  00067	8b c1		 mov	 eax, ecx
$LN129@BackupSyst:
  00069	52		 push	 edx
  0006a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0006d	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00072	8d 8d c0 81 ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00078	e8 00 00 00 00	 call	 ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device
  0007d	8d 8d 50 80 ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00083	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00087	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 2166 : 	
; 2167 : 		byte bootLoaderBuf[GST_BOOT_LOADER_AREA_SECTOR_COUNT * GST_SECTOR_SIZE_BIOS];
; 2168 : 
; 2169 : 		device.SeekAt (0);

  0008c	80 bd c0 81 ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  00093	0f 57 c0	 xorps	 xmm0, xmm0
  00096	66 0f 13 85 c8
	81 ff ff	 movlpd	 QWORD PTR _device$[ebp+8], xmm0
  0009e	75 4f		 jne	 SHORT $LN140@BackupSyst
  000a0	6a 00		 push	 0
  000a2	6a 00		 push	 0
  000a4	66 0f 13 85 48
	80 ff ff	 movlpd	 QWORD PTR _pos$2[ebp], xmm0
  000ac	ff b5 4c 80 ff
	ff		 push	 DWORD PTR _pos$2[ebp+4]
  000b2	ff b5 48 80 ff
	ff		 push	 DWORD PTR _pos$2[ebp]
  000b8	ff b5 d0 81 ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  000c4	85 c0		 test	 eax, eax
  000c6	75 27		 jne	 SHORT $LN140@BackupSyst
  000c8	c7 85 48 80 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000d8	89 85 4c 80 ff
	ff		 mov	 DWORD PTR $T3[ebp+4], eax
  000de	8d 85 48 80 ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000e4	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN530@BackupSyst:
$LN140@BackupSyst:

; 2170 : 		device.Read (bootLoaderBuf, sizeof (bootLoaderBuf));

  000ef	68 00 7e 00 00	 push	 32256			; 00007e00H
  000f4	8d 85 f0 81 ff
	ff		 lea	 eax, DWORD PTR _bootLoaderBuf$[ebp]
  000fa	50		 push	 eax
  000fb	8d 8d c0 81 ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00101	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read

; 2171 : 
; 2172 : 		// Prevent GostCrypt loader from being backed up
; 2173 : 		for (size_t i = 0; i < sizeof (bootLoaderBuf) - strlen (GST_APP_NAME); ++i)

  00106	33 c9		 xor	 ecx, ecx
  00108	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@BackupSyst:

; 2174 : 		{
; 2175 : 			if (memcmp (bootLoaderBuf + i, GST_APP_NAME, strlen (GST_APP_NAME)) == 0)

  00110	81 bc 0d f0 81
	ff ff 47 6f 73
	74		 cmp	 DWORD PTR _bootLoaderBuf$[ebp+ecx], 1953722183 ; 74736f47H
  0011b	75 1b		 jne	 SHORT $LN526@BackupSyst
  0011d	81 bc 0d f4 81
	ff ff 43 72 79
	70		 cmp	 DWORD PTR _bootLoaderBuf$[ebp+ecx+4], 1887007299 ; 70797243H
  00128	75 0e		 jne	 SHORT $LN526@BackupSyst
  0012a	80 bc 0d f8 81
	ff ff 74	 cmp	 BYTE PTR _bootLoaderBuf$[ebp+ecx+8], 116 ; 00000074H
  00132	0f 84 90 00 00
	00		 je	 $LN522@BackupSyst
$LN526@BackupSyst:

; 2171 : 
; 2172 : 		// Prevent GostCrypt loader from being backed up
; 2173 : 		for (size_t i = 0; i < sizeof (bootLoaderBuf) - strlen (GST_APP_NAME); ++i)

  00138	41		 inc	 ecx
  00139	81 f9 f7 7d 00
	00		 cmp	 ecx, 32247		; 00007df7H
  0013f	72 cf		 jb	 SHORT $LL4@BackupSyst

; 2180 : 			}
; 2181 : 		}
; 2182 : 
; 2183 : 		File backupFile (GetSystemLoaderBackupPath(), false, true);

  00141	6a 01		 push	 1
  00143	6a 00		 push	 0
  00145	83 ec 18	 sub	 esp, 24			; 00000018H
  00148	8b ce		 mov	 ecx, esi
  0014a	54		 push	 esp
  0014b	e8 00 00 00 00	 call	 ?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GostCrypt::BootEncryption::GetSystemLoaderBackupPath
  00150	8d 8d 90 81 ff
	ff		 lea	 ecx, DWORD PTR _backupFile$[ebp]
  00156	e8 00 00 00 00	 call	 ??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z ; GostCrypt::File::File

; 2184 : 		backupFile.Write (bootLoaderBuf, sizeof (bootLoaderBuf));

  0015b	68 00 7e 00 00	 push	 32256			; 00007e00H
  00160	8d 85 f0 81 ff
	ff		 lea	 eax, DWORD PTR _bootLoaderBuf$[ebp]
  00166	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0016a	50		 push	 eax
  0016b	8d 8d 90 81 ff
	ff		 lea	 ecx, DWORD PTR _backupFile$[ebp]
  00171	e8 00 00 00 00	 call	 ?Write@File@GostCrypt@@QAEXPAEK@Z ; GostCrypt::File::Write

; 2185 : 	}

  00176	80 bd 91 81 ff
	ff 00		 cmp	 BYTE PTR _backupFile$[ebp+1], 0
  0017d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  00183	74 18		 je	 SHORT $LN271@BackupSyst
  00185	80 bd 90 81 ff
	ff 00		 cmp	 BYTE PTR _backupFile$[ebp], 0
  0018c	75 08		 jne	 SHORT $LN272@BackupSyst
  0018e	ff b5 a0 81 ff
	ff		 push	 DWORD PTR _backupFile$[ebp+16]
  00194	ff d6		 call	 esi
$LN272@BackupSyst:
  00196	c6 85 91 81 ff
	ff 00		 mov	 BYTE PTR _backupFile$[ebp+1], 0
$LN271@BackupSyst:
  0019d	8b 85 bc 81 ff
	ff		 mov	 eax, DWORD PTR _backupFile$[ebp+44]
  001a3	83 f8 10	 cmp	 eax, 16			; 00000010H
  001a6	0f 82 c2 00 00
	00		 jb	 $LN360@BackupSyst
  001ac	8b 8d a8 81 ff
	ff		 mov	 ecx, DWORD PTR _backupFile$[ebp+24]
  001b2	40		 inc	 eax
  001b3	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  001b8	0f 82 a7 00 00
	00		 jb	 $LN355@BackupSyst
  001be	f6 c1 1f	 test	 cl, 31			; 0000001fH
  001c1	74 7e		 je	 SHORT $LN356@BackupSyst
  001c3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN531@BackupSyst:
$LN522@BackupSyst:

; 2176 : 			{
; 2177 : 				if (AskWarnNoYes ("GST_BOOT_LOADER_ALREADY_INSTALLED") == IDNO)

  001c8	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HLAJAJLP@GST_BOOT_LOADER_ALREADY_INSTALLE@
  001cd	e8 00 00 00 00	 call	 _AskWarnNoYes
  001d2	83 c4 04	 add	 esp, 4
  001d5	83 f8 07	 cmp	 eax, 7
  001d8	75 1b		 jne	 SHORT $LN6@BackupSyst

; 2178 : 					throw UserAbort (SRC_POS);

  001da	68 00 00 00 00	 push	 OFFSET __TI2?AUUserAbort@GostCrypt@@
  001df	8d 85 4c 80 ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001e5	c7 85 4c 80 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], OFFSET ??_7UserAbort@GostCrypt@@6B@
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN532@BackupSyst:
$LN6@BackupSyst:

; 2179 : 				return;

  001f5	80 bd c1 81 ff
	ff 00		 cmp	 BYTE PTR _device$[ebp+1], 0
  001fc	74 1c		 je	 SHORT $LN163@BackupSyst
  001fe	80 bd c0 81 ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  00205	75 0c		 jne	 SHORT $LN164@BackupSyst
  00207	ff b5 d0 81 ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  0020d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN164@BackupSyst:
  00213	c6 85 c1 81 ff
	ff 00		 mov	 BYTE PTR _device$[ebp+1], 0
$LN163@BackupSyst:
  0021a	8b 85 ec 81 ff
	ff		 mov	 eax, DWORD PTR _device$[ebp+44]
  00220	83 f8 10	 cmp	 eax, 16			; 00000010H
  00223	0f 82 d1 00 00
	00		 jb	 $LN488@BackupSyst
  00229	40		 inc	 eax
  0022a	8d 8d d8 81 ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp+24]
  00230	50		 push	 eax
  00231	ff b5 d8 81 ff
	ff		 push	 DWORD PTR _device$[ebp+24]
  00237	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  0023c	e9 b9 00 00 00	 jmp	 $LN488@BackupSyst

; 2185 : 	}

$LN356@BackupSyst:
  00241	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00244	3b c1		 cmp	 eax, ecx
  00246	72 05		 jb	 SHORT $LN357@BackupSyst
  00248	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN533@BackupSyst:
$LN357@BackupSyst:
  0024d	2b c8		 sub	 ecx, eax
  0024f	83 f9 04	 cmp	 ecx, 4
  00252	73 05		 jae	 SHORT $LN358@BackupSyst
  00254	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN534@BackupSyst:
$LN358@BackupSyst:
  00259	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0025c	76 05		 jbe	 SHORT $LN359@BackupSyst
  0025e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN535@BackupSyst:
$LN359@BackupSyst:
  00263	8b c8		 mov	 ecx, eax
$LN355@BackupSyst:
  00265	51		 push	 ecx
  00266	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0026b	83 c4 04	 add	 esp, 4
$LN360@BackupSyst:
  0026e	80 bd c1 81 ff
	ff 00		 cmp	 BYTE PTR _device$[ebp+1], 0
  00275	c7 85 bc 81 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _backupFile$[ebp+44], 15 ; 0000000fH
  0027f	c7 85 b8 81 ff
	ff 00 00 00 00	 mov	 DWORD PTR _backupFile$[ebp+40], 0
  00289	c6 85 a8 81 ff
	ff 00		 mov	 BYTE PTR _backupFile$[ebp+24], 0
  00290	74 18		 je	 SHORT $LN399@BackupSyst
  00292	80 bd c0 81 ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  00299	75 08		 jne	 SHORT $LN400@BackupSyst
  0029b	ff b5 d0 81 ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  002a1	ff d6		 call	 esi
$LN400@BackupSyst:
  002a3	c6 85 c1 81 ff
	ff 00		 mov	 BYTE PTR _device$[ebp+1], 0
$LN399@BackupSyst:
  002aa	8b 85 ec 81 ff
	ff		 mov	 eax, DWORD PTR _device$[ebp+44]
  002b0	83 f8 10	 cmp	 eax, 16			; 00000010H
  002b3	72 45		 jb	 SHORT $LN488@BackupSyst
  002b5	8b 8d d8 81 ff
	ff		 mov	 ecx, DWORD PTR _device$[ebp+24]
  002bb	40		 inc	 eax
  002bc	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  002c1	72 2e		 jb	 SHORT $LN483@BackupSyst
  002c3	f6 c1 1f	 test	 cl, 31			; 0000001fH
  002c6	74 05		 je	 SHORT $LN484@BackupSyst
  002c8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN536@BackupSyst:
$LN484@BackupSyst:
  002cd	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  002d0	3b c1		 cmp	 eax, ecx
  002d2	72 05		 jb	 SHORT $LN485@BackupSyst
  002d4	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN537@BackupSyst:
$LN485@BackupSyst:
  002d9	2b c8		 sub	 ecx, eax
  002db	83 f9 04	 cmp	 ecx, 4
  002de	73 05		 jae	 SHORT $LN486@BackupSyst
  002e0	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN538@BackupSyst:
$LN486@BackupSyst:
  002e5	83 f9 23	 cmp	 ecx, 35			; 00000023H
  002e8	76 05		 jbe	 SHORT $LN487@BackupSyst
  002ea	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN539@BackupSyst:
$LN487@BackupSyst:
  002ef	8b c8		 mov	 ecx, eax
$LN483@BackupSyst:
  002f1	51		 push	 ecx
  002f2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002f7	83 c4 04	 add	 esp, 4
$LN488@BackupSyst:
  002fa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00304	59		 pop	 ecx
  00305	5e		 pop	 esi
  00306	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00309	33 cd		 xor	 ecx, ebp
  0030b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00310	8b e5		 mov	 esp, ebp
  00312	5d		 pop	 ebp
  00313	c3		 ret	 0
$LN529@BackupSyst:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ$0:
  00000	8d 8d 50 80 ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ$2:
  0000b	8d 8d c0 81 ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1Device@GostCrypt@@QAE@XZ
__unwindfunclet$?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ$4:
  00016	8d 8d 90 81 ff
	ff		 lea	 ecx, DWORD PTR _backupFile$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1File@GostCrypt@@QAE@XZ ; GostCrypt::File::~File
__ehhandler$?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 8a 4c 80 ff
	ff		 mov	 ecx, DWORD PTR [edx-32692]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ
  00044	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ ENDP ; GostCrypt::BootEncryption::BackupSystemLoader
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?WriteLocalMachineRegistryDwordValue@BootEncryption@GostCrypt@@QAEXPAD0K@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_keyPath$ = 8						; size = 4
_valueName$ = 12					; size = 4
_value$ = 16						; size = 4
?WriteLocalMachineRegistryDwordValue@BootEncryption@GostCrypt@@QAEXPAD0K@Z PROC ; GostCrypt::BootEncryption::WriteLocalMachineRegistryDwordValue, COMDAT
; _this$ = ecx

; 2998 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2999 : 		if (!IsAdmin() && IsUacSupported())

  00006	e8 00 00 00 00	 call	 _IsAdmin
  0000b	85 c0		 test	 eax, eax
  0000d	75 20		 jne	 SHORT $LN4@WriteLocal
  0000f	e8 00 00 00 00	 call	 _IsUacSupported
  00014	85 c0		 test	 eax, eax
  00016	74 17		 je	 SHORT $LN4@WriteLocal

; 3000 : 		{
; 3001 : 			Elevator::WriteLocalMachineRegistryDwordValue (keyPath, valueName, value);

  00018	ff 75 10	 push	 DWORD PTR _value$[ebp]
  0001b	ff 75 0c	 push	 DWORD PTR _valueName$[ebp]
  0001e	ff 75 08	 push	 DWORD PTR _keyPath$[ebp]
  00021	e8 00 00 00 00	 call	 ?WriteLocalMachineRegistryDwordValue@Elevator@GostCrypt@@SAXPAD0K@Z ; GostCrypt::Elevator::WriteLocalMachineRegistryDwordValue
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@WriteLocal:

; 3006 : 	}

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 0c 00	 ret	 12			; 0000000cH
$LN4@WriteLocal:

; 3002 : 			return;
; 3003 : 		}
; 3004 : 
; 3005 : 		throw_sys_if (!WriteLocalMachineRegistryDword (keyPath, valueName, value));

  0002f	ff 75 10	 push	 DWORD PTR _value$[ebp]
  00032	ff 75 0c	 push	 DWORD PTR _valueName$[ebp]
  00035	ff 75 08	 push	 DWORD PTR _keyPath$[ebp]
  00038	e8 00 00 00 00	 call	 _WriteLocalMachineRegistryDword
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	85 c0		 test	 eax, eax
  00042	75 e5		 jne	 SHORT $LN3@WriteLocal
  00044	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00051	89 45 fc	 mov	 DWORD PTR $T1[ebp+4], eax
  00054	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN16@WriteLocal:
$LN13@WriteLocal:
  00062	cc		 int	 3
?WriteLocalMachineRegistryDwordValue@BootEncryption@GostCrypt@@QAEXPAD0K@Z ENDP ; GostCrypt::BootEncryption::WriteLocalMachineRegistryDwordValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?WriteBootSectorUserConfig@BootEncryption@GostCrypt@@QAEXEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_pos$2 = -1448						; size = 8
$T3 = -1448						; size = 8
$T4 = -1448						; size = 8
$T5 = -1440						; size = 320
$T6 = -1120						; size = 32
_device$ = -1088					; size = 48
_mbrVerificationBuf$ = -1040				; size = 512
_mbr$ = -528						; size = 512
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_userConfig$ = 8					; size = 1
_customUserMessage$ = 12				; size = 4
?WriteBootSectorUserConfig@BootEncryption@GostCrypt@@QAEXEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; GostCrypt::BootEncryption::WriteBootSectorUserConfig, COMDAT
; _this$ = ecx

; 1549 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?WriteBootSectorUserConfig@BootEncryption@GostCrypt@@QAEXEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 9c 05 00
	00		 sub	 esp, 1436		; 0000059cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	8b 75 0c	 mov	 esi, DWORD PTR _customUserMessage$[ebp]

; 1550 : 		Device device (GetSystemDriveConfiguration().DevicePath);

  0002f	8d 85 60 fa ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00035	6a 00		 push	 0
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  0003d	83 ec 18	 sub	 esp, 24			; 00000018H
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	8b cc		 mov	 ecx, esp
  00049	8d 50 18	 lea	 edx, DWORD PTR [eax+24]
  0004c	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00053	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0005a	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0005e	72 04		 jb	 SHORT $LN126@WriteBootS
  00060	8b 01		 mov	 eax, DWORD PTR [ecx]
  00062	eb 02		 jmp	 SHORT $LN127@WriteBootS
$LN126@WriteBootS:
  00064	8b c1		 mov	 eax, ecx
$LN127@WriteBootS:
  00066	52		 push	 edx
  00067	c6 00 00	 mov	 BYTE PTR [eax], 0
  0006a	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0006f	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00075	e8 00 00 00 00	 call	 ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device
  0007a	8d 8d 60 fa ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00080	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00084	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 1551 : 		byte mbr[GST_SECTOR_SIZE_BIOS];
; 1552 : 
; 1553 : 		device.SeekAt (0);

  00089	80 bd c0 fb ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  00090	0f 57 c0	 xorps	 xmm0, xmm0
  00093	66 0f 13 85 c8
	fb ff ff	 movlpd	 QWORD PTR _device$[ebp+8], xmm0
  0009b	75 4f		 jne	 SHORT $LN138@WriteBootS
  0009d	6a 00		 push	 0
  0009f	6a 00		 push	 0
  000a1	66 0f 13 85 58
	fa ff ff	 movlpd	 QWORD PTR _pos$2[ebp], xmm0
  000a9	ff b5 5c fa ff
	ff		 push	 DWORD PTR _pos$2[ebp+4]
  000af	ff b5 58 fa ff
	ff		 push	 DWORD PTR _pos$2[ebp]
  000b5	ff b5 d0 fb ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  000c1	85 c0		 test	 eax, eax
  000c3	75 27		 jne	 SHORT $LN138@WriteBootS
  000c5	c7 85 58 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000d5	89 85 5c fa ff
	ff		 mov	 DWORD PTR $T3[ebp+4], eax
  000db	8d 85 58 fa ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000e1	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN437@WriteBootS:
$LN138@WriteBootS:

; 1554 : 		device.Read (mbr, sizeof (mbr));

  000ec	68 00 02 00 00	 push	 512			; 00000200H
  000f1	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _mbr$[ebp]
  000f7	50		 push	 eax
  000f8	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  000fe	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read

; 1555 : 
; 1556 : 		if (!BufferContainsString (mbr, sizeof (mbr), GST_APP_NAME)
; 1557 : 			|| BE16 (*(uint16 *) (mbr + GST_BOOT_SECTOR_VERSION_OFFSET)) != VERSION_NUM)

  00103	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  00108	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _mbr$[ebp]
  0010e	68 00 02 00 00	 push	 512			; 00000200H
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 _BufferContainsString
  00119	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011c	85 c0		 test	 eax, eax
  0011e	0f 84 32 01 00
	00		 je	 $LN3@WriteBootS
  00124	ff 75 9e	 push	 DWORD PTR _mbr$[ebp+430]
  00127	e8 00 00 00 00	 call	 _MirrorBytes16
  0012c	b9 00 13 00 00	 mov	 ecx, 4864		; 00001300H
  00131	83 c4 04	 add	 esp, 4
  00134	66 3b c1	 cmp	 ax, cx
  00137	0f 85 19 01 00
	00		 jne	 $LN3@WriteBootS

; 1560 : 		}
; 1561 : 
; 1562 : 		mbr[GST_BOOT_SECTOR_USER_CONFIG_OFFSET] = userConfig;

  0013d	8a 45 08	 mov	 al, BYTE PTR _userConfig$[ebp]
  00140	0f 57 c0	 xorps	 xmm0, xmm0
  00143	88 45 a6	 mov	 BYTE PTR _mbr$[ebp+438], al

; 1563 : 
; 1564 : 		memset (mbr + GST_BOOT_SECTOR_USER_MESSAGE_OFFSET, 0, GST_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);
; 1565 : 
; 1566 : 		if (!customUserMessage.empty())

  00146	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00149	66 0f d6 45 96	 movq	 QWORD PTR _mbr$[ebp+422], xmm0
  0014e	0f 11 45 86	 movups	 XMMWORD PTR _mbr$[ebp+406], xmm0
  00152	85 c0		 test	 eax, eax
  00154	74 40		 je	 SHORT $LN4@WriteBootS

; 1567 : 		{
; 1568 : 			if (customUserMessage.size() > GST_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH)

  00156	83 f8 18	 cmp	 eax, 24			; 00000018H
  00159	76 25		 jbe	 SHORT $LN5@WriteBootS

; 1569 : 				throw ParameterIncorrect (SRC_POS);

  0015b	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00160	8d 85 58 fa ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00166	c7 85 58 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00170	50		 push	 eax
  00171	c7 85 5c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+4], OFFSET ??_C@_0DK@IOCENGCH@GostCrypt?3?3BootEncryption?3?3Write@
  0017b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN438@WriteBootS:
$LN5@WriteBootS:

; 1570 : 
; 1571 : 			memcpy (mbr + GST_BOOT_SECTOR_USER_MESSAGE_OFFSET, customUserMessage.c_str(), customUserMessage.size());

  00180	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00184	72 02		 jb	 SHORT $LN315@WriteBootS
  00186	8b 36		 mov	 esi, DWORD PTR [esi]
$LN315@WriteBootS:
  00188	50		 push	 eax
  00189	8d 45 86	 lea	 eax, DWORD PTR _mbr$[ebp+406]
  0018c	56		 push	 esi
  0018d	50		 push	 eax
  0018e	e8 00 00 00 00	 call	 _memcpy
  00193	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@WriteBootS:

; 1572 : 		}
; 1573 : 
; 1574 : 		device.SeekAt (0);

  00196	6a 00		 push	 0
  00198	6a 00		 push	 0
  0019a	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  001a0	e8 00 00 00 00	 call	 ?SeekAt@File@GostCrypt@@QAEX_J@Z ; GostCrypt::File::SeekAt

; 1575 : 		device.Write (mbr, sizeof (mbr));

  001a5	68 00 02 00 00	 push	 512			; 00000200H
  001aa	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _mbr$[ebp]
  001b0	50		 push	 eax
  001b1	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  001b7	e8 00 00 00 00	 call	 ?Write@File@GostCrypt@@QAEXPAEK@Z ; GostCrypt::File::Write

; 1576 : 
; 1577 : 		byte mbrVerificationBuf[GST_SECTOR_SIZE_BIOS];
; 1578 : 		device.SeekAt (0);

  001bc	6a 00		 push	 0
  001be	6a 00		 push	 0
  001c0	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  001c6	e8 00 00 00 00	 call	 ?SeekAt@File@GostCrypt@@QAEX_J@Z ; GostCrypt::File::SeekAt

; 1579 : 		device.Read (mbrVerificationBuf, sizeof (mbr));

  001cb	68 00 02 00 00	 push	 512			; 00000200H
  001d0	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _mbrVerificationBuf$[ebp]
  001d6	50		 push	 eax
  001d7	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  001dd	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read

; 1580 : 
; 1581 : 		if (memcmp (mbr, mbrVerificationBuf, sizeof (mbr)) != 0)

  001e2	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _mbr$[ebp]
  001e8	be fc 01 00 00	 mov	 esi, 508		; 000001fcH
  001ed	8d 95 f0 fb ff
	ff		 lea	 edx, DWORD PTR _mbrVerificationBuf$[ebp]
$LL434@WriteBootS:
  001f3	8b 01		 mov	 eax, DWORD PTR [ecx]
  001f5	3b 02		 cmp	 eax, DWORD PTR [edx]
  001f7	75 1b		 jne	 SHORT $LN433@WriteBootS
  001f9	83 c1 04	 add	 ecx, 4
  001fc	83 c2 04	 add	 edx, 4
  001ff	83 ee 04	 sub	 esi, 4
  00202	73 ef		 jae	 SHORT $LL434@WriteBootS

; 1583 : 	}

  00204	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  0020a	e8 00 00 00 00	 call	 ??1Device@GostCrypt@@QAE@XZ
  0020f	e9 85 00 00 00	 jmp	 $LN165@WriteBootS
$LN433@WriteBootS:

; 1582 : 			throw ErrorException ("ERROR_MBR_PROTECTED");

  00214	33 c0		 xor	 eax, eax
  00216	c7 85 a0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], OFFSET ??_7ErrorException@GostCrypt@@6B@
  00220	66 89 85 a8 fb
	ff ff		 mov	 WORD PTR $T6[ebp+8], ax
  00227	8d 85 a0 fb ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0022d	68 00 00 00 00	 push	 OFFSET __TI2?AUErrorException@GostCrypt@@
  00232	50		 push	 eax
  00233	c7 85 a4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+4], OFFSET ??_C@_0BE@GPJOEGCF@ERROR_MBR_PROTECTED?$AA@
  0023d	c7 85 bc fb ff
	ff 07 00 00 00	 mov	 DWORD PTR $T6[ebp+28], 7
  00247	c7 85 b8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+24], 0
  00251	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN439@WriteBootS:
$LN3@WriteBootS:

; 1558 : 		{
; 1559 : 			return;

  00256	80 bd c1 fb ff
	ff 00		 cmp	 BYTE PTR _device$[ebp+1], 0
  0025d	74 1c		 je	 SHORT $LN156@WriteBootS
  0025f	80 bd c0 fb ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  00266	75 0c		 jne	 SHORT $LN157@WriteBootS
  00268	ff b5 d0 fb ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  0026e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN157@WriteBootS:
  00274	c6 85 c1 fb ff
	ff 00		 mov	 BYTE PTR _device$[ebp+1], 0
$LN156@WriteBootS:
  0027b	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _device$[ebp+44]
  00281	83 f8 10	 cmp	 eax, 16			; 00000010H
  00284	72 13		 jb	 SHORT $LN165@WriteBootS
  00286	40		 inc	 eax
  00287	8d 8d d8 fb ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp+24]
  0028d	50		 push	 eax
  0028e	ff b5 d8 fb ff
	ff		 push	 DWORD PTR _device$[ebp+24]
  00294	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN165@WriteBootS:

; 1583 : 	}

  00299	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0029c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002a3	59		 pop	 ecx
  002a4	5e		 pop	 esi
  002a5	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a8	33 cd		 xor	 ecx, ebp
  002aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002af	8b e5		 mov	 esp, ebp
  002b1	5d		 pop	 ebp
  002b2	c2 08 00	 ret	 8
$LN436@WriteBootS:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?WriteBootSectorUserConfig@BootEncryption@GostCrypt@@QAEXEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00000	8d 8d 60 fa ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?WriteBootSectorUserConfig@BootEncryption@GostCrypt@@QAEXEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
  0000b	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1Device@GostCrypt@@QAE@XZ
__ehhandler$?WriteBootSectorUserConfig@BootEncryption@GostCrypt@@QAEXEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a 5c fa ff
	ff		 mov	 ecx, DWORD PTR [edx-1444]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?WriteBootSectorUserConfig@BootEncryption@GostCrypt@@QAEXEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?WriteBootSectorUserConfig@BootEncryption@GostCrypt@@QAEXEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; GostCrypt::BootEncryption::WriteBootSectorUserConfig
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z
_TEXT	SEGMENT
_pos$2 = -1448						; size = 8
_pos$3 = -1448						; size = 8
_pos$4 = -1448						; size = 8
$T5 = -1448						; size = 8
$T6 = -1440						; size = 320
$T7 = -1120						; size = 32
_device$ = -1088					; size = 48
_mbrVerificationBuf$ = -1040				; size = 512
_mbr$ = -528						; size = 512
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_newConfig$ = 8						; size = 4
?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z PROC ; GostCrypt::BootEncryption::WriteBootSectorConfig, COMDAT
; _this$ = ecx

; 1518 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 9c 05 00
	00		 sub	 esp, 1436		; 0000059cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b 7d 08	 mov	 edi, DWORD PTR _newConfig$[ebp]

; 1519 : 		Device device (GetSystemDriveConfiguration().DevicePath);

  00030	8d 85 60 fa ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00036	6a 00		 push	 0
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  0003e	83 ec 18	 sub	 esp, 24			; 00000018H
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00048	8b cc		 mov	 ecx, esp
  0004a	8d 50 18	 lea	 edx, DWORD PTR [eax+24]
  0004d	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00054	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0005b	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0005f	72 04		 jb	 SHORT $LN122@WriteBootS
  00061	8b 01		 mov	 eax, DWORD PTR [ecx]
  00063	eb 02		 jmp	 SHORT $LN123@WriteBootS
$LN122@WriteBootS:
  00065	8b c1		 mov	 eax, ecx
$LN123@WriteBootS:
  00067	52		 push	 edx
  00068	c6 00 00	 mov	 BYTE PTR [eax], 0
  0006b	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00070	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00076	e8 00 00 00 00	 call	 ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device
  0007b	8d 8d 60 fa ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00081	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00085	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 1520 : 		byte mbr[GST_SECTOR_SIZE_BIOS];
; 1521 : 
; 1522 : 		device.SeekAt (0);

  0008a	80 bd c0 fb ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  00091	0f 57 c0	 xorps	 xmm0, xmm0
  00094	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__SetFilePointerEx@20
  0009a	66 0f 13 85 c8
	fb ff ff	 movlpd	 QWORD PTR _device$[ebp+8], xmm0
  000a2	75 4b		 jne	 SHORT $LN134@WriteBootS
  000a4	6a 00		 push	 0
  000a6	6a 00		 push	 0
  000a8	66 0f 13 85 58
	fa ff ff	 movlpd	 QWORD PTR _pos$4[ebp], xmm0
  000b0	ff b5 5c fa ff
	ff		 push	 DWORD PTR _pos$4[ebp+4]
  000b6	ff b5 58 fa ff
	ff		 push	 DWORD PTR _pos$4[ebp]
  000bc	ff b5 d0 fb ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  000c2	ff d6		 call	 esi
  000c4	85 c0		 test	 eax, eax
  000c6	75 27		 jne	 SHORT $LN134@WriteBootS
$LN288@WriteBootS:
  000c8	c7 85 58 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000d8	89 85 5c fa ff
	ff		 mov	 DWORD PTR $T5[ebp+4], eax
  000de	8d 85 58 fa ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  000e4	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
$LN289@WriteBootS:
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN290@WriteBootS:
$LN134@WriteBootS:

; 1523 : 		device.Read (mbr, sizeof (mbr));

  000ef	68 00 02 00 00	 push	 512			; 00000200H
  000f4	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _mbr$[ebp]
  000fa	50		 push	 eax
  000fb	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00101	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read

; 1524 : 
; 1525 : 		memcpy (mbr + GST_BOOT_SECTOR_CONFIG_OFFSET, newConfig, GST_BOOT_CFG_FLAG_AREA_SIZE);
; 1526 : 
; 1527 : 		device.SeekAt (0);

  00106	80 bd c0 fb ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  0010d	0f 57 c0	 xorps	 xmm0, xmm0
  00110	8a 07		 mov	 al, BYTE PTR [edi]
  00112	88 45 a7	 mov	 BYTE PTR _mbr$[ebp+439], al
  00115	66 0f 13 85 c8
	fb ff ff	 movlpd	 QWORD PTR _device$[ebp+8], xmm0
  0011d	75 24		 jne	 SHORT $LN147@WriteBootS
  0011f	6a 00		 push	 0
  00121	6a 00		 push	 0
  00123	66 0f 13 85 58
	fa ff ff	 movlpd	 QWORD PTR _pos$3[ebp], xmm0
  0012b	ff b5 5c fa ff
	ff		 push	 DWORD PTR _pos$3[ebp+4]
  00131	ff b5 58 fa ff
	ff		 push	 DWORD PTR _pos$3[ebp]
  00137	ff b5 d0 fb ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  0013d	ff d6		 call	 esi
  0013f	85 c0		 test	 eax, eax
  00141	74 85		 je	 SHORT $LN288@WriteBootS
$LN147@WriteBootS:

; 1528 : 		device.Write (mbr, sizeof (mbr));

  00143	68 00 02 00 00	 push	 512			; 00000200H
  00148	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _mbr$[ebp]
  0014e	50		 push	 eax
  0014f	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00155	e8 00 00 00 00	 call	 ?Write@File@GostCrypt@@QAEXPAEK@Z ; GostCrypt::File::Write

; 1529 : 
; 1530 : 		byte mbrVerificationBuf[GST_SECTOR_SIZE_BIOS];
; 1531 : 		device.SeekAt (0);

  0015a	80 bd c0 fb ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  00161	0f 57 c0	 xorps	 xmm0, xmm0
  00164	66 0f 13 85 c8
	fb ff ff	 movlpd	 QWORD PTR _device$[ebp+8], xmm0
  0016c	75 28		 jne	 SHORT $LN159@WriteBootS
  0016e	6a 00		 push	 0
  00170	6a 00		 push	 0
  00172	66 0f 13 85 58
	fa ff ff	 movlpd	 QWORD PTR _pos$2[ebp], xmm0
  0017a	ff b5 5c fa ff
	ff		 push	 DWORD PTR _pos$2[ebp+4]
  00180	ff b5 58 fa ff
	ff		 push	 DWORD PTR _pos$2[ebp]
  00186	ff b5 d0 fb ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  0018c	ff d6		 call	 esi
  0018e	85 c0		 test	 eax, eax
  00190	0f 84 32 ff ff
	ff		 je	 $LN288@WriteBootS
$LN159@WriteBootS:

; 1532 : 		device.Read (mbrVerificationBuf, sizeof (mbr));

  00196	68 00 02 00 00	 push	 512			; 00000200H
  0019b	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _mbrVerificationBuf$[ebp]
  001a1	50		 push	 eax
  001a2	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  001a8	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read

; 1533 : 
; 1534 : 		if (memcmp (mbr, mbrVerificationBuf, sizeof (mbr)) != 0)

  001ad	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _mbr$[ebp]
  001b3	be fc 01 00 00	 mov	 esi, 508		; 000001fcH
  001b8	8d 95 f0 fb ff
	ff		 lea	 edx, DWORD PTR _mbrVerificationBuf$[ebp]
  001be	66 90		 npad	 2
$LL285@WriteBootS:
  001c0	8b 01		 mov	 eax, DWORD PTR [ecx]
  001c2	3b 02		 cmp	 eax, DWORD PTR [edx]
  001c4	75 33		 jne	 SHORT $LN284@WriteBootS
  001c6	83 c1 04	 add	 ecx, 4
  001c9	83 c2 04	 add	 edx, 4
  001cc	83 ee 04	 sub	 esi, 4
  001cf	73 ef		 jae	 SHORT $LL285@WriteBootS

; 1536 : 	}

  001d1	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  001d7	e8 00 00 00 00	 call	 ??1Device@GostCrypt@@QAE@XZ
  001dc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001df	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e6	59		 pop	 ecx
  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi
  001e9	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ec	33 cd		 xor	 ecx, ebp
  001ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f3	8b e5		 mov	 esp, ebp
  001f5	5d		 pop	 ebp
  001f6	c2 04 00	 ret	 4
$LN284@WriteBootS:

; 1535 : 			throw ErrorException ("ERROR_MBR_PROTECTED");

  001f9	33 c0		 xor	 eax, eax
  001fb	c7 85 a0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], OFFSET ??_7ErrorException@GostCrypt@@6B@
  00205	66 89 85 a8 fb
	ff ff		 mov	 WORD PTR $T7[ebp+8], ax
  0020c	8d 85 a0 fb ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00212	c7 85 a4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+4], OFFSET ??_C@_0BE@GPJOEGCF@ERROR_MBR_PROTECTED?$AA@
  0021c	c7 85 bc fb ff
	ff 07 00 00 00	 mov	 DWORD PTR $T7[ebp+28], 7
  00226	c7 85 b8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+24], 0
  00230	68 00 00 00 00	 push	 OFFSET __TI2?AUErrorException@GostCrypt@@
  00235	e9 af fe ff ff	 jmp	 $LN289@WriteBootS
$LN287@WriteBootS:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z$0:
  00000	8d 8d 60 fa ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z$2:
  0000b	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1Device@GostCrypt@@QAE@XZ
__ehhandler$?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a 58 fa ff
	ff		 mov	 ecx, DWORD PTR [edx-1448]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z ENDP ; GostCrypt::BootEncryption::WriteBootSectorConfig
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?WriteBootDriveSector@BootEncryption@GostCrypt@@QAEX_KPAE@Z
_TEXT	SEGMENT
_request$ = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_offset$ = 8						; size = 8
_data$ = 16						; size = 4
?WriteBootDriveSector@BootEncryption@GostCrypt@@QAEX_KPAE@Z PROC ; GostCrypt::BootEncryption::WriteBootDriveSector, COMDAT
; _this$ = ecx

; 3149 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3150 : 		WriteBootDriveSectorRequest request;
; 3151 : 		request.Offset.QuadPart = offset;

  00013	8b 45 08	 mov	 eax, DWORD PTR _offset$[ebp]
  00016	8b d1		 mov	 edx, ecx
  00018	56		 push	 esi
  00019	8b 75 10	 mov	 esi, DWORD PTR _data$[ebp]

; 3152 : 		memcpy (request.Data, data, sizeof (request.Data));

  0001c	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00021	57		 push	 edi

; 3153 : 
; 3154 : 		CallDriver (GST_IOCTL_WRITE_BOOT_DRIVE_SECTOR, &request, sizeof (request), NULL, 0);

  00022	6a 00		 push	 0
  00024	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _request$[ebp], eax
  0002a	8d bd fc fd ff
	ff		 lea	 edi, DWORD PTR _request$[ebp+8]
  00030	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp+4]
  00033	6a 00		 push	 0
  00035	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _request$[ebp+4], eax
  0003b	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _request$[ebp]
  00041	68 08 02 00 00	 push	 520			; 00000208H
  00046	f3 a5		 rep movsd
  00048	50		 push	 eax
  00049	68 88 20 22 00	 push	 2236552			; 00222088H
  0004e	8b ca		 mov	 ecx, edx
  00050	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 3155 : 	}

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	5f		 pop	 edi
  00059	33 cd		 xor	 ecx, ebp
  0005b	5e		 pop	 esi
  0005c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 0c 00	 ret	 12			; 0000000cH
?WriteBootDriveSector@BootEncryption@GostCrypt@@QAEX_KPAE@Z ENDP ; GostCrypt::BootEncryption::WriteBootDriveSector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ
_TEXT	SEGMENT
_finally1727$ = -1168					; size = 4
$T2 = -1164						; size = 8
_pos$3 = -1164						; size = 8
$T4 = -1164						; size = 8
$T5 = -1164						; size = 8
_configFlags$6 = -1156					; size = 1
_configFlags$7 = -1155					; size = 1
_configFlags$8 = -1154					; size = 1
_configFlags$9 = -1153					; size = 1
_configFlags$10 = -1153					; size = 1
$T11 = -1152						; size = 320
_device$ = -832						; size = 48
_randData$ = -784					; size = 256
_mbr$ = -528						; size = 512
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ PROC ; GostCrypt::BootEncryption::WipeHiddenOSCreationConfig, COMDAT
; _this$ = ecx

; 1711 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 84 04 00
	00		 sub	 esp, 1156		; 00000484H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b f9		 mov	 edi, ecx

; 1712 : 		if (IsHiddenOSRunning() || Randinit() != ERR_SUCCESS)

  00030	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  00035	85 c0		 test	 eax, eax
  00037	0f 85 2c 03 00
	00		 jne	 $LN12@WipeHidden
  0003d	e8 00 00 00 00	 call	 _Randinit
  00042	85 c0		 test	 eax, eax
  00044	0f 85 1f 03 00
	00		 jne	 $LN12@WipeHidden

; 1714 : 
; 1715 : 		Device device (GetSystemDriveConfiguration().DevicePath);

  0004a	50		 push	 eax
  0004b	8d 85 80 fb ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  00051	8b cf		 mov	 ecx, edi
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  00059	83 ec 18	 sub	 esp, 24			; 00000018H
  0005c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00063	8b cc		 mov	 ecx, esp
  00065	8d 50 18	 lea	 edx, DWORD PTR [eax+24]
  00068	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0006f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00076	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0007a	72 04		 jb	 SHORT $LN140@WipeHidden
  0007c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007e	eb 02		 jmp	 SHORT $LN141@WipeHidden
$LN140@WipeHidden:
  00080	8b c1		 mov	 eax, ecx
$LN141@WipeHidden:
  00082	52		 push	 edx
  00083	c6 00 00	 mov	 BYTE PTR [eax], 0
  00086	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0008b	8d 8d c0 fc ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00091	e8 00 00 00 00	 call	 ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device
  00096	8d 8d 80 fb ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  0009c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000a0	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 1716 : 		byte mbr[GST_SECTOR_SIZE_BIOS];
; 1717 : 
; 1718 : 		device.SeekAt (0);

  000a5	6a 00		 push	 0
  000a7	6a 00		 push	 0
  000a9	8d 8d c0 fc ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  000af	e8 00 00 00 00	 call	 ?SeekAt@File@GostCrypt@@QAEX_J@Z ; GostCrypt::File::SeekAt

; 1719 : 		device.Read (mbr, sizeof (mbr));

  000b4	68 00 02 00 00	 push	 512			; 00000200H
  000b9	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _mbr$[ebp]
  000bf	50		 push	 eax
  000c0	8d 8d c0 fc ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  000c6	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read

; 1720 : 		
; 1721 : 		finally_do_arg (BootEncryption *, this,

  000cb	89 bd 70 fb ff
	ff		 mov	 DWORD PTR _finally1727$[ebp], edi

; 1722 : 		{
; 1723 : 			try
; 1724 : 			{
; 1725 : 				finally_arg->SetHiddenOSCreationPhase (GST_HIDDEN_OS_CREATION_PHASE_NONE);
; 1726 : 			} catch (...) { }
; 1727 : 		});
; 1728 : 
; 1729 : #if PRAND_DISK_WIPE_PASSES > RNG_POOL_SIZE
; 1730 : #	error PRAND_DISK_WIPE_PASSES > RNG_POOL_SIZE
; 1731 : #endif
; 1732 : 
; 1733 : 		byte randData[PRAND_DISK_WIPE_PASSES];
; 1734 : 		if (!RandgetBytes (randData, sizeof (randData), FALSE))

  000d1	6a 00		 push	 0
  000d3	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR _randData$[ebp]
  000d9	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000dd	68 00 01 00 00	 push	 256			; 00000100H
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 _RandgetBytes
  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000eb	85 c0		 test	 eax, eax
  000ed	75 25		 jne	 SHORT $LN13@WipeHidden

; 1735 : 			throw ParameterIncorrect (SRC_POS);

  000ef	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  000f4	8d 85 74 fb ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  000fa	c7 85 74 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00104	50		 push	 eax
  00105	c7 85 78 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+4], OFFSET ??_C@_0DL@LMFKBOII@GostCrypt?3?3BootEncryption?3?3WipeH@
  0010f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN325@WipeHidden:
$LN13@WipeHidden:

; 1736 : 
; 1737 : 		for (int wipePass = 0; wipePass < PRAND_DISK_WIPE_PASSES; wipePass++)

  00114	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SetFilePointerEx@20
  0011a	33 f6		 xor	 esi, esi
  0011c	0f 1f 40 00	 npad	 4
$LL4@WipeHidden:

; 1738 : 		{
; 1739 : 			for (int i = 0; i < GST_BOOT_SECTOR_OUTER_VOLUME_BAK_HEADER_CRC_SIZE; ++i)
; 1740 : 			{
; 1741 : 				mbr[GST_BOOT_SECTOR_OUTER_VOLUME_BAK_HEADER_CRC_OFFSET + i] = randData[wipePass];

  00120	8a 94 35 f0 fc
	ff ff		 mov	 dl, BYTE PTR _randData$[ebp+esi]
  00127	8a ca		 mov	 cl, dl

; 1742 : 			}
; 1743 : 
; 1744 : 			mbr[GST_BOOT_SECTOR_CONFIG_OFFSET] &= (byte) ~GST_BOOT_CFG_MASK_HIDDEN_OS_CREATION_PHASE;
; 1745 : 			mbr[GST_BOOT_SECTOR_CONFIG_OFFSET] |= randData[wipePass] & GST_BOOT_CFG_MASK_HIDDEN_OS_CREATION_PHASE;

  00129	8a c2		 mov	 al, dl
  0012b	32 45 a7	 xor	 al, BYTE PTR _mbr$[ebp+439]
  0012e	0f b6 c9	 movzx	 ecx, cl
  00131	24 3f		 and	 al, 63			; 0000003fH
  00133	69 c9 01 01 01
	01		 imul	 ecx, 16843009		; 01010101H
  00139	32 c2		 xor	 al, dl
  0013b	88 45 a7	 mov	 BYTE PTR _mbr$[ebp+439], al
  0013e	89 4d 82	 mov	 DWORD PTR _mbr$[ebp+402], ecx

; 1746 : 
; 1747 : 			if (wipePass == PRAND_DISK_WIPE_PASSES - 1)

  00141	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  00147	75 07		 jne	 SHORT $LN14@WipeHidden

; 1748 : 				memset (mbr + GST_BOOT_SECTOR_OUTER_VOLUME_BAK_HEADER_CRC_OFFSET, 0, GST_BOOT_SECTOR_OUTER_VOLUME_BAK_HEADER_CRC_SIZE);

  00149	c7 45 82 00 00
	00 00		 mov	 DWORD PTR _mbr$[ebp+402], 0
$LN14@WipeHidden:

; 1749 : 
; 1750 : 			device.SeekAt (0);

  00150	80 bd c0 fc ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  00157	0f 57 c0	 xorps	 xmm0, xmm0
  0015a	66 0f 13 85 c8
	fc ff ff	 movlpd	 QWORD PTR _device$[ebp+8], xmm0
  00162	75 28		 jne	 SHORT $LN159@WipeHidden
  00164	6a 00		 push	 0
  00166	6a 00		 push	 0
  00168	66 0f 13 85 74
	fb ff ff	 movlpd	 QWORD PTR _pos$3[ebp], xmm0
  00170	ff b5 78 fb ff
	ff		 push	 DWORD PTR _pos$3[ebp+4]
  00176	ff b5 74 fb ff
	ff		 push	 DWORD PTR _pos$3[ebp]
  0017c	ff b5 d0 fc ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  00182	ff d3		 call	 ebx
  00184	85 c0		 test	 eax, eax
  00186	0f 84 6d 01 00
	00		 je	 $LN312@WipeHidden
$LN159@WipeHidden:

; 1751 : 			device.Write (mbr, sizeof (mbr));

  0018c	68 00 02 00 00	 push	 512			; 00000200H
  00191	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _mbr$[ebp]
  00197	50		 push	 eax
  00198	8d 8d c0 fc ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  0019e	e8 00 00 00 00	 call	 ?Write@File@GostCrypt@@QAEXPAEK@Z ; GostCrypt::File::Write
  001a3	46		 inc	 esi
  001a4	81 fe 00 01 00
	00		 cmp	 esi, 256		; 00000100H
  001aa	0f 8c 70 ff ff
	ff		 jl	 $LL4@WipeHidden

; 1752 : 		}
; 1753 : 
; 1754 : 		for (int wipePass = 0; wipePass < PRAND_DISK_WIPE_PASSES/4 + 1; wipePass++)

  001b0	be 41 00 00 00	 mov	 esi, 65			; 00000041H
$LL10@WipeHidden:

; 1755 : 		{
; 1756 : 			SetHiddenOSCreationPhase (GST_HIDDEN_OS_CREATION_PHASE_NONE);

  001b5	6a 00		 push	 0
  001b7	6a 00		 push	 0
  001b9	6a 00		 push	 0
  001bb	6a 01		 push	 1
  001bd	8d 85 7e fb ff
	ff		 lea	 eax, DWORD PTR _configFlags$8[ebp]
  001c3	8b cf		 mov	 ecx, edi
  001c5	50		 push	 eax
  001c6	e8 00 00 00 00	 call	 ?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z ; GostCrypt::BootEncryption::ReadBootSectorConfig
  001cb	80 a5 7e fb ff
	ff 3f		 and	 BYTE PTR _configFlags$8[ebp], 63 ; 0000003fH
  001d2	8d 85 7e fb ff
	ff		 lea	 eax, DWORD PTR _configFlags$8[ebp]
  001d8	50		 push	 eax
  001d9	8b cf		 mov	 ecx, edi
  001db	e8 00 00 00 00	 call	 ?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z ; GostCrypt::BootEncryption::WriteBootSectorConfig

; 1757 : 			SetHiddenOSCreationPhase (GST_HIDDEN_OS_CREATION_PHASE_CLONING);

  001e0	6a 00		 push	 0
  001e2	6a 00		 push	 0
  001e4	6a 00		 push	 0
  001e6	6a 01		 push	 1
  001e8	8d 85 7d fb ff
	ff		 lea	 eax, DWORD PTR _configFlags$7[ebp]
  001ee	8b cf		 mov	 ecx, edi
  001f0	50		 push	 eax
  001f1	e8 00 00 00 00	 call	 ?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z ; GostCrypt::BootEncryption::ReadBootSectorConfig
  001f6	0f b6 85 7d fb
	ff ff		 movzx	 eax, BYTE PTR _configFlags$7[ebp]
  001fd	8b cf		 mov	 ecx, edi
  001ff	24 3f		 and	 al, 63			; 0000003fH
  00201	0c 40		 or	 al, 64			; 00000040H
  00203	88 85 7d fb ff
	ff		 mov	 BYTE PTR _configFlags$7[ebp], al
  00209	8d 85 7d fb ff
	ff		 lea	 eax, DWORD PTR _configFlags$7[ebp]
  0020f	50		 push	 eax
  00210	e8 00 00 00 00	 call	 ?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z ; GostCrypt::BootEncryption::WriteBootSectorConfig

; 1758 : 			SetHiddenOSCreationPhase (GST_HIDDEN_OS_CREATION_PHASE_WIPING);

  00215	6a 00		 push	 0
  00217	6a 00		 push	 0
  00219	6a 00		 push	 0
  0021b	6a 01		 push	 1
  0021d	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _configFlags$6[ebp]
  00223	8b cf		 mov	 ecx, edi
  00225	50		 push	 eax
  00226	e8 00 00 00 00	 call	 ?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z ; GostCrypt::BootEncryption::ReadBootSectorConfig
  0022b	0f b6 85 7c fb
	ff ff		 movzx	 eax, BYTE PTR _configFlags$6[ebp]
  00232	8b cf		 mov	 ecx, edi
  00234	24 3f		 and	 al, 63			; 0000003fH
  00236	0c 80		 or	 al, 128			; 00000080H
  00238	88 85 7c fb ff
	ff		 mov	 BYTE PTR _configFlags$6[ebp], al
  0023e	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR _configFlags$6[ebp]
  00244	50		 push	 eax
  00245	e8 00 00 00 00	 call	 ?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z ; GostCrypt::BootEncryption::WriteBootSectorConfig

; 1759 : 			SetHiddenOSCreationPhase (GST_HIDDEN_OS_CREATION_PHASE_WIPED);

  0024a	6a 00		 push	 0
  0024c	6a 00		 push	 0
  0024e	6a 00		 push	 0
  00250	6a 01		 push	 1
  00252	8d 85 7f fb ff
	ff		 lea	 eax, DWORD PTR _configFlags$10[ebp]
  00258	8b cf		 mov	 ecx, edi
  0025a	50		 push	 eax
  0025b	e8 00 00 00 00	 call	 ?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z ; GostCrypt::BootEncryption::ReadBootSectorConfig
  00260	80 8d 7f fb ff
	ff c0		 or	 BYTE PTR _configFlags$10[ebp], 192 ; 000000c0H
  00267	8d 85 7f fb ff
	ff		 lea	 eax, DWORD PTR _configFlags$10[ebp]
  0026d	50		 push	 eax
  0026e	8b cf		 mov	 ecx, edi
  00270	e8 00 00 00 00	 call	 ?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z ; GostCrypt::BootEncryption::WriteBootSectorConfig
  00275	83 ee 01	 sub	 esi, 1
  00278	0f 85 37 ff ff
	ff		 jne	 $LL10@WipeHidden

; 1760 : 		}
; 1761 : 		SetHiddenOSCreationPhase (GST_HIDDEN_OS_CREATION_PHASE_NONE);

  0027e	56		 push	 esi
  0027f	56		 push	 esi
  00280	56		 push	 esi
  00281	6a 01		 push	 1
  00283	8d 85 7f fb ff
	ff		 lea	 eax, DWORD PTR _configFlags$9[ebp]
  00289	8b cf		 mov	 ecx, edi
  0028b	50		 push	 eax
  0028c	e8 00 00 00 00	 call	 ?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z ; GostCrypt::BootEncryption::ReadBootSectorConfig
  00291	80 a5 7f fb ff
	ff 3f		 and	 BYTE PTR _configFlags$9[ebp], 63 ; 0000003fH
  00298	8d 85 7f fb ff
	ff		 lea	 eax, DWORD PTR _configFlags$9[ebp]
  0029e	50		 push	 eax
  0029f	8b cf		 mov	 ecx, edi
  002a1	e8 00 00 00 00	 call	 ?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z ; GostCrypt::BootEncryption::WriteBootSectorConfig

; 1762 : 	}

  002a6	8d 8d 70 fb ff
	ff		 lea	 ecx, DWORD PTR _finally1727$[ebp]
  002ac	e8 00 00 00 00	 call	 ??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ ; `GostCrypt::BootEncryption::WipeHiddenOSCreationConfig'::`2'::Finally1727::~Finally1727
  002b1	80 bd c1 fc ff
	ff 00		 cmp	 BYTE PTR _device$[ebp+1], 0
  002b8	74 1c		 je	 SHORT $LN187@WipeHidden
  002ba	80 bd c0 fc ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  002c1	75 0c		 jne	 SHORT $LN188@WipeHidden
  002c3	ff b5 d0 fc ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  002c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN188@WipeHidden:
  002cf	c6 85 c1 fc ff
	ff 00		 mov	 BYTE PTR _device$[ebp+1], 0
$LN187@WipeHidden:
  002d6	8b 85 ec fc ff
	ff		 mov	 eax, DWORD PTR _device$[ebp+44]
  002dc	83 f8 10	 cmp	 eax, 16			; 00000010H
  002df	72 6c		 jb	 SHORT $LN191@WipeHidden
  002e1	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _device$[ebp+24]
  002e7	40		 inc	 eax
  002e8	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  002ed	72 55		 jb	 SHORT $LN271@WipeHidden
  002ef	f6 c1 1f	 test	 cl, 31			; 0000001fH
  002f2	74 2c		 je	 SHORT $LN272@WipeHidden
  002f4	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN326@WipeHidden:
$LN312@WipeHidden:

; 1749 : 
; 1750 : 			device.SeekAt (0);

  002f9	c7 85 74 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00303	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00309	89 85 78 fb ff
	ff		 mov	 DWORD PTR $T2[ebp+4], eax
  0030f	8d 85 74 fb ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00315	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  0031a	50		 push	 eax
  0031b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN327@WipeHidden:

; 1762 : 	}

$LN272@WipeHidden:
  00320	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00323	3b c1		 cmp	 eax, ecx
  00325	72 05		 jb	 SHORT $LN273@WipeHidden
  00327	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN328@WipeHidden:
$LN273@WipeHidden:
  0032c	2b c8		 sub	 ecx, eax
  0032e	83 f9 04	 cmp	 ecx, 4
  00331	73 05		 jae	 SHORT $LN274@WipeHidden
  00333	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN329@WipeHidden:
$LN274@WipeHidden:
  00338	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0033b	76 05		 jbe	 SHORT $LN275@WipeHidden
  0033d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN330@WipeHidden:
$LN275@WipeHidden:
  00342	8b c8		 mov	 ecx, eax
$LN271@WipeHidden:
  00344	51		 push	 ecx
  00345	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0034a	83 c4 04	 add	 esp, 4
$LN191@WipeHidden:
  0034d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00350	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00357	59		 pop	 ecx
  00358	5f		 pop	 edi
  00359	5e		 pop	 esi
  0035a	5b		 pop	 ebx
  0035b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0035e	33 cd		 xor	 ecx, ebp
  00360	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00365	8b e5		 mov	 esp, ebp
  00367	5d		 pop	 ebp
  00368	c3		 ret	 0
$LN12@WipeHidden:

; 1713 : 			throw ParameterIncorrect (SRC_POS);

  00369	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  0036e	8d 85 74 fb ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00374	c7 85 74 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0037e	50		 push	 eax
  0037f	c7 85 78 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+4], OFFSET ??_C@_0DL@OJIEGNGA@GostCrypt?3?3BootEncryption?3?3WipeH@
  00389	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN331@WipeHidden:
$LN324@WipeHidden:
  0038e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ$0:
  00000	8d 8d 80 fb ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ$2:
  0000b	8d 8d c0 fc ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1Device@GostCrypt@@QAE@XZ
__unwindfunclet$?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ$3:
  00016	8d 8d 70 fb ff
	ff		 lea	 ecx, DWORD PTR _finally1727$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1Finally1727@?1??WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ@QAE@XZ ; `GostCrypt::BootEncryption::WipeHiddenOSCreationConfig'::`2'::Finally1727::~Finally1727
__ehhandler$?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 8a 6c fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1172]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ
  00044	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?WipeHiddenOSCreationConfig@BootEncryption@GostCrypt@@QAEXXZ ENDP ; GostCrypt::BootEncryption::WipeHiddenOSCreationConfig
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ
_TEXT	SEGMENT
_buffer$2 = -132					; size = 8
$T3 = -120						; size = 12
$T4 = -108						; size = 8
_this$ = -100						; size = 4
_drive$5 = -93						; size = 1
_driveDevice$6 = -92					; size = 48
_path$7 = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ PROC ; GostCrypt::BootEncryption::VerifyRescueDisk, COMDAT
; _this$ = ecx

; 2023 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 78	 sub	 esp, 120		; 00000078H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002e	8b f9		 mov	 edi, ecx
  00030	89 7d 9c	 mov	 DWORD PTR _this$[ebp], edi

; 2024 : 		if (!RescueIsoImage)

  00033	83 bf c0 01 00
	00 00		 cmp	 DWORD PTR [edi+448], 0
  0003a	75 1c		 jne	 SHORT $LN5@VerifyResc

; 2025 : 			throw ParameterIncorrect (SRC_POS);

  0003c	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00041	8d 45 94	 lea	 eax, DWORD PTR $T4[ebp]
  00044	c7 45 94 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0004b	50		 push	 eax
  0004c	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+4], OFFSET ??_C@_0DB@MFFJFGID@GostCrypt?3?3BootEncryption?3?3Verif@
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN980@VerifyResc:
$LN5@VerifyResc:

; 2026 : 
; 2027 : 		for (char drive = 'Z'; drive >= 'C'; --drive)

  00058	b3 5a		 mov	 bl, 90			; 0000005aH
$LN979@VerifyResc:
  0005a	88 5d a3	 mov	 BYTE PTR _drive$5[ebp], bl
  0005d	80 fb 43	 cmp	 bl, 67			; 00000043H
  00060	0f 8c 4f 02 00
	00		 jl	 $LN3@VerifyResc

; 2028 : 		{
; 2029 : 			try
; 2030 : 			{
; 2031 : 				string path = "X:";

  00066	6a 02		 push	 2
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_02EHLIIHJM@X?3?$AA@
  0006d	8d 4d d4	 lea	 ecx, DWORD PTR _path$7[ebp]
  00070	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00077	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR _path$7[ebp+20], 15 ; 0000000fH
  0007e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _path$7[ebp+16], 0
  00085	c6 45 d4 00	 mov	 BYTE PTR _path$7[ebp], 0
  00089	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2032 : 				path[0] = drive;

  0008e	83 7d e8 10	 cmp	 DWORD PTR _path$7[ebp+20], 16 ; 00000010H
  00092	8d 45 d4	 lea	 eax, DWORD PTR _path$7[ebp]

; 2033 : 
; 2034 : 				Device driveDevice (path, true);

  00095	6a 01		 push	 1
  00097	0f 43 45 d4	 cmovae	 eax, DWORD PTR _path$7[ebp]
  0009b	83 ec 18	 sub	 esp, 24			; 00000018H
  0009e	8b cc		 mov	 ecx, esp
  000a0	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  000a4	88 18		 mov	 BYTE PTR [eax], bl
  000a6	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  000ad	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  000b4	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  000b8	72 04		 jb	 SHORT $LN301@VerifyResc
  000ba	8b 01		 mov	 eax, DWORD PTR [ecx]
  000bc	eb 02		 jmp	 SHORT $LN302@VerifyResc
$LN301@VerifyResc:
  000be	8b c1		 mov	 eax, ecx
$LN302@VerifyResc:
  000c0	6a ff		 push	 -1
  000c2	c6 00 00	 mov	 BYTE PTR [eax], 0
  000c5	8d 45 d4	 lea	 eax, DWORD PTR _path$7[ebp]
  000c8	6a 00		 push	 0
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000d0	8d 4d a4	 lea	 ecx, DWORD PTR _driveDevice$6[ebp]
  000d3	e8 00 00 00 00	 call	 ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device

; 2035 : 				size_t verifiedSectorCount = (GST_CD_BOOTSECTOR_OFFSET + GST_ORIG_BOOT_LOADER_BACKUP_SECTOR_OFFSET + GST_BOOT_LOADER_AREA_SIZE) / 2048;
; 2036 : 				Buffer buffer ((verifiedSectorCount + 1) * 2048);

  000d8	68 00 d0 01 00	 push	 118784			; 0001d000H
  000dd	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000e1	c7 45 80 00 d0
	01 00		 mov	 DWORD PTR _buffer$2[ebp+4], 118784 ; 0001d000H
  000e8	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000ed	8b f0		 mov	 esi, eax
  000ef	83 c4 04	 add	 esp, 4
  000f2	89 b5 7c ff ff
	ff		 mov	 DWORD PTR _buffer$2[ebp], esi
  000f8	85 f6		 test	 esi, esi
  000fa	75 24		 jne	 SHORT $LN310@VerifyResc
  000fc	0f 57 c0	 xorps	 xmm0, xmm0
  000ff	c7 45 88 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00106	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0010b	8d 45 88	 lea	 eax, DWORD PTR $T3[ebp]
  0010e	66 0f d6 45 8c	 movq	 QWORD PTR $T3[ebp+4], xmm0
  00113	50		 push	 eax
  00114	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], OFFSET ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
  0011b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN981@VerifyResc:
$LN310@VerifyResc:

; 2037 : 
; 2038 : 				DWORD bytesRead = driveDevice.Read (buffer.Ptr(), buffer.Size());

  00120	68 00 d0 01 00	 push	 118784			; 0001d000H
  00125	56		 push	 esi
  00126	8d 4d a4	 lea	 ecx, DWORD PTR _driveDevice$6[ebp]
  00129	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  0012d	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read

; 2039 : 				if (bytesRead != buffer.Size())

  00132	3d 00 d0 01 00	 cmp	 eax, 118784		; 0001d000H
  00137	74 70		 je	 SHORT $LN7@VerifyResc

; 2040 : 					continue;

  00139	56		 push	 esi
  0013a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0013f	83 c4 04	 add	 esp, 4
  00142	80 7d a5 00	 cmp	 BYTE PTR _driveDevice$6[ebp+1], 0
  00146	74 13		 je	 SHORT $LN332@VerifyResc
  00148	80 7d a4 00	 cmp	 BYTE PTR _driveDevice$6[ebp], 0
  0014c	75 09		 jne	 SHORT $LN333@VerifyResc
  0014e	ff 75 b4	 push	 DWORD PTR _driveDevice$6[ebp+16]
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN333@VerifyResc:
  00157	c6 45 a5 00	 mov	 BYTE PTR _driveDevice$6[ebp+1], 0
$LN332@VerifyResc:
  0015b	8b 45 d0	 mov	 eax, DWORD PTR _driveDevice$6[ebp+44]
  0015e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00161	72 0d		 jb	 SHORT $LN341@VerifyResc
  00163	40		 inc	 eax
  00164	8d 4d bc	 lea	 ecx, DWORD PTR _driveDevice$6[ebp+24]
  00167	50		 push	 eax
  00168	ff 75 bc	 push	 DWORD PTR _driveDevice$6[ebp+24]
  0016b	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN341@VerifyResc:
  00170	8b 45 e8	 mov	 eax, DWORD PTR _path$7[ebp+20]
  00173	c7 45 d0 0f 00
	00 00		 mov	 DWORD PTR _driveDevice$6[ebp+44], 15 ; 0000000fH
  0017a	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _driveDevice$6[ebp+40], 0
  00181	c6 45 bc 00	 mov	 BYTE PTR _driveDevice$6[ebp+24], 0
  00185	83 f8 10	 cmp	 eax, 16			; 00000010H
  00188	0f 82 19 01 00
	00		 jb	 $LN442@VerifyResc
  0018e	40		 inc	 eax
  0018f	8d 4d d4	 lea	 ecx, DWORD PTR _path$7[ebp]
  00192	50		 push	 eax
  00193	ff 75 d4	 push	 DWORD PTR _path$7[ebp]
  00196	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  0019b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001a2	fe cb		 dec	 bl
  001a4	e9 b1 fe ff ff	 jmp	 $LN979@VerifyResc
$LN7@VerifyResc:

; 2041 : 
; 2042 : 				if (memcmp (buffer.Ptr(), RescueIsoImage, buffer.Size()) == 0)

  001a9	8b 97 c0 01 00
	00		 mov	 edx, DWORD PTR [edi+448]
  001af	8b ce		 mov	 ecx, esi
  001b1	bf fc cf 01 00	 mov	 edi, 118780		; 0001cffcH
$LL976@VerifyResc:
  001b6	8b 01		 mov	 eax, DWORD PTR [ecx]
  001b8	3b 02		 cmp	 eax, DWORD PTR [edx]
  001ba	75 70		 jne	 SHORT $LN8@VerifyResc
  001bc	83 c1 04	 add	 ecx, 4
  001bf	83 c2 04	 add	 edx, 4
  001c2	83 ef 04	 sub	 edi, 4
  001c5	73 ef		 jae	 SHORT $LL976@VerifyResc

; 2043 : 					return true;

  001c7	56		 push	 esi
  001c8	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  001cd	83 c4 04	 add	 esp, 4
  001d0	80 7d a5 00	 cmp	 BYTE PTR _driveDevice$6[ebp+1], 0
  001d4	74 13		 je	 SHORT $LN551@VerifyResc
  001d6	80 7d a4 00	 cmp	 BYTE PTR _driveDevice$6[ebp], 0
  001da	75 09		 jne	 SHORT $LN552@VerifyResc
  001dc	ff 75 b4	 push	 DWORD PTR _driveDevice$6[ebp+16]
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN552@VerifyResc:
  001e5	c6 45 a5 00	 mov	 BYTE PTR _driveDevice$6[ebp+1], 0
$LN551@VerifyResc:
  001e9	8b 45 d0	 mov	 eax, DWORD PTR _driveDevice$6[ebp+44]
  001ec	83 f8 10	 cmp	 eax, 16			; 00000010H
  001ef	72 0d		 jb	 SHORT $LN560@VerifyResc
  001f1	40		 inc	 eax
  001f2	8d 4d bc	 lea	 ecx, DWORD PTR _driveDevice$6[ebp+24]
  001f5	50		 push	 eax
  001f6	ff 75 bc	 push	 DWORD PTR _driveDevice$6[ebp+24]
  001f9	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN560@VerifyResc:
  001fe	8b 45 e8	 mov	 eax, DWORD PTR _path$7[ebp+20]
  00201	c7 45 d0 0f 00
	00 00		 mov	 DWORD PTR _driveDevice$6[ebp+44], 15 ; 0000000fH
  00208	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _driveDevice$6[ebp+40], 0
  0020f	c6 45 bc 00	 mov	 BYTE PTR _driveDevice$6[ebp+24], 0
  00213	83 f8 10	 cmp	 eax, 16			; 00000010H
  00216	72 0d		 jb	 SHORT $LN661@VerifyResc
  00218	40		 inc	 eax
  00219	8d 4d d4	 lea	 ecx, DWORD PTR _path$7[ebp]
  0021c	50		 push	 eax
  0021d	ff 75 d4	 push	 DWORD PTR _path$7[ebp]
  00220	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN661@VerifyResc:
  00225	b0 01		 mov	 al, 1
  00227	e9 8b 00 00 00	 jmp	 $LN1@VerifyResc
$LN8@VerifyResc:

; 2044 : 			}

  0022c	56		 push	 esi
  0022d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00232	83 c4 04	 add	 esp, 4
  00235	80 7d a5 00	 cmp	 BYTE PTR _driveDevice$6[ebp+1], 0
  00239	74 13		 je	 SHORT $LN766@VerifyResc
  0023b	80 7d a4 00	 cmp	 BYTE PTR _driveDevice$6[ebp], 0
  0023f	75 09		 jne	 SHORT $LN767@VerifyResc
  00241	ff 75 b4	 push	 DWORD PTR _driveDevice$6[ebp+16]
  00244	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN767@VerifyResc:
  0024a	c6 45 a5 00	 mov	 BYTE PTR _driveDevice$6[ebp+1], 0
$LN766@VerifyResc:
  0024e	8b 45 d0	 mov	 eax, DWORD PTR _driveDevice$6[ebp+44]
  00251	83 f8 10	 cmp	 eax, 16			; 00000010H
  00254	72 0d		 jb	 SHORT $LN775@VerifyResc
  00256	40		 inc	 eax
  00257	8d 4d bc	 lea	 ecx, DWORD PTR _driveDevice$6[ebp+24]
  0025a	50		 push	 eax
  0025b	ff 75 bc	 push	 DWORD PTR _driveDevice$6[ebp+24]
  0025e	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN775@VerifyResc:
  00263	8b 45 e8	 mov	 eax, DWORD PTR _path$7[ebp+20]
  00266	c7 45 d0 0f 00
	00 00		 mov	 DWORD PTR _driveDevice$6[ebp+44], 15 ; 0000000fH
  0026d	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _driveDevice$6[ebp+40], 0
  00274	c6 45 bc 00	 mov	 BYTE PTR _driveDevice$6[ebp+24], 0
  00278	83 f8 10	 cmp	 eax, 16			; 00000010H
  0027b	72 27		 jb	 SHORT $LN876@VerifyResc
  0027d	40		 inc	 eax
  0027e	8d 4d d4	 lea	 ecx, DWORD PTR _path$7[ebp]
  00281	50		 push	 eax
  00282	ff 75 d4	 push	 DWORD PTR _path$7[ebp]
  00285	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  0028a	8b 7d 9c	 mov	 edi, DWORD PTR _this$[ebp]
  0028d	fe cb		 dec	 bl
  0028f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00296	e9 bf fd ff ff	 jmp	 $LN979@VerifyResc
__catch$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ$0:

; 2045 : 			catch (...) { }

  0029b	b8 00 00 00 00	 mov	 eax, $LN17@VerifyResc
  002a0	c3		 ret	 0
$LN17@VerifyResc:
  002a1	8a 5d a3	 mov	 bl, BYTE PTR _drive$5[ebp]

; 2044 : 			}

$LN876@VerifyResc:
  002a4	8b 7d 9c	 mov	 edi, DWORD PTR _this$[ebp]

; 2040 : 					continue;

$LN442@VerifyResc:
  002a7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 2026 : 
; 2027 : 		for (char drive = 'Z'; drive >= 'C'; --drive)

  002ae	fe cb		 dec	 bl
  002b0	e9 a5 fd ff ff	 jmp	 $LN979@VerifyResc
$LN3@VerifyResc:

; 2046 : 		}
; 2047 : 
; 2048 : 		return false;

  002b5	32 c0		 xor	 al, al
$LN1@VerifyResc:

; 2049 : 	}

  002b7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002ba	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002c1	59		 pop	 ecx
  002c2	5f		 pop	 edi
  002c3	5e		 pop	 esi
  002c4	5b		 pop	 ebx
  002c5	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c8	33 cd		 xor	 ecx, ebp
  002ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002cf	8b e5		 mov	 esp, ebp
  002d1	5d		 pop	 ebp
  002d2	c3		 ret	 0
$LN978@VerifyResc:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ$2:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _path$7[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ$4:
  00008	8d 4d a4	 lea	 ecx, DWORD PTR _driveDevice$6[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1Device@GostCrypt@@QAE@XZ
__unwindfunclet$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ$5:
  00010	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _buffer$2[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1Buffer@GostCrypt@@QAE@XZ ; GostCrypt::Buffer::~Buffer
__ehhandler$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ:
  0001b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00022	8b 8a 78 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-136]
  00028	33 c8		 xor	 ecx, eax
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00032	33 c8		 xor	 ecx, eax
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ
  0003e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?VerifyRescueDisk@BootEncryption@GostCrypt@@QAE_NXZ ENDP ; GostCrypt::BootEncryption::VerifyRescueDisk
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?SystemDriveIsDynamic@BootEncryption@GostCrypt@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -880						; size = 320
_request$ = -560					; size = 553
__$ArrayPad$ = -4					; size = 4
?SystemDriveIsDynamic@BootEncryption@GostCrypt@@QAE_NXZ PROC ; GostCrypt::BootEncryption::SystemDriveIsDynamic, COMDAT
; _this$ = ecx

; 1193 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 70 03 00
	00		 sub	 esp, 880		; 00000370H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 1194 : 		GetSystemDriveConfigurationRequest request;
; 1195 : 		_snwprintf (request.DevicePath, array_capacity (request.DevicePath), L"%hs", GetSystemDriveConfiguration().DeviceKernelPath.c_str());

  00014	8d 85 90 fc ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0001a	8b f1		 mov	 esi, ecx
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  00022	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00026	72 02		 jb	 SHORT $LN17@SystemDriv
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
$LN17@SystemDriv:
  0002a	50		 push	 eax
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs?$AA?$AA@
  00030	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _request$[ebp]
  00036	68 04 01 00 00	 push	 260			; 00000104H
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 __snwprintf
  00041	83 c4 10	 add	 esp, 16			; 00000010H
  00044	8d 8d 90 fc ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0004a	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 1196 : 
; 1197 : 		CallDriver (GST_IOCTL_GET_SYSTEM_DRIVE_CONFIG, &request, sizeof (request), &request, sizeof (request));

  0004f	68 29 02 00 00	 push	 553			; 00000229H
  00054	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _request$[ebp]
  0005a	8b ce		 mov	 ecx, esi
  0005c	50		 push	 eax
  0005d	68 29 02 00 00	 push	 553			; 00000229H
  00062	50		 push	 eax
  00063	68 70 20 22 00	 push	 2236528			; 00222070H
  00068	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 1198 : 		return request.DriveIsDynamic ? true : false;

  0006d	83 7d d9 00	 cmp	 DWORD PTR _request$[ebp+521], 0

; 1199 : 	}

  00071	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00074	0f 95 c0	 setne	 al
  00077	33 cd		 xor	 ecx, ebp
  00079	5e		 pop	 esi
  0007a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?SystemDriveIsDynamic@BootEncryption@GostCrypt@@QAE_NXZ ENDP ; GostCrypt::BootEncryption::SystemDriveIsDynamic
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?SystemPartitionCoversWholeDrive@BootEncryption@GostCrypt@@QAE_NXZ
_TEXT	SEGMENT
_config$ = -324						; size = 320
__$ArrayPad$ = -4					; size = 4
?SystemPartitionCoversWholeDrive@BootEncryption@GostCrypt@@QAE_NXZ PROC ; GostCrypt::BootEncryption::SystemPartitionCoversWholeDrive, COMDAT
; _this$ = ecx

; 1302 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 01 00
	00		 sub	 esp, 324		; 00000144H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx

; 1303 : 		SystemDriveConfiguration config = GetSystemDriveConfiguration();

  00014	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _config$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration

; 1304 : 
; 1305 : 		if (IsOSAtLeast (WIN_7)
; 1306 : 			&& config.Partitions.size() == 2
; 1307 : 			&& config.ExtraBootPartitionPresent
; 1308 : 			&& config.DrivePartition.Info.PartitionLength.QuadPart - config.SystemPartition.Info.PartitionLength.QuadPart < 164 * BYTES_PER_MB)

  00020	6a 0d		 push	 13			; 0000000dH
  00022	e8 00 00 00 00	 call	 _IsOSAtLeast
  00027	83 c4 04	 add	 esp, 4
  0002a	85 c0		 test	 eax, eax
  0002c	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _config$[ebp+188]
  00032	74 32		 je	 SHORT $LN2@SystemPart
  00034	83 f8 02	 cmp	 eax, 2
  00037	75 2d		 jne	 SHORT $LN2@SystemPart
  00039	80 bd 64 ff ff
	ff 00		 cmp	 BYTE PTR _config$[ebp+168], 0
  00040	74 4d		 je	 SHORT $LN4@SystemPart
  00042	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _config$[ebp+88]
  00048	2b 4d 9c	 sub	 ecx, DWORD PTR _config$[ebp+224]
  0004b	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _config$[ebp+92]
  00051	1b 45 a0	 sbb	 eax, DWORD PTR _config$[ebp+228]
  00054	85 c0		 test	 eax, eax
  00056	7f 37		 jg	 SHORT $LN4@SystemPart
  00058	7c 31		 jl	 SHORT $LN33@SystemPart
  0005a	81 f9 00 00 40
	0a		 cmp	 ecx, 171966464		; 0a400000H
  00060	73 2d		 jae	 SHORT $LN4@SystemPart
  00062	b3 01		 mov	 bl, 1
  00064	eb 2b		 jmp	 SHORT $LN5@SystemPart
$LN2@SystemPart:

; 1309 : 		{
; 1310 : 			return true;
; 1311 : 		}
; 1312 : 
; 1313 : 		return config.Partitions.size() == 1

  00066	83 f8 01	 cmp	 eax, 1
  00069	75 24		 jne	 SHORT $LN4@SystemPart
  0006b	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _config$[ebp+88]
  00071	2b 4d 9c	 sub	 ecx, DWORD PTR _config$[ebp+224]
  00074	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _config$[ebp+92]
  0007a	1b 45 a0	 sbb	 eax, DWORD PTR _config$[ebp+228]
  0007d	85 c0		 test	 eax, eax
  0007f	7f 0e		 jg	 SHORT $LN4@SystemPart
  00081	7c 08		 jl	 SHORT $LN33@SystemPart
  00083	81 f9 00 00 00
	04		 cmp	 ecx, 67108864		; 04000000H
  00089	73 04		 jae	 SHORT $LN4@SystemPart
$LN33@SystemPart:
  0008b	b3 01		 mov	 bl, 1
  0008d	eb 02		 jmp	 SHORT $LN5@SystemPart
$LN4@SystemPart:
  0008f	32 db		 xor	 bl, bl
$LN5@SystemPart:
  00091	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp]
  00097	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 1314 : 			&& config.DrivePartition.Info.PartitionLength.QuadPart - config.SystemPartition.Info.PartitionLength.QuadPart < 64 * BYTES_PER_MB;
; 1315 : 	}

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009f	8a c3		 mov	 al, bl
  000a1	33 cd		 xor	 ecx, ebp
  000a3	5b		 pop	 ebx
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
?SystemPartitionCoversWholeDrive@BootEncryption@GostCrypt@@QAE_NXZ ENDP ; GostCrypt::BootEncryption::SystemPartitionCoversWholeDrive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ
_TEXT	SEGMENT
$T2 = -928						; size = 8
$T3 = -920						; size = 8
_pos$4 = -912						; size = 8
_this$GSCopy$1$ = -904					; size = 4
$T5 = -900						; size = 320
_device$6 = -580					; size = 48
_mbrBuf$7 = -532					; size = 512
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ PROC ; GostCrypt::BootEncryption::SystemDriveContainsNonStandardPartitions, COMDAT
; _this$ = ecx

; 1160 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 94 03 00
	00		 sub	 esp, 916		; 00000394H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 8d 78 fc ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx

; 1161 : 		for (int partitionType = 1; partitionType <= 0xff; ++partitionType)

  00034	bb 01 00 00 00	 mov	 ebx, 1
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@SystemDriv:

; 1162 : 		{
; 1163 : 			switch (partitionType)

  00040	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00043	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  00046	77 0e		 ja	 SHORT $LN5@SystemDriv
  00048	0f b6 83 ff ff
	ff ff		 movzx	 eax, BYTE PTR $LN720@SystemDriv[ebx-1]
  0004f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN724@SystemDriv[eax*4]
$LN5@SystemDriv:

; 1164 : 			{
; 1165 : 			case PARTITION_FAT_12:
; 1166 : 			case PARTITION_FAT_16:
; 1167 : 			case PARTITION_EXTENDED:
; 1168 : 			case PARTITION_HUGE:
; 1169 : 			case PARTITION_IFS:
; 1170 : 			case PARTITION_FAT32:
; 1171 : 			case PARTITION_FAT32_XINT13:
; 1172 : 			case PARTITION_XINT13:
; 1173 : 			case PARTITION_XINT13_EXTENDED:
; 1174 : 				continue;
; 1175 : 			}
; 1176 : 
; 1177 : 			if (SystemDriveContainsPartitionType ((byte) partitionType))

  00056	6a 01		 push	 1
  00058	8d 85 7c fc ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  00064	83 ec 18	 sub	 esp, 24			; 00000018H
  00067	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006e	8b fc		 mov	 edi, esp
  00070	8d 70 18	 lea	 esi, DWORD PTR [eax+24]
  00073	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
  0007a	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00081	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00085	72 04		 jb	 SHORT $LN150@SystemDriv
  00087	8b 07		 mov	 eax, DWORD PTR [edi]
  00089	eb 02		 jmp	 SHORT $LN151@SystemDriv
$LN150@SystemDriv:
  0008b	8b c7		 mov	 eax, edi
$LN151@SystemDriv:
  0008d	c6 00 00	 mov	 BYTE PTR [eax], 0
  00090	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00094	73 15		 jae	 SHORT $LN162@SystemDriv
  00096	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00099	83 c0 01	 add	 eax, 1
  0009c	74 17		 je	 SHORT $LN163@SystemDriv
  0009e	50		 push	 eax
  0009f	56		 push	 esi
  000a0	57		 push	 edi
  000a1	e8 00 00 00 00	 call	 _memmove
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a9	eb 0a		 jmp	 SHORT $LN163@SystemDriv
$LN162@SystemDriv:
  000ab	8b 06		 mov	 eax, DWORD PTR [esi]
  000ad	89 07		 mov	 DWORD PTR [edi], eax
  000af	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN163@SystemDriv:
  000b5	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b8	89 47 10	 mov	 DWORD PTR [edi+16], eax
  000bb	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000be	89 47 14	 mov	 DWORD PTR [edi+20], eax
  000c1	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  000c8	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000cc	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000d3	72 02		 jb	 SHORT $LN403@SystemDriv
  000d5	8b 36		 mov	 esi, DWORD PTR [esi]
$LN403@SystemDriv:
  000d7	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR _device$6[ebp]
  000dd	c6 06 00	 mov	 BYTE PTR [esi], 0
  000e0	e8 00 00 00 00	 call	 ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device
  000e5	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  000eb	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000ef	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
  000f4	80 bd bc fd ff
	ff 00		 cmp	 BYTE PTR _device$6[ebp], 0
  000fb	0f 57 c0	 xorps	 xmm0, xmm0
  000fe	66 0f 13 85 c4
	fd ff ff	 movlpd	 QWORD PTR _device$6[ebp+8], xmm0
  00106	75 2c		 jne	 SHORT $LN413@SystemDriv
  00108	6a 00		 push	 0
  0010a	6a 00		 push	 0
  0010c	66 0f 13 85 70
	fc ff ff	 movlpd	 QWORD PTR _pos$4[ebp], xmm0
  00114	ff b5 74 fc ff
	ff		 push	 DWORD PTR _pos$4[ebp+4]
  0011a	ff b5 70 fc ff
	ff		 push	 DWORD PTR _pos$4[ebp]
  00120	ff b5 cc fd ff
	ff		 push	 DWORD PTR _device$6[ebp+16]
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  0012c	85 c0		 test	 eax, eax
  0012e	0f 84 d6 00 00
	00		 je	 $LN700@SystemDriv
$LN413@SystemDriv:
  00134	68 00 02 00 00	 push	 512			; 00000200H
  00139	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _mbrBuf$7[ebp]
  0013f	50		 push	 eax
  00140	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR _device$6[ebp]
  00146	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read
  0014b	b8 55 aa 00 00	 mov	 eax, 43605		; 0000aa55H
  00150	66 39 45 ea	 cmp	 WORD PTR _mbrBuf$7[ebp+510], ax
  00154	0f 85 44 01 00
	00		 jne	 $LN701@SystemDriv
  0015a	33 c9		 xor	 ecx, ecx
  0015c	8d 45 ae	 lea	 eax, DWORD PTR _mbrBuf$7[ebp+450]
  0015f	90		 npad	 1
$LL13@SystemDriv:
  00160	38 18		 cmp	 BYTE PTR [eax], bl
  00162	0f 84 ce 00 00
	00		 je	 $LN689@SystemDriv
  00168	41		 inc	 ecx
  00169	83 c0 10	 add	 eax, 16			; 00000010H
  0016c	83 f9 04	 cmp	 ecx, 4
  0016f	72 ef		 jb	 SHORT $LL13@SystemDriv
  00171	80 bd bd fd ff
	ff 00		 cmp	 BYTE PTR _device$6[ebp+1], 0
  00178	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0017f	74 1c		 je	 SHORT $LN564@SystemDriv
  00181	80 bd bc fd ff
	ff 00		 cmp	 BYTE PTR _device$6[ebp], 0
  00188	75 0c		 jne	 SHORT $LN565@SystemDriv
  0018a	ff b5 cc fd ff
	ff		 push	 DWORD PTR _device$6[ebp+16]
  00190	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN565@SystemDriv:
  00196	c6 85 bd fd ff
	ff 00		 mov	 BYTE PTR _device$6[ebp+1], 0
$LN564@SystemDriv:
  0019d	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _device$6[ebp+44]
  001a3	83 f8 10	 cmp	 eax, 16			; 00000010H
  001a6	72 31		 jb	 SHORT $LN721@SystemDriv
  001a8	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _device$6[ebp+24]
  001ae	40		 inc	 eax
  001af	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  001b4	72 1a		 jb	 SHORT $LN648@SystemDriv
  001b6	f6 c1 1f	 test	 cl, 31			; 0000001fH
  001b9	75 76		 jne	 SHORT $LN711@SystemDriv
  001bb	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  001be	3b c1		 cmp	 eax, ecx
  001c0	73 6f		 jae	 SHORT $LN711@SystemDriv
  001c2	2b c8		 sub	 ecx, eax
  001c4	83 f9 04	 cmp	 ecx, 4
  001c7	72 68		 jb	 SHORT $LN711@SystemDriv
  001c9	83 f9 23	 cmp	 ecx, 35			; 00000023H
  001cc	77 63		 ja	 SHORT $LN711@SystemDriv
  001ce	8b c8		 mov	 ecx, eax
$LN648@SystemDriv:
  001d0	51		 push	 ecx
  001d1	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001d6	83 c4 04	 add	 esp, 4
$LN721@SystemDriv:
  001d9	8b 8d 78 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
$LN2@SystemDriv:

; 1161 : 		for (int partitionType = 1; partitionType <= 0xff; ++partitionType)

  001df	43		 inc	 ebx
  001e0	81 fb ff 00 00
	00		 cmp	 ebx, 255		; 000000ffH
  001e6	0f 8e 54 fe ff
	ff		 jle	 $LL4@SystemDriv

; 1179 : 		}
; 1180 : 
; 1181 : 		return false;

  001ec	32 c0		 xor	 al, al
$LN1@SystemDriv:

; 1182 : 	}

  001ee	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001f1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001f8	59		 pop	 ecx
  001f9	5f		 pop	 edi
  001fa	5e		 pop	 esi
  001fb	5b		 pop	 ebx
  001fc	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ff	33 cd		 xor	 ecx, ebp
  00201	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c3		 ret	 0
$LN700@SystemDriv:

; 1164 : 			{
; 1165 : 			case PARTITION_FAT_12:
; 1166 : 			case PARTITION_FAT_16:
; 1167 : 			case PARTITION_EXTENDED:
; 1168 : 			case PARTITION_HUGE:
; 1169 : 			case PARTITION_IFS:
; 1170 : 			case PARTITION_FAT32:
; 1171 : 			case PARTITION_FAT32_XINT13:
; 1172 : 			case PARTITION_XINT13:
; 1173 : 			case PARTITION_XINT13_EXTENDED:
; 1174 : 				continue;
; 1175 : 			}
; 1176 : 
; 1177 : 			if (SystemDriveContainsPartitionType ((byte) partitionType))

  0020a	c7 85 68 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00214	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0021a	89 85 6c fc ff
	ff		 mov	 DWORD PTR $T3[ebp+4], eax
  00220	8d 85 68 fc ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00226	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  0022b	50		 push	 eax
  0022c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN725@SystemDriv:
$LN711@SystemDriv:
  00231	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN726@SystemDriv:
$LN689@SystemDriv:
  00236	80 bd bd fd ff
	ff 00		 cmp	 BYTE PTR _device$6[ebp+1], 0
  0023d	74 1c		 je	 SHORT $LN435@SystemDriv
  0023f	80 bd bc fd ff
	ff 00		 cmp	 BYTE PTR _device$6[ebp], 0
  00246	75 0c		 jne	 SHORT $LN436@SystemDriv
  00248	ff b5 cc fd ff
	ff		 push	 DWORD PTR _device$6[ebp+16]
  0024e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN436@SystemDriv:
  00254	c6 85 bd fd ff
	ff 00		 mov	 BYTE PTR _device$6[ebp+1], 0
$LN435@SystemDriv:
  0025b	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _device$6[ebp+44]
  00261	83 f8 10	 cmp	 eax, 16			; 00000010H
  00264	72 31		 jb	 SHORT $LN712@SystemDriv
  00266	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _device$6[ebp+24]
  0026c	40		 inc	 eax
  0026d	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00272	72 1a		 jb	 SHORT $LN519@SystemDriv
  00274	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00277	75 b8		 jne	 SHORT $LN711@SystemDriv
  00279	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0027c	3b c1		 cmp	 eax, ecx
  0027e	73 b1		 jae	 SHORT $LN711@SystemDriv
  00280	2b c8		 sub	 ecx, eax
  00282	83 f9 04	 cmp	 ecx, 4
  00285	72 aa		 jb	 SHORT $LN711@SystemDriv
  00287	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0028a	77 a5		 ja	 SHORT $LN711@SystemDriv
  0028c	8b c8		 mov	 ecx, eax
$LN519@SystemDriv:
  0028e	51		 push	 ecx
  0028f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00294	83 c4 04	 add	 esp, 4
$LN712@SystemDriv:

; 1178 : 				return true;

  00297	b0 01		 mov	 al, 1
  00299	e9 50 ff ff ff	 jmp	 $LN1@SystemDriv
$LN701@SystemDriv:

; 1164 : 			{
; 1165 : 			case PARTITION_FAT_12:
; 1166 : 			case PARTITION_FAT_16:
; 1167 : 			case PARTITION_EXTENDED:
; 1168 : 			case PARTITION_HUGE:
; 1169 : 			case PARTITION_IFS:
; 1170 : 			case PARTITION_FAT32:
; 1171 : 			case PARTITION_FAT32_XINT13:
; 1172 : 			case PARTITION_XINT13:
; 1173 : 			case PARTITION_XINT13_EXTENDED:
; 1174 : 				continue;
; 1175 : 			}
; 1176 : 
; 1177 : 			if (SystemDriveContainsPartitionType ((byte) partitionType))

  0029e	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  002a3	8d 85 60 fc ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  002a9	c7 85 60 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  002b3	50		 push	 eax
  002b4	c7 85 64 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_0EB@HMOPBABC@GostCrypt?3?3BootEncryption?3?3Syste@
  002be	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN727@SystemDriv:
$LN723@SystemDriv:
  002c3	90		 npad	 1
$LN724@SystemDriv:

; 1182 : 	}

  002c4	00 00 00 00	 DD	 $LN2@SystemDriv
  002c8	00 00 00 00	 DD	 $LN5@SystemDriv
$LN720@SystemDriv:
  002cc	00		 DB	 0
  002cd	01		 DB	 1
  002ce	01		 DB	 1
  002cf	00		 DB	 0
  002d0	00		 DB	 0
  002d1	00		 DB	 0
  002d2	00		 DB	 0
  002d3	01		 DB	 1
  002d4	01		 DB	 1
  002d5	01		 DB	 1
  002d6	00		 DB	 0
  002d7	00		 DB	 0
  002d8	01		 DB	 1
  002d9	00		 DB	 0
  002da	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ$0:
  00000	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ$2:
  0000b	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR _device$6[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1Device@GostCrypt@@QAE@XZ
__ehhandler$?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a 5c fc ff
	ff		 mov	 ecx, DWORD PTR [edx-932]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SystemDriveContainsNonStandardPartitions@BootEncryption@GostCrypt@@QAE_NXZ ENDP ; GostCrypt::BootEncryption::SystemDriveContainsNonStandardPartitions
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?SystemDriveContainsExtendedPartition@BootEncryption@GostCrypt@@QAE_NXZ
_TEXT	SEGMENT
?SystemDriveContainsExtendedPartition@BootEncryption@GostCrypt@@QAE_NXZ PROC ; GostCrypt::BootEncryption::SystemDriveContainsExtendedPartition, COMDAT
; _this$ = ecx

; 1146 : 	{

  00000	56		 push	 esi

; 1147 : 		return SystemDriveContainsPartitionType (PARTITION_EXTENDED) || SystemDriveContainsPartitionType (PARTITION_XINT13_EXTENDED);

  00001	6a 05		 push	 5
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z ; GostCrypt::BootEncryption::SystemDriveContainsPartitionType
  0000a	84 c0		 test	 al, al
  0000c	75 0f		 jne	 SHORT $LN3@SystemDriv
  0000e	6a 0f		 push	 15			; 0000000fH
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z ; GostCrypt::BootEncryption::SystemDriveContainsPartitionType
  00017	84 c0		 test	 al, al
  00019	75 02		 jne	 SHORT $LN3@SystemDriv
  0001b	5e		 pop	 esi

; 1148 : 	}

  0001c	c3		 ret	 0
$LN3@SystemDriv:

; 1147 : 		return SystemDriveContainsPartitionType (PARTITION_EXTENDED) || SystemDriveContainsPartitionType (PARTITION_XINT13_EXTENDED);

  0001d	b0 01		 mov	 al, 1
  0001f	5e		 pop	 esi

; 1148 : 	}

  00020	c3		 ret	 0
?SystemDriveContainsExtendedPartition@BootEncryption@GostCrypt@@QAE_NXZ ENDP ; GostCrypt::BootEncryption::SystemDriveContainsExtendedPartition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z
_TEXT	SEGMENT
_pos$2 = -908						; size = 8
$T3 = -908						; size = 8
$T4 = -908						; size = 8
$T5 = -900						; size = 320
_device$ = -580						; size = 48
_mbrBuf$ = -532						; size = 512
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 1
?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z PROC ; GostCrypt::BootEncryption::SystemDriveContainsPartitionType, COMDAT
; _this$ = ecx

; 1117 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 80 03 00
	00		 sub	 esp, 896		; 00000380H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1118 : 		Device device (GetSystemDriveConfiguration().DevicePath, true);

  0002b	6a 01		 push	 1
  0002d	8d 85 7c fc ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  00039	83 ec 18	 sub	 esp, 24			; 00000018H
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	8b cc		 mov	 ecx, esp
  00045	8d 50 18	 lea	 edx, DWORD PTR [eax+24]
  00048	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0004f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00056	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0005a	72 04		 jb	 SHORT $LN126@SystemDriv
  0005c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005e	eb 02		 jmp	 SHORT $LN127@SystemDriv
$LN126@SystemDriv:
  00060	8b c1		 mov	 eax, ecx
$LN127@SystemDriv:
  00062	52		 push	 edx
  00063	c6 00 00	 mov	 BYTE PTR [eax], 0
  00066	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0006b	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00071	e8 00 00 00 00	 call	 ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device
  00076	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0007c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00080	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 1119 : 
; 1120 : 		byte mbrBuf[GST_SECTOR_SIZE_BIOS];
; 1121 : 		device.SeekAt (0);

  00085	80 bd bc fd ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  0008c	0f 57 c0	 xorps	 xmm0, xmm0
  0008f	66 0f 13 85 c4
	fd ff ff	 movlpd	 QWORD PTR _device$[ebp+8], xmm0
  00097	75 4f		 jne	 SHORT $LN138@SystemDriv
  00099	6a 00		 push	 0
  0009b	6a 00		 push	 0
  0009d	66 0f 13 85 74
	fc ff ff	 movlpd	 QWORD PTR _pos$2[ebp], xmm0
  000a5	ff b5 78 fc ff
	ff		 push	 DWORD PTR _pos$2[ebp+4]
  000ab	ff b5 74 fc ff
	ff		 push	 DWORD PTR _pos$2[ebp]
  000b1	ff b5 cc fd ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  000bd	85 c0		 test	 eax, eax
  000bf	75 27		 jne	 SHORT $LN138@SystemDriv
  000c1	c7 85 74 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000d1	89 85 78 fc ff
	ff		 mov	 DWORD PTR $T3[ebp+4], eax
  000d7	8d 85 74 fc ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000dd	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN401@SystemDriv:
$LN138@SystemDriv:

; 1122 : 		device.Read (mbrBuf, sizeof (mbrBuf));

  000e8	68 00 02 00 00	 push	 512			; 00000200H
  000ed	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _mbrBuf$[ebp]
  000f3	50		 push	 eax
  000f4	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  000fa	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read

; 1123 : 
; 1124 : 		MBR *mbr = reinterpret_cast <MBR *> (mbrBuf);
; 1125 : 		if (mbr->Signature != 0xaa55)

  000ff	b8 55 aa 00 00	 mov	 eax, 43605		; 0000aa55H
  00104	66 39 45 ea	 cmp	 WORD PTR _mbrBuf$[ebp+510], ax
  00108	74 25		 je	 SHORT $LN5@SystemDriv

; 1126 : 			throw ParameterIncorrect (SRC_POS);

  0010a	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  0010f	8d 85 74 fc ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00115	c7 85 74 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0011f	50		 push	 eax
  00120	c7 85 78 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+4], OFFSET ??_C@_0EB@HMOPBABC@GostCrypt?3?3BootEncryption?3?3Syste@
  0012a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN402@SystemDriv:
$LN5@SystemDriv:

; 1127 : 
; 1128 : 		for (size_t i = 0; i < array_capacity (mbr->Partitions); ++i)

  0012f	8a 55 08	 mov	 dl, BYTE PTR _type$[ebp]
  00132	8d 45 ae	 lea	 eax, DWORD PTR _mbrBuf$[ebp+450]
  00135	33 c9		 xor	 ecx, ecx
$LL4@SystemDriv:

; 1129 : 		{
; 1130 : 			if (mbr->Partitions[i].Type == type)

  00137	38 10		 cmp	 BYTE PTR [eax], dl
  00139	0f 84 82 00 00
	00		 je	 $LN395@SystemDriv

; 1127 : 
; 1128 : 		for (size_t i = 0; i < array_capacity (mbr->Partitions); ++i)

  0013f	41		 inc	 ecx
  00140	83 c0 10	 add	 eax, 16			; 00000010H
  00143	83 f9 04	 cmp	 ecx, 4
  00146	72 ef		 jb	 SHORT $LL4@SystemDriv

; 1132 : 		}
; 1133 : 
; 1134 : 		return false;

  00148	80 bd bd fd ff
	ff 00		 cmp	 BYTE PTR _device$[ebp+1], 0
  0014f	74 1c		 je	 SHORT $LN272@SystemDriv
  00151	80 bd bc fd ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  00158	75 0c		 jne	 SHORT $LN273@SystemDriv
  0015a	ff b5 cc fd ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  00160	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN273@SystemDriv:
  00166	c6 85 bd fd ff
	ff 00		 mov	 BYTE PTR _device$[ebp+1], 0
$LN272@SystemDriv:
  0016d	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _device$[ebp+44]
  00173	83 f8 10	 cmp	 eax, 16			; 00000010H
  00176	72 45		 jb	 SHORT $LN361@SystemDriv
  00178	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _device$[ebp+24]
  0017e	40		 inc	 eax
  0017f	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00184	72 2e		 jb	 SHORT $LN356@SystemDriv
  00186	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00189	74 05		 je	 SHORT $LN357@SystemDriv
  0018b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN403@SystemDriv:
$LN357@SystemDriv:
  00190	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00193	3b c1		 cmp	 eax, ecx
  00195	72 05		 jb	 SHORT $LN358@SystemDriv
  00197	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN404@SystemDriv:
$LN358@SystemDriv:
  0019c	2b c8		 sub	 ecx, eax
  0019e	83 f9 04	 cmp	 ecx, 4
  001a1	73 05		 jae	 SHORT $LN359@SystemDriv
  001a3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN405@SystemDriv:
$LN359@SystemDriv:
  001a8	83 f9 23	 cmp	 ecx, 35			; 00000023H
  001ab	76 05		 jbe	 SHORT $LN360@SystemDriv
  001ad	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN406@SystemDriv:
$LN360@SystemDriv:
  001b2	8b c8		 mov	 ecx, eax
$LN356@SystemDriv:
  001b4	51		 push	 ecx
  001b5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001ba	83 c4 04	 add	 esp, 4
$LN361@SystemDriv:
  001bd	32 c0		 xor	 al, al
  001bf	eb 45		 jmp	 SHORT $LN1@SystemDriv
$LN395@SystemDriv:

; 1131 : 				return true;

  001c1	80 bd bd fd ff
	ff 00		 cmp	 BYTE PTR _device$[ebp+1], 0
  001c8	74 1c		 je	 SHORT $LN161@SystemDriv
  001ca	80 bd bc fd ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  001d1	75 0c		 jne	 SHORT $LN162@SystemDriv
  001d3	ff b5 cc fd ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  001d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN162@SystemDriv:
  001df	c6 85 bd fd ff
	ff 00		 mov	 BYTE PTR _device$[ebp+1], 0
$LN161@SystemDriv:
  001e6	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _device$[ebp+44]
  001ec	83 f8 10	 cmp	 eax, 16			; 00000010H
  001ef	72 13		 jb	 SHORT $LN170@SystemDriv
  001f1	40		 inc	 eax
  001f2	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp+24]
  001f8	50		 push	 eax
  001f9	ff b5 d4 fd ff
	ff		 push	 DWORD PTR _device$[ebp+24]
  001ff	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN170@SystemDriv:
  00204	b0 01		 mov	 al, 1
$LN1@SystemDriv:

; 1135 : 	}

  00206	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00209	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00210	59		 pop	 ecx
  00211	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00214	33 cd		 xor	 ecx, ebp
  00216	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021b	8b e5		 mov	 esp, ebp
  0021d	5d		 pop	 ebp
  0021e	c2 04 00	 ret	 4
$LN400@SystemDriv:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z$0:
  00000	8d 8d 7c fc ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z$2:
  0000b	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1Device@GostCrypt@@QAE@XZ
__ehhandler$?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a 7c fc ff
	ff		 mov	 ecx, DWORD PTR [edx-900]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SystemDriveContainsPartitionType@BootEncryption@GostCrypt@@QAE_NE@Z ENDP ; GostCrypt::BootEncryption::SystemDriveContainsPartitionType
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?StartEncryption@BootEncryption@GostCrypt@@QAEXW4WipeAlgorithmId@@_N@Z
_TEXT	SEGMENT
$T1 = -124						; size = 8
_encStatus$ = -116					; size = 94
_request$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_wipeAlgorithm$ = 8					; size = 4
_zeroUnreadableSectors$ = 12				; size = 1
?StartEncryption@BootEncryption@GostCrypt@@QAEXW4WipeAlgorithmId@@_N@Z PROC ; GostCrypt::BootEncryption::StartEncryption, COMDAT
; _this$ = ecx

; 3063 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 3064 : 		BootEncryptionStatus encStatus = GetStatus();

  00011	6a 5e		 push	 94			; 0000005eH
  00013	8d 45 8c	 lea	 eax, DWORD PTR _encStatus$[ebp]
  00016	8b f1		 mov	 esi, ecx
  00018	50		 push	 eax
  00019	6a 00		 push	 0
  0001b	6a 00		 push	 0
  0001d	68 48 20 22 00	 push	 2236488			; 00222048H
  00022	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 3065 : 
; 3066 : 		if (!encStatus.DeviceFilterActive || !encStatus.DriveMounted || encStatus.SetupInProgress)

  00027	83 7d 8c 00	 cmp	 DWORD PTR _encStatus$[ebp], 0
  0002b	74 4e		 je	 SHORT $LN13@StartEncry
  0002d	83 7d 92 00	 cmp	 DWORD PTR _encStatus$[ebp+6], 0
  00031	74 48		 je	 SHORT $LN13@StartEncry
  00033	83 7d ca 00	 cmp	 DWORD PTR _encStatus$[ebp+62], 0
  00037	75 42		 jne	 SHORT $LN13@StartEncry

; 3068 : 
; 3069 : 		BootEncryptionSetupRequest request;
; 3070 : 		ZeroMemory (&request, sizeof (request));
; 3071 : 		
; 3072 : 		request.SetupMode = SetupEncryption;
; 3073 : 		request.WipeAlgorithm = wipeAlgorithm;

  00039	8b 45 08	 mov	 eax, DWORD PTR _wipeAlgorithm$[ebp]
  0003c	0f 57 c0	 xorps	 xmm0, xmm0
  0003f	0f 11 45 ec	 movups	 XMMWORD PTR _request$[ebp], xmm0

; 3074 : 		request.ZeroUnreadableSectors = zeroUnreadableSectors;
; 3075 : 
; 3076 : 		CallDriver (GST_IOCTL_BOOT_ENCRYPTION_SETUP, &request, sizeof (request), NULL, 0);

  00043	6a 00		 push	 0
  00045	89 45 f0	 mov	 DWORD PTR _request$[ebp+4], eax
  00048	8b ce		 mov	 ecx, esi
  0004a	0f b6 45 0c	 movzx	 eax, BYTE PTR _zeroUnreadableSectors$[ebp]
  0004e	6a 00		 push	 0
  00050	89 45 f4	 mov	 DWORD PTR _request$[ebp+8], eax
  00053	8d 45 ec	 lea	 eax, DWORD PTR _request$[ebp]
  00056	6a 10		 push	 16			; 00000010H
  00058	50		 push	 eax
  00059	68 4c 20 22 00	 push	 2236492			; 0022204cH
  0005e	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _request$[ebp], 1
  00065	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 3077 : 	}

  0006a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006d	33 cd		 xor	 ecx, ebp
  0006f	5e		 pop	 esi
  00070	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 08 00	 ret	 8
$LN13@StartEncry:

; 3067 : 			throw ParameterIncorrect (SRC_POS);

  0007b	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00080	8d 45 84	 lea	 eax, DWORD PTR $T1[ebp]
  00083	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0008a	50		 push	 eax
  0008b	c7 45 88 00 00
	00 00		 mov	 DWORD PTR $T1[ebp+4], OFFSET ??_C@_0DA@BCJAFCLE@GostCrypt?3?3BootEncryption?3?3Start@
  00092	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@StartEncry:
$LN12@StartEncry:
  00097	cc		 int	 3
?StartEncryption@BootEncryption@GostCrypt@@QAEXW4WipeAlgorithmId@@_N@Z ENDP ; GostCrypt::BootEncryption::StartEncryption
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?StartDecoyOSWipe@BootEncryption@GostCrypt@@QAEXW4WipeAlgorithmId@@@Z
_TEXT	SEGMENT
$T1 = -288						; size = 8
$T2 = -280						; size = 8
$T3 = -272						; size = 8
_request$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_wipeAlgorithm$ = 8					; size = 4
?StartDecoyOSWipe@BootEncryption@GostCrypt@@QAEXW4WipeAlgorithmId@@@Z PROC ; GostCrypt::BootEncryption::StartDecoyOSWipe, COMDAT
; _this$ = ecx

; 1639 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx

; 1640 : 		if (!IsHiddenOSRunning())

  00016	e8 00 00 00 00	 call	 _IsHiddenOSRunning
  0001b	85 c0		 test	 eax, eax
  0001d	0f 84 a8 00 00
	00		 je	 $LN46@StartDecoy

; 1642 : 
; 1643 : 		WipeDecoySystemRequest request;
; 1644 : 		ZeroMemory (&request, sizeof (request));

  00023	68 04 01 00 00	 push	 260			; 00000104H
  00028	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _request$[ebp]
  0002e	6a 00		 push	 0
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _memset

; 1645 : 
; 1646 : 		request.WipeAlgorithm = wipeAlgorithm;

  00036	8b 45 08	 mov	 eax, DWORD PTR _wipeAlgorithm$[ebp]
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _request$[ebp], eax

; 1647 : 		
; 1648 : 		if (Randinit() != ERR_SUCCESS)

  00042	e8 00 00 00 00	 call	 _Randinit
  00047	85 c0		 test	 eax, eax
  00049	0f 85 a1 00 00
	00		 jne	 $LN48@StartDecoy

; 1650 : 
; 1651 : 		UserEnrichRandomPool (ParentWindow);

  0004f	ff 36		 push	 DWORD PTR [esi]
  00051	e8 00 00 00 00	 call	 _UserEnrichRandomPool

; 1652 : 
; 1653 : 		if (!RandgetBytes (request.WipeKey, sizeof (request.WipeKey), TRUE))

  00056	6a 01		 push	 1
  00058	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _request$[ebp+4]
  0005e	68 00 01 00 00	 push	 256			; 00000100H
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _RandgetBytes
  00069	83 c4 10	 add	 esp, 16			; 00000010H
  0006c	85 c0		 test	 eax, eax
  0006e	0f 84 a1 00 00
	00		 je	 $LN49@StartDecoy

; 1655 : 
; 1656 : 		CallDriver (GST_IOCTL_START_DECOY_SYSTEM_WIPE, &request, sizeof (request), NULL, 0);

  00074	6a 00		 push	 0
  00076	6a 00		 push	 0
  00078	68 04 01 00 00	 push	 260			; 00000104H
  0007d	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _request$[ebp]
  00083	8b ce		 mov	 ecx, esi
  00085	50		 push	 eax
  00086	68 78 20 22 00	 push	 2236536			; 00222078H
  0008b	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 1657 : 
; 1658 : 		burn (&request, sizeof (request));

  00090	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _request$[ebp]
  00096	b9 04 01 00 00	 mov	 ecx, 260		; 00000104H
  0009b	8b f1		 mov	 esi, ecx
  0009d	8b d0		 mov	 edx, eax
  0009f	90		 npad	 1
$LL27@StartDecoy:
  000a0	c6 02 00	 mov	 BYTE PTR [edx], 0
  000a3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000a6	83 ee 01	 sub	 esi, 1
  000a9	75 f5		 jne	 SHORT $LL27@StartDecoy
  000ab	5e		 pop	 esi
  000ac	0f 1f 40 00	 npad	 4
$LL5@StartDecoy:
  000b0	c6 00 00	 mov	 BYTE PTR [eax], 0
  000b3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  000b6	83 e9 01	 sub	 ecx, 1
  000b9	75 f5		 jne	 SHORT $LL5@StartDecoy

; 1659 : 	}

  000bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000be	33 cd		 xor	 ecx, ebp
  000c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 04 00	 ret	 4
$LN46@StartDecoy:

; 1641 : 			throw ParameterIncorrect (SRC_POS);

  000cb	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  000d0	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000d6	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  000e0	50		 push	 eax
  000e1	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp+4], OFFSET ??_C@_0DB@GOMJMIPK@GostCrypt?3?3BootEncryption?3?3Start@
  000eb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN50@StartDecoy:
$LN48@StartDecoy:

; 1649 : 			throw ParameterIncorrect (SRC_POS);

  000f0	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  000f5	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000fb	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00105	50		 push	 eax
  00106	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_0DB@KGBAECPC@GostCrypt?3?3BootEncryption?3?3Start@
  00110	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN51@StartDecoy:
$LN49@StartDecoy:

; 1654 : 			throw ParameterIncorrect (SRC_POS);

  00115	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  0011a	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00120	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0012a	50		 push	 eax
  0012b	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp+4], OFFSET ??_C@_0DB@BCHMFGII@GostCrypt?3?3BootEncryption?3?3Start@
  00135	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN52@StartDecoy:
$LN45@StartDecoy:
  0013a	cc		 int	 3
?StartDecoyOSWipe@BootEncryption@GostCrypt@@QAEXW4WipeAlgorithmId@@@Z ENDP ; GostCrypt::BootEncryption::StartDecoyOSWipe
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?StartDecryption@BootEncryption@GostCrypt@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -124						; size = 8
_encStatus$ = -116					; size = 94
_request$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_discardUnreadableEncryptedSectors$ = 8			; size = 4
?StartDecryption@BootEncryption@GostCrypt@@QAEXH@Z PROC	; GostCrypt::BootEncryption::StartDecryption, COMDAT
; _this$ = ecx

; 3038 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 3039 : 		BootEncryptionStatus encStatus = GetStatus();

  00011	6a 5e		 push	 94			; 0000005eH
  00013	8d 45 8c	 lea	 eax, DWORD PTR _encStatus$[ebp]
  00016	8b f1		 mov	 esi, ecx
  00018	50		 push	 eax
  00019	6a 00		 push	 0
  0001b	6a 00		 push	 0
  0001d	68 48 20 22 00	 push	 2236488			; 00222048H
  00022	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 3040 : 
; 3041 : 		if (!encStatus.DeviceFilterActive || !encStatus.DriveMounted || encStatus.SetupInProgress)

  00027	83 7d 8c 00	 cmp	 DWORD PTR _encStatus$[ebp], 0
  0002b	74 47		 je	 SHORT $LN13@StartDecry
  0002d	83 7d 92 00	 cmp	 DWORD PTR _encStatus$[ebp+6], 0
  00031	74 41		 je	 SHORT $LN13@StartDecry
  00033	83 7d ca 00	 cmp	 DWORD PTR _encStatus$[ebp+62], 0
  00037	75 3b		 jne	 SHORT $LN13@StartDecry

; 3043 : 
; 3044 : 		BootEncryptionSetupRequest request;
; 3045 : 		ZeroMemory (&request, sizeof (request));
; 3046 : 		
; 3047 : 		request.SetupMode = SetupDecryption;
; 3048 : 		request.DiscardUnreadableEncryptedSectors = discardUnreadableEncryptedSectors;

  00039	8b 45 08	 mov	 eax, DWORD PTR _discardUnreadableEncryptedSectors$[ebp]
  0003c	0f 57 c0	 xorps	 xmm0, xmm0

; 3049 : 
; 3050 : 		CallDriver (GST_IOCTL_BOOT_ENCRYPTION_SETUP, &request, sizeof (request), NULL, 0);

  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	0f 11 45 ec	 movups	 XMMWORD PTR _request$[ebp], xmm0
  00047	89 45 f8	 mov	 DWORD PTR _request$[ebp+12], eax
  0004a	8b ce		 mov	 ecx, esi
  0004c	6a 10		 push	 16			; 00000010H
  0004e	8d 45 ec	 lea	 eax, DWORD PTR _request$[ebp]
  00051	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _request$[ebp], 2
  00058	50		 push	 eax
  00059	68 4c 20 22 00	 push	 2236492			; 0022204cH
  0005e	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 3051 : 	}

  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	33 cd		 xor	 ecx, ebp
  00068	5e		 pop	 esi
  00069	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN13@StartDecry:

; 3042 : 			throw ParameterIncorrect (SRC_POS);

  00074	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00079	8d 45 84	 lea	 eax, DWORD PTR $T1[ebp]
  0007c	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00083	50		 push	 eax
  00084	c7 45 88 00 00
	00 00		 mov	 DWORD PTR $T1[ebp+4], OFFSET ??_C@_0DA@BMPPEFPA@GostCrypt?3?3BootEncryption?3?3Start@
  0008b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@StartDecry:
$LN12@StartDecry:
  00090	cc		 int	 3
?StartDecryption@BootEncryption@GostCrypt@@QAEXH@Z ENDP	; GostCrypt::BootEncryption::StartDecryption
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?SetHiddenOSCreationPhase@BootEncryption@GostCrypt@@QAEXI@Z
_TEXT	SEGMENT
_configFlags$ = -1					; size = 1
_newPhase$ = 8						; size = 4
?SetHiddenOSCreationPhase@BootEncryption@GostCrypt@@QAEXI@Z PROC ; GostCrypt::BootEncryption::SetHiddenOSCreationPhase, COMDAT
; _this$ = ecx

; 1612 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1613 : #if GST_BOOT_CFG_FLAG_AREA_SIZE != 1
; 1614 : #	error GST_BOOT_CFG_FLAG_AREA_SIZE != 1; revise GetHiddenOSCreationPhase() and SetHiddenOSCreationPhase()
; 1615 : #endif
; 1616 : 		byte configFlags [GST_BOOT_CFG_FLAG_AREA_SIZE];
; 1617 : 
; 1618 : 		ReadBootSectorConfig (configFlags, sizeof(configFlags));

  00005	6a 00		 push	 0
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	6a 01		 push	 1
  0000d	8d 45 ff	 lea	 eax, DWORD PTR _configFlags$[ebp]
  00010	8b f1		 mov	 esi, ecx
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z ; GostCrypt::BootEncryption::ReadBootSectorConfig

; 1619 : 
; 1620 : 		configFlags[0] &= (byte) ~GST_BOOT_CFG_MASK_HIDDEN_OS_CREATION_PHASE;

  00018	8a 45 ff	 mov	 al, BYTE PTR _configFlags$[ebp]

; 1621 : 
; 1622 : 		configFlags[0] |= newPhase;
; 1623 : 
; 1624 : 		WriteBootSectorConfig (configFlags);

  0001b	8b ce		 mov	 ecx, esi
  0001d	24 3f		 and	 al, 63			; 0000003fH
  0001f	0a 45 08	 or	 al, BYTE PTR _newPhase$[ebp]
  00022	88 45 ff	 mov	 BYTE PTR _configFlags$[ebp], al
  00025	8d 45 ff	 lea	 eax, DWORD PTR _configFlags$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z ; GostCrypt::BootEncryption::WriteBootSectorConfig
  0002e	5e		 pop	 esi

; 1625 : 	}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?SetHiddenOSCreationPhase@BootEncryption@GostCrypt@@QAEXI@Z ENDP ; GostCrypt::BootEncryption::SetHiddenOSCreationPhase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z
_TEXT	SEGMENT
$T2 = -500						; size = 8
_finally793$ = -496					; size = 4
$T3 = -492						; size = 8
_finally798$ = -488					; size = 4
$T4 = -484						; size = 8
$T5 = -476						; size = 24
_path$6 = -452						; size = 24
_driverPath$ = -428					; size = 24
_pathBuf$7 = -404					; size = 260
_filesystem$8 = -144					; size = 128
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_startType$ = 8						; size = 4
?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z PROC ; GostCrypt::BootEncryption::SetDriverServiceStartType, COMDAT
; _this$ = ecx

; 781  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec e8 01 00
	00		 sub	 esp, 488		; 000001e8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b d9		 mov	 ebx, ecx

; 782  : 		if (!IsAdmin() && IsUacSupported())

  00030	e8 00 00 00 00	 call	 _IsAdmin
  00035	85 c0		 test	 eax, eax
  00037	75 19		 jne	 SHORT $LN17@SetDriverS
  00039	e8 00 00 00 00	 call	 _IsUacSupported
  0003e	85 c0		 test	 eax, eax
  00040	74 10		 je	 SHORT $LN17@SetDriverS

; 783  : 		{
; 784  : 			Elevator::SetDriverServiceStartType (startType);

  00042	ff 75 08	 push	 DWORD PTR _startType$[ebp]
  00045	e8 00 00 00 00	 call	 ?SetDriverServiceStartType@Elevator@GostCrypt@@SAXK@Z ; GostCrypt::Elevator::SetDriverServiceStartType
  0004a	83 c4 04	 add	 esp, 4

; 785  : 			return;

  0004d	e9 be 02 00 00	 jmp	 $LN1@SetDriverS
$LN17@SetDriverS:

; 786  : 		}
; 787  : 
; 788  : 		BOOL startOnBoot = (startType == SERVICE_BOOT_START);
; 789  : 
; 790  : 		SC_HANDLE serviceManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);

  00052	68 3f 00 0f 00	 push	 983103			; 000f003fH
  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenSCManagerA@12

; 791  : 		throw_sys_if (!serviceManager);

  00061	85 c0		 test	 eax, eax
  00063	75 27		 jne	 SHORT $LN2@SetDriverS
  00065	c7 85 0c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00075	89 85 10 fe ff
	ff		 mov	 DWORD PTR $T2[ebp+4], eax
  0007b	8d 85 0c fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00081	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN236@SetDriverS:
$LN2@SetDriverS:

; 792  : 
; 793  : 		finally_do_arg (SC_HANDLE, serviceManager, { CloseServiceHandle (finally_arg); });

  0008c	89 85 10 fe ff
	ff		 mov	 DWORD PTR _finally793$[ebp], eax

; 794  : 
; 795  : 		SC_HANDLE service = OpenService (serviceManager, "gostcrypt", SERVICE_CHANGE_CONFIG);

  00092	6a 02		 push	 2
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_09JCILFBFB@gostcrypt?$AA@
  00099	50		 push	 eax
  0009a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenServiceA@12
  000a7	8b f8		 mov	 edi, eax

; 796  : 		throw_sys_if (!service);

  000a9	85 ff		 test	 edi, edi
  000ab	75 27		 jne	 SHORT $LN5@SetDriverS
  000ad	c7 85 14 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000bd	89 85 18 fe ff
	ff		 mov	 DWORD PTR $T3[ebp+4], eax
  000c3	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000c9	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN237@SetDriverS:
$LN5@SetDriverS:

; 797  : 
; 798  : 		finally_do_arg (SC_HANDLE, service, { CloseServiceHandle (finally_arg); });

  000d4	89 bd 18 fe ff
	ff		 mov	 DWORD PTR _finally798$[ebp], edi

; 799  : 
; 800  : 		// Windows versions preceding Vista can be installed on FAT filesystem which does not
; 801  : 		// support long filenames during boot. Convert the driver path to short form if required.
; 802  : 		string driverPath;

  000da	c7 85 68 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _driverPath$[ebp+20], 15 ; 0000000fH
  000e4	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _driverPath$[ebp+16], 0
  000ee	c6 85 54 fe ff
	ff 00		 mov	 BYTE PTR _driverPath$[ebp], 0
  000f5	8b 75 08	 mov	 esi, DWORD PTR _startType$[ebp]
  000f8	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000fc	85 f6		 test	 esi, esi

; 803  : 		if (startOnBoot && !IsOSAtLeast (WIN_VISTA))

  000fe	0f 85 99 01 00
	00		 jne	 $LN232@SetDriverS
  00104	6a 0b		 push	 11			; 0000000bH
  00106	e8 00 00 00 00	 call	 _IsOSAtLeast
  0010b	83 c4 04	 add	 esp, 4
  0010e	85 c0		 test	 eax, eax
  00110	0f 85 68 01 00
	00		 jne	 $LN13@SetDriverS

; 804  : 		{
; 805  : 			char pathBuf[MAX_PATH];
; 806  : 			char filesystem[128];
; 807  : 
; 808  : 			string path (GetWindowsDirectory());

  00116	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR _path$6[ebp]
  0011c	8b cb		 mov	 ecx, ebx
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ?GetWindowsDirectoryA@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GostCrypt::BootEncryption::GetWindowsDirectoryA

; 809  : 			path += "\\drivers\\gostcrypt.sys";

  00124	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@EJBOALFB@?2drivers?2gostcrypt?4sys?$AA@
  00129	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR _path$6[ebp]
  0012f	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00133	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 810  : 
; 811  : 			if (GetVolumePathName (path.c_str(), pathBuf, sizeof (pathBuf))
; 812  : 				&& GetVolumeInformation (pathBuf, NULL, 0, NULL, NULL, NULL, filesystem, sizeof(filesystem))
; 813  : 				&& memcmp (filesystem, "FAT", 3) == 0)

  00138	83 bd 50 fe ff
	ff 10		 cmp	 DWORD PTR _path$6[ebp+20], 16 ; 00000010H
  0013f	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR _pathBuf$7[ebp]
  00145	68 04 01 00 00	 push	 260			; 00000104H
  0014a	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR _path$6[ebp]
  00150	0f 43 85 3c fe
	ff ff		 cmovae	 eax, DWORD PTR _path$6[ebp]
  00157	51		 push	 ecx
  00158	50		 push	 eax
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVolumePathNameA@12
  0015f	85 c0		 test	 eax, eax
  00161	0f 84 08 01 00
	00		 je	 $LN21@SetDriverS
  00167	68 80 00 00 00	 push	 128			; 00000080H
  0016c	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _filesystem$8[ebp]
  00172	50		 push	 eax
  00173	56		 push	 esi
  00174	56		 push	 esi
  00175	56		 push	 esi
  00176	56		 push	 esi
  00177	56		 push	 esi
  00178	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR _pathBuf$7[ebp]
  0017e	50		 push	 eax
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVolumeInformationA@32
  00185	85 c0		 test	 eax, eax
  00187	0f 84 e2 00 00
	00		 je	 $LN21@SetDriverS
  0018d	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _filesystem$8[ebp]
  00193	66 81 39 46 41	 cmp	 WORD PTR [ecx], 16710	; 00004146H
  00198	0f 85 d1 00 00
	00		 jne	 $LN21@SetDriverS
  0019e	80 79 02 54	 cmp	 BYTE PTR [ecx+2], 84	; 00000054H
  001a2	0f 85 c7 00 00
	00		 jne	 $LN21@SetDriverS

; 814  : 			{
; 815  : 				throw_sys_if (GetShortPathName (path.c_str(), pathBuf, sizeof (pathBuf)) == 0);

  001a8	83 bd 50 fe ff
	ff 10		 cmp	 DWORD PTR _path$6[ebp+20], 16 ; 00000010H
  001af	8d 8d 6c fe ff
	ff		 lea	 ecx, DWORD PTR _pathBuf$7[ebp]
  001b5	68 04 01 00 00	 push	 260			; 00000104H
  001ba	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR _path$6[ebp]
  001c0	0f 43 85 3c fe
	ff ff		 cmovae	 eax, DWORD PTR _path$6[ebp]
  001c7	51		 push	 ecx
  001c8	50		 push	 eax
  001c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetShortPathNameA@12
  001cf	85 c0		 test	 eax, eax
  001d1	75 27		 jne	 SHORT $LN8@SetDriverS
$LN235@SetDriverS:
  001d3	c7 85 1c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  001dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001e3	89 85 20 fe ff
	ff		 mov	 DWORD PTR $T4[ebp+4], eax
  001e9	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001ef	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  001f4	50		 push	 eax
  001f5	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN238@SetDriverS:
$LN8@SetDriverS:

; 816  : 
; 817  : 				// Convert absolute path to relative to the Windows directory
; 818  : 				driverPath = pathBuf;

  001fa	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR _pathBuf$7[ebp]
  00200	50		 push	 eax
  00201	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR _driverPath$[ebp]
  00207	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 819  : 				driverPath = driverPath.substr (driverPath.rfind ("\\", driverPath.rfind ("\\", driverPath.rfind ("\\") - 1) - 1) + 1);

  0020c	6a ff		 push	 -1
  0020e	6a ff		 push	 -1
  00210	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2?$AA@
  00215	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR _driverPath$[ebp]
  0021b	e8 00 00 00 00	 call	 ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
  00220	48		 dec	 eax
  00221	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR _driverPath$[ebp]
  00227	50		 push	 eax
  00228	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2?$AA@
  0022d	e8 00 00 00 00	 call	 ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
  00232	48		 dec	 eax
  00233	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR _driverPath$[ebp]
  00239	50		 push	 eax
  0023a	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2?$AA@
  0023f	e8 00 00 00 00	 call	 ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
  00244	40		 inc	 eax
  00245	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR _driverPath$[ebp]
  0024b	50		 push	 eax
  0024c	8d 85 24 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00252	50		 push	 eax
  00253	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  00258	50		 push	 eax
  00259	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR _driverPath$[ebp]
  0025f	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  00264	8d 8d 24 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0026a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN21@SetDriverS:

; 820  : 			}
; 821  : 		}

  0026f	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR _path$6[ebp]
  00275	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00279	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN13@SetDriverS:

; 822  : 
; 823  : 		throw_sys_if (!ChangeServiceConfig (service, SERVICE_NO_CHANGE, SERVICE_NO_CHANGE,

  0027e	83 bd 64 fe ff
	ff 00		 cmp	 DWORD PTR _driverPath$[ebp+16], 0
  00285	74 16		 je	 SHORT $LN232@SetDriverS
  00287	83 bd 68 fe ff
	ff 10		 cmp	 DWORD PTR _driverPath$[ebp+20], 16 ; 00000010H
  0028e	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR _driverPath$[ebp]
  00294	0f 43 8d 54 fe
	ff ff		 cmovae	 ecx, DWORD PTR _driverPath$[ebp]
  0029b	eb 02		 jmp	 SHORT $LN206@SetDriverS
$LN232@SetDriverS:
  0029d	33 c9		 xor	 ecx, ecx
$LN206@SetDriverS:
  0029f	6a 00		 push	 0
  002a1	6a 00		 push	 0
  002a3	6a 00		 push	 0
  002a5	6a 00		 push	 0
  002a7	33 d2		 xor	 edx, edx
  002a9	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06IBDJIBGI@Filter?$AA@
  002ae	6a 00		 push	 0
  002b0	85 f6		 test	 esi, esi
  002b2	0f 45 c2	 cmovne	 eax, edx
  002b5	50		 push	 eax
  002b6	8b c6		 mov	 eax, esi
  002b8	f7 d8		 neg	 eax
  002ba	51		 push	 ecx
  002bb	1b c0		 sbb	 eax, eax
  002bd	83 c0 02	 add	 eax, 2
  002c0	50		 push	 eax
  002c1	6a ff		 push	 -1
  002c3	6a ff		 push	 -1
  002c5	57		 push	 edi
  002c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ChangeServiceConfigA@44
  002cc	85 c0		 test	 eax, eax
  002ce	0f 84 ff fe ff
	ff		 je	 $LN235@SetDriverS

; 824  : 			startOnBoot ? SERVICE_ERROR_SEVERE : SERVICE_ERROR_NORMAL,
; 825  : 			driverPath.empty() ? NULL : driverPath.c_str(),
; 826  : 			startOnBoot ? "Filter" : NULL,
; 827  : 			NULL, NULL, NULL, NULL, NULL));
; 828  : 
; 829  : 		// ChangeServiceConfig() rejects SERVICE_BOOT_START with ERROR_INVALID_PARAMETER
; 830  : 		throw_sys_if (!WriteLocalMachineRegistryDword ("SYSTEM\\CurrentControlSet\\Services\\gostcrypt", "Start", startType));

  002d4	56		 push	 esi
  002d5	68 00 00 00 00	 push	 OFFSET ??_C@_05FHMJPCKA@Start?$AA@
  002da	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LCJDGIOL@SYSTEM?2CurrentControlSet?2Service@
  002df	e8 00 00 00 00	 call	 _WriteLocalMachineRegistryDword
  002e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002e7	85 c0		 test	 eax, eax
  002e9	0f 84 e4 fe ff
	ff		 je	 $LN235@SetDriverS

; 831  : 	}

  002ef	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR _driverPath$[ebp]
  002f5	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  002fa	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _finally798$[ebp]
  00300	e8 00 00 00 00	 call	 ??1Finally798@?1??SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z@QAE@XZ ; `GostCrypt::BootEncryption::SetDriverServiceStartType'::`2'::Finally798::~Finally798
  00305	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR _finally793$[ebp]
  0030b	e8 00 00 00 00	 call	 ??1Finally793@?1??SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z@QAE@XZ ; `GostCrypt::BootEncryption::SetDriverServiceStartType'::`2'::Finally793::~Finally793
$LN1@SetDriverS:
  00310	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00313	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0031a	59		 pop	 ecx
  0031b	5f		 pop	 edi
  0031c	5e		 pop	 esi
  0031d	5b		 pop	 ebx
  0031e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00321	33 cd		 xor	 ecx, ebp
  00323	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00328	8b e5		 mov	 esp, ebp
  0032a	5d		 pop	 ebp
  0032b	c2 04 00	 ret	 4
$LN234@SetDriverS:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z$0:
  00000	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR _finally793$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1Finally793@?1??SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z@QAE@XZ ; `GostCrypt::BootEncryption::SetDriverServiceStartType'::`2'::Finally793::~Finally793
__unwindfunclet$?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z$1:
  0000b	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _finally798$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1Finally798@?1??SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z@QAE@XZ ; `GostCrypt::BootEncryption::SetDriverServiceStartType'::`2'::Finally798::~Finally798
__unwindfunclet$?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z$2:
  00016	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR _driverPath$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z$3:
  00021	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR _path$6[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 8a 08 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-504]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z
  0004f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z ENDP ; GostCrypt::BootEncryption::SetDriverServiceStartType
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?SetDriverConfigurationFlag@BootEncryption@GostCrypt@@QAEXI_N@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_configMap$2 = -4					; size = 4
_flag$ = 8						; size = 4
_state$ = 12						; size = 1
?SetDriverConfigurationFlag@BootEncryption@GostCrypt@@QAEXI_N@Z PROC ; GostCrypt::BootEncryption::SetDriverConfigurationFlag, COMDAT
; _this$ = ecx

; 3018 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 3019 : 		DWORD configMap = ReadDriverConfigurationFlags();

  00007	8d 45 fc	 lea	 eax, DWORD PTR _configMap$2[ebp]
  0000a	50		 push	 eax
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@NANEHOFP@GostCryptConfig?$AA@
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LCJDGIOL@SYSTEM?2CurrentControlSet?2Service@
  00015	e8 00 00 00 00	 call	 _ReadLocalMachineRegistryDword
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	8b f0		 mov	 esi, eax
  0001f	f7 de		 neg	 esi
  00021	1b f6		 sbb	 esi, esi
  00023	23 75 fc	 and	 esi, DWORD PTR _configMap$2[ebp]

; 3020 : 
; 3021 : 		if (state)

  00026	80 7d 0c 00	 cmp	 BYTE PTR _state$[ebp], 0
  0002a	74 05		 je	 SHORT $LN2@SetDriverC

; 3022 : 			configMap |= flag;

  0002c	0b 75 08	 or	 esi, DWORD PTR _flag$[ebp]

; 3023 : 		else

  0002f	eb 07		 jmp	 SHORT $LN3@SetDriverC
$LN2@SetDriverC:

; 3024 : 			configMap &= ~flag;

  00031	8b 45 08	 mov	 eax, DWORD PTR _flag$[ebp]
  00034	f7 d0		 not	 eax
  00036	23 f0		 and	 esi, eax
$LN3@SetDriverC:

; 3025 : 
; 3026 : 		WriteLocalMachineRegistryDwordValue ("SYSTEM\\CurrentControlSet\\Services\\gostcrypt", GST_DRIVER_CONFIG_REG_VALUE_NAME, configMap);

  00038	e8 00 00 00 00	 call	 _IsAdmin
  0003d	85 c0		 test	 eax, eax
  0003f	75 23		 jne	 SHORT $LN11@SetDriverC
  00041	e8 00 00 00 00	 call	 _IsUacSupported
  00046	85 c0		 test	 eax, eax
  00048	74 1a		 je	 SHORT $LN11@SetDriverC
  0004a	56		 push	 esi
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@NANEHOFP@GostCryptConfig?$AA@
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LCJDGIOL@SYSTEM?2CurrentControlSet?2Service@
  00055	e8 00 00 00 00	 call	 ?WriteLocalMachineRegistryDwordValue@Elevator@GostCrypt@@SAXPAD0K@Z ; GostCrypt::Elevator::WriteLocalMachineRegistryDwordValue
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@SetDriverC:
  0005d	5e		 pop	 esi

; 3027 : 	}

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8

; 3025 : 
; 3026 : 		WriteLocalMachineRegistryDwordValue ("SYSTEM\\CurrentControlSet\\Services\\gostcrypt", GST_DRIVER_CONFIG_REG_VALUE_NAME, configMap);

$LN11@SetDriverC:
  00064	56		 push	 esi
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@NANEHOFP@GostCryptConfig?$AA@
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LCJDGIOL@SYSTEM?2CurrentControlSet?2Service@
  0006f	e8 00 00 00 00	 call	 _WriteLocalMachineRegistryDword
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
  00077	85 c0		 test	 eax, eax
  00079	75 e2		 jne	 SHORT $LN10@SetDriverC
  0007b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00088	89 45 fc	 mov	 DWORD PTR $T1[ebp+4], eax
  0008b	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  0008e	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN24@SetDriverC:
$LN21@SetDriverC:
  00099	cc		 int	 3
?SetDriverConfigurationFlag@BootEncryption@GostCrypt@@QAEXI_N@Z ENDP ; GostCrypt::BootEncryption::SetDriverConfigurationFlag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?RestrictPagingFilesToSystemPartition@BootEncryption@GostCrypt@@QAEXXZ
_TEXT	SEGMENT
$T1 = -164						; size = 8
$T2 = -156						; size = 24
_pagingFiles$ = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
?RestrictPagingFilesToSystemPartition@BootEncryption@GostCrypt@@QAEXXZ PROC ; GostCrypt::BootEncryption::RestrictPagingFilesToSystemPartition, COMDAT
; _this$ = ecx

; 2979 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 2980 : 		char pagingFiles[128];
; 2981 : 		strncpy (pagingFiles, "X:\\pagefile.sys 0 0", sizeof (pagingFiles));

  00014	68 80 00 00 00	 push	 128			; 00000080H
  00019	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _pagingFiles$[ebp]
  0001f	8b f1		 mov	 esi, ecx
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GGLBNJIB@X?3?2pagefile?4sys?50?50?$AA@
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _strncpy
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2982 : 		pagingFiles[0] = GetWindowsDirectory()[0];

  0002f	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00035	8b ce		 mov	 ecx, esi
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?GetWindowsDirectoryA@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GostCrypt::BootEncryption::GetWindowsDirectoryA
  0003d	5e		 pop	 esi
  0003e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00042	72 02		 jb	 SHORT $LN20@RestrictPa
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
$LN20@RestrictPa:
  00046	8a 00		 mov	 al, BYTE PTR [eax]
  00048	88 85 7c ff ff
	ff		 mov	 BYTE PTR _pagingFiles$[ebp], al
  0004e	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp+20]
  00054	83 f8 10	 cmp	 eax, 16			; 00000010H
  00057	72 13		 jb	 SHORT $LN30@RestrictPa
  00059	40		 inc	 eax
  0005a	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00060	50		 push	 eax
  00061	ff b5 64 ff ff
	ff		 push	 DWORD PTR $T2[ebp]
  00067	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN30@RestrictPa:

; 2983 : 
; 2984 : 		throw_sys_if (!WriteLocalMachineRegistryMultiString ("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management", "PagingFiles", pagingFiles, strlen (pagingFiles) + 2));

  0006c	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _pagingFiles$[ebp]
  00072	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL130@RestrictPa:
  00075	8a 01		 mov	 al, BYTE PTR [ecx]
  00077	41		 inc	 ecx
  00078	84 c0		 test	 al, al
  0007a	75 f9		 jne	 SHORT $LL130@RestrictPa
  0007c	2b ca		 sub	 ecx, edx
  0007e	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  00081	50		 push	 eax
  00082	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _pagingFiles$[ebp]
  00088	50		 push	 eax
  00089	68 00 00 00 00	 push	 OFFSET ??_C@_0M@BHFNFFHI@PagingFiles?$AA@
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@FMLJHJOD@System?2CurrentControlSet?2Control@
  00093	e8 00 00 00 00	 call	 _WriteLocalMachineRegistryMultiString
  00098	83 c4 10	 add	 esp, 16			; 00000010H
  0009b	85 c0		 test	 eax, eax
  0009d	74 0e		 je	 SHORT $LN132@RestrictPa

; 2985 : 	}

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN132@RestrictPa:

; 2983 : 
; 2984 : 		throw_sys_if (!WriteLocalMachineRegistryMultiString ("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management", "PagingFiles", pagingFiles, strlen (pagingFiles) + 2));

  000ad	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000bd	89 85 60 ff ff
	ff		 mov	 DWORD PTR $T1[ebp+4], eax
  000c3	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000c9	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN134@RestrictPa:
$LN131@RestrictPa:
  000d4	cc		 int	 3
?RestrictPagingFilesToSystemPartition@BootEncryption@GostCrypt@@QAEXXZ ENDP ; GostCrypt::BootEncryption::RestrictPagingFilesToSystemPartition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ
_TEXT	SEGMENT
_pagingFileRegDataSize$ = -65740			; size = 4
$T2 = -65736						; size = 24
$T3 = -65712						; size = 24
$T4 = -65688						; size = 32
$T5 = -65656						; size = 24
$T6 = -65632						; size = 24
$T7 = -65632						; size = 24
$T8 = -65632						; size = 24
$T9 = -65608						; size = 32
$T10 = -65600						; size = 24
$T11 = -65576						; size = 24
$T12 = -65576						; size = 24
$T13 = -65576						; size = 24
$T14 = -65576						; size = 24
$T15 = -65576						; size = 24
_pagingFileRegData$ = -65552				; size = 65536
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ PROC ; GostCrypt::BootEncryption::InitialSecurityChecksForHiddenOS, COMDAT
; _this$ = ecx

; 2518 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 c0 00 01 00	 mov	 eax, 65728		; 000100c0H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b f9		 mov	 edi, ecx

; 2519 : 		char windowsDrive = (char) toupper (GetWindowsDirectory()[0]);

  00034	8d 85 d8 ff fe
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?GetWindowsDirectoryA@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GostCrypt::BootEncryption::GetWindowsDirectoryA
  00040	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00044	72 02		 jb	 SHORT $LN37@InitialSec
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
$LN37@InitialSec:
  00048	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _toupper
  00051	8b 8d ec ff fe
	ff		 mov	 ecx, DWORD PTR $T15[ebp+20]
  00057	83 c4 04	 add	 esp, 4
  0005a	8a d8		 mov	 bl, al
  0005c	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0005f	72 13		 jb	 SHORT $LN46@InitialSec
  00061	41		 inc	 ecx
  00062	51		 push	 ecx
  00063	ff b5 d8 ff fe
	ff		 push	 DWORD PTR $T15[ebp]
  00069	8d 8d d8 ff fe
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  0006f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN46@InitialSec:

; 2520 : 
; 2521 : 		// Paging files
; 2522 : 		bool pagingFilesOk = !IsPagingFileActive (TRUE);

  00074	e8 00 00 00 00	 call	 _IsAdmin
  00079	85 c0		 test	 eax, eax
  0007b	75 1d		 jne	 SHORT $LN142@InitialSec
  0007d	e8 00 00 00 00	 call	 _IsUacSupported
  00082	85 c0		 test	 eax, eax
  00084	74 14		 je	 SHORT $LN142@InitialSec
  00086	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate
  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  00090	6a 01		 push	 1
  00092	50		 push	 eax
  00093	8b 08		 mov	 ecx, DWORD PTR [eax]
  00095	ff 51 24	 call	 DWORD PTR [ecx+36]
  00098	eb 0a		 jmp	 SHORT $LN1331@InitialSec
$LN142@InitialSec:
  0009a	6a 01		 push	 1
  0009c	e8 00 00 00 00	 call	 _IsPagingFileActive
  000a1	83 c4 04	 add	 esp, 4
$LN1331@InitialSec:
  000a4	85 c0		 test	 eax, eax

; 2523 : 
; 2524 : 		char pagingFileRegData[65536];
; 2525 : 		DWORD pagingFileRegDataSize = sizeof (pagingFileRegData);

  000a6	c7 85 34 ff fe
	ff 00 00 01 00	 mov	 DWORD PTR _pagingFileRegDataSize$[ebp], 65536 ; 00010000H

; 2526 : 
; 2527 : 		if (ReadLocalMachineRegistryMultiString ("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management", "PagingFiles", pagingFileRegData, &pagingFileRegDataSize)
; 2528 : 			&& pagingFileRegDataSize > 4)

  000b0	8d 85 34 ff fe
	ff		 lea	 eax, DWORD PTR _pagingFileRegDataSize$[ebp]
  000b6	50		 push	 eax
  000b7	8d 85 f0 ff fe
	ff		 lea	 eax, DWORD PTR _pagingFileRegData$[ebp]
  000bd	0f 95 c7	 setne	 bh
  000c0	50		 push	 eax
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_0M@BHFNFFHI@PagingFiles?$AA@
  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@FMLJHJOD@System?2CurrentControlSet?2Control@
  000cb	80 f7 01	 xor	 bh, 1
  000ce	e8 00 00 00 00	 call	 _ReadLocalMachineRegistryMultiString
  000d3	83 c4 10	 add	 esp, 16			; 00000010H
  000d6	85 c0		 test	 eax, eax
  000d8	74 51		 je	 SHORT $LN3@InitialSec
  000da	8b 8d 34 ff fe
	ff		 mov	 ecx, DWORD PTR _pagingFileRegDataSize$[ebp]
  000e0	83 f9 04	 cmp	 ecx, 4
  000e3	76 46		 jbe	 SHORT $LN3@InitialSec

; 2529 : 		{
; 2530 : 			for (size_t i = 1; i < pagingFileRegDataSize - 2; ++i)

  000e5	be 01 00 00 00	 mov	 esi, 1
  000ea	8d 41 fe	 lea	 eax, DWORD PTR [ecx-2]
  000ed	3b c6		 cmp	 eax, esi
  000ef	76 3a		 jbe	 SHORT $LN3@InitialSec
  000f1	b8 3a 5c 00 00	 mov	 eax, 23610		; 00005c3aH
$LL4@InitialSec:

; 2531 : 			{
; 2532 : 				if (memcmp (pagingFileRegData + i, ":\\", 2) == 0 && toupper (pagingFileRegData[i - 1]) != windowsDrive)

  000f6	66 39 84 35 f0
	ff fe ff	 cmp	 WORD PTR _pagingFileRegData$[ebp+esi], ax
  000fe	75 1e		 jne	 SHORT $LN2@InitialSec
  00100	0f be 84 35 ef
	ff fe ff	 movsx	 eax, BYTE PTR _pagingFileRegData$[ebp+esi-1]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _toupper
  0010e	0f be cb	 movsx	 ecx, bl
  00111	83 c4 04	 add	 esp, 4
  00114	3b c1		 cmp	 eax, ecx
  00116	75 1b		 jne	 SHORT $LN1326@InitialSec
  00118	8b 8d 34 ff fe
	ff		 mov	 ecx, DWORD PTR _pagingFileRegDataSize$[ebp]
$LN2@InitialSec:

; 2529 : 		{
; 2530 : 			for (size_t i = 1; i < pagingFileRegDataSize - 2; ++i)

  0011e	8d 41 fe	 lea	 eax, DWORD PTR [ecx-2]
  00121	46		 inc	 esi
  00122	3b f0		 cmp	 esi, eax
  00124	b8 3a 5c 00 00	 mov	 eax, 23610		; 00005c3aH
  00129	72 cb		 jb	 SHORT $LL4@InitialSec
$LN3@InitialSec:

; 2533 : 				{
; 2534 : 					pagingFilesOk = false;
; 2535 : 					break;
; 2536 : 				}
; 2537 : 			}
; 2538 : 		}
; 2539 : 
; 2540 : 		if (!pagingFilesOk)

  0012b	84 ff		 test	 bh, bh
  0012d	0f 85 80 02 00
	00		 jne	 $LN7@InitialSec
$LN1326@InitialSec:

; 2541 : 		{
; 2542 : 			if (AskWarnYesNoString ((wchar_t *) (wstring (GetString ("PAGING_FILE_NOT_ON_SYS_PARTITION")) 
; 2543 : 				+ GetString ("LEAKS_OUTSIDE_SYSPART_UNIVERSAL_EXPLANATION")
; 2544 : 				+ L"\n\n\n"
; 2545 : 				+ GetString ("RESTRICT_PAGING_FILES_TO_SYS_PARTITION")
; 2546 : 				).c_str()) == IDYES)

  00133	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KMEGGAHA@PAGING_FILE_NOT_ON_SYS_PARTITION@
  00138	e8 00 00 00 00	 call	 _GetString
  0013d	8b d0		 mov	 edx, eax
  0013f	c7 85 9c ff fe
	ff 07 00 00 00	 mov	 DWORD PTR $T5[ebp+20], 7
  00149	33 c0		 xor	 eax, eax
  0014b	c7 85 98 ff fe
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+16], 0
  00155	83 c4 04	 add	 esp, 4
  00158	66 89 85 88 ff
	fe ff		 mov	 WORD PTR $T5[ebp], ax
  0015f	66 39 02	 cmp	 WORD PTR [edx], ax
  00162	75 04		 jne	 SHORT $LN258@InitialSec
  00164	33 c9		 xor	 ecx, ecx
  00166	eb 17		 jmp	 SHORT $LN259@InitialSec
$LN258@InitialSec:
  00168	8b ca		 mov	 ecx, edx
  0016a	8d 71 02	 lea	 esi, DWORD PTR [ecx+2]
  0016d	0f 1f 00	 npad	 3
$LL1327@InitialSec:
  00170	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00173	83 c1 02	 add	 ecx, 2
  00176	66 85 c0	 test	 ax, ax
  00179	75 f5		 jne	 SHORT $LL1327@InitialSec
  0017b	2b ce		 sub	 ecx, esi
  0017d	d1 f9		 sar	 ecx, 1
$LN259@InitialSec:
  0017f	51		 push	 ecx
  00180	52		 push	 edx
  00181	8d 8d 88 ff fe
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00187	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BBEONPDF@LEAKS_OUTSIDE_SYSPART_UNIVERSAL_@
  00191	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00198	e8 00 00 00 00	 call	 _GetString
  0019d	50		 push	 eax
  0019e	8d 85 88 ff fe
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  001a4	50		 push	 eax
  001a5	8d 85 d8 ff fe
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  001b1	68 00 00 00 00	 push	 OFFSET ??_C@_17MFDLPPFM@?$AA?6?$AA?6?$AA?6?$AA?$AA@
  001b6	50		 push	 eax
  001b7	8d 85 a0 ff fe
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  001bd	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  001c1	50		 push	 eax
  001c2	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  001c7	8b f0		 mov	 esi, eax
  001c9	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@FJCBOPJI@RESTRICT_PAGING_FILES_TO_SYS_PAR@
  001ce	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  001d2	e8 00 00 00 00	 call	 _GetString
  001d7	50		 push	 eax
  001d8	8d 85 c0 ff fe
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  001de	56		 push	 esi
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  001e5	83 c4 2c	 add	 esp, 44			; 0000002cH
  001e8	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  001ec	72 02		 jb	 SHORT $LN274@InitialSec
  001ee	8b 00		 mov	 eax, DWORD PTR [eax]
$LN274@InitialSec:
  001f0	50		 push	 eax
  001f1	e8 00 00 00 00	 call	 _AskWarnYesNoString
  001f6	83 c4 04	 add	 esp, 4
  001f9	83 f8 06	 cmp	 eax, 6
  001fc	8b 85 d4 ff fe
	ff		 mov	 eax, DWORD PTR $T10[ebp+20]
  00202	0f 94 c3	 sete	 bl
  00205	83 f8 08	 cmp	 eax, 8
  00208	72 13		 jb	 SHORT $LN283@InitialSec
  0020a	40		 inc	 eax
  0020b	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  00211	50		 push	 eax
  00212	ff b5 c0 ff fe
	ff		 push	 DWORD PTR $T10[ebp]
  00218	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN283@InitialSec:
  0021d	33 c0		 xor	 eax, eax
  0021f	c7 85 d4 ff fe
	ff 07 00 00 00	 mov	 DWORD PTR $T10[ebp+20], 7
  00229	66 89 85 c0 ff
	fe ff		 mov	 WORD PTR $T10[ebp], ax
  00230	8b 85 b4 ff fe
	ff		 mov	 eax, DWORD PTR $T8[ebp+20]
  00236	c7 85 d0 ff fe
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+16], 0
  00240	83 f8 08	 cmp	 eax, 8
  00243	72 13		 jb	 SHORT $LN386@InitialSec
  00245	40		 inc	 eax
  00246	8d 8d a0 ff fe
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0024c	50		 push	 eax
  0024d	ff b5 a0 ff fe
	ff		 push	 DWORD PTR $T8[ebp]
  00253	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN386@InitialSec:
  00258	33 c0		 xor	 eax, eax
  0025a	c7 85 b4 ff fe
	ff 07 00 00 00	 mov	 DWORD PTR $T8[ebp+20], 7
  00264	66 89 85 a0 ff
	fe ff		 mov	 WORD PTR $T8[ebp], ax
  0026b	8b 85 ec ff fe
	ff		 mov	 eax, DWORD PTR $T14[ebp+20]
  00271	c7 85 b0 ff fe
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+16], 0
  0027b	83 f8 08	 cmp	 eax, 8
  0027e	72 13		 jb	 SHORT $LN489@InitialSec
  00280	40		 inc	 eax
  00281	8d 8d d8 ff fe
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  00287	50		 push	 eax
  00288	ff b5 d8 ff fe
	ff		 push	 DWORD PTR $T14[ebp]
  0028e	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN489@InitialSec:
  00293	33 c0		 xor	 eax, eax
  00295	c7 85 ec ff fe
	ff 07 00 00 00	 mov	 DWORD PTR $T14[ebp+20], 7
  0029f	66 89 85 d8 ff
	fe ff		 mov	 WORD PTR $T14[ebp], ax
  002a6	8b 85 9c ff fe
	ff		 mov	 eax, DWORD PTR $T5[ebp+20]
  002ac	c7 85 e8 ff fe
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+16], 0
  002b6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002bd	83 f8 08	 cmp	 eax, 8
  002c0	72 13		 jb	 SHORT $LN592@InitialSec
  002c2	40		 inc	 eax
  002c3	8d 8d 88 ff fe
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  002c9	50		 push	 eax
  002ca	ff b5 88 ff fe
	ff		 push	 DWORD PTR $T5[ebp]
  002d0	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN592@InitialSec:
  002d5	84 db		 test	 bl, bl
  002d7	74 11		 je	 SHORT $LN8@InitialSec

; 2547 : 			{
; 2548 : 				RestrictPagingFilesToSystemPartition();

  002d9	8b cf		 mov	 ecx, edi
  002db	e8 00 00 00 00	 call	 ?RestrictPagingFilesToSystemPartition@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::RestrictPagingFilesToSystemPartition

; 2549 : 				RestartComputer();

  002e0	e8 00 00 00 00	 call	 _RestartComputer

; 2550 : 				AbortProcessSilent();

  002e5	e8 00 00 00 00	 call	 _AbortProcessSilent
$LN8@InitialSec:

; 2551 : 			}
; 2552 : 
; 2553 : 			throw ErrorException (wstring (GetString ("PAGING_FILE_NOT_ON_SYS_PARTITION")) 

  002ea	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KMEGGAHA@PAGING_FILE_NOT_ON_SYS_PARTITION@
  002ef	e8 00 00 00 00	 call	 _GetString
  002f4	8b d0		 mov	 edx, eax
  002f6	c7 85 ec ff fe
	ff 07 00 00 00	 mov	 DWORD PTR $T13[ebp+20], 7
  00300	33 c0		 xor	 eax, eax
  00302	c7 85 e8 ff fe
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp+16], 0
  0030c	83 c4 04	 add	 esp, 4
  0030f	66 89 85 d8 ff
	fe ff		 mov	 WORD PTR $T13[ebp], ax
  00316	66 39 02	 cmp	 WORD PTR [edx], ax
  00319	75 04		 jne	 SHORT $LN803@InitialSec
  0031b	33 c9		 xor	 ecx, ecx
  0031d	eb 14		 jmp	 SHORT $LN804@InitialSec
$LN803@InitialSec:
  0031f	8b ca		 mov	 ecx, edx
  00321	8d 71 02	 lea	 esi, DWORD PTR [ecx+2]
$LL1328@InitialSec:
  00324	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00327	83 c1 02	 add	 ecx, 2
  0032a	66 85 c0	 test	 ax, ax
  0032d	75 f5		 jne	 SHORT $LL1328@InitialSec
  0032f	2b ce		 sub	 ecx, esi
  00331	d1 f9		 sar	 ecx, 1
$LN804@InitialSec:
  00333	51		 push	 ecx
  00334	52		 push	 edx
  00335	8d 8d d8 ff fe
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  0033b	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00340	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BBEONPDF@LEAKS_OUTSIDE_SYSPART_UNIVERSAL_@
  00345	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  0034c	e8 00 00 00 00	 call	 _GetString
  00351	50		 push	 eax
  00352	8d 85 d8 ff fe
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  00358	50		 push	 eax
  00359	8d 85 a0 ff fe
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  0035f	50		 push	 eax
  00360	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00365	83 c4 10	 add	 esp, 16			; 00000010H
  00368	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
$LN1332@InitialSec:
  0036c	33 c9		 xor	 ecx, ecx
  0036e	c7 85 b8 ff fe
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp], OFFSET ??_7ErrorException@GostCrypt@@6B@
  00378	6a ff		 push	 -1
  0037a	51		 push	 ecx
  0037b	66 89 8d c0 ff
	fe ff		 mov	 WORD PTR $T9[ebp+8], cx
  00382	8d 8d c0 ff fe
	ff		 lea	 ecx, DWORD PTR $T9[ebp+8]
  00388	50		 push	 eax
  00389	c7 85 d4 ff fe
	ff 07 00 00 00	 mov	 DWORD PTR $T9[ebp+28], 7
  00393	c7 85 d0 ff fe
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+24], 0
  0039d	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  003a2	68 00 00 00 00	 push	 OFFSET __TI2?AUErrorException@GostCrypt@@
  003a7	8d 85 b8 ff fe
	ff		 lea	 eax, DWORD PTR $T9[ebp]
$LN1333@InitialSec:
  003ad	50		 push	 eax
  003ae	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1334@InitialSec:
$LN7@InitialSec:

; 2554 : 				+ GetString ("LEAKS_OUTSIDE_SYSPART_UNIVERSAL_EXPLANATION"));
; 2555 : 		}
; 2556 : 
; 2557 : 		// User profile
; 2558 : 		char *configPath = GetConfigPath ("dummy");

  003b3	68 00 00 00 00	 push	 OFFSET ??_C@_05JLNEMJLN@dummy?$AA@
  003b8	e8 00 00 00 00	 call	 _GetConfigPath
  003bd	83 c4 04	 add	 esp, 4

; 2559 : 		if (configPath && toupper (configPath[0]) != windowsDrive)

  003c0	85 c0		 test	 eax, eax
  003c2	74 59		 je	 SHORT $LN9@InitialSec
  003c4	0f be 00	 movsx	 eax, BYTE PTR [eax]
  003c7	50		 push	 eax
  003c8	e8 00 00 00 00	 call	 _toupper
  003cd	0f be cb	 movsx	 ecx, bl
  003d0	83 c4 04	 add	 esp, 4
  003d3	3b c1		 cmp	 eax, ecx
  003d5	74 46		 je	 SHORT $LN9@InitialSec

; 2560 : 		{
; 2561 : 			throw ErrorException (wstring (GetString ("USER_PROFILE_NOT_ON_SYS_PARTITION")) 

  003d7	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@GBKHKMEM@USER_PROFILE_NOT_ON_SYS_PARTITIO@
  003dc	e8 00 00 00 00	 call	 _GetString
  003e1	83 c4 04	 add	 esp, 4
  003e4	8d 8d d8 ff fe
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  003ea	50		 push	 eax
  003eb	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  003f0	8b f0		 mov	 esi, eax
  003f2	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BBEONPDF@LEAKS_OUTSIDE_SYSPART_UNIVERSAL_@
  003f7	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  003fe	e8 00 00 00 00	 call	 _GetString
  00403	50		 push	 eax
  00404	8d 85 a0 ff fe
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0040a	56		 push	 esi
  0040b	50		 push	 eax
  0040c	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00411	83 c4 10	 add	 esp, 16			; 00000010H
  00414	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00418	e9 4f ff ff ff	 jmp	 $LN1332@InitialSec
$LN9@InitialSec:

; 2562 : 				+ GetString ("LEAKS_OUTSIDE_SYSPART_UNIVERSAL_EXPLANATION"));
; 2563 : 		}
; 2564 : 
; 2565 : 		// Temporary files
; 2566 : 		if (toupper (GetTempPath()[0]) != windowsDrive)

  0041d	8d 85 d8 ff fe
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  00423	8b cf		 mov	 ecx, edi
  00425	50		 push	 eax
  00426	e8 00 00 00 00	 call	 ?GetTempPathA@BootEncryption@GostCrypt@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GostCrypt::BootEncryption::GetTempPathA
  0042b	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0042f	72 02		 jb	 SHORT $LN1084@InitialSec
  00431	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1084@InitialSec:
  00433	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00436	50		 push	 eax
  00437	e8 00 00 00 00	 call	 _toupper
  0043c	0f be cb	 movsx	 ecx, bl
  0043f	83 c4 04	 add	 esp, 4
  00442	3b c1		 cmp	 eax, ecx
  00444	8b 85 ec ff fe
	ff		 mov	 eax, DWORD PTR $T11[ebp+20]
  0044a	0f 95 c3	 setne	 bl
  0044d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00450	72 13		 jb	 SHORT $LN1093@InitialSec
  00452	40		 inc	 eax
  00453	8d 8d d8 ff fe
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00459	50		 push	 eax
  0045a	ff b5 d8 ff fe
	ff		 push	 DWORD PTR $T11[ebp]
  00460	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN1093@InitialSec:
  00465	84 db		 test	 bl, bl
  00467	0f 84 87 00 00
	00		 je	 $LN10@InitialSec

; 2567 : 		{
; 2568 : 			throw ErrorException (wstring (GetString ("TEMP_NOT_ON_SYS_PARTITION")) 

  0046d	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@HBDIJMEI@TEMP_NOT_ON_SYS_PARTITION?$AA@
  00472	e8 00 00 00 00	 call	 _GetString
  00477	83 c4 04	 add	 esp, 4
  0047a	8d 8d 50 ff fe
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00480	50		 push	 eax
  00481	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00486	8b f0		 mov	 esi, eax
  00488	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BBEONPDF@LEAKS_OUTSIDE_SYSPART_UNIVERSAL_@
  0048d	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7
  00494	e8 00 00 00 00	 call	 _GetString
  00499	50		 push	 eax
  0049a	8d 85 38 ff fe
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  004a0	56		 push	 esi
  004a1	50		 push	 eax
  004a2	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  004a7	83 c4 10	 add	 esp, 16			; 00000010H
  004aa	33 c9		 xor	 ecx, ecx
  004ac	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  004b0	6a ff		 push	 -1
  004b2	51		 push	 ecx
  004b3	66 89 8d 70 ff
	fe ff		 mov	 WORD PTR $T4[ebp+8], cx
  004ba	8d 8d 70 ff fe
	ff		 lea	 ecx, DWORD PTR $T4[ebp+8]
  004c0	50		 push	 eax
  004c1	c7 85 68 ff fe
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], OFFSET ??_7ErrorException@GostCrypt@@6B@
  004cb	c7 85 84 ff fe
	ff 07 00 00 00	 mov	 DWORD PTR $T4[ebp+28], 7
  004d5	c7 85 80 ff fe
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+24], 0
  004df	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  004e4	68 00 00 00 00	 push	 OFFSET __TI2?AUErrorException@GostCrypt@@
  004e9	8d 85 68 ff fe
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  004ef	e9 b9 fe ff ff	 jmp	 $LN1333@InitialSec
$LN10@InitialSec:

; 2569 : 				+ GetString ("LEAKS_OUTSIDE_SYSPART_UNIVERSAL_EXPLANATION"));
; 2570 : 		}
; 2571 : 	}

  004f4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004f7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004fe	59		 pop	 ecx
  004ff	5f		 pop	 edi
  00500	5e		 pop	 esi
  00501	5b		 pop	 ebx
  00502	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00505	33 cd		 xor	 ecx, ebp
  00507	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0050c	8b e5		 mov	 esp, ebp
  0050e	5d		 pop	 ebp
  0050f	c3		 ret	 0
$LN1330@InitialSec:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$1:
  00000	8d 8d 88 ff fe
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$2:
  0000b	8d 8d d8 ff fe
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$3:
  00016	8d 8d a0 ff fe
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$5:
  00021	8d 8d d8 ff fe
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$6:
  0002c	8d 8d a0 ff fe
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$7:
  00037	8d 8d d8 ff fe
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$8:
  00042	8d 8d a0 ff fe
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$10:
  0004d	8d 8d 50 ff fe
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ$11:
  00058	8d 8d 38 ff fe
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0005e	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ:
  00063	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00067	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0006a	8b 8a 30 ff fe
	ff		 mov	 ecx, DWORD PTR [edx-65744]
  00070	33 c8		 xor	 ecx, eax
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0007a	33 c8		 xor	 ecx, eax
  0007c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00081	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ
  00086	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?InitialSecurityChecksForHiddenOS@BootEncryption@GostCrypt@@QAEXXZ ENDP ; GostCrypt::BootEncryption::InitialSecurityChecksForHiddenOS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?RestartComputer@BootEncryption@GostCrypt@@QAE_NXZ
_TEXT	SEGMENT
?RestartComputer@BootEncryption@GostCrypt@@QAE_NXZ PROC	; GostCrypt::BootEncryption::RestartComputer, COMDAT
; _this$ = ecx

; 3206 : 		return (::RestartComputer() != FALSE);

  00000	e8 00 00 00 00	 call	 _RestartComputer
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	f7 d8		 neg	 eax

; 3207 : 	}

  0000b	c3		 ret	 0
?RestartComputer@BootEncryption@GostCrypt@@QAE_NXZ ENDP	; GostCrypt::BootEncryption::RestartComputer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ
_TEXT	SEGMENT
$T2 = -404						; size = 8
$T3 = -400						; size = 4
$T4 = -396						; size = 24
$T5 = -396						; size = 24
$T6 = -372						; size = 24
$T7 = -348						; size = 24
_path$8 = -324						; size = 24
$T9 = -300						; size = 24
_pathBuf$ = -276					; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ PROC ; GostCrypt::BootEncryption::RenameDeprecatedSystemLoaderBackup, COMDAT
; _this$ = ecx

; 1844 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 88 01 00
	00		 sub	 esp, 392		; 00000188H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f1		 mov	 esi, ecx

; 1845 : 		char pathBuf[MAX_PATH];
; 1846 : 
; 1847 : 		if (SUCCEEDED (SHGetFolderPath (NULL, CSIDL_COMMON_APPDATA, NULL, 0, pathBuf)))

  0002f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pathBuf$[ebp]
  00035	c7 85 70 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], 0
  0003f	50		 push	 eax
  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	6a 23		 push	 35			; 00000023H
  00046	6a 00		 push	 0
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SHGetFolderPathA@20
  0004e	85 c0		 test	 eax, eax
  00050	0f 88 9e 02 00
	00		 js	 $LN732@RenameDepr

; 1848 : 		{
; 1849 : 			string path = string (pathBuf) + "\\" GST_APP_NAME + '\\' + GST_SYS_BOOT_LOADER_BACKUP_NAME_LEGACY;

  00056	80 bd ec fe ff
	ff 00		 cmp	 BYTE PTR _pathBuf$[ebp], 0
  0005d	c7 85 e8 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T9[ebp+20], 15 ; 0000000fH
  00067	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+16], 0
  00071	c6 85 d4 fe ff
	ff 00		 mov	 BYTE PTR $T9[ebp], 0
  00078	75 04		 jne	 SHORT $LN129@RenameDepr
  0007a	33 c9		 xor	 ecx, ecx
  0007c	eb 12		 jmp	 SHORT $LN130@RenameDepr
$LN129@RenameDepr:
  0007e	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pathBuf$[ebp]
  00084	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL827@RenameDepr:
  00087	8a 01		 mov	 al, BYTE PTR [ecx]
  00089	41		 inc	 ecx
  0008a	84 c0		 test	 al, al
  0008c	75 f9		 jne	 SHORT $LL827@RenameDepr
  0008e	2b ca		 sub	 ecx, edx
$LN130@RenameDepr:
  00090	51		 push	 ecx
  00091	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pathBuf$[ebp]
  00097	50		 push	 eax
  00098	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  0009e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CANDMBMO@?2GostCrypt?$AA@
  000a8	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  000ae	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000b5	50		 push	 eax
  000b6	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000c2	6a 5c		 push	 92			; 0000005cH
  000c4	50		 push	 eax
  000c5	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  000cb	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@PPCBILBO@Original?5System?5Loader?4bak?$AA@
  000da	50		 push	 eax
  000db	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _path$8[ebp]
  000e1	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000eb	83 c4 24	 add	 esp, 36			; 00000024H
  000ee	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR $T7[ebp+20]
  000f4	83 f8 10	 cmp	 eax, 16			; 00000010H
  000f7	72 13		 jb	 SHORT $LN137@RenameDepr
  000f9	40		 inc	 eax
  000fa	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00100	50		 push	 eax
  00101	ff b5 a4 fe ff
	ff		 push	 DWORD PTR $T7[ebp]
  00107	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN137@RenameDepr:
  0010c	c7 85 b8 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T7[ebp+20], 15 ; 0000000fH
  00116	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+16], 0
  00120	c6 85 a4 fe ff
	ff 00		 mov	 BYTE PTR $T7[ebp], 0
  00127	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR $T6[ebp+20]
  0012d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00130	72 13		 jb	 SHORT $LN238@RenameDepr
  00132	40		 inc	 eax
  00133	8d 8d 8c fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00139	50		 push	 eax
  0013a	ff b5 8c fe ff
	ff		 push	 DWORD PTR $T6[ebp]
  00140	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN238@RenameDepr:
  00145	c7 85 a0 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH
  0014f	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+16], 0
  00159	c6 85 8c fe ff
	ff 00		 mov	 BYTE PTR $T6[ebp], 0
  00160	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR $T9[ebp+20]
  00166	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0016a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0016d	72 13		 jb	 SHORT $LN339@RenameDepr
  0016f	40		 inc	 eax
  00170	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00176	50		 push	 eax
  00177	ff b5 d4 fe ff
	ff		 push	 DWORD PTR $T9[ebp]
  0017d	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN339@RenameDepr:

; 1850 : 
; 1851 : 			if (FileExists (path.c_str()) && !FileExists (GetSystemLoaderBackupPath().c_str()))

  00182	83 bd d0 fe ff
	ff 10		 cmp	 DWORD PTR _path$8[ebp+20], 16 ; 00000010H
  00189	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _path$8[ebp]
  0018f	c7 85 e8 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T9[ebp+20], 15 ; 0000000fH
  00199	0f 43 85 bc fe
	ff ff		 cmovae	 eax, DWORD PTR _path$8[ebp]
  001a0	50		 push	 eax
  001a1	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+16], 0
  001ab	c6 85 d4 fe ff
	ff 00		 mov	 BYTE PTR $T9[ebp], 0
  001b2	e8 00 00 00 00	 call	 _FileExists
  001b7	83 c4 04	 add	 esp, 4
  001ba	85 c0		 test	 eax, eax
  001bc	74 31		 je	 SHORT $LN9@RenameDepr
  001be	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  001c4	8b ce		 mov	 ecx, esi
  001c6	50		 push	 eax
  001c7	e8 00 00 00 00	 call	 ?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GostCrypt::BootEncryption::GetSystemLoaderBackupPath
  001cc	c7 85 70 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR $T3[ebp], 1
  001d6	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  001da	72 02		 jb	 SHORT $LN465@RenameDepr
  001dc	8b 00		 mov	 eax, DWORD PTR [eax]
$LN465@RenameDepr:
  001de	50		 push	 eax
  001df	e8 00 00 00 00	 call	 _FileExists
  001e4	83 c4 04	 add	 esp, 4
  001e7	85 c0		 test	 eax, eax
  001e9	75 04		 jne	 SHORT $LN9@RenameDepr
  001eb	b3 01		 mov	 bl, 1
  001ed	eb 02		 jmp	 SHORT $LN10@RenameDepr
$LN9@RenameDepr:
  001ef	32 db		 xor	 bl, bl
$LN10@RenameDepr:
  001f1	f6 85 70 fe ff
	ff 01		 test	 BYTE PTR $T3[ebp], 1
  001f8	74 1e		 je	 SHORT $LN474@RenameDepr
  001fa	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR $T5[ebp+20]
  00200	83 f8 10	 cmp	 eax, 16			; 00000010H
  00203	72 13		 jb	 SHORT $LN474@RenameDepr
  00205	40		 inc	 eax
  00206	8d 8d 74 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0020c	50		 push	 eax
  0020d	ff b5 74 fe ff
	ff		 push	 DWORD PTR $T5[ebp]
  00213	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN474@RenameDepr:
  00218	84 db		 test	 bl, bl
  0021a	0f 84 b6 00 00
	00		 je	 $LN3@RenameDepr

; 1852 : 				throw_sys_if (rename (path.c_str(), GetSystemLoaderBackupPath().c_str()) != 0);

  00220	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00226	8b ce		 mov	 ecx, esi
  00228	50		 push	 eax
  00229	e8 00 00 00 00	 call	 ?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GostCrypt::BootEncryption::GetSystemLoaderBackupPath
  0022e	8b c8		 mov	 ecx, eax
  00230	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00234	72 02		 jb	 SHORT $LN583@RenameDepr
  00236	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN583@RenameDepr:
  00238	83 bd d0 fe ff
	ff 10		 cmp	 DWORD PTR _path$8[ebp+20], 16 ; 00000010H
  0023f	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _path$8[ebp]
  00245	51		 push	 ecx
  00246	0f 43 85 bc fe
	ff ff		 cmovae	 eax, DWORD PTR _path$8[ebp]
  0024d	50		 push	 eax
  0024e	e8 00 00 00 00	 call	 _rename
  00253	83 c4 08	 add	 esp, 8
  00256	85 c0		 test	 eax, eax
  00258	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR $T4[ebp+20]
  0025e	0f 95 c3	 setne	 bl
  00261	83 f8 10	 cmp	 eax, 16			; 00000010H
  00264	72 45		 jb	 SHORT $LN689@RenameDepr
  00266	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
  0026c	40		 inc	 eax
  0026d	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00272	72 2e		 jb	 SHORT $LN684@RenameDepr
  00274	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00277	74 05		 je	 SHORT $LN685@RenameDepr
  00279	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN830@RenameDepr:
$LN685@RenameDepr:
  0027e	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00281	3b c1		 cmp	 eax, ecx
  00283	72 05		 jb	 SHORT $LN686@RenameDepr
  00285	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN831@RenameDepr:
$LN686@RenameDepr:
  0028a	2b c8		 sub	 ecx, eax
  0028c	83 f9 04	 cmp	 ecx, 4
  0028f	73 05		 jae	 SHORT $LN687@RenameDepr
  00291	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN832@RenameDepr:
$LN687@RenameDepr:
  00296	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00299	76 05		 jbe	 SHORT $LN688@RenameDepr
  0029b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN833@RenameDepr:
$LN688@RenameDepr:
  002a0	8b c8		 mov	 ecx, eax
$LN684@RenameDepr:
  002a2	51		 push	 ecx
  002a3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  002a8	83 c4 04	 add	 esp, 4
$LN689@RenameDepr:
  002ab	84 db		 test	 bl, bl
  002ad	74 27		 je	 SHORT $LN3@RenameDepr
  002af	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  002b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  002bf	89 85 70 fe ff
	ff		 mov	 DWORD PTR $T2[ebp+4], eax
  002c5	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  002cb	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  002d0	50		 push	 eax
  002d1	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN834@RenameDepr:
$LN3@RenameDepr:

; 1853 : 		}

  002d6	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _path$8[ebp+20]
  002dc	83 f8 10	 cmp	 eax, 16			; 00000010H
  002df	72 13		 jb	 SHORT $LN732@RenameDepr
  002e1	40		 inc	 eax
  002e2	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _path$8[ebp]
  002e8	50		 push	 eax
  002e9	ff b5 bc fe ff
	ff		 push	 DWORD PTR _path$8[ebp]
  002ef	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN732@RenameDepr:

; 1854 : 	}

  002f4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002f7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002fe	59		 pop	 ecx
  002ff	5e		 pop	 esi
  00300	5b		 pop	 ebx
  00301	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00304	33 cd		 xor	 ecx, ebp
  00306	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0030b	8b e5		 mov	 esp, ebp
  0030d	5d		 pop	 ebp
  0030e	c3		 ret	 0
$LN829@RenameDepr:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ$0:
  00000	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ$1:
  0000b	8d 8d 8c fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ$2:
  00016	8d 8d a4 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ$3:
  00021	8d 8d bc fe ff
	ff		 lea	 ecx, DWORD PTR _path$8[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 8a 6c fe ff
	ff		 mov	 ecx, DWORD PTR [edx-404]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ
  0004f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RenameDeprecatedSystemLoaderBackup@BootEncryption@GostCrypt@@QAEXXZ ENDP ; GostCrypt::BootEncryption::RenameDeprecatedSystemLoaderBackup
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z
_TEXT	SEGMENT
$T2 = -436						; size = 8
$T3 = -428						; size = 8
$T4 = -420						; size = 8
$T5 = -412						; size = 8
$T6 = -404						; size = 8
$T7 = -396						; size = 8
_description$8 = -388					; size = 4
_scm$ = -384						; size = 4
_this$GSCopy$ = -380					; size = 4
$T9 = -376						; size = 24
$T10 = -352						; size = 24
$T11 = -328						; size = 24
_servicePath$ = -304					; size = 24
_appPath$12 = -280					; size = 260
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_registerService$ = 8					; size = 4
?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z PROC ; GostCrypt::BootEncryption::RegisterSystemFavoritesService, COMDAT
; _this$ = ecx

; 2350 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a8 01 00
	00		 sub	 esp, 424		; 000001a8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b f1		 mov	 esi, ecx
  00033	89 b5 84 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], esi

; 2351 : 		if (!IsAdmin() && IsUacSupported())

  00039	e8 00 00 00 00	 call	 _IsAdmin
  0003e	85 c0		 test	 eax, eax
  00040	75 19		 jne	 SHORT $LN20@RegisterSy
  00042	e8 00 00 00 00	 call	 _IsUacSupported
  00047	85 c0		 test	 eax, eax
  00049	74 10		 je	 SHORT $LN20@RegisterSy

; 2352 : 		{
; 2353 : 			Elevator::RegisterSystemFavoritesService (registerService);

  0004b	ff 75 08	 push	 DWORD PTR _registerService$[ebp]
  0004e	e8 00 00 00 00	 call	 ?RegisterSystemFavoritesService@Elevator@GostCrypt@@SAXH@Z ; GostCrypt::Elevator::RegisterSystemFavoritesService
  00053	83 c4 04	 add	 esp, 4

; 2354 : 			return;

  00056	e9 2f 03 00 00	 jmp	 $LN1@RegisterSy
$LN20@RegisterSy:

; 2355 : 		}
; 2356 : 
; 2357 : 		SC_HANDLE scm = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);

  0005b	68 3f 00 0f 00	 push	 983103			; 000f003fH
  00060	6a 00		 push	 0
  00062	6a 00		 push	 0
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenSCManagerA@12
  0006a	8b f8		 mov	 edi, eax
  0006c	89 bd 80 fe ff
	ff		 mov	 DWORD PTR _scm$[ebp], edi

; 2358 : 		throw_sys_if (!scm);

  00072	85 ff		 test	 edi, edi
  00074	75 27		 jne	 SHORT $LN2@RegisterSy
  00076	c7 85 74 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00086	89 85 78 fe ff
	ff		 mov	 DWORD PTR $T7[ebp+4], eax
  0008c	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00092	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN133@RegisterSy:
$LN2@RegisterSy:

; 2359 : 
; 2360 : 		string servicePath = GetServiceConfigPath (GST_APP_NAME ".exe");

  0009d	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _servicePath$[ebp]
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GKOBNEPO@GostCrypt?4exe?$AA@
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ?GetServiceConfigPath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; GetServiceConfigPath
  000ae	83 c4 08	 add	 esp, 8

; 2361 : 
; 2362 : 		if (registerService)

  000b1	83 7d 08 00	 cmp	 DWORD PTR _registerService$[ebp], 0

; 2363 : 		{
; 2364 : 			try
; 2365 : 			{
; 2366 : 				RegisterSystemFavoritesService (FALSE);

  000b5	8b ce		 mov	 ecx, esi
  000b7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000be	6a 00		 push	 0
  000c0	0f 84 ff 01 00
	00		 je	 $LN22@RegisterSy
  000c6	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  000ca	e8 00 00 00 00	 call	 ?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z ; GostCrypt::BootEncryption::RegisterSystemFavoritesService
  000cf	eb 12		 jmp	 SHORT $LN132@RegisterSy
__catch$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$0:

; 2367 : 			}
; 2368 : 			catch (...) { }

  000d1	b8 00 00 00 00	 mov	 eax, $LN44@RegisterSy
  000d6	c3		 ret	 0
$LN44@RegisterSy:
  000d7	8b bd 80 fe ff
	ff		 mov	 edi, DWORD PTR _scm$[ebp]
  000dd	8b b5 84 fe ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
$LN132@RegisterSy:

; 2369 : 
; 2370 : 			char appPath[GST_MAX_PATH];
; 2371 : 			throw_sys_if (!GetModuleFileName (NULL, appPath, sizeof (appPath)));

  000e3	68 04 01 00 00	 push	 260			; 00000104H
  000e8	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _appPath$12[ebp]
  000ee	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000f5	50		 push	 eax
  000f6	6a 00		 push	 0
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12
  000fe	85 c0		 test	 eax, eax
  00100	75 27		 jne	 SHORT $LN5@RegisterSy
  00102	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00112	89 85 70 fe ff
	ff		 mov	 DWORD PTR $T6[ebp+4], eax
  00118	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0011e	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN134@RegisterSy:
$LN5@RegisterSy:

; 2372 : 
; 2373 : 			throw_sys_if (!CopyFile (appPath, servicePath.c_str(), FALSE));

  00129	83 bd e4 fe ff
	ff 10		 cmp	 DWORD PTR _servicePath$[ebp+20], 16 ; 00000010H
  00130	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _servicePath$[ebp]
  00136	6a 00		 push	 0
  00138	0f 43 85 d0 fe
	ff ff		 cmovae	 eax, DWORD PTR _servicePath$[ebp]
  0013f	50		 push	 eax
  00140	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _appPath$12[ebp]
  00146	50		 push	 eax
  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CopyFileA@12
  0014d	85 c0		 test	 eax, eax
  0014f	75 27		 jne	 SHORT $LN8@RegisterSy
  00151	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0015b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00161	89 85 68 fe ff
	ff		 mov	 DWORD PTR $T5[ebp+4], eax
  00167	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0016d	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN135@RegisterSy:
$LN8@RegisterSy:

; 2374 : 
; 2375 : 			SC_HANDLE service = CreateService (scm,

  00178	68 00 00 00 00	 push	 OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
  0017d	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00183	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00188	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _servicePath$[ebp]
  0018e	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  00192	51		 push	 ecx
  00193	50		 push	 eax
  00194	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  0019a	50		 push	 eax
  0019b	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  001a0	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@KLJIEDOC@?$CC?5?1systemFavoritesService?$AA@
  001a5	50		 push	 eax
  001a6	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  001ac	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  001b0	50		 push	 eax
  001b1	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  001b6	83 c4 18	 add	 esp, 24			; 00000018H
  001b9	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  001bd	72 02		 jb	 SHORT $LN95@RegisterSy
  001bf	8b 00		 mov	 eax, DWORD PTR [eax]
$LN95@RegisterSy:
  001c1	6a 00		 push	 0
  001c3	6a 00		 push	 0
  001c5	6a 00		 push	 0
  001c7	6a 00		 push	 0
  001c9	68 00 00 00 00	 push	 OFFSET ??_C@_09ENFKIOHO@Event?5Log?$AA@
  001ce	50		 push	 eax
  001cf	6a 01		 push	 1
  001d1	6a 02		 push	 2
  001d3	6a 10		 push	 16			; 00000010H
  001d5	68 ff 01 0f 00	 push	 983551			; 000f01ffH
  001da	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LDDPDLLO@GostCrypt?5System?5Favorites?$AA@
  001df	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@IIGMOCCE@GostCryptSystemFavorites?$AA@
  001e4	57		 push	 edi
  001e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateServiceA@52
  001eb	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  001f1	8b f8		 mov	 edi, eax
  001f3	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001f8	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  001fe	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00203	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00209	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0020d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 2376 : 				GST_SYSTEM_FAVORITES_SERVICE_NAME,
; 2377 : 				GST_APP_NAME " System Favorites",
; 2378 : 				SERVICE_ALL_ACCESS,
; 2379 : 				SERVICE_WIN32_OWN_PROCESS,
; 2380 : 				SERVICE_AUTO_START,
; 2381 : 				SERVICE_ERROR_NORMAL,
; 2382 : 				(string ("\"") + servicePath + "\" " GST_SYSTEM_FAVORITES_SERVICE_CMDLINE_OPTION).c_str(),
; 2383 : 				GST_SYSTEM_FAVORITES_SERVICE_LOAD_ORDER_GROUP,
; 2384 : 				NULL,
; 2385 : 				NULL,
; 2386 : 				NULL,
; 2387 : 				NULL);
; 2388 : 
; 2389 : 			throw_sys_if (!service);

  00212	85 ff		 test	 edi, edi
  00214	75 27		 jne	 SHORT $LN11@RegisterSy
  00216	c7 85 5c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00220	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00226	89 85 60 fe ff
	ff		 mov	 DWORD PTR $T4[ebp+4], eax
  0022c	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00232	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00237	50		 push	 eax
  00238	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN136@RegisterSy:
$LN11@RegisterSy:

; 2390 : 
; 2391 : 			SERVICE_DESCRIPTION description;
; 2392 : 			description.lpDescription = "Mounts GostCrypt system favorite volumes.";
; 2393 : 			ChangeServiceConfig2 (service, SERVICE_CONFIG_DESCRIPTION, &description);

  0023d	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR _description$8[ebp]
  00243	c7 85 7c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _description$8[ebp], OFFSET ??_C@_0CK@KHOKHPEC@Mounts?5GostCrypt?5system?5favorite@
  0024d	50		 push	 eax
  0024e	6a 01		 push	 1
  00250	57		 push	 edi
  00251	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ChangeServiceConfig2A@12

; 2394 : 
; 2395 : 			CloseServiceHandle (service);

  00257	57		 push	 edi
  00258	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseServiceHandle@4

; 2396 : 
; 2397 : 			try
; 2398 : 			{
; 2399 : 				WriteLocalMachineRegistryString ("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Minimal\\" GST_SYSTEM_FAVORITES_SERVICE_NAME, NULL, "Service", FALSE);

  0025e	6a 00		 push	 0
  00260	68 00 00 00 00	 push	 OFFSET ??_C@_07LMLHFMEG@Service?$AA@
  00265	6a 00		 push	 0
  00267	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@MKLMKGDH@SYSTEM?2CurrentControlSet?2Control@
  0026c	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  00270	e8 00 00 00 00	 call	 _WriteLocalMachineRegistryString

; 2400 : 				WriteLocalMachineRegistryString ("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Network\\" GST_SYSTEM_FAVORITES_SERVICE_NAME, NULL, "Service", FALSE);

  00275	6a 00		 push	 0
  00277	68 00 00 00 00	 push	 OFFSET ??_C@_07LMLHFMEG@Service?$AA@
  0027c	6a 00		 push	 0
  0027e	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@ELDIGJGM@SYSTEM?2CurrentControlSet?2Control@
  00283	e8 00 00 00 00	 call	 _WriteLocalMachineRegistryString
  00288	83 c4 20	 add	 esp, 32			; 00000020H

; 2401 : 
; 2402 : 				SetDriverConfigurationFlag (GST_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES, true);

  0028b	8b ce		 mov	 ecx, esi
  0028d	6a 01		 push	 1
  0028f	6a 02		 push	 2
  00291	e8 00 00 00 00	 call	 ?SetDriverConfigurationFlag@BootEncryption@GostCrypt@@QAEXI_N@Z ; GostCrypt::BootEncryption::SetDriverConfigurationFlag

; 2413 : 			}
; 2414 : 		}
; 2415 : 		else

  00296	e9 e4 00 00 00	 jmp	 $LN23@RegisterSy
__catch$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$2:

; 2403 : 			}
; 2404 : 			catch (...)
; 2405 : 			{
; 2406 : 				try
; 2407 : 				{
; 2408 : 					RegisterSystemFavoritesService (false);

  0029b	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  002a1	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  002a4	6a 00		 push	 0
  002a6	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+12], 7
  002aa	e8 00 00 00 00	 call	 ?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z ; GostCrypt::BootEncryption::RegisterSystemFavoritesService
$LN46@RegisterSy:

; 2411 : 
; 2412 : 				throw;

  002af	6a 00		 push	 0
  002b1	6a 00		 push	 0
  002b3	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 6
  002ba	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN137@RegisterSy:
__catch$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$3:

; 2409 : 				}
; 2410 : 				catch (...) { }

  002bf	b8 00 00 00 00	 mov	 eax, $LN46@RegisterSy
  002c4	c3		 ret	 0
$LN22@RegisterSy:

; 2416 : 		{
; 2417 : 			SetDriverConfigurationFlag (GST_DRIVER_CONFIG_CACHE_BOOT_PASSWORD_FOR_SYS_FAVORITES, false);

  002c5	6a 02		 push	 2
  002c7	e8 00 00 00 00	 call	 ?SetDriverConfigurationFlag@BootEncryption@GostCrypt@@QAEXI_N@Z ; GostCrypt::BootEncryption::SetDriverConfigurationFlag

; 2418 : 
; 2419 : 			DeleteLocalMachineRegistryKey ("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Minimal", GST_SYSTEM_FAVORITES_SERVICE_NAME);

  002cc	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@IIGMOCCE@GostCryptSystemFavorites?$AA@
  002d1	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@DDPDEKGA@SYSTEM?2CurrentControlSet?2Control@
  002d6	e8 00 00 00 00	 call	 _DeleteLocalMachineRegistryKey

; 2420 : 			DeleteLocalMachineRegistryKey ("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Network", GST_SYSTEM_FAVORITES_SERVICE_NAME);

  002db	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@IIGMOCCE@GostCryptSystemFavorites?$AA@
  002e0	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@PMGJGMIM@SYSTEM?2CurrentControlSet?2Control@
  002e5	e8 00 00 00 00	 call	 _DeleteLocalMachineRegistryKey
  002ea	83 c4 10	 add	 esp, 16			; 00000010H

; 2421 : 
; 2422 : 			SC_HANDLE service = OpenService (scm, GST_SYSTEM_FAVORITES_SERVICE_NAME, SERVICE_ALL_ACCESS);

  002ed	68 ff 01 0f 00	 push	 983551			; 000f01ffH
  002f2	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@IIGMOCCE@GostCryptSystemFavorites?$AA@
  002f7	57		 push	 edi
  002f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenServiceA@12
  002fe	8b f0		 mov	 esi, eax

; 2423 : 			throw_sys_if (!service);

  00300	85 f6		 test	 esi, esi
  00302	75 27		 jne	 SHORT $LN14@RegisterSy
  00304	c7 85 54 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0030e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00314	89 85 58 fe ff
	ff		 mov	 DWORD PTR $T3[ebp+4], eax
  0031a	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00320	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00325	50		 push	 eax
  00326	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN138@RegisterSy:
$LN14@RegisterSy:

; 2424 : 
; 2425 : 			throw_sys_if (!DeleteService (service));

  0032b	56		 push	 esi
  0032c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteService@4
  00332	85 c0		 test	 eax, eax
  00334	75 27		 jne	 SHORT $LN17@RegisterSy
  00336	c7 85 4c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00340	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00346	89 85 50 fe ff
	ff		 mov	 DWORD PTR $T2[ebp+4], eax
  0034c	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00352	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00357	50		 push	 eax
  00358	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN139@RegisterSy:
$LN17@RegisterSy:

; 2426 : 			CloseServiceHandle (service);

  0035d	56		 push	 esi
  0035e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseServiceHandle@4

; 2427 : 
; 2428 : 			DeleteFile (servicePath.c_str());

  00364	83 bd e4 fe ff
	ff 10		 cmp	 DWORD PTR _servicePath$[ebp+20], 16 ; 00000010H
  0036b	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _servicePath$[ebp]
  00371	0f 43 85 d0 fe
	ff ff		 cmovae	 eax, DWORD PTR _servicePath$[ebp]
  00378	50		 push	 eax
  00379	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4
$LN23@RegisterSy:

; 2429 : 		}
; 2430 : 	}

  0037f	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _servicePath$[ebp]
  00385	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1@RegisterSy:
  0038a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0038d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00394	59		 pop	 ecx
  00395	5f		 pop	 edi
  00396	5e		 pop	 esi
  00397	5b		 pop	 ebx
  00398	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0039b	33 cd		 xor	 ecx, ebp
  0039d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a2	8b e5		 mov	 esp, ebp
  003a4	5d		 pop	 ebp
  003a5	c2 04 00	 ret	 4
$LN131@RegisterSy:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$6:
  00000	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _servicePath$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$7:
  0000b	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z$8:
  00016	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 8a 48 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-440]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z
  00044	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z ENDP ; GostCrypt::BootEncryption::RegisterSystemFavoritesService
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_registerDriver$ = 8					; size = 1
_filterType$ = 12					; size = 4
?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z PROC ; GostCrypt::BootEncryption::RegisterFilterDriver, COMDAT
; _this$ = ecx

; 2312 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 2313 : 		if (!IsAdmin() && IsUacSupported())

  00009	e8 00 00 00 00	 call	 _IsAdmin
  0000e	85 c0		 test	 eax, eax
  00010	75 1e		 jne	 SHORT $LN4@RegisterFi
  00012	e8 00 00 00 00	 call	 _IsUacSupported
  00017	85 c0		 test	 eax, eax
  00019	74 15		 je	 SHORT $LN4@RegisterFi

; 2314 : 		{
; 2315 : 			Elevator::RegisterFilterDriver (registerDriver, filterType);

  0001b	ff 75 0c	 push	 DWORD PTR _filterType$[ebp]
  0001e	ff 75 08	 push	 DWORD PTR _registerDriver$[ebp]
  00021	e8 00 00 00 00	 call	 ?RegisterFilterDriver@Elevator@GostCrypt@@SAX_NW4FilterType@BootEncryption@2@@Z ; GostCrypt::Elevator::RegisterFilterDriver
  00026	83 c4 08	 add	 esp, 8
  00029	5f		 pop	 edi

; 2336 : 		}
; 2337 : 	}

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
$LN4@RegisterFi:

; 2316 : 			return;
; 2317 : 		}
; 2318 : 
; 2319 : 		switch (filterType)

  00030	8b 45 0c	 mov	 eax, DWORD PTR _filterType$[ebp]
  00033	83 e8 00	 sub	 eax, 0
  00036	74 47		 je	 SHORT $LN5@RegisterFi
  00038	83 e8 01	 sub	 eax, 1
  0003b	74 19		 je	 SHORT $LN6@RegisterFi
  0003d	83 e8 01	 sub	 eax, 1
  00040	75 55		 jne	 SHORT $LN17@RegisterFi

; 2328 : 			break;
; 2329 : 
; 2330 : 		case DumpFilter:
; 2331 : 			RegisterFilter (registerDriver, filterType);

  00042	50		 push	 eax
  00043	6a 02		 push	 2
  00045	ff 75 08	 push	 DWORD PTR _registerDriver$[ebp]
  00048	8b cf		 mov	 ecx, edi
  0004a	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
  0004f	5f		 pop	 edi

; 2336 : 		}
; 2337 : 	}

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN6@RegisterFi:

; 2323 : 			break;
; 2324 : 
; 2325 : 		case VolumeFilter:
; 2326 : 			RegisterFilter (registerDriver, filterType, &GUID_DEVCLASS_VOLUME);

  00056	68 00 00 00 00	 push	 OFFSET _GUID_DEVCLASS_VOLUME
  0005b	6a 01		 push	 1
  0005d	ff 75 08	 push	 DWORD PTR _registerDriver$[ebp]
  00060	8b cf		 mov	 ecx, edi
  00062	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter

; 2327 : 			RegisterFilter (registerDriver, filterType, &GUID_DEVCLASS_FLOPPYDISK);

  00067	68 00 00 00 00	 push	 OFFSET _GUID_DEVCLASS_FLOPPYDISK
  0006c	6a 01		 push	 1
  0006e	ff 75 08	 push	 DWORD PTR _registerDriver$[ebp]
  00071	8b cf		 mov	 ecx, edi
  00073	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
  00078	5f		 pop	 edi

; 2336 : 		}
; 2337 : 	}

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 08 00	 ret	 8
$LN5@RegisterFi:

; 2320 : 		{
; 2321 : 		case DriveFilter:
; 2322 : 			RegisterFilter (registerDriver, filterType, &GUID_DEVCLASS_DISKDRIVE);

  0007f	68 00 00 00 00	 push	 OFFSET _GUID_DEVCLASS_DISKDRIVE
  00084	6a 00		 push	 0
  00086	ff 75 08	 push	 DWORD PTR _registerDriver$[ebp]
  00089	8b cf		 mov	 ecx, edi
  0008b	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
  00090	5f		 pop	 edi

; 2336 : 		}
; 2337 : 	}

  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 08 00	 ret	 8
$LN17@RegisterFi:

; 2332 : 			break;
; 2333 : 
; 2334 : 		default:
; 2335 : 			throw ParameterIncorrect (SRC_POS);

  00097	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  0009c	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  0009f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  000a6	50		 push	 eax
  000a7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp+4], OFFSET ??_C@_0DF@LDCHKMLL@GostCrypt?3?3BootEncryption?3?3Regis@
  000ae	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN19@RegisterFi:
$LN15@RegisterFi:
  000b3	cc		 int	 3
?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z ENDP ; GostCrypt::BootEncryption::RegisterFilterDriver
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z
_TEXT	SEGMENT
$T2 = -76						; size = 8
$T3 = -68						; size = 8
$T4 = -60						; size = 8
$T5 = -52						; size = 8
$T6 = -44						; size = 8
$T7 = -36						; size = 8
$T8 = -28						; size = 8
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_hiddenSystem$ = 8					; size = 1
?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z PROC ; GostCrypt::BootEncryption::RegisterBootDriver, COMDAT
; _this$ = ecx

; 3166 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 3167 : 		SetDriverServiceStartType (SERVICE_BOOT_START);

  00030	6a 00		 push	 0
  00032	e8 00 00 00 00	 call	 ?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z ; GostCrypt::BootEncryption::SetDriverServiceStartType

; 3168 : 
; 3169 : 		try

  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 3170 : 		{
; 3171 : 			RegisterFilterDriver (false, DriveFilter);

  0003e	e8 00 00 00 00	 call	 _IsAdmin
  00043	85 c0		 test	 eax, eax
  00045	75 46		 jne	 SHORT $LN37@RegisterBo
  00047	e8 00 00 00 00	 call	 _IsUacSupported
  0004c	85 c0		 test	 eax, eax
  0004e	74 3d		 je	 SHORT $LN37@RegisterBo
  00050	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate
  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  0005a	6a 00		 push	 0
  0005c	6a 00		 push	 0
  0005e	50		 push	 eax
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	ff 51 2c	 call	 DWORD PTR [ecx+44]
  00064	85 c0		 test	 eax, eax
  00066	74 35		 je	 SHORT $LN35@RegisterBo
  00068	50		 push	 eax
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  0006f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T8[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0007c	89 45 e8	 mov	 DWORD PTR $T8[ebp+4], eax
  0007f	8d 45 e4	 lea	 eax, DWORD PTR $T8[ebp]
  00082	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN201@RegisterBo:
$LN37@RegisterBo:
  0008d	68 00 00 00 00	 push	 OFFSET _GUID_DEVCLASS_DISKDRIVE
  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	8b ce		 mov	 ecx, esi
  00098	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
$LN35@RegisterBo:

; 3172 : 			RegisterFilterDriver (false, VolumeFilter);

  0009d	e8 00 00 00 00	 call	 _IsAdmin
  000a2	85 c0		 test	 eax, eax
  000a4	75 46		 jne	 SHORT $LN61@RegisterBo
  000a6	e8 00 00 00 00	 call	 _IsUacSupported
  000ab	85 c0		 test	 eax, eax
  000ad	74 3d		 je	 SHORT $LN61@RegisterBo
  000af	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate
  000b4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  000b9	6a 01		 push	 1
  000bb	6a 00		 push	 0
  000bd	50		 push	 eax
  000be	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c0	ff 51 2c	 call	 DWORD PTR [ecx+44]
  000c3	85 c0		 test	 eax, eax
  000c5	74 45		 je	 SHORT $LN62@RegisterBo
  000c7	50		 push	 eax
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  000ce	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T7[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000db	89 45 e0	 mov	 DWORD PTR $T7[ebp+4], eax
  000de	8d 45 dc	 lea	 eax, DWORD PTR $T7[ebp]
  000e1	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN202@RegisterBo:
$LN61@RegisterBo:
  000ec	68 00 00 00 00	 push	 OFFSET _GUID_DEVCLASS_VOLUME
  000f1	6a 01		 push	 1
  000f3	6a 00		 push	 0
  000f5	8b ce		 mov	 ecx, esi
  000f7	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
  000fc	68 00 00 00 00	 push	 OFFSET _GUID_DEVCLASS_FLOPPYDISK
  00101	6a 01		 push	 1
  00103	6a 00		 push	 0
  00105	8b ce		 mov	 ecx, esi
  00107	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
$LN62@RegisterBo:

; 3173 : 			RegisterFilterDriver (false, DumpFilter);

  0010c	e8 00 00 00 00	 call	 _IsAdmin
  00111	85 c0		 test	 eax, eax
  00113	75 46		 jne	 SHORT $LN84@RegisterBo
  00115	e8 00 00 00 00	 call	 _IsUacSupported
  0011a	85 c0		 test	 eax, eax
  0011c	74 3d		 je	 SHORT $LN84@RegisterBo
  0011e	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate
  00123	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  00128	6a 02		 push	 2
  0012a	6a 00		 push	 0
  0012c	50		 push	 eax
  0012d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012f	ff 51 2c	 call	 DWORD PTR [ecx+44]
  00132	85 c0		 test	 eax, eax
  00134	74 3d		 je	 SHORT $LN23@RegisterBo
  00136	50		 push	 eax
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  0013d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0014a	89 45 d8	 mov	 DWORD PTR $T6[ebp+4], eax
  0014d	8d 45 d4	 lea	 eax, DWORD PTR $T6[ebp]
  00150	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN203@RegisterBo:
$LN84@RegisterBo:
  0015b	6a 00		 push	 0
  0015d	6a 02		 push	 2
  0015f	6a 00		 push	 0
  00161	8b ce		 mov	 ecx, esi
  00163	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
  00168	eb 09		 jmp	 SHORT $LN23@RegisterBo
__catch$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$0:

; 3174 : 		}
; 3175 : 		catch (...) { }

  0016a	b8 00 00 00 00	 mov	 eax, $LN196@RegisterBo
  0016f	c3		 ret	 0
$LN196@RegisterBo:
  00170	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN23@RegisterBo:

; 3176 : 
; 3177 : 		try

  00173	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2

; 3178 : 		{
; 3179 : 			RegisterFilterDriver (true, DriveFilter);

  0017a	e8 00 00 00 00	 call	 _IsAdmin
  0017f	85 c0		 test	 eax, eax
  00181	75 46		 jne	 SHORT $LN107@RegisterBo
  00183	e8 00 00 00 00	 call	 _IsUacSupported
  00188	85 c0		 test	 eax, eax
  0018a	74 3d		 je	 SHORT $LN107@RegisterBo
  0018c	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate
  00191	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  00196	6a 00		 push	 0
  00198	6a 01		 push	 1
  0019a	50		 push	 eax
  0019b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019d	ff 51 2c	 call	 DWORD PTR [ecx+44]
  001a0	85 c0		 test	 eax, eax
  001a2	74 35		 je	 SHORT $LN105@RegisterBo
  001a4	50		 push	 eax
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  001ab	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001b8	89 45 d0	 mov	 DWORD PTR $T5[ebp+4], eax
  001bb	8d 45 cc	 lea	 eax, DWORD PTR $T5[ebp]
  001be	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  001c3	50		 push	 eax
  001c4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN204@RegisterBo:
$LN107@RegisterBo:
  001c9	68 00 00 00 00	 push	 OFFSET _GUID_DEVCLASS_DISKDRIVE
  001ce	6a 00		 push	 0
  001d0	6a 01		 push	 1
  001d2	8b ce		 mov	 ecx, esi
  001d4	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
$LN105@RegisterBo:

; 3180 : 
; 3181 : 			if (hiddenSystem)

  001d9	80 7d 08 00	 cmp	 BYTE PTR _hiddenSystem$[ebp], 0
  001dd	74 6f		 je	 SHORT $LN131@RegisterBo

; 3182 : 				RegisterFilterDriver (true, VolumeFilter);

  001df	e8 00 00 00 00	 call	 _IsAdmin
  001e4	85 c0		 test	 eax, eax
  001e6	75 46		 jne	 SHORT $LN130@RegisterBo
  001e8	e8 00 00 00 00	 call	 _IsUacSupported
  001ed	85 c0		 test	 eax, eax
  001ef	74 3d		 je	 SHORT $LN130@RegisterBo
  001f1	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate
  001f6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  001fb	6a 01		 push	 1
  001fd	6a 01		 push	 1
  001ff	50		 push	 eax
  00200	8b 08		 mov	 ecx, DWORD PTR [eax]
  00202	ff 51 2c	 call	 DWORD PTR [ecx+44]
  00205	85 c0		 test	 eax, eax
  00207	74 45		 je	 SHORT $LN131@RegisterBo
  00209	50		 push	 eax
  0020a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  00210	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00217	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0021d	89 45 c8	 mov	 DWORD PTR $T4[ebp+4], eax
  00220	8d 45 c4	 lea	 eax, DWORD PTR $T4[ebp]
  00223	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00228	50		 push	 eax
  00229	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN205@RegisterBo:
$LN130@RegisterBo:
  0022e	68 00 00 00 00	 push	 OFFSET _GUID_DEVCLASS_VOLUME
  00233	6a 01		 push	 1
  00235	6a 01		 push	 1
  00237	8b ce		 mov	 ecx, esi
  00239	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
  0023e	68 00 00 00 00	 push	 OFFSET _GUID_DEVCLASS_FLOPPYDISK
  00243	6a 01		 push	 1
  00245	6a 01		 push	 1
  00247	8b ce		 mov	 ecx, esi
  00249	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
$LN131@RegisterBo:

; 3183 : 
; 3184 : 			RegisterFilterDriver (true, DumpFilter);

  0024e	e8 00 00 00 00	 call	 _IsAdmin
  00253	85 c0		 test	 eax, eax
  00255	75 46		 jne	 SHORT $LN153@RegisterBo
  00257	e8 00 00 00 00	 call	 _IsUacSupported
  0025c	85 c0		 test	 eax, eax
  0025e	74 3d		 je	 SHORT $LN153@RegisterBo
  00260	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate
  00265	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  0026a	6a 02		 push	 2
  0026c	6a 01		 push	 1
  0026e	50		 push	 eax
  0026f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00271	ff 51 2c	 call	 DWORD PTR [ecx+44]
  00274	85 c0		 test	 eax, eax
  00276	74 32		 je	 SHORT $LN32@RegisterBo
  00278	50		 push	 eax
  00279	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  0027f	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00286	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0028c	89 45 c0	 mov	 DWORD PTR $T3[ebp+4], eax
  0028f	8d 45 bc	 lea	 eax, DWORD PTR $T3[ebp]
  00292	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN206@RegisterBo:
$LN153@RegisterBo:
  0029d	6a 00		 push	 0
  0029f	6a 02		 push	 2
  002a1	6a 01		 push	 1
  002a3	8b ce		 mov	 ecx, esi
  002a5	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
$LN32@RegisterBo:

; 3194 : 		}
; 3195 : 	}

  002aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002b4	59		 pop	 ecx
  002b5	5f		 pop	 edi
  002b6	5e		 pop	 esi
  002b7	5b		 pop	 ebx
  002b8	8b e5		 mov	 esp, ebp
  002ba	5d		 pop	 ebp
  002bb	c2 04 00	 ret	 4
__catch$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$2:

; 3185 : 		}
; 3186 : 		catch (...)
; 3187 : 		{
; 3188 : 			try { RegisterFilterDriver (false, DriveFilter); } catch (...) { }

  002be	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  002c1	8b ce		 mov	 ecx, esi
  002c3	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  002c6	6a 00		 push	 0
  002c8	6a 00		 push	 0
  002ca	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  002ce	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z ; GostCrypt::BootEncryption::RegisterFilterDriver
  002d3	eb 09		 jmp	 SHORT $LN199@RegisterBo
__catch$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$3:
  002d5	b8 00 00 00 00	 mov	 eax, $LN25@RegisterBo
  002da	c3		 ret	 0
$LN25@RegisterBo:
  002db	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN199@RegisterBo:

; 3189 : 			try { RegisterFilterDriver (false, VolumeFilter); } catch (...) { }

  002de	6a 01		 push	 1
  002e0	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  002e7	8b ce		 mov	 ecx, esi
  002e9	6a 00		 push	 0
  002eb	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  002ef	e8 00 00 00 00	 call	 ?RegisterFilterDriver@BootEncryption@GostCrypt@@QAEX_NW4FilterType@12@@Z ; GostCrypt::BootEncryption::RegisterFilterDriver
  002f4	eb 09		 jmp	 SHORT $LN200@RegisterBo
__catch$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$5:
  002f6	b8 00 00 00 00	 mov	 eax, $LN27@RegisterBo
  002fb	c3		 ret	 0
$LN27@RegisterBo:
  002fc	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN200@RegisterBo:
  002ff	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3

; 3190 : 			try { RegisterFilterDriver (false, DumpFilter); } catch (...) { }

  00306	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+12], 8
  0030a	e8 00 00 00 00	 call	 _IsAdmin
  0030f	85 c0		 test	 eax, eax
  00311	75 46		 jne	 SHORT $LN176@RegisterBo
  00313	e8 00 00 00 00	 call	 _IsUacSupported
  00318	85 c0		 test	 eax, eax
  0031a	74 3d		 je	 SHORT $LN176@RegisterBo
  0031c	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate
  00321	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  00326	6a 02		 push	 2
  00328	6a 00		 push	 0
  0032a	50		 push	 eax
  0032b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032d	ff 51 2c	 call	 DWORD PTR [ecx+44]
  00330	85 c0		 test	 eax, eax
  00332	74 3d		 je	 SHORT $LN178@RegisterBo
  00334	50		 push	 eax
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  0033b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00342	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00348	89 45 b8	 mov	 DWORD PTR $T2[ebp+4], eax
  0034b	8d 45 b4	 lea	 eax, DWORD PTR $T2[ebp]
  0034e	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00353	50		 push	 eax
  00354	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN207@RegisterBo:
$LN176@RegisterBo:
  00359	6a 00		 push	 0
  0035b	6a 02		 push	 2
  0035d	6a 00		 push	 0
  0035f	8b ce		 mov	 ecx, esi
  00361	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
  00366	eb 09		 jmp	 SHORT $LN178@RegisterBo
__catch$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$7:
  00368	b8 00 00 00 00	 mov	 eax, $LN29@RegisterBo
  0036d	c3		 ret	 0
$LN29@RegisterBo:
  0036e	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
$LN178@RegisterBo:
  00371	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3

; 3191 : 			try { SetDriverServiceStartType (SERVICE_SYSTEM_START); } catch (...) { }

  00378	8b ce		 mov	 ecx, esi
  0037a	6a 01		 push	 1
  0037c	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  00380	e8 00 00 00 00	 call	 ?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z ; GostCrypt::BootEncryption::SetDriverServiceStartType
$LN31@RegisterBo:

; 3192 : 
; 3193 : 			throw;

  00385	6a 00		 push	 0
  00387	6a 00		 push	 0
  00389	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  00390	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN208@RegisterBo:
__catch$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z$9:

; 3191 : 			try { SetDriverServiceStartType (SERVICE_SYSTEM_START); } catch (...) { }

  00395	b8 00 00 00 00	 mov	 eax, $LN31@RegisterBo
  0039a	c3		 ret	 0
$LN198@RegisterBo:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z ENDP ; GostCrypt::BootEncryption::RegisterBootDriver
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?ReadDriverConfigurationFlags@BootEncryption@GostCrypt@@QAEIXZ
_TEXT	SEGMENT
_configMap$ = -4					; size = 4
?ReadDriverConfigurationFlags@BootEncryption@GostCrypt@@QAEIXZ PROC ; GostCrypt::BootEncryption::ReadDriverConfigurationFlags, COMDAT
; _this$ = ecx

; 3130 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3131 : 		DWORD configMap;
; 3132 : 
; 3133 : 		if (!ReadLocalMachineRegistryDword ("SYSTEM\\CurrentControlSet\\Services\\gostcrypt", GST_DRIVER_CONFIG_REG_VALUE_NAME, &configMap))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _configMap$[ebp]
  00007	50		 push	 eax
  00008	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@NANEHOFP@GostCryptConfig?$AA@
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LCJDGIOL@SYSTEM?2CurrentControlSet?2Service@
  00012	e8 00 00 00 00	 call	 _ReadLocalMachineRegistryDword
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001a	f7 d8		 neg	 eax
  0001c	1b c0		 sbb	 eax, eax
  0001e	23 45 fc	 and	 eax, DWORD PTR _configMap$[ebp]

; 3134 : 			configMap = 0;
; 3135 : 
; 3136 : 		return configMap;
; 3137 : 	}

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?ReadDriverConfigurationFlags@BootEncryption@GostCrypt@@QAEIXZ ENDP ; GostCrypt::BootEncryption::ReadDriverConfigurationFlags
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z
_TEXT	SEGMENT
$T2 = -928						; size = 8
_bootLoaderVersion$GSCopy$ = -920			; size = 4
_customUserMessage$GSCopy$ = -916			; size = 4
_userConfig$GSCopy$ = -912				; size = 4
_config$GSCopy$ = -908					; size = 4
_customUserMessage$GSCopy$1$ = -904			; size = 4
_this$GSCopy$1$ = -900					; size = 4
$T3 = -896						; size = 320
_request$ = -576					; size = 553
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_config$ = 8						; size = 4
_bufLength$ = 12					; size = 4
_userConfig$ = 16					; size = 4
_customUserMessage$ = 20				; size = 4
_bootLoaderVersion$ = 24				; size = 4
?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z PROC ; GostCrypt::BootEncryption::ReadBootSectorConfig, COMDAT
; _this$ = ecx

; 1467 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 94 03 00
	00		 sub	 esp, 916		; 00000394H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 8d 7c fc ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  00037	8b 75 08	 mov	 esi, DWORD PTR _config$[ebp]
  0003a	8b 45 14	 mov	 eax, DWORD PTR _customUserMessage$[ebp]
  0003d	8b 7d 10	 mov	 edi, DWORD PTR _userConfig$[ebp]
  00040	8b 5d 18	 mov	 ebx, DWORD PTR _bootLoaderVersion$[ebp]
  00043	89 b5 74 fc ff
	ff		 mov	 DWORD PTR _config$GSCopy$[ebp], esi
  00049	89 bd 70 fc ff
	ff		 mov	 DWORD PTR _userConfig$GSCopy$[ebp], edi
  0004f	89 85 78 fc ff
	ff		 mov	 DWORD PTR _customUserMessage$GSCopy$1$[ebp], eax
  00055	89 85 6c fc ff
	ff		 mov	 DWORD PTR _customUserMessage$GSCopy$[ebp], eax
  0005b	89 9d 68 fc ff
	ff		 mov	 DWORD PTR _bootLoaderVersion$GSCopy$[ebp], ebx

; 1468 : 		if (config && bufLength < GST_BOOT_CFG_FLAG_AREA_SIZE)

  00061	85 f6		 test	 esi, esi
  00063	74 2b		 je	 SHORT $LN2@ReadBootSe
  00065	83 7d 0c 01	 cmp	 DWORD PTR _bufLength$[ebp], 1
  00069	73 25		 jae	 SHORT $LN2@ReadBootSe

; 1469 : 			throw ParameterIncorrect (SRC_POS);

  0006b	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00070	8d 85 60 fc ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00076	c7 85 60 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00080	50		 push	 eax
  00081	c7 85 64 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_0DF@DPDHMAHA@GostCrypt?3?3BootEncryption?3?3ReadB@
  0008b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN51@ReadBootSe:
$LN2@ReadBootSe:

; 1470 : 
; 1471 : 		GetSystemDriveConfigurationRequest request;
; 1472 : 		_snwprintf (request.DevicePath, array_capacity (request.DevicePath), L"%hs", GetSystemDriveConfiguration().DeviceKernelPath.c_str());

  00090	8d 85 80 fc ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  0009c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  000a0	72 02		 jb	 SHORT $LN37@ReadBootSe
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
$LN37@ReadBootSe:
  000a4	50		 push	 eax
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs?$AA?$AA@
  000aa	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR _request$[ebp]
  000b0	68 04 01 00 00	 push	 260			; 00000104H
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 __snwprintf
  000bb	83 c4 10	 add	 esp, 16			; 00000010H
  000be	8d 8d 80 fc ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  000c4	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 1473 : 
; 1474 : 		try
; 1475 : 		{
; 1476 : 			CallDriver (GST_IOCTL_GET_SYSTEM_DRIVE_CONFIG, &request, sizeof (request), &request, sizeof (request));

  000c9	8b 8d 7c fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  000cf	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR _request$[ebp]
  000d5	68 29 02 00 00	 push	 553			; 00000229H
  000da	50		 push	 eax
  000db	68 29 02 00 00	 push	 553			; 00000229H
  000e0	50		 push	 eax
  000e1	68 70 20 22 00	 push	 2236528			; 00222070H
  000e6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000ed	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 1477 : 			if (config)

  000f2	85 f6		 test	 esi, esi
  000f4	74 05		 je	 SHORT $LN4@ReadBootSe

; 1478 : 				*config = request.Configuration;

  000f6	8a 45 c8	 mov	 al, BYTE PTR _request$[ebp+520]
  000f9	88 06		 mov	 BYTE PTR [esi], al
$LN4@ReadBootSe:

; 1479 : 
; 1480 : 			if (userConfig)

  000fb	85 ff		 test	 edi, edi
  000fd	74 05		 je	 SHORT $LN5@ReadBootSe

; 1481 : 				*userConfig = request.UserConfiguration;

  000ff	8a 45 cf	 mov	 al, BYTE PTR _request$[ebp+527]
  00102	88 07		 mov	 BYTE PTR [edi], al
$LN5@ReadBootSe:

; 1482 : 			
; 1483 : 			if (customUserMessage)

  00104	8b 95 78 fc ff
	ff		 mov	 edx, DWORD PTR _customUserMessage$GSCopy$1$[ebp]
  0010a	85 d2		 test	 edx, edx
  0010c	74 29		 je	 SHORT $LN6@ReadBootSe

; 1484 : 			{
; 1485 : 				request.CustomUserMessage[GST_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH] = 0;
; 1486 : 				*customUserMessage = request.CustomUserMessage;

  0010e	80 7d d0 00	 cmp	 BYTE PTR _request$[ebp+528], 0
  00112	c6 45 e8 00	 mov	 BYTE PTR _request$[ebp+552], 0
  00116	75 04		 jne	 SHORT $LN46@ReadBootSe
  00118	33 c9		 xor	 ecx, ecx
  0011a	eb 0f		 jmp	 SHORT $LN47@ReadBootSe
$LN46@ReadBootSe:
  0011c	8d 4d d0	 lea	 ecx, DWORD PTR _request$[ebp+528]
  0011f	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL48@ReadBootSe:
  00122	8a 01		 mov	 al, BYTE PTR [ecx]
  00124	41		 inc	 ecx
  00125	84 c0		 test	 al, al
  00127	75 f9		 jne	 SHORT $LL48@ReadBootSe
  00129	2b ce		 sub	 ecx, esi
$LN47@ReadBootSe:
  0012b	51		 push	 ecx
  0012c	8d 45 d0	 lea	 eax, DWORD PTR _request$[ebp+528]
  0012f	8b ca		 mov	 ecx, edx
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN6@ReadBootSe:

; 1487 : 			}
; 1488 : 
; 1489 : 			if (bootLoaderVersion)

  00137	85 db		 test	 ebx, ebx
  00139	74 07		 je	 SHORT $LN17@ReadBootSe

; 1490 : 				*bootLoaderVersion = request.BootLoaderVersion;

  0013b	66 8b 45 cd	 mov	 ax, WORD PTR _request$[ebp+525]
  0013f	66 89 03	 mov	 WORD PTR [ebx], ax
$LN17@ReadBootSe:

; 1506 : 	}

  00142	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00145	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0014c	59		 pop	 ecx
  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
  00150	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00153	33 cd		 xor	 ecx, ebp
  00155	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c2 14 00	 ret	 20			; 00000014H
__catch$?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z$0:

; 1491 : 		}
; 1492 : 		catch (...)
; 1493 : 		{
; 1494 : 			if (config)

  00160	8b 85 74 fc ff
	ff		 mov	 eax, DWORD PTR _config$GSCopy$[ebp]
  00166	85 c0		 test	 eax, eax
  00168	74 03		 je	 SHORT $LN8@ReadBootSe

; 1495 : 				*config = 0;

  0016a	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN8@ReadBootSe:

; 1496 : 
; 1497 : 			if (userConfig)

  0016d	8b 85 70 fc ff
	ff		 mov	 eax, DWORD PTR _userConfig$GSCopy$[ebp]
  00173	85 c0		 test	 eax, eax
  00175	74 03		 je	 SHORT $LN9@ReadBootSe

; 1498 : 				*userConfig = 0;

  00177	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN9@ReadBootSe:

; 1499 : 			
; 1500 : 			if (customUserMessage)

  0017a	8b 8d 6c fc ff
	ff		 mov	 ecx, DWORD PTR _customUserMessage$GSCopy$[ebp]
  00180	85 c9		 test	 ecx, ecx
  00182	74 05		 je	 SHORT $LN10@ReadBootSe

; 1501 : 				customUserMessage->clear();

  00184	e8 00 00 00 00	 call	 ?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
$LN10@ReadBootSe:

; 1502 : 
; 1503 : 			if (bootLoaderVersion)

  00189	8b 85 68 fc ff
	ff		 mov	 eax, DWORD PTR _bootLoaderVersion$GSCopy$[ebp]
  0018f	85 c0		 test	 eax, eax
  00191	74 05		 je	 SHORT $LN11@ReadBootSe

; 1504 : 				*bootLoaderVersion = 0;

  00193	33 c9		 xor	 ecx, ecx
  00195	66 89 08	 mov	 WORD PTR [eax], cx
$LN11@ReadBootSe:

; 1505 : 		}

  00198	b8 00 00 00 00	 mov	 eax, $LN17@ReadBootSe
  0019d	c3		 ret	 0
$LN50@ReadBootSe:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 5c fc ff
	ff		 mov	 ecx, DWORD PTR [edx-932]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z ENDP ; GostCrypt::BootEncryption::ReadBootSectorConfig
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?ProbeRealSystemDriveSize@BootEncryption@GostCrypt@@QAEXXZ
_TEXT	SEGMENT
$T1 = -860						; size = 4
$T2 = -856						; size = 320
_request$ = -536					; size = 532
__$ArrayPad$ = -4					; size = 4
?ProbeRealSystemDriveSize@BootEncryption@GostCrypt@@QAEXXZ PROC ; GostCrypt::BootEncryption::ProbeRealSystemDriveSize, COMDAT
; _this$ = ecx

; 842  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 03 00
	00		 sub	 esp, 860		; 0000035cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx

; 843  : 		if (RealSystemDriveSizeValid)

  00016	80 be c5 05 00
	00 00		 cmp	 BYTE PTR [esi+1477], 0
  0001d	75 73		 jne	 SHORT $LN3@ProbeRealS

; 844  : 			return;
; 845  : 
; 846  : 		GetSystemDriveConfiguration();

  0001f	8d 85 a8 fc ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  0002b	8d 8d a8 fc ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00031	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 847  : 
; 848  : 		ProbeRealDriveSizeRequest request;
; 849  : 		_snwprintf (request.DeviceName, array_capacity (request.DeviceName), L"%hs", DriveConfig.DrivePartition.DevicePath.c_str());

  00036	83 7e 54 10	 cmp	 DWORD PTR [esi+84], 16	; 00000010H
  0003a	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  0003d	72 02		 jb	 SHORT $LN19@ProbeRealS
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN19@ProbeRealS:
  00041	50		 push	 eax
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs?$AA?$AA@
  00047	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _request$[ebp]
  0004d	68 04 01 00 00	 push	 260			; 00000104H
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __snwprintf
  00058	83 c4 10	 add	 esp, 16			; 00000010H

; 850  : 		
; 851  : 		CallDriver (GST_IOCTL_PROBE_REAL_DRIVE_SIZE, &request, sizeof (request), &request, sizeof (request));

  0005b	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _request$[ebp]
  00061	8b ce		 mov	 ecx, esi
  00063	68 14 02 00 00	 push	 532			; 00000214H
  00068	50		 push	 eax
  00069	68 14 02 00 00	 push	 532			; 00000214H
  0006e	50		 push	 eax
  0006f	68 40 20 22 00	 push	 2236480			; 00222040H
  00074	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 852  : 		DriveConfig.DrivePartition.Info.PartitionLength = request.RealDriveSize;
; 853  : 
; 854  : 		RealSystemDriveSizeValid = true;
; 855  : 
; 856  : 		if (request.TimeOut)

  00079	83 7d f8 00	 cmp	 DWORD PTR _request$[ebp+528], 0
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _request$[ebp+520]
  00080	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00083	8b 45 f4	 mov	 eax, DWORD PTR _request$[ebp+524]
  00086	89 46 64	 mov	 DWORD PTR [esi+100], eax
  00089	c6 86 c5 05 00
	00 01		 mov	 BYTE PTR [esi+1477], 1
  00090	75 0f		 jne	 SHORT $LN29@ProbeRealS
$LN3@ProbeRealS:

; 858  : 	}

  00092	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00095	33 cd		 xor	 ecx, ebp
  00097	5e		 pop	 esi
  00098	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
$LN29@ProbeRealS:

; 857  : 			throw TimeOut (SRC_POS);

  000a1	68 00 00 00 00	 push	 OFFSET __TI2?AUTimeOut@GostCrypt@@
  000a6	8d 85 a4 fc ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000ac	c7 85 a4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], OFFSET ??_7TimeOut@GostCrypt@@6B@
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN31@ProbeRealS:
$LN28@ProbeRealS:
  000bc	cc		 int	 3
?ProbeRealSystemDriveSize@BootEncryption@GostCrypt@@QAEXXZ ENDP ; GostCrypt::BootEncryption::ProbeRealSystemDriveSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_e$2 = -564						; size = 4
$T3 = -556						; size = 12
_sector$4 = -544					; size = 8
$T5 = -536						; size = 8
_rescueIsoImagePath$GSCopy$ = -528			; size = 4
$T6 = -524						; size = 4
_sector$1$ = -520					; size = 4
_password$GSCopy$ = -516				; size = 4
_encryptedAreaStart$2$ = -512				; size = 4
_this$GSCopy$ = -512					; size = 4
_geometry$7 = -508					; size = 24
_encStatus$ = -484					; size = 94
_config$ = -388						; size = 320
_device$8 = -68						; size = 48
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_systemPartitionOnly$ = 8				; size = 1
_password$ = 12						; size = 4
_ea$ = 16						; size = 4
_mode$ = 20						; size = 4
_pkcs5$ = 24						; size = 4
_rescueIsoImagePath$ = 28				; size = 4
?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; GostCrypt::BootEncryption::PrepareInstallation, COMDAT
; _this$ = ecx

; 2899 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 28 02 00
	00		 sub	 esp, 552		; 00000228H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b f1		 mov	 esi, ecx
  00033	8b 45 0c	 mov	 eax, DWORD PTR _password$[ebp]
  00036	8b 5d 1c	 mov	 ebx, DWORD PTR _rescueIsoImagePath$[ebp]

; 2900 : 		BootEncryptionStatus encStatus = GetStatus();

  00039	6a 5e		 push	 94			; 0000005eH
  0003b	89 85 fc fd ff
	ff		 mov	 DWORD PTR _password$GSCopy$[ebp], eax
  00041	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR _encStatus$[ebp]
  00047	50		 push	 eax
  00048	6a 00		 push	 0
  0004a	6a 00		 push	 0
  0004c	68 48 20 22 00	 push	 2236488			; 00222048H
  00051	89 b5 00 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  00057	89 9d f0 fd ff
	ff		 mov	 DWORD PTR _rescueIsoImagePath$GSCopy$[ebp], ebx
  0005d	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 2901 : 		if (encStatus.DriveMounted)

  00062	83 bd 22 fe ff
	ff 00		 cmp	 DWORD PTR _encStatus$[ebp+6], 0
  00069	74 25		 je	 SHORT $LN2@PrepareIns

; 2902 : 			throw ParameterIncorrect (SRC_POS);

  0006b	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00070	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00076	c7 85 e8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00080	50		 push	 eax
  00081	c7 85 ec fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+4], OFFSET ??_C@_0DE@NDCLNHEC@GostCrypt?3?3BootEncryption?3?3Prepa@
  0008b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN186@PrepareIns:
$LN2@PrepareIns:

; 2903 : 
; 2904 : 		CheckRequirements ();

  00090	8b ce		 mov	 ecx, esi
  00092	e8 00 00 00 00	 call	 ?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::CheckRequirements

; 2905 : 
; 2906 : 		SystemDriveConfiguration config = GetSystemDriveConfiguration();

  00097	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR _config$[ebp]
  0009d	8b ce		 mov	 ecx, esi
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration

; 2907 : 
; 2908 : 		// Some chipset drivers may prevent access to the last sector of the drive
; 2909 : 		if (!systemPartitionOnly)

  000a5	80 7d 08 00	 cmp	 BYTE PTR _systemPartitionOnly$[ebp], 0
  000a9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000b0	0f 85 53 01 00
	00		 jne	 $LN168@PrepareIns

; 2910 : 		{
; 2911 : 			DISK_GEOMETRY geometry = GetDriveGeometry (config.DriveNumber);

  000b6	ff b5 ac fe ff
	ff		 push	 DWORD PTR _config$[ebp+48]
  000bc	8d 85 04 fe ff
	ff		 lea	 eax, DWORD PTR _geometry$7[ebp]
  000c2	8b ce		 mov	 ecx, esi
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z ; GostCrypt::BootEncryption::GetDriveGeometry

; 2912 : 			Buffer sector (geometry.BytesPerSector);

  000ca	8b 85 18 fe ff
	ff		 mov	 eax, DWORD PTR _geometry$7[ebp+20]
  000d0	50		 push	 eax
  000d1	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _sector$1$[ebp], eax
  000d7	89 85 e4 fd ff
	ff		 mov	 DWORD PTR _sector$4[ebp+4], eax
  000dd	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000e2	8b f8		 mov	 edi, eax
  000e4	83 c4 04	 add	 esp, 4
  000e7	89 bd e0 fd ff
	ff		 mov	 DWORD PTR _sector$4[ebp], edi
  000ed	85 ff		 test	 edi, edi
  000ef	75 30		 jne	 SHORT $LN26@PrepareIns
  000f1	0f 57 c0	 xorps	 xmm0, xmm0
  000f4	c7 85 d4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000fe	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00103	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00109	66 0f d6 85 d8
	fd ff ff	 movq	 QWORD PTR $T3[ebp+4], xmm0
  00111	50		 push	 eax
  00112	c7 85 d8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp+4], OFFSET ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
  0011c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN187@PrepareIns:
$LN26@PrepareIns:

; 2913 : 
; 2914 : 			Device device (config.DevicePath);

  00121	6a 00		 push	 0
  00123	83 ec 18	 sub	 esp, 24			; 00000018H
  00126	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0012a	8b cc		 mov	 ecx, esp
  0012c	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00133	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0013a	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0013e	72 04		 jb	 SHORT $LN151@PrepareIns
  00140	8b 01		 mov	 eax, DWORD PTR [ecx]
  00142	eb 02		 jmp	 SHORT $LN152@PrepareIns
$LN151@PrepareIns:
  00144	8b c1		 mov	 eax, ecx
$LN152@PrepareIns:
  00146	6a ff		 push	 -1
  00148	c6 00 00	 mov	 BYTE PTR [eax], 0
  0014b	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _config$[ebp+24]
  00151	6a 00		 push	 0
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00159	8d 4d bc	 lea	 ecx, DWORD PTR _device$8[ebp]
  0015c	e8 00 00 00 00	 call	 ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device

; 2915 : 
; 2916 : 			try
; 2917 : 			{
; 2918 : 				device.SeekAt (config.DrivePartition.Info.PartitionLength.QuadPart - geometry.BytesPerSector);

  00161	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _config$[ebp+88]
  00167	2b 8d 18 fe ff
	ff		 sub	 ecx, DWORD PTR _geometry$7[ebp+20]
  0016d	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _config$[ebp+92]
  00173	83 d8 00	 sbb	 eax, 0
  00176	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  0017a	50		 push	 eax
  0017b	51		 push	 ecx
  0017c	8d 4d bc	 lea	 ecx, DWORD PTR _device$8[ebp]
  0017f	e8 00 00 00 00	 call	 ?SeekAt@File@GostCrypt@@QAEX_J@Z ; GostCrypt::File::SeekAt

; 2919 : 				device.Read (sector.Ptr(), sector.Size());

  00184	ff b5 f8 fd ff
	ff		 push	 DWORD PTR _sector$1$[ebp]
  0018a	8d 4d bc	 lea	 ecx, DWORD PTR _device$8[ebp]
  0018d	57		 push	 edi
  0018e	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read
  00193	eb 58		 jmp	 SHORT $LN184@PrepareIns
__catch$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:

; 2920 : 			}
; 2921 : 			catch (SystemException &e)
; 2922 : 			{
; 2923 : 				if (e.ErrorCode != ERROR_CRC)

  00195	8b 8d cc fd ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  0019b	83 79 04 17	 cmp	 DWORD PTR [ecx+4], 23	; 00000017H
  0019f	74 34		 je	 SHORT $LN5@PrepareIns

; 2924 : 				{
; 2925 : 					e.Show (ParentWindow);

  001a1	8b 85 00 fe ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  001a7	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a9	ff 30		 push	 DWORD PTR [eax]
  001ab	ff 12		 call	 DWORD PTR [edx]

; 2926 : 					Error ("WHOLE_DRIVE_ENCRYPTION_PREVENTED_BY_DRIVERS");

  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@NPKCCOOP@WHOLE_DRIVE_ENCRYPTION_PREVENTED@
  001b2	e8 00 00 00 00	 call	 _Error
  001b7	83 c4 04	 add	 esp, 4

; 2927 : 					throw UserAbort (SRC_POS);

  001ba	c7 85 f4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], OFFSET ??_7UserAbort@GostCrypt@@6B@
  001c4	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  001ca	68 00 00 00 00	 push	 OFFSET __TI2?AUUserAbort@GostCrypt@@
  001cf	50		 push	 eax
  001d0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN188@PrepareIns:
$LN5@PrepareIns:

; 2928 : 				}
; 2929 : 			}

  001d5	b8 00 00 00 00	 mov	 eax, $LN17@PrepareIns
  001da	c3		 ret	 0
$LN17@PrepareIns:
  001db	8b bd e0 fd ff
	ff		 mov	 edi, DWORD PTR _sector$4[ebp]
  001e1	8b b5 00 fe ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  001e7	8b 9d f0 fd ff
	ff		 mov	 ebx, DWORD PTR _rescueIsoImagePath$GSCopy$[ebp]
$LN184@PrepareIns:

; 2930 : 		}

  001ed	8d 4d bc	 lea	 ecx, DWORD PTR _device$8[ebp]
  001f0	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  001f7	e8 00 00 00 00	 call	 ??1Device@GostCrypt@@QAE@XZ
  001fc	57		 push	 edi
  001fd	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00201	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00206	83 c4 04	 add	 esp, 4
$LN168@PrepareIns:

; 2931 : 
; 2932 : 		BackupSystemLoader ();

  00209	8b ce		 mov	 ecx, esi
  0020b	e8 00 00 00 00	 call	 ?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ ; GostCrypt::BootEncryption::BackupSystemLoader

; 2933 : 
; 2934 : 		uint64 volumeSize;
; 2935 : 		uint64 encryptedAreaStart;
; 2936 : 
; 2937 : 		if (systemPartitionOnly)

  00210	80 7d 08 00	 cmp	 BYTE PTR _systemPartitionOnly$[ebp], 0
  00214	74 1a		 je	 SHORT $LN6@PrepareIns

; 2938 : 		{
; 2939 : 			volumeSize = config.SystemPartition.Info.PartitionLength.QuadPart;

  00216	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _config$[ebp+224]
  0021c	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _config$[ebp+228]

; 2940 : 			encryptedAreaStart = config.SystemPartition.Info.StartingOffset.QuadPart;

  00222	8b bd 54 ff ff
	ff		 mov	 edi, DWORD PTR _config$[ebp+216]
  00228	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _config$[ebp+220]

; 2941 : 		}
; 2942 : 		else

  0022e	eb 2a		 jmp	 SHORT $LN185@PrepareIns
$LN6@PrepareIns:

; 2943 : 		{
; 2944 : 			volumeSize = config.DrivePartition.Info.PartitionLength.QuadPart - GST_BOOT_LOADER_AREA_SIZE;

  00230	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _config$[ebp+88]
  00236	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _config$[ebp+92]
  0023c	81 c1 00 82 ff
	ff		 add	 ecx, -32256		; ffff8200H

; 2945 : 			encryptedAreaStart = config.DrivePartition.Info.StartingOffset.QuadPart + GST_BOOT_LOADER_AREA_SIZE;

  00242	8b bd cc fe ff
	ff		 mov	 edi, DWORD PTR _config$[ebp+80]
  00248	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _config$[ebp+84]
  0024e	83 d2 ff	 adc	 edx, -1
  00251	81 c7 00 7e 00
	00		 add	 edi, 32256		; 00007e00H
  00257	83 d0 00	 adc	 eax, 0
$LN185@PrepareIns:

; 2946 : 		}
; 2947 : 
; 2948 : 		SelectedEncryptionAlgorithmId = ea;
; 2949 : 		CreateVolumeHeader (volumeSize, encryptedAreaStart, &password, ea, mode, pkcs5);

  0025a	ff 75 18	 push	 DWORD PTR _pkcs5$[ebp]
  0025d	89 85 00 fe ff
	ff		 mov	 DWORD PTR _encryptedAreaStart$2$[ebp], eax
  00263	ff 75 14	 push	 DWORD PTR _mode$[ebp]
  00266	8b 45 10	 mov	 eax, DWORD PTR _ea$[ebp]
  00269	50		 push	 eax
  0026a	ff b5 fc fd ff
	ff		 push	 DWORD PTR _password$GSCopy$[ebp]
  00270	89 86 48 01 00
	00		 mov	 DWORD PTR [esi+328], eax
  00276	ff b5 00 fe ff
	ff		 push	 DWORD PTR _encryptedAreaStart$2$[ebp]
  0027c	57		 push	 edi
  0027d	52		 push	 edx
  0027e	51		 push	 ecx
  0027f	8b ce		 mov	 ecx, esi
  00281	e8 00 00 00 00	 call	 ?CreateVolumeHeader@BootEncryption@GostCrypt@@IAEX_K0PAUPassword@@HHH@Z ; GostCrypt::BootEncryption::CreateVolumeHeader

; 2950 : 		
; 2951 : 		if (!rescueIsoImagePath.empty())

  00286	83 7b 10 00	 cmp	 DWORD PTR [ebx+16], 0
  0028a	74 0a		 je	 SHORT $LN8@PrepareIns

; 2952 : 			CreateRescueIsoImage (true, rescueIsoImagePath);

  0028c	53		 push	 ebx
  0028d	6a 01		 push	 1
  0028f	8b ce		 mov	 ecx, esi
  00291	e8 00 00 00 00	 call	 ?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GostCrypt::BootEncryption::CreateRescueIsoImage
$LN8@PrepareIns:

; 2953 : 	}

  00296	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp]
  0029c	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
  002a1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002a4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002ab	59		 pop	 ecx
  002ac	5f		 pop	 edi
  002ad	5e		 pop	 esi
  002ae	5b		 pop	 ebx
  002af	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b2	33 cd		 xor	 ecx, ebp
  002b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b9	8b e5		 mov	 esp, ebp
  002bb	5d		 pop	 ebp
  002bc	c2 18 00	 ret	 24			; 00000018H
$LN183@PrepareIns:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
  00000	8d 8d 7c fe ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$3:
  0000b	8d 8d e0 fd ff
	ff		 lea	 ecx, DWORD PTR _sector$4[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1Buffer@GostCrypt@@QAE@XZ ; GostCrypt::Buffer::~Buffer
__unwindfunclet$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$5:
  00016	8d 4d bc	 lea	 ecx, DWORD PTR _device$8[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1Device@GostCrypt@@QAE@XZ
__ehhandler$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  0001e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00022	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00025	8b 8a c8 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-568]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00041	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?PrepareInstallation@BootEncryption@GostCrypt@@QAEX_NAAUPassword@@HHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; GostCrypt::BootEncryption::PrepareInstallation
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?PrepareHiddenOSCreation@BootEncryption@GostCrypt@@QAEXHHH@Z
_TEXT	SEGMENT
$T1 = -108						; size = 8
_encStatus$ = -100					; size = 94
__$ArrayPad$ = -4					; size = 4
_ea$ = 8						; size = 4
_mode$ = 12						; size = 4
_pkcs5$ = 16						; size = 4
?PrepareHiddenOSCreation@BootEncryption@GostCrypt@@QAEXHHH@Z PROC ; GostCrypt::BootEncryption::PrepareHiddenOSCreation, COMDAT
; _this$ = ecx

; 2873 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 2874 : 		BootEncryptionStatus encStatus = GetStatus();

  00011	6a 5e		 push	 94			; 0000005eH
  00013	8d 45 9c	 lea	 eax, DWORD PTR _encStatus$[ebp]
  00016	8b f1		 mov	 esi, ecx
  00018	50		 push	 eax
  00019	6a 00		 push	 0
  0001b	6a 00		 push	 0
  0001d	68 48 20 22 00	 push	 2236488			; 00222048H
  00022	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 2875 : 		if (encStatus.DriveMounted)

  00027	83 7d a2 00	 cmp	 DWORD PTR _encStatus$[ebp+6], 0
  0002b	75 28		 jne	 SHORT $LN12@PrepareHid

; 2877 : 
; 2878 : 		CheckRequirements();

  0002d	8b ce		 mov	 ecx, esi
  0002f	e8 00 00 00 00	 call	 ?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ ; GostCrypt::BootEncryption::CheckRequirements

; 2879 : 		BackupSystemLoader();

  00034	8b ce		 mov	 ecx, esi
  00036	e8 00 00 00 00	 call	 ?BackupSystemLoader@BootEncryption@GostCrypt@@IAEXXZ ; GostCrypt::BootEncryption::BackupSystemLoader

; 2880 : 
; 2881 : 		SelectedEncryptionAlgorithmId = ea;
; 2882 : 	}

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003e	8b 45 08	 mov	 eax, DWORD PTR _ea$[ebp]
  00041	33 cd		 xor	 ecx, ebp
  00043	89 86 48 01 00
	00		 mov	 DWORD PTR [esi+328], eax
  00049	5e		 pop	 esi
  0004a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 0c 00	 ret	 12			; 0000000cH
$LN12@PrepareHid:

; 2876 : 			throw ParameterIncorrect (SRC_POS);

  00055	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  0005a	8d 45 94	 lea	 eax, DWORD PTR $T1[ebp]
  0005d	c7 45 94 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00064	50		 push	 eax
  00065	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T1[ebp+4], OFFSET ??_C@_0DI@OHOEDBDC@GostCrypt?3?3BootEncryption?3?3Prepa@
  0006c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@PrepareHid:
$LN11@PrepareHid:
  00071	cc		 int	 3
?PrepareHiddenOSCreation@BootEncryption@GostCrypt@@QAEXHHH@Z ENDP ; GostCrypt::BootEncryption::PrepareHiddenOSCreation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?IsPagingFileActive@BootEncryption@GostCrypt@@QAE_NH@Z
_TEXT	SEGMENT
_checkNonWindowsPartitionsOnly$ = 8			; size = 4
?IsPagingFileActive@BootEncryption@GostCrypt@@QAE_NH@Z PROC ; GostCrypt::BootEncryption::IsPagingFileActive, COMDAT
; _this$ = ecx

; 2964 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2965 : 		if (!IsAdmin() && IsUacSupported())

  00003	e8 00 00 00 00	 call	 _IsAdmin
  00008	85 c0		 test	 eax, eax
  0000a	75 25		 jne	 SHORT $LN2@IsPagingFi
  0000c	e8 00 00 00 00	 call	 _IsUacSupported
  00011	85 c0		 test	 eax, eax
  00013	74 1c		 je	 SHORT $LN2@IsPagingFi

; 2966 : 			return Elevator::IsPagingFileActive (checkNonWindowsPartitionsOnly) ? true : false;

  00015	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  0001f	ff 75 08	 push	 DWORD PTR _checkNonWindowsPartitionsOnly$[ebp]
  00022	50		 push	 eax
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	ff 51 24	 call	 DWORD PTR [ecx+36]

; 2967 : 
; 2968 : 		return ::IsPagingFileActive (checkNonWindowsPartitionsOnly) ? true : false;

  00028	85 c0		 test	 eax, eax
  0002a	0f 95 c0	 setne	 al

; 2969 : 	}

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
$LN2@IsPagingFi:

; 2967 : 
; 2968 : 		return ::IsPagingFileActive (checkNonWindowsPartitionsOnly) ? true : false;

  00031	ff 75 08	 push	 DWORD PTR _checkNonWindowsPartitionsOnly$[ebp]
  00034	e8 00 00 00 00	 call	 _IsPagingFileActive
  00039	83 c4 04	 add	 esp, 4
  0003c	85 c0		 test	 eax, eax
  0003e	0f 95 c0	 setne	 al

; 2969 : 	}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?IsPagingFileActive@BootEncryption@GostCrypt@@QAE_NH@Z ENDP ; GostCrypt::BootEncryption::IsPagingFileActive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?IsHiddenSystemRunning@BootEncryption@GostCrypt@@QAE_NXZ
_TEXT	SEGMENT
_hiddenSystemStatus$ = -4				; size = 4
?IsHiddenSystemRunning@BootEncryption@GostCrypt@@QAE_NXZ PROC ; GostCrypt::BootEncryption::IsHiddenSystemRunning, COMDAT
; _this$ = ecx

; 1099 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1100 : 		int hiddenSystemStatus;
; 1101 : 		
; 1102 : 		CallDriver (GST_IOCTL_IS_HIDDEN_SYSTEM_RUNNING, nullptr, 0, &hiddenSystemStatus, sizeof (hiddenSystemStatus));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _hiddenSystemStatus$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	6a 00		 push	 0
  0000e	68 6c 20 22 00	 push	 2236524			; 0022206cH
  00013	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 1103 : 		return hiddenSystemStatus != 0;

  00018	33 c0		 xor	 eax, eax
  0001a	39 45 fc	 cmp	 DWORD PTR _hiddenSystemStatus$[ebp], eax
  0001d	0f 95 c0	 setne	 al

; 1104 : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?IsHiddenSystemRunning@BootEncryption@GostCrypt@@QAE_NXZ ENDP ; GostCrypt::BootEncryption::IsHiddenSystemRunning
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?IsCDDrivePresent@BootEncryption@GostCrypt@@QAE_NXZ
_TEXT	SEGMENT
_path$1 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
?IsCDDrivePresent@BootEncryption@GostCrypt@@QAE_NXZ PROC ; GostCrypt::BootEncryption::IsCDDrivePresent, COMDAT
; _this$ = ecx

; 2000 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi

; 2001 : 		for (char drive = 'Z'; drive >= 'C'; --drive)

  00012	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDriveTypeA@4
  00018	b3 5a		 mov	 bl, 90			; 0000005aH
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@IsCDDriveP:

; 2002 : 		{
; 2003 : 			string path = "X:\\";

  00020	6a 03		 push	 3
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_03OPPAHFLA@X?3?2?$AA@
  00027	8d 4d e4	 lea	 ecx, DWORD PTR _path$1[ebp]
  0002a	c7 45 f8 0f 00
	00 00		 mov	 DWORD PTR _path$1[ebp+20], 15 ; 0000000fH
  00031	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _path$1[ebp+16], 0
  00038	c6 45 e4 00	 mov	 BYTE PTR _path$1[ebp], 0
  0003c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2004 : 			path[0] = drive;

  00041	83 7d f8 10	 cmp	 DWORD PTR _path$1[ebp+20], 16 ; 00000010H
  00045	8d 45 e4	 lea	 eax, DWORD PTR _path$1[ebp]
  00048	0f 43 45 e4	 cmovae	 eax, DWORD PTR _path$1[ebp]
  0004c	88 18		 mov	 BYTE PTR [eax], bl

; 2005 : 
; 2006 : 			if (GetDriveType (path.c_str()) == DRIVE_CDROM)

  0004e	8d 45 e4	 lea	 eax, DWORD PTR _path$1[ebp]
  00051	83 7d f8 10	 cmp	 DWORD PTR _path$1[ebp+20], 16 ; 00000010H
  00055	0f 43 45 e4	 cmovae	 eax, DWORD PTR _path$1[ebp]
  00059	50		 push	 eax
  0005a	ff d6		 call	 esi
  0005c	83 f8 05	 cmp	 eax, 5
  0005f	74 4f		 je	 SHORT $LN410@IsCDDriveP

; 2008 : 		}

  00061	8b 4d f8	 mov	 ecx, DWORD PTR _path$1[ebp+20]
  00064	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00067	72 2e		 jb	 SHORT $LN373@IsCDDriveP
  00069	8b 45 e4	 mov	 eax, DWORD PTR _path$1[ebp]
  0006c	41		 inc	 ecx
  0006d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00073	72 19		 jb	 SHORT $LN368@IsCDDriveP
  00075	a8 1f		 test	 al, 31			; 0000001fH
  00077	75 7f		 jne	 SHORT $LN421@IsCDDriveP
  00079	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0007c	3b c8		 cmp	 ecx, eax
  0007e	73 78		 jae	 SHORT $LN421@IsCDDriveP
  00080	2b c1		 sub	 eax, ecx
  00082	83 f8 04	 cmp	 eax, 4
  00085	72 71		 jb	 SHORT $LN421@IsCDDriveP
  00087	83 f8 23	 cmp	 eax, 35			; 00000023H
  0008a	77 6c		 ja	 SHORT $LN421@IsCDDriveP
  0008c	8b c1		 mov	 eax, ecx
$LN368@IsCDDriveP:
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00094	83 c4 04	 add	 esp, 4
$LN373@IsCDDriveP:

; 2001 : 		for (char drive = 'Z'; drive >= 'C'; --drive)

  00097	fe cb		 dec	 bl
  00099	80 fb 43	 cmp	 bl, 67			; 00000043H
  0009c	7d 82		 jge	 SHORT $LL4@IsCDDriveP

; 2009 : 
; 2010 : 		return false;

  0009e	5e		 pop	 esi
  0009f	32 c0		 xor	 al, al
  000a1	5b		 pop	 ebx

; 2011 : 	}

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
$LN410@IsCDDriveP:

; 2007 : 				return true;

  000b0	8b 45 f8	 mov	 eax, DWORD PTR _path$1[ebp+20]
  000b3	83 f8 10	 cmp	 eax, 16			; 00000010H
  000b6	72 2e		 jb	 SHORT $LN256@IsCDDriveP
  000b8	8b 4d e4	 mov	 ecx, DWORD PTR _path$1[ebp]
  000bb	40		 inc	 eax
  000bc	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000c1	72 1a		 jb	 SHORT $LN251@IsCDDriveP
  000c3	f6 c1 1f	 test	 cl, 31			; 0000001fH
  000c6	75 30		 jne	 SHORT $LN421@IsCDDriveP
  000c8	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  000cb	3b c1		 cmp	 eax, ecx
  000cd	73 2e		 jae	 SHORT $LN423@IsCDDriveP
  000cf	2b c8		 sub	 ecx, eax
  000d1	83 f9 04	 cmp	 ecx, 4
  000d4	72 2c		 jb	 SHORT $LN424@IsCDDriveP
  000d6	83 f9 23	 cmp	 ecx, 35			; 00000023H
  000d9	77 2c		 ja	 SHORT $LN425@IsCDDriveP
  000db	8b c8		 mov	 ecx, eax
$LN251@IsCDDriveP:
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e3	83 c4 04	 add	 esp, 4
$LN256@IsCDDriveP:

; 2011 : 	}

  000e6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e9	b0 01		 mov	 al, 1
  000eb	5e		 pop	 esi
  000ec	33 cd		 xor	 ecx, ebp
  000ee	5b		 pop	 ebx
  000ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
$LN421@IsCDDriveP:

; 2007 : 				return true;

  000f8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN426@IsCDDriveP:
$LN423@IsCDDriveP:
  000fd	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN427@IsCDDriveP:
$LN424@IsCDDriveP:
  00102	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN428@IsCDDriveP:
$LN425@IsCDDriveP:
  00107	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN429@IsCDDriveP:
$LN420@IsCDDriveP:
  0010c	cc		 int	 3
?IsCDDrivePresent@BootEncryption@GostCrypt@@QAE_NXZ ENDP ; GostCrypt::BootEncryption::IsCDDrivePresent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?InvalidateCachedSysDriveProperties@BootEncryption@GostCrypt@@QAEXXZ
_TEXT	SEGMENT
?InvalidateCachedSysDriveProperties@BootEncryption@GostCrypt@@QAEXXZ PROC ; GostCrypt::BootEncryption::InvalidateCachedSysDriveProperties, COMDAT
; _this$ = ecx

; 870  : 		DriveConfigValid = false;

  00000	66 c7 81 c4 05
	00 00 00 00	 mov	 WORD PTR [ecx+1476], 0

; 871  : 		RealSystemDriveSizeValid = false;
; 872  : 	}

  00009	c3		 ret	 0
?InvalidateCachedSysDriveProperties@BootEncryption@GostCrypt@@QAEXXZ ENDP ; GostCrypt::BootEncryption::InvalidateCachedSysDriveProperties
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z
_TEXT	SEGMENT
_pos$2 = -33192						; size = 8
_pos$3 = -33192						; size = 8
_pos$4 = -33192						; size = 8
$T5 = -33192						; size = 8
$T6 = -33184						; size = 320
$T7 = -32864						; size = 32
_device$ = -32832					; size = 48
_bootLoaderBuf$ = -32784				; size = 31744
_mbrVerificationBuf$ = -1040				; size = 512
_mbr$ = -528						; size = 512
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_preserveUserConfig$ = 8				; size = 1
_hiddenOSCreation$ = 12					; size = 1
?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z PROC ; GostCrypt::BootEncryption::InstallBootLoader, COMDAT
; _this$ = ecx

; 1777 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 9c 81 00 00	 mov	 eax, 33180		; 0000819cH
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b f1		 mov	 esi, ecx

; 1778 : 		byte bootLoaderBuf[GST_BOOT_LOADER_AREA_SIZE - GST_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE];
; 1779 : 		CreateBootLoaderInMemory (bootLoaderBuf, sizeof (bootLoaderBuf), false, hiddenOSCreation);

  00034	ff 75 0c	 push	 DWORD PTR _hiddenOSCreation$[ebp]
  00037	8d 85 f0 7f ff
	ff		 lea	 eax, DWORD PTR _bootLoaderBuf$[ebp]
  0003d	6a 00		 push	 0
  0003f	68 00 7c 00 00	 push	 31744			; 00007c00H
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z ; GostCrypt::BootEncryption::CreateBootLoaderInMemory

; 1780 : 
; 1781 : 		// Write MBR
; 1782 : 		Device device (GetSystemDriveConfiguration().DevicePath);

  0004a	6a 00		 push	 0
  0004c	8d 85 60 7e ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00052	8b ce		 mov	 ecx, esi
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  0005a	83 ec 18	 sub	 esp, 24			; 00000018H
  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00064	8b cc		 mov	 ecx, esp
  00066	8d 50 18	 lea	 edx, DWORD PTR [eax+24]
  00069	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00070	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00077	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0007b	72 04		 jb	 SHORT $LN124@InstallBoo
  0007d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007f	eb 02		 jmp	 SHORT $LN125@InstallBoo
$LN124@InstallBoo:
  00081	8b c1		 mov	 eax, ecx
$LN125@InstallBoo:
  00083	52		 push	 edx
  00084	c6 00 00	 mov	 BYTE PTR [eax], 0
  00087	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0008c	8d 8d c0 7f ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00092	e8 00 00 00 00	 call	 ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device
  00097	8d 8d 60 7e ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0009d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000a1	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 1783 : 		byte mbr[GST_SECTOR_SIZE_BIOS];
; 1784 : 
; 1785 : 		device.SeekAt (0);

  000a6	80 bd c0 7f ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  000ad	0f 57 c0	 xorps	 xmm0, xmm0
  000b0	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SetFilePointerEx@20
  000b6	66 0f 13 85 c8
	7f ff ff	 movlpd	 QWORD PTR _device$[ebp+8], xmm0
  000be	75 4b		 jne	 SHORT $LN136@InstallBoo
  000c0	6a 00		 push	 0
  000c2	6a 00		 push	 0
  000c4	66 0f 13 85 58
	7e ff ff	 movlpd	 QWORD PTR _pos$4[ebp], xmm0
  000cc	ff b5 5c 7e ff
	ff		 push	 DWORD PTR _pos$4[ebp+4]
  000d2	ff b5 58 7e ff
	ff		 push	 DWORD PTR _pos$4[ebp]
  000d8	ff b5 d0 7f ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  000de	ff d3		 call	 ebx
  000e0	85 c0		 test	 eax, eax
  000e2	75 27		 jne	 SHORT $LN136@InstallBoo
$LN302@InstallBoo:
  000e4	c7 85 58 7e ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000f4	89 85 5c 7e ff
	ff		 mov	 DWORD PTR $T5[ebp+4], eax
  000fa	8d 85 58 7e ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00100	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
$LN303@InstallBoo:
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN304@InstallBoo:
$LN136@InstallBoo:

; 1786 : 		device.Read (mbr, sizeof (mbr));

  0010b	68 00 02 00 00	 push	 512			; 00000200H
  00110	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _mbr$[ebp]
  00116	50		 push	 eax
  00117	8d 8d c0 7f ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  0011d	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read

; 1787 : 
; 1788 : 		if (preserveUserConfig && BufferContainsString (mbr, sizeof (mbr), GST_APP_NAME))

  00122	80 7d 08 00	 cmp	 BYTE PTR _preserveUserConfig$[ebp], 0
  00126	74 4e		 je	 SHORT $LN3@InstallBoo
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  0012d	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _mbr$[ebp]
  00133	68 00 02 00 00	 push	 512			; 00000200H
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 _BufferContainsString
  0013e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00141	85 c0		 test	 eax, eax
  00143	74 31		 je	 SHORT $LN3@InstallBoo

; 1789 : 		{
; 1790 : 			uint16 version = BE16 (*(uint16 *) (mbr + GST_BOOT_SECTOR_VERSION_OFFSET));

  00145	ff 75 9e	 push	 DWORD PTR _mbr$[ebp+430]
  00148	e8 00 00 00 00	 call	 _MirrorBytes16
  0014d	83 c4 04	 add	 esp, 4

; 1791 : 			if (version != 0)

  00150	66 85 c0	 test	 ax, ax
  00153	74 21		 je	 SHORT $LN3@InstallBoo

; 1792 : 			{
; 1793 : 				bootLoaderBuf[GST_BOOT_SECTOR_USER_CONFIG_OFFSET] = mbr[GST_BOOT_SECTOR_USER_CONFIG_OFFSET];
; 1794 : 				memcpy (bootLoaderBuf + GST_BOOT_SECTOR_USER_MESSAGE_OFFSET, mbr + GST_BOOT_SECTOR_USER_MESSAGE_OFFSET, GST_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);

  00155	0f 10 45 86	 movups	 xmm0, XMMWORD PTR _mbr$[ebp+406]
  00159	8a 45 a6	 mov	 al, BYTE PTR _mbr$[ebp+438]
  0015c	88 85 a6 81 ff
	ff		 mov	 BYTE PTR _bootLoaderBuf$[ebp+438], al
  00162	0f 11 85 86 81
	ff ff		 movups	 XMMWORD PTR _bootLoaderBuf$[ebp+406], xmm0
  00169	f3 0f 7e 45 96	 movq	 xmm0, QWORD PTR _mbr$[ebp+422]
  0016e	66 0f d6 85 96
	81 ff ff	 movq	 QWORD PTR _bootLoaderBuf$[ebp+422], xmm0
$LN3@InstallBoo:

; 1795 : 			}
; 1796 : 		}
; 1797 : 
; 1798 : 		memcpy (mbr, bootLoaderBuf, GST_MAX_MBR_BOOT_CODE_SIZE);
; 1799 : 
; 1800 : 		device.SeekAt (0);

  00176	80 bd c0 7f ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  0017d	8d b5 f0 7f ff
	ff		 lea	 esi, DWORD PTR _bootLoaderBuf$[ebp]
  00183	b9 6e 00 00 00	 mov	 ecx, 110		; 0000006eH
  00188	8d bd f0 fd ff
	ff		 lea	 edi, DWORD PTR _mbr$[ebp]
  0018e	0f 57 c0	 xorps	 xmm0, xmm0
  00191	f3 a5		 rep movsd
  00193	66 0f 13 85 c8
	7f ff ff	 movlpd	 QWORD PTR _device$[ebp+8], xmm0
  0019b	75 28		 jne	 SHORT $LN149@InstallBoo
  0019d	6a 00		 push	 0
  0019f	6a 00		 push	 0
  001a1	66 0f 13 85 58
	7e ff ff	 movlpd	 QWORD PTR _pos$3[ebp], xmm0
  001a9	ff b5 5c 7e ff
	ff		 push	 DWORD PTR _pos$3[ebp+4]
  001af	ff b5 58 7e ff
	ff		 push	 DWORD PTR _pos$3[ebp]
  001b5	ff b5 d0 7f ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  001bb	ff d3		 call	 ebx
  001bd	85 c0		 test	 eax, eax
  001bf	0f 84 1f ff ff
	ff		 je	 $LN302@InstallBoo
$LN149@InstallBoo:

; 1801 : 		device.Write (mbr, sizeof (mbr));

  001c5	68 00 02 00 00	 push	 512			; 00000200H
  001ca	8d 85 f0 fd ff
	ff		 lea	 eax, DWORD PTR _mbr$[ebp]
  001d0	50		 push	 eax
  001d1	8d 8d c0 7f ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  001d7	e8 00 00 00 00	 call	 ?Write@File@GostCrypt@@QAEXPAEK@Z ; GostCrypt::File::Write

; 1802 : 
; 1803 : 		byte mbrVerificationBuf[GST_SECTOR_SIZE_BIOS];
; 1804 : 		device.SeekAt (0);

  001dc	80 bd c0 7f ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  001e3	0f 57 c0	 xorps	 xmm0, xmm0
  001e6	66 0f 13 85 c8
	7f ff ff	 movlpd	 QWORD PTR _device$[ebp+8], xmm0
  001ee	75 28		 jne	 SHORT $LN161@InstallBoo
  001f0	6a 00		 push	 0
  001f2	6a 00		 push	 0
  001f4	66 0f 13 85 58
	7e ff ff	 movlpd	 QWORD PTR _pos$2[ebp], xmm0
  001fc	ff b5 5c 7e ff
	ff		 push	 DWORD PTR _pos$2[ebp+4]
  00202	ff b5 58 7e ff
	ff		 push	 DWORD PTR _pos$2[ebp]
  00208	ff b5 d0 7f ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  0020e	ff d3		 call	 ebx
  00210	85 c0		 test	 eax, eax
  00212	0f 84 cc fe ff
	ff		 je	 $LN302@InstallBoo
$LN161@InstallBoo:

; 1805 : 		device.Read (mbrVerificationBuf, sizeof (mbr));

  00218	68 00 02 00 00	 push	 512			; 00000200H
  0021d	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _mbrVerificationBuf$[ebp]
  00223	50		 push	 eax
  00224	8d 8d c0 7f ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  0022a	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read

; 1806 : 
; 1807 : 		if (memcmp (mbr, mbrVerificationBuf, sizeof (mbr)) != 0)

  0022f	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _mbr$[ebp]
  00235	be fc 01 00 00	 mov	 esi, 508		; 000001fcH
  0023a	8d 95 f0 fb ff
	ff		 lea	 edx, DWORD PTR _mbrVerificationBuf$[ebp]
$LL299@InstallBoo:
  00240	8b 01		 mov	 eax, DWORD PTR [ecx]
  00242	3b 02		 cmp	 eax, DWORD PTR [edx]
  00244	0f 85 83 00 00
	00		 jne	 $LN298@InstallBoo
  0024a	83 c1 04	 add	 ecx, 4
  0024d	83 c2 04	 add	 edx, 4
  00250	83 ee 04	 sub	 esi, 4
  00253	73 eb		 jae	 SHORT $LL299@InstallBoo

; 1809 : 
; 1810 : 		// Write boot loader
; 1811 : 		device.SeekAt (GST_SECTOR_SIZE_BIOS);

  00255	80 bd c0 7f ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  0025c	c7 85 c8 7f ff
	ff 00 02 00 00	 mov	 DWORD PTR _device$[ebp+8], 512 ; 00000200H
  00266	c7 85 cc 7f ff
	ff 00 00 00 00	 mov	 DWORD PTR _device$[ebp+12], 0
  00270	75 1b		 jne	 SHORT $LN287@InstallBoo
  00272	6a 00		 push	 0
  00274	6a 00		 push	 0
  00276	6a 00		 push	 0
  00278	68 00 02 00 00	 push	 512			; 00000200H
  0027d	ff b5 d0 7f ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  00283	ff d3		 call	 ebx
  00285	85 c0		 test	 eax, eax
  00287	0f 84 57 fe ff
	ff		 je	 $LN302@InstallBoo
$LN287@InstallBoo:

; 1812 : 		device.Write (bootLoaderBuf + GST_SECTOR_SIZE_BIOS, sizeof (bootLoaderBuf) - GST_SECTOR_SIZE_BIOS);

  0028d	68 00 7a 00 00	 push	 31232			; 00007a00H
  00292	8d 85 f0 81 ff
	ff		 lea	 eax, DWORD PTR _bootLoaderBuf$[ebp+512]
  00298	50		 push	 eax
  00299	8d 8d c0 7f ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  0029f	e8 00 00 00 00	 call	 ?Write@File@GostCrypt@@QAEXPAEK@Z ; GostCrypt::File::Write

; 1813 : 	}

  002a4	8d 8d c0 7f ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  002aa	e8 00 00 00 00	 call	 ??1Device@GostCrypt@@QAE@XZ
  002af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002b9	59		 pop	 ecx
  002ba	5f		 pop	 edi
  002bb	5e		 pop	 esi
  002bc	5b		 pop	 ebx
  002bd	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c0	33 cd		 xor	 ecx, ebp
  002c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c7	8b e5		 mov	 esp, ebp
  002c9	5d		 pop	 ebp
  002ca	c2 08 00	 ret	 8
$LN298@InstallBoo:

; 1808 : 			throw ErrorException ("ERROR_MBR_PROTECTED");

  002cd	33 c0		 xor	 eax, eax
  002cf	c7 85 a0 7f ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], OFFSET ??_7ErrorException@GostCrypt@@6B@
  002d9	66 89 85 a8 7f
	ff ff		 mov	 WORD PTR $T7[ebp+8], ax
  002e0	8d 85 a0 7f ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  002e6	c7 85 a4 7f ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+4], OFFSET ??_C@_0BE@GPJOEGCF@ERROR_MBR_PROTECTED?$AA@
  002f0	c7 85 bc 7f ff
	ff 07 00 00 00	 mov	 DWORD PTR $T7[ebp+28], 7
  002fa	c7 85 b8 7f ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+24], 0
  00304	68 00 00 00 00	 push	 OFFSET __TI2?AUErrorException@GostCrypt@@
  00309	e9 f7 fd ff ff	 jmp	 $LN303@InstallBoo
$LN301@InstallBoo:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z$0:
  00000	8d 8d 60 7e ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z$2:
  0000b	8d 8d c0 7f ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1Device@GostCrypt@@QAE@XZ
__ehhandler$?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a 54 7e ff
	ff		 mov	 ecx, DWORD PTR [edx-33196]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z ENDP ; GostCrypt::BootEncryption::InstallBootLoader
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?Install@BootEncryption@GostCrypt@@QAEX_N@Z
_TEXT	SEGMENT
_e$2 = -132						; size = 4
$T3 = -128						; size = 8
_this$GSCopy$ = -120					; size = 4
_encStatus$ = -116					; size = 94
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_hiddenSystem$ = 8					; size = 1
?Install@BootEncryption@GostCrypt@@QAEX_N@Z PROC	; GostCrypt::BootEncryption::Install, COMDAT
; _this$ = ecx

; 2832 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Install@BootEncryption@GostCrypt@@QAEX_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 78	 sub	 esp, 120		; 00000078H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002e	8b f1		 mov	 esi, ecx

; 2833 : 		BootEncryptionStatus encStatus = GetStatus();

  00030	6a 5e		 push	 94			; 0000005eH
  00032	8d 45 8c	 lea	 eax, DWORD PTR _encStatus$[ebp]
  00035	89 75 88	 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  00038	50		 push	 eax
  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	68 48 20 22 00	 push	 2236488			; 00222048H
  00042	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 2834 : 		if (encStatus.DriveMounted)

  00047	83 7d 92 00	 cmp	 DWORD PTR _encStatus$[ebp+6], 0
  0004b	74 1c		 je	 SHORT $LN2@Install

; 2835 : 			throw ParameterIncorrect (SRC_POS);

  0004d	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00052	8d 45 80	 lea	 eax, DWORD PTR $T3[ebp]
  00055	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0005c	50		 push	 eax
  0005d	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], OFFSET ??_C@_0CI@DLMOLIMI@GostCrypt?3?3BootEncryption?3?3Insta@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN24@Install:
$LN2@Install:

; 2836 : 
; 2837 : 		try
; 2838 : 		{
; 2839 : 			InstallBootLoader (false, hiddenSystem);

  00069	8b 5d 08	 mov	 ebx, DWORD PTR _hiddenSystem$[ebp]
  0006c	8b ce		 mov	 ecx, esi
  0006e	53		 push	 ebx
  0006f	6a 00		 push	 0
  00071	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00078	e8 00 00 00 00	 call	 ?InstallBootLoader@BootEncryption@GostCrypt@@QAEX_N0@Z ; GostCrypt::BootEncryption::InstallBootLoader

; 2840 : 
; 2841 : 			if (!hiddenSystem)

  0007d	84 db		 test	 bl, bl
  0007f	75 07		 jne	 SHORT $LN4@Install

; 2842 : 				InstallVolumeHeader ();

  00081	8b ce		 mov	 ecx, esi
  00083	e8 00 00 00 00	 call	 ?InstallVolumeHeader@BootEncryption@GostCrypt@@IAEXXZ ; GostCrypt::BootEncryption::InstallVolumeHeader
$LN4@Install:

; 2843 : 
; 2844 : 			RegisterBootDriver (hiddenSystem);

  00088	53		 push	 ebx
  00089	8b ce		 mov	 ecx, esi
  0008b	e8 00 00 00 00	 call	 ?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z ; GostCrypt::BootEncryption::RegisterBootDriver

; 2858 : 		}
; 2859 : 	}

  00090	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00093	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009a	59		 pop	 ecx
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a1	33 cd		 xor	 ecx, ebp
  000a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c2 04 00	 ret	 4
__catch$?Install@BootEncryption@GostCrypt@@QAEX_N@Z$0:

; 2845 : 		}
; 2846 : 		catch (Exception &)
; 2847 : 		{
; 2848 : 			try
; 2849 : 			{
; 2850 : 				RestoreSystemLoader ();

  000ae	8b 4d 88	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  000b1	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  000b4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000b8	e8 00 00 00 00	 call	 ?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ ; GostCrypt::BootEncryption::RestoreSystemLoader
$LN12@Install:

; 2856 : 
; 2857 : 			throw;

  000bd	6a 00		 push	 0
  000bf	6a 00		 push	 0
  000c1	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  000c8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN25@Install:
__catch$?Install@BootEncryption@GostCrypt@@QAEX_N@Z$1:

; 2851 : 			}
; 2852 : 			catch (Exception &e)
; 2853 : 			{
; 2854 : 				e.Show (ParentWindow);

  000cd	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  000d3	8b 45 88	 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  000d6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d8	ff 30		 push	 DWORD PTR [eax]
  000da	ff 12		 call	 DWORD PTR [edx]

; 2855 : 			}

  000dc	b8 00 00 00 00	 mov	 eax, $LN12@Install
  000e1	c3		 ret	 0
$LN23@Install:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Install@BootEncryption@GostCrypt@@QAEX_N@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a 78 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-136]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Install@BootEncryption@GostCrypt@@QAEX_N@Z
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Install@BootEncryption@GostCrypt@@QAEX_N@Z ENDP	; GostCrypt::BootEncryption::Install
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ
_TEXT	SEGMENT
_kernelPath$2 = -816					; size = 176
_ss$3 = -640						; size = 176
$T4 = -464						; size = 8
___$ReturnUdt$GSCopy$1$ = -460				; size = 4
_this$GSCopy$1$ = -456					; size = 4
$T5 = -452						; size = 4
_$S5$6 = -448						; size = 24
_$S4$7 = -448						; size = 24
_partitions$8 = -424					; size = 8
tv6558 = -416						; size = 4
_driveNumber$1$ = -416					; size = 4
_this$ = -416						; size = 4
_activePartitionFound$1$ = -411				; size = 1
_windowsFound$1$ = -410					; size = 1
$T9 = -409						; size = 1
$T10 = -409						; size = 1
$T11 = -409						; size = 1
_config$ = -408						; size = 320
_winDir$ = -88						; size = 24
$T12 = -64						; size = 24
$T13 = -64						; size = 24
$T14 = -64						; size = 24
$T15 = -40						; size = 24
$T16 = -40						; size = 24
$T17 = -40						; size = 24
$T18 = -40						; size = 24
$T19 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ PROC ; GostCrypt::BootEncryption::GetSystemDriveConfiguration, COMDAT
; _this$ = ecx

; 1211 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 24 03 00
	00		 sub	 esp, 804		; 00000324H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b f1		 mov	 esi, ecx
  00030	89 b5 38 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi
  00036	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00039	33 db		 xor	 ebx, ebx
  0003b	89 9d 3c fe ff
	ff		 mov	 DWORD PTR $T5[ebp], ebx
  00041	89 bd 34 fe ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], edi

; 1212 : 		if (DriveConfigValid)

  00047	38 9e c4 05 00
	00		 cmp	 BYTE PTR [esi+1476], bl
  0004d	74 12		 je	 SHORT $LN17@GetSystemD

; 1213 : 			return DriveConfig;

  0004f	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00052	51		 push	 ecx
  00053	8b cf		 mov	 ecx, edi
  00055	e8 00 00 00 00	 call	 ??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z
  0005a	8b c7		 mov	 eax, edi
  0005c	e9 8a 0a 00 00	 jmp	 $LN1@GetSystemD
$LN17@GetSystemD:

; 1214 : 
; 1215 : 		SystemDriveConfiguration config;

  00061	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp]
  00067	e8 00 00 00 00	 call	 ??0SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 1216 : 
; 1217 : 		string winDir = GetWindowsDirectory();

  0006c	8d 45 a8	 lea	 eax, DWORD PTR _winDir$[ebp]
  0006f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00076	50		 push	 eax
  00077	8b ce		 mov	 ecx, esi
  00079	e8 00 00 00 00	 call	 ?GetWindowsDirectoryA@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GostCrypt::BootEncryption::GetWindowsDirectoryA

; 1218 : 
; 1219 : 		// Scan all drives
; 1220 : 		for (int driveNumber = 0; driveNumber < 32; ++driveNumber)

  0007e	33 c0		 xor	 eax, eax
  00080	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00084	89 85 60 fe ff
	ff		 mov	 DWORD PTR _driveNumber$1$[ebp], eax
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL4@GetSystemD:

; 1221 : 		{
; 1222 : 			bool windowsFound = false;
; 1223 : 			bool activePartitionFound = false;
; 1224 : 			config.ExtraBootPartitionPresent = false;
; 1225 : 			config.SystemLoaderPresent = false;
; 1226 : 
; 1227 : 			PartitionList partitions = GetDrivePartitions (driveNumber);

  00090	50		 push	 eax
  00091	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _partitions$8[ebp]
  00097	c6 85 66 fe ff
	ff 00		 mov	 BYTE PTR _windowsFound$1$[ebp], 0
  0009e	50		 push	 eax
  0009f	8b ce		 mov	 ecx, esi
  000a1	c6 85 65 fe ff
	ff 00		 mov	 BYTE PTR _activePartitionFound$1$[ebp], 0
  000a8	c6 85 10 ff ff
	ff 00		 mov	 BYTE PTR _config$[ebp+168], 0
  000af	c6 45 a0 00	 mov	 BYTE PTR _config$[ebp+312], 0
  000b3	e8 00 00 00 00	 call	 ?GetDrivePartitions@BootEncryption@GostCrypt@@IAE?AV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@H@Z ; GostCrypt::BootEncryption::GetDrivePartitions

; 1228 : 			foreach (const Partition &part, partitions)

  000b8	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _partitions$8[ebp]
  000be	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000c2	50		 push	 eax
  000c3	8d 85 40 fe ff
	ff		 lea	 eax, DWORD PTR _$S4$7[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
  000cf	83 c4 08	 add	 esp, 8
  000d2	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR _$S4$7[ebp]
  000d8	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR _$S4$7[ebp]
  000de	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000e2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e5	ff d0		 call	 eax
  000e7	84 c0		 test	 al, al
  000e9	0f 84 dd 04 00
	00		 je	 $LN6@GetSystemD
  000ef	90		 npad	 1
$LL7@GetSystemD:
  000f0	8b b5 54 fe ff
	ff		 mov	 esi, DWORD PTR _$S4$7[ebp+20]
  000f6	33 c0		 xor	 eax, eax
  000f8	83 c6 08	 add	 esi, 8
  000fb	38 85 45 fe ff
	ff		 cmp	 BYTE PTR _$S4$7[ebp+5], al
  00101	0f 94 c0	 sete	 al
  00104	88 85 45 fe ff
	ff		 mov	 BYTE PTR _$S4$7[ebp+5], al
  0010a	84 c0		 test	 al, al
  0010c	0f 84 92 04 00
	00		 je	 $LN5@GetSystemD
$LL10@GetSystemD:
  00112	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0

; 1229 : 			{
; 1230 : 				if (!part.MountPoint.empty()
; 1231 : 					&& (_access ((part.MountPoint + "\\bootmgr").c_str(), 0) == 0 || _access ((part.MountPoint + "\\ntldr").c_str(), 0) == 0))

  00116	74 6e		 je	 SHORT $LN30@GetSystemD
  00118	68 00 00 00 00	 push	 OFFSET ??_C@_08OINNAHG@?2bootmgr?$AA@
  0011d	8d 7e 38	 lea	 edi, DWORD PTR [esi+56]
  00120	8d 45 c0	 lea	 eax, DWORD PTR $T14[ebp]
  00123	57		 push	 edi
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0012a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012d	83 cb 02	 or	 ebx, 2
  00130	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00134	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00138	89 9d 3c fe ff
	ff		 mov	 DWORD PTR $T5[ebp], ebx
  0013e	72 02		 jb	 SHORT $LN112@GetSystemD
  00140	8b 00		 mov	 eax, DWORD PTR [eax]
$LN112@GetSystemD:
  00142	6a 00		 push	 0
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 __access
  0014a	83 c4 08	 add	 esp, 8
  0014d	85 c0		 test	 eax, eax
  0014f	74 2c		 je	 SHORT $LN29@GetSystemD
  00151	68 00 00 00 00	 push	 OFFSET ??_C@_06JLGNLLFE@?2ntldr?$AA@
  00156	8d 45 d8	 lea	 eax, DWORD PTR $T19[ebp]
  00159	57		 push	 edi
  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00160	83 c4 0c	 add	 esp, 12			; 0000000cH
  00163	83 cb 04	 or	 ebx, 4
  00166	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0016a	72 02		 jb	 SHORT $LN129@GetSystemD
  0016c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN129@GetSystemD:
  0016e	6a 00		 push	 0
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 __access
  00176	83 c4 08	 add	 esp, 8
  00179	85 c0		 test	 eax, eax
  0017b	75 09		 jne	 SHORT $LN30@GetSystemD
$LN29@GetSystemD:
  0017d	c6 85 67 fe ff
	ff 01		 mov	 BYTE PTR $T11[ebp], 1
  00184	eb 07		 jmp	 SHORT $LN31@GetSystemD
$LN30@GetSystemD:
  00186	c6 85 67 fe ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
$LN31@GetSystemD:
  0018d	f6 c3 04	 test	 bl, 4
  00190	74 5b		 je	 SHORT $LN133@GetSystemD
  00192	8b 45 ec	 mov	 eax, DWORD PTR $T19[ebp+20]
  00195	83 e3 fb	 and	 ebx, -5			; fffffffbH
  00198	83 f8 10	 cmp	 eax, 16			; 00000010H
  0019b	72 3e		 jb	 SHORT $LN218@GetSystemD
  0019d	8b 4d d8	 mov	 ecx, DWORD PTR $T19[ebp]
  001a0	40		 inc	 eax
  001a1	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  001a6	72 2a		 jb	 SHORT $LN213@GetSystemD
  001a8	f6 c1 1f	 test	 cl, 31			; 0000001fH
  001ab	0f 85 b6 04 00
	00		 jne	 $LN3026@GetSystemD
  001b1	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  001b4	3b c1		 cmp	 eax, ecx
  001b6	0f 83 ab 04 00
	00		 jae	 $LN3026@GetSystemD
  001bc	2b c8		 sub	 ecx, eax
  001be	83 f9 04	 cmp	 ecx, 4
  001c1	0f 82 a0 04 00
	00		 jb	 $LN3026@GetSystemD
  001c7	83 f9 23	 cmp	 ecx, 35			; 00000023H
  001ca	0f 87 97 04 00
	00		 ja	 $LN3026@GetSystemD
  001d0	8b c8		 mov	 ecx, eax
$LN213@GetSystemD:
  001d2	51		 push	 ecx
  001d3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001d8	83 c4 04	 add	 esp, 4
$LN218@GetSystemD:
  001db	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T19[ebp+20], 15 ; 0000000fH
  001e2	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T19[ebp+16], 0
  001e9	c6 45 d8 00	 mov	 BYTE PTR $T19[ebp], 0
$LN133@GetSystemD:
  001ed	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  001f4	f6 c3 02	 test	 bl, 2
  001f7	74 49		 je	 SHORT $LN336@GetSystemD
  001f9	8b 45 d4	 mov	 eax, DWORD PTR $T14[ebp+20]
  001fc	83 e3 fd	 and	 ebx, -3			; fffffffdH
  001ff	83 f8 10	 cmp	 eax, 16			; 00000010H
  00202	72 3e		 jb	 SHORT $LN336@GetSystemD
  00204	8b 4d c0	 mov	 ecx, DWORD PTR $T14[ebp]
  00207	40		 inc	 eax
  00208	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0020d	72 2a		 jb	 SHORT $LN331@GetSystemD
  0020f	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00212	0f 85 4f 04 00
	00		 jne	 $LN3026@GetSystemD
  00218	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0021b	3b c1		 cmp	 eax, ecx
  0021d	0f 83 44 04 00
	00		 jae	 $LN3026@GetSystemD
  00223	2b c8		 sub	 ecx, eax
  00225	83 f9 04	 cmp	 ecx, 4
  00228	0f 82 39 04 00
	00		 jb	 $LN3026@GetSystemD
  0022e	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00231	0f 87 30 04 00
	00		 ja	 $LN3026@GetSystemD
  00237	8b c8		 mov	 ecx, eax
$LN331@GetSystemD:
  00239	51		 push	 ecx
  0023a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0023f	83 c4 04	 add	 esp, 4
$LN336@GetSystemD:
  00242	80 bd 67 fe ff
	ff 00		 cmp	 BYTE PTR $T11[ebp], 0
  00249	74 09		 je	 SHORT $LN18@GetSystemD

; 1232 : 				{
; 1233 : 					config.SystemLoaderPresent = true;

  0024b	c6 45 a0 01	 mov	 BYTE PTR _config$[ebp+312], 1

; 1234 : 				}
; 1235 : 				else if (!part.VolumeNameId.empty()

  0024f	e9 62 01 00 00	 jmp	 $LN20@GetSystemD
$LN18@GetSystemD:
  00254	83 7e 68 00	 cmp	 DWORD PTR [esi+104], 0

; 1236 : 					&& (_waccess ((part.VolumeNameId + L"\\bootmgr").c_str(), 0) == 0 || _waccess ((part.VolumeNameId + L"\\ntldr").c_str(), 0) == 0))

  00258	74 6e		 je	 SHORT $LN33@GetSystemD
  0025a	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@EONGMCPP@?$AA?2?$AAb?$AAo?$AAo?$AAt?$AAm?$AAg?$AAr?$AA?$AA@
  0025f	8d 7e 58	 lea	 edi, DWORD PTR [esi+88]
  00262	8d 45 c0	 lea	 eax, DWORD PTR $T13[ebp]
  00265	57		 push	 edi
  00266	50		 push	 eax
  00267	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0026c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0026f	83 cb 08	 or	 ebx, 8
  00272	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00276	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  0027a	89 9d 3c fe ff
	ff		 mov	 DWORD PTR $T5[ebp], ebx
  00280	72 02		 jb	 SHORT $LN393@GetSystemD
  00282	8b 00		 mov	 eax, DWORD PTR [eax]
$LN393@GetSystemD:
  00284	6a 00		 push	 0
  00286	50		 push	 eax
  00287	e8 00 00 00 00	 call	 __waccess
  0028c	83 c4 08	 add	 esp, 8
  0028f	85 c0		 test	 eax, eax
  00291	74 2c		 je	 SHORT $LN32@GetSystemD
  00293	68 00 00 00 00	 push	 OFFSET ??_C@_1O@MIGMNGND@?$AA?2?$AAn?$AAt?$AAl?$AAd?$AAr?$AA?$AA@
  00298	8d 45 d8	 lea	 eax, DWORD PTR $T18[ebp]
  0029b	57		 push	 edi
  0029c	50		 push	 eax
  0029d	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  002a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a5	83 cb 10	 or	 ebx, 16			; 00000010H
  002a8	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  002ac	72 02		 jb	 SHORT $LN410@GetSystemD
  002ae	8b 00		 mov	 eax, DWORD PTR [eax]
$LN410@GetSystemD:
  002b0	6a 00		 push	 0
  002b2	50		 push	 eax
  002b3	e8 00 00 00 00	 call	 __waccess
  002b8	83 c4 08	 add	 esp, 8
  002bb	85 c0		 test	 eax, eax
  002bd	75 09		 jne	 SHORT $LN33@GetSystemD
$LN32@GetSystemD:
  002bf	c6 85 67 fe ff
	ff 01		 mov	 BYTE PTR $T10[ebp], 1
  002c6	eb 07		 jmp	 SHORT $LN34@GetSystemD
$LN33@GetSystemD:
  002c8	c6 85 67 fe ff
	ff 00		 mov	 BYTE PTR $T10[ebp], 0
$LN34@GetSystemD:
  002cf	f6 c3 10	 test	 bl, 16			; 00000010H
  002d2	74 6a		 je	 SHORT $LN414@GetSystemD
  002d4	8b 45 ec	 mov	 eax, DWORD PTR $T18[ebp+20]
  002d7	83 e3 ef	 and	 ebx, -17		; ffffffefH
  002da	83 f8 08	 cmp	 eax, 8
  002dd	72 4b		 jb	 SHORT $LN501@GetSystemD
  002df	8b 4d d8	 mov	 ecx, DWORD PTR $T18[ebp]
  002e2	40		 inc	 eax
  002e3	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  002e8	0f 87 79 03 00
	00		 ja	 $LN3026@GetSystemD
  002ee	03 c0		 add	 eax, eax
  002f0	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  002f5	72 2a		 jb	 SHORT $LN496@GetSystemD
  002f7	f6 c1 1f	 test	 cl, 31			; 0000001fH
  002fa	0f 85 67 03 00
	00		 jne	 $LN3026@GetSystemD
  00300	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00303	3b c1		 cmp	 eax, ecx
  00305	0f 83 5c 03 00
	00		 jae	 $LN3026@GetSystemD
  0030b	2b c8		 sub	 ecx, eax
  0030d	83 f9 04	 cmp	 ecx, 4
  00310	0f 82 51 03 00
	00		 jb	 $LN3026@GetSystemD
  00316	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00319	0f 87 48 03 00
	00		 ja	 $LN3026@GetSystemD
  0031f	8b c8		 mov	 ecx, eax
$LN496@GetSystemD:
  00321	51		 push	 ecx
  00322	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00327	83 c4 04	 add	 esp, 4
$LN501@GetSystemD:
  0032a	33 c0		 xor	 eax, eax
  0032c	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR $T18[ebp+20], 7
  00333	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T18[ebp+16], 0
  0033a	66 89 45 d8	 mov	 WORD PTR $T18[ebp], ax
$LN414@GetSystemD:
  0033e	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00345	f6 c3 08	 test	 bl, 8
  00348	74 56		 je	 SHORT $LN620@GetSystemD
  0034a	8b 45 d4	 mov	 eax, DWORD PTR $T13[ebp+20]
  0034d	83 e3 f7	 and	 ebx, -9			; fffffff7H
  00350	83 f8 08	 cmp	 eax, 8
  00353	72 4b		 jb	 SHORT $LN620@GetSystemD
  00355	8b 4d c0	 mov	 ecx, DWORD PTR $T13[ebp]
  00358	40		 inc	 eax
  00359	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0035e	0f 87 03 03 00
	00		 ja	 $LN3026@GetSystemD
  00364	03 c0		 add	 eax, eax
  00366	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0036b	72 2a		 jb	 SHORT $LN615@GetSystemD
  0036d	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00370	0f 85 f1 02 00
	00		 jne	 $LN3026@GetSystemD
  00376	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00379	3b c1		 cmp	 eax, ecx
  0037b	0f 83 e6 02 00
	00		 jae	 $LN3026@GetSystemD
  00381	2b c8		 sub	 ecx, eax
  00383	83 f9 04	 cmp	 ecx, 4
  00386	0f 82 db 02 00
	00		 jb	 $LN3026@GetSystemD
  0038c	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0038f	0f 87 d2 02 00
	00		 ja	 $LN3026@GetSystemD
  00395	8b c8		 mov	 ecx, eax
$LN615@GetSystemD:
  00397	51		 push	 ecx
  00398	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0039d	83 c4 04	 add	 esp, 4
$LN620@GetSystemD:
  003a0	0f b6 45 a0	 movzx	 eax, BYTE PTR _config$[ebp+312]
  003a4	b9 01 00 00 00	 mov	 ecx, 1
  003a9	80 bd 67 fe ff
	ff 00		 cmp	 BYTE PTR $T10[ebp], 0
  003b0	0f 45 c1	 cmovne	 eax, ecx
  003b3	88 45 a0	 mov	 BYTE PTR _config$[ebp+312], al
$LN20@GetSystemD:

; 1237 : 				{
; 1238 : 					config.SystemLoaderPresent = true;
; 1239 : 				}
; 1240 : 
; 1241 : 				if (!windowsFound && !part.MountPoint.empty() && ToUpperCase (winDir).find (ToUpperCase (part.MountPoint)) == 0)

  003b6	80 bd 66 fe ff
	ff 00		 cmp	 BYTE PTR _windowsFound$1$[ebp], 0
  003bd	75 56		 jne	 SHORT $LN3082@GetSystemD
  003bf	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0
  003c3	74 50		 je	 SHORT $LN3082@GetSystemD
  003c5	8d 46 38	 lea	 eax, DWORD PTR [esi+56]
  003c8	50		 push	 eax
  003c9	8d 45 c0	 lea	 eax, DWORD PTR $T12[ebp]
  003cc	50		 push	 eax
  003cd	e8 00 00 00 00	 call	 ?ToUpperCase@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z ; ToUpperCase
  003d2	8b f8		 mov	 edi, eax
  003d4	8d 45 a8	 lea	 eax, DWORD PTR _winDir$[ebp]
  003d7	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  003db	50		 push	 eax
  003dc	8d 45 d8	 lea	 eax, DWORD PTR $T17[ebp]
  003df	83 cb 20	 or	 ebx, 32			; 00000020H
  003e2	50		 push	 eax
  003e3	89 9d 3c fe ff
	ff		 mov	 DWORD PTR $T5[ebp], ebx
  003e9	e8 00 00 00 00	 call	 ?ToUpperCase@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z ; ToUpperCase
  003ee	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  003f1	83 c4 10	 add	 esp, 16			; 00000010H
  003f4	83 cb 40	 or	 ebx, 64			; 00000040H
  003f7	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  003fb	72 02		 jb	 SHORT $LN689@GetSystemD
  003fd	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN689@GetSystemD:
  003ff	51		 push	 ecx
  00400	6a 00		 push	 0
  00402	57		 push	 edi
  00403	8b c8		 mov	 ecx, eax
  00405	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  0040a	c6 85 67 fe ff
	ff 01		 mov	 BYTE PTR $T9[ebp], 1
  00411	85 c0		 test	 eax, eax
  00413	74 07		 je	 SHORT $LN36@GetSystemD
$LN3082@GetSystemD:
  00415	c6 85 67 fe ff
	ff 00		 mov	 BYTE PTR $T9[ebp], 0
$LN36@GetSystemD:
  0041c	f6 c3 40	 test	 bl, 64			; 00000040H
  0041f	74 5b		 je	 SHORT $LN693@GetSystemD
  00421	8b 45 ec	 mov	 eax, DWORD PTR $T17[ebp+20]
  00424	83 e3 bf	 and	 ebx, -65		; ffffffbfH
  00427	83 f8 10	 cmp	 eax, 16			; 00000010H
  0042a	72 3e		 jb	 SHORT $LN778@GetSystemD
  0042c	8b 4d d8	 mov	 ecx, DWORD PTR $T17[ebp]
  0042f	40		 inc	 eax
  00430	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00435	72 2a		 jb	 SHORT $LN773@GetSystemD
  00437	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0043a	0f 85 27 02 00
	00		 jne	 $LN3026@GetSystemD
  00440	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00443	3b c1		 cmp	 eax, ecx
  00445	0f 83 1c 02 00
	00		 jae	 $LN3026@GetSystemD
  0044b	2b c8		 sub	 ecx, eax
  0044d	83 f9 04	 cmp	 ecx, 4
  00450	0f 82 11 02 00
	00		 jb	 $LN3026@GetSystemD
  00456	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00459	0f 87 08 02 00
	00		 ja	 $LN3026@GetSystemD
  0045f	8b c8		 mov	 ecx, eax
$LN773@GetSystemD:
  00461	51		 push	 ecx
  00462	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00467	83 c4 04	 add	 esp, 4
$LN778@GetSystemD:
  0046a	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T17[ebp+20], 15 ; 0000000fH
  00471	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+16], 0
  00478	c6 45 d8 00	 mov	 BYTE PTR $T17[ebp], 0
$LN693@GetSystemD:
  0047c	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00483	f6 c3 20	 test	 bl, 32			; 00000020H
  00486	74 49		 je	 SHORT $LN895@GetSystemD
  00488	8b 4d d4	 mov	 ecx, DWORD PTR $T12[ebp+20]
  0048b	83 e3 df	 and	 ebx, -33		; ffffffdfH
  0048e	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00491	72 3e		 jb	 SHORT $LN895@GetSystemD
  00493	8b 45 c0	 mov	 eax, DWORD PTR $T12[ebp]
  00496	41		 inc	 ecx
  00497	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0049d	72 29		 jb	 SHORT $LN890@GetSystemD
  0049f	a8 1f		 test	 al, 31			; 0000001fH
  004a1	0f 85 c0 01 00
	00		 jne	 $LN3026@GetSystemD
  004a7	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  004aa	3b c8		 cmp	 ecx, eax
  004ac	0f 83 b5 01 00
	00		 jae	 $LN3026@GetSystemD
  004b2	2b c1		 sub	 eax, ecx
  004b4	83 f8 04	 cmp	 eax, 4
  004b7	0f 82 aa 01 00
	00		 jb	 $LN3026@GetSystemD
  004bd	83 f8 23	 cmp	 eax, 35			; 00000023H
  004c0	0f 87 a1 01 00
	00		 ja	 $LN3026@GetSystemD
  004c6	8b c1		 mov	 eax, ecx
$LN890@GetSystemD:
  004c8	50		 push	 eax
  004c9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  004ce	83 c4 04	 add	 esp, 4
$LN895@GetSystemD:
  004d1	80 bd 67 fe ff
	ff 00		 cmp	 BYTE PTR $T9[ebp], 0
  004d8	74 70		 je	 SHORT $LN21@GetSystemD

; 1242 : 				{
; 1243 : 					config.SystemPartition = part;

  004da	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _config$[ebp+192]
  004e0	3b c6		 cmp	 eax, esi
  004e2	74 0c		 je	 SHORT $LN929@GetSystemD
  004e4	6a ff		 push	 -1
  004e6	6a 00		 push	 0
  004e8	56		 push	 esi
  004e9	8b c8		 mov	 ecx, eax
  004eb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN929@GetSystemD:
  004f0	0f 10 46 18	 movups	 xmm0, XMMWORD PTR [esi+24]
  004f4	8d 46 38	 lea	 eax, DWORD PTR [esi+56]
  004f7	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp+248]
  004fd	0f 11 85 40 ff
	ff ff		 movups	 XMMWORD PTR _config$[ebp+216], xmm0
  00504	0f 10 46 28	 movups	 xmm0, XMMWORD PTR [esi+40]
  00508	0f 11 85 50 ff
	ff ff		 movups	 XMMWORD PTR _config$[ebp+232], xmm0
  0050f	3b c8		 cmp	 ecx, eax
  00511	74 0a		 je	 SHORT $LN1077@GetSystemD
  00513	6a ff		 push	 -1
  00515	6a 00		 push	 0
  00517	50		 push	 eax
  00518	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN1077@GetSystemD:
  0051d	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  00520	8d 4d 80	 lea	 ecx, DWORD PTR _config$[ebp+280]
  00523	89 85 78 ff ff
	ff		 mov	 DWORD PTR _config$[ebp+272], eax
  00529	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0052c	89 85 7c ff ff
	ff		 mov	 DWORD PTR _config$[ebp+276], eax
  00532	8d 46 58	 lea	 eax, DWORD PTR [esi+88]
  00535	3b c8		 cmp	 ecx, eax
  00537	74 0a		 je	 SHORT $LN1224@GetSystemD
  00539	6a ff		 push	 -1
  0053b	6a 00		 push	 0
  0053d	50		 push	 eax
  0053e	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN1224@GetSystemD:

; 1244 : 					windowsFound = true;

  00543	c6 85 66 fe ff
	ff 01		 mov	 BYTE PTR _windowsFound$1$[ebp], 1
$LN21@GetSystemD:

; 1245 : 				}
; 1246 : 
; 1247 : 				if (!activePartitionFound && part.Info.BootIndicator)

  0054a	80 bd 65 fe ff
	ff 00		 cmp	 BYTE PTR _activePartitionFound$1$[ebp], 0
  00551	75 31		 jne	 SHORT $LN8@GetSystemD
  00553	80 7e 31 00	 cmp	 BYTE PTR [esi+49], 0
  00557	74 2b		 je	 SHORT $LN8@GetSystemD

; 1248 : 				{
; 1249 : 					activePartitionFound = true;
; 1250 : 
; 1251 : 					if (part.Info.PartitionLength.QuadPart > 0 && part.Info.PartitionLength.QuadPart <= GST_MAX_EXTRA_BOOT_PARTITION_SIZE)

  00559	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0055c	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0055f	c6 85 65 fe ff
	ff 01		 mov	 BYTE PTR _activePartitionFound$1$[ebp], 1
  00566	85 c9		 test	 ecx, ecx
  00568	7c 1a		 jl	 SHORT $LN8@GetSystemD
  0056a	7f 18		 jg	 SHORT $LN8@GetSystemD
  0056c	85 c0		 test	 eax, eax
  0056e	74 14		 je	 SHORT $LN8@GetSystemD
  00570	85 c9		 test	 ecx, ecx
  00572	7f 10		 jg	 SHORT $LN8@GetSystemD
  00574	7c 07		 jl	 SHORT $LN3078@GetSystemD
  00576	3d 00 00 00 20	 cmp	 eax, 536870912		; 20000000H
  0057b	77 07		 ja	 SHORT $LN8@GetSystemD
$LN3078@GetSystemD:

; 1252 : 						config.ExtraBootPartitionPresent = true;

  0057d	c6 85 10 ff ff
	ff 01		 mov	 BYTE PTR _config$[ebp+168], 1
$LN8@GetSystemD:

; 1228 : 			foreach (const Partition &part, partitions)

  00584	33 c0		 xor	 eax, eax
  00586	c6 85 44 fe ff
	ff 01		 mov	 BYTE PTR _$S4$7[ebp+4], 1
  0058d	38 85 45 fe ff
	ff		 cmp	 BYTE PTR _$S4$7[ebp+5], al
  00593	0f 94 c0	 sete	 al
  00596	88 85 45 fe ff
	ff		 mov	 BYTE PTR _$S4$7[ebp+5], al
  0059c	84 c0		 test	 al, al
  0059e	0f 85 6e fb ff
	ff		 jne	 $LL10@GetSystemD
$LN5@GetSystemD:
  005a4	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR _$S4$7[ebp]
  005aa	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR _$S4$7[ebp]
  005b0	ff 50 08	 call	 DWORD PTR [eax+8]
  005b3	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR _$S4$7[ebp]
  005b9	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR _$S4$7[ebp]
  005bf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  005c2	ff d0		 call	 eax
  005c4	84 c0		 test	 al, al
  005c6	0f 85 24 fb ff
	ff		 jne	 $LL7@GetSystemD
$LN6@GetSystemD:

; 1253 : 				}
; 1254 : 			}

  005cc	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR _$S4$7[ebp+8]
  005d2	8b 38		 mov	 edi, DWORD PTR [eax]
  005d4	89 00		 mov	 DWORD PTR [eax], eax
  005d6	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR _$S4$7[ebp+8]
  005dc	89 40 04	 mov	 DWORD PTR [eax+4], eax
  005df	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR _$S4$7[ebp+8]
  005e5	c7 85 4c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S4$7[ebp+12], 0
  005ef	3b f8		 cmp	 edi, eax
  005f1	74 1f		 je	 SHORT $LN1382@GetSystemD
$LL1383@GetSystemD:
  005f3	8b 37		 mov	 esi, DWORD PTR [edi]
  005f5	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  005f8	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  005fd	57		 push	 edi
  005fe	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00603	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR _$S4$7[ebp+8]
  00609	83 c4 04	 add	 esp, 4
  0060c	8b fe		 mov	 edi, esi
  0060e	3b f0		 cmp	 esi, eax
  00610	75 e1		 jne	 SHORT $LL1383@GetSystemD
$LN1382@GetSystemD:
  00612	6a 78		 push	 120			; 00000078H
  00614	6a 01		 push	 1
  00616	50		 push	 eax
  00617	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPAXII@Z ; std::_Deallocate
  0061c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1255 : 
; 1256 : 			if (windowsFound)

  0061f	80 bd 66 fe ff
	ff 00		 cmp	 BYTE PTR _windowsFound$1$[ebp], 0
  00626	75 69		 jne	 SHORT $LN3057@GetSystemD

; 1286 : 			}
; 1287 : 		}

  00628	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _partitions$8[ebp]
  0062e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00632	e8 00 00 00 00	 call	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear
  00637	6a 01		 push	 1
  00639	ff b5 58 fe ff
	ff		 push	 DWORD PTR _partitions$8[ebp]
  0063f	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _partitions$8[ebp]
  00645	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::deallocate
  0064a	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _driveNumber$1$[ebp]
  00650	40		 inc	 eax
  00651	89 85 60 fe ff
	ff		 mov	 DWORD PTR _driveNumber$1$[ebp], eax
  00657	83 f8 20	 cmp	 eax, 32			; 00000020H
  0065a	7d 10		 jge	 SHORT $LN3076@GetSystemD

; 1218 : 
; 1219 : 		// Scan all drives
; 1220 : 		for (int driveNumber = 0; driveNumber < 32; ++driveNumber)

  0065c	8b b5 38 fe ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  00662	e9 29 fa ff ff	 jmp	 $LL4@GetSystemD
$LN3026@GetSystemD:

; 1229 : 			{
; 1230 : 				if (!part.MountPoint.empty()
; 1231 : 					&& (_access ((part.MountPoint + "\\bootmgr").c_str(), 0) == 0 || _access ((part.MountPoint + "\\ntldr").c_str(), 0) == 0))

  00667	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN3086@GetSystemD:
$LN3076@GetSystemD:

; 1288 : 
; 1289 : 		throw ParameterIncorrect (SRC_POS);

  0066c	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00671	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00677	c7 85 30 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00681	50		 push	 eax
  00682	c7 85 34 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+4], OFFSET ??_C@_0DM@OMHMHGFL@GostCrypt?3?3BootEncryption?3?3GetSy@
  0068c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3087@GetSystemD:
$LN3057@GetSystemD:

; 1257 : 			{
; 1258 : 				config.DriveNumber = driveNumber;

  00691	8b bd 60 fe ff
	ff		 mov	 edi, DWORD PTR _driveNumber$1$[ebp]
  00697	89 bd 98 fe ff
	ff		 mov	 DWORD PTR _config$[ebp+48], edi

; 1259 : 
; 1260 : 				stringstream ss;

  0069d	c7 85 80 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _ss$3[ebp], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  006a7	c7 85 90 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _ss$3[ebp+16], OFFSET ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  006b1	c7 85 e8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _ss$3[ebp+104], OFFSET ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
  006bb	6a 00		 push	 0
  006bd	8d 85 98 fd ff
	ff		 lea	 eax, DWORD PTR _ss$3[ebp+24]
  006c3	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  006c7	81 cb 80 00 00
	00		 or	 ebx, 128		; 00000080H
  006cd	8d 8d 80 fd ff
	ff		 lea	 ecx, DWORD PTR _ss$3[ebp]
  006d3	50		 push	 eax
  006d4	89 9d 3c fe ff
	ff		 mov	 DWORD PTR $T5[ebp], ebx
  006da	e8 00 00 00 00	 call	 ??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::basic_iostream<char,std::char_traits<char> >::basic_iostream<char,std::char_traits<char> >
  006df	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _ss$3[ebp]
  006e5	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 8
  006ec	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  006ef	c7 84 05 80 fd
	ff ff 00 00 00
	00		 mov	 DWORD PTR _ss$3[ebp+eax], OFFSET ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  006fa	8b 85 80 fd ff
	ff		 mov	 eax, DWORD PTR _ss$3[ebp]
  00700	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00703	8d 41 98	 lea	 eax, DWORD PTR [ecx-104]
  00706	89 84 0d 7c fd
	ff ff		 mov	 DWORD PTR _ss$3[ebp+ecx-4], eax
  0070d	8d 85 98 fd ff
	ff		 lea	 eax, DWORD PTR _ss$3[ebp+24]
  00713	8b c8		 mov	 ecx, eax
  00715	89 85 60 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
  0071b	e8 00 00 00 00	 call	 ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
  00720	c7 85 98 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _ss$3[ebp+24], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0072a	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _ss$3[ebp+80], 0
  00734	c7 85 d4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _ss$3[ebp+84], 0

; 1261 : 				ss << "PhysicalDrive" << driveNumber;

  0073e	57		 push	 edi
  0073f	8d 85 90 fd ff
	ff		 lea	 eax, DWORD PTR _ss$3[ebp+16]
  00745	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00749	68 00 00 00 00	 push	 OFFSET ??_C@_0O@ICNEBHDC@PhysicalDrive?$AA@
  0074e	50		 push	 eax
  0074f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00754	83 c4 08	 add	 esp, 8
  00757	8b c8		 mov	 ecx, eax
  00759	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 1262 : 				config.DevicePath = ss.str();

  0075e	8d 45 d8	 lea	 eax, DWORD PTR $T16[ebp]
  00761	50		 push	 eax
  00762	8d 8d 80 fd ff
	ff		 lea	 ecx, DWORD PTR _ss$3[ebp]
  00768	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  0076d	8b f0		 mov	 esi, eax
  0076f	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR _config$[ebp+24]
  00775	3b c6		 cmp	 eax, esi
  00777	74 45		 je	 SHORT $LN1644@GetSystemD
  00779	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _config$[ebp+44]
  0077f	83 f8 10	 cmp	 eax, 16			; 00000010H
  00782	72 13		 jb	 SHORT $LN1650@GetSystemD
  00784	40		 inc	 eax
  00785	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp+24]
  0078b	50		 push	 eax
  0078c	ff b5 80 fe ff
	ff		 push	 DWORD PTR _config$[ebp+24]
  00792	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN1650@GetSystemD:
  00797	56		 push	 esi
  00798	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp+24]
  0079e	c7 85 94 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _config$[ebp+44], 15 ; 0000000fH
  007a8	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _config$[ebp+40], 0
  007b2	c6 85 80 fe ff
	ff 00		 mov	 BYTE PTR _config$[ebp+24], 0
  007b9	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN1644@GetSystemD:
  007be	8b 45 ec	 mov	 eax, DWORD PTR $T16[ebp+20]
  007c1	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  007c5	83 f8 10	 cmp	 eax, 16			; 00000010H
  007c8	72 0d		 jb	 SHORT $LN1940@GetSystemD
  007ca	40		 inc	 eax
  007cb	8d 4d d8	 lea	 ecx, DWORD PTR $T16[ebp]
  007ce	50		 push	 eax
  007cf	ff 75 d8	 push	 DWORD PTR $T16[ebp]
  007d2	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN1940@GetSystemD:

; 1263 : 
; 1264 : 				stringstream kernelPath;

  007d7	6a 01		 push	 1
  007d9	6a 03		 push	 3
  007db	8d 8d d0 fc ff
	ff		 lea	 ecx, DWORD PTR _kernelPath$2[ebp]
  007e1	e8 00 00 00 00	 call	 ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >

; 1265 : 				kernelPath << "\\Device\\Harddisk" << driveNumber << "\\Partition0";

  007e6	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OJHKIMBP@?2Partition0?$AA@
  007eb	57		 push	 edi
  007ec	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _kernelPath$2[ebp+16]
  007f2	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  007f6	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EPPOJBJL@?2Device?2Harddisk?$AA@
  007fb	50		 push	 eax
  007fc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00801	83 c4 08	 add	 esp, 8
  00804	8b c8		 mov	 ecx, eax
  00806	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  0080b	50		 push	 eax
  0080c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00811	83 c4 08	 add	 esp, 8

; 1266 : 				config.DeviceKernelPath = kernelPath.str();

  00814	8d 45 d8	 lea	 eax, DWORD PTR $T15[ebp]
  00817	8d 8d d0 fc ff
	ff		 lea	 ecx, DWORD PTR _kernelPath$2[ebp]
  0081d	50		 push	 eax
  0081e	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  00823	8b f0		 mov	 esi, eax
  00825	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR _config$[ebp]
  0082b	3b c6		 cmp	 eax, esi
  0082d	74 45		 je	 SHORT $LN2039@GetSystemD
  0082f	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _config$[ebp+20]
  00835	83 f8 10	 cmp	 eax, 16			; 00000010H
  00838	72 13		 jb	 SHORT $LN2045@GetSystemD
  0083a	40		 inc	 eax
  0083b	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp]
  00841	50		 push	 eax
  00842	ff b5 68 fe ff
	ff		 push	 DWORD PTR _config$[ebp]
  00848	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN2045@GetSystemD:
  0084d	56		 push	 esi
  0084e	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp]
  00854	c7 85 7c fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _config$[ebp+20], 15 ; 0000000fH
  0085e	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _config$[ebp+16], 0
  00868	c6 85 68 fe ff
	ff 00		 mov	 BYTE PTR _config$[ebp], 0
  0086f	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN2039@GetSystemD:
  00874	8b 45 ec	 mov	 eax, DWORD PTR $T15[ebp+20]
  00877	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  0087b	83 f8 10	 cmp	 eax, 16			; 00000010H
  0087e	72 0d		 jb	 SHORT $LN2335@GetSystemD
  00880	40		 inc	 eax
  00881	8d 4d d8	 lea	 ecx, DWORD PTR $T15[ebp]
  00884	50		 push	 eax
  00885	ff 75 d8	 push	 DWORD PTR $T15[ebp]
  00888	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN2335@GetSystemD:

; 1267 : 
; 1268 : 				config.DrivePartition = partitions.front();

  0088d	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR _partitions$8[ebp]
  00893	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp+56]
  00899	8b 00		 mov	 eax, DWORD PTR [eax]
  0089b	83 c0 08	 add	 eax, 8
  0089e	50		 push	 eax
  0089f	e8 00 00 00 00	 call	 ??4Partition@GostCrypt@@QAEAAU01@ABU01@@Z

; 1269 : 				partitions.pop_front();

  008a4	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR _partitions$8[ebp]
  008aa	8b 30		 mov	 esi, DWORD PTR [eax]
  008ac	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  008af	8b 06		 mov	 eax, DWORD PTR [esi]
  008b1	89 01		 mov	 DWORD PTR [ecx], eax
  008b3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  008b5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  008b8	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  008bb	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  008be	ff 8d 5c fe ff
	ff		 dec	 DWORD PTR _partitions$8[ebp+4]
  008c4	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  008c9	6a 01		 push	 1
  008cb	56		 push	 esi
  008cc	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _partitions$8[ebp]
  008d2	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::deallocate

; 1270 : 				config.Partitions = partitions;

  008d7	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR _partitions$8[ebp]
  008dd	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp+184]
  008e3	50		 push	 eax
  008e4	ff 30		 push	 DWORD PTR [eax]
  008e6	e8 00 00 00 00	 call	 ??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::assign<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > > >

; 1271 : 
; 1272 : 				config.InitialUnallocatedSpace = 0x7fffFFFFffffFFFFull;
; 1273 : 				config.TotalUnallocatedSpace = config.DrivePartition.Info.PartitionLength.QuadPart;

  008eb	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR _config$[ebp+88]
  008f1	89 45 98	 mov	 DWORD PTR _config$[ebp+304], eax
  008f4	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _config$[ebp+92]
  008fa	89 45 9c	 mov	 DWORD PTR _config$[ebp+308], eax

; 1274 : 
; 1275 : 				foreach (const Partition &part, config.Partitions)

  008fd	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR _config$[ebp+184]
  00903	50		 push	 eax
  00904	8d 85 40 fe ff
	ff		 lea	 eax, DWORD PTR _$S5$6[ebp]
  0090a	c7 85 18 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _config$[ebp+176], -1
  00914	50		 push	 eax
  00915	c7 85 1c ff ff
	ff ff ff ff 7f	 mov	 DWORD PTR _config$[ebp+180], 2147483647 ; 7fffffffH
  0091f	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
  00924	83 c4 08	 add	 esp, 8
  00927	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR _$S5$6[ebp]
  0092d	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR _$S5$6[ebp]
  00933	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  00937	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0093a	ff d0		 call	 eax
  0093c	84 c0		 test	 al, al
  0093e	0f 84 b7 00 00
	00		 je	 $LN12@GetSystemD
  00944	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL13@GetSystemD:
  00950	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR _$S5$6[ebp+20]
  00956	33 c9		 xor	 ecx, ecx
  00958	38 8d 45 fe ff
	ff		 cmp	 BYTE PTR _$S5$6[ebp+5], cl
  0095e	0f 94 c1	 sete	 cl
  00961	88 8d 45 fe ff
	ff		 mov	 BYTE PTR _$S5$6[ebp+5], cl
  00967	84 c9		 test	 cl, cl
  00969	74 68		 je	 SHORT $LN11@GetSystemD
  0096b	8b 5d 9c	 mov	 ebx, DWORD PTR _config$[ebp+308]
  0096e	8b bd 1c ff ff
	ff		 mov	 edi, DWORD PTR _config$[ebp+180]
  00974	8b b5 18 ff ff
	ff		 mov	 esi, DWORD PTR _config$[ebp+176]
  0097a	66 0f 1f 44 00
	00		 npad	 6
$LL16@GetSystemD:

; 1276 : 				{
; 1277 : 					if (part.Info.StartingOffset.QuadPart < config.InitialUnallocatedSpace)

  00980	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00983	3b c7		 cmp	 eax, edi
  00985	89 85 60 fe ff
	ff		 mov	 DWORD PTR tv6558[ebp], eax
  0098b	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0098e	7f 1a		 jg	 SHORT $LN25@GetSystemD
  00990	7c 04		 jl	 SHORT $LN3079@GetSystemD
  00992	3b c6		 cmp	 eax, esi
  00994	73 14		 jae	 SHORT $LN25@GetSystemD
$LN3079@GetSystemD:

; 1278 : 						config.InitialUnallocatedSpace = part.Info.StartingOffset.QuadPart;

  00996	8b bd 60 fe ff
	ff		 mov	 edi, DWORD PTR tv6558[ebp]
  0099c	8b f0		 mov	 esi, eax
  0099e	89 b5 18 ff ff
	ff		 mov	 DWORD PTR _config$[ebp+176], esi
  009a4	89 bd 1c ff ff
	ff		 mov	 DWORD PTR _config$[ebp+180], edi
$LN25@GetSystemD:

; 1279 : 
; 1280 : 					config.TotalUnallocatedSpace -= part.Info.PartitionLength.QuadPart;

  009aa	8b 45 98	 mov	 eax, DWORD PTR _config$[ebp+304]
  009ad	2b 42 28	 sub	 eax, DWORD PTR [edx+40]
  009b0	89 45 98	 mov	 DWORD PTR _config$[ebp+304], eax
  009b3	1b 5a 2c	 sbb	 ebx, DWORD PTR [edx+44]
  009b6	33 c0		 xor	 eax, eax
  009b8	84 c9		 test	 cl, cl
  009ba	89 5d 9c	 mov	 DWORD PTR _config$[ebp+308], ebx
  009bd	c6 85 44 fe ff
	ff 01		 mov	 BYTE PTR _$S5$6[ebp+4], 1
  009c4	0f 94 c0	 sete	 al
  009c7	8a c8		 mov	 cl, al
  009c9	88 8d 45 fe ff
	ff		 mov	 BYTE PTR _$S5$6[ebp+5], cl
  009cf	84 c0		 test	 al, al
  009d1	75 ad		 jne	 SHORT $LL16@GetSystemD
$LN11@GetSystemD:

; 1274 : 
; 1275 : 				foreach (const Partition &part, config.Partitions)

  009d3	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR _$S5$6[ebp]
  009d9	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR _$S5$6[ebp]
  009df	ff 50 08	 call	 DWORD PTR [eax+8]
  009e2	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR _$S5$6[ebp]
  009e8	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR _$S5$6[ebp]
  009ee	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  009f1	ff d0		 call	 eax
  009f3	84 c0		 test	 al, al
  009f5	0f 85 55 ff ff
	ff		 jne	 $LL13@GetSystemD
$LN12@GetSystemD:

; 1281 : 				}

  009fb	8d 8d 48 fe ff
	ff		 lea	 ecx, DWORD PTR _$S5$6[ebp+8]
  00a01	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00a05	e8 00 00 00 00	 call	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear
  00a0a	6a 01		 push	 1
  00a0c	ff b5 48 fe ff
	ff		 push	 DWORD PTR _$S5$6[ebp+8]
  00a12	8d 8d 48 fe ff
	ff		 lea	 ecx, DWORD PTR _$S5$6[ebp+8]
  00a18	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::deallocate

; 1282 : 
; 1283 : 				DriveConfig = config;

  00a1d	8b bd 38 fe ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  00a23	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR _config$[ebp]
  00a29	50		 push	 eax
  00a2a	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  00a2d	8b ce		 mov	 ecx, esi
  00a2f	e8 00 00 00 00	 call	 ??4SystemDriveConfiguration@GostCrypt@@QAEAAU01@ABU01@@Z

; 1284 : 				DriveConfigValid = true;
; 1285 : 				return DriveConfig;

  00a34	56		 push	 esi
  00a35	8b b5 34 fe ff
	ff		 mov	 esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  00a3b	8b ce		 mov	 ecx, esi
  00a3d	c6 87 c4 05 00
	00 01		 mov	 BYTE PTR [edi+1476], 1
  00a44	e8 00 00 00 00	 call	 ??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z
  00a49	8d 8d 38 fd ff
	ff		 lea	 ecx, DWORD PTR _kernelPath$2[ebp+104]
  00a4f	e8 00 00 00 00	 call	 ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  00a54	8d 85 38 fd ff
	ff		 lea	 eax, DWORD PTR _kernelPath$2[ebp+104]
  00a5a	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  00a5e	50		 push	 eax
  00a5f	c7 85 38 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _kernelPath$2[ebp+104], OFFSET ??_7ios_base@std@@6B@
  00a69	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00a6e	83 c4 04	 add	 esp, 4
  00a71	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _ss$3[ebp+104]
  00a77	e8 00 00 00 00	 call	 ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  00a7c	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _ss$3[ebp+104]
  00a82	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  00a86	50		 push	 eax
  00a87	c7 85 e8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _ss$3[ebp+104], OFFSET ??_7ios_base@std@@6B@
  00a91	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00a96	83 c4 04	 add	 esp, 4
  00a99	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _partitions$8[ebp]
  00a9f	e8 00 00 00 00	 call	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear
  00aa4	6a 01		 push	 1
  00aa6	ff b5 58 fe ff
	ff		 push	 DWORD PTR _partitions$8[ebp]
  00aac	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _partitions$8[ebp]
  00ab2	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::deallocate
  00ab7	8b 45 bc	 mov	 eax, DWORD PTR _winDir$[ebp+20]
  00aba	83 f8 10	 cmp	 eax, 16			; 00000010H
  00abd	72 0d		 jb	 SHORT $LN2860@GetSystemD
  00abf	40		 inc	 eax
  00ac0	8d 4d a8	 lea	 ecx, DWORD PTR _winDir$[ebp]
  00ac3	50		 push	 eax
  00ac4	ff 75 a8	 push	 DWORD PTR _winDir$[ebp]
  00ac7	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN2860@GetSystemD:
  00acc	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp]
  00ad2	c7 45 bc 0f 00
	00 00		 mov	 DWORD PTR _winDir$[ebp+20], 15 ; 0000000fH
  00ad9	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _winDir$[ebp+16], 0
  00ae0	c6 45 a8 00	 mov	 BYTE PTR _winDir$[ebp], 0
  00ae4	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
  00ae9	8b c6		 mov	 eax, esi
$LN1@GetSystemD:

; 1290 : 	}

  00aeb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00aee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00af5	59		 pop	 ecx
  00af6	5f		 pop	 edi
  00af7	5e		 pop	 esi
  00af8	5b		 pop	 ebx
  00af9	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00afc	33 cd		 xor	 ecx, ebp
  00afe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b03	8b e5		 mov	 esp, ebp
  00b05	5d		 pop	 ebp
  00b06	c2 04 00	 ret	 4
$LN3084@GetSystemD:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$1:
  00000	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$2:
  0000b	8d 4d a8	 lea	 ecx, DWORD PTR _winDir$[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$3:
  00013	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR _partitions$8[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::~list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$4:
  0001e	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR _$S4$7[ebp]
  00024	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$5:
  00029	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  0002f	83 e0 02	 and	 eax, 2
  00032	0f 84 0f 00 00
	00		 je	 $LN50@GetSystemD
  00038	83 a5 3c fe ff
	ff fd		 and	 DWORD PTR $T5[ebp], -3	; fffffffdH
  0003f	8d 4d c0	 lea	 ecx, DWORD PTR $T14[ebp]
  00042	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN50@GetSystemD:
  00047	c3		 ret	 0
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$7:
  00048	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  0004e	83 e0 08	 and	 eax, 8
  00051	0f 84 0f 00 00
	00		 je	 $LN56@GetSystemD
  00057	83 a5 3c fe ff
	ff f7		 and	 DWORD PTR $T5[ebp], -9	; fffffff7H
  0005e	8d 4d c0	 lea	 ecx, DWORD PTR $T13[ebp]
  00061	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN56@GetSystemD:
  00066	c3		 ret	 0
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$9:
  00067	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  0006d	83 e0 20	 and	 eax, 32			; 00000020H
  00070	0f 84 0f 00 00
	00		 je	 $LN62@GetSystemD
  00076	83 a5 3c fe ff
	ff df		 and	 DWORD PTR $T5[ebp], -33	; ffffffdfH
  0007d	8d 4d c0	 lea	 ecx, DWORD PTR $T12[ebp]
  00080	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN62@GetSystemD:
  00085	c3		 ret	 0
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$364:
  00086	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  0008c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00091	0f 84 15 00 00
	00		 je	 $LN1601@GetSystemD
  00097	81 a5 3c fe ff
	ff 7f ff ff ff	 and	 DWORD PTR $T5[ebp], -129 ; ffffff7fH
  000a1	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR _ss$3[ebp+104]
  000a7	e9 00 00 00 00	 jmp	 ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$LN1601@GetSystemD:
  000ac	c3		 ret	 0
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$365:
  000ad	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR _ss$3[ebp+32]
  000b3	e9 00 00 00 00	 jmp	 ??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_iostream<char,std::char_traits<char> >::~basic_iostream<char,std::char_traits<char> >
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$367:
  000b8	8b 8d 60 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$11:
  000c3	8d 8d 80 fd ff
	ff		 lea	 ecx, DWORD PTR _ss$3[ebp]
  000c9	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$369:
  000ce	e8 00 00 00 00	 call	 ___std_terminate
  000d3	c3		 ret	 0
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$13:
  000d4	8d 8d d0 fc ff
	ff		 lea	 ecx, DWORD PTR _kernelPath$2[ebp]
  000da	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$464:
  000df	e8 00 00 00 00	 call	 ___std_terminate
  000e4	c3		 ret	 0
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$15:
  000e5	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR _$S5$6[ebp]
  000eb	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$628:
  000f0	e8 00 00 00 00	 call	 ___std_terminate
  000f5	c3		 ret	 0
__unwindfunclet$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ$631:
  000f6	e8 00 00 00 00	 call	 ___std_terminate
  000fb	c3		 ret	 0
__ehhandler$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ:
  000fc	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00100	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00103	8b 8a cc fc ff
	ff		 mov	 ecx, DWORD PTR [edx-820]
  00109	33 c8		 xor	 ecx, eax
  0010b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00110	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00113	33 c8		 xor	 ecx, eax
  00115	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ
  0011f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ENDP ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?GetVolumeProperties@BootEncryption@GostCrypt@@QAEXPAUVOLUME_PROPERTIES_STRUCT@@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_properties$ = 8					; size = 4
?GetVolumeProperties@BootEncryption@GostCrypt@@QAEXPAUVOLUME_PROPERTIES_STRUCT@@@Z PROC ; GostCrypt::BootEncryption::GetVolumeProperties, COMDAT
; _this$ = ecx

; 1083 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1084 : 		if (properties == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _properties$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c0		 test	 eax, eax
  0000b	74 1a		 je	 SHORT $LN10@GetVolumeP

; 1086 : 
; 1087 : 		CallDriver (GST_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES, NULL, 0, properties, sizeof (*properties));

  0000d	68 54 02 00 00	 push	 596			; 00000254H
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	68 58 20 22 00	 push	 2236504			; 00222058H
  0001c	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 1088 : 	}

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN10@GetVolumeP:

; 1085 : 			throw ParameterIncorrect (SRC_POS);

  00027	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  0002c	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  0002f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00036	50		 push	 eax
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp+4], OFFSET ??_C@_0DE@OACJGKF@GostCrypt?3?3BootEncryption?3?3GetVo@
  0003e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN12@GetVolumeP:
$LN9@GetVolumeP:
  00043	cc		 int	 3
?GetVolumeProperties@BootEncryption@GostCrypt@@QAEXPAUVOLUME_PROPERTIES_STRUCT@@@Z ENDP ; GostCrypt::BootEncryption::GetVolumeProperties
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?GetTempPathA@BootEncryption@GostCrypt@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -276						; size = 4
$T2 = -272						; size = 8
_tempPath$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetTempPathA@BootEncryption@GostCrypt@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; GostCrypt::BootEncryption::GetTempPathA, COMDAT
; _this$ = ecx

; 997  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 		char tempPath[MAX_PATH];
; 999  : 		DWORD tempLen = ::GetTempPath (sizeof (tempPath), tempPath);

  00017	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _tempPath$[ebp]
  0001d	50		 push	 eax
  0001e	68 04 01 00 00	 push	 260			; 00000104H
  00023	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTempPathA@8

; 1000 : 		if (tempLen == 0 || tempLen > sizeof (tempPath))

  00033	85 c0		 test	 eax, eax
  00035	74 28		 je	 SHORT $LN13@GetTempPat
  00037	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  0003c	77 21		 ja	 SHORT $LN13@GetTempPat

; 1002 : 
; 1003 : 		return string (tempPath);

  0003e	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _tempPath$[ebp]
  00044	8b ce		 mov	 ecx, esi
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 1004 : 	}

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004f	8b c6		 mov	 eax, esi
  00051	33 cd		 xor	 ecx, ebp
  00053	5e		 pop	 esi
  00054	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN13@GetTempPat:

; 1001 : 			throw ParameterIncorrect (SRC_POS);

  0005f	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00064	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0006a	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00074	50		 push	 eax
  00075	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_0CN@FBLLBALE@GostCrypt?3?3BootEncryption?3?3GetTe@
  0007f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@GetTempPat:
$LN12@GetTempPat:
  00084	cc		 int	 3
?GetTempPathA@BootEncryption@GostCrypt@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; GostCrypt::BootEncryption::GetTempPathA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ PROC ; GostCrypt::BootEncryption::GetStatus, COMDAT
; _this$ = ecx

; 1065 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1066 : 		/* IMPORTANT: Do NOT add any potentially time-consuming operations to this function. */
; 1067 : 
; 1068 : 		BootEncryptionStatus status;
; 1069 : 		CallDriver (GST_IOCTL_GET_BOOT_ENCRYPTION_STATUS, NULL, 0, &status, sizeof (status));

  00003	6a 5e		 push	 94			; 0000005eH
  00005	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00008	6a 00		 push	 0
  0000a	6a 00		 push	 0
  0000c	68 48 20 22 00	 push	 2236488			; 00222048H
  00011	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 1070 : 		return status;

  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1071 : 	}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?GetStatus@BootEncryption@GostCrypt@@QAE?AUBootEncryptionStatus@@XZ ENDP ; GostCrypt::BootEncryption::GetStatus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?IsBootLoaderOnDrive@BootEncryption@GostCrypt@@QAE_NPAD@Z
_TEXT	SEGMENT
_dwResult$1 = -544					; size = 4
_openTestStruct$2 = -540				; size = 536
__$ArrayPad$ = -4					; size = 4
_devicePath$ = 8					; size = 4
?IsBootLoaderOnDrive@BootEncryption@GostCrypt@@QAE_NPAD@Z PROC ; GostCrypt::BootEncryption::IsBootLoaderOnDrive, COMDAT
; _this$ = ecx

; 1033 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1034 : 		try 
; 1035 : 		{
; 1036 : 			OPEN_TEST_STRUCT openTestStruct;
; 1037 : 			memset (&openTestStruct, 0, sizeof (openTestStruct));

  00013	68 18 02 00 00	 push	 536			; 00000218H
  00018	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _openTestStruct$2[ebp]
  0001e	6a 00		 push	 0
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _memset

; 1038 : 			DWORD dwResult;
; 1039 : 
; 1040 : 			strcpy ((char *) &openTestStruct.wszFileName[0], devicePath);

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _devicePath$[ebp]
  00029	8d 95 e4 fd ff
	ff		 lea	 edx, DWORD PTR _openTestStruct$2[ebp]
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00032	2b d1		 sub	 edx, ecx
$LL4@IsBootLoad:
  00034	8a 01		 mov	 al, BYTE PTR [ecx]
  00036	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00039	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  0003d	84 c0		 test	 al, al
  0003f	75 f3		 jne	 SHORT $LL4@IsBootLoad

; 1041 : 			ToUNICODE ((char *) &openTestStruct.wszFileName[0]);

  00041	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _openTestStruct$2[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _ToUNICODE
  0004d	83 c4 04	 add	 esp, 4

; 1042 : 
; 1043 : 			openTestStruct.bDetectGSTBootLoader = TRUE;

  00050	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _openTestStruct$2[ebp+520], 1

; 1044 : 
; 1045 : 			return (DeviceIoControl (hDriver, GST_IOCTL_OPEN_TEST,

  00057	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _dwResult$1[ebp]
  0005d	6a 00		 push	 0
  0005f	50		 push	 eax
  00060	68 18 02 00 00	 push	 536			; 00000218H
  00065	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _openTestStruct$2[ebp]
  0006b	50		 push	 eax
  0006c	68 18 02 00 00	 push	 536			; 00000218H
  00071	50		 push	 eax
  00072	68 34 20 22 00	 push	 2236468			; 00222034H
  00077	ff 35 00 00 00
	00		 push	 DWORD PTR _hDriver
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00083	85 c0		 test	 eax, eax
  00085	74 18		 je	 SHORT $LN5@IsBootLoad
  00087	83 7d f0 00	 cmp	 DWORD PTR _openTestStruct$2[ebp+524], 0
  0008b	74 12		 je	 SHORT $LN5@IsBootLoad
  0008d	b0 01		 mov	 al, 1

; 1046 : 				   &openTestStruct, sizeof (OPEN_TEST_STRUCT),
; 1047 : 				   &openTestStruct, sizeof (OPEN_TEST_STRUCT),
; 1048 : 				   &dwResult, NULL) && openTestStruct.GSTBootLoaderDetected);
; 1049 : 		}
; 1050 : 		catch (...)
; 1051 : 		{
; 1052 : 			return false;
; 1053 : 		}
; 1054 : 	}

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00092	33 cd		 xor	 ecx, ebp
  00094	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 04 00	 ret	 4
$LN5@IsBootLoad:
  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	32 c0		 xor	 al, al
  000a4	33 cd		 xor	 ecx, ebp
  000a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 04 00	 ret	 4
?IsBootLoaderOnDrive@BootEncryption@GostCrypt@@QAE_NPAD@Z ENDP ; GostCrypt::BootEncryption::IsBootLoaderOnDrive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -716				; size = 4
$T2 = -712						; size = 4
___$ReturnUdt$GSCopy$1$ = -708				; size = 4
tv4796 = -704						; size = 8
tv4788 = -704						; size = 8
$T3 = -704						; size = 8
_minOffsetFound$1$ = -700				; size = 4
_this$GSCopy$1$ = -696					; size = 4
_candidateForHiddenOSFound$1$ = -689			; size = 1
_bootPartition$4 = -688					; size = 112
_config$ = -576						; size = 320
$T5 = -256						; size = 24
$T6 = -256						; size = 24
$T7 = -256						; size = 24
$T8 = -256						; size = 24
$T9 = -232						; size = 24
$T10 = -232						; size = 24
$T11 = -232						; size = 24
$T12 = -232						; size = 24
_partitionBehindBoot$13 = -208				; size = 112
$T14 = -96						; size = 24
_$S2$15 = -96						; size = 24
$T16 = -72						; size = 32
$T17 = -72						; size = 32
$T18 = -40						; size = 24
$T19 = -40						; size = 24
$T20 = -40						; size = 24
_$S3$21 = -40						; size = 24
_$S1$22 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ PROC ; GostCrypt::BootEncryption::GetPartitionForHiddenOS, COMDAT
; _this$ = ecx

; 630  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 02 00
	00		 sub	 esp, 704		; 000002c0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b d9		 mov	 ebx, ecx
  00030	89 9d 48 fd ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx
  00036	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00039	c7 85 38 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  00043	89 8d 3c fd ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], ecx
  00049	89 8d 34 fd ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], ecx

; 631  : 		Partition candidatePartition;

  0004f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00056	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  0005d	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00064	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00068	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0006f	72 04		 jb	 SHORT $LN164@GetPartiti
  00071	8b 01		 mov	 eax, DWORD PTR [ecx]
  00073	eb 02		 jmp	 SHORT $LN165@GetPartiti
$LN164@GetPartiti:
  00075	8b c1		 mov	 eax, ecx
$LN165@GetPartiti:
  00077	c6 00 00	 mov	 BYTE PTR [eax], 0
  0007a	8d 41 38	 lea	 eax, DWORD PTR [ecx+56]
  0007d	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  00084	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  0008b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
  00092	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00096	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  0009d	72 02		 jb	 SHORT $LN271@GetPartiti
  0009f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN271@GetPartiti:
  000a1	c6 00 00	 mov	 BYTE PTR [eax], 0
  000a4	8d 41 58	 lea	 eax, DWORD PTR [ecx+88]
  000a7	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  000ae	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  000b5	c7 40 14 07 00
	00 00		 mov	 DWORD PTR [eax+20], 7
  000bc	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  000c0	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  000c7	72 02		 jb	 SHORT $LN380@GetPartiti
  000c9	8b 00		 mov	 eax, DWORD PTR [eax]
$LN380@GetPartiti:
  000cb	33 d2		 xor	 edx, edx
  000cd	66 89 10	 mov	 WORD PTR [eax], dx

; 737  : 		return candidatePartition;

  000d0	6a 70		 push	 112			; 00000070H
  000d2	52		 push	 edx
  000d3	51		 push	 ecx
  000d4	89 55 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edx
  000d7	c7 85 38 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR $T2[ebp], 1
  000e1	e8 00 00 00 00	 call	 _memset
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e9	66 c7 83 c4 05
	00 00 00 00	 mov	 WORD PTR [ebx+1476], 0
  000f2	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR _config$[ebp]
  000f8	8b cb		 mov	 ecx, ebx
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  00100	32 db		 xor	 bl, bl
  00102	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00109	83 bd d4 fe ff
	ff 00		 cmp	 DWORD PTR _config$[ebp+276], 0
  00110	88 9d 4f fd ff
	ff		 mov	 BYTE PTR _candidateForHiddenOSFound$1$[ebp], bl
  00116	74 25		 je	 SHORT $LN20@GetPartiti

; 632  : 
; 633  : 		memset (&candidatePartition, 0, sizeof(candidatePartition));
; 634  : 
; 635  : 		// The user may have modified/added/deleted partitions since the time the partition table was last scanned
; 636  : 		InvalidateCachedSysDriveProperties();
; 637  : 
; 638  : 		SystemDriveConfiguration config = GetSystemDriveConfiguration ();
; 639  : 		bool activePartitionFound = false;
; 640  : 		bool candidateForHiddenOSFound = false;
; 641  : 
; 642  : 		if (config.SystemPartition.IsGPT)
; 643  : 			throw ParameterIncorrect (SRC_POS);	// It is assumed that CheckRequirements() had been called

  00118	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  0011d	8d 85 40 fd ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00123	c7 85 40 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0012d	50		 push	 eax
  0012e	c7 85 44 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp+4], OFFSET ??_C@_0DH@EHEJHGNE@GostCrypt?3?3BootEncryption?3?3GetPa@
  00138	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2220@GetPartiti:
$LN20@GetPartiti:

; 644  : 
; 645  : 		// Find the first active partition on the system drive 
; 646  : 		foreach (const Partition &partition, config.Partitions)

  0013d	8d 85 78 fe ff
	ff		 lea	 eax, DWORD PTR _config$[ebp+184]
  00143	50		 push	 eax
  00144	8d 45 d8	 lea	 eax, DWORD PTR _$S1$22[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
  0014d	83 c4 08	 add	 esp, 8
  00150	8b 45 d8	 mov	 eax, DWORD PTR _$S1$22[ebp]
  00153	8d 4d d8	 lea	 ecx, DWORD PTR _$S1$22[ebp]
  00156	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0015a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0015d	ff d0		 call	 eax
  0015f	84 c0		 test	 al, al
  00161	0f 84 83 02 00
	00		 je	 $LN2209@GetPartiti
$LL4@GetPartiti:
  00167	8b 75 ec	 mov	 esi, DWORD PTR _$S1$22[ebp+20]
  0016a	33 c9		 xor	 ecx, ecx
  0016c	83 c6 08	 add	 esi, 8
  0016f	38 4d dd	 cmp	 BYTE PTR _$S1$22[ebp+5], cl
  00172	0f 94 c1	 sete	 cl
  00175	88 4d dd	 mov	 BYTE PTR _$S1$22[ebp+5], cl
  00178	84 c9		 test	 cl, cl
  0017a	0f 84 4e 02 00
	00		 je	 $LN2@GetPartiti
$LL7@GetPartiti:

; 647  : 		{
; 648  : 			if (partition.Info.BootIndicator)

  00180	80 7e 31 00	 cmp	 BYTE PTR [esi+49], 0
  00184	75 19		 jne	 SHORT $LN2177@GetPartiti

; 644  : 
; 645  : 		// Find the first active partition on the system drive 
; 646  : 		foreach (const Partition &partition, config.Partitions)

  00186	33 c0		 xor	 eax, eax
  00188	c6 45 dc 01	 mov	 BYTE PTR _$S1$22[ebp+4], 1
  0018c	84 c9		 test	 cl, cl
  0018e	0f 94 c0	 sete	 al
  00191	8a c8		 mov	 cl, al
  00193	88 4d dd	 mov	 BYTE PTR _$S1$22[ebp+5], cl
  00196	84 c0		 test	 al, al
  00198	75 e6		 jne	 SHORT $LL7@GetPartiti

; 666  : 							}
; 667  : 						}

  0019a	e9 2f 02 00 00	 jmp	 $LN2@GetPartiti
$LN2177@GetPartiti:

; 649  : 			{
; 650  : 				if (partition.Info.PartitionNumber != config.SystemPartition.Number)

  0019f	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  001a2	3b 85 d0 fe ff
	ff		 cmp	 eax, DWORD PTR _config$[ebp+272]
  001a8	0f 84 1e 02 00
	00		 je	 $LN22@GetPartiti

; 651  : 				{
; 652  : 					// If there is an extra boot partition, the system partition must be located right behind it
; 653  : 					if (IsOSAtLeast (WIN_7) && config.ExtraBootPartitionPresent)

  001ae	6a 0d		 push	 13			; 0000000dH
  001b0	e8 00 00 00 00	 call	 _IsOSAtLeast
  001b5	83 c4 04	 add	 esp, 4
  001b8	85 c0		 test	 eax, eax
  001ba	0f 84 97 03 00
	00		 je	 $LN23@GetPartiti
  001c0	80 bd 68 fe ff
	ff 00		 cmp	 BYTE PTR _config$[ebp+168], 0
  001c7	0f 84 8a 03 00
	00		 je	 $LN23@GetPartiti

; 654  : 					{
; 655  : 						int64 minOffsetFound = config.DrivePartition.Info.PartitionLength.QuadPart;

  001cd	8b bd 18 fe ff
	ff		 mov	 edi, DWORD PTR _config$[ebp+88]

; 656  : 						Partition bootPartition = partition;

  001d3	8d 8d 50 fd ff
	ff		 lea	 ecx, DWORD PTR _bootPartition$4[ebp]
  001d9	8b 9d 1c fe ff
	ff		 mov	 ebx, DWORD PTR _config$[ebp+92]
  001df	56		 push	 esi
  001e0	89 bd 44 fd ff
	ff		 mov	 DWORD PTR _minOffsetFound$1$[ebp], edi
  001e6	e8 00 00 00 00	 call	 ??0Partition@GostCrypt@@QAE@ABU01@@Z

; 657  : 						Partition partitionBehindBoot;

  001eb	33 c0		 xor	 eax, eax
  001ed	c7 85 44 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR _partitionBehindBoot$13[ebp+20], 15 ; 0000000fH
  001f7	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _partitionBehindBoot$13[ebp+16], 0
  00201	c6 85 30 ff ff
	ff 00		 mov	 BYTE PTR _partitionBehindBoot$13[ebp], 0
  00208	c7 85 7c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR _partitionBehindBoot$13[ebp+76], 15 ; 0000000fH
  00212	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _partitionBehindBoot$13[ebp+72], 0
  0021c	c6 85 68 ff ff
	ff 00		 mov	 BYTE PTR _partitionBehindBoot$13[ebp+56], 0
  00223	c7 45 9c 07 00
	00 00		 mov	 DWORD PTR _partitionBehindBoot$13[ebp+108], 7
  0022a	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _partitionBehindBoot$13[ebp+104], 0
  00231	66 89 45 88	 mov	 WORD PTR _partitionBehindBoot$13[ebp+88], ax

; 658  : 
; 659  : 						foreach (const Partition &partition, config.Partitions)

  00235	8d 85 78 fe ff
	ff		 lea	 eax, DWORD PTR _config$[ebp+184]
  0023b	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0023f	50		 push	 eax
  00240	8d 45 a0	 lea	 eax, DWORD PTR _$S2$15[ebp]
  00243	50		 push	 eax
  00244	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
  00249	83 c4 08	 add	 esp, 8
  0024c	8b 45 a0	 mov	 eax, DWORD PTR _$S2$15[ebp]
  0024f	8d 4d a0	 lea	 ecx, DWORD PTR _$S2$15[ebp]
  00252	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00256	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00259	ff d0		 call	 eax
  0025b	84 c0		 test	 al, al
  0025d	0f 84 df 00 00
	00		 je	 $LN9@GetPartiti
$LL10@GetPartiti:
  00263	8b 75 b4	 mov	 esi, DWORD PTR _$S2$15[ebp+20]
  00266	33 c0		 xor	 eax, eax
  00268	83 c6 08	 add	 esi, 8
  0026b	38 45 a5	 cmp	 BYTE PTR _$S2$15[ebp+5], al
  0026e	0f 94 c0	 sete	 al
  00271	88 45 a5	 mov	 BYTE PTR _$S2$15[ebp+5], al
  00274	84 c0		 test	 al, al
  00276	0f 84 aa 00 00
	00		 je	 $LN8@GetPartiti
  0027c	0f 1f 40 00	 npad	 4
$LL13@GetPartiti:

; 660  : 						{
; 661  : 							if (partition.Info.StartingOffset.QuadPart > bootPartition.Info.StartingOffset.QuadPart
; 662  : 								&& partition.Info.StartingOffset.QuadPart < minOffsetFound)

  00280	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00283	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00286	3b 8d 6c fd ff
	ff		 cmp	 ecx, DWORD PTR _bootPartition$4[ebp+28]
  0028c	7c 7b		 jl	 SHORT $LN11@GetPartiti
  0028e	7f 08		 jg	 SHORT $LN2210@GetPartiti
  00290	3b 85 68 fd ff
	ff		 cmp	 eax, DWORD PTR _bootPartition$4[ebp+24]
  00296	76 71		 jbe	 SHORT $LN11@GetPartiti
$LN2210@GetPartiti:
  00298	3b cb		 cmp	 ecx, ebx
  0029a	7f 6d		 jg	 SHORT $LN11@GetPartiti
  0029c	7c 04		 jl	 SHORT $LN2211@GetPartiti
  0029e	3b c7		 cmp	 eax, edi
  002a0	73 67		 jae	 SHORT $LN11@GetPartiti
$LN2211@GetPartiti:

; 663  : 							{
; 664  : 								minOffsetFound = partition.Info.StartingOffset.QuadPart;

  002a2	8b f8		 mov	 edi, eax
  002a4	8b d9		 mov	 ebx, ecx

; 665  : 								partitionBehindBoot = partition;

  002a6	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _partitionBehindBoot$13[ebp]
  002ac	3b c6		 cmp	 eax, esi
  002ae	74 0c		 je	 SHORT $LN751@GetPartiti
  002b0	6a ff		 push	 -1
  002b2	6a 00		 push	 0
  002b4	56		 push	 esi
  002b5	8b c8		 mov	 ecx, eax
  002b7	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN751@GetPartiti:
  002bc	0f 10 46 18	 movups	 xmm0, XMMWORD PTR [esi+24]
  002c0	8d 46 38	 lea	 eax, DWORD PTR [esi+56]
  002c3	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _partitionBehindBoot$13[ebp+56]
  002c9	0f 11 85 48 ff
	ff ff		 movups	 XMMWORD PTR _partitionBehindBoot$13[ebp+24], xmm0
  002d0	0f 10 46 28	 movups	 xmm0, XMMWORD PTR [esi+40]
  002d4	0f 11 85 58 ff
	ff ff		 movups	 XMMWORD PTR _partitionBehindBoot$13[ebp+40], xmm0
  002db	3b c8		 cmp	 ecx, eax
  002dd	74 0a		 je	 SHORT $LN882@GetPartiti
  002df	6a ff		 push	 -1
  002e1	6a 00		 push	 0
  002e3	50		 push	 eax
  002e4	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN882@GetPartiti:
  002e9	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  002ec	8d 4d 88	 lea	 ecx, DWORD PTR _partitionBehindBoot$13[ebp+88]
  002ef	89 45 80	 mov	 DWORD PTR _partitionBehindBoot$13[ebp+80], eax
  002f2	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  002f5	89 45 84	 mov	 DWORD PTR _partitionBehindBoot$13[ebp+84], eax
  002f8	8d 46 58	 lea	 eax, DWORD PTR [esi+88]
  002fb	3b c8		 cmp	 ecx, eax
  002fd	74 0a		 je	 SHORT $LN11@GetPartiti
  002ff	6a ff		 push	 -1
  00301	6a 00		 push	 0
  00303	50		 push	 eax
  00304	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN11@GetPartiti:

; 658  : 
; 659  : 						foreach (const Partition &partition, config.Partitions)

  00309	33 c0		 xor	 eax, eax
  0030b	c6 45 a4 01	 mov	 BYTE PTR _$S2$15[ebp+4], 1
  0030f	38 45 a5	 cmp	 BYTE PTR _$S2$15[ebp+5], al
  00312	0f 94 c0	 sete	 al
  00315	88 45 a5	 mov	 BYTE PTR _$S2$15[ebp+5], al
  00318	84 c0		 test	 al, al
  0031a	0f 85 60 ff ff
	ff		 jne	 $LL13@GetPartiti
  00320	89 bd 44 fd ff
	ff		 mov	 DWORD PTR _minOffsetFound$1$[ebp], edi
$LN8@GetPartiti:
  00326	8b 45 a0	 mov	 eax, DWORD PTR _$S2$15[ebp]
  00329	8d 4d a0	 lea	 ecx, DWORD PTR _$S2$15[ebp]
  0032c	ff 50 08	 call	 DWORD PTR [eax+8]
  0032f	8b 45 a0	 mov	 eax, DWORD PTR _$S2$15[ebp]
  00332	8d 4d a0	 lea	 ecx, DWORD PTR _$S2$15[ebp]
  00335	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00338	ff d0		 call	 eax
  0033a	84 c0		 test	 al, al
  0033c	0f 85 21 ff ff
	ff		 jne	 $LL10@GetPartiti
$LN9@GetPartiti:

; 666  : 							}
; 667  : 						}

  00342	8b 45 a8	 mov	 eax, DWORD PTR _$S2$15[ebp+8]
  00345	8b 38		 mov	 edi, DWORD PTR [eax]
  00347	89 00		 mov	 DWORD PTR [eax], eax
  00349	8b 45 a8	 mov	 eax, DWORD PTR _$S2$15[ebp+8]
  0034c	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0034f	8b 45 a8	 mov	 eax, DWORD PTR _$S2$15[ebp+8]
  00352	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _$S2$15[ebp+12], 0
  00359	3b f8		 cmp	 edi, eax
  0035b	74 1f		 je	 SHORT $LN1155@GetPartiti
  0035d	0f 1f 00	 npad	 3
$LL1156@GetPartiti:
  00360	8b 37		 mov	 esi, DWORD PTR [edi]
  00362	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00365	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  0036a	57		 push	 edi
  0036b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00370	8b 45 a8	 mov	 eax, DWORD PTR _$S2$15[ebp+8]
  00373	83 c4 04	 add	 esp, 4
  00376	8b fe		 mov	 edi, esi
  00378	3b f0		 cmp	 esi, eax
  0037a	75 e4		 jne	 SHORT $LL1156@GetPartiti
$LN1155@GetPartiti:
  0037c	50		 push	 eax
  0037d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 668  : 
; 669  : 						if (minOffsetFound != config.DrivePartition.Info.PartitionLength.QuadPart
; 670  : 							&& partitionBehindBoot.Number == config.SystemPartition.Number)

  00382	8b 85 44 fd ff
	ff		 mov	 eax, DWORD PTR _minOffsetFound$1$[ebp]
  00388	83 c4 04	 add	 esp, 4
  0038b	3b 85 18 fe ff
	ff		 cmp	 eax, DWORD PTR _config$[ebp+88]
  00391	75 0c		 jne	 SHORT $LN2212@GetPartiti
  00393	3b 9d 1c fe ff
	ff		 cmp	 ebx, DWORD PTR _config$[ebp+92]
  00399	0f 84 9e 01 00
	00		 je	 $LN25@GetPartiti
$LN2212@GetPartiti:
  0039f	8b 45 80	 mov	 eax, DWORD PTR _partitionBehindBoot$13[ebp+80]
  003a2	3b 85 d0 fe ff
	ff		 cmp	 eax, DWORD PTR _config$[ebp+272]
  003a8	0f 85 8f 01 00
	00		 jne	 $LN25@GetPartiti

; 671  : 						{
; 672  : 							activePartitionFound = true;
; 673  : 							break;

  003ae	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _partitionBehindBoot$13[ebp]
  003b4	b3 01		 mov	 bl, 1
  003b6	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  003bb	8d 8d 50 fd ff
	ff		 lea	 ecx, DWORD PTR _bootPartition$4[ebp]
  003c1	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  003c5	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  003ca	eb 02		 jmp	 SHORT $LN2@GetPartiti
$LN22@GetPartiti:

; 678  : 						+ GetRemarksOnHiddenOS());
; 679  : 				}
; 680  : 
; 681  : 				activePartitionFound = true;

  003cc	b3 01		 mov	 bl, 1
$LN2@GetPartiti:

; 644  : 
; 645  : 		// Find the first active partition on the system drive 
; 646  : 		foreach (const Partition &partition, config.Partitions)

  003ce	8b 45 d8	 mov	 eax, DWORD PTR _$S1$22[ebp]
  003d1	8d 4d d8	 lea	 ecx, DWORD PTR _$S1$22[ebp]
  003d4	ff 50 08	 call	 DWORD PTR [eax+8]
  003d7	8b 45 d8	 mov	 eax, DWORD PTR _$S1$22[ebp]
  003da	8d 4d d8	 lea	 ecx, DWORD PTR _$S1$22[ebp]
  003dd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003e0	ff d0		 call	 eax
  003e2	84 c0		 test	 al, al
  003e4	0f 85 7d fd ff
	ff		 jne	 $LL4@GetPartiti
$LN2209@GetPartiti:

; 682  : 				break;
; 683  : 			}
; 684  : 		}

  003ea	8d 4d e0	 lea	 ecx, DWORD PTR _$S1$22[ebp+8]
  003ed	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  003f1	e8 00 00 00 00	 call	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear
  003f6	6a 01		 push	 1
  003f8	ff 75 e0	 push	 DWORD PTR _$S1$22[ebp+8]
  003fb	8d 4d e0	 lea	 ecx, DWORD PTR _$S1$22[ebp+8]
  003fe	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::deallocate

; 685  : 
; 686  : 		/* WARNING: Note that the partition number at the end of a device path (\Device\HarddiskY\PartitionX) must
; 687  : 		NOT be used to find the first partition physically located behind the active one. The reason is that the 
; 688  : 		user may have deleted and created partitions during this session and e.g. the second partition could have 
; 689  : 		a higer number than the third one. */
; 690  : 
; 691  : 		
; 692  : 		// Find the first partition physically located behind the active partition
; 693  : 		if (activePartitionFound)

  00403	84 db		 test	 bl, bl
  00405	0f 84 3b 03 00
	00		 je	 $LN26@GetPartiti

; 694  : 		{
; 695  : 			int64 minOffsetFound = config.DrivePartition.Info.PartitionLength.QuadPart;

  0040b	8b bd 18 fe ff
	ff		 mov	 edi, DWORD PTR _config$[ebp+88]

; 696  : 
; 697  : 			foreach (const Partition &partition, config.Partitions)

  00411	8d 85 78 fe ff
	ff		 lea	 eax, DWORD PTR _config$[ebp+184]
  00417	8b 9d 1c fe ff
	ff		 mov	 ebx, DWORD PTR _config$[ebp+92]
  0041d	50		 push	 eax
  0041e	8d 45 d8	 lea	 eax, DWORD PTR _$S3$21[ebp]
  00421	50		 push	 eax
  00422	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
  00427	83 c4 08	 add	 esp, 8
  0042a	8b 45 d8	 mov	 eax, DWORD PTR _$S3$21[ebp]
  0042d	8d 4d d8	 lea	 ecx, DWORD PTR _$S3$21[ebp]
  00430	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00434	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00437	ff d0		 call	 eax
  00439	84 c0		 test	 al, al
  0043b	0f 84 8b 00 00
	00		 je	 $LN15@GetPartiti
$LL16@GetPartiti:
  00441	8b 75 ec	 mov	 esi, DWORD PTR _$S3$21[ebp+20]
  00444	33 c9		 xor	 ecx, ecx
  00446	83 c6 08	 add	 esi, 8
  00449	38 4d dd	 cmp	 BYTE PTR _$S3$21[ebp+5], cl
  0044c	0f 94 c1	 sete	 cl
  0044f	88 4d dd	 mov	 BYTE PTR _$S3$21[ebp+5], cl
  00452	84 c9		 test	 cl, cl
  00454	74 5a		 je	 SHORT $LN14@GetPartiti
  00456	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL19@GetPartiti:

; 698  : 			{
; 699  : 				if (partition.Info.StartingOffset.QuadPart > config.SystemPartition.Info.StartingOffset.QuadPart
; 700  : 					&& partition.Info.StartingOffset.QuadPart < minOffsetFound)

  00460	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00463	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00466	3b 95 9c fe ff
	ff		 cmp	 edx, DWORD PTR _config$[ebp+220]
  0046c	7c 2e		 jl	 SHORT $LN17@GetPartiti
  0046e	7f 08		 jg	 SHORT $LN2213@GetPartiti
  00470	3b 85 98 fe ff
	ff		 cmp	 eax, DWORD PTR _config$[ebp+216]
  00476	76 24		 jbe	 SHORT $LN17@GetPartiti
$LN2213@GetPartiti:
  00478	3b d3		 cmp	 edx, ebx
  0047a	7f 20		 jg	 SHORT $LN17@GetPartiti
  0047c	7c 04		 jl	 SHORT $LN2214@GetPartiti
  0047e	3b c7		 cmp	 eax, edi
  00480	73 1a		 jae	 SHORT $LN17@GetPartiti
$LN2214@GetPartiti:

; 701  : 				{
; 702  : 					minOffsetFound = partition.Info.StartingOffset.QuadPart;
; 703  : 
; 704  : 					candidatePartition = partition;

  00482	8b 8d 3c fd ff
	ff		 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  00488	8b f8		 mov	 edi, eax
  0048a	56		 push	 esi
  0048b	8b da		 mov	 ebx, edx
  0048d	e8 00 00 00 00	 call	 ??4Partition@GostCrypt@@QAEAAU01@ABU01@@Z

; 705  : 
; 706  : 					candidateForHiddenOSFound = true;

  00492	8a 4d dd	 mov	 cl, BYTE PTR _$S3$21[ebp+5]
  00495	c6 85 4f fd ff
	ff 01		 mov	 BYTE PTR _candidateForHiddenOSFound$1$[ebp], 1
$LN17@GetPartiti:

; 696  : 
; 697  : 			foreach (const Partition &partition, config.Partitions)

  0049c	33 c0		 xor	 eax, eax
  0049e	c6 45 dc 01	 mov	 BYTE PTR _$S3$21[ebp+4], 1
  004a2	84 c9		 test	 cl, cl
  004a4	0f 94 c0	 sete	 al
  004a7	8a c8		 mov	 cl, al
  004a9	88 4d dd	 mov	 BYTE PTR _$S3$21[ebp+5], cl
  004ac	84 c0		 test	 al, al
  004ae	75 b0		 jne	 SHORT $LL19@GetPartiti
$LN14@GetPartiti:
  004b0	8b 45 d8	 mov	 eax, DWORD PTR _$S3$21[ebp]
  004b3	8d 4d d8	 lea	 ecx, DWORD PTR _$S3$21[ebp]
  004b6	ff 50 08	 call	 DWORD PTR [eax+8]
  004b9	8b 45 d8	 mov	 eax, DWORD PTR _$S3$21[ebp]
  004bc	8d 4d d8	 lea	 ecx, DWORD PTR _$S3$21[ebp]
  004bf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  004c2	ff d0		 call	 eax
  004c4	84 c0		 test	 al, al
  004c6	0f 85 75 ff ff
	ff		 jne	 $LL16@GetPartiti
$LN15@GetPartiti:

; 707  : 				}
; 708  : 			}

  004cc	8d 4d e0	 lea	 ecx, DWORD PTR _$S3$21[ebp+8]
  004cf	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  004d3	e8 00 00 00 00	 call	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear
  004d8	6a 78		 push	 120			; 00000078H
  004da	6a 01		 push	 1
  004dc	ff 75 e0	 push	 DWORD PTR _$S3$21[ebp+8]
  004df	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPAXII@Z ; std::_Deallocate
  004e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 709  : 
; 710  : 			if (!candidateForHiddenOSFound)

  004e7	80 bd 4f fd ff
	ff 00		 cmp	 BYTE PTR _candidateForHiddenOSFound$1$[ebp], 0
  004ee	0f 85 df 00 00
	00		 jne	 $LN29@GetPartiti

; 711  : 			{
; 712  : 				throw ErrorException (wstring (GetString ("NO_PARTITION_FOLLOWS_BOOT_PARTITION"))

  004f4	8b 8d 48 fd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  004fa	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00500	50		 push	 eax
  00501	e8 00 00 00 00	 call	 ?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; GostCrypt::BootEncryption::GetRemarksOnHiddenOS
  00506	8b f0		 mov	 esi, eax
  00508	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@MAHFALCP@NO_PARTITION_FOLLOWS_BOOT_PARTIT@
  0050d	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00511	e8 00 00 00 00	 call	 _GetString
  00516	83 c4 04	 add	 esp, 4
  00519	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  0051f	50		 push	 eax
  00520	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00525	56		 push	 esi
  00526	50		 push	 eax
  00527	8d 45 d8	 lea	 eax, DWORD PTR $T20[ebp]
  0052a	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  0052e	50		 push	 eax
  0052f	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00534	83 c4 0c	 add	 esp, 12			; 0000000cH
  00537	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  0053b	eb 61		 jmp	 SHORT $LN2218@GetPartiti
$LN25@GetPartiti:

; 674  : 						}
; 675  : 					}

  0053d	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _partitionBehindBoot$13[ebp]
  00543	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  00548	8d 8d 50 fd ff
	ff		 lea	 ecx, DWORD PTR _bootPartition$4[ebp]
  0054e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00552	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
$LN23@GetPartiti:

; 676  : 
; 677  : 					throw ErrorException (wstring (GetString ("SYSTEM_PARTITION_NOT_ACTIVE"))

  00557	8b 8d 48 fd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0055d	8d 45 a0	 lea	 eax, DWORD PTR $T14[ebp]
  00560	50		 push	 eax
  00561	e8 00 00 00 00	 call	 ?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; GostCrypt::BootEncryption::GetRemarksOnHiddenOS
  00566	8b f0		 mov	 esi, eax
  00568	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@FBNGAMD@SYSTEM_PARTITION_NOT_ACTIVE?$AA@
  0056d	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00571	e8 00 00 00 00	 call	 _GetString
  00576	83 c4 04	 add	 esp, 4
  00579	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  0057f	50		 push	 eax
  00580	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00585	56		 push	 esi
  00586	50		 push	 eax
  00587	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  0058d	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00591	50		 push	 eax
  00592	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00597	83 c4 0c	 add	 esp, 12			; 0000000cH
  0059a	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
$LN2218@GetPartiti:
  0059e	33 c9		 xor	 ecx, ecx
  005a0	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T17[ebp], OFFSET ??_7ErrorException@GostCrypt@@6B@
  005a7	6a ff		 push	 -1
  005a9	51		 push	 ecx
  005aa	66 89 4d c0	 mov	 WORD PTR $T17[ebp+8], cx
  005ae	8d 4d c0	 lea	 ecx, DWORD PTR $T17[ebp+8]
  005b1	50		 push	 eax
  005b2	c7 45 d4 07 00
	00 00		 mov	 DWORD PTR $T17[ebp+28], 7
  005b9	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+24], 0
  005c0	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN2219@GetPartiti:
  005c5	68 00 00 00 00	 push	 OFFSET __TI2?AUErrorException@GostCrypt@@
  005ca	8d 45 b8	 lea	 eax, DWORD PTR $T17[ebp]
  005cd	50		 push	 eax
  005ce	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2221@GetPartiti:
$LN29@GetPartiti:

; 713  : 					+ GetRemarksOnHiddenOS());
; 714  : 			}
; 715  : 
; 716  : 			if (config.SystemPartition.Info.PartitionLength.QuadPart > GST_MAX_FAT_SECTOR_COUNT * GST_SECTOR_SIZE_BIOS)

  005d3	8b bd a4 fe ff
	ff		 mov	 edi, DWORD PTR _config$[ebp+228]
  005d9	8b b5 a0 fe ff
	ff		 mov	 esi, DWORD PTR _config$[ebp+224]
  005df	81 ff 00 02 00
	00		 cmp	 edi, 512		; 00000200H
  005e5	0f 82 96 00 00
	00		 jb	 $LN30@GetPartiti
  005eb	77 08		 ja	 SHORT $LN2215@GetPartiti
  005ed	85 f6		 test	 esi, esi
  005ef	0f 84 8c 00 00
	00		 je	 $LN30@GetPartiti
$LN2215@GetPartiti:

; 717  : 			{
; 718  : 				if ((double) candidatePartition.Info.PartitionLength.QuadPart / config.SystemPartition.Info.PartitionLength.QuadPart < MIN_HIDDENOS_DECOY_PARTITION_SIZE_RATIO_NTFS)

  005f5	8b 9d 3c fd ff
	ff		 mov	 ebx, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  005fb	8b 53 24	 mov	 edx, DWORD PTR [ebx+36]
  005fe	8b 4b 20	 mov	 ecx, DWORD PTR [ebx+32]
  00601	e8 00 00 00 00	 call	 __ltod3
  00606	8b d7		 mov	 edx, edi
  00608	f2 0f 11 85 40
	fd ff ff	 movsd	 QWORD PTR tv4788[ebp], xmm0
  00610	8b ce		 mov	 ecx, esi
  00612	e8 00 00 00 00	 call	 __ltod3
  00617	f2 0f 10 95 40
	fd ff ff	 movsd	 xmm2, QWORD PTR tv4788[ebp]
  0061f	f2 0f 5e d0	 divsd	 xmm2, xmm0
  00623	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000cccccccccccd
  0062b	66 0f 2f ca	 comisd	 xmm1, xmm2
  0062f	0f 86 d4 00 00
	00		 jbe	 $LN33@GetPartiti

; 719  : 				{
; 720  : 					throw ErrorException (wstring (GetString ("PARTITION_TOO_SMALL_FOR_HIDDEN_OS_NTFS"))

  00635	8b 8d 48 fd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0063b	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00641	50		 push	 eax
  00642	e8 00 00 00 00	 call	 ?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; GostCrypt::BootEncryption::GetRemarksOnHiddenOS
  00647	8b f0		 mov	 esi, eax
  00649	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@NLNOGBOO@PARTITION_TOO_SMALL_FOR_HIDDEN_O@
  0064e	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00652	e8 00 00 00 00	 call	 _GetString
  00657	83 c4 04	 add	 esp, 4
  0065a	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  00660	50		 push	 eax
  00661	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00666	56		 push	 esi
  00667	50		 push	 eax
  00668	8d 45 d8	 lea	 eax, DWORD PTR $T19[ebp]
  0066b	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  0066f	50		 push	 eax
  00670	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00675	83 c4 0c	 add	 esp, 12			; 0000000cH
  00678	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  0067c	e9 1d ff ff ff	 jmp	 $LN2218@GetPartiti
$LN30@GetPartiti:

; 721  : 						+ GetRemarksOnHiddenOS());
; 722  : 				}
; 723  : 			}
; 724  : 			else if ((double) candidatePartition.Info.PartitionLength.QuadPart / config.SystemPartition.Info.PartitionLength.QuadPart < MIN_HIDDENOS_DECOY_PARTITION_SIZE_RATIO_FAT)

  00681	8b 9d 3c fd ff
	ff		 mov	 ebx, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
  00687	8b 53 24	 mov	 edx, DWORD PTR [ebx+36]
  0068a	8b 4b 20	 mov	 ecx, DWORD PTR [ebx+32]
  0068d	e8 00 00 00 00	 call	 __ltod3
  00692	8b d7		 mov	 edx, edi
  00694	f2 0f 11 85 40
	fd ff ff	 movsd	 QWORD PTR tv4796[ebp], xmm0
  0069c	8b ce		 mov	 ecx, esi
  0069e	e8 00 00 00 00	 call	 __ltod3
  006a3	f2 0f 10 95 40
	fd ff ff	 movsd	 xmm2, QWORD PTR tv4796[ebp]
  006ab	f2 0f 5e d0	 divsd	 xmm2, xmm0
  006af	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0cccccccccccd
  006b7	66 0f 2f ca	 comisd	 xmm1, xmm2
  006bb	76 4c		 jbe	 SHORT $LN33@GetPartiti

; 725  : 			{
; 726  : 				throw ErrorException (wstring (GetString ("PARTITION_TOO_SMALL_FOR_HIDDEN_OS"))

  006bd	8b 8d 48 fd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  006c3	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  006c9	50		 push	 eax
  006ca	e8 00 00 00 00	 call	 ?GetRemarksOnHiddenOS@BootEncryption@GostCrypt@@IAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; GostCrypt::BootEncryption::GetRemarksOnHiddenOS
  006cf	8b f0		 mov	 esi, eax
  006d1	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PECBFKPM@PARTITION_TOO_SMALL_FOR_HIDDEN_O@
  006d6	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  006da	e8 00 00 00 00	 call	 _GetString
  006df	83 c4 04	 add	 esp, 4
  006e2	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  006e8	50		 push	 eax
  006e9	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  006ee	56		 push	 esi
  006ef	50		 push	 eax
  006f0	8d 45 d8	 lea	 eax, DWORD PTR $T18[ebp]
  006f3	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  006f7	50		 push	 eax
  006f8	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  006fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00700	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  00704	e9 95 fe ff ff	 jmp	 $LN2218@GetPartiti
$LN33@GetPartiti:

; 734  : 		}
; 735  : 
; 736  : 		HiddenOSCandidatePartition = candidatePartition;

  00709	8b 8d 48 fd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0070f	53		 push	 ebx
  00710	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  00716	e8 00 00 00 00	 call	 ??4Partition@GostCrypt@@QAEAAU01@ABU01@@Z

; 737  : 		return candidatePartition;

  0071b	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp]
  00721	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
  00726	8b c3		 mov	 eax, ebx

; 738  : 	}

  00728	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0072b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00732	59		 pop	 ecx
  00733	5f		 pop	 edi
  00734	5e		 pop	 esi
  00735	5b		 pop	 ebx
  00736	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00739	33 cd		 xor	 ecx, ebp
  0073b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00740	8b e5		 mov	 esp, ebp
  00742	5d		 pop	 ebp
  00743	c2 04 00	 ret	 4
$LN26@GetPartiti:

; 727  : 					+ GetRemarksOnHiddenOS());
; 728  : 			}
; 729  : 		}
; 730  : 		else
; 731  : 		{
; 732  : 			// No active partition on the system drive
; 733  : 			throw ErrorException ("SYSTEM_PARTITION_NOT_ACTIVE");

  00746	33 c0		 xor	 eax, eax
  00748	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T16[ebp], OFFSET ??_7ErrorException@GostCrypt@@6B@
  0074f	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T16[ebp+4], OFFSET ??_C@_0BM@FBNGAMD@SYSTEM_PARTITION_NOT_ACTIVE?$AA@
  00756	c7 45 d4 07 00
	00 00		 mov	 DWORD PTR $T16[ebp+28], 7
  0075d	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T16[ebp+24], 0
  00764	66 89 45 c0	 mov	 WORD PTR $T16[ebp+8], ax
  00768	e9 58 fe ff ff	 jmp	 $LN2219@GetPartiti
$LN2217@GetPartiti:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$0:
  00000	8b 85 38 fd ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  00006	83 e0 01	 and	 eax, 1
  00009	0f 84 12 00 00
	00		 je	 $LN42@GetPartiti
  0000f	83 a5 38 fd ff
	ff fe		 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00016	8b 8d 34 fd ff
	ff		 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1Partition@GostCrypt@@QAE@XZ
$LN42@GetPartiti:
  00021	c3		 ret	 0
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$1:
  00022	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp]
  00028	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$2:
  0002d	8d 4d d8	 lea	 ecx, DWORD PTR _$S1$22[ebp]
  00030	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$3:
  00035	8d 8d 50 fd ff
	ff		 lea	 ecx, DWORD PTR _bootPartition$4[ebp]
  0003b	e9 00 00 00 00	 jmp	 ??1Partition@GostCrypt@@QAE@XZ
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$4:
  00040	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _partitionBehindBoot$13[ebp]
  00046	e9 00 00 00 00	 jmp	 ??1Partition@GostCrypt@@QAE@XZ
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$5:
  0004b	8d 4d a0	 lea	 ecx, DWORD PTR _$S2$15[ebp]
  0004e	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$9:
  00053	8d 4d d8	 lea	 ecx, DWORD PTR _$S3$21[ebp]
  00056	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$10:
  0005b	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00061	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$11:
  00066	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  0006c	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$12:
  00071	8d 4d d8	 lea	 ecx, DWORD PTR $T20[ebp]
  00074	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$6:
  00079	8d 4d a0	 lea	 ecx, DWORD PTR $T14[ebp]
  0007c	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$7:
  00081	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00087	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$8:
  0008c	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00092	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$13:
  00097	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0009d	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$14:
  000a2	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  000a8	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$15:
  000ad	8d 4d d8	 lea	 ecx, DWORD PTR $T19[ebp]
  000b0	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$16:
  000b5	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  000bb	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$17:
  000c0	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  000c6	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ$18:
  000cb	8d 4d d8	 lea	 ecx, DWORD PTR $T18[ebp]
  000ce	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ:
  000d3	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000d7	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000da	8b 8a 30 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-720]
  000e0	33 c8		 xor	 ecx, eax
  000e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e7	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  000ea	33 c8		 xor	 ecx, eax
  000ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f1	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ
  000f6	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ ENDP ; GostCrypt::BootEncryption::GetPartitionForHiddenOS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?GetInstalledBootLoaderVersion@BootEncryption@GostCrypt@@QAEGXZ
_TEXT	SEGMENT
_version$ = -4						; size = 2
?GetInstalledBootLoaderVersion@BootEncryption@GostCrypt@@QAEGXZ PROC ; GostCrypt::BootEncryption::GetInstalledBootLoaderVersion, COMDAT
; _this$ = ecx

; 1015 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1016 : 		uint16 version;
; 1017 : 		CallDriver (GST_IOCTL_GET_BOOT_LOADER_VERSION, NULL, 0, &version, sizeof (version));

  00004	6a 02		 push	 2
  00006	8d 45 fc	 lea	 eax, DWORD PTR _version$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	6a 00		 push	 0
  0000e	68 08 20 22 00	 push	 2236424			; 00222008H
  00013	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 1018 : 		return version;

  00018	66 8b 45 fc	 mov	 ax, WORD PTR _version$[ebp]

; 1019 : 	}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?GetInstalledBootLoaderVersion@BootEncryption@GostCrypt@@QAEGXZ ENDP ; GostCrypt::BootEncryption::GetInstalledBootLoaderVersion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?GetHiddenOSCreationPhase@BootEncryption@GostCrypt@@QAEIXZ
_TEXT	SEGMENT
_configFlags$ = -1					; size = 1
?GetHiddenOSCreationPhase@BootEncryption@GostCrypt@@QAEIXZ PROC ; GostCrypt::BootEncryption::GetHiddenOSCreationPhase, COMDAT
; _this$ = ecx

; 1594 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1595 : 		byte configFlags [GST_BOOT_CFG_FLAG_AREA_SIZE];
; 1596 : 
; 1597 : 		ReadBootSectorConfig (configFlags, sizeof(configFlags));

  00004	6a 00		 push	 0
  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	6a 01		 push	 1
  0000c	8d 45 ff	 lea	 eax, DWORD PTR _configFlags$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z ; GostCrypt::BootEncryption::ReadBootSectorConfig

; 1598 : 
; 1599 : 		return (configFlags[0] & GST_BOOT_CFG_MASK_HIDDEN_OS_CREATION_PHASE);

  00015	0f b6 45 ff	 movzx	 eax, BYTE PTR _configFlags$[ebp]
  00019	25 c0 00 00 00	 and	 eax, 192		; 000000c0H

; 1600 : 	}

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?GetHiddenOSCreationPhase@BootEncryption@GostCrypt@@QAEIXZ ENDP ; GostCrypt::BootEncryption::GetHiddenOSCreationPhase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?GetDriverServiceStartType@BootEncryption@GostCrypt@@QAEKXZ
_TEXT	SEGMENT
$T1 = -12						; size = 8
_startType$ = -4					; size = 4
?GetDriverServiceStartType@BootEncryption@GostCrypt@@QAEKXZ PROC ; GostCrypt::BootEncryption::GetDriverServiceStartType, COMDAT
; _this$ = ecx

; 749  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 750  : 		DWORD startType;
; 751  : 		throw_sys_if (!ReadLocalMachineRegistryDword ("SYSTEM\\CurrentControlSet\\Services\\gostcrypt", "Start", &startType));

  00006	8d 45 fc	 lea	 eax, DWORD PTR _startType$[ebp]
  00009	50		 push	 eax
  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_05FHMJPCKA@Start?$AA@
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LCJDGIOL@SYSTEM?2CurrentControlSet?2Service@
  00014	e8 00 00 00 00	 call	 _ReadLocalMachineRegistryDword
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001c	85 c0		 test	 eax, eax
  0001e	74 07		 je	 SHORT $LN13@GetDriverS

; 752  : 		return startType;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _startType$[ebp]

; 753  : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN13@GetDriverS:

; 750  : 		DWORD startType;
; 751  : 		throw_sys_if (!ReadLocalMachineRegistryDword ("SYSTEM\\CurrentControlSet\\Services\\gostcrypt", "Start", &startType));

  00027	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00034	89 45 f8	 mov	 DWORD PTR $T1[ebp+4], eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  0003a	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN15@GetDriverS:
$LN12@GetDriverS:
  00045	cc		 int	 3
?GetDriverServiceStartType@BootEncryption@GostCrypt@@QAEKXZ ENDP ; GostCrypt::BootEncryption::GetDriverServiceStartType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?GetDecoyOSWipeStatus@BootEncryption@GostCrypt@@QAE?AUDecoySystemWipeStatus@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetDecoyOSWipeStatus@BootEncryption@GostCrypt@@QAE?AUDecoySystemWipeStatus@@XZ PROC ; GostCrypt::BootEncryption::GetDecoyOSWipeStatus, COMDAT
; _this$ = ecx

; 1683 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1684 : 		DecoySystemWipeStatus status;
; 1685 : 		CallDriver (GST_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS, NULL, 0, &status, sizeof (status));

  00003	6a 10		 push	 16			; 00000010H
  00005	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00008	6a 00		 push	 0
  0000a	6a 00		 push	 0
  0000c	68 80 20 22 00	 push	 2236544			; 00222080H
  00011	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 1686 : 		return status;

  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1687 : 	}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?GetDecoyOSWipeStatus@BootEncryption@GostCrypt@@QAE?AUDecoySystemWipeStatus@@XZ ENDP ; GostCrypt::BootEncryption::GetDecoyOSWipeStatus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?DeleteFileAdmin@BootEncryption@GostCrypt@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_file$ = 8						; size = 4
?DeleteFileAdmin@BootEncryption@GostCrypt@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; GostCrypt::BootEncryption::DeleteFileAdmin, COMDAT
; _this$ = ecx

; 3113 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3114 : 		if (!IsAdmin() && IsUacSupported())

  00006	e8 00 00 00 00	 call	 _IsAdmin
  0000b	85 c0		 test	 eax, eax
  0000d	75 1a		 jne	 SHORT $LN4@DeleteFile
  0000f	e8 00 00 00 00	 call	 _IsUacSupported
  00014	85 c0		 test	 eax, eax
  00016	74 11		 je	 SHORT $LN4@DeleteFile

; 3115 : 			Elevator::DeleteFile (file);

  00018	ff 75 08	 push	 DWORD PTR _file$[ebp]
  0001b	e8 00 00 00 00	 call	 ?DeleteFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GostCrypt::Elevator::DeleteFileA
  00020	83 c4 04	 add	 esp, 4
$LN3@DeleteFile:

; 3118 : 	}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@DeleteFile:

; 3116 : 		else
; 3117 : 			throw_sys_if (!::DeleteFile (file.c_str()));

  00029	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  0002c	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4
  00038	85 c0		 test	 eax, eax
  0003a	75 e7		 jne	 SHORT $LN3@DeleteFile
  0003c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00049	89 45 fc	 mov	 DWORD PTR $T1[ebp+4], eax
  0004c	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  0004f	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN17@DeleteFile:
$LN14@DeleteFile:
  0005a	cc		 int	 3
?DeleteFileAdmin@BootEncryption@GostCrypt@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; GostCrypt::BootEncryption::DeleteFileAdmin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z
_TEXT	SEGMENT
_e$2 = -1084						; size = 4
$T3 = -1076						; size = 8
$T4 = -1068						; size = 8
$T5 = -1060						; size = 8
$T6 = -1052						; size = 8
$T7 = -1044						; size = 8
_this$GSCopy$ = -1036					; size = 4
_configFlags$8 = -1029					; size = 1
_finally2637$9 = -1029					; size = 1
_config$ = -1028					; size = 320
_encStatus$ = -708					; size = 94
_device$10 = -612					; size = 48
$T11 = -564						; size = 32
_header$12 = -532					; size = 512
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_displayWaitDialog$ = 8					; size = 1
?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z PROC	; GostCrypt::BootEncryption::Deinstall, COMDAT
; _this$ = ecx

; 2585 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 30 04 00
	00		 sub	 esp, 1072		; 00000430H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b f1		 mov	 esi, ecx

; 2586 : 		BootEncryptionStatus encStatus = GetStatus();

  00033	6a 5e		 push	 94			; 0000005eH
  00035	8d 85 3c fd ff
	ff		 lea	 eax, DWORD PTR _encStatus$[ebp]
  0003b	89 b5 f4 fb ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  00041	50		 push	 eax
  00042	6a 00		 push	 0
  00044	6a 00		 push	 0
  00046	68 48 20 22 00	 push	 2236488			; 00222048H
  0004b	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 2587 : 
; 2588 : 		if (encStatus.DriveEncrypted || encStatus.DriveMounted)

  00050	83 bd 4a fd ff
	ff 00		 cmp	 DWORD PTR _encStatus$[ebp+14], 0
  00057	0f 85 66 03 00
	00		 jne	 $LN3@Deinstall
  0005d	83 bd 42 fd ff
	ff 00		 cmp	 DWORD PTR _encStatus$[ebp+6], 0
  00064	0f 85 59 03 00
	00		 jne	 $LN3@Deinstall

; 2590 : 
; 2591 : 		SystemDriveConfiguration config = GetSystemDriveConfiguration ();

  0006a	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _config$[ebp]
  00070	8b ce		 mov	 ecx, esi
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration

; 2592 : 
; 2593 : 		if (encStatus.VolumeHeaderPresent)

  00078	83 bd 46 fd ff
	ff 00		 cmp	 DWORD PTR _encStatus$[ebp+10], 0
  0007f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00086	0f 84 b5 00 00
	00		 je	 $LN4@Deinstall

; 2594 : 		{
; 2595 : 			// Verify CRC of header salt
; 2596 : 			Device device (config.DevicePath, true);

  0008c	6a 01		 push	 1
  0008e	83 ec 18	 sub	 esp, 24			; 00000018H
  00091	8b cc		 mov	 ecx, esp
  00093	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0009a	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  000a1	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  000a5	72 04		 jb	 SHORT $LN157@Deinstall
  000a7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a9	eb 02		 jmp	 SHORT $LN158@Deinstall
$LN157@Deinstall:
  000ab	8b c1		 mov	 eax, ecx
$LN158@Deinstall:
  000ad	6a ff		 push	 -1
  000af	c6 00 00	 mov	 BYTE PTR [eax], 0
  000b2	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _config$[ebp+24]
  000b8	6a 00		 push	 0
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000c0	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR _device$10[ebp]
  000c6	e8 00 00 00 00	 call	 ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device

; 2597 : 			byte header[GST_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE];
; 2598 : 
; 2599 : 			device.SeekAt (GST_BOOT_VOLUME_HEADER_SECTOR_OFFSET);

  000cb	6a 00		 push	 0
  000cd	68 00 7c 00 00	 push	 31744			; 00007c00H
  000d2	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR _device$10[ebp]
  000d8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  000dc	e8 00 00 00 00	 call	 ?SeekAt@File@GostCrypt@@QAEX_J@Z ; GostCrypt::File::SeekAt

; 2600 : 			device.Read (header, sizeof (header));

  000e1	68 00 02 00 00	 push	 512			; 00000200H
  000e6	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _header$12[ebp]
  000ec	50		 push	 eax
  000ed	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR _device$10[ebp]
  000f3	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read

; 2601 : 
; 2602 : 			if (encStatus.VolumeHeaderSaltCrc32 != GetCrc32 ((byte *) header, PKCS5_SALT_SIZE))

  000f8	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _header$12[ebp]
  000fe	6a 40		 push	 64			; 00000040H
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 _GetCrc32
  00106	83 c4 08	 add	 esp, 8
  00109	39 85 76 fd ff
	ff		 cmp	 DWORD PTR _encStatus$[ebp+58], eax
  0010f	74 25		 je	 SHORT $LN5@Deinstall

; 2603 : 				throw ParameterIncorrect (SRC_POS);

  00111	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00116	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  0011c	c7 85 ec fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00126	50		 push	 eax
  00127	c7 85 f0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+4], OFFSET ??_C@_0CK@HMMKEFKJ@GostCrypt?3?3BootEncryption?3?3Deins@
  00131	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN360@Deinstall:
$LN5@Deinstall:

; 2604 : 		}

  00136	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR _device$10[ebp]
  0013c	e8 00 00 00 00	 call	 ??1Device@GostCrypt@@QAE@XZ
$LN4@Deinstall:

; 2605 : 
; 2606 : 		try

  00141	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 2607 : 		{
; 2608 : 			RegisterFilterDriver (false, DriveFilter);

  00145	e8 00 00 00 00	 call	 _IsAdmin
  0014a	85 c0		 test	 eax, eax
  0014c	75 4f		 jne	 SHORT $LN172@Deinstall
  0014e	e8 00 00 00 00	 call	 _IsUacSupported
  00153	85 c0		 test	 eax, eax
  00155	74 46		 je	 SHORT $LN172@Deinstall
  00157	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  00161	6a 00		 push	 0
  00163	6a 00		 push	 0
  00165	50		 push	 eax
  00166	8b 08		 mov	 ecx, DWORD PTR [eax]
  00168	ff 51 2c	 call	 DWORD PTR [ecx+44]
  0016b	85 c0		 test	 eax, eax
  0016d	74 3e		 je	 SHORT $LN170@Deinstall
  0016f	50		 push	 eax
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  00176	c7 85 e4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00186	89 85 e8 fb ff
	ff		 mov	 DWORD PTR $T6[ebp+4], eax
  0018c	8d 85 e4 fb ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00192	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00197	50		 push	 eax
  00198	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN361@Deinstall:
$LN172@Deinstall:
  0019d	68 00 00 00 00	 push	 OFFSET _GUID_DEVCLASS_DISKDRIVE
  001a2	6a 00		 push	 0
  001a4	6a 00		 push	 0
  001a6	8b ce		 mov	 ecx, esi
  001a8	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
$LN170@Deinstall:

; 2609 : 			RegisterFilterDriver (false, VolumeFilter);

  001ad	e8 00 00 00 00	 call	 _IsAdmin
  001b2	85 c0		 test	 eax, eax
  001b4	75 4f		 jne	 SHORT $LN196@Deinstall
  001b6	e8 00 00 00 00	 call	 _IsUacSupported
  001bb	85 c0		 test	 eax, eax
  001bd	74 46		 je	 SHORT $LN196@Deinstall
  001bf	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate
  001c4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  001c9	6a 01		 push	 1
  001cb	6a 00		 push	 0
  001cd	50		 push	 eax
  001ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d0	ff 51 2c	 call	 DWORD PTR [ecx+44]
  001d3	85 c0		 test	 eax, eax
  001d5	74 4e		 je	 SHORT $LN197@Deinstall
  001d7	50		 push	 eax
  001d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  001de	c7 85 dc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  001e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001ee	89 85 e0 fb ff
	ff		 mov	 DWORD PTR $T5[ebp+4], eax
  001f4	8d 85 dc fb ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  001fa	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  001ff	50		 push	 eax
  00200	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN362@Deinstall:
$LN196@Deinstall:
  00205	68 00 00 00 00	 push	 OFFSET _GUID_DEVCLASS_VOLUME
  0020a	6a 01		 push	 1
  0020c	6a 00		 push	 0
  0020e	8b ce		 mov	 ecx, esi
  00210	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
  00215	68 00 00 00 00	 push	 OFFSET _GUID_DEVCLASS_FLOPPYDISK
  0021a	6a 01		 push	 1
  0021c	6a 00		 push	 0
  0021e	8b ce		 mov	 ecx, esi
  00220	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
$LN197@Deinstall:

; 2610 : 			RegisterFilterDriver (false, DumpFilter);

  00225	e8 00 00 00 00	 call	 _IsAdmin
  0022a	85 c0		 test	 eax, eax
  0022c	75 4f		 jne	 SHORT $LN219@Deinstall
  0022e	e8 00 00 00 00	 call	 _IsUacSupported
  00233	85 c0		 test	 eax, eax
  00235	74 46		 je	 SHORT $LN219@Deinstall
  00237	e8 00 00 00 00	 call	 ?Elevate@Elevator@GostCrypt@@KAXXZ ; GostCrypt::Elevator::Elevate
  0023c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  00241	6a 02		 push	 2
  00243	6a 00		 push	 0
  00245	50		 push	 eax
  00246	8b 08		 mov	 ecx, DWORD PTR [eax]
  00248	ff 51 2c	 call	 DWORD PTR [ecx+44]
  0024b	85 c0		 test	 eax, eax
  0024d	74 3b		 je	 SHORT $LN221@Deinstall
  0024f	50		 push	 eax
  00250	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  00256	c7 85 d4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00260	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00266	89 85 d8 fb ff
	ff		 mov	 DWORD PTR $T4[ebp+4], eax
  0026c	8d 85 d4 fb ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00272	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00277	50		 push	 eax
  00278	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN363@Deinstall:
$LN219@Deinstall:
  0027d	6a 00		 push	 0
  0027f	6a 02		 push	 2
  00281	6a 00		 push	 0
  00283	8b ce		 mov	 ecx, esi
  00285	e8 00 00 00 00	 call	 ?RegisterFilter@BootEncryption@GostCrypt@@IAEX_NW4FilterType@12@PBU_GUID@@@Z ; GostCrypt::BootEncryption::RegisterFilter
$LN221@Deinstall:

; 2611 : 			SetDriverServiceStartType (SERVICE_SYSTEM_START);

  0028a	6a 01		 push	 1
  0028c	8b ce		 mov	 ecx, esi
  0028e	e8 00 00 00 00	 call	 ?SetDriverServiceStartType@BootEncryption@GostCrypt@@QAEXK@Z ; GostCrypt::BootEncryption::SetDriverServiceStartType

; 2622 : 		}
; 2623 : 
; 2624 : 		SetHiddenOSCreationPhase (GST_HIDDEN_OS_CREATION_PHASE_NONE);	// In case RestoreSystemLoader() fails

  00293	6a 00		 push	 0
  00295	6a 00		 push	 0
  00297	6a 00		 push	 0
  00299	6a 01		 push	 1
  0029b	8d 85 fb fb ff
	ff		 lea	 eax, DWORD PTR _configFlags$8[ebp]
  002a1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  002a8	50		 push	 eax
  002a9	8b ce		 mov	 ecx, esi
  002ab	e8 00 00 00 00	 call	 ?ReadBootSectorConfig@BootEncryption@GostCrypt@@QAEXPAEI0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAG@Z ; GostCrypt::BootEncryption::ReadBootSectorConfig
  002b0	80 a5 fb fb ff
	ff 3f		 and	 BYTE PTR _configFlags$8[ebp], 63 ; 0000003fH
  002b7	8d 85 fb fb ff
	ff		 lea	 eax, DWORD PTR _configFlags$8[ebp]
  002bd	50		 push	 eax
  002be	8b ce		 mov	 ecx, esi
  002c0	e8 00 00 00 00	 call	 ?WriteBootSectorConfig@BootEncryption@GostCrypt@@QAEXQBE@Z ; GostCrypt::BootEncryption::WriteBootSectorConfig
  002c5	6a 00		 push	 0
  002c7	8b ce		 mov	 ecx, esi
  002c9	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  002cd	e8 00 00 00 00	 call	 ?RegisterSystemFavoritesService@BootEncryption@GostCrypt@@QAEXH@Z ; GostCrypt::BootEncryption::RegisterSystemFavoritesService
  002d2	eb 0c		 jmp	 SHORT $LN359@Deinstall
__catch$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$4:

; 2625 : 
; 2626 : 		try
; 2627 : 		{
; 2628 : 			RegisterSystemFavoritesService (false);
; 2629 : 		}
; 2630 : 		catch (...) { }

  002d4	b8 00 00 00 00	 mov	 eax, $LN29@Deinstall
  002d9	c3		 ret	 0
$LN29@Deinstall:
  002da	8b b5 f4 fb ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
$LN359@Deinstall:

; 2631 : 
; 2632 : 		try
; 2633 : 		{
; 2634 : 			if (displayWaitDialog)

  002e0	8a 5d 08	 mov	 bl, BYTE PTR _displayWaitDialog$[ebp]
  002e3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  002ea	84 db		 test	 bl, bl
  002ec	74 0a		 je	 SHORT $LN10@Deinstall

; 2635 : 				DisplayStaticModelessWaitDlg (ParentWindow);

  002ee	ff 36		 push	 DWORD PTR [esi]
  002f0	e8 00 00 00 00	 call	 _DisplayStaticModelessWaitDlg
  002f5	83 c4 04	 add	 esp, 4
$LN10@Deinstall:

; 2636 : 
; 2637 : 			finally_do_arg (bool, displayWaitDialog, { if (finally_arg) CloseStaticModelessWaitDlg(); });

  002f8	88 9d fb fb ff
	ff		 mov	 BYTE PTR _finally2637$9[ebp], bl

; 2638 : 
; 2639 : 			RestoreSystemLoader ();

  002fe	8b ce		 mov	 ecx, esi
  00300	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+12], 9
  00304	e8 00 00 00 00	 call	 ?RestoreSystemLoader@BootEncryption@GostCrypt@@IAEXXZ ; GostCrypt::BootEncryption::RestoreSystemLoader

; 2640 : 		}

  00309	8d 8d fb fb ff
	ff		 lea	 ecx, DWORD PTR _finally2637$9[ebp]
  0030f	e8 00 00 00 00	 call	 ??1Finally2637@?BA@??Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z@QAE@XZ ; `GostCrypt::BootEncryption::Deinstall'::`16'::Finally2637::~Finally2637

; 2645 : 		}
; 2646 : 	}

  00314	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp]
  0031a	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
  0031f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00322	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00329	59		 pop	 ecx
  0032a	5f		 pop	 edi
  0032b	5e		 pop	 esi
  0032c	5b		 pop	 ebx
  0032d	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00330	33 cd		 xor	 ecx, ebp
  00332	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00337	8b e5		 mov	 esp, ebp
  00339	5d		 pop	 ebp
  0033a	c2 04 00	 ret	 4
__catch$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$6:

; 2641 : 		catch (Exception &e)
; 2642 : 		{
; 2643 : 			e.Show (ParentWindow);

  0033d	8b 8d c4 fb ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  00343	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  00349	8b 11		 mov	 edx, DWORD PTR [ecx]
  0034b	ff 30		 push	 DWORD PTR [eax]
  0034d	ff 12		 call	 DWORD PTR [edx]

; 2644 : 			throw ErrorException ("SYS_LOADER_RESTORE_FAILED");

  0034f	33 c0		 xor	 eax, eax
  00351	c7 85 cc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp], OFFSET ??_7ErrorException@GostCrypt@@6B@
  0035b	66 89 85 d4 fd
	ff ff		 mov	 WORD PTR $T11[ebp+8], ax
  00362	8d 85 cc fd ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  00368	68 00 00 00 00	 push	 OFFSET __TI2?AUErrorException@GostCrypt@@
  0036d	50		 push	 eax
  0036e	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+4], OFFSET ??_C@_0BK@DNPPNAJB@SYS_LOADER_RESTORE_FAILED?$AA@
  00378	c7 85 e8 fd ff
	ff 07 00 00 00	 mov	 DWORD PTR $T11[ebp+28], 7
  00382	c7 85 e4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+24], 0
  0038c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN364@Deinstall:
__catch$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$0:

; 2612 : 		}
; 2613 : 		catch (...)
; 2614 : 		{
; 2615 : 			try
; 2616 : 			{
; 2617 : 				RegisterBootDriver (IsHiddenSystemRunning());

  00391	8b b5 f4 fb ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  00397	8b ce		 mov	 ecx, esi
  00399	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0039c	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  003a0	e8 00 00 00 00	 call	 ?IsHiddenSystemRunning@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::IsHiddenSystemRunning
  003a5	50		 push	 eax
  003a6	8b ce		 mov	 ecx, esi
  003a8	e8 00 00 00 00	 call	 ?RegisterBootDriver@BootEncryption@GostCrypt@@QAEX_N@Z ; GostCrypt::BootEncryption::RegisterBootDriver
$LN25@Deinstall:

; 2620 : 
; 2621 : 			throw;

  003ad	6a 00		 push	 0
  003af	6a 00		 push	 0
  003b1	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  003b8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN365@Deinstall:
__catch$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$1:

; 2618 : 			}
; 2619 : 			catch (...) { }

  003bd	b8 00 00 00 00	 mov	 eax, $LN25@Deinstall
  003c2	c3		 ret	 0
$LN3@Deinstall:

; 2589 : 			throw ParameterIncorrect (SRC_POS);

  003c3	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  003c8	8d 85 cc fb ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  003ce	c7 85 cc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  003d8	50		 push	 eax
  003d9	c7 85 d0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp+4], OFFSET ??_C@_0CK@JKIDFDHF@GostCrypt?3?3BootEncryption?3?3Deins@
  003e3	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN366@Deinstall:
$LN358@Deinstall:
  003e8	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$8:
  00000	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$10:
  0000b	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR _device$10[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1Device@GostCrypt@@QAE@XZ
__unwindfunclet$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z$11:
  00016	8d 8d fb fb ff
	ff		 lea	 ecx, DWORD PTR _finally2637$9[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1Finally2637@?BA@??Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z@QAE@XZ ; `GostCrypt::BootEncryption::Deinstall'::`16'::Finally2637::~Finally2637
__ehhandler$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 8a c0 fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1088]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z
  00044	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Deinstall@BootEncryption@GostCrypt@@QAEX_N@Z ENDP	; GostCrypt::BootEncryption::Deinstall
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_e$2 = -552						; size = 4
$T3 = -548						; size = 12
$T4 = -536						; size = 12
_imageBuf$ = -524					; size = 8
$T5 = -516						; size = 8
$T6 = -508						; size = 8
_this$GSCopy$1$ = -500					; size = 4
_isoImagePath$GSCopy$ = -496				; size = 4
_this$GSCopy$ = -492					; size = 4
_isoImagePath$GSCopy$1$ = -488				; size = 4
$T7 = -484						; size = 320
_encStatus$ = -164					; size = 94
_isoFile$8 = -68					; size = 48
_sysBakFile$9 = -68					; size = 48
_bootDevice$10 = -68					; size = 48
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_initialSetup$ = 8					; size = 1
_isoImagePath$ = 12					; size = 4
?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; GostCrypt::BootEncryption::CreateRescueIsoImage, COMDAT
; _this$ = ecx

; 1868 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 1c 02 00
	00		 sub	 esp, 540		; 0000021cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b f1		 mov	 esi, ecx
  00033	89 b5 0c fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi
  00039	8b 7d 0c	 mov	 edi, DWORD PTR _isoImagePath$[ebp]

; 1869 : 		BootEncryptionStatus encStatus = GetStatus();

  0003c	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _encStatus$[ebp]
  00042	6a 5e		 push	 94			; 0000005eH
  00044	50		 push	 eax
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	68 48 20 22 00	 push	 2236488			; 00222048H
  0004e	89 b5 14 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  00054	89 bd 18 fe ff
	ff		 mov	 DWORD PTR _isoImagePath$GSCopy$1$[ebp], edi
  0005a	89 bd 10 fe ff
	ff		 mov	 DWORD PTR _isoImagePath$GSCopy$[ebp], edi
  00060	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 1870 : 		if (encStatus.SetupInProgress)

  00065	83 7d 9a 00	 cmp	 DWORD PTR _encStatus$[ebp+62], 0
  00069	74 25		 je	 SHORT $LN2@CreateResc

; 1871 : 			throw ParameterIncorrect (SRC_POS);

  0006b	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  00070	8d 85 04 fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00076	c7 85 04 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00080	50		 push	 eax
  00081	c7 85 08 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+4], OFFSET ??_C@_0DF@KLIDFACM@GostCrypt?3?3BootEncryption?3?3Creat@
  0008b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN316@CreateResc:
$LN2@CreateResc:

; 1872 : 
; 1873 : 		Buffer imageBuf (RescueIsoImageSize);

  00090	68 00 00 1c 00	 push	 1835008			; 001c0000H
  00095	c7 85 f8 fd ff
	ff 00 00 1c 00	 mov	 DWORD PTR _imageBuf$[ebp+4], 1835008 ; 001c0000H
  0009f	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000a4	8b d8		 mov	 ebx, eax
  000a6	83 c4 04	 add	 esp, 4
  000a9	89 9d f4 fd ff
	ff		 mov	 DWORD PTR _imageBuf$[ebp], ebx
  000af	85 db		 test	 ebx, ebx
  000b1	75 30		 jne	 SHORT $LN30@CreateResc
  000b3	0f 57 c0	 xorps	 xmm0, xmm0
  000b6	c7 85 e8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000c0	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000c5	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  000cb	66 0f d6 85 ec
	fd ff ff	 movq	 QWORD PTR $T4[ebp+4], xmm0
  000d3	50		 push	 eax
  000d4	c7 85 ec fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+4], OFFSET ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
  000de	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN317@CreateResc:
$LN30@CreateResc:

; 1874 : 		
; 1875 : 		byte *image = imageBuf.Ptr();
; 1876 : 		memset (image, 0, RescueIsoImageSize);

  000e3	68 00 00 1c 00	 push	 1835008			; 001c0000H
  000e8	6a 00		 push	 0
  000ea	53		 push	 ebx
  000eb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000f2	e8 00 00 00 00	 call	 _memset

; 1877 : 
; 1878 : 		// Primary volume descriptor
; 1879 : 		strcpy ((char *)image + 0x8000, "\001CD001\001");

  000f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_07NKOFPJFH@?$ABCD001?$AB?$AA@
  000fc	89 83 00 80 00
	00		 mov	 DWORD PTR [ebx+32768], eax
  00102	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_07NKOFPJFH@?$ABCD001?$AB?$AA@+4
  00107	89 83 04 80 00
	00		 mov	 DWORD PTR [ebx+32772], eax

; 1880 : 		strcpy ((char *)image + 0x7fff + 41, "GostCrypt Rescue Disk           ");

  0010d	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0CB@MBJIJKGC@GostCrypt?5Rescue?5Disk?5?5?5?5?5?5?5?5?5?5?5@

; 1881 : 		*(uint32 *) (image + 0x7fff + 81) = RescueIsoImageSize / 2048;
; 1882 : 		*(uint32 *) (image + 0x7fff + 85) = BE32 (RescueIsoImageSize / 2048);

  00114	68 80 03 00 00	 push	 896			; 00000380H
  00119	0f 11 83 28 80
	00 00		 movups	 XMMWORD PTR [ebx+32808], xmm0
  00120	0f 10 05 10 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0CB@MBJIJKGC@GostCrypt?5Rescue?5Disk?5?5?5?5?5?5?5?5?5?5?5@+16
  00127	0f 11 83 38 80
	00 00		 movups	 XMMWORD PTR [ebx+32824], xmm0
  0012e	a0 20 00 00 00	 mov	 al, BYTE PTR ??_C@_0CB@MBJIJKGC@GostCrypt?5Rescue?5Disk?5?5?5?5?5?5?5?5?5?5?5@+32
  00133	88 83 48 80 00
	00		 mov	 BYTE PTR [ebx+32840], al
  00139	c7 83 50 80 00
	00 80 03 00 00	 mov	 DWORD PTR [ebx+32848], 896 ; 00000380H
  00143	e8 00 00 00 00	 call	 _MirrorBytes32
  00148	89 83 54 80 00
	00		 mov	 DWORD PTR [ebx+32852], eax
  0014e	83 c4 10	 add	 esp, 16			; 00000010H

; 1883 : 		image[0x7fff + 121] = 1;

  00151	c6 83 78 80 00
	00 01		 mov	 BYTE PTR [ebx+32888], 1

; 1884 : 		image[0x7fff + 124] = 1;
; 1885 : 		image[0x7fff + 125] = 1;
; 1886 : 		image[0x7fff + 128] = 1;
; 1887 : 		image[0x7fff + 130] = 8;
; 1888 : 		image[0x7fff + 131] = 8;
; 1889 : 
; 1890 : 		image[0x7fff + 133] = 10;
; 1891 : 		image[0x7fff + 140] = 10;
; 1892 : 		image[0x7fff + 141] = 0x14;
; 1893 : 		image[0x7fff + 157] = 0x22;
; 1894 : 		image[0x7fff + 159] = 0x18;
; 1895 : 
; 1896 : 		// Boot record volume descriptor
; 1897 : 		strcpy ((char *)image + 0x8801, "CD001\001EL TORITO SPECIFICATION");
; 1898 : 		image[0x8800 + 0x47] = 0x19;
; 1899 : 
; 1900 : 		// Volume descriptor set terminator
; 1901 : 		strcpy ((char *)image + 0x9000, "\377CD001\001");
; 1902 : 
; 1903 : 		// Path table
; 1904 : 		image[0xA000 + 0] = 1;
; 1905 : 		image[0xA000 + 2] = 0x18;
; 1906 : 		image[0xA000 + 6] = 1;
; 1907 : 
; 1908 : 		// Root directory
; 1909 : 		image[0xc000 + 0] = 0x22;
; 1910 : 		image[0xc000 + 2] = 0x18;
; 1911 : 		image[0xc000 + 9] = 0x18;
; 1912 : 		image[0xc000 + 11] = 0x08;
; 1913 : 		image[0xc000 + 16] = 0x08;
; 1914 : 		image[0xc000 + 25] = 0x02;
; 1915 : 		image[0xc000 + 28] = 0x01;
; 1916 : 		image[0xc000 + 31] = 0x01;
; 1917 : 		image[0xc000 + 32] = 0x01;
; 1918 : 		image[0xc000 + 34] = 0x22;
; 1919 : 		image[0xc000 + 36] = 0x18;
; 1920 : 		image[0xc000 + 43] = 0x18;
; 1921 : 		image[0xc000 + 45] = 0x08;
; 1922 : 		image[0xc000 + 50] = 0x08;
; 1923 : 		image[0xc000 + 59] = 0x02;
; 1924 : 		image[0xc000 + 62] = 0x01;
; 1925 : 		*(uint32 *) (image + 0xc000 + 65) = 0x010101;
; 1926 : 
; 1927 : 		// Validation entry
; 1928 : 		image[0xc800] = 1;
; 1929 : 		int offset = 0xc800 + 0x1c;
; 1930 : 		image[offset++] = 0xaa;
; 1931 : 		image[offset++] = 0x55;
; 1932 : 		image[offset++] = 0x55;
; 1933 : 		image[offset] = 0xaa;
; 1934 : 
; 1935 : 		// Initial entry
; 1936 : 		offset = 0xc820;
; 1937 : 		image[offset++] = 0x88;
; 1938 : 		image[offset++] = 2;
; 1939 : 		image[0xc820 + 6] = 1;
; 1940 : 		image[0xc820 + 8] = GST_CD_BOOT_LOADER_SECTOR;
; 1941 : 
; 1942 : 		// GostCrypt Boot Loader
; 1943 : 		CreateBootLoaderInMemory (image + GST_CD_BOOTSECTOR_OFFSET, GST_BOOT_LOADER_AREA_SIZE, true);

  00158	8b ce		 mov	 ecx, esi
  0015a	66 c7 83 7b 80
	00 00 01 01	 mov	 WORD PTR [ebx+32891], 257 ; 00000101H
  00163	c6 83 7f 80 00
	00 01		 mov	 BYTE PTR [ebx+32895], 1
  0016a	66 c7 83 81 80
	00 00 08 08	 mov	 WORD PTR [ebx+32897], 2056 ; 00000808H
  00173	c6 83 84 80 00
	00 0a		 mov	 BYTE PTR [ebx+32900], 10 ; 0000000aH
  0017a	66 c7 83 8b 80
	00 00 0a 14	 mov	 WORD PTR [ebx+32907], 5130 ; 0000140aH
  00183	c6 83 9c 80 00
	00 22		 mov	 BYTE PTR [ebx+32924], 34 ; 00000022H
  0018a	c6 83 9e 80 00
	00 18		 mov	 BYTE PTR [ebx+32926], 24 ; 00000018H
  00191	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BO@DHOJLLGB@CD001?$ABEL?5TORITO?5SPECIFICATION?$AA@
  00198	6a 00		 push	 0
  0019a	6a 01		 push	 1
  0019c	0f 11 83 01 88
	00 00		 movups	 XMMWORD PTR [ebx+34817], xmm0
  001a3	68 00 7e 00 00	 push	 32256			; 00007e00H
  001a8	f3 0f 7e 05 10
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0BO@DHOJLLGB@CD001?$ABEL?5TORITO?5SPECIFICATION?$AA@+16
  001b0	66 0f d6 83 11
	88 00 00	 movq	 QWORD PTR [ebx+34833], xmm0
  001b8	a1 18 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BO@DHOJLLGB@CD001?$ABEL?5TORITO?5SPECIFICATION?$AA@+24
  001bd	89 83 19 88 00
	00		 mov	 DWORD PTR [ebx+34841], eax
  001c3	66 a1 1c 00 00
	00		 mov	 ax, WORD PTR ??_C@_0BO@DHOJLLGB@CD001?$ABEL?5TORITO?5SPECIFICATION?$AA@+28
  001c9	66 89 83 1d 88
	00 00		 mov	 WORD PTR [ebx+34845], ax
  001d0	c6 83 47 88 00
	00 19		 mov	 BYTE PTR [ebx+34887], 25 ; 00000019H
  001d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_07DAAEPPCP@?$PPCD001?$AB?$AA@
  001dc	89 83 00 90 00
	00		 mov	 DWORD PTR [ebx+36864], eax
  001e2	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_07DAAEPPCP@?$PPCD001?$AB?$AA@+4
  001e7	89 83 04 90 00
	00		 mov	 DWORD PTR [ebx+36868], eax
  001ed	8d 83 00 d0 00
	00		 lea	 eax, DWORD PTR [ebx+53248]
  001f3	c6 83 00 a0 00
	00 01		 mov	 BYTE PTR [ebx+40960], 1
  001fa	c6 83 02 a0 00
	00 18		 mov	 BYTE PTR [ebx+40962], 24 ; 00000018H
  00201	c6 83 06 a0 00
	00 01		 mov	 BYTE PTR [ebx+40966], 1
  00208	c6 83 00 c0 00
	00 22		 mov	 BYTE PTR [ebx+49152], 34 ; 00000022H
  0020f	c6 83 02 c0 00
	00 18		 mov	 BYTE PTR [ebx+49154], 24 ; 00000018H
  00216	c6 83 09 c0 00
	00 18		 mov	 BYTE PTR [ebx+49161], 24 ; 00000018H
  0021d	c6 83 0b c0 00
	00 08		 mov	 BYTE PTR [ebx+49163], 8
  00224	c6 83 10 c0 00
	00 08		 mov	 BYTE PTR [ebx+49168], 8
  0022b	c6 83 19 c0 00
	00 02		 mov	 BYTE PTR [ebx+49177], 2
  00232	c6 83 1c c0 00
	00 01		 mov	 BYTE PTR [ebx+49180], 1
  00239	66 c7 83 1f c0
	00 00 01 01	 mov	 WORD PTR [ebx+49183], 257 ; 00000101H
  00242	c6 83 22 c0 00
	00 22		 mov	 BYTE PTR [ebx+49186], 34 ; 00000022H
  00249	c6 83 24 c0 00
	00 18		 mov	 BYTE PTR [ebx+49188], 24 ; 00000018H
  00250	c6 83 2b c0 00
	00 18		 mov	 BYTE PTR [ebx+49195], 24 ; 00000018H
  00257	c6 83 2d c0 00
	00 08		 mov	 BYTE PTR [ebx+49197], 8
  0025e	c6 83 32 c0 00
	00 08		 mov	 BYTE PTR [ebx+49202], 8
  00265	c6 83 3b c0 00
	00 02		 mov	 BYTE PTR [ebx+49211], 2
  0026c	c6 83 3e c0 00
	00 01		 mov	 BYTE PTR [ebx+49214], 1
  00273	c7 83 41 c0 00
	00 01 01 01 00	 mov	 DWORD PTR [ebx+49217], 65793 ; 00010101H
  0027d	c6 83 00 c8 00
	00 01		 mov	 BYTE PTR [ebx+51200], 1
  00284	c7 83 1c c8 00
	00 aa 55 55 aa	 mov	 DWORD PTR [ebx+51228], -1437248086 ; aa5555aaH
  0028e	66 c7 83 20 c8
	00 00 88 02	 mov	 WORD PTR [ebx+51232], 648 ; 00000288H
  00297	50		 push	 eax
  00298	c6 83 26 c8 00
	00 01		 mov	 BYTE PTR [ebx+51238], 1
  0029f	c6 83 28 c8 00
	00 1a		 mov	 BYTE PTR [ebx+51240], 26 ; 0000001aH
  002a6	e8 00 00 00 00	 call	 ?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z ; GostCrypt::BootEncryption::CreateBootLoaderInMemory

; 1944 : 
; 1945 : 		// Volume header
; 1946 : 		if (initialSetup)

  002ab	80 7d 08 00	 cmp	 BYTE PTR _initialSetup$[ebp], 0
  002af	74 52		 je	 SHORT $LN3@CreateResc

; 1947 : 		{
; 1948 : 			if (!RescueVolumeHeaderValid)

  002b1	80 be c6 05 00
	00 00		 cmp	 BYTE PTR [esi+1478], 0
  002b8	75 25		 jne	 SHORT $LN5@CreateResc

; 1949 : 				throw ParameterIncorrect (SRC_POS);

  002ba	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  002bf	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  002c5	c7 85 fc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  002cf	50		 push	 eax
  002d0	c7 85 00 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+4], OFFSET ??_C@_0DF@NJKAADBI@GostCrypt?3?3BootEncryption?3?3Creat@
  002da	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN318@CreateResc:
$LN5@CreateResc:

; 1950 : 
; 1951 : 			memcpy (image + GST_CD_BOOTSECTOR_OFFSET + GST_BOOT_VOLUME_HEADER_SECTOR_OFFSET, RescueVolumeHeader, GST_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  002df	81 c6 c4 01 00
	00		 add	 esi, 452		; 000001c4H
  002e5	8d bb 00 4c 01
	00		 lea	 edi, DWORD PTR [ebx+84992]
  002eb	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  002f0	f3 a5		 rep movsd

; 1952 : 		}
; 1953 : 		else

  002f2	8b b5 0c fe ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  002f8	8b bd 18 fe ff
	ff		 mov	 edi, DWORD PTR _isoImagePath$GSCopy$1$[ebp]
  002fe	e9 81 00 00 00	 jmp	 $LN4@CreateResc
$LN3@CreateResc:

; 1954 : 		{
; 1955 : 			Device bootDevice (GetSystemDriveConfiguration().DevicePath, true);

  00303	6a 01		 push	 1
  00305	8d 85 1c fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  0030b	8b ce		 mov	 ecx, esi
  0030d	50		 push	 eax
  0030e	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration
  00313	83 ec 18	 sub	 esp, 24			; 00000018H
  00316	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0031a	8b cc		 mov	 ecx, esp
  0031c	8d 50 18	 lea	 edx, DWORD PTR [eax+24]
  0031f	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00326	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0032d	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00331	72 04		 jb	 SHORT $LN159@CreateResc
  00333	8b 01		 mov	 eax, DWORD PTR [ecx]
  00335	eb 02		 jmp	 SHORT $LN160@CreateResc
$LN159@CreateResc:
  00337	8b c1		 mov	 eax, ecx
$LN160@CreateResc:
  00339	52		 push	 edx
  0033a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0033d	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00342	8d 4d bc	 lea	 ecx, DWORD PTR _bootDevice$10[ebp]
  00345	e8 00 00 00 00	 call	 ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device
  0034a	8d 8d 1c fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00350	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  00354	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 1956 : 			bootDevice.SeekAt (GST_BOOT_VOLUME_HEADER_SECTOR_OFFSET);

  00359	6a 00		 push	 0
  0035b	68 00 7c 00 00	 push	 31744			; 00007c00H
  00360	8d 4d bc	 lea	 ecx, DWORD PTR _bootDevice$10[ebp]
  00363	e8 00 00 00 00	 call	 ?SeekAt@File@GostCrypt@@QAEX_J@Z ; GostCrypt::File::SeekAt

; 1957 : 			bootDevice.Read (image + GST_CD_BOOTSECTOR_OFFSET + GST_BOOT_VOLUME_HEADER_SECTOR_OFFSET, GST_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE);

  00368	68 00 02 00 00	 push	 512			; 00000200H
  0036d	8d 83 00 4c 01
	00		 lea	 eax, DWORD PTR [ebx+84992]
  00373	50		 push	 eax
  00374	8d 4d bc	 lea	 ecx, DWORD PTR _bootDevice$10[ebp]
  00377	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read

; 1958 : 		}

  0037c	8d 4d bc	 lea	 ecx, DWORD PTR _bootDevice$10[ebp]
  0037f	e8 00 00 00 00	 call	 ??1Device@GostCrypt@@QAE@XZ
$LN4@CreateResc:

; 1959 : 
; 1960 : 		// Original system loader
; 1961 : 		try
; 1962 : 		{
; 1963 : 			File sysBakFile (GetSystemLoaderBackupPath(), true);

  00384	6a 00		 push	 0
  00386	6a 01		 push	 1
  00388	83 ec 18	 sub	 esp, 24			; 00000018H
  0038b	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  0038f	8b ce		 mov	 ecx, esi
  00391	54		 push	 esp
  00392	e8 00 00 00 00	 call	 ?GetSystemLoaderBackupPath@BootEncryption@GostCrypt@@IAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GostCrypt::BootEncryption::GetSystemLoaderBackupPath
  00397	8d 4d bc	 lea	 ecx, DWORD PTR _sysBakFile$9[ebp]
  0039a	e8 00 00 00 00	 call	 ??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z ; GostCrypt::File::File

; 1964 : 			sysBakFile.Read (image + GST_CD_BOOTSECTOR_OFFSET + GST_ORIG_BOOT_LOADER_BACKUP_SECTOR_OFFSET, GST_BOOT_LOADER_AREA_SIZE);

  0039f	68 00 7e 00 00	 push	 32256			; 00007e00H
  003a4	8d 83 00 4e 01
	00		 lea	 eax, DWORD PTR [ebx+85504]
  003aa	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  003ae	50		 push	 eax
  003af	8d 4d bc	 lea	 ecx, DWORD PTR _sysBakFile$9[ebp]
  003b2	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read

; 1965 : 			
; 1966 : 			image[GST_CD_BOOTSECTOR_OFFSET + GST_BOOT_SECTOR_CONFIG_OFFSET] |= GST_BOOT_CFG_FLAG_RESCUE_DISK_ORIG_SYS_LOADER;

  003b7	80 8b b7 d1 00
	00 20		 or	 BYTE PTR [ebx+53687], 32 ; 00000020H

; 1967 : 		}

  003be	8d 4d bc	 lea	 ecx, DWORD PTR _sysBakFile$9[ebp]
  003c1	e8 00 00 00 00	 call	 ??1File@GostCrypt@@QAE@XZ ; GostCrypt::File::~File
  003c6	eb 37		 jmp	 SHORT $LN315@CreateResc
__catch$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:

; 1968 : 		catch (Exception &e)
; 1969 : 		{
; 1970 : 			e.Show (ParentWindow);

  003c8	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  003ce	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  003d4	8b 11		 mov	 edx, DWORD PTR [ecx]
  003d6	ff 30		 push	 DWORD PTR [eax]
  003d8	ff 12		 call	 DWORD PTR [edx]

; 1971 : 			Warning ("SYS_LOADER_UNAVAILABLE_FOR_RESCUE_DISK");

  003da	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@FHEPLLOO@SYS_LOADER_UNAVAILABLE_FOR_RESCU@
  003df	e8 00 00 00 00	 call	 _Warning
  003e4	83 c4 04	 add	 esp, 4

; 1972 : 		}

  003e7	b8 00 00 00 00	 mov	 eax, $LN21@CreateResc
  003ec	c3		 ret	 0
$LN21@CreateResc:
  003ed	8b 9d f4 fd ff
	ff		 mov	 ebx, DWORD PTR _imageBuf$[ebp]
  003f3	8b b5 14 fe ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  003f9	8b bd 10 fe ff
	ff		 mov	 edi, DWORD PTR _isoImagePath$GSCopy$[ebp]
$LN315@CreateResc:

; 1973 : 		
; 1974 : 		// Boot loader backup
; 1975 : 		CreateBootLoaderInMemory (image + GST_CD_BOOTSECTOR_OFFSET + GST_BOOT_LOADER_BACKUP_RESCUE_DISK_SECTOR_OFFSET, GST_BOOT_LOADER_AREA_SIZE, false);

  003ff	6a 00		 push	 0
  00401	6a 00		 push	 0
  00403	68 00 7e 00 00	 push	 32256			; 00007e00H
  00408	8d 83 00 cc 01
	00		 lea	 eax, DWORD PTR [ebx+117760]
  0040e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00415	50		 push	 eax
  00416	8b ce		 mov	 ecx, esi
  00418	e8 00 00 00 00	 call	 ?CreateBootLoaderInMemory@BootEncryption@GostCrypt@@IAEXPAEI_N1@Z ; GostCrypt::BootEncryption::CreateBootLoaderInMemory
  0041d	68 00 00 1c 00	 push	 1835008			; 001c0000H
  00422	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00427	83 c4 04	 add	 esp, 4
  0042a	89 86 c0 01 00
	00		 mov	 DWORD PTR [esi+448], eax
  00430	85 c0		 test	 eax, eax
  00432	75 30		 jne	 SHORT $LN7@CreateResc

; 1976 : 
; 1977 : 		RescueIsoImage = new byte[RescueIsoImageSize];
; 1978 : 		if (!RescueIsoImage)
; 1979 : 			throw bad_alloc();

  00434	0f 57 c0	 xorps	 xmm0, xmm0
  00437	c7 85 dc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00441	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00446	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0044c	66 0f d6 85 e0
	fd ff ff	 movq	 QWORD PTR $T3[ebp+4], xmm0
  00454	50		 push	 eax
  00455	c7 85 e0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp+4], OFFSET ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
  0045f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN319@CreateResc:
$LN7@CreateResc:

; 1980 : 		memcpy (RescueIsoImage, image, RescueIsoImageSize);

  00464	68 00 00 1c 00	 push	 1835008			; 001c0000H
  00469	53		 push	 ebx
  0046a	50		 push	 eax
  0046b	e8 00 00 00 00	 call	 _memcpy
  00470	83 c4 0c	 add	 esp, 12			; 0000000cH
  00473	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0

; 1981 : 
; 1982 : 		if (!isoImagePath.empty())

  00477	74 52		 je	 SHORT $LN8@CreateResc

; 1983 : 		{
; 1984 : 			File isoFile (isoImagePath, false, true);

  00479	6a 01		 push	 1
  0047b	6a 00		 push	 0
  0047d	83 ec 18	 sub	 esp, 24			; 00000018H
  00480	8b cc		 mov	 ecx, esp
  00482	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00489	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00490	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00494	72 04		 jb	 SHORT $LN303@CreateResc
  00496	8b 01		 mov	 eax, DWORD PTR [ecx]
  00498	eb 02		 jmp	 SHORT $LN304@CreateResc
$LN303@CreateResc:
  0049a	8b c1		 mov	 eax, ecx
$LN304@CreateResc:
  0049c	6a ff		 push	 -1
  0049e	6a 00		 push	 0
  004a0	57		 push	 edi
  004a1	c6 00 00	 mov	 BYTE PTR [eax], 0
  004a4	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  004a9	8d 4d bc	 lea	 ecx, DWORD PTR _isoFile$8[ebp]
  004ac	e8 00 00 00 00	 call	 ??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z ; GostCrypt::File::File

; 1985 : 			isoFile.Write (image, RescueIsoImageSize);

  004b1	68 00 00 1c 00	 push	 1835008			; 001c0000H
  004b6	53		 push	 ebx
  004b7	8d 4d bc	 lea	 ecx, DWORD PTR _isoFile$8[ebp]
  004ba	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+12], 7
  004be	e8 00 00 00 00	 call	 ?Write@File@GostCrypt@@QAEXPAEK@Z ; GostCrypt::File::Write

; 1986 : 		}

  004c3	8d 4d bc	 lea	 ecx, DWORD PTR _isoFile$8[ebp]
  004c6	e8 00 00 00 00	 call	 ??1File@GostCrypt@@QAE@XZ ; GostCrypt::File::~File
$LN8@CreateResc:

; 1987 : 	}

  004cb	53		 push	 ebx
  004cc	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  004d1	83 c4 04	 add	 esp, 4
  004d4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  004d7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004de	59		 pop	 ecx
  004df	5f		 pop	 edi
  004e0	5e		 pop	 esi
  004e1	5b		 pop	 ebx
  004e2	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004e5	33 cd		 xor	 ecx, ebp
  004e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004ec	8b e5		 mov	 esp, ebp
  004ee	5d		 pop	 ebp
  004ef	c2 08 00	 ret	 8
$LN314@CreateResc:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
  00000	8d 8d f4 fd ff
	ff		 lea	 ecx, DWORD PTR _imageBuf$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1Buffer@GostCrypt@@QAE@XZ ; GostCrypt::Buffer::~Buffer
__unwindfunclet$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$3:
  0000b	8d 8d 1c fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$5:
  00016	8d 4d bc	 lea	 ecx, DWORD PTR _bootDevice$10[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1Device@GostCrypt@@QAE@XZ
__unwindfunclet$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$7:
  0001e	8d 4d bc	 lea	 ecx, DWORD PTR _sysBakFile$9[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1File@GostCrypt@@QAE@XZ ; GostCrypt::File::~File
__unwindfunclet$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$9:
  00026	8d 4d bc	 lea	 ecx, DWORD PTR _isoFile$8[ebp]
  00029	e9 00 00 00 00	 jmp	 ??1File@GostCrypt@@QAE@XZ ; GostCrypt::File::~File
__ehhandler$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  0002e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00032	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00035	8b 8a d4 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-556]
  0003b	33 c8		 xor	 ecx, eax
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00045	33 c8		 xor	 ecx, eax
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00051	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateRescueIsoImage@BootEncryption@GostCrypt@@QAEX_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; GostCrypt::BootEncryption::CreateRescueIsoImage
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?CopyFileAdmin@BootEncryption@GostCrypt@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_sourceFile$ = 8					; size = 4
_destinationFile$ = 12					; size = 4
?CopyFileAdmin@BootEncryption@GostCrypt@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z PROC ; GostCrypt::BootEncryption::CopyFileAdmin, COMDAT
; _this$ = ecx

; 3089 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3090 : 		if (!IsAdmin())

  00006	e8 00 00 00 00	 call	 _IsAdmin
  0000b	85 c0		 test	 eax, eax
  0000d	75 1d		 jne	 SHORT $LN4@CopyFileAd

; 3091 : 		{
; 3092 : 			if (!IsUacSupported())

  0000f	e8 00 00 00 00	 call	 _IsUacSupported
  00014	85 c0		 test	 eax, eax
  00016	74 38		 je	 SHORT $LN23@CopyFileAd

; 3096 : 			}
; 3097 : 			else
; 3098 : 				Elevator::CopyFile (sourceFile, destinationFile);

  00018	ff 75 0c	 push	 DWORD PTR _destinationFile$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR _sourceFile$[ebp]
  0001e	e8 00 00 00 00	 call	 ?CopyFileA@Elevator@GostCrypt@@SAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; GostCrypt::Elevator::CopyFileA
  00023	83 c4 08	 add	 esp, 8

; 3102 : 	}

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
$LN4@CopyFileAd:

; 3099 : 		}
; 3100 : 		else
; 3101 : 			throw_sys_if (!::CopyFile (sourceFile.c_str(), destinationFile.c_str(), FALSE));

  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _destinationFile$[ebp]
  0002f	6a 00		 push	 0
  00031	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _sourceFile$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CopyFileA@12
  00046	85 c0		 test	 eax, eax
  00048	74 0e		 je	 SHORT $LN22@CopyFileAd

; 3102 : 	}

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
$LN23@CopyFileAd:

; 3093 : 			{
; 3094 : 				SetLastError (ERROR_ACCESS_DENIED);

  00050	6a 05		 push	 5
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
$LN22@CopyFileAd:

; 3095 : 				throw SystemException();

  00058	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00065	89 45 fc	 mov	 DWORD PTR $T1[ebp+4], eax
  00068	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  0006b	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN25@CopyFileAd:
$LN21@CopyFileAd:
  00076	cc		 int	 3
?CopyFileAdmin@BootEncryption@GostCrypt@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ENDP ; GostCrypt::BootEncryption::CopyFileAdmin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?CheckRequirementsHiddenOS@BootEncryption@GostCrypt@@QAEXXZ
_TEXT	SEGMENT
$T1 = -116						; size = 112
__$ArrayPad$ = -4					; size = 4
?CheckRequirementsHiddenOS@BootEncryption@GostCrypt@@QAEXXZ PROC ; GostCrypt::BootEncryption::CheckRequirementsHiddenOS, COMDAT
; _this$ = ecx

; 2500 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2501 : 		// It is assumed that CheckRequirements() had been called (so we don't check e.g. whether it's GPT).
; 2502 : 
; 2503 : 		// The user may have modified/added/deleted partitions since the partition table was last scanned.
; 2504 : 		InvalidateCachedSysDriveProperties ();
; 2505 : 
; 2506 : 		GetPartitionForHiddenOS ();

  00010	8d 45 8c	 lea	 eax, DWORD PTR $T1[ebp]
  00013	66 c7 81 c4 05
	00 00 00 00	 mov	 WORD PTR [ecx+1476], 0
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?GetPartitionForHiddenOS@BootEncryption@GostCrypt@@QAE?AUPartition@2@XZ ; GostCrypt::BootEncryption::GetPartitionForHiddenOS
  00022	8d 4d 8c	 lea	 ecx, DWORD PTR $T1[ebp]
  00025	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ

; 2507 : 	}

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002d	33 cd		 xor	 ecx, ebp
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?CheckRequirementsHiddenOS@BootEncryption@GostCrypt@@QAEXXZ ENDP ; GostCrypt::BootEncryption::CheckRequirementsHiddenOS
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ
_TEXT	SEGMENT
$T2 = -396						; size = 4
_config$ = -392						; size = 320
_geometry$ = -72					; size = 24
$T3 = -48						; size = 32
$T4 = -48						; size = 32
$T5 = -48						; size = 32
$T6 = -48						; size = 32
$T7 = -48						; size = 32
$T8 = -48						; size = 32
$T9 = -48						; size = 32
_$S6$10 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ PROC ; GostCrypt::BootEncryption::CheckRequirements, COMDAT
; _this$ = ecx

; 2440 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 80 01 00
	00		 sub	 esp, 384		; 00000180H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f1		 mov	 esi, ecx

; 2441 : 		if (nCurrentOS == WIN_2000)

  0002f	83 3d 00 00 00
	00 07		 cmp	 DWORD PTR _nCurrentOS, 7
  00036	75 30		 jne	 SHORT $LN8@CheckRequi

; 2442 : 			throw ErrorException ("SYS_ENCRYPTION_UNSUPPORTED_ON_CURRENT_OS");

  00038	33 c0		 xor	 eax, eax
  0003a	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T9[ebp], OFFSET ??_7ErrorException@GostCrypt@@6B@
  00041	66 89 45 d8	 mov	 WORD PTR $T9[ebp+8], ax
  00045	8d 45 d0	 lea	 eax, DWORD PTR $T9[ebp]
  00048	68 00 00 00 00	 push	 OFFSET __TI2?AUErrorException@GostCrypt@@
  0004d	50		 push	 eax
  0004e	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T9[ebp+4], OFFSET ??_C@_0CJ@BKBFFPJL@SYS_ENCRYPTION_UNSUPPORTED_ON_CU@
  00055	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR $T9[ebp+28], 7
  0005c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T9[ebp+24], 0
  00063	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN854@CheckRequi:
$LN8@CheckRequi:

; 2443 :  
; 2444 : 		if (CurrentOSMajor == 6 && CurrentOSMinor == 0 && CurrentOSServicePack < 1)

  00068	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR _CurrentOSMajor, 6
  0006f	75 42		 jne	 SHORT $LN9@CheckRequi
  00071	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _CurrentOSMinor, 0
  00078	75 39		 jne	 SHORT $LN9@CheckRequi
  0007a	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR _CurrentOSServicePack, 1
  00081	7d 30		 jge	 SHORT $LN9@CheckRequi

; 2445 : 			throw ErrorException ("SYS_ENCRYPTION_UNSUPPORTED_ON_VISTA_SP0");

  00083	33 c0		 xor	 eax, eax
  00085	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T8[ebp], OFFSET ??_7ErrorException@GostCrypt@@6B@
  0008c	66 89 45 d8	 mov	 WORD PTR $T8[ebp+8], ax
  00090	8d 45 d0	 lea	 eax, DWORD PTR $T8[ebp]
  00093	68 00 00 00 00	 push	 OFFSET __TI2?AUErrorException@GostCrypt@@
  00098	50		 push	 eax
  00099	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T8[ebp+4], OFFSET ??_C@_0CI@OBNNMOKO@SYS_ENCRYPTION_UNSUPPORTED_ON_VI@
  000a0	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR $T8[ebp+28], 7
  000a7	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T8[ebp+24], 0
  000ae	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN855@CheckRequi:
$LN9@CheckRequi:

; 2446 : 
; 2447 : 		if (IsNonInstallMode())

  000b3	e8 00 00 00 00	 call	 _IsNonInstallMode
  000b8	85 c0		 test	 eax, eax
  000ba	74 30		 je	 SHORT $LN10@CheckRequi

; 2448 : 			throw ErrorException ("FEATURE_REQUIRES_INSTALLATION");

  000bc	33 c0		 xor	 eax, eax
  000be	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T7[ebp], OFFSET ??_7ErrorException@GostCrypt@@6B@
  000c5	66 89 45 d8	 mov	 WORD PTR $T7[ebp+8], ax
  000c9	8d 45 d0	 lea	 eax, DWORD PTR $T7[ebp]
  000cc	68 00 00 00 00	 push	 OFFSET __TI2?AUErrorException@GostCrypt@@
  000d1	50		 push	 eax
  000d2	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T7[ebp+4], OFFSET ??_C@_0BO@EPIDJGMK@FEATURE_REQUIRES_INSTALLATION?$AA@
  000d9	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR $T7[ebp+28], 7
  000e0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T7[ebp+24], 0
  000e7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN856@CheckRequi:
$LN10@CheckRequi:

; 2449 : 
; 2450 : 		SystemDriveConfiguration config = GetSystemDriveConfiguration ();

  000ec	8d 85 78 fe ff
	ff		 lea	 eax, DWORD PTR _config$[ebp]
  000f2	8b ce		 mov	 ecx, esi
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration

; 2451 : 
; 2452 : 		if (config.SystemPartition.IsGPT)

  000fa	83 7d 8c 00	 cmp	 DWORD PTR _config$[ebp+276], 0
  000fe	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00105	74 30		 je	 SHORT $LN11@CheckRequi

; 2453 : 			throw ErrorException ("GPT_BOOT_DRIVE_UNSUPPORTED");

  00107	33 c0		 xor	 eax, eax
  00109	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], OFFSET ??_7ErrorException@GostCrypt@@6B@
  00110	66 89 45 d8	 mov	 WORD PTR $T6[ebp+8], ax
  00114	8d 45 d0	 lea	 eax, DWORD PTR $T6[ebp]
  00117	68 00 00 00 00	 push	 OFFSET __TI2?AUErrorException@GostCrypt@@
  0011c	50		 push	 eax
  0011d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T6[ebp+4], OFFSET ??_C@_0BL@CEKJKLIB@GPT_BOOT_DRIVE_UNSUPPORTED?$AA@
  00124	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR $T6[ebp+28], 7
  0012b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T6[ebp+24], 0
  00132	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN857@CheckRequi:
$LN11@CheckRequi:

; 2454 : 
; 2455 : 		if (SystemDriveIsDynamic())

  00137	8b ce		 mov	 ecx, esi
  00139	e8 00 00 00 00	 call	 ?SystemDriveIsDynamic@BootEncryption@GostCrypt@@QAE_NXZ ; GostCrypt::BootEncryption::SystemDriveIsDynamic
  0013e	84 c0		 test	 al, al
  00140	74 30		 je	 SHORT $LN12@CheckRequi

; 2456 : 			throw ErrorException ("SYSENC_UNSUPPORTED_FOR_DYNAMIC_DISK");

  00142	33 c0		 xor	 eax, eax
  00144	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], OFFSET ??_7ErrorException@GostCrypt@@6B@
  0014b	66 89 45 d8	 mov	 WORD PTR $T5[ebp+8], ax
  0014f	8d 45 d0	 lea	 eax, DWORD PTR $T5[ebp]
  00152	68 00 00 00 00	 push	 OFFSET __TI2?AUErrorException@GostCrypt@@
  00157	50		 push	 eax
  00158	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+4], OFFSET ??_C@_0CE@HGBKLHHD@SYSENC_UNSUPPORTED_FOR_DYNAMIC_D@
  0015f	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR $T5[ebp+28], 7
  00166	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+24], 0
  0016d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN858@CheckRequi:
$LN12@CheckRequi:

; 2457 : 
; 2458 : 		if (config.InitialUnallocatedSpace < GST_BOOT_LOADER_AREA_SIZE)

  00172	83 bd 2c ff ff
	ff 00		 cmp	 DWORD PTR _config$[ebp+180], 0
  00179	7f 3e		 jg	 SHORT $LN13@CheckRequi
  0017b	7c 0c		 jl	 SHORT $LN851@CheckRequi
  0017d	81 bd 28 ff ff
	ff 00 7e 00 00	 cmp	 DWORD PTR _config$[ebp+176], 32256 ; 00007e00H
  00187	73 30		 jae	 SHORT $LN13@CheckRequi
$LN851@CheckRequi:

; 2459 : 			throw ErrorException ("NO_SPACE_FOR_BOOT_LOADER");

  00189	33 c0		 xor	 eax, eax
  0018b	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_7ErrorException@GostCrypt@@6B@
  00192	66 89 45 d8	 mov	 WORD PTR $T4[ebp+8], ax
  00196	8d 45 d0	 lea	 eax, DWORD PTR $T4[ebp]
  00199	68 00 00 00 00	 push	 OFFSET __TI2?AUErrorException@GostCrypt@@
  0019e	50		 push	 eax
  0019f	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+4], OFFSET ??_C@_0BJ@HICFFOOK@NO_SPACE_FOR_BOOT_LOADER?$AA@
  001a6	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR $T4[ebp+28], 7
  001ad	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+24], 0
  001b4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN859@CheckRequi:
$LN13@CheckRequi:

; 2460 : 
; 2461 : 		DISK_GEOMETRY geometry = GetDriveGeometry (config.DriveNumber);

  001b9	ff b5 a8 fe ff
	ff		 push	 DWORD PTR _config$[ebp+48]
  001bf	8d 45 b8	 lea	 eax, DWORD PTR _geometry$[ebp]
  001c2	8b ce		 mov	 ecx, esi
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 ?GetDriveGeometry@BootEncryption@GostCrypt@@IAE?AU_DISK_GEOMETRY@@H@Z ; GostCrypt::BootEncryption::GetDriveGeometry

; 2462 : 
; 2463 : 		if (geometry.BytesPerSector != GST_SECTOR_SIZE_BIOS)

  001ca	81 7d cc 00 02
	00 00		 cmp	 DWORD PTR _geometry$[ebp+20], 512 ; 00000200H
  001d1	74 30		 je	 SHORT $LN14@CheckRequi

; 2464 : 			throw ErrorException ("SYSENC_UNSUPPORTED_SECTOR_SIZE_BIOS");

  001d3	33 c0		 xor	 eax, eax
  001d5	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_7ErrorException@GostCrypt@@6B@
  001dc	66 89 45 d8	 mov	 WORD PTR $T3[ebp+8], ax
  001e0	8d 45 d0	 lea	 eax, DWORD PTR $T3[ebp]
  001e3	68 00 00 00 00	 push	 OFFSET __TI2?AUErrorException@GostCrypt@@
  001e8	50		 push	 eax
  001e9	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], OFFSET ??_C@_0CE@NNOADDIE@SYSENC_UNSUPPORTED_SECTOR_SIZE_B@
  001f0	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR $T3[ebp+28], 7
  001f7	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+24], 0
  001fe	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN860@CheckRequi:
$LN14@CheckRequi:

; 2465 : 
; 2466 : 		bool activePartitionFound = false;

  00203	32 db		 xor	 bl, bl

; 2467 : 		if (!config.SystemPartition.IsGPT)

  00205	83 7d 8c 00	 cmp	 DWORD PTR _config$[ebp+276], 0
  00209	75 7a		 jne	 SHORT $LN15@CheckRequi

; 2468 : 		{
; 2469 : 			// Determine whether there is an Active partition on the system drive
; 2470 : 			foreach (const Partition &partition, config.Partitions)

  0020b	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _config$[ebp+184]
  00211	50		 push	 eax
  00212	8d 45 d8	 lea	 eax, DWORD PTR _$S6$10[ebp]
  00215	50		 push	 eax
  00216	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
  0021b	83 c4 08	 add	 esp, 8
  0021e	8b 45 d8	 mov	 eax, DWORD PTR _$S6$10[ebp]
  00221	8d 4d d8	 lea	 ecx, DWORD PTR _$S6$10[ebp]
  00224	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00228	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0022b	ff d0		 call	 eax
  0022d	84 c0		 test	 al, al
  0022f	74 48		 je	 SHORT $LN3@CheckRequi
$LL4@CheckRequi:
  00231	8b 55 ec	 mov	 edx, DWORD PTR _$S6$10[ebp+20]
  00234	33 c9		 xor	 ecx, ecx
  00236	38 4d dd	 cmp	 BYTE PTR _$S6$10[ebp+5], cl
  00239	0f 94 c1	 sete	 cl
  0023c	88 4d dd	 mov	 BYTE PTR _$S6$10[ebp+5], cl
  0023f	84 c9		 test	 cl, cl
  00241	74 1e		 je	 SHORT $LN2@CheckRequi
$LL7@CheckRequi:

; 2471 : 			{
; 2472 : 				if (partition.Info.BootIndicator)

  00243	80 7a 39 00	 cmp	 BYTE PTR [edx+57], 0
  00247	75 16		 jne	 SHORT $LN844@CheckRequi

; 2468 : 		{
; 2469 : 			// Determine whether there is an Active partition on the system drive
; 2470 : 			foreach (const Partition &partition, config.Partitions)

  00249	33 c0		 xor	 eax, eax
  0024b	c6 45 dc 01	 mov	 BYTE PTR _$S6$10[ebp+4], 1
  0024f	84 c9		 test	 cl, cl
  00251	0f 94 c0	 sete	 al
  00254	8a c8		 mov	 cl, al
  00256	88 4d dd	 mov	 BYTE PTR _$S6$10[ebp+5], cl
  00259	84 c0		 test	 al, al
  0025b	75 e6		 jne	 SHORT $LL7@CheckRequi

; 2471 : 			{
; 2472 : 				if (partition.Info.BootIndicator)

  0025d	eb 02		 jmp	 SHORT $LN2@CheckRequi
$LN844@CheckRequi:

; 2473 : 				{
; 2474 : 					activePartitionFound = true;

  0025f	b3 01		 mov	 bl, 1
$LN2@CheckRequi:

; 2468 : 		{
; 2469 : 			// Determine whether there is an Active partition on the system drive
; 2470 : 			foreach (const Partition &partition, config.Partitions)

  00261	8b 45 d8	 mov	 eax, DWORD PTR _$S6$10[ebp]
  00264	8d 4d d8	 lea	 ecx, DWORD PTR _$S6$10[ebp]
  00267	ff 50 08	 call	 DWORD PTR [eax+8]
  0026a	8b 45 d8	 mov	 eax, DWORD PTR _$S6$10[ebp]
  0026d	8d 4d d8	 lea	 ecx, DWORD PTR _$S6$10[ebp]
  00270	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00273	ff d0		 call	 eax
  00275	84 c0		 test	 al, al
  00277	75 b8		 jne	 SHORT $LL4@CheckRequi
$LN3@CheckRequi:

; 2475 : 					break;
; 2476 : 				}
; 2477 : 			}

  00279	8d 4d d8	 lea	 ecx, DWORD PTR _$S6$10[ebp]
  0027c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00280	e8 00 00 00 00	 call	 ??1?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
$LN15@CheckRequi:

; 2478 : 		}
; 2479 : 
; 2480 : 		if (!config.SystemLoaderPresent || !activePartitionFound)

  00285	80 7d b0 00	 cmp	 BYTE PTR _config$[ebp+312], 0
  00289	74 04		 je	 SHORT $LN18@CheckRequi
  0028b	84 db		 test	 bl, bl
  0028d	75 3d		 jne	 SHORT $LN17@CheckRequi
$LN18@CheckRequi:

; 2481 : 		{
; 2482 : 			static bool confirmed = false;
; 2483 : 
; 2484 : 			if (!confirmed && AskWarnNoYes ("WINDOWS_NOT_ON_BOOT_DRIVE_ERROR") == IDNO)

  0028f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?confirmed@?BM@??CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ@4_NA, 0
  00296	75 2d		 jne	 SHORT $LN19@CheckRequi
  00298	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@PKMHCFDK@WINDOWS_NOT_ON_BOOT_DRIVE_ERROR?$AA@
  0029d	e8 00 00 00 00	 call	 _AskWarnNoYes
  002a2	83 c4 04	 add	 esp, 4
  002a5	83 f8 07	 cmp	 eax, 7
  002a8	75 1b		 jne	 SHORT $LN19@CheckRequi

; 2485 : 				throw UserAbort (SRC_POS);

  002aa	68 00 00 00 00	 push	 OFFSET __TI2?AUUserAbort@GostCrypt@@
  002af	8d 85 74 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  002b5	c7 85 74 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_7UserAbort@GostCrypt@@6B@
  002bf	50		 push	 eax
  002c0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN861@CheckRequi:
$LN19@CheckRequi:

; 2486 : 
; 2487 : 			confirmed = true;

  002c5	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?confirmed@?BM@??CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ@4_NA, 1
$LN17@CheckRequi:

; 2488 : 		}
; 2489 : 	}

  002cc	8d 8d 78 fe ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp]
  002d2	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
  002d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002e1	59		 pop	 ecx
  002e2	5e		 pop	 esi
  002e3	5b		 pop	 ebx
  002e4	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e7	33 cd		 xor	 ecx, ebp
  002e9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ee	8b e5		 mov	 esp, ebp
  002f0	5d		 pop	 ebp
  002f1	c3		 ret	 0
$LN853@CheckRequi:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ$0:
  00000	8d 8d 78 fe ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ$1:
  0000b	8d 4d d8	 lea	 ecx, DWORD PTR _$S6$10[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__ehhandler$?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 8a 74 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-396]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ
  00036	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CheckRequirements@BootEncryption@GostCrypt@@QAEXXZ ENDP ; GostCrypt::BootEncryption::CheckRequirements
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?CheckEncryptionSetupResult@BootEncryption@GostCrypt@@QAEXXZ
_TEXT	SEGMENT
?CheckEncryptionSetupResult@BootEncryption@GostCrypt@@QAEXXZ PROC ; GostCrypt::BootEncryption::CheckEncryptionSetupResult, COMDAT
; _this$ = ecx

; 2819 : 		CallDriver (GST_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT);

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	6a 00		 push	 0
  00006	6a 00		 push	 0
  00008	68 54 20 22 00	 push	 2236500			; 00222054H
  0000d	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 2820 : 	}

  00012	c3		 ret	 0
?CheckEncryptionSetupResult@BootEncryption@GostCrypt@@QAEXXZ ENDP ; GostCrypt::BootEncryption::CheckEncryptionSetupResult
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?CheckDecoyOSWipeResult@BootEncryption@GostCrypt@@QAEXXZ
_TEXT	SEGMENT
?CheckDecoyOSWipeResult@BootEncryption@GostCrypt@@QAEXXZ PROC ; GostCrypt::BootEncryption::CheckDecoyOSWipeResult, COMDAT
; _this$ = ecx

; 1699 : 		CallDriver (GST_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT);

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	6a 00		 push	 0
  00006	6a 00		 push	 0
  00008	68 84 20 22 00	 push	 2236548			; 00222084H
  0000d	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 1700 : 	}

  00012	c3		 ret	 0
?CheckDecoyOSWipeResult@BootEncryption@GostCrypt@@QAEXXZ ENDP ; GostCrypt::BootEncryption::CheckDecoyOSWipeResult
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z
_TEXT	SEGMENT
_e$2 = -1192						; size = 4
$T3 = -1188						; size = 8
$T4 = -1180						; size = 8
$T5 = -1172						; size = 8
$T6 = -1164						; size = 8
$T7 = -1156						; size = 8
$T8 = -1148						; size = 8
_$S7$9 = -1140						; size = 24
_this$GSCopy$ = -1116					; size = 4
_newPassword$GSCopy$ = -1112				; size = 4
_finally2801$10 = -1112					; size = 4
_tmpCryptoInfo$11 = -1108				; size = 4
_finally2703$ = -1104					; size = 4
_this$GSCopy$1$ = -1100					; size = 4
_backupHeaderOffset$2$ = -1096				; size = 4
_backupHeaderOffset$1$ = -1092				; size = 4
_cryptoInfo$ = -1088					; size = 4
_newPassword$GSCopy$1$ = -1084				; size = 4
_result$ = -1084					; size = 4
_oldPassword$GSCopy$1$ = -1080				; size = 4
_backupHeader$1$ = -1080				; size = 4
_headerOffset$2$ = -1076				; size = 4
_headerUpdated$ = -1069					; size = 1
_finally2719$ = -1069					; size = 1
_config$ = -1068					; size = 320
_reopenRequest$12 = -748				; size = 72
_encStatus$ = -676					; size = 94
_device$ = -580						; size = 48
_header$ = -532						; size = 512
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_oldPassword$ = 8					; size = 4
_newPassword$ = 12					; size = 4
_pkcs5$ = 16						; size = 4
?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z PROC ; GostCrypt::BootEncryption::ChangePassword, COMDAT
; _this$ = ecx

; 2661 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 9c 04 00
	00		 sub	 esp, 1180		; 0000049cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b f9		 mov	 edi, ecx
  00033	89 bd b4 fb ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi
  00039	8b 45 08	 mov	 eax, DWORD PTR _oldPassword$[ebp]
  0003c	89 85 c8 fb ff
	ff		 mov	 DWORD PTR _oldPassword$GSCopy$1$[ebp], eax
  00042	8b 45 0c	 mov	 eax, DWORD PTR _newPassword$[ebp]

; 2662 : 		BootEncryptionStatus encStatus = GetStatus();

  00045	6a 5e		 push	 94			; 0000005eH
  00047	89 85 c4 fb ff
	ff		 mov	 DWORD PTR _newPassword$GSCopy$1$[ebp], eax
  0004d	89 85 a8 fb ff
	ff		 mov	 DWORD PTR _newPassword$GSCopy$[ebp], eax
  00053	8d 85 5c fd ff
	ff		 lea	 eax, DWORD PTR _encStatus$[ebp]
  00059	50		 push	 eax
  0005a	6a 00		 push	 0
  0005c	6a 00		 push	 0
  0005e	68 48 20 22 00	 push	 2236488			; 00222048H
  00063	89 bd a4 fb ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  00069	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 2663 : 
; 2664 : 		if (encStatus.SetupInProgress)

  0006e	83 bd 9a fd ff
	ff 00		 cmp	 DWORD PTR _encStatus$[ebp+62], 0
  00075	74 25		 je	 SHORT $LN16@ChangePass

; 2665 : 			throw ParameterIncorrect (SRC_POS);

  00077	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  0007c	8d 85 84 fb ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  00082	c7 85 84 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0008c	50		 push	 eax
  0008d	c7 85 88 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+4], OFFSET ??_C@_0CP@GALNFEGF@GostCrypt?3?3BootEncryption?3?3Chang@
  00097	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN598@ChangePass:
$LN16@ChangePass:

; 2666 : 
; 2667 : 		SystemDriveConfiguration config = GetSystemDriveConfiguration ();

  0009c	8d 85 d4 fb ff
	ff		 lea	 eax, DWORD PTR _config$[ebp]
  000a2	8b cf		 mov	 ecx, edi
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ?GetSystemDriveConfiguration@BootEncryption@GostCrypt@@QAE?AUSystemDriveConfiguration@2@XZ ; GostCrypt::BootEncryption::GetSystemDriveConfiguration

; 2668 : 
; 2669 : 		char header[GST_BOOT_ENCRYPTION_VOLUME_HEADER_SIZE];
; 2670 : 		Device device (config.DevicePath);

  000aa	6a 00		 push	 0
  000ac	83 ec 18	 sub	 esp, 24			; 00000018H
  000af	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000b6	8b cc		 mov	 ecx, esp
  000b8	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  000bf	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  000c6	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  000ca	72 04		 jb	 SHORT $LN169@ChangePass
  000cc	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ce	eb 02		 jmp	 SHORT $LN170@ChangePass
$LN169@ChangePass:
  000d0	8b c1		 mov	 eax, ecx
$LN170@ChangePass:
  000d2	6a ff		 push	 -1
  000d4	c6 00 00	 mov	 BYTE PTR [eax], 0
  000d7	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _config$[ebp+24]
  000dd	6a 00		 push	 0
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000e5	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  000eb	e8 00 00 00 00	 call	 ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; GostCrypt::Device::Device

; 2671 : 
; 2672 : 		// Only one algorithm is currently supported
; 2673 : 		if (pkcs5 != 0)

  000f0	83 7d 10 00	 cmp	 DWORD PTR _pkcs5$[ebp], 0
  000f4	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  000f8	74 25		 je	 SHORT $LN17@ChangePass

; 2674 : 			throw ParameterIncorrect (SRC_POS);

  000fa	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  000ff	8d 85 7c fb ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00105	c7 85 7c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0010f	50		 push	 eax
  00110	c7 85 80 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+4], OFFSET ??_C@_0CP@HIGEAPBD@GostCrypt?3?3BootEncryption?3?3Chang@
  0011a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN599@ChangePass:
$LN17@ChangePass:

; 2675 : 
; 2676 : 		int64 headerOffset = GST_BOOT_VOLUME_HEADER_SECTOR_OFFSET;

  0011f	33 f6		 xor	 esi, esi

; 2677 : 		int64 backupHeaderOffset = -1;

  00121	c7 85 bc fb ff
	ff ff ff ff ff	 mov	 DWORD PTR _backupHeaderOffset$1$[ebp], -1
  0012b	bb 00 7c 00 00	 mov	 ebx, 31744		; 00007c00H
  00130	89 b5 cc fb ff
	ff		 mov	 DWORD PTR _headerOffset$2$[ebp], esi
  00136	c7 85 b8 fb ff
	ff ff ff ff ff	 mov	 DWORD PTR _backupHeaderOffset$2$[ebp], -1

; 2678 : 
; 2679 : 		if (encStatus.HiddenSystem)

  00140	39 b5 aa fd ff
	ff		 cmp	 DWORD PTR _encStatus$[ebp+78], esi
  00146	0f 84 4e 01 00
	00		 je	 $LN20@ChangePass

; 2680 : 		{
; 2681 : 			headerOffset = encStatus.HiddenSystemPartitionStart + GST_HIDDEN_VOLUME_HEADER_OFFSET;

  0014c	8b 9d ae fd ff
	ff		 mov	 ebx, DWORD PTR _encStatus$[ebp+82]

; 2682 : 
; 2683 : 			// Find hidden system partition
; 2684 : 			foreach (const Partition &partition, config.Partitions)

  00152	8d 85 8c fc ff
	ff		 lea	 eax, DWORD PTR _config$[ebp+184]
  00158	8b b5 b2 fd ff
	ff		 mov	 esi, DWORD PTR _encStatus$[ebp+86]
  0015e	81 c3 00 00 01
	00		 add	 ebx, 65536		; 00010000H
  00164	50		 push	 eax
  00165	8d 85 8c fb ff
	ff		 lea	 eax, DWORD PTR _$S7$9[ebp]
  0016b	83 d6 00	 adc	 esi, 0
  0016e	50		 push	 eax
  0016f	89 b5 cc fb ff
	ff		 mov	 DWORD PTR _headerOffset$2$[ebp], esi
  00175	e8 00 00 00 00	 call	 ??$GetContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@SA?AU?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@01@ABV?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@Z ; GostCrypt::ForEach::GetContainerForward<std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
  0017a	83 c4 08	 add	 esp, 8
  0017d	8b 85 8c fb ff
	ff		 mov	 eax, DWORD PTR _$S7$9[ebp]
  00183	8d 8d 8c fb ff
	ff		 lea	 ecx, DWORD PTR _$S7$9[ebp]
  00189	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  0018d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00190	ff d0		 call	 eax
  00192	84 c0		 test	 al, al
  00194	0f 84 ad 00 00
	00		 je	 $LN3@ChangePass
  0019a	66 0f 1f 44 00
	00		 npad	 6
$LL4@ChangePass:
  001a0	8b 95 a0 fb ff
	ff		 mov	 edx, DWORD PTR _$S7$9[ebp+20]
  001a6	33 c9		 xor	 ecx, ecx
  001a8	38 8d 91 fb ff
	ff		 cmp	 BYTE PTR _$S7$9[ebp+5], cl
  001ae	0f 94 c1	 sete	 cl
  001b1	88 8d 91 fb ff
	ff		 mov	 BYTE PTR _$S7$9[ebp+5], cl
  001b7	84 c9		 test	 cl, cl
  001b9	74 58		 je	 SHORT $LN2@ChangePass
  001bb	0f 1f 44 00 00	 npad	 5
$LL7@ChangePass:

; 2685 : 			{
; 2686 : 				if (partition.Info.StartingOffset.QuadPart == encStatus.HiddenSystemPartitionStart)

  001c0	8b 85 ae fd ff
	ff		 mov	 eax, DWORD PTR _encStatus$[ebp+82]
  001c6	39 42 20	 cmp	 DWORD PTR [edx+32], eax
  001c9	75 0b		 jne	 SHORT $LN590@ChangePass
  001cb	8b 85 b2 fd ff
	ff		 mov	 eax, DWORD PTR _encStatus$[ebp+86]
  001d1	39 42 24	 cmp	 DWORD PTR [edx+36], eax
  001d4	74 1c		 je	 SHORT $LN579@ChangePass
$LN590@ChangePass:

; 2682 : 
; 2683 : 			// Find hidden system partition
; 2684 : 			foreach (const Partition &partition, config.Partitions)

  001d6	33 c0		 xor	 eax, eax
  001d8	c6 85 90 fb ff
	ff 01		 mov	 BYTE PTR _$S7$9[ebp+4], 1
  001df	84 c9		 test	 cl, cl
  001e1	0f 94 c0	 sete	 al
  001e4	8a c8		 mov	 cl, al
  001e6	88 8d 91 fb ff
	ff		 mov	 BYTE PTR _$S7$9[ebp+5], cl
  001ec	84 c0		 test	 al, al
  001ee	75 d0		 jne	 SHORT $LL7@ChangePass
  001f0	eb 21		 jmp	 SHORT $LN2@ChangePass
$LN579@ChangePass:

; 2687 : 				{
; 2688 : 					backupHeaderOffset = partition.Info.StartingOffset.QuadPart + partition.Info.PartitionLength.QuadPart - GST_VOLUME_HEADER_SIZE;

  001f2	8b 7a 28	 mov	 edi, DWORD PTR [edx+40]
  001f5	03 7a 20	 add	 edi, DWORD PTR [edx+32]
  001f8	8b 72 2c	 mov	 esi, DWORD PTR [edx+44]
  001fb	13 72 24	 adc	 esi, DWORD PTR [edx+36]
  001fe	81 ef 00 00 01
	00		 sub	 edi, 65536		; 00010000H
  00204	89 bd bc fb ff
	ff		 mov	 DWORD PTR _backupHeaderOffset$1$[ebp], edi
  0020a	83 de 00	 sbb	 esi, 0
  0020d	89 b5 b8 fb ff
	ff		 mov	 DWORD PTR _backupHeaderOffset$2$[ebp], esi
$LN2@ChangePass:

; 2682 : 
; 2683 : 			// Find hidden system partition
; 2684 : 			foreach (const Partition &partition, config.Partitions)

  00213	8b 85 8c fb ff
	ff		 mov	 eax, DWORD PTR _$S7$9[ebp]
  00219	8d 8d 8c fb ff
	ff		 lea	 ecx, DWORD PTR _$S7$9[ebp]
  0021f	ff 50 08	 call	 DWORD PTR [eax+8]
  00222	8b 85 8c fb ff
	ff		 mov	 eax, DWORD PTR _$S7$9[ebp]
  00228	8d 8d 8c fb ff
	ff		 lea	 ecx, DWORD PTR _$S7$9[ebp]
  0022e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00231	ff d0		 call	 eax
  00233	84 c0		 test	 al, al
  00235	0f 85 65 ff ff
	ff		 jne	 $LL4@ChangePass
  0023b	8b b5 cc fb ff
	ff		 mov	 esi, DWORD PTR _headerOffset$2$[ebp]
  00241	8b bd b4 fb ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN3@ChangePass:

; 2689 : 					break;
; 2690 : 				}
; 2691 : 			}

  00247	8d 8d 94 fb ff
	ff		 lea	 ecx, DWORD PTR _$S7$9[ebp+8]
  0024d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00251	e8 00 00 00 00	 call	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear
  00256	ff b5 94 fb ff
	ff		 push	 DWORD PTR _$S7$9[ebp+8]
  0025c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 2692 : 
; 2693 : 			if (backupHeaderOffset == -1)

  00261	8b 85 bc fb ff
	ff		 mov	 eax, DWORD PTR _backupHeaderOffset$1$[ebp]
  00267	83 c4 04	 add	 esp, 4
  0026a	23 85 b8 fb ff
	ff		 and	 eax, DWORD PTR _backupHeaderOffset$2$[ebp]
  00270	83 f8 ff	 cmp	 eax, -1
  00273	75 25		 jne	 SHORT $LN20@ChangePass

; 2694 : 				throw ParameterIncorrect (SRC_POS);

  00275	68 00 00 00 00	 push	 OFFSET __TI2?AUParameterIncorrect@GostCrypt@@
  0027a	8d 85 74 fb ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00280	c7 85 74 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0028a	50		 push	 eax
  0028b	c7 85 78 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+4], OFFSET ??_C@_0CP@HCPKCCBJ@GostCrypt?3?3BootEncryption?3?3Chang@
  00295	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN600@ChangePass:
$LN20@ChangePass:

; 2695 : 		}
; 2696 : 
; 2697 : 		device.SeekAt (headerOffset);

  0029a	80 bd bc fd ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  002a1	89 9d c4 fd ff
	ff		 mov	 DWORD PTR _device$[ebp+8], ebx
  002a7	89 b5 c8 fd ff
	ff		 mov	 DWORD PTR _device$[ebp+12], esi
  002ad	75 3d		 jne	 SHORT $LN282@ChangePass
  002af	6a 00		 push	 0
  002b1	6a 00		 push	 0
  002b3	56		 push	 esi
  002b4	53		 push	 ebx
  002b5	ff b5 cc fd ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  002bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  002c1	85 c0		 test	 eax, eax
  002c3	75 27		 jne	 SHORT $LN282@ChangePass
  002c5	c7 85 6c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  002cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  002d5	89 85 70 fb ff
	ff		 mov	 DWORD PTR $T5[ebp+4], eax
  002db	8d 85 6c fb ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  002e1	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  002e6	50		 push	 eax
  002e7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN601@ChangePass:
$LN282@ChangePass:

; 2698 : 		device.Read ((byte *) header, sizeof (header));

  002ec	68 00 02 00 00	 push	 512			; 00000200H
  002f1	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  002f7	50		 push	 eax
  002f8	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  002fe	e8 00 00 00 00	 call	 ?Read@File@GostCrypt@@QAEKPAEK@Z ; GostCrypt::File::Read

; 2699 : 
; 2700 : 		PCRYPTO_INFO cryptoInfo = NULL;
; 2701 : 		
; 2702 : 		int status = ReadVolumeHeader (!encStatus.HiddenSystem, header, oldPassword, &cryptoInfo, NULL);

  00303	6a 00		 push	 0
  00305	8d 85 c0 fb ff
	ff		 lea	 eax, DWORD PTR _cryptoInfo$[ebp]
  0030b	c7 85 c0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _cryptoInfo$[ebp], 0
  00315	50		 push	 eax
  00316	ff b5 c8 fb ff
	ff		 push	 DWORD PTR _oldPassword$GSCopy$1$[ebp]
  0031c	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00322	50		 push	 eax
  00323	33 c0		 xor	 eax, eax
  00325	39 85 aa fd ff
	ff		 cmp	 DWORD PTR _encStatus$[ebp+78], eax
  0032b	0f 94 c0	 sete	 al
  0032e	50		 push	 eax
  0032f	e8 00 00 00 00	 call	 _ReadVolumeHeader

; 2703 : 		finally_do_arg (PCRYPTO_INFO, cryptoInfo, { if (finally_arg) crypto_close (finally_arg); });

  00334	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  0033a	83 c4 14	 add	 esp, 20			; 00000014H
  0033d	8b f0		 mov	 esi, eax
  0033f	89 8d b0 fb ff
	ff		 mov	 DWORD PTR _finally2703$[ebp], ecx
  00345	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3

; 2704 : 
; 2705 : 		if (status != 0)

  00349	85 f6		 test	 esi, esi
  0034b	74 26		 je	 SHORT $LN10@ChangePass

; 2706 : 		{
; 2707 : 			handleError (ParentWindow, status);

  0034d	56		 push	 esi
  0034e	ff 37		 push	 DWORD PTR [edi]
  00350	e8 00 00 00 00	 call	 _handleError
  00355	83 c4 08	 add	 esp, 8

; 2708 : 			return status;

  00358	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _finally2703$[ebp]
  0035e	e8 00 00 00 00	 call	 ??1Finally2703@?1??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ ; `GostCrypt::BootEncryption::ChangePassword'::`2'::Finally2703::~Finally2703
  00363	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00369	e8 00 00 00 00	 call	 ??1Device@GostCrypt@@QAE@XZ
  0036e	e9 d0 03 00 00	 jmp	 $LN595@ChangePass
$LN10@ChangePass:

; 2709 : 		}
; 2710 : 
; 2711 : 		// Change the PKCS-5 PRF if requested by user
; 2712 : 		if (pkcs5 != 0)
; 2713 : 		{
; 2714 : 			cryptoInfo->pkcs5 = pkcs5;
; 2715 : 			RandSetHashFunction (pkcs5);
; 2716 : 		}
; 2717 : 
; 2718 : 		throw_sys_if (Randinit () != 0);

  00373	e8 00 00 00 00	 call	 _Randinit
  00378	85 c0		 test	 eax, eax
  0037a	74 27		 je	 SHORT $LN8@ChangePass
  0037c	c7 85 64 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00386	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0038c	89 85 68 fb ff
	ff		 mov	 DWORD PTR $T4[ebp+4], eax
  00392	8d 85 64 fb ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00398	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  0039d	50		 push	 eax
  0039e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN602@ChangePass:
$LN8@ChangePass:

; 2719 : 		finally_do ({ RandStop (FALSE); });
; 2720 : 
; 2721 : 		NormalCursor();

  003a3	e8 00 00 00 00	 call	 _NormalCursor

; 2722 : 		UserEnrichRandomPool (ParentWindow);

  003a8	ff 37		 push	 DWORD PTR [edi]
  003aa	e8 00 00 00 00	 call	 _UserEnrichRandomPool
  003af	83 c4 04	 add	 esp, 4

; 2723 : 		WaitCursor();

  003b2	e8 00 00 00 00	 call	 _WaitCursor

; 2724 : 
; 2725 : 		/**
; 2726 : 		 *
; 2727 : 		 *	The header will be re-encrypted PRAND_DISK_WIPE_PASSES times to prevent adversaries from using 
; 2728 : 		 *	techniques such as magnetic force microscopy or magnetic force scanning tunnelling microscopy
; 2729 : 		 *	to recover the overwritten header. According to Peter Gutmann, data should be overwritten 22
; 2730 : 		 *	times (ideally, 35 times) using non-random patterns and pseudorandom data. However, as users might
; 2731 : 		 *	impatiently interupt the process (etc.) we will not use the Gutmann's patterns but will write the
; 2732 : 		 *	valid re-encrypted header, i.e. pseudorandom data, and there will be many more passes than Guttman
; 2733 : 		 *	recommends. During each pass we will write a valid working header. Each pass will use the same master
; 2734 : 		 *	key, and also the same header key, secondary key (XTS), etc., derived from the new password. The only
; 2735 : 		 *	item that will be different for each pass will be the salt. This is sufficient to cause each "version"
; 2736 : 		 *	of the header to differ substantially and in a random manner from the versions written during the
; 2737 : 		 *	other passes. 
; 2738 : 		*
; 2739 : 		*/
; 2740 : 
; 2741 : 		bool headerUpdated = false;
; 2742 : 		int result = ERR_SUCCESS;
; 2743 : 
; 2744 : 		try
; 2745 : 		{
; 2746 : 			BOOL backupHeader = FALSE;

  003b7	8b 95 aa fd ff
	ff		 mov	 edx, DWORD PTR _encStatus$[ebp+78]
  003bd	32 c0		 xor	 al, al
  003bf	33 c9		 xor	 ecx, ecx
  003c1	88 85 d3 fb ff
	ff		 mov	 BYTE PTR _headerUpdated$[ebp], al
  003c7	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  003cb	89 8d c8 fb ff
	ff		 mov	 DWORD PTR _backupHeader$1$[ebp], ecx
$LL11@ChangePass:

; 2747 : 			while (TRUE)
; 2748 : 			{
; 2749 : 				for (int wipePass = 0; wipePass < PRAND_DISK_WIPE_PASSES; wipePass++)

  003d1	33 ff		 xor	 edi, edi
$LL15@ChangePass:
  003d3	81 ff 00 01 00
	00		 cmp	 edi, 256		; 00000100H
  003d9	0f 8d 13 02 00
	00		 jge	 $LN14@ChangePass

; 2750 : 				{
; 2751 : 					PCRYPTO_INFO tmpCryptoInfo = NULL;
; 2752 : 
; 2753 : 					status = CreateVolumeHeaderInMemory (!encStatus.HiddenSystem,

  003df	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  003e5	33 c0		 xor	 eax, eax
  003e7	c7 85 ac fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _tmpCryptoInfo$11[ebp], 0
  003f1	81 ff ff 00 00
	00		 cmp	 edi, 255		; 000000ffH
  003f7	0f 9c c0	 setl	 al
  003fa	50		 push	 eax
  003fb	ff b1 e8 1e 00
	00		 push	 DWORD PTR [ecx+7912]
  00401	8b 81 08 1f 00
	00		 mov	 eax, DWORD PTR [ecx+7944]
  00407	83 c8 01	 or	 eax, 1
  0040a	50		 push	 eax
  0040b	0f b7 81 e0 1e
	00 00		 movzx	 eax, WORD PTR [ecx+7904]
  00412	50		 push	 eax
  00413	ff b1 04 1f 00
	00		 push	 DWORD PTR [ecx+7940]
  00419	8d 85 ac fb ff
	ff		 lea	 eax, DWORD PTR _tmpCryptoInfo$11[ebp]
  0041f	ff b1 00 1f 00
	00		 push	 DWORD PTR [ecx+7936]
  00425	ff b1 fc 1e 00
	00		 push	 DWORD PTR [ecx+7932]
  0042b	ff b1 f8 1e 00
	00		 push	 DWORD PTR [ecx+7928]
  00431	ff b1 bc 1e 00
	00		 push	 DWORD PTR [ecx+7868]
  00437	ff b1 b8 1e 00
	00		 push	 DWORD PTR [ecx+7864]
  0043d	ff b1 f4 1e 00
	00		 push	 DWORD PTR [ecx+7924]
  00443	ff b1 f0 1e 00
	00		 push	 DWORD PTR [ecx+7920]
  00449	50		 push	 eax
  0044a	8d 81 50 1c 00
	00		 lea	 eax, DWORD PTR [ecx+7248]
  00450	50		 push	 eax
  00451	ff b1 94 1e 00
	00		 push	 DWORD PTR [ecx+7828]
  00457	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  0045d	ff b5 c4 fb ff
	ff		 push	 DWORD PTR _newPassword$GSCopy$1$[ebp]
  00463	ff 71 04	 push	 DWORD PTR [ecx+4]
  00466	ff 31		 push	 DWORD PTR [ecx]
  00468	50		 push	 eax
  00469	33 c0		 xor	 eax, eax
  0046b	85 d2		 test	 edx, edx
  0046d	0f 94 c0	 sete	 al
  00470	50		 push	 eax
  00471	e8 00 00 00 00	 call	 _CreateVolumeHeaderInMemory
  00476	8b f0		 mov	 esi, eax
  00478	83 c4 50	 add	 esp, 80			; 00000050H

; 2754 : 						header,
; 2755 : 						cryptoInfo->ea,
; 2756 : 						cryptoInfo->mode,
; 2757 : 						newPassword,
; 2758 : 						cryptoInfo->pkcs5,
; 2759 : 						(char *) cryptoInfo->master_keydata,
; 2760 : 						&tmpCryptoInfo,
; 2761 : 						cryptoInfo->VolumeSize.Value,
; 2762 : 						cryptoInfo->hiddenVolumeSize,
; 2763 : 						cryptoInfo->EncryptedAreaStart.Value,
; 2764 : 						cryptoInfo->EncryptedAreaLength.Value,
; 2765 : 						cryptoInfo->RequiredProgramVersion,
; 2766 : 						cryptoInfo->HeaderFlags | GST_HEADER_FLAG_ENCRYPTED_SYSTEM,
; 2767 : 						cryptoInfo->SectorSize,
; 2768 : 						wipePass < PRAND_DISK_WIPE_PASSES - 1);
; 2769 : 
; 2770 : 					if (tmpCryptoInfo)

  0047b	8b 85 ac fb ff
	ff		 mov	 eax, DWORD PTR _tmpCryptoInfo$11[ebp]
  00481	85 c0		 test	 eax, eax
  00483	74 09		 je	 SHORT $LN25@ChangePass

; 2771 : 						crypto_close (tmpCryptoInfo);

  00485	50		 push	 eax
  00486	e8 00 00 00 00	 call	 _crypto_close
  0048b	83 c4 04	 add	 esp, 4
$LN25@ChangePass:

; 2772 : 
; 2773 : 					if (status != 0)

  0048e	85 f6		 test	 esi, esi
  00490	0f 84 9d 00 00
	00		 je	 $LN26@ChangePass

; 2774 : 					{
; 2775 : 						handleError (ParentWindow, status);

  00496	8b 8d b4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0049c	56		 push	 esi
  0049d	ff 31		 push	 DWORD PTR [ecx]
  0049f	e8 00 00 00 00	 call	 _handleError
  004a4	83 c4 08	 add	 esp, 8

; 2776 : 						return status;

  004a7	8d 8d d3 fb ff
	ff		 lea	 ecx, DWORD PTR _finally2719$[ebp]
  004ad	e8 00 00 00 00	 call	 ??1Finally2719@?1??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ ; `GostCrypt::BootEncryption::ChangePassword'::`2'::Finally2719::~Finally2719
  004b2	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _finally2703$[ebp]
  004b8	e8 00 00 00 00	 call	 ??1Finally2703@?1??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ ; `GostCrypt::BootEncryption::ChangePassword'::`2'::Finally2703::~Finally2703
  004bd	80 bd bd fd ff
	ff 00		 cmp	 BYTE PTR _device$[ebp+1], 0
  004c4	74 1c		 je	 SHORT $LN306@ChangePass
  004c6	80 bd bc fd ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  004cd	75 0c		 jne	 SHORT $LN307@ChangePass
  004cf	ff b5 cc fd ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  004d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN307@ChangePass:
  004db	c6 85 bd fd ff
	ff 00		 mov	 BYTE PTR _device$[ebp+1], 0
$LN306@ChangePass:
  004e2	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _device$[ebp+44]
  004e8	83 f9 10	 cmp	 ecx, 16			; 00000010H
  004eb	0f 82 37 02 00
	00		 jb	 $LN538@ChangePass
  004f1	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _device$[ebp+24]
  004f7	41		 inc	 ecx
  004f8	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  004fe	72 2d		 jb	 SHORT $LN390@ChangePass
  00500	a8 1f		 test	 al, 31			; 0000001fH
  00502	74 05		 je	 SHORT $LN391@ChangePass
  00504	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN603@ChangePass:
$LN391@ChangePass:
  00509	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0050c	3b c8		 cmp	 ecx, eax
  0050e	72 05		 jb	 SHORT $LN392@ChangePass
  00510	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN604@ChangePass:
$LN392@ChangePass:
  00515	2b c1		 sub	 eax, ecx
  00517	83 f8 04	 cmp	 eax, 4
  0051a	73 05		 jae	 SHORT $LN393@ChangePass
  0051c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN605@ChangePass:
$LN393@ChangePass:
  00521	83 f8 23	 cmp	 eax, 35			; 00000023H
  00524	76 05		 jbe	 SHORT $LN394@ChangePass
  00526	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN606@ChangePass:
$LN394@ChangePass:
  0052b	8b c1		 mov	 eax, ecx
$LN390@ChangePass:
  0052d	50		 push	 eax
  0052e	e9 ed 01 00 00	 jmp	 $LN596@ChangePass
$LN26@ChangePass:

; 2777 : 					}
; 2778 : 
; 2779 : 					device.SeekAt (headerOffset);

  00533	80 bd bc fd ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  0053a	8b b5 cc fb ff
	ff		 mov	 esi, DWORD PTR _headerOffset$2$[ebp]
  00540	89 9d c4 fd ff
	ff		 mov	 DWORD PTR _device$[ebp+8], ebx
  00546	89 b5 c8 fd ff
	ff		 mov	 DWORD PTR _device$[ebp+12], esi
  0054c	75 3d		 jne	 SHORT $LN430@ChangePass
  0054e	6a 00		 push	 0
  00550	6a 00		 push	 0
  00552	56		 push	 esi
  00553	53		 push	 ebx
  00554	ff b5 cc fd ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  0055a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00560	85 c0		 test	 eax, eax
  00562	75 27		 jne	 SHORT $LN430@ChangePass
  00564	c7 85 5c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0056e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00574	89 85 60 fb ff
	ff		 mov	 DWORD PTR $T3[ebp+4], eax
  0057a	8d 85 5c fb ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00580	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00585	50		 push	 eax
  00586	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN607@ChangePass:
$LN430@ChangePass:

; 2780 : 					device.Write ((byte *) header, sizeof (header));

  0058b	68 00 02 00 00	 push	 512			; 00000200H
  00590	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _header$[ebp]
  00596	50		 push	 eax
  00597	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  0059d	e8 00 00 00 00	 call	 ?Write@File@GostCrypt@@QAEXPAEK@Z ; GostCrypt::File::Write
  005a2	8b 95 aa fd ff
	ff		 mov	 edx, DWORD PTR _encStatus$[ebp+78]

; 2781 : 					headerUpdated = true;

  005a8	b0 01		 mov	 al, 1
  005aa	88 85 d3 fb ff
	ff		 mov	 BYTE PTR _headerUpdated$[ebp], al
  005b0	47		 inc	 edi
  005b1	e9 1d fe ff ff	 jmp	 $LL15@ChangePass
__catch$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z$0:

; 2790 : 		}
; 2791 : 		catch (Exception &e)
; 2792 : 		{
; 2793 : 			e.Show (ParentWindow);

  005b6	8b 8d 58 fb ff
	ff		 mov	 ecx, DWORD PTR _e$2[ebp]
  005bc	8b 85 a4 fb ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  005c2	8b 11		 mov	 edx, DWORD PTR [ecx]
  005c4	ff 30		 push	 DWORD PTR [eax]
  005c6	ff 12		 call	 DWORD PTR [edx]

; 2794 : 			result = ERR_OS_ERROR;

  005c8	c7 85 c4 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _result$[ebp], 1

; 2795 : 		}

  005d2	b8 00 00 00 00	 mov	 eax, $LN43@ChangePass
  005d7	c3		 ret	 0
$LN43@ChangePass:
  005d8	8a 85 d3 fb ff
	ff		 mov	 al, BYTE PTR _headerUpdated$[ebp]
  005de	8b b5 c4 fb ff
	ff		 mov	 esi, DWORD PTR _result$[ebp]
  005e4	8b 8d a4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  005ea	8b 95 a8 fb ff
	ff		 mov	 edx, DWORD PTR _newPassword$GSCopy$[ebp]
  005f0	eb 3c		 jmp	 SHORT $LN597@ChangePass
$LN14@ChangePass:

; 2782 : 				}
; 2783 : 
; 2784 : 				if (!encStatus.HiddenSystem || backupHeader)

  005f2	85 d2		 test	 edx, edx
  005f4	74 2a		 je	 SHORT $LN28@ChangePass
  005f6	83 bd c8 fb ff
	ff 00		 cmp	 DWORD PTR _backupHeader$1$[ebp], 0
  005fd	75 21		 jne	 SHORT $LN28@ChangePass

; 2785 : 					break;
; 2786 : 
; 2787 : 				backupHeader = TRUE;
; 2788 : 				headerOffset = backupHeaderOffset;

  005ff	8b 8d b8 fb ff
	ff		 mov	 ecx, DWORD PTR _backupHeaderOffset$2$[ebp]
  00605	8b 9d bc fb ff
	ff		 mov	 ebx, DWORD PTR _backupHeaderOffset$1$[ebp]
  0060b	c7 85 c8 fb ff
	ff 01 00 00 00	 mov	 DWORD PTR _backupHeader$1$[ebp], 1
  00615	89 8d cc fb ff
	ff		 mov	 DWORD PTR _headerOffset$2$[ebp], ecx

; 2789 : 			}

  0061b	e9 b1 fd ff ff	 jmp	 $LL11@ChangePass
$LN28@ChangePass:
  00620	8b 8d b4 fb ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00626	33 f6		 xor	 esi, esi
  00628	8b 95 c4 fb ff
	ff		 mov	 edx, DWORD PTR _newPassword$GSCopy$1$[ebp]
$LN597@ChangePass:
  0062e	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4

; 2796 : 
; 2797 : 		if (headerUpdated)

  00635	84 c0		 test	 al, al
  00637	74 64		 je	 SHORT $LN29@ChangePass

; 2798 : 		{
; 2799 : 			ReopenBootVolumeHeaderRequest reopenRequest;
; 2800 : 			reopenRequest.VolumePassword = *newPassword;

  00639	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]

; 2801 : 			finally_do_arg (ReopenBootVolumeHeaderRequest*, &reopenRequest, { burn (finally_arg, sizeof (*finally_arg)); });

  0063c	8d 85 14 fd ff
	ff		 lea	 eax, DWORD PTR _reopenRequest$12[ebp]
  00642	89 85 a8 fb ff
	ff		 mov	 DWORD PTR _finally2801$10[ebp], eax
  00648	0f 11 85 14 fd
	ff ff		 movups	 XMMWORD PTR _reopenRequest$12[ebp], xmm0
  0064f	0f 10 42 10	 movups	 xmm0, XMMWORD PTR [edx+16]
  00653	0f 11 85 24 fd
	ff ff		 movups	 XMMWORD PTR _reopenRequest$12[ebp+16], xmm0
  0065a	0f 10 42 20	 movups	 xmm0, XMMWORD PTR [edx+32]
  0065e	0f 11 85 34 fd
	ff ff		 movups	 XMMWORD PTR _reopenRequest$12[ebp+32], xmm0
  00665	0f 10 42 30	 movups	 xmm0, XMMWORD PTR [edx+48]
  00669	0f 11 85 44 fd
	ff ff		 movups	 XMMWORD PTR _reopenRequest$12[ebp+48], xmm0
  00670	f3 0f 7e 42 40	 movq	 xmm0, QWORD PTR [edx+64]
  00675	66 0f d6 85 54
	fd ff ff	 movq	 QWORD PTR _reopenRequest$12[ebp+64], xmm0

; 2802 : 
; 2803 : 			CallDriver (GST_IOCTL_REOPEN_BOOT_VOLUME_HEADER, &reopenRequest, sizeof (reopenRequest));

  0067d	6a 00		 push	 0
  0067f	6a 00		 push	 0
  00681	6a 48		 push	 72			; 00000048H
  00683	50		 push	 eax
  00684	68 5c 20 22 00	 push	 2236508			; 0022205cH
  00689	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+12], 7
  0068d	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 2804 : 		}

  00692	8d 8d a8 fb ff
	ff		 lea	 ecx, DWORD PTR _finally2801$10[ebp]
  00698	e8 00 00 00 00	 call	 ??1Finally2801@?CL@??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ ; `GostCrypt::BootEncryption::ChangePassword'::`43'::Finally2801::~Finally2801
$LN29@ChangePass:

; 2805 : 
; 2806 : 		return result;

  0069d	8d 8d d3 fb ff
	ff		 lea	 ecx, DWORD PTR _finally2719$[ebp]
  006a3	e8 00 00 00 00	 call	 ??1Finally2719@?1??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ ; `GostCrypt::BootEncryption::ChangePassword'::`2'::Finally2719::~Finally2719
  006a8	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _finally2703$[ebp]
  006ae	e8 00 00 00 00	 call	 ??1Finally2703@?1??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ ; `GostCrypt::BootEncryption::ChangePassword'::`2'::Finally2703::~Finally2703
  006b3	80 bd bd fd ff
	ff 00		 cmp	 BYTE PTR _device$[ebp+1], 0
  006ba	74 1c		 je	 SHORT $LN449@ChangePass
  006bc	80 bd bc fd ff
	ff 00		 cmp	 BYTE PTR _device$[ebp], 0
  006c3	75 0c		 jne	 SHORT $LN450@ChangePass
  006c5	ff b5 cc fd ff
	ff		 push	 DWORD PTR _device$[ebp+16]
  006cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN450@ChangePass:
  006d1	c6 85 bd fd ff
	ff 00		 mov	 BYTE PTR _device$[ebp+1], 0
$LN449@ChangePass:
  006d8	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _device$[ebp+44]
  006de	83 f8 10	 cmp	 eax, 16			; 00000010H
  006e1	72 45		 jb	 SHORT $LN538@ChangePass
  006e3	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _device$[ebp+24]
  006e9	40		 inc	 eax
  006ea	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  006ef	72 2e		 jb	 SHORT $LN533@ChangePass
  006f1	f6 c1 1f	 test	 cl, 31			; 0000001fH
  006f4	74 05		 je	 SHORT $LN534@ChangePass
  006f6	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN608@ChangePass:
$LN534@ChangePass:
  006fb	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  006fe	3b c1		 cmp	 eax, ecx
  00700	72 05		 jb	 SHORT $LN535@ChangePass
  00702	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN609@ChangePass:
$LN535@ChangePass:
  00707	2b c8		 sub	 ecx, eax
  00709	83 f9 04	 cmp	 ecx, 4
  0070c	73 05		 jae	 SHORT $LN536@ChangePass
  0070e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN610@ChangePass:
$LN536@ChangePass:
  00713	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00716	76 05		 jbe	 SHORT $LN537@ChangePass
  00718	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN611@ChangePass:
$LN537@ChangePass:
  0071d	8b c8		 mov	 ecx, eax
$LN533@ChangePass:
  0071f	51		 push	 ecx
$LN596@ChangePass:
  00720	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00725	83 c4 04	 add	 esp, 4
$LN538@ChangePass:
  00728	c6 85 d4 fd ff
	ff 00		 mov	 BYTE PTR _device$[ebp+24], 0
  0072f	c7 85 e4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _device$[ebp+40], 0
  00739	c7 85 e8 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR _device$[ebp+44], 15 ; 0000000fH
$LN595@ChangePass:
  00743	8d 8d d4 fb ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp]
  00749	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
  0074e	8b c6		 mov	 eax, esi

; 2807 : 	}

  00750	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00753	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0075a	59		 pop	 ecx
  0075b	5f		 pop	 edi
  0075c	5e		 pop	 esi
  0075d	5b		 pop	 ebx
  0075e	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00761	33 cd		 xor	 ecx, ebp
  00763	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00768	8b e5		 mov	 esp, ebp
  0076a	5d		 pop	 ebp
  0076b	c2 0c 00	 ret	 12			; 0000000cH
$LN594@ChangePass:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z$2:
  00000	8d 8d d4 fb ff
	ff		 lea	 ecx, DWORD PTR _config$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
__unwindfunclet$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z$4:
  0000b	8d 8d bc fd ff
	ff		 lea	 ecx, DWORD PTR _device$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1Device@GostCrypt@@QAE@XZ
__unwindfunclet$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z$5:
  00016	8d 8d 8c fb ff
	ff		 lea	 ecx, DWORD PTR _$S7$9[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$ContainerForward@V?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@ForEach@GostCrypt@@UAE@XZ
__unwindfunclet$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z$6:
  00021	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _finally2703$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1Finally2703@?1??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ ; `GostCrypt::BootEncryption::ChangePassword'::`2'::Finally2703::~Finally2703
__unwindfunclet$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z$7:
  0002c	8d 8d d3 fb ff
	ff		 lea	 ecx, DWORD PTR _finally2719$[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1Finally2719@?1??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ ; `GostCrypt::BootEncryption::ChangePassword'::`2'::Finally2719::~Finally2719
__unwindfunclet$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z$8:
  00037	8d 8d a8 fb ff
	ff		 lea	 ecx, DWORD PTR _finally2801$10[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1Finally2801@?CL@??ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z@QAE@XZ ; `GostCrypt::BootEncryption::ChangePassword'::`43'::Finally2801::~Finally2801
__ehhandler$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z:
  00042	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00046	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00049	8b 8a 54 fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1196]
  0004f	33 c8		 xor	 ecx, eax
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00059	33 c8		 xor	 ecx, eax
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z
  00065	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ChangePassword@BootEncryption@GostCrypt@@QAEHPAUPassword@@0H@Z ENDP ; GostCrypt::BootEncryption::ChangePassword
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z
_TEXT	SEGMENT
$T2 = -28						; size = 8
_bytesReturned$3 = -20					; size = 4
__$EHRec$ = -16						; size = 16
_ioctl$ = 8						; size = 4
_input$ = 12						; size = 4
_inputSize$ = 16					; size = 4
_output$ = 20						; size = 4
_outputSize$ = 24					; size = 4
?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z PROC ; GostCrypt::BootEncryption::CallDriver, COMDAT
; _this$ = ecx

; 606  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 607  : 		try
; 608  : 		{
; 609  : 			DWORD bytesReturned;
; 610  : 			throw_sys_if (!DeviceIoControl (hDriver, ioctl, input, inputSize, output, outputSize, &bytesReturned, NULL));

  0002b	6a 00		 push	 0
  0002d	8d 45 ec	 lea	 eax, DWORD PTR _bytesReturned$3[ebp]
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00037	50		 push	 eax
  00038	ff 75 18	 push	 DWORD PTR _outputSize$[ebp]
  0003b	ff 75 14	 push	 DWORD PTR _output$[ebp]
  0003e	ff 75 10	 push	 DWORD PTR _inputSize$[ebp]
  00041	ff 75 0c	 push	 DWORD PTR _input$[ebp]
  00044	ff 75 08	 push	 DWORD PTR _ioctl$[ebp]
  00047	ff 35 00 00 00
	00		 push	 DWORD PTR _hDriver
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  00053	85 c0		 test	 eax, eax
  00055	75 4f		 jne	 SHORT $LN2@CallDriver
  00057	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00064	89 45 e8	 mov	 DWORD PTR $T2[ebp+4], eax
  00067	8d 45 e4	 lea	 eax, DWORD PTR $T2[ebp]
  0006a	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN21@CallDriver:
__catch$?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z$0:

; 611  : 		}
; 612  : 		catch (SystemException &)
; 613  : 		{
; 614  : 			if (GetLastError() == ERROR_ACCESS_DENIED && IsUacSupported())

  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0007b	83 f8 05	 cmp	 eax, 5
  0007e	75 3a		 jne	 SHORT $LN7@CallDriver
  00080	e8 00 00 00 00	 call	 _IsUacSupported
  00085	85 c0		 test	 eax, eax
  00087	74 31		 je	 SHORT $LN7@CallDriver

; 615  : 				Elevator::CallDriver (ioctl, input, inputSize, output, outputSize);

  00089	ff 75 18	 push	 DWORD PTR _outputSize$[ebp]
  0008c	ff 75 14	 push	 DWORD PTR _output$[ebp]
  0008f	ff 75 10	 push	 DWORD PTR _inputSize$[ebp]
  00092	ff 75 0c	 push	 DWORD PTR _input$[ebp]
  00095	ff 75 08	 push	 DWORD PTR _ioctl$[ebp]
  00098	e8 00 00 00 00	 call	 ?CallDriver@Elevator@GostCrypt@@SAXKPAXK0K@Z ; GostCrypt::Elevator::CallDriver
  0009d	83 c4 14	 add	 esp, 20			; 00000014H

; 618  : 		}

  000a0	b8 00 00 00 00	 mov	 eax, $LN2@CallDriver
  000a5	c3		 ret	 0
$LN2@CallDriver:

; 619  : 	}

  000a6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000a9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b0	59		 pop	 ecx
  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 14 00	 ret	 20			; 00000014H
$LN7@CallDriver:

; 616  : 			else
; 617  : 				throw;

  000ba	6a 00		 push	 0
  000bc	6a 00		 push	 0
  000be	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN22@CallDriver:
$LN20@CallDriver:
  000c3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ENDP ; GostCrypt::BootEncryption::CallDriver
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?AbortSetupWait@BootEncryption@GostCrypt@@QAEXXZ
_TEXT	SEGMENT
$T1 = -196						; size = 94
_encStatus$ = -100					; size = 94
__$ArrayPad$ = -4					; size = 4
?AbortSetupWait@BootEncryption@GostCrypt@@QAEXXZ PROC	; GostCrypt::BootEncryption::AbortSetupWait, COMDAT
; _this$ = ecx

; 2143 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx

; 2144 : 		CallDriver (GST_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP);

  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	68 50 20 22 00	 push	 2236496			; 00222050H
  00021	8b d9		 mov	 ebx, ecx
  00023	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 2145 : 
; 2146 : 		BootEncryptionStatus encStatus = GetStatus();

  00028	6a 5e		 push	 94			; 0000005eH
  0002a	8d 45 9c	 lea	 eax, DWORD PTR _encStatus$[ebp]
  0002d	8b cb		 mov	 ecx, ebx
  0002f	50		 push	 eax
  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	68 48 20 22 00	 push	 2236488			; 00222048H
  00039	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 2147 : 
; 2148 : 		while (encStatus.SetupInProgress)

  0003e	83 7d da 00	 cmp	 DWORD PTR _encStatus$[ebp+62], 0
  00042	74 40		 je	 SHORT $LN3@AbortSetup
  00044	56		 push	 esi
  00045	57		 push	 edi
$LL2@AbortSetup:

; 2149 : 		{
; 2150 : 			Sleep (GST_ABORT_TRANSFORM_WAIT_INTERVAL);

  00046	6a 0a		 push	 10			; 0000000aH
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 2151 : 			encStatus = GetStatus();

  0004e	6a 5e		 push	 94			; 0000005eH
  00050	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00056	8b cb		 mov	 ecx, ebx
  00058	50		 push	 eax
  00059	6a 00		 push	 0
  0005b	6a 00		 push	 0
  0005d	68 48 20 22 00	 push	 2236488			; 00222048H
  00062	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver
  00067	83 bd 7a ff ff
	ff 00		 cmp	 DWORD PTR $T1[ebp+62], 0
  0006e	8d b5 3c ff ff
	ff		 lea	 esi, DWORD PTR $T1[ebp]
  00074	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00079	8d 7d 9c	 lea	 edi, DWORD PTR _encStatus$[ebp]
  0007c	f3 a5		 rep movsd
  0007e	66 a5		 movsw
  00080	75 c4		 jne	 SHORT $LL2@AbortSetup
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
$LN3@AbortSetup:

; 2152 : 		}
; 2153 : 	}

  00084	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00087	33 cd		 xor	 ecx, ebp
  00089	5b		 pop	 ebx
  0008a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
?AbortSetupWait@BootEncryption@GostCrypt@@QAEXXZ ENDP	; GostCrypt::BootEncryption::AbortSetupWait
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?AbortSetup@BootEncryption@GostCrypt@@QAEXXZ
_TEXT	SEGMENT
?AbortSetup@BootEncryption@GostCrypt@@QAEXXZ PROC	; GostCrypt::BootEncryption::AbortSetup, COMDAT
; _this$ = ecx

; 2131 : 		CallDriver (GST_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP);

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	6a 00		 push	 0
  00006	6a 00		 push	 0
  00008	68 50 20 22 00	 push	 2236496			; 00222050H
  0000d	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 2132 : 	}

  00012	c3		 ret	 0
?AbortSetup@BootEncryption@GostCrypt@@QAEXXZ ENDP	; GostCrypt::BootEncryption::AbortSetup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?AbortDecoyOSWipe@BootEncryption@GostCrypt@@QAEXXZ
_TEXT	SEGMENT
?AbortDecoyOSWipe@BootEncryption@GostCrypt@@QAEXXZ PROC	; GostCrypt::BootEncryption::AbortDecoyOSWipe, COMDAT
; _this$ = ecx

; 1671 : 		CallDriver (GST_IOCTL_ABORT_DECOY_SYSTEM_WIPE);

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	6a 00		 push	 0
  00006	6a 00		 push	 0
  00008	68 7c 20 22 00	 push	 2236540			; 0022207cH
  0000d	e8 00 00 00 00	 call	 ?CallDriver@BootEncryption@GostCrypt@@QAEXKPAXK0K@Z ; GostCrypt::BootEncryption::CallDriver

; 1672 : 	}

  00012	c3		 ret	 0
?AbortDecoyOSWipe@BootEncryption@GostCrypt@@QAEXXZ ENDP	; GostCrypt::BootEncryption::AbortDecoyOSWipe
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??1BootEncryption@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1BootEncryption@GostCrypt@@QAE@XZ PROC		; GostCrypt::BootEncryption::~BootEncryption, COMDAT
; _this$ = ecx

; 585  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1BootEncryption@GostCrypt@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 586  : 		if (RescueIsoImage)

  00025	8b 86 c0 01 00
	00		 mov	 eax, DWORD PTR [esi+448]
  0002b	85 c0		 test	 eax, eax
  0002d	74 09		 je	 SHORT $LN2@BootEncryp

; 587  : 			delete[] RescueIsoImage;

  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00035	83 c4 04	 add	 esp, 4
$LN2@BootEncryp:

; 588  : 
; 589  : 		Elevator::Release();

  00038	83 2d 00 00 00
	00 01		 sub	 DWORD PTR ?ReferenceCount@Elevator@GostCrypt@@1HA, 1 ; GostCrypt::Elevator::ReferenceCount
  0003f	75 20		 jne	 SHORT $LN5@BootEncryp
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A ; GostCrypt::Elevator::ElevatedComInstance
  00047	85 c9		 test	 ecx, ecx
  00049	74 16		 je	 SHORT $LN5@BootEncryp
  0004b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004d	51		 push	 ecx
  0004e	ff 50 08	 call	 DWORD PTR [eax+8]
  00051	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ElevatedComInstance@Elevator@GostCrypt@@1PAUIGostCryptMainCom@@A, 0 ; GostCrypt::Elevator::ElevatedComInstance
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0
$LN5@BootEncryp:

; 590  : 	}

  00061	8d 8e 50 01 00
	00		 lea	 ecx, DWORD PTR [esi+336]
  00067	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  0006c	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0006f	e8 00 00 00 00	 call	 ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
  00074	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00077	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007e	59		 pop	 ecx
  0007f	5e		 pop	 esi
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1BootEncryption@GostCrypt@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1BootEncryption@GostCrypt@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1BootEncryption@GostCrypt@@QAE@XZ ENDP		; GostCrypt::BootEncryption::~BootEncryption
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_parent$ = 8						; size = 4
??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z PROC	; GostCrypt::BootEncryption::BootEncryption, COMDAT
; _this$ = ecx

; 574  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 568  : 		ParentWindow (parent),

  00004	8b 45 08	 mov	 eax, DWORD PTR _parent$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi

; 574  : 	{

  0000d	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00010	89 06		 mov	 DWORD PTR [esi], eax
  00012	e8 00 00 00 00	 call	 ??0SystemDriveConfiguration@GostCrypt@@QAE@XZ

; 571  : 		RescueVolumeHeaderValid (false),
; 572  : 		SelectedEncryptionAlgorithmId (0),

  00017	c7 86 48 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+328], 0

; 574  : 	{

  00021	33 c0		 xor	 eax, eax
  00023	c7 86 64 01 00
	00 0f 00 00 00	 mov	 DWORD PTR [esi+356], 15	; 0000000fH
  0002d	c7 86 60 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+352], 0
  00037	c6 86 50 01 00
	00 00		 mov	 BYTE PTR [esi+336], 0
  0003e	c7 86 9c 01 00
	00 0f 00 00 00	 mov	 DWORD PTR [esi+412], 15	; 0000000fH
  00048	c7 86 98 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+408], 0
  00052	c6 86 88 01 00
	00 00		 mov	 BYTE PTR [esi+392], 0
  00059	c7 86 bc 01 00
	00 07 00 00 00	 mov	 DWORD PTR [esi+444], 7
  00063	c7 86 b8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+440], 0
  0006d	66 89 86 a8 01
	00 00		 mov	 WORD PTR [esi+424], ax

; 569  : 		RealSystemDriveSizeValid (false),
; 570  : 		RescueIsoImage (nullptr),

  00074	89 86 c0 01 00
	00		 mov	 DWORD PTR [esi+448], eax

; 567  : 		: DriveConfigValid (false),

  0007a	89 86 c4 05 00
	00		 mov	 DWORD PTR [esi+1476], eax

; 575  : 		Elevator::AddReference();
; 576  : 	}

  00080	8b c6		 mov	 eax, esi
  00082	ff 05 00 00 00
	00		 inc	 DWORD PTR ?ReferenceCount@Elevator@GostCrypt@@1HA ; GostCrypt::Elevator::ReferenceCount
  00088	5e		 pop	 esi
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z ENDP	; GostCrypt::BootEncryption::BootEncryption
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4SystemDriveConfiguration@GostCrypt@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4SystemDriveConfiguration@GostCrypt@@QAEAAU01@ABU01@@Z PROC ; GostCrypt::SystemDriveConfiguration::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 0a		 je	 SHORT $LN4@operator
  0000f	6a ff		 push	 -1
  00011	6a 00		 push	 0
  00013	57		 push	 edi
  00014	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN4@operator:
  00019	8d 47 18	 lea	 eax, DWORD PTR [edi+24]
  0001c	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  0001f	3b c8		 cmp	 ecx, eax
  00021	74 0a		 je	 SHORT $LN135@operator
  00023	6a ff		 push	 -1
  00025	6a 00		 push	 0
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN135@operator:
  0002d	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  00030	8d 5f 38	 lea	 ebx, DWORD PTR [edi+56]
  00033	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  00036	89 46 30	 mov	 DWORD PTR [esi+48], eax
  00039	3b cb		 cmp	 ecx, ebx
  0003b	74 0d		 je	 SHORT $LN268@operator
  0003d	6a ff		 push	 -1
  0003f	6a 00		 push	 0
  00041	53		 push	 ebx
  00042	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00047	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
$LN268@operator:
  0004a	0f 10 43 18	 movups	 xmm0, XMMWORD PTR [ebx+24]
  0004e	8d 43 38	 lea	 eax, DWORD PTR [ebx+56]
  00051	8d 51 38	 lea	 edx, DWORD PTR [ecx+56]
  00054	0f 11 41 18	 movups	 XMMWORD PTR [ecx+24], xmm0
  00058	0f 10 43 28	 movups	 xmm0, XMMWORD PTR [ebx+40]
  0005c	0f 11 41 28	 movups	 XMMWORD PTR [ecx+40], xmm0
  00060	3b d0		 cmp	 edx, eax
  00062	74 0f		 je	 SHORT $LN399@operator
  00064	6a ff		 push	 -1
  00066	6a 00		 push	 0
  00068	50		 push	 eax
  00069	8b ca		 mov	 ecx, edx
  0006b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00070	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
$LN399@operator:
  00073	8b 43 50	 mov	 eax, DWORD PTR [ebx+80]
  00076	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00079	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  0007c	83 c3 58	 add	 ebx, 88			; 00000058H
  0007f	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  00082	83 c1 58	 add	 ecx, 88			; 00000058H
  00085	3b cb		 cmp	 ecx, ebx
  00087	74 0a		 je	 SHORT $LN530@operator
  00089	6a ff		 push	 -1
  0008b	6a 00		 push	 0
  0008d	53		 push	 ebx
  0008e	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN530@operator:
  00093	8a 87 a8 00 00
	00		 mov	 al, BYTE PTR [edi+168]
  00099	8d 8e b8 00 00
	00		 lea	 ecx, DWORD PTR [esi+184]
  0009f	88 86 a8 00 00
	00		 mov	 BYTE PTR [esi+168], al
  000a5	8b 87 b0 00 00
	00		 mov	 eax, DWORD PTR [edi+176]
  000ab	89 86 b0 00 00
	00		 mov	 DWORD PTR [esi+176], eax
  000b1	8b 87 b4 00 00
	00		 mov	 eax, DWORD PTR [edi+180]
  000b7	89 86 b4 00 00
	00		 mov	 DWORD PTR [esi+180], eax
  000bd	8d 87 b8 00 00
	00		 lea	 eax, DWORD PTR [edi+184]
  000c3	3b c8		 cmp	 ecx, eax
  000c5	74 0a		 je	 SHORT $LN663@operator
  000c7	8b 00		 mov	 eax, DWORD PTR [eax]
  000c9	50		 push	 eax
  000ca	ff 30		 push	 DWORD PTR [eax]
  000cc	e8 00 00 00 00	 call	 ??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::assign<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > > >
$LN663@operator:
  000d1	8d 9f c0 00 00
	00		 lea	 ebx, DWORD PTR [edi+192]
  000d7	8d 8e c0 00 00
	00		 lea	 ecx, DWORD PTR [esi+192]
  000dd	3b cb		 cmp	 ecx, ebx
  000df	74 10		 je	 SHORT $LN748@operator
  000e1	6a ff		 push	 -1
  000e3	6a 00		 push	 0
  000e5	53		 push	 ebx
  000e6	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000eb	8d 8e c0 00 00
	00		 lea	 ecx, DWORD PTR [esi+192]
$LN748@operator:
  000f1	0f 10 43 18	 movups	 xmm0, XMMWORD PTR [ebx+24]
  000f5	8d 43 38	 lea	 eax, DWORD PTR [ebx+56]
  000f8	8d 51 38	 lea	 edx, DWORD PTR [ecx+56]
  000fb	0f 11 41 18	 movups	 XMMWORD PTR [ecx+24], xmm0
  000ff	0f 10 43 28	 movups	 xmm0, XMMWORD PTR [ebx+40]
  00103	0f 11 41 28	 movups	 XMMWORD PTR [ecx+40], xmm0
  00107	3b d0		 cmp	 edx, eax
  00109	74 12		 je	 SHORT $LN879@operator
  0010b	6a ff		 push	 -1
  0010d	6a 00		 push	 0
  0010f	50		 push	 eax
  00110	8b ca		 mov	 ecx, edx
  00112	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00117	8d 8e c0 00 00
	00		 lea	 ecx, DWORD PTR [esi+192]
$LN879@operator:
  0011d	8b 43 50	 mov	 eax, DWORD PTR [ebx+80]
  00120	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00123	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  00126	83 c3 58	 add	 ebx, 88			; 00000058H
  00129	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  0012c	83 c1 58	 add	 ecx, 88			; 00000058H
  0012f	3b cb		 cmp	 ecx, ebx
  00131	74 0a		 je	 SHORT $LN1010@operator
  00133	6a ff		 push	 -1
  00135	6a 00		 push	 0
  00137	53		 push	 ebx
  00138	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN1010@operator:
  0013d	8b 87 30 01 00
	00		 mov	 eax, DWORD PTR [edi+304]
  00143	89 86 30 01 00
	00		 mov	 DWORD PTR [esi+304], eax
  00149	8b 87 34 01 00
	00		 mov	 eax, DWORD PTR [edi+308]
  0014f	89 86 34 01 00
	00		 mov	 DWORD PTR [esi+308], eax
  00155	8a 87 38 01 00
	00		 mov	 al, BYTE PTR [edi+312]
  0015b	88 86 38 01 00
	00		 mov	 BYTE PTR [esi+312], al
  00161	8b c6		 mov	 eax, esi
  00163	5f		 pop	 edi
  00164	5e		 pop	 esi
  00165	5b		 pop	 ebx
  00166	5d		 pop	 ebp
  00167	c2 04 00	 ret	 4
??4SystemDriveConfiguration@GostCrypt@@QAEAAU01@ABU01@@Z ENDP ; GostCrypt::SystemDriveConfiguration::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z PROC ; GostCrypt::SystemDriveConfiguration::SystemDriveConfiguration, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00031	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00038	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0003f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00043	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004a	72 04		 jb	 SHORT $LN126@SystemDriv
  0004c	8b 06		 mov	 eax, DWORD PTR [esi]
  0004e	eb 02		 jmp	 SHORT $LN127@SystemDriv
$LN126@SystemDriv:
  00050	8b c6		 mov	 eax, esi
$LN127@SystemDriv:
  00052	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00055	6a ff		 push	 -1
  00057	6a 00		 push	 0
  00059	57		 push	 edi
  0005a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0005d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00062	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00065	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006c	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00073	8d 57 18	 lea	 edx, DWORD PTR [edi+24]
  00076	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0007d	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00081	72 04		 jb	 SHORT $LN251@SystemDriv
  00083	8b 01		 mov	 eax, DWORD PTR [ecx]
  00085	eb 02		 jmp	 SHORT $LN252@SystemDriv
$LN251@SystemDriv:
  00087	8b c1		 mov	 eax, ecx
$LN252@SystemDriv:
  00089	6a ff		 push	 -1
  0008b	6a 00		 push	 0
  0008d	52		 push	 edx
  0008e	c6 00 00	 mov	 BYTE PTR [eax], 0
  00091	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00096	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  00099	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  0009c	89 46 30	 mov	 DWORD PTR [esi+48], eax
  0009f	8d 47 38	 lea	 eax, DWORD PTR [edi+56]
  000a2	50		 push	 eax
  000a3	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000a7	e8 00 00 00 00	 call	 ??0Partition@GostCrypt@@QAE@ABU01@@Z
  000ac	0f b6 87 a8 00
	00 00		 movzx	 eax, BYTE PTR [edi+168]
  000b3	8d 8e b8 00 00
	00		 lea	 ecx, DWORD PTR [esi+184]
  000b9	88 86 a8 00 00
	00		 mov	 BYTE PTR [esi+168], al
  000bf	8b 87 b0 00 00
	00		 mov	 eax, DWORD PTR [edi+176]
  000c5	89 86 b0 00 00
	00		 mov	 DWORD PTR [esi+176], eax
  000cb	8b 87 b4 00 00
	00		 mov	 eax, DWORD PTR [edi+180]
  000d1	89 86 b4 00 00
	00		 mov	 DWORD PTR [esi+180], eax
  000d7	8d 87 b8 00 00
	00		 lea	 eax, DWORD PTR [edi+184]
  000dd	50		 push	 eax
  000de	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000e2	e8 00 00 00 00	 call	 ??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
  000e7	8d 87 c0 00 00
	00		 lea	 eax, DWORD PTR [edi+192]
  000ed	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000f1	50		 push	 eax
  000f2	8d 8e c0 00 00
	00		 lea	 ecx, DWORD PTR [esi+192]
  000f8	e8 00 00 00 00	 call	 ??0Partition@GostCrypt@@QAE@ABU01@@Z
  000fd	8b 87 30 01 00
	00		 mov	 eax, DWORD PTR [edi+304]
  00103	89 86 30 01 00
	00		 mov	 DWORD PTR [esi+304], eax
  00109	8b 87 34 01 00
	00		 mov	 eax, DWORD PTR [edi+308]
  0010f	89 86 34 01 00
	00		 mov	 DWORD PTR [esi+308], eax
  00115	0f b6 87 38 01
	00 00		 movzx	 eax, BYTE PTR [edi+312]
  0011c	88 86 38 01 00
	00		 mov	 BYTE PTR [esi+312], al
  00122	8b c6		 mov	 eax, esi
  00124	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00127	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012e	59		 pop	 ecx
  0012f	5f		 pop	 edi
  00130	5e		 pop	 esi
  00131	8b e5		 mov	 esp, ebp
  00133	5d		 pop	 ebp
  00134	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 18	 add	 ecx, 24			; 00000018H
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 38	 add	 ecx, 56			; 00000038H
  00019	e9 00 00 00 00	 jmp	 ??1Partition@GostCrypt@@QAE@XZ
__unwindfunclet$??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00027	e9 00 00 00 00	 jmp	 ??1?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::~list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
__ehhandler$??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z
  00042	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SystemDriveConfiguration@GostCrypt@@QAE@ABU01@@Z ENDP ; GostCrypt::SystemDriveConfiguration::SystemDriveConfiguration
; Function compile flags: /Ogtp
;	COMDAT ??1SystemDriveConfiguration@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??1SystemDriveConfiguration@GostCrypt@@QAE@XZ PROC	; GostCrypt::SystemDriveConfiguration::~SystemDriveConfiguration, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
  00004	8d 8f c0 00 00
	00		 lea	 ecx, DWORD PTR [edi+192]
  0000a	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  0000f	8d 8f b8 00 00
	00		 lea	 ecx, DWORD PTR [edi+184]
  00015	e8 00 00 00 00	 call	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear
  0001a	ff b7 b8 00 00
	00		 push	 DWORD PTR [edi+184]
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
  00028	8d 4f 38	 lea	 ecx, DWORD PTR [edi+56]
  0002b	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  00030	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00033	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  00036	83 f8 10	 cmp	 eax, 16			; 00000010H
  00039	72 0b		 jb	 SHORT $LN82@SystemDriv
  0003b	40		 inc	 eax
  0003c	8b ce		 mov	 ecx, esi
  0003e	50		 push	 eax
  0003f	ff 36		 push	 DWORD PTR [esi]
  00041	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN82@SystemDriv:
  00046	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0004d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00051	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00058	72 02		 jb	 SHORT $LN170@SystemDriv
  0005a	8b 36		 mov	 esi, DWORD PTR [esi]
$LN170@SystemDriv:
  0005c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0005f	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00062	83 f8 10	 cmp	 eax, 16			; 00000010H
  00065	72 0b		 jb	 SHORT $LN183@SystemDriv
  00067	40		 inc	 eax
  00068	8b cf		 mov	 ecx, edi
  0006a	50		 push	 eax
  0006b	ff 37		 push	 DWORD PTR [edi]
  0006d	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN183@SystemDriv:
  00072	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
  00079	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  0007d	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00084	72 08		 jb	 SHORT $LN271@SystemDriv
  00086	8b 07		 mov	 eax, DWORD PTR [edi]
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0008d	c3		 ret	 0
$LN271@SystemDriv:
  0008e	c6 07 00	 mov	 BYTE PTR [edi], 0
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	c3		 ret	 0
??1SystemDriveConfiguration@GostCrypt@@QAE@XZ ENDP	; GostCrypt::SystemDriveConfiguration::~SystemDriveConfiguration
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SystemDriveConfiguration@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0SystemDriveConfiguration@GostCrypt@@QAE@XZ PROC	; GostCrypt::SystemDriveConfiguration::SystemDriveConfiguration, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SystemDriveConfiguration@GostCrypt@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002c	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00033	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
  0003a	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
  00041	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00045	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  0004c	72 04		 jb	 SHORT $LN108@SystemDriv
  0004e	8b 07		 mov	 eax, DWORD PTR [edi]
  00050	eb 02		 jmp	 SHORT $LN109@SystemDriv
$LN108@SystemDriv:
  00052	8b c7		 mov	 eax, edi
$LN109@SystemDriv:
  00054	c6 00 00	 mov	 BYTE PTR [eax], 0
  00057	8d 47 18	 lea	 eax, DWORD PTR [edi+24]
  0005a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00061	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
  00068	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  0006f	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00073	72 02		 jb	 SHORT $LN216@SystemDriv
  00075	8b 00		 mov	 eax, DWORD PTR [eax]
$LN216@SystemDriv:
  00077	c6 00 00	 mov	 BYTE PTR [eax], 0
  0007a	8d 47 38	 lea	 eax, DWORD PTR [edi+56]
  0007d	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
  00084	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  0008b	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0008f	72 04		 jb	 SHORT $LN325@SystemDriv
  00091	8b 08		 mov	 ecx, DWORD PTR [eax]
  00093	eb 02		 jmp	 SHORT $LN326@SystemDriv
$LN325@SystemDriv:
  00095	8b c8		 mov	 ecx, eax
$LN326@SystemDriv:
  00097	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0009a	8d 48 38	 lea	 ecx, DWORD PTR [eax+56]
  0009d	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  000a4	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  000ab	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  000af	72 02		 jb	 SHORT $LN433@SystemDriv
  000b1	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN433@SystemDriv:
  000b3	83 c0 58	 add	 eax, 88			; 00000058H
  000b6	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000b9	c7 40 14 07 00
	00 00		 mov	 DWORD PTR [eax+20], 7
  000c0	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  000c7	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  000cb	72 02		 jb	 SHORT $LN542@SystemDriv
  000cd	8b 00		 mov	 eax, DWORD PTR [eax]
$LN542@SystemDriv:
  000cf	33 c9		 xor	 ecx, ecx
  000d1	66 89 08	 mov	 WORD PTR [eax], cx
  000d4	8d b7 b8 00 00
	00		 lea	 esi, DWORD PTR [edi+184]
  000da	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000de	89 0e		 mov	 DWORD PTR [esi], ecx
  000e0	51		 push	 ecx
  000e1	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  000e4	51		 push	 ecx
  000e5	8b ce		 mov	 ecx, esi
  000e7	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
  000ea	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Buynode0
  000ef	89 06		 mov	 DWORD PTR [esi], eax
  000f1	33 c0		 xor	 eax, eax
  000f3	c7 87 d4 00 00
	00 0f 00 00 00	 mov	 DWORD PTR [edi+212], 15	; 0000000fH
  000fd	c7 87 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+208], 0
  00107	c6 87 c0 00 00
	00 00		 mov	 BYTE PTR [edi+192], 0
  0010e	c7 87 0c 01 00
	00 0f 00 00 00	 mov	 DWORD PTR [edi+268], 15	; 0000000fH
  00118	c7 87 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+264], 0
  00122	c6 87 f8 00 00
	00 00		 mov	 BYTE PTR [edi+248], 0
  00129	c7 87 2c 01 00
	00 07 00 00 00	 mov	 DWORD PTR [edi+300], 7
  00133	c7 87 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+296], 0
  0013d	66 89 87 18 01
	00 00		 mov	 WORD PTR [edi+280], ax
  00144	8b c7		 mov	 eax, edi
  00146	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00149	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00150	59		 pop	 ecx
  00151	5f		 pop	 edi
  00152	5e		 pop	 esi
  00153	8b e5		 mov	 esp, ebp
  00155	5d		 pop	 ebp
  00156	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SystemDriveConfiguration@GostCrypt@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0SystemDriveConfiguration@GostCrypt@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 18	 add	 ecx, 24			; 00000018H
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0SystemDriveConfiguration@GostCrypt@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 38	 add	 ecx, 56			; 00000038H
  00019	e9 00 00 00 00	 jmp	 ??1Partition@GostCrypt@@QAE@XZ
__ehhandler$??0SystemDriveConfiguration@GostCrypt@@QAE@XZ:
  0001e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00022	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00025	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00028	33 c8		 xor	 ecx, eax
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SystemDriveConfiguration@GostCrypt@@QAE@XZ
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SystemDriveConfiguration@GostCrypt@@QAE@XZ ENDP	; GostCrypt::SystemDriveConfiguration::SystemDriveConfiguration
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Incsize@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Incsize@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXI@Z PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Incsize, COMDAT
; _this$ = ecx

; 1906 : 		{	// alter element count, with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1907 : 		if (max_size() - this->_Mysize() - 1 < _Count)

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	b8 21 22 22 02	 mov	 eax, 35791393		; 02222221H
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  0000f	2b c2		 sub	 eax, edx
  00011	3b c6		 cmp	 eax, esi
  00013	72 0b		 jb	 SHORT $LN41@Incsize

; 1909 : 		this->_Mysize() += _Count;

  00015	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  00018	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0001b	5e		 pop	 esi

; 1910 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
$LN41@Incsize:

; 1908 : 			_Xlength_error("list<T> too long");

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00025	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN43@Incsize:
$LN40@Incsize:
  0002a	cc		 int	 3
?_Incsize@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXI@Z ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Incsize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Tidy@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Tidy, COMDAT
; _this$ = ecx

; 1884 : 		clear();

  00000	e9 00 00 00 00	 jmp	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear
?_Tidy@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear, COMDAT
; _this$ = ecx

; 1500 : 		{	// erase all

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi

; 1501 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1502 : 
; 1503 : 		this->_Orphan_ptr(nullptr);
; 1504 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1505 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

  00004	8b 03		 mov	 eax, DWORD PTR [ebx]
  00006	8b 30		 mov	 esi, DWORD PTR [eax]

; 1506 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

  00008	89 00		 mov	 DWORD PTR [eax], eax

; 1507 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

  0000a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0000c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1508 : 		this->_Mysize() = 0;

  0000f	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1509 : 
; 1510 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

  00016	3b 33		 cmp	 esi, DWORD PTR [ebx]
  00018	74 20		 je	 SHORT $LN3@clear
  0001a	57		 push	 edi
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@clear:

; 1511 : 			{	// delete an element
; 1512 : 			_Pnext = this->_Nextnode(_Pnode);

  00020	8b 3e		 mov	 edi, DWORD PTR [esi]

; 1513 : 			this->_Freenode(_Pnode);

  00022	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00025	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00030	83 c4 04	 add	 esp, 4
  00033	8b f7		 mov	 esi, edi
  00035	3b 3b		 cmp	 edi, DWORD PTR [ebx]
  00037	75 e7		 jne	 SHORT $LL4@clear
  00039	5f		 pop	 edi
$LN3@clear:
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx

; 1514 : 			}
; 1515 : 		}

  0003c	c3		 ret	 0
?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?erase@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@0@Z PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::erase, COMDAT
; _this$ = ecx

; 1485 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1486 : 		if (_First == begin() && _Last == end())

  00003	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	57		 push	 edi
  0000a	8b 7d 0c	 mov	 edi, DWORD PTR __First$[ebp]
  0000d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0000f	3b 3a		 cmp	 edi, DWORD PTR [edx]
  00011	75 16		 jne	 SHORT $LN250@erase
  00013	3b c2		 cmp	 eax, edx
  00015	75 12		 jne	 SHORT $LN250@erase

; 1487 : 			{	// erase all and return fresh iterator
; 1488 : 			clear();

  00017	e8 00 00 00 00	 call	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear

; 1489 : 			return (end());

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00021	5f		 pop	 edi
  00022	5b		 pop	 ebx
  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 1496 : 			}
; 1497 : 		}

  00025	5d		 pop	 ebp
  00026	c2 0c 00	 ret	 12			; 0000000cH
$LN250@erase:

; 1490 : 			}
; 1491 : 		else
; 1492 : 			{	// erase subrange
; 1493 : 			while (_First != _Last)

  00029	3b f8		 cmp	 edi, eax
  0002b	74 33		 je	 SHORT $LN3@erase
  0002d	56		 push	 esi
  0002e	66 90		 npad	 2
$LL2@erase:

; 1494 : 				_First = erase(_First);

  00030	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00033	8b 37		 mov	 esi, DWORD PTR [edi]
  00035	89 30		 mov	 DWORD PTR [eax], esi
  00037	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00039	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0003c	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0003f	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00042	ff 4b 04	 dec	 DWORD PTR [ebx+4]
  00045	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  0004a	57		 push	 edi
  0004b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00050	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00053	83 c4 04	 add	 esp, 4
  00056	8b fe		 mov	 edi, esi
  00058	89 7d 0c	 mov	 DWORD PTR __First$[ebp], edi
  0005b	3b f0		 cmp	 esi, eax
  0005d	75 d1		 jne	 SHORT $LL2@erase
  0005f	5e		 pop	 esi
$LN3@erase:

; 1495 : 			return (_Make_iter(_Last));

  00060	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00063	5f		 pop	 edi
  00064	5b		 pop	 ebx
  00065	89 01		 mov	 DWORD PTR [ecx], eax
  00067	8b c1		 mov	 eax, ecx

; 1496 : 			}
; 1497 : 		}

  00069	5d		 pop	 ebp
  0006a	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@0@Z ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Unchecked_erase@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Unchecked_erase@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Unchecked_erase, COMDAT
; _this$ = ecx

; 1473 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1474 : 		_Nodeptr _Pnode = _Where._Mynode();

  00004	8b 75 08	 mov	 esi, DWORD PTR __Where$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 1475 : 
; 1476 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =

  0000a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]

; 1477 : 			this->_Nextnode(_Pnode);
; 1478 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1479 : 			this->_Prevnode(_Pnode);
; 1480 : 		this->_Freenode(_Pnode);

  0000d	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	89 02		 mov	 DWORD PTR [edx], eax
  00014	8b 16		 mov	 edx, DWORD PTR [esi]
  00016	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00019	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0001c	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00027	83 c4 04	 add	 esp, 4

; 1481 : 		--this->_Mysize();

  0002a	ff 4f 04	 dec	 DWORD PTR [edi+4]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi

; 1482 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?_Unchecked_erase@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?erase@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@@Z PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::erase, COMDAT
; _this$ = ecx

; 1466 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1467 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 06		 mov	 eax, DWORD PTR [esi]
  0000c	89 45 0c	 mov	 DWORD PTR __Where$[ebp], eax
  0000f	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	89 02		 mov	 DWORD PTR [edx], eax
  00016	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00018	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1468 : 		this->_Freenode(_Pnode);

  0001e	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00021	ff 4f 04	 dec	 DWORD PTR [edi+4]
  00024	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  00029	56		 push	 esi
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1469 : 		return (_Make_iter(_Where));

  0002f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00032	83 c4 04	 add	 esp, 4
  00035	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00038	5f		 pop	 edi
  00039	89 08		 mov	 DWORD PTR [eax], ecx
  0003b	5e		 pop	 esi

; 1470 : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
?erase@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@@Z ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Unlinknode@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Unlinknode@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@@Z PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Unlinknode, COMDAT
; _this$ = ecx

; 1444 : 		{	// unlink node at _Where from the list

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1445 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1446 : 		if (_Where._Getcont() != &this->_Get_data()
; 1447 : 			|| _Where._Ptr == this->_Myhead())
; 1448 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1449 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1450 : 		_Orphan_ptr(_Pnode);
; 1451 : 
; 1452 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1453 : 		_Nodeptr _Pnode = (_Where)._Mynode();

  00003	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	56		 push	 esi

; 1454 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1455 : 
; 1456 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =

  00007	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0000a	8b 10		 mov	 edx, DWORD PTR [eax]
  0000c	89 16		 mov	 DWORD PTR [esi], edx

; 1457 : 			this->_Nextnode(_Pnode);
; 1458 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =

  0000e	8b 30		 mov	 esi, DWORD PTR [eax]
  00010	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00013	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1459 : 			this->_Prevnode(_Pnode);
; 1460 : 
; 1461 : 		--this->_Mysize();

  00016	ff 49 04	 dec	 DWORD PTR [ecx+4]
  00019	5e		 pop	 esi

; 1462 : 		return (_Pnode);
; 1463 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Unlinknode@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@@Z ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Unlinknode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?push_back@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXABUPartition@GostCrypt@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXABUPartition@GostCrypt@@@Z PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::push_back, COMDAT
; _this$ = ecx

; 1292 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1293 : 		_Insert(_Unchecked_end(), _Val);

  00007	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0000a	8b 3e		 mov	 edi, DWORD PTR [esi]
  0000c	ff 77 04	 push	 DWORD PTR [edi+4]
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 ??$_Buynode@ABUPartition@GostCrypt@@@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@1@PAU21@0ABUPartition@GostCrypt@@@Z ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Buynode<GostCrypt::Partition const &>
  00015	8b d0		 mov	 edx, eax
  00017	b9 21 22 22 02	 mov	 ecx, 35791393		; 02222221H
  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	2b c8		 sub	 ecx, eax
  00021	83 f9 01	 cmp	 ecx, 1
  00024	72 12		 jb	 SHORT $LN91@push_back
  00026	40		 inc	 eax
  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0002a	89 57 04	 mov	 DWORD PTR [edi+4], edx
  0002d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	89 10		 mov	 DWORD PTR [eax], edx

; 1294 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN91@push_back:

; 1293 : 		_Insert(_Unchecked_end(), _Val);

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0003d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN93@push_back:
$LN90@push_back:
  00042	cc		 int	 3
?push_back@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXABUPartition@GostCrypt@@@Z ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?pop_front@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_front@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::pop_front, COMDAT
; _this$ = ecx

; 1288 : 		erase(begin());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	89 02		 mov	 DWORD PTR [edx], eax
  0000c	8b 16		 mov	 edx, DWORD PTR [esi]
  0000e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00011	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00014	ff 49 04	 dec	 DWORD PTR [ecx+4]
  00017	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0001a	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
  00028	5e		 pop	 esi

; 1289 : 		}

  00029	c3		 ret	 0
?pop_front@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::pop_front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?front@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEAAUPartition@GostCrypt@@XZ
_TEXT	SEGMENT
?front@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEAAUPartition@GostCrypt@@XZ PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::front, COMDAT
; _this$ = ecx

; 1263 : 		return (*begin());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	83 c0 08	 add	 eax, 8

; 1264 : 		}

  00007	c3		 ret	 0
?front@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEAAUPartition@GostCrypt@@XZ ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?max_size@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QBEIXZ PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::max_size, COMDAT
; _this$ = ecx

; 1247 : 		return (this->_Getal().max_size());

  00000	b8 22 22 22 02	 mov	 eax, 35791394		; 02222222H

; 1248 : 		}

  00005	c3		 ret	 0
?max_size@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QBEIXZ ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?size@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QBEIXZ PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::size, COMDAT
; _this$ = ecx

; 1242 : 		return (this->_Mysize());

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1243 : 		}

  00003	c3		 ret	 0
?size@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QBEIXZ ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Make_iter@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@@Z PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Make_iter, COMDAT
; _this$ = ecx

; 1163 : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1164 : 		return (iterator(_Where._Ptr, &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1165 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@@Z ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Unchecked_end@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1152 : 		{	// return unchecked iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1153 : 		return (_Unchecked_iterator(this->_Myhead(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1154 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Unchecked_end@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?end@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::end, COMDAT
; _this$ = ecx

; 1135 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1136 : 		return (const_iterator(this->_Myhead(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1137 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?end@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::end, COMDAT
; _this$ = ecx

; 1130 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1131 : 		return (iterator(this->_Myhead(), &this->_Get_data()));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1132 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?begin@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::begin, COMDAT
; _this$ = ecx

; 1124 : 		{	// return iterator for beginning of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1125 : 		return (const_iterator(this->_Nextnode(this->_Myhead()),

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1126 : 			&this->_Get_data()));
; 1127 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?begin@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@XZ PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::begin, COMDAT
; _this$ = ecx

; 1118 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1119 : 		return (iterator(this->_Nextnode(this->_Myhead()),

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1120 : 			&this->_Get_data()));
; 1121 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@2@XZ ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??4?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::operator=, COMDAT
; _this$ = ecx

; 1102 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1103 : 		if (this != &_Right)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b f0		 cmp	 esi, eax
  0000b	74 0a		 je	 SHORT $LN84@operator

; 1104 : 			{	// different, assign it
; 1105 : 			if (this->_Getal() != _Right._Getal()
; 1106 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1107 : 				{	// change allocator before copying
; 1108 : 				clear();
; 1109 : 				this->_Copy_alloc(_Right._Getal());
; 1110 : 				}
; 1111 : 
; 1112 : 			assign(_Right.begin(), _Right.end());

  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	50		 push	 eax
  00010	ff 30		 push	 DWORD PTR [eax]
  00012	e8 00 00 00 00	 call	 ??$assign@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@0@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::assign<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > > >
$LN84@operator:

; 1113 : 			}
; 1114 : 		return (*this);

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi

; 1115 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??4?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??1?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::~list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >, COMDAT
; _this$ = ecx

; 1097 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1098 : 		_Tidy();

  00003	e8 00 00 00 00	 call	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear

; 1099 : 		}

  00008	ff 36		 push	 DWORD PTR [esi]
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
  00012	5e		 pop	 esi
  00013	c3		 ret	 0
??1?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::~list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Assign_rv@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEX$$QAV12@@Z PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Assign_rv, COMDAT
; _this$ = ecx

; 1013 : 		{	// swap with empty *this, same allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1014 : 		this->_Swap_all(_Right);
; 1015 : 		_Swap_adl(this->_Myhead(), _Right._Myhead());

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	89 01		 mov	 DWORD PTR [ecx], eax
  0000d	89 16		 mov	 DWORD PTR [esi], edx

; 1016 : 		_STD swap(this->_Mysize(), _Right._Mysize());

  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00015	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00018	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0001b	5e		 pop	 esi

; 1017 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?_Assign_rv@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEX$$QAV12@@Z ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >, COMDAT
; _this$ = ecx

; 986  : 		{	// construct list by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Buynode0

; 987  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00020	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00023	89 06		 mov	 DWORD PTR [esi], eax
  00025	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00027	89 0e		 mov	 DWORD PTR [esi], ecx
  00029	89 02		 mov	 DWORD PTR [edx], eax
  0002b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00031	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 988  : 		}

  00034	8b c6		 mov	 eax, esi
  00036	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00039	5e		 pop	 esi
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 1
__Right$ = 8						; size = 4
??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >, COMDAT
; _this$ = ecx

; 924  : 		{	// construct list by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 921  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0003a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00041	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Buynode0
  00046	89 06		 mov	 DWORD PTR [esi], eax

; 925  : 		_TRY_BEGIN
; 926  : 		insert(begin(), _Right.begin(), _Right.end());

  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	c6 45 08 00	 mov	 BYTE PTR $T2[ebp], 0
  00051	ff 75 08	 push	 DWORD PTR $T2[ebp]
  00054	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00056	51		 push	 ecx
  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0005e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00062	8b 11		 mov	 edx, DWORD PTR [ecx]
  00064	8b ce		 mov	 ecx, esi
  00066	52		 push	 edx
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ??$_Insert_range@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@std@@@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@U_Iterator_base0@2@@1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Insert_range<std::_List_const_iterator<std::_List_val<std::_List_simple_types<GostCrypt::Partition> > > >

; 930  : 		_CATCH_END
; 931  : 		}

  0006d	8b c6		 mov	 eax, esi
  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00079	59		 pop	 ecx
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
__catch$??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$0:

; 927  : 		_CATCH_ALL
; 928  : 		_Tidy();

  00083	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?clear@?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXXZ ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::clear

; 929  : 		_RERAISE;

  0008b	6a 00		 push	 0
  0008d	6a 00		 push	 0
  0008f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN248@list:
$LN247@list:
  00094	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z$2:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ
__ehhandler$??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >, COMDAT
; _this$ = ecx

; 893  : 		{	// construct empty list

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Buynode0
  00020	89 06		 mov	 DWORD PTR [esi], eax

; 894  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$list@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::list<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::~_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >, COMDAT
; _this$ = ecx
  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::~_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Freenode@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z PROC ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Freenode, COMDAT
; _this$ = ecx

; 848  : 		{	// give node back

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 849  : 		this->_Getal().destroy(
; 850  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 851  : 		this->_Getal().destroy(
; 852  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 853  : 		this->_Getal().destroy(

  00004	8b 75 08	 mov	 esi, DWORD PTR __Pnode$[ebp]
  00007	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0000a	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ

; 854  : 			_STD addressof(this->_Myval(_Pnode)));
; 855  : 		this->_Getal().deallocate(_Pnode, 1);

  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
  00018	5e		 pop	 esi

; 856  : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?_Freenode@?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z ENDP ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_Freenode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >, COMDAT
; _this$ = ecx

; 818  : 		{	// default construct

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Buynode0
  00020	89 06		 mov	 DWORD PTR [esi], eax

; 819  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$_List_buy@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >::_List_buy<GostCrypt::Partition,std::allocator<GostCrypt::Partition> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >,std::_List_val<std::_List_simple_types<GostCrypt::Partition> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myval@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAUPartition@GostCrypt@@PAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAUPartition@GostCrypt@@PAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<GostCrypt::Partition> >::_Myval, COMDAT

; 545  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 546  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 547  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAUPartition@GostCrypt@@PAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<GostCrypt::Partition> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Prevnode@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<GostCrypt::Partition> >::_Prevnode, COMDAT

; 540  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 541  : 		return ((_Nodepref)_Pnode->_Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 542  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<GostCrypt::Partition> >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<GostCrypt::Partition> >::_Nextnode, COMDAT

; 535  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 536  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 537  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<GostCrypt::Partition> >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<GostCrypt::Partition> >::_List_val<std::_List_simple_types<GostCrypt::Partition> >, COMDAT
; _this$ = ecx

; 529  : 		: _Myhead(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 532  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<GostCrypt::Partition> >::_List_val<std::_List_simple_types<GostCrypt::Partition> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Mysize@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QBEABIXZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Mysize, COMDAT
; _this$ = ecx

; 797  : 		return (_Get_data()._Mysize);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 798  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QBEABIXZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Mysize@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Mysize, COMDAT
; _this$ = ecx

; 792  : 		return (_Get_data()._Mysize);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 793  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myhead@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QBEABQAU?$_List_node@UPartition@GostCrypt@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QBEABQAU?$_List_node@UPartition@GostCrypt@@PAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Myhead, COMDAT
; _this$ = ecx

; 787  : 		return (_Get_data()._Myhead);

  00000	8b c1		 mov	 eax, ecx

; 788  : 		}

  00002	c3		 ret	 0
?_Myhead@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QBEABQAU?$_List_node@UPartition@GostCrypt@@PAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myhead@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Myhead, COMDAT
; _this$ = ecx

; 782  : 		return (_Get_data()._Myhead);

  00000	8b c1		 mov	 eax, ecx

; 783  : 		}

  00002	c3		 ret	 0
?_Myhead@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Get_data@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Get_data, COMDAT
; _this$ = ecx

; 777  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 778  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Get_data@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Get_data, COMDAT
; _this$ = ecx

; 772  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 773  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@UPartition@GostCrypt@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Getal@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Getal, COMDAT
; _this$ = ecx

; 767  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 768  : 		}

  00002	c3		 ret	 0
?_Getal@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Getal@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Getal, COMDAT
; _this$ = ecx

; 762  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 763  : 		}

  00002	c3		 ret	 0
?_Getal@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Swap_all@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_all@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Swap_all, COMDAT
; _this$ = ecx

; 757  : 		_Get_data()._Swap_all(_Right._Get_data());
; 758  : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Buynode0@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@0@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
?_Buynode0@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@0@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Buynode0, COMDAT
; _this$ = ecx

; 729  : 		{	// allocate a node and set links

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 730  : 		_Nodeptr _Pnode = _Getal().allocate(1);

  00003	6a 78		 push	 120			; 00000078H
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4
  0000d	85 c0		 test	 eax, eax
  0000f	74 1f		 je	 SHORT $LN117@Buynode0

; 731  : 
; 732  : 		if (_Next == _Nodeptr())

  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Next$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	75 06		 jne	 SHORT $LN115@Buynode0

; 733  : 			{	// point at self
; 734  : 			_Next = _Pnode;

  00018	8b c8		 mov	 ecx, eax

; 735  : 			_Prev = _Pnode;

  0001a	8b d0		 mov	 edx, eax
  0001c	eb 03		 jmp	 SHORT $LN2@Buynode0
$LN115@Buynode0:
  0001e	8b 55 0c	 mov	 edx, DWORD PTR __Prev$[ebp]
$LN2@Buynode0:

; 736  : 			}
; 737  : 		_TRY_BEGIN
; 738  : 		_Getal().construct(

  00021	89 08		 mov	 DWORD PTR [eax], ecx

; 739  : 			_STD addressof(_Nextnode(_Pnode)), _Next);
; 740  : 		_Getal().construct(

  00023	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00026	85 c9		 test	 ecx, ecx
  00028	74 02		 je	 SHORT $LN4@Buynode0
  0002a	89 11		 mov	 DWORD PTR [ecx], edx
$LN4@Buynode0:

; 741  : 			_STD addressof(_Prevnode(_Pnode)), _Prev);
; 742  : 		_CATCH_ALL
; 743  : 		_Getal().deallocate(_Pnode, 1);
; 744  : 		_RERAISE;
; 745  : 		_CATCH_END
; 746  : 
; 747  : 		return (_Pnode);
; 748  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
$LN117@Buynode0:

; 730  : 		_Nodeptr _Pnode = _Getal().allocate(1);

  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN119@Buynode0:
$LN116@Buynode0:
  00035	cc		 int	 3
?_Buynode0@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@0@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Freeheadnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Freeheadnode, COMDAT
; _this$ = ecx

; 719  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Getal().destroy(
; 721  : 			_STD addressof(_Nextnode(_Pnode)));
; 722  : 		_Getal().destroy(
; 723  : 			_STD addressof(_Prevnode(_Pnode)));
; 724  : 		_Getal().deallocate(_Pnode, 1);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 725  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freeheadnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Buyheadnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Buyheadnode, COMDAT
; _this$ = ecx

; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Buynode0

; 716  : 		}

  00009	c3		 ret	 0
?_Buyheadnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Copy_alloc@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Copy_alloc@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 622  : 		_Pocca(_Getal(), _Al);
; 623  : 		}

  00000	c2 04 00	 ret	 4
?_Copy_alloc@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??1?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::~_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >, COMDAT
; _this$ = ecx

; 617  : 		_Freeheadnode(_Myhead());

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx

; 618  : 		}

  00008	c3		 ret	 0
??1?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::~_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >, COMDAT
; _this$ = ecx

; 602  : 		{	// default construct head node

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 603  : 		_Myhead() = _Buyheadnode();

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Buynode0
  00019	89 06		 mov	 DWORD PTR [esi], eax

; 604  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c3		 ret	 0
??0?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myval@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAUPartition@GostCrypt@@PAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAUPartition@GostCrypt@@PAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Myval, COMDAT

; 595  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 596  : 		return (_List_val<_Val_types>::_Myval(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 597  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAUPartition@GostCrypt@@PAU?$_List_node@UPartition@GostCrypt@@PAX@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Prevnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Prevnode, COMDAT

; 590  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 591  : 		return (_List_val<_Val_types>::_Prevnode(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 592  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z PROC ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Nextnode, COMDAT

; 585  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 586  : 		return (_List_val<_Val_types>::_Nextnode(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 587  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_alloc@U?$_List_base_types@UPartition@GostCrypt@@V?$allocator@UPartition@GostCrypt@@@std@@@std@@@std@@SAAAPAU?$_List_node@UPartition@GostCrypt@@PAX@2@PAU32@@Z ENDP ; std::_List_alloc<std::_List_base_types<GostCrypt::Partition,std::allocator<GostCrypt::Partition> > >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	b8 22 22 22 02	 mov	 eax, 35791394		; 02222222H

; 1009 : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 988  : 		}

  00003	5d		 pop	 ebp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00004	e9 00 00 00 00	 jmp	 ?deallocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 977  : 		}

  00003	5d		 pop	 ebp

; 976  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	b8 22 22 22 02	 mov	 eax, 35791394		; 02222222H

; 870  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<GostCrypt::Partition,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 22 22 22 02	 mov	 eax, 35791394		; 02222222H

; 750  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 06		 jne	 SHORT $LN4@allocate
  0000a	33 c0		 xor	 eax, eax
$LN12@allocate:

; 726  : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  00010	81 f9 22 22 22
	02		 cmp	 ecx, 35791394		; 02222222H
  00016	77 43		 ja	 SHORT $LN14@allocate
  00018	8b c1		 mov	 eax, ecx
  0001a	c1 e0 04	 shl	 eax, 4
  0001d	2b c1		 sub	 eax, ecx
  0001f	c1 e0 03	 shl	 eax, 3
  00022	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00027	72 23		 jb	 SHORT $LN6@allocate
  00029	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  0002c	3b c8		 cmp	 ecx, eax
  0002e	76 30		 jbe	 SHORT $LN16@allocate
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00036	8b c8		 mov	 ecx, eax
  00038	83 c4 04	 add	 esp, 4
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 26		 je	 SHORT $LN17@allocate
  0003f	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00042	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00045	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00052	83 c4 04	 add	 esp, 4
  00055	85 c0		 test	 eax, eax
  00057	75 b3		 jne	 SHORT $LN12@allocate
  00059	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:
  0005b	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:
  00060	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:
  00065	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:
  0006a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  0006f	cc		 int	 3
?allocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	81 fa 22 22 22
	02		 cmp	 edx, 35791394		; 02222222H
  0000f	77 38		 ja	 SHORT $LN13@deallocate
  00011	8b c2		 mov	 eax, edx
  00013	c1 e0 04	 shl	 eax, 4
  00016	2b c2		 sub	 eax, edx
  00018	c1 e0 03	 shl	 eax, 3
  0001b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00020	72 1a		 jb	 SHORT $LN5@deallocate
  00022	f6 c1 1f	 test	 cl, 31			; 0000001fH
  00025	75 27		 jne	 SHORT $LN15@deallocate
  00027	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0002a	3b c1		 cmp	 eax, ecx
  0002c	73 25		 jae	 SHORT $LN16@deallocate
  0002e	2b c8		 sub	 ecx, eax
  00030	83 f9 04	 cmp	 ecx, 4
  00033	72 23		 jb	 SHORT $LN17@deallocate
  00035	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00038	77 23		 ja	 SHORT $LN18@deallocate
  0003a	8b c8		 mov	 ecx, eax
$LN5@deallocate:
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00042	83 c4 04	 add	 esp, 4

; 721  : 		}

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00049	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:
  0004e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:
  00053	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:
  00058	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  0005d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  00062	cc		 int	 3
?deallocate@?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAEXPAU?$_List_node@UPartition@GostCrypt@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::allocator<std::_List_node<GostCrypt::Partition,void *> >, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::allocator<std::_List_node<GostCrypt::Partition,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::allocator<std::_List_node<GostCrypt::Partition,void *> >, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_List_node@UPartition@GostCrypt@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_List_node<GostCrypt::Partition,void *> >::allocator<std::_List_node<GostCrypt::Partition,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GPartition@GostCrypt@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GPartition@GostCrypt@@QAEPAXI@Z PROC			; GostCrypt::Partition::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1Partition@GostCrypt@@QAE@XZ
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN4@scalar
  00011	6a 70		 push	 112			; 00000070H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GPartition@GostCrypt@@QAEPAXI@Z ENDP			; GostCrypt::Partition::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4Partition@GostCrypt@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4Partition@GostCrypt@@QAEAAU01@ABU01@@Z PROC		; GostCrypt::Partition::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 0a		 je	 SHORT $LN4@operator
  0000e	6a ff		 push	 -1
  00010	6a 00		 push	 0
  00012	57		 push	 edi
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN4@operator:
  00018	0f 10 47 18	 movups	 xmm0, XMMWORD PTR [edi+24]
  0001c	8d 47 38	 lea	 eax, DWORD PTR [edi+56]
  0001f	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  00022	0f 11 46 18	 movups	 XMMWORD PTR [esi+24], xmm0
  00026	0f 10 47 28	 movups	 xmm0, XMMWORD PTR [edi+40]
  0002a	0f 11 46 28	 movups	 XMMWORD PTR [esi+40], xmm0
  0002e	3b c8		 cmp	 ecx, eax
  00030	74 0a		 je	 SHORT $LN135@operator
  00032	6a ff		 push	 -1
  00034	6a 00		 push	 0
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN135@operator:
  0003c	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  0003f	8d 4e 58	 lea	 ecx, DWORD PTR [esi+88]
  00042	89 46 50	 mov	 DWORD PTR [esi+80], eax
  00045	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  00048	83 c7 58	 add	 edi, 88			; 00000058H
  0004b	89 46 54	 mov	 DWORD PTR [esi+84], eax
  0004e	3b cf		 cmp	 ecx, edi
  00050	74 0a		 je	 SHORT $LN398@operator
  00052	6a ff		 push	 -1
  00054	6a 00		 push	 0
  00056	57		 push	 edi
  00057	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN398@operator:
  0005c	5f		 pop	 edi
  0005d	8b c6		 mov	 eax, esi
  0005f	5e		 pop	 esi
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
??4Partition@GostCrypt@@QAEAAU01@ABU01@@Z ENDP		; GostCrypt::Partition::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0Partition@GostCrypt@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0Partition@GostCrypt@@QAE@$$QAU01@@Z PROC		; GostCrypt::Partition::Partition, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	56		 push	 esi
  0000b	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
  00012	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00019	c6 07 00	 mov	 BYTE PTR [edi], 0
  0001c	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00021	0f 10 46 18	 movups	 xmm0, XMMWORD PTR [esi+24]
  00025	8d 4f 38	 lea	 ecx, DWORD PTR [edi+56]
  00028	8d 46 38	 lea	 eax, DWORD PTR [esi+56]
  0002b	0f 11 47 18	 movups	 XMMWORD PTR [edi+24], xmm0
  0002f	50		 push	 eax
  00030	0f 10 46 28	 movups	 xmm0, XMMWORD PTR [esi+40]
  00034	0f 11 47 28	 movups	 XMMWORD PTR [edi+40], xmm0
  00038	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  0003f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00046	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00049	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0004e	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  00051	8d 4f 58	 lea	 ecx, DWORD PTR [edi+88]
  00054	89 47 50	 mov	 DWORD PTR [edi+80], eax
  00057	33 d2		 xor	 edx, edx
  00059	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0005c	89 47 54	 mov	 DWORD PTR [edi+84], eax
  0005f	8d 46 58	 lea	 eax, DWORD PTR [esi+88]
  00062	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  00069	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00070	50		 push	 eax
  00071	66 89 11	 mov	 WORD PTR [ecx], dx
  00074	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
  00079	8b c7		 mov	 eax, edi
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
??0Partition@GostCrypt@@QAE@$$QAU01@@Z ENDP		; GostCrypt::Partition::Partition
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0Partition@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0Partition@GostCrypt@@QAE@ABU01@@Z PROC		; GostCrypt::Partition::Partition, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0Partition@GostCrypt@@QAE@ABU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00031	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00038	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0003f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00043	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004a	72 04		 jb	 SHORT $LN124@Partition
  0004c	8b 06		 mov	 eax, DWORD PTR [esi]
  0004e	eb 02		 jmp	 SHORT $LN125@Partition
$LN124@Partition:
  00050	8b c6		 mov	 eax, esi
$LN125@Partition:
  00052	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  00055	6a ff		 push	 -1
  00057	6a 00		 push	 0
  00059	57		 push	 edi
  0005a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0005d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00062	0f 10 47 18	 movups	 xmm0, XMMWORD PTR [edi+24]
  00066	8d 4e 38	 lea	 ecx, DWORD PTR [esi+56]
  00069	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00070	8d 57 38	 lea	 edx, DWORD PTR [edi+56]
  00073	0f 11 46 18	 movups	 XMMWORD PTR [esi+24], xmm0
  00077	0f 10 47 28	 movups	 xmm0, XMMWORD PTR [edi+40]
  0007b	0f 11 46 28	 movups	 XMMWORD PTR [esi+40], xmm0
  0007f	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00086	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0008d	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00091	72 04		 jb	 SHORT $LN249@Partition
  00093	8b 01		 mov	 eax, DWORD PTR [ecx]
  00095	eb 02		 jmp	 SHORT $LN250@Partition
$LN249@Partition:
  00097	8b c1		 mov	 eax, ecx
$LN250@Partition:
  00099	6a ff		 push	 -1
  0009b	6a 00		 push	 0
  0009d	52		 push	 edx
  0009e	c6 00 00	 mov	 BYTE PTR [eax], 0
  000a1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000a6	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  000a9	8d 4e 58	 lea	 ecx, DWORD PTR [esi+88]
  000ac	89 46 50	 mov	 DWORD PTR [esi+80], eax
  000af	33 d2		 xor	 edx, edx
  000b1	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  000b4	89 46 54	 mov	 DWORD PTR [esi+84], eax
  000b7	8d 47 58	 lea	 eax, DWORD PTR [edi+88]
  000ba	6a ff		 push	 -1
  000bc	52		 push	 edx
  000bd	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  000c4	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  000cb	50		 push	 eax
  000cc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000d0	66 89 11	 mov	 WORD PTR [ecx], dx
  000d3	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  000d8	8b c6		 mov	 eax, esi
  000da	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000dd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e4	59		 pop	 ecx
  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Partition@GostCrypt@@QAE@ABU01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0Partition@GostCrypt@@QAE@ABU01@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 38	 add	 ecx, 56			; 00000038H
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0Partition@GostCrypt@@QAE@ABU01@@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Partition@GostCrypt@@QAE@ABU01@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Partition@GostCrypt@@QAE@ABU01@@Z ENDP		; GostCrypt::Partition::Partition
; Function compile flags: /Ogtp
;	COMDAT ??1Partition@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??1Partition@GostCrypt@@QAE@XZ PROC			; GostCrypt::Partition::~Partition, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00006	57		 push	 edi
  00007	8d 7e 58	 lea	 edi, DWORD PTR [esi+88]
  0000a	83 f8 08	 cmp	 eax, 8
  0000d	72 0b		 jb	 SHORT $LN9@Partition
  0000f	40		 inc	 eax
  00010	8b cf		 mov	 ecx, edi
  00012	50		 push	 eax
  00013	ff 37		 push	 DWORD PTR [edi]
  00015	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN9@Partition:
  0001a	c7 47 14 07 00
	00 00		 mov	 DWORD PTR [edi+20], 7
  00021	83 7f 14 08	 cmp	 DWORD PTR [edi+20], 8
  00025	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  0002c	72 02		 jb	 SHORT $LN99@Partition
  0002e	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN99@Partition:
  00030	33 c0		 xor	 eax, eax
  00032	66 89 07	 mov	 WORD PTR [edi], ax
  00035	8d 7e 38	 lea	 edi, DWORD PTR [esi+56]
  00038	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0003b	83 f8 10	 cmp	 eax, 16			; 00000010H
  0003e	72 0b		 jb	 SHORT $LN112@Partition
  00040	40		 inc	 eax
  00041	8b cf		 mov	 ecx, edi
  00043	50		 push	 eax
  00044	ff 37		 push	 DWORD PTR [edi]
  00046	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN112@Partition:
  0004b	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
  00052	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00056	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  0005d	72 02		 jb	 SHORT $LN200@Partition
  0005f	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN200@Partition:
  00061	c6 07 00	 mov	 BYTE PTR [edi], 0
  00064	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00067	83 f8 10	 cmp	 eax, 16			; 00000010H
  0006a	72 0b		 jb	 SHORT $LN213@Partition
  0006c	40		 inc	 eax
  0006d	8b ce		 mov	 ecx, esi
  0006f	50		 push	 eax
  00070	ff 36		 push	 DWORD PTR [esi]
  00072	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN213@Partition:
  00077	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0007e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00082	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00089	72 08		 jb	 SHORT $LN301@Partition
  0008b	8b 06		 mov	 eax, DWORD PTR [esi]
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	c6 00 00	 mov	 BYTE PTR [eax], 0
  00092	c3		 ret	 0
$LN301@Partition:
  00093	5f		 pop	 edi
  00094	c6 06 00	 mov	 BYTE PTR [esi], 0
  00097	5e		 pop	 esi
  00098	c3		 ret	 0
??1Partition@GostCrypt@@QAE@XZ ENDP			; GostCrypt::Partition::~Partition
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0Partition@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??0Partition@GostCrypt@@QAE@XZ PROC			; GostCrypt::Partition::Partition, COMDAT
; _this$ = ecx
  00000	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00007	33 c0		 xor	 eax, eax
  00009	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00013	c7 41 4c 0f 00
	00 00		 mov	 DWORD PTR [ecx+76], 15	; 0000000fH
  0001a	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0
  00021	c6 41 38 00	 mov	 BYTE PTR [ecx+56], 0
  00025	c7 41 6c 07 00
	00 00		 mov	 DWORD PTR [ecx+108], 7
  0002c	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0
  00033	66 89 41 58	 mov	 WORD PTR [ecx+88], ax
  00037	8b c1		 mov	 eax, ecx
  00039	c3		 ret	 0
??0Partition@GostCrypt@@QAE@XZ ENDP			; GostCrypt::Partition::Partition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.h
;	COMDAT ?Size@Buffer@GostCrypt@@QBEIXZ
_TEXT	SEGMENT
?Size@Buffer@GostCrypt@@QBEIXZ PROC			; GostCrypt::Buffer::Size, COMDAT
; _this$ = ecx

; 63   : 		size_t Size () const { return DataSize; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?Size@Buffer@GostCrypt@@QBEIXZ ENDP			; GostCrypt::Buffer::Size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.h
;	COMDAT ?Ptr@Buffer@GostCrypt@@QBEPAEXZ
_TEXT	SEGMENT
?Ptr@Buffer@GostCrypt@@QBEPAEXZ PROC			; GostCrypt::Buffer::Ptr, COMDAT
; _this$ = ecx

; 62   : 		byte *Ptr () const { return DataPtr; }

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	c3		 ret	 0
?Ptr@Buffer@GostCrypt@@QBEPAEXZ ENDP			; GostCrypt::Buffer::Ptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.h
;	COMDAT ??1Buffer@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??1Buffer@GostCrypt@@QAE@XZ PROC			; GostCrypt::Buffer::~Buffer, COMDAT
; _this$ = ecx

; 61   : 		~Buffer () { delete[] DataPtr; }

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1Buffer@GostCrypt@@QAE@XZ ENDP			; GostCrypt::Buffer::~Buffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.h
;	COMDAT ??0Buffer@GostCrypt@@QAE@I@Z
_TEXT	SEGMENT
$T1 = -12						; size = 12
_size$ = 8						; size = 4
??0Buffer@GostCrypt@@QAE@I@Z PROC			; GostCrypt::Buffer::Buffer, COMDAT
; _this$ = ecx

; 55   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 54   : 		Buffer (size_t size) : DataSize (size)

  00003	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]

; 55   : 		{

  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx

; 56   : 			DataPtr = new byte[size];

  0000c	50		 push	 eax
  0000d	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00010	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00015	83 c4 04	 add	 esp, 4
  00018	89 06		 mov	 DWORD PTR [esi], eax

; 57   : 			if (!DataPtr)

  0001a	85 c0		 test	 eax, eax
  0001c	74 09		 je	 SHORT $LN9@Buffer

; 59   : 		}

  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN9@Buffer:
  00027	0f 57 c0	 xorps	 xmm0, xmm0

; 58   : 				throw bad_alloc();

  0002a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00031	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00036	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00039	66 0f d6 45 f8	 movq	 QWORD PTR $T1[ebp+4], xmm0
  0003e	50		 push	 eax
  0003f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp+4], OFFSET ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN11@Buffer:
$LN8@Buffer:
  0004b	cc		 int	 3
??0Buffer@GostCrypt@@QAE@I@Z ENDP			; GostCrypt::Buffer::Buffer
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1Device@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??1Device@GostCrypt@@QAE@XZ PROC			; GostCrypt::Device::~Device, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	80 7e 01 00	 cmp	 BYTE PTR [esi+1], 0
  00007	74 12		 je	 SHORT $LN7@Device
  00009	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000c	75 09		 jne	 SHORT $LN8@Device
  0000e	ff 76 10	 push	 DWORD PTR [esi+16]
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN8@Device:
  00017	c6 46 01 00	 mov	 BYTE PTR [esi+1], 0
$LN7@Device:
  0001b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0001e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00021	72 0d		 jb	 SHORT $LN16@Device
  00023	40		 inc	 eax
  00024	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00027	50		 push	 eax
  00028	ff 76 18	 push	 DWORD PTR [esi+24]
  0002b	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN16@Device:
  00030	c7 46 2c 0f 00
	00 00		 mov	 DWORD PTR [esi+44], 15	; 0000000fH
  00037	83 7e 2c 10	 cmp	 DWORD PTR [esi+44], 16	; 00000010H
  0003b	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00042	72 08		 jb	 SHORT $LN104@Device
  00044	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00047	5e		 pop	 esi
  00048	c6 00 00	 mov	 BYTE PTR [eax], 0
  0004b	c3		 ret	 0
$LN104@Device:
  0004c	c6 46 18 00	 mov	 BYTE PTR [esi+24], 0
  00050	5e		 pop	 esi
  00051	c3		 ret	 0
??1Device@GostCrypt@@QAE@XZ ENDP			; GostCrypt::Device::~Device
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T2 = -80						; size = 8
_this$GSCopy$ = -72					; size = 4
$T3 = -68						; size = 24
$T4 = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_path$ = 8						; size = 24
_readOnly$ = 32						; size = 1
??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC ; GostCrypt::Device::Device, COMDAT
; _this$ = ecx

; 525  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002e	8b f1		 mov	 esi, ecx
  00030	89 75 ac	 mov	 DWORD PTR _this$[ebp], esi
  00033	8a 5d 20	 mov	 bl, BYTE PTR _readOnly$[ebp]
  00036	89 75 b8	 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  00039	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  0003c	c6 46 01 00	 mov	 BYTE PTR [esi+1], 0
  00040	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
  00047	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  0004e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00052	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00059	72 02		 jb	 SHORT $LN121@Device
  0005b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN121@Device:
  0005d	c6 00 00	 mov	 BYTE PTR [eax], 0

; 526  : 		 FileOpen = false;
; 527  : 		 Elevated = false;
; 528  : 
; 529  : 		Handle = CreateFile ((string ("\\\\.\\") + path).c_str(),

  00060	6a 04		 push	 4
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_04GBDIODIA@?2?2?4?2?$AA@
  00067	8d 4d d4	 lea	 ecx, DWORD PTR $T4[ebp]
  0006a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0006e	66 c7 06 00 00	 mov	 WORD PTR [esi], 0
  00073	c7 45 e8 0f 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH
  0007a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+16], 0
  00081	c6 45 d4 00	 mov	 BYTE PTR $T4[ebp], 0
  00085	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0008a	8d 45 08	 lea	 eax, DWORD PTR _path$[ebp]
  0008d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00091	50		 push	 eax
  00092	8d 45 d4	 lea	 eax, DWORD PTR $T4[ebp]
  00095	50		 push	 eax
  00096	8d 45 bc	 lea	 eax, DWORD PTR $T3[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@ABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0009f	8b c8		 mov	 ecx, eax
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  000a8	72 02		 jb	 SHORT $LN253@Device
  000aa	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN253@Device:
  000ac	6a 00		 push	 0
  000ae	68 00 00 00 90	 push	 -1879048192		; 90000000H
  000b3	6a 03		 push	 3
  000b5	6a 00		 push	 0
  000b7	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  000bc	84 db		 test	 bl, bl
  000be	6a 03		 push	 3
  000c0	b8 00 00 00 c0	 mov	 eax, -1073741824	; c0000000H
  000c5	0f 45 c2	 cmovne	 eax, edx
  000c8	50		 push	 eax
  000c9	51		 push	 ecx
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  000d0	89 46 10	 mov	 DWORD PTR [esi+16], eax
  000d3	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp+20]
  000d6	83 f8 10	 cmp	 eax, 16			; 00000010H
  000d9	72 0d		 jb	 SHORT $LN262@Device
  000db	40		 inc	 eax
  000dc	8d 4d bc	 lea	 ecx, DWORD PTR $T3[ebp]
  000df	50		 push	 eax
  000e0	ff 75 bc	 push	 DWORD PTR $T3[ebp]
  000e3	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN262@Device:
  000e8	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp+20]
  000eb	c7 45 d0 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
  000f2	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0
  000f9	c6 45 bc 00	 mov	 BYTE PTR $T3[ebp], 0
  000fd	83 f8 10	 cmp	 eax, 16			; 00000010H
  00100	72 0d		 jb	 SHORT $LN363@Device
  00102	40		 inc	 eax
  00103	8d 4d d4	 lea	 ecx, DWORD PTR $T4[ebp]
  00106	50		 push	 eax
  00107	ff 75 d4	 push	 DWORD PTR $T4[ebp]
  0010a	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN363@Device:

; 530  : 			readOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
; 531  : 			FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
; 532  : 			FILE_FLAG_RANDOM_ACCESS | FILE_FLAG_WRITE_THROUGH, NULL);
; 533  : 
; 534  : 		try
; 535  : 		{
; 536  : 			throw_sys_if (Handle == INVALID_HANDLE_VALUE);

  0010f	83 7e 10 ff	 cmp	 DWORD PTR [esi+16], -1
  00113	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  00117	75 41		 jne	 SHORT $LN2@Device
  00119	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00126	89 45 b4	 mov	 DWORD PTR $T2[ebp+4], eax
  00129	8d 45 b0	 lea	 eax, DWORD PTR $T2[ebp]
  0012c	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN697@Device:
__catch$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$0:

; 537  : 		}
; 538  : 		catch (SystemException &)
; 539  : 		{
; 540  : 			if (GetLastError() == ERROR_ACCESS_DENIED && IsUacSupported())

  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0013d	83 f8 05	 cmp	 eax, 5
  00140	75 7e		 jne	 SHORT $LN7@Device
  00142	e8 00 00 00 00	 call	 _IsUacSupported
  00147	85 c0		 test	 eax, eax
  00149	74 75		 je	 SHORT $LN7@Device

; 541  : 				Elevated = true;

  0014b	8b 45 b8	 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  0014e	c6 00 01	 mov	 BYTE PTR [eax], 1

; 544  : 		}

  00151	b8 00 00 00 00	 mov	 eax, $LN17@Device
  00156	c3		 ret	 0
$LN17@Device:
  00157	8b 75 b8	 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
$LN2@Device:

; 545  : 
; 546  : 		FileOpen = true;
; 547  : 		FilePointerPosition = 0;
; 548  : 		IsDevice = true;
; 549  : 		Path = path;

  0015a	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  0015d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00164	8d 45 08	 lea	 eax, DWORD PTR _path$[ebp]
  00167	c6 46 01 01	 mov	 BYTE PTR [esi+1], 1
  0016b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00172	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00179	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1
  0017d	3b c8		 cmp	 ecx, eax
  0017f	74 0a		 je	 SHORT $LN464@Device
  00181	6a ff		 push	 -1
  00183	6a 00		 push	 0
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN464@Device:

; 550  : 	}

  0018b	8b 4d 1c	 mov	 ecx, DWORD PTR _path$[ebp+20]
  0018e	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00191	72 0d		 jb	 SHORT $LN600@Device
  00193	41		 inc	 ecx
  00194	51		 push	 ecx
  00195	ff 75 08	 push	 DWORD PTR _path$[ebp]
  00198	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  0019b	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN600@Device:
  001a0	8b c6		 mov	 eax, esi
  001a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001ac	59		 pop	 ecx
  001ad	5f		 pop	 edi
  001ae	5e		 pop	 esi
  001af	5b		 pop	 ebx
  001b0	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b3	33 cd		 xor	 ecx, ebp
  001b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ba	8b e5		 mov	 esp, ebp
  001bc	5d		 pop	 ebp
  001bd	c2 1c 00	 ret	 28			; 0000001cH
$LN7@Device:

; 542  : 			else
; 543  : 				throw;

  001c0	6a 00		 push	 0
  001c2	6a 00		 push	 0
  001c4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN698@Device:
$LN696@Device:
  001c9	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$2:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$3:
  00008	8b 4d b8	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1File@GostCrypt@@QAE@XZ ; GostCrypt::File::~File
__unwindfunclet$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$4:
  00010	8d 4d d4	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Device@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; GostCrypt::Device::Device
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?SeekAt@File@GostCrypt@@QAEX_J@Z
_TEXT	SEGMENT
$T1 = 8							; size = 8
_position$ = 8						; size = 8
?SeekAt@File@GostCrypt@@QAEX_J@Z PROC			; GostCrypt::File::SeekAt, COMDAT
; _this$ = ecx

; 446  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 		FilePointerPosition = position;
; 448  : 
; 449  : 		if (!Elevated)

  00003	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00006	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  00009	8b 55 0c	 mov	 edx, DWORD PTR _position$[ebp+4]
  0000c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0000f	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00012	75 13		 jne	 SHORT $LN3@SeekAt

; 450  : 		{
; 451  : 			LARGE_INTEGER pos;
; 452  : 			pos.QuadPart = position;
; 453  : 			throw_sys_if (!SetFilePointerEx (Handle, pos, NULL, FILE_BEGIN));

  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	52		 push	 edx
  00019	50		 push	 eax
  0001a	ff 71 10	 push	 DWORD PTR [ecx+16]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  00023	85 c0		 test	 eax, eax
  00025	74 04		 je	 SHORT $LN14@SeekAt
$LN3@SeekAt:

; 454  : 		}
; 455  : 	}

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
$LN14@SeekAt:

; 450  : 		{
; 451  : 			LARGE_INTEGER pos;
; 452  : 			pos.QuadPart = position;
; 453  : 			throw_sys_if (!SetFilePointerEx (Handle, pos, NULL, FILE_BEGIN));

  0002b	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00038	89 45 0c	 mov	 DWORD PTR $T1[ebp+4], eax
  0003b	8d 45 08	 lea	 eax, DWORD PTR $T1[ebp]
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN16@SeekAt:
$LN13@SeekAt:
  00049	cc		 int	 3
?SeekAt@File@GostCrypt@@QAEX_J@Z ENDP			; GostCrypt::File::SeekAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?Write@File@GostCrypt@@QAEXPAEK@Z
_TEXT	SEGMENT
_e$2 = -1532						; size = 4
$T3 = -1528						; size = 8
$T4 = -1520						; size = 8
_buffer$GSCopy$ = -1512					; size = 4
_this$GSCopy$ = -1508					; size = 4
_bytesWritten$ = -1504					; size = 4
_bootEnc$5 = -1500					; size = 1480
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
?Write@File@GostCrypt@@QAEXPAEK@Z PROC			; GostCrypt::File::Write, COMDAT
; _this$ = ecx

; 467  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Write@File@GostCrypt@@QAEXPAEK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec f0 05 00
	00		 sub	 esp, 1520		; 000005f0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b f1		 mov	 esi, ecx

; 468  : 		DWORD bytesWritten;
; 469  : 
; 470  : 		try
; 471  : 		{
; 472  : 			if (Elevated)

  00033	80 3e 00	 cmp	 BYTE PTR [esi], 0

; 473  : 			{
; 474  : 				Elevator::ReadWriteFile (true, IsDevice, Path, buffer, FilePointerPosition, size, &bytesWritten);

  00036	8d 8d 20 fa ff
	ff		 lea	 ecx, DWORD PTR _bytesWritten$[ebp]
  0003c	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0003f	8b 7d 0c	 mov	 edi, DWORD PTR _size$[ebp]
  00042	89 b5 1c fa ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  00048	89 85 18 fa ff
	ff		 mov	 DWORD PTR _buffer$GSCopy$[ebp], eax
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00055	74 58		 je	 SHORT $LN7@Write
  00057	51		 push	 ecx
  00058	57		 push	 edi
  00059	ff 76 0c	 push	 DWORD PTR [esi+12]
  0005c	ff 76 08	 push	 DWORD PTR [esi+8]
  0005f	50		 push	 eax
  00060	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  00063	50		 push	 eax
  00064	0f b6 46 14	 movzx	 eax, BYTE PTR [esi+20]
  00068	50		 push	 eax
  00069	6a 01		 push	 1
  0006b	e8 00 00 00 00	 call	 ?ReadWriteFile@Elevator@GostCrypt@@SAXHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE_KIPAK@Z ; GostCrypt::Elevator::ReadWriteFile

; 475  : 				FilePointerPosition += bytesWritten;

  00070	8b 85 20 fa ff
	ff		 mov	 eax, DWORD PTR _bytesWritten$[ebp]
  00076	83 c4 20	 add	 esp, 32			; 00000020H
  00079	01 46 08	 add	 DWORD PTR [esi+8], eax
  0007c	83 56 0c 00	 adc	 DWORD PTR [esi+12], 0

; 476  : 				throw_sys_if (bytesWritten != size);

  00080	3b c7		 cmp	 eax, edi
  00082	0f 84 f1 00 00
	00		 je	 $LN22@Write
  00088	c7 85 10 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00098	89 85 14 fa ff
	ff		 mov	 DWORD PTR $T4[ebp+4], eax
  0009e	8d 85 10 fa ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  000a4	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN40@Write:
$LN7@Write:

; 477  : 			}
; 478  : 			else
; 479  : 			{
; 480  : 				throw_sys_if (!WriteFile (Handle, buffer, size, &bytesWritten, NULL) || bytesWritten != size);

  000af	6a 00		 push	 0
  000b1	51		 push	 ecx
  000b2	57		 push	 edi
  000b3	50		 push	 eax
  000b4	ff 76 10	 push	 DWORD PTR [esi+16]
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  000bd	85 c0		 test	 eax, eax
  000bf	74 0c		 je	 SHORT $LN15@Write
  000c1	39 bd 20 fa ff
	ff		 cmp	 DWORD PTR _bytesWritten$[ebp], edi
  000c7	0f 84 ac 00 00
	00		 je	 $LN22@Write
$LN15@Write:
  000cd	c7 85 08 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000dd	89 85 0c fa ff
	ff		 mov	 DWORD PTR $T3[ebp+4], eax
  000e3	8d 85 08 fa ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000e9	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN41@Write:
__catch$?Write@File@GostCrypt@@QAEXPAEK@Z$0:

; 481  : 			}
; 482  : 		}
; 483  : 		catch (SystemException &e)
; 484  : 		{
; 485  : 			if (!IsDevice || e.ErrorCode != ERROR_WRITE_PROTECT)

  000f4	8b b5 1c fa ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  000fa	80 7e 14 00	 cmp	 BYTE PTR [esi+20], 0
  000fe	0f 84 93 00 00
	00		 je	 $LN17@Write
  00104	8b 85 04 fa ff
	ff		 mov	 eax, DWORD PTR _e$2[ebp]
  0010a	83 78 04 13	 cmp	 DWORD PTR [eax+4], 19	; 00000013H
  0010e	0f 85 83 00 00
	00		 jne	 $LN17@Write

; 487  : 
; 488  : 			BootEncryption bootEnc (NULL);

  00114	6a 00		 push	 0
  00116	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$5[ebp]
  0011c	e8 00 00 00 00	 call	 ??0BootEncryption@GostCrypt@@QAE@PAUHWND__@@@Z ; GostCrypt::BootEncryption::BootEncryption

; 489  : 
; 490  : 			while (size >= GST_SECTOR_SIZE_BIOS)

  00121	8b 5d 0c	 mov	 ebx, DWORD PTR _size$[ebp]
  00124	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00128	81 fb 00 02 00
	00		 cmp	 ebx, 512		; 00000200H
  0012e	72 38		 jb	 SHORT $LN9@Write

; 487  : 
; 488  : 			BootEncryption bootEnc (NULL);

  00130	8b bd 18 fa ff
	ff		 mov	 edi, DWORD PTR _buffer$GSCopy$[ebp]
  00136	c1 eb 09	 shr	 ebx, 9
  00139	0f 1f 80 00 00
	00 00		 npad	 7
$LL8@Write:

; 491  : 			{
; 492  : 				bootEnc.WriteBootDriveSector (FilePointerPosition, buffer);

  00140	57		 push	 edi
  00141	ff 76 0c	 push	 DWORD PTR [esi+12]
  00144	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$5[ebp]
  0014a	ff 76 08	 push	 DWORD PTR [esi+8]
  0014d	e8 00 00 00 00	 call	 ?WriteBootDriveSector@BootEncryption@GostCrypt@@QAEX_KPAE@Z ; GostCrypt::BootEncryption::WriteBootDriveSector

; 493  : 
; 494  : 				FilePointerPosition += GST_SECTOR_SIZE_BIOS;

  00152	81 46 08 00 02
	00 00		 add	 DWORD PTR [esi+8], 512	; 00000200H
  00159	83 56 0c 00	 adc	 DWORD PTR [esi+12], 0

; 495  : 				buffer += GST_SECTOR_SIZE_BIOS;

  0015d	81 c7 00 02 00
	00		 add	 edi, 512		; 00000200H
  00163	83 eb 01	 sub	 ebx, 1
  00166	75 d8		 jne	 SHORT $LL8@Write
$LN9@Write:

; 496  : 				size -= GST_SECTOR_SIZE_BIOS;
; 497  : 			}
; 498  : 		}

  00168	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$5[ebp]
  0016e	e8 00 00 00 00	 call	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
  00173	b8 00 00 00 00	 mov	 eax, $LN22@Write
  00178	c3		 ret	 0
$LN22@Write:

; 499  : 	}

  00179	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0017c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00183	59		 pop	 ecx
  00184	5f		 pop	 edi
  00185	5e		 pop	 esi
  00186	5b		 pop	 ebx
  00187	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018a	33 cd		 xor	 ecx, ebp
  0018c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00191	8b e5		 mov	 esp, ebp
  00193	5d		 pop	 ebp
  00194	c2 08 00	 ret	 8
$LN17@Write:

; 486  : 				throw;

  00197	6a 00		 push	 0
  00199	6a 00		 push	 0
  0019b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN42@Write:
$LN39@Write:
  001a0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Write@File@GostCrypt@@QAEXPAEK@Z$2:
  00000	8d 8d 24 fa ff
	ff		 lea	 ecx, DWORD PTR _bootEnc$5[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1BootEncryption@GostCrypt@@QAE@XZ ; GostCrypt::BootEncryption::~BootEncryption
__ehhandler$?Write@File@GostCrypt@@QAEXPAEK@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 00 fa ff
	ff		 mov	 ecx, DWORD PTR [edx-1536]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Write@File@GostCrypt@@QAEXPAEK@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Write@File@GostCrypt@@QAEXPAEK@Z ENDP			; GostCrypt::File::Write
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?Read@File@GostCrypt@@QAEKPAEK@Z
_TEXT	SEGMENT
_bytesRead$ = -12					; size = 4
$T1 = -8						; size = 8
_bytesRead$2 = -4					; size = 4
_buffer$ = 8						; size = 4
_size$ = 12						; size = 4
?Read@File@GostCrypt@@QAEKPAEK@Z PROC			; GostCrypt::File::Read, COMDAT
; _this$ = ecx

; 421  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 422  : 		DWORD bytesRead;
; 423  : 
; 424  : 		if (Elevated)

  00009	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000c	74 34		 je	 SHORT $LN4@Read

; 425  : 		{
; 426  : 			DWORD bytesRead;
; 427  : 
; 428  : 			Elevator::ReadWriteFile (false, IsDevice, Path, buffer, FilePointerPosition, size, &bytesRead);

  0000e	8d 45 fc	 lea	 eax, DWORD PTR _bytesRead$2[ebp]
  00011	50		 push	 eax
  00012	ff 75 0c	 push	 DWORD PTR _size$[ebp]
  00015	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  00018	ff 76 0c	 push	 DWORD PTR [esi+12]
  0001b	ff 76 08	 push	 DWORD PTR [esi+8]
  0001e	ff 75 08	 push	 DWORD PTR _buffer$[ebp]
  00021	50		 push	 eax
  00022	0f b6 46 14	 movzx	 eax, BYTE PTR [esi+20]
  00026	50		 push	 eax
  00027	6a 00		 push	 0
  00029	e8 00 00 00 00	 call	 ?ReadWriteFile@Elevator@GostCrypt@@SAXHHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE_KIPAK@Z ; GostCrypt::Elevator::ReadWriteFile

; 429  : 			FilePointerPosition += bytesRead;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _bytesRead$2[ebp]
  00031	83 c4 20	 add	 esp, 32			; 00000020H
  00034	01 46 08	 add	 DWORD PTR [esi+8], eax
  00037	83 56 0c 00	 adc	 DWORD PTR [esi+12], 0
  0003b	5e		 pop	 esi

; 435  : 	}

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN4@Read:

; 430  : 			return bytesRead;
; 431  : 		}
; 432  : 
; 433  : 		throw_sys_if (!ReadFile (Handle, buffer, size, &bytesRead, NULL));

  00042	6a 00		 push	 0
  00044	8d 45 f4	 lea	 eax, DWORD PTR _bytesRead$[ebp]
  00047	50		 push	 eax
  00048	ff 75 0c	 push	 DWORD PTR _size$[ebp]
  0004b	ff 75 08	 push	 DWORD PTR _buffer$[ebp]
  0004e	ff 76 10	 push	 DWORD PTR [esi+16]
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  00057	85 c0		 test	 eax, eax
  00059	74 0a		 je	 SHORT $LN14@Read

; 434  : 		return bytesRead;

  0005b	8b 45 f4	 mov	 eax, DWORD PTR _bytesRead$[ebp]
  0005e	5e		 pop	 esi

; 435  : 	}

  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN14@Read:

; 430  : 			return bytesRead;
; 431  : 		}
; 432  : 
; 433  : 		throw_sys_if (!ReadFile (Handle, buffer, size, &bytesRead, NULL));

  00065	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00072	89 45 fc	 mov	 DWORD PTR $T1[ebp+4], eax
  00075	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  00078	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN16@Read:
$LN13@Read:
  00083	cc		 int	 3
?Read@File@GostCrypt@@QAEKPAEK@Z ENDP			; GostCrypt::File::Read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ?Close@File@GostCrypt@@QAEXXZ
_TEXT	SEGMENT
?Close@File@GostCrypt@@QAEXXZ PROC			; GostCrypt::File::Close, COMDAT
; _this$ = ecx

; 400  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 401  : 		if (FileOpen)

  00003	80 7e 01 00	 cmp	 BYTE PTR [esi+1], 0
  00007	74 12		 je	 SHORT $LN2@Close

; 402  : 		{
; 403  : 			if (!Elevated)

  00009	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000c	75 09		 jne	 SHORT $LN3@Close

; 404  : 				CloseHandle (Handle);

  0000e	ff 76 10	 push	 DWORD PTR [esi+16]
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN3@Close:

; 405  : 
; 406  : 			FileOpen = false;

  00017	c6 46 01 00	 mov	 BYTE PTR [esi+1], 0
$LN2@Close:
  0001b	5e		 pop	 esi

; 407  : 		}
; 408  : 	}

  0001c	c3		 ret	 0
?Close@File@GostCrypt@@QAEXXZ ENDP			; GostCrypt::File::Close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.h
;	COMDAT ??1File@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??1File@GostCrypt@@QAE@XZ PROC				; GostCrypt::File::~File, COMDAT
; _this$ = ecx

; 27   : 		~File () { Close(); }

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	80 7e 01 00	 cmp	 BYTE PTR [esi+1], 0
  00007	74 12		 je	 SHORT $LN4@File
  00009	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000c	75 09		 jne	 SHORT $LN5@File
  0000e	ff 76 10	 push	 DWORD PTR [esi+16]
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN5@File:
  00017	c6 46 01 00	 mov	 BYTE PTR [esi+1], 0
$LN4@File:
  0001b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0001e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00021	72 0d		 jb	 SHORT $LN13@File
  00023	40		 inc	 eax
  00024	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  00027	50		 push	 eax
  00028	ff 76 18	 push	 DWORD PTR [esi+24]
  0002b	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN13@File:
  00030	c7 46 2c 0f 00
	00 00		 mov	 DWORD PTR [esi+44], 15	; 0000000fH
  00037	83 7e 2c 10	 cmp	 DWORD PTR [esi+44], 16	; 00000010H
  0003b	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00042	72 08		 jb	 SHORT $LN101@File
  00044	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00047	5e		 pop	 esi
  00048	c6 00 00	 mov	 BYTE PTR [eax], 0
  0004b	c3		 ret	 0
$LN101@File:
  0004c	c6 46 18 00	 mov	 BYTE PTR [esi+24], 0
  00050	5e		 pop	 esi
  00051	c3		 ret	 0
??1File@GostCrypt@@QAE@XZ ENDP				; GostCrypt::File::~File
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.cpp
;	COMDAT ??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T2 = -28						; size = 8
_this$GSCopy$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_path$ = 8						; size = 24
_readOnly$ = 32						; size = 1
_create$ = 36						; size = 1
??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z PROC ; GostCrypt::File::File, COMDAT
; _this$ = ecx

; 368  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e0	 mov	 DWORD PTR _this$[ebp], esi
  00030	8a 55 20	 mov	 dl, BYTE PTR _readOnly$[ebp]
  00033	8a 5d 24	 mov	 bl, BYTE PTR _create$[ebp]
  00036	89 75 ec	 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  00039	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  0003c	66 c7 06 00 00	 mov	 WORD PTR [esi], 0
  00041	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH
  00048	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  0004f	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00053	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0005a	72 02		 jb	 SHORT $LN117@File
  0005c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN117@File:
  0005e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 369  : 		Handle = CreateFile (path.c_str(),

  00061	83 7d 1c 10	 cmp	 DWORD PTR _path$[ebp+20], 16 ; 00000010H
  00065	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  00068	6a 00		 push	 0
  0006a	0f 43 4d 08	 cmovae	 ecx, DWORD PTR _path$[ebp]
  0006e	bf 00 00 00 80	 mov	 edi, -2147483648	; 80000000H
  00073	33 c0		 xor	 eax, eax
  00075	84 db		 test	 bl, bl
  00077	68 00 00 00 90	 push	 -1879048192		; 90000000H
  0007c	0f 94 c0	 sete	 al
  0007f	83 c0 02	 add	 eax, 2
  00082	84 d2		 test	 dl, dl
  00084	50		 push	 eax
  00085	6a 00		 push	 0
  00087	6a 03		 push	 3
  00089	b8 00 00 00 c0	 mov	 eax, -1073741824	; c0000000H
  0008e	0f 45 c7	 cmovne	 eax, edi
  00091	50		 push	 eax
  00092	51		 push	 ecx
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00099	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 370  : 			readOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
; 371  : 			FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, create ? CREATE_ALWAYS : OPEN_EXISTING,
; 372  : 			FILE_FLAG_RANDOM_ACCESS | FILE_FLAG_WRITE_THROUGH, NULL);
; 373  : 
; 374  : 		try

  0009c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 375  : 		{
; 376  : 			throw_sys_if (Handle == INVALID_HANDLE_VALUE);

  000a0	83 f8 ff	 cmp	 eax, -1
  000a3	75 41		 jne	 SHORT $LN2@File
  000a5	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7SystemException@GostCrypt@@6B@
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000b2	89 45 e8	 mov	 DWORD PTR $T2[ebp+4], eax
  000b5	8d 45 e4	 lea	 eax, DWORD PTR $T2[ebp]
  000b8	68 00 00 00 00	 push	 OFFSET __TI2?AUSystemException@GostCrypt@@
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN379@File:
__catch$??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z$0:

; 377  : 		}
; 378  : 		catch (SystemException &)
; 379  : 		{
; 380  : 			if (GetLastError() == ERROR_ACCESS_DENIED && IsUacSupported())

  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000c9	83 f8 05	 cmp	 eax, 5
  000cc	75 74		 jne	 SHORT $LN7@File
  000ce	e8 00 00 00 00	 call	 _IsUacSupported
  000d3	85 c0		 test	 eax, eax
  000d5	74 6b		 je	 SHORT $LN7@File

; 381  : 				Elevated = true;

  000d7	8b 45 ec	 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  000da	c6 00 01	 mov	 BYTE PTR [eax], 1

; 384  : 		}

  000dd	b8 00 00 00 00	 mov	 eax, $LN15@File
  000e2	c3		 ret	 0
$LN15@File:
  000e3	8b 75 ec	 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
$LN2@File:

; 385  : 
; 386  : 		FileOpen = true;
; 387  : 		FilePointerPosition = 0;
; 388  : 		IsDevice = false;
; 389  : 		Path = path;

  000e6	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  000e9	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  000f0	8d 45 08	 lea	 eax, DWORD PTR _path$[ebp]
  000f3	c6 46 01 01	 mov	 BYTE PTR [esi+1], 1
  000f7	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  000fe	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00105	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  00109	3b c8		 cmp	 ecx, eax
  0010b	74 0a		 je	 SHORT $LN146@File
  0010d	6a ff		 push	 -1
  0010f	6a 00		 push	 0
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN146@File:

; 390  : 	}

  00117	8b 4d 1c	 mov	 ecx, DWORD PTR _path$[ebp+20]
  0011a	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0011d	72 0d		 jb	 SHORT $LN282@File
  0011f	41		 inc	 ecx
  00120	51		 push	 ecx
  00121	ff 75 08	 push	 DWORD PTR _path$[ebp]
  00124	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  00127	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN282@File:
  0012c	8b c6		 mov	 eax, esi
  0012e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00131	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00138	59		 pop	 ecx
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 20 00	 ret	 32			; 00000020H
$LN7@File:

; 382  : 			else
; 383  : 				throw;

  00142	6a 00		 push	 0
  00144	6a 00		 push	 0
  00146	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN380@File:
$LN378@File:
  0014b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z$2:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _path$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z$3:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0000b	83 c1 18	 add	 ecx, 24			; 00000018H
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0File@GostCrypt@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z ENDP ; GostCrypt::File::File
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\bootencryption.h
;	COMDAT ??0File@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0File@GostCrypt@@QAE@XZ PROC				; GostCrypt::File::File, COMDAT
; _this$ = ecx

; 25   : 		File () : FileOpen (false) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c6 41 01 00	 mov	 BYTE PTR [ecx+1], 0
  00008	8b c1		 mov	 eax, ecx
  0000a	c7 41 2c 0f 00
	00 00		 mov	 DWORD PTR [ecx+44], 15	; 0000000fH
  00011	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
  00018	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001b	c6 41 18 00	 mov	 BYTE PTR [ecx+24], 0
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??0File@GostCrypt@@QAE@XZ ENDP				; GostCrypt::File::File
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0UserAbort@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0UserAbort@GostCrypt@@QAE@ABU01@@Z PROC		; GostCrypt::UserAbort::UserAbort, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7UserAbort@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c2 04 00	 ret	 4
??0UserAbort@GostCrypt@@QAE@ABU01@@Z ENDP		; GostCrypt::UserAbort::UserAbort
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ?Show@UserAbort@GostCrypt@@UBEXPAUHWND__@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
?Show@UserAbort@GostCrypt@@UBEXPAUHWND__@@@Z PROC	; GostCrypt::UserAbort::Show, COMDAT
; _this$ = ecx

; 74   : 		void Show (HWND parent) const { }

  00000	c2 04 00	 ret	 4
?Show@UserAbort@GostCrypt@@UBEXPAUHWND__@@@Z ENDP	; GostCrypt::UserAbort::Show
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ??0UserAbort@GostCrypt@@QAE@PBD@Z
_TEXT	SEGMENT
_srcPos$ = 8						; size = 4
??0UserAbort@GostCrypt@@QAE@PBD@Z PROC			; GostCrypt::UserAbort::UserAbort, COMDAT
; _this$ = ecx

; 73   : 		UserAbort (const char *srcPos) { }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7UserAbort@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c2 04 00	 ret	 4
??0UserAbort@GostCrypt@@QAE@PBD@Z ENDP			; GostCrypt::UserAbort::UserAbort
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0TimeOut@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0TimeOut@GostCrypt@@QAE@ABU01@@Z PROC			; GostCrypt::TimeOut::TimeOut, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7TimeOut@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c2 04 00	 ret	 4
??0TimeOut@GostCrypt@@QAE@ABU01@@Z ENDP			; GostCrypt::TimeOut::TimeOut
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ?Show@TimeOut@GostCrypt@@UBEXPAUHWND__@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
?Show@TimeOut@GostCrypt@@UBEXPAUHWND__@@@Z PROC		; GostCrypt::TimeOut::Show, COMDAT
; _this$ = ecx

; 68   : 		void Show (HWND parent) const { ErrorDirect (L"Timeout"); }

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_1BA@BKONPLFM@?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@
  00005	e8 00 00 00 00	 call	 _ErrorDirect
  0000a	59		 pop	 ecx
  0000b	c2 04 00	 ret	 4
?Show@TimeOut@GostCrypt@@UBEXPAUHWND__@@@Z ENDP		; GostCrypt::TimeOut::Show
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ??0TimeOut@GostCrypt@@QAE@PBD@Z
_TEXT	SEGMENT
_srcPos$ = 8						; size = 4
??0TimeOut@GostCrypt@@QAE@PBD@Z PROC			; GostCrypt::TimeOut::TimeOut, COMDAT
; _this$ = ecx

; 67   : 		TimeOut (const char *srcPos) { }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7TimeOut@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c2 04 00	 ret	 4
??0TimeOut@GostCrypt@@QAE@PBD@Z ENDP			; GostCrypt::TimeOut::TimeOut
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2355 : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 2356 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;

  0002d	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00030	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00037	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0003e	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00045	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00049	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00050	72 04		 jb	 SHORT $LN105@operator
  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	eb 02		 jmp	 SHORT $LN106@operator
$LN105@operator:
  00056	8b c6		 mov	 eax, esi
$LN106@operator:
  00058	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2360 : 	return (_Ans);

  0005b	8b 7d 10	 mov	 edi, DWORD PTR __Right$[ebp]
  0005e	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  00061	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  0006f	80 3f 00	 cmp	 BYTE PTR [edi], 0
  00072	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  00075	75 04		 jne	 SHORT $LN126@operator

; 2357 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));

  00077	33 c9		 xor	 ecx, ecx
  00079	eb 0e		 jmp	 SHORT $LN127@operator
$LN126@operator:
  0007b	8b cf		 mov	 ecx, edi
  0007d	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL188@operator:
  00080	8a 01		 mov	 al, BYTE PTR [ecx]
  00082	41		 inc	 ecx
  00083	84 c0		 test	 al, al
  00085	75 f9		 jne	 SHORT $LL188@operator
  00087	2b ca		 sub	 ecx, edx
$LN127@operator:
  00089	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  0008c	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  0008f	3b d8		 cmp	 ebx, eax
  00091	77 26		 ja	 SHORT $LN174@operator
  00093	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  00096	74 21		 je	 SHORT $LN174@operator
  00098	6a 01		 push	 1
  0009a	50		 push	 eax
  0009b	8b ce		 mov	 ecx, esi
  0009d	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  000a2	84 c0		 test	 al, al
  000a4	74 13		 je	 SHORT $LN174@operator
  000a6	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000aa	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000ad	72 04		 jb	 SHORT $LN169@operator
  000af	8b 06		 mov	 eax, DWORD PTR [esi]
  000b1	eb 02		 jmp	 SHORT $LN170@operator
$LN169@operator:
  000b3	8b c6		 mov	 eax, esi
$LN170@operator:
  000b5	c6 04 18 00	 mov	 BYTE PTR [eax+ebx], 0
$LN174@operator:

; 2358 : 	_Ans += _Left;

  000b9	6a ff		 push	 -1
  000bb	6a 00		 push	 0
  000bd	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  000c0	8b ce		 mov	 ecx, esi
  000c2	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2359 : 	_Ans += _Right;

  000c7	80 3f 00	 cmp	 BYTE PTR [edi], 0
  000ca	75 04		 jne	 SHORT $LN186@operator
  000cc	33 c9		 xor	 ecx, ecx
  000ce	eb 0e		 jmp	 SHORT $LN187@operator
$LN186@operator:
  000d0	8b cf		 mov	 ecx, edi
  000d2	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL189@operator:
  000d5	8a 01		 mov	 al, BYTE PTR [ecx]
  000d7	41		 inc	 ecx
  000d8	84 c0		 test	 al, al
  000da	75 f9		 jne	 SHORT $LL189@operator
  000dc	2b ca		 sub	 ecx, edx
$LN187@operator:
  000de	51		 push	 ecx
  000df	57		 push	 edi
  000e0	8b ce		 mov	 ecx, esi
  000e2	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2360 : 	return (_Ans);

  000e7	8b c6		 mov	 eax, esi

; 2361 : 	}

  000e9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ec	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f3	59		 pop	 ecx
  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@operator
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@operator:
  00018	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2439 : 	{	// return string + NTCS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2440 : 	return (_STD move(_Left.append(_Right)));

  00004	8b 55 10	 mov	 edx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000f	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00012	75 04		 jne	 SHORT $LN9@operator
  00014	33 c0		 xor	 eax, eax
  00016	eb 11		 jmp	 SHORT $LN10@operator
$LN9@operator:
  00018	8b c2		 mov	 eax, edx
  0001a	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0001d	0f 1f 00	 npad	 3
$LL139@operator:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL139@operator
  00027	2b c6		 sub	 eax, esi
$LN10@operator:
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  0002c	50		 push	 eax
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00033	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00036	8b ce		 mov	 ecx, esi
  00038	50		 push	 eax
  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00040	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00047	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004a	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0004f	8b c6		 mov	 eax, esi
  00051	5e		 pop	 esi

; 2441 : 	}

  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2417 : 	{	// return NTCS + string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2418 : 	return (_STD move(_Right.insert(0, _Left)));

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Left$[ebp]
  00007	56		 push	 esi
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000f	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00012	75 04		 jne	 SHORT $LN9@operator
  00014	33 c0		 xor	 eax, eax
  00016	eb 11		 jmp	 SHORT $LN10@operator
$LN9@operator:
  00018	8b c2		 mov	 eax, edx
  0001a	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0001d	0f 1f 00	 npad	 3
$LL139@operator:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL139@operator
  00027	2b c6		 sub	 eax, esi
$LN10@operator:
  00029	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002c	50		 push	 eax
  0002d	52		 push	 edx
  0002e	6a 00		 push	 0
  00030	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00035	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00038	8b ce		 mov	 ecx, esi
  0003a	50		 push	 eax
  0003b	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00042	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00049	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004c	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  00051	8b c6		 mov	 eax, esi
  00053	5e		 pop	 esi

; 2419 : 	}

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z PROC	; GostCrypt::ParameterIncorrect::ParameterIncorrect, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0ParameterIncorrect@GostCrypt@@QAE@ABU01@@Z ENDP	; GostCrypt::ParameterIncorrect::ParameterIncorrect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z
_TEXT	SEGMENT
_msgBody$ = -88						; size = 24
$T2 = -64						; size = 24
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_parent$ = 8						; size = 4
?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z PROC ; GostCrypt::ParameterIncorrect::Show, COMDAT
; _this$ = ecx

; 57   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 58   : 			string msgBody = "Parameter incorrect.\n\n\n(If you report a bug in connection with this, please include the following technical information in the bug report:\n" + string (SrcPos) + ")";

  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	8b 7d 08	 mov	 edi, DWORD PTR _parent$[ebp]
  00030	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
  00037	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0
  0003e	c6 45 d8 00	 mov	 BYTE PTR $T3[ebp], 0
  00042	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00045	75 04		 jne	 SHORT $LN116@Show
  00047	33 c9		 xor	 ecx, ecx
  00049	eb 0e		 jmp	 SHORT $LN117@Show
$LN116@Show:
  0004b	8b ca		 mov	 ecx, edx
  0004d	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL438@Show:
  00050	8a 01		 mov	 al, BYTE PTR [ecx]
  00052	41		 inc	 ecx
  00053	84 c0		 test	 al, al
  00055	75 f9		 jne	 SHORT $LL438@Show
  00057	2b ce		 sub	 ecx, esi
$LN117@Show:
  00059	51		 push	 ecx
  0005a	52		 push	 edx
  0005b	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  0005e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00063	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  00066	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006d	50		 push	 eax
  0006e	8d 45 c0	 lea	 eax, DWORD PTR $T2[ebp]
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0IM@CKBKFPJM@Parameter?5incorrect?4?6?6?6?$CIIf?5you?5r@
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_01PKGAHCOL@?$CJ?$AA@
  00081	50		 push	 eax
  00082	8d 45 a8	 lea	 eax, DWORD PTR _msgBody$[ebp]
  00085	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0008f	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp+20]
  00092	83 c4 18	 add	 esp, 24			; 00000018H
  00095	83 f8 10	 cmp	 eax, 16			; 00000010H
  00098	72 0d		 jb	 SHORT $LN124@Show
  0009a	40		 inc	 eax
  0009b	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  0009e	50		 push	 eax
  0009f	ff 75 c0	 push	 DWORD PTR $T2[ebp]
  000a2	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN124@Show:
  000a7	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp+20]
  000aa	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
  000b1	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0
  000b8	c6 45 c0 00	 mov	 BYTE PTR $T2[ebp], 0
  000bc	83 f8 10	 cmp	 eax, 16			; 00000010H
  000bf	72 0d		 jb	 SHORT $LN225@Show
  000c1	40		 inc	 eax
  000c2	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  000c5	50		 push	 eax
  000c6	ff 75 d8	 push	 DWORD PTR $T3[ebp]
  000c9	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN225@Show:

; 59   : 			MessageBox (parent, msgBody.c_str(), "GostCrypt", MB_ICONERROR | MB_SETFOREGROUND);

  000ce	83 7d bc 10	 cmp	 DWORD PTR _msgBody$[ebp+20], 16 ; 00000010H
  000d2	8d 45 a8	 lea	 eax, DWORD PTR _msgBody$[ebp]
  000d5	68 10 00 01 00	 push	 65552			; 00010010H
  000da	0f 43 45 a8	 cmovae	 eax, DWORD PTR _msgBody$[ebp]
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_09NKHKFHLH@GostCrypt?$AA@
  000e3	50		 push	 eax
  000e4	57		 push	 edi
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 60   : 		}

  000eb	8b 45 bc	 mov	 eax, DWORD PTR _msgBody$[ebp+20]
  000ee	83 f8 10	 cmp	 eax, 16			; 00000010H
  000f1	72 0d		 jb	 SHORT $LN343@Show
  000f3	40		 inc	 eax
  000f4	8d 4d a8	 lea	 ecx, DWORD PTR _msgBody$[ebp]
  000f7	50		 push	 eax
  000f8	ff 75 a8	 push	 DWORD PTR _msgBody$[ebp]
  000fb	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN343@Show:
  00100	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00103	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010a	59		 pop	 ecx
  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00110	33 cd		 xor	 ecx, ebp
  00112	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z$1:
  00008	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Show@ParameterIncorrect@GostCrypt@@UBEXPAUHWND__@@@Z ENDP ; GostCrypt::ParameterIncorrect::Show
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ??0ParameterIncorrect@GostCrypt@@QAE@PBD@Z
_TEXT	SEGMENT
_srcPos$ = 8						; size = 4
??0ParameterIncorrect@GostCrypt@@QAE@PBD@Z PROC		; GostCrypt::ParameterIncorrect::ParameterIncorrect, COMDAT
; _this$ = ecx

; 54   : 		ParameterIncorrect (const char *srcPos) : SrcPos (srcPos) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _srcPos$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00009	8b c1		 mov	 eax, ecx
  0000b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ParameterIncorrect@GostCrypt@@6B@
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0ParameterIncorrect@GostCrypt@@QAE@PBD@Z ENDP		; GostCrypt::ParameterIncorrect::ParameterIncorrect
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0ErrorException@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0ErrorException@GostCrypt@@QAE@ABU01@@Z PROC		; GostCrypt::ErrorException::ErrorException, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	6a ff		 push	 -1
  0000c	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0000f	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ErrorException@GostCrypt@@6B@
  00018	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001b	83 c2 08	 add	 edx, 8
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	33 c0		 xor	 eax, eax
  00023	50		 push	 eax
  00024	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  0002b	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00032	52		 push	 edx
  00033	66 89 01	 mov	 WORD PTR [ecx], ax
  00036	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0003b	8b c6		 mov	 eax, esi
  0003d	5e		 pop	 esi
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0ErrorException@GostCrypt@@QAE@ABU01@@Z ENDP		; GostCrypt::ErrorException::ErrorException
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1ErrorException@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??1ErrorException@GostCrypt@@QAE@XZ PROC		; GostCrypt::ErrorException::~ErrorException, COMDAT
; _this$ = ecx
  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00003	56		 push	 esi
  00004	8d 71 08	 lea	 esi, DWORD PTR [ecx+8]
  00007	83 f8 08	 cmp	 eax, 8
  0000a	72 0b		 jb	 SHORT $LN9@ErrorExcep
  0000c	40		 inc	 eax
  0000d	8b ce		 mov	 ecx, esi
  0000f	50		 push	 eax
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN9@ErrorExcep:
  00017	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0001e	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00022	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00029	72 09		 jb	 SHORT $LN99@ErrorExcep
  0002b	8b 06		 mov	 eax, DWORD PTR [esi]
  0002d	33 c9		 xor	 ecx, ecx
  0002f	5e		 pop	 esi
  00030	66 89 08	 mov	 WORD PTR [eax], cx
  00033	c3		 ret	 0
$LN99@ErrorExcep:
  00034	33 c0		 xor	 eax, eax
  00036	66 89 06	 mov	 WORD PTR [esi], ax
  00039	5e		 pop	 esi
  0003a	c3		 ret	 0
??1ErrorException@GostCrypt@@QAE@XZ ENDP		; GostCrypt::ErrorException::~ErrorException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ?Show@ErrorException@GostCrypt@@UBEXPAUHWND__@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
?Show@ErrorException@GostCrypt@@UBEXPAUHWND__@@@Z PROC	; GostCrypt::ErrorException::Show, COMDAT
; _this$ = ecx

; 42   : 			if (ErrMsg.empty())

  00000	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  00004	75 0e		 jne	 SHORT $LN2@Show

; 43   : 				::Error (ErrLangId);

  00006	ff 71 04	 push	 DWORD PTR [ecx+4]
  00009	e8 00 00 00 00	 call	 _Error
  0000e	83 c4 04	 add	 esp, 4

; 46   : 		}

  00011	c2 04 00	 ret	 4
$LN2@Show:

; 44   : 			else
; 45   : 				::ErrorDirect (ErrMsg.c_str());

  00014	83 79 1c 08	 cmp	 DWORD PTR [ecx+28], 8
  00018	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  0001b	72 02		 jb	 SHORT $LN31@Show
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN31@Show:
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _ErrorDirect
  00025	59		 pop	 ecx

; 46   : 		}

  00026	c2 04 00	 ret	 4
?Show@ErrorException@GostCrypt@@UBEXPAUHWND__@@@Z ENDP	; GostCrypt::ErrorException::Show
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ??0ErrorException@GostCrypt@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_errMsg$ = 8						; size = 4
??0ErrorException@GostCrypt@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; GostCrypt::ErrorException::ErrorException, COMDAT
; _this$ = ecx

; 38   : 		ErrorException (const wstring &errMsg) : ErrMsg (errMsg) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	33 c0		 xor	 eax, eax
  00009	6a ff		 push	 -1
  0000b	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0000e	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00011	50		 push	 eax
  00012	ff 75 08	 push	 DWORD PTR _errMsg$[ebp]
  00015	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ErrorException@GostCrypt@@6B@
  0001b	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  00022	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00029	66 89 01	 mov	 WORD PTR [ecx], ax
  0002c	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
??0ErrorException@GostCrypt@@QAE@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; GostCrypt::ErrorException::ErrorException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ??0ErrorException@GostCrypt@@QAE@PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_langId$ = 8						; size = 4
??0ErrorException@GostCrypt@@QAE@PAD@Z PROC		; GostCrypt::ErrorException::ErrorException, COMDAT
; _this$ = ecx

; 37   : 		ErrorException (char *langId) : ErrLangId (langId) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 45 08	 mov	 eax, DWORD PTR _langId$[ebp]
  00007	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000a	33 c0		 xor	 eax, eax
  0000c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ErrorException@GostCrypt@@6B@
  00012	c7 41 1c 07 00
	00 00		 mov	 DWORD PTR [ecx+28], 7
  00019	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00020	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
  00024	8b c1		 mov	 eax, ecx
  00026	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??0ErrorException@GostCrypt@@QAE@PAD@Z ENDP		; GostCrypt::ErrorException::ErrorException
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SystemException@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0SystemException@GostCrypt@@QAE@ABU01@@Z PROC		; GostCrypt::SystemException::SystemException, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7SystemException@GostCrypt@@6B@
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0SystemException@GostCrypt@@QAE@ABU01@@Z ENDP		; GostCrypt::SystemException::SystemException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ?Show@SystemException@GostCrypt@@UBEXPAUHWND__@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
?Show@SystemException@GostCrypt@@UBEXPAUHWND__@@@Z PROC	; GostCrypt::SystemException::Show, COMDAT
; _this$ = ecx

; 27   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   : 			SetLastError (ErrorCode);

  00003	ff 71 04	 push	 DWORD PTR [ecx+4]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 29   : 			handleWin32Error (parent);

  0000c	ff 75 08	 push	 DWORD PTR _parent$[ebp]
  0000f	e8 00 00 00 00	 call	 _handleWin32Error
  00014	83 c4 04	 add	 esp, 4

; 30   : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?Show@SystemException@GostCrypt@@UBEXPAUHWND__@@@Z ENDP	; GostCrypt::SystemException::Show
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\exception.h
;	COMDAT ??0SystemException@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??0SystemException@GostCrypt@@QAE@XZ PROC		; GostCrypt::SystemException::SystemException, COMDAT
; _this$ = ecx

; 24   : 		SystemException () : ErrorCode (GetLastError()) { }

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7SystemException@GostCrypt@@6B@
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0000f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00012	8b c6		 mov	 eax, esi
  00014	5e		 pop	 esi
  00015	c3		 ret	 0
??0SystemException@GostCrypt@@QAE@XZ ENDP		; GostCrypt::SystemException::SystemException
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0Exception@GostCrypt@@QAE@ABU01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0Exception@GostCrypt@@QAE@ABU01@@Z PROC		; GostCrypt::Exception::Exception, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Exception@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c2 04 00	 ret	 4
??0Exception@GostCrypt@@QAE@ABU01@@Z ENDP		; GostCrypt::Exception::Exception
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0Exception@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??0Exception@GostCrypt@@QAE@XZ PROC			; GostCrypt::Exception::Exception, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Exception@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0Exception@GostCrypt@@QAE@XZ ENDP			; GostCrypt::Exception::Exception
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F_AtlWinModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlWinModule'', COMDAT
  00000	ff 35 04 00 00
	00		 push	 DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
  00006	68 00 00 00 00	 push	 OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  0000b	e8 00 00 00 00	 call	 ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
  00010	a1 20 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
  00015	85 c0		 test	 eax, eax
  00017	74 13		 je	 SHORT $LN29@dynamic
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _free
  0001f	83 c4 04	 add	 esp, 4
  00022	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32, 0
$LN29@dynamic:
  0002c	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+40, 0
  00036	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36, 0
  00040	c3		 ret	 0
??__F_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlWinModule''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlWinModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlWinModule'', COMDAT

; 2815 : __declspec(selectany) CAtlWinModule _AtlWinModule;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  00005	e8 00 00 00 00	 call	 ??0CAtlWinModule@ATL@@QAE@XZ ; ATL::CAtlWinModule::CAtlWinModule
  0000a	68 00 00 00 00	 push	 OFFSET ??__F_AtlWinModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlWinModule''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__E_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlWinModule''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlWinModule@ATL@@QAEXXZ PROC			; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2800 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

  00000	ff 35 04 00 00
	00		 push	 DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
  00006	51		 push	 ecx
  00007	e8 00 00 00 00	 call	 ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2801 : 	}

  0000c	c3		 ret	 0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2794 : 	{

  00000	56		 push	 esi

; 2795 : 		Term();

  00001	ff 35 04 00 00
	00		 push	 DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
  00007	8b f1		 mov	 esi, ecx
  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2796 : 	}

  0000f	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00012	85 c0		 test	 eax, eax
  00014	74 10		 je	 SHORT $LN26@CAtlWinMod
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _free
  0001c	83 c4 04	 add	 esp, 4
  0001f	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
$LN26@CAtlWinMod:
  00026	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  0002d	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  00034	5e		 pop	 esi
  00035	c3		 ret	 0
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2780 : 	CAtlWinModule()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	0f 57 c0	 xorps	 xmm0, xmm0

; 2781 : 	{

  0000a	0f 11 46 04	 movups	 XMMWORD PTR [esi+4], xmm0
  0000e	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00011	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00014	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0

; 2782 : 		cbSize = sizeof(_ATL_WIN_MODULE);
; 2783 : 		HRESULT hr = AtlWinModuleInit(this);

  00019	6a 00		 push	 0
  0001b	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  00022	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  00029	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00030	50		 push	 eax
  00031	c7 06 2c 00 00
	00		 mov	 DWORD PTR [esi], 44	; 0000002cH
  00037	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8
  00044	85 c0		 test	 eax, eax
  00046	75 2a		 jne	 SHORT $LN26@CAtlWinMod
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0004e	85 c0		 test	 eax, eax
  00050	7e 0a		 jle	 SHORT $LN27@CAtlWinMod
  00052	0f b7 c0	 movzx	 eax, ax
  00055	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H

; 2784 : 		if (FAILED(hr))

  0005a	85 c0		 test	 eax, eax
$LN27@CAtlWinMod:

; 2789 : 			return;
; 2790 : 		}
; 2791 : 	}

  0005c	8b c6		 mov	 eax, esi

; 2784 : 		if (FAILED(hr))

  0005e	79 14		 jns	 SHORT $LN2@CAtlWinMod

; 2785 : 		{
; 2786 : 			ATLASSERT(0);
; 2787 : 			CAtlBaseModule::m_bInitFailed = true;

  00060	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2788 : 			cbSize = 0;

  00067	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0006d	5e		 pop	 esi

; 2789 : 			return;
; 2790 : 		}
; 2791 : 	}

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
$LN26@CAtlWinMod:
  00072	8b c6		 mov	 eax, esi
$LN2@CAtlWinMod:
  00074	5e		 pop	 esi
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F_AtlComModule@ATL@@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__F_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlComModule'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??__F_AtlComModule@ATL@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  00027	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002e	e8 00 00 00 00	 call	 ?Term@CAtlComModule@ATL@@QAEXXZ ; ATL::CAtlComModule::Term
  00033	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  00038	e8 00 00 00 00	 call	 ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00040	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00047	59		 pop	 ecx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__F_AtlComModule@ATL@@YAXXZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??__F_AtlComModule@ATL@@YAXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??__F_AtlComModule@ATL@@YAXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??__F_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlComModule''
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlComModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlComModule'', COMDAT

; 2559 : __declspec(selectany) CAtlComModule _AtlComModule;

  00000	6a 00		 push	 0
  00002	68 10 00 00 00	 push	 OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A+16
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8
  0000d	85 c0		 test	 eax, eax
  0000f	75 29		 jne	 SHORT $LN4@dynamic
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00017	85 c0		 test	 eax, eax
  00019	7e 0a		 jle	 SHORT $LN20@dynamic
  0001b	0f b7 c0	 movzx	 eax, ax
  0001e	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
  00023	85 c0		 test	 eax, eax
$LN20@dynamic:
  00025	79 13		 jns	 SHORT $LN4@dynamic
  00027	68 00 00 00 00	 push	 OFFSET ??__F_AtlComModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlComModule''
  0002c	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
  00033	e8 00 00 00 00	 call	 _atexit
  00038	59		 pop	 ecx
  00039	c3		 ret	 0
$LN4@dynamic:
  0003a	68 00 00 00 00	 push	 OFFSET ??__F_AtlComModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlComModule''
  0003f	c7 05 00 00 00
	00 28 00 00 00	 mov	 DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A, 40 ; 00000028H
  00049	e8 00 00 00 00	 call	 _atexit
  0004e	59		 pop	 ecx
  0004f	c3		 ret	 0
??__E_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlComModule''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlComModule@ATL@@QAEXXZ PROC			; ATL::CAtlComModule::Term, COMDAT
; _this$ = ecx

; 2456 : 	{

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 2457 : 		if (cbSize == 0)

  00003	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00006	74 46		 je	 SHORT $LN1@Term

; 2458 : 			return;
; 2459 : 
; 2460 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  00008	56		 push	 esi
  00009	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  0000c	3b 77 0c	 cmp	 esi, DWORD PTR [edi+12]
  0000f	73 2c		 jae	 SHORT $LN3@Term
  00011	53		 push	 ebx
$LL4@Term:

; 2461 : 		{
; 2462 : 			if (*ppEntry != NULL)

  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	85 c0		 test	 eax, eax
  00016	74 1c		 je	 SHORT $LN2@Term

; 2463 : 			{
; 2464 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

  00018	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]

; 2465 : 				
; 2466 : 				if (pCache->pCF != NULL)

  0001b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0001d	85 c0		 test	 eax, eax
  0001f	74 13		 je	 SHORT $LN2@Term

; 2467 : 				{
; 2468 : 					// Decode factory pointer if it's not null
; 2469 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DecodePointer@4

; 2470 : 					_Analysis_assume_(factory != nullptr);
; 2471 : 					factory->Release();					

  00028	50		 push	 eax
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	ff 51 08	 call	 DWORD PTR [ecx+8]

; 2472 : 					pCache->pCF = NULL;

  0002e	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$LN2@Term:

; 2458 : 			return;
; 2459 : 
; 2460 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  00034	83 c6 04	 add	 esi, 4
  00037	3b 77 0c	 cmp	 esi, DWORD PTR [edi+12]
  0003a	72 d6		 jb	 SHORT $LL4@Term
  0003c	5b		 pop	 ebx
$LN3@Term:

; 2473 : 				}				
; 2474 : 			}
; 2475 : 		}
; 2476 : 		m_csObjMap.Term();

  0003d	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  00040	50		 push	 eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 2477 : 		// Set to 0 to indicate that this function has been called
; 2478 : 		// At this point no one should be concerned about cbsize
; 2479 : 		// having the correct value
; 2480 : 		cbSize = 0;

  00047	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0004d	5e		 pop	 esi
$LN1@Term:
  0004e	5f		 pop	 edi

; 2481 : 	}

  0004f	c3		 ret	 0
?Term@CAtlComModule@ATL@@QAEXXZ ENDP			; ATL::CAtlComModule::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::~CAtlComModule, COMDAT
; _this$ = ecx

; 2450 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CAtlComModule@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2451 : 		Term();

  00022	e8 00 00 00 00	 call	 ?Term@CAtlComModule@ATL@@QAEXXZ ; ATL::CAtlComModule::Term

; 2452 : 	}

  00027	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0002a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00031	59		 pop	 ecx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CAtlComModule@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::~CAtlComModule
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::CAtlComModule, COMDAT
; _this$ = ecx

; 2429 : 	CAtlComModule() throw()

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	0f 57 c0	 xorps	 xmm0, xmm0

; 2430 : 	{

  00006	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00009	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 2431 : 		cbSize = 0;
; 2432 : 
; 2433 : 		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);
; 2434 : 
; 2435 : 		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;
; 2436 : 		m_ppAutoObjMapLast = &__pobjMapEntryLast;
; 2437 : 
; 2438 : 		if (FAILED(m_csObjMap.Init()))

  0000c	6a 00		 push	 0
  0000e	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  00013	50		 push	 eax
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0001a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], OFFSET ___ImageBase
  00021	c7 46 08 04 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET ___pobjMapEntryFirst+4
  00028	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], OFFSET ___pobjMapEntryLast
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8
  00035	85 c0		 test	 eax, eax
  00037	75 21		 jne	 SHORT $LN2@CAtlComMod
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0003f	85 c0		 test	 eax, eax
  00041	7e 0a		 jle	 SHORT $LN18@CAtlComMod
  00043	0f b7 c0	 movzx	 eax, ax
  00046	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
  0004b	85 c0		 test	 eax, eax
$LN18@CAtlComMod:
  0004d	79 0b		 jns	 SHORT $LN2@CAtlComMod

; 2447 : 	}

  0004f	8b c6		 mov	 eax, esi
  00051	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
  00058	5e		 pop	 esi
  00059	c3		 ret	 0
$LN2@CAtlComMod:

; 2439 : 		{
; 2440 : 			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));
; 2441 : 			ATLASSERT(0);
; 2442 : 			CAtlBaseModule::m_bInitFailed = true;
; 2443 : 			return;
; 2444 : 		}
; 2445 : 		// Set cbSize on success.
; 2446 : 		cbSize = sizeof(_ATL_COM_MODULE);

  0005a	c7 06 28 00 00
	00		 mov	 DWORD PTR [esi], 40	; 00000028H

; 2447 : 	}

  00060	8b c6		 mov	 eax, esi
  00062	5e		 pop	 esi
  00063	c3		 ret	 0
??0CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::CAtlComModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC ; ATL::AtlWinModuleTerm, COMDAT

; 7649 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 7650 : 	if (pWinModule == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _pWinModule$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 0a		 jne	 SHORT $LN5@AtlWinModu
$LN37@AtlWinModu:

; 7651 : 		return E_INVALIDARG;

  0000b	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00010	5e		 pop	 esi

; 7663 : }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
$LN5@AtlWinModu:

; 7652 : 	if (pWinModule->cbSize == 0)

  00015	8b 06		 mov	 eax, DWORD PTR [esi]
  00017	85 c0		 test	 eax, eax
  00019	74 6a		 je	 SHORT $LN36@AtlWinModu

; 7653 : 		return S_OK;
; 7654 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  0001b	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  0001e	75 eb		 jne	 SHORT $LN37@AtlWinModu

; 7655 : 		return E_INVALIDARG;
; 7656 : 
; 7657 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

  00020	57		 push	 edi
  00021	33 ff		 xor	 edi, edi
  00023	39 7e 24	 cmp	 DWORD PTR [esi+36], edi
  00026	7e 27		 jle	 SHORT $LN3@AtlWinModu

; 7658 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

  00028	53		 push	 ebx
  00029	8b 5d 0c	 mov	 ebx, DWORD PTR _hInst$[ebp]
  0002c	0f 1f 40 00	 npad	 4
$LL4@AtlWinModu:
  00030	85 ff		 test	 edi, edi
  00032	78 58		 js	 SHORT $LN28@AtlWinModu
  00034	3b 7e 24	 cmp	 edi, DWORD PTR [esi+36]
  00037	7d 53		 jge	 SHORT $LN28@AtlWinModu
  00039	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0003c	53		 push	 ebx
  0003d	0f b7 04 78	 movzx	 eax, WORD PTR [eax+edi*2]
  00041	50		 push	 eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassA@8
  00048	47		 inc	 edi
  00049	3b 7e 24	 cmp	 edi, DWORD PTR [esi+36]
  0004c	7c e2		 jl	 SHORT $LL4@AtlWinModu
  0004e	5b		 pop	 ebx
$LN3@AtlWinModu:

; 7659 : 	pWinModule->m_rgWindowClassAtoms.RemoveAll();

  0004f	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00052	5f		 pop	 edi
  00053	85 c0		 test	 eax, eax
  00055	74 10		 je	 SHORT $LN22@AtlWinModu
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _free
  0005d	83 c4 04	 add	 esp, 4
  00060	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
$LN22@AtlWinModu:

; 7660 : 	pWinModule->m_csWindowCreate.Term();

  00067	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0006a	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  00071	50		 push	 eax
  00072	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 7661 : 	pWinModule->cbSize = 0;

  0007f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN36@AtlWinModu:

; 7662 : 	return S_OK;

  00085	33 c0		 xor	 eax, eax
  00087	5e		 pop	 esi

; 7663 : }

  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
$LN28@AtlWinModu:

; 7658 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

  0008c	6a 00		 push	 0
  0008e	6a 00		 push	 0
  00090	6a 01		 push	 1
  00092	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16
$LN39@AtlWinModu:
$LN38@AtlWinModu:
  0009d	cc		 int	 3
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z PROC ; ATL::AtlWinModuleInit, COMDAT

; 8393 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8394 : 	if (pWinModule == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 09		 jne	 SHORT $LN2@AtlWinModu
$LN15@AtlWinModu:

; 8395 : 		return E_INVALIDARG;

  0000a	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H

; 8410 : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
$LN2@AtlWinModu:

; 8396 : 
; 8397 : 	// check only in the DLL
; 8398 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  00013	83 38 2c	 cmp	 DWORD PTR [eax], 44	; 0000002cH
  00016	75 f2		 jne	 SHORT $LN15@AtlWinModu

; 8399 : 		return E_INVALIDARG;
; 8400 : 
; 8401 : 	pWinModule->m_pCreateWndList = NULL;

  00018	56		 push	 esi
  00019	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 8402 : 
; 8403 : 	HRESULT hr = pWinModule->m_csWindowCreate.Init();

  00020	33 f6		 xor	 esi, esi
  00022	56		 push	 esi
  00023	83 c0 04	 add	 eax, 4
  00026	50		 push	 eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8
  0002d	85 c0		 test	 eax, eax
  0002f	75 15		 jne	 SHORT $LN14@AtlWinModu
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00037	8b f0		 mov	 esi, eax
  00039	85 f6		 test	 esi, esi
  0003b	7e 09		 jle	 SHORT $LN14@AtlWinModu
  0003d	0f b7 f6	 movzx	 esi, si
  00040	81 ce 00 00 07
	80		 or	 esi, -2147024896	; 80070000H
$LN14@AtlWinModu:

; 8404 : 	if (FAILED(hr))
; 8405 : 	{
; 8406 : 		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to initialize critical section in AtlWinModuleInit\n"));
; 8407 : 		ATLASSERT(0);
; 8408 : 	}
; 8409 : 	return hr;

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi

; 8410 : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleInit
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00006	85 c0		 test	 eax, eax
  00008	74 10		 je	 SHORT $LN19@ATL_WIN_MO
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _free
  00010	83 c4 04	 add	 esp, 4
  00013	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
$LN19@ATL_WIN_MO:
  0001a	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00021	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  00028	5e		 pop	 esi
  00029	c3		 ret	 0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	0f 57 c0	 xorps	 xmm0, xmm0
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000a	0f 11 41 04	 movups	 XMMWORD PTR [ecx+4], xmm0
  0000e	8b c1		 mov	 eax, ecx
  00010	66 0f d6 41 14	 movq	 QWORD PTR [ecx+20], xmm0
  00015	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  0001c	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
  00023	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 236  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 237  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00003	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0e		 js	 SHORT $LN3@operator
  0000a	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0000d	7d 09		 jge	 SHORT $LN3@operator

; 241  : 		}
; 242  : 		return m_aT[nIndex];

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]

; 243  : 	}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@operator:

; 239  : 		{
; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	6a 01		 push	 1
  0001e	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16
$LN9@operator:
$LN8@operator:
  00029	cc		 int	 3
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 215  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 216  : 		if(m_aT != NULL)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0f		 je	 SHORT $LN11@RemoveAll

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4

; 221  : 			m_aT = NULL;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN11@RemoveAll:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

  00018	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00026	5e		 pop	 esi

; 225  :     }

  00027	c3		 ret	 0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 161  : 		return m_nSize;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 162  : 	}

  00003	c3		 ret	 0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 310  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 311  : 	RemoveAll();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0f		 je	 SHORT $LN13@CSimpleArr
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN13@CSimpleArr:
  00018	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00026	5e		 pop	 esi

; 312  : }

  00027	c3		 ret	 0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 121  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??1_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??0_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
  00000	0f 57 c0	 xorps	 xmm0, xmm0
  00003	8b c1		 mov	 eax, ecx
  00005	0f 11 41 10	 movups	 XMMWORD PTR [ecx+16], xmm0
  00009	66 0f d6 41 20	 movq	 QWORD PTR [ecx+32], xmm0
  0000e	c3		 ret	 0
??0_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlAdd@I@ATL@@YAJPAIII@Z
_TEXT	SEGMENT
_ptResult$ = 8						; size = 4
_tLeft$ = 12						; size = 4
_tRight$ = 16						; size = 4
??$AtlAdd@I@ATL@@YAJPAIII@Z PROC			; ATL::AtlAdd<unsigned int>, COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	if(::ATL::AtlLimits<T>::_Max-tLeft < tRight)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _tLeft$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	8b 55 10	 mov	 edx, DWORD PTR _tRight$[ebp]
  0000b	f7 d0		 not	 eax
  0000d	3b c2		 cmp	 eax, edx
  0000f	73 07		 jae	 SHORT $LN2@AtlAdd

; 101  : 	{
; 102  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  00011	b8 16 02 07 80	 mov	 eax, -2147024362	; 80070216H

; 106  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN2@AtlAdd:

; 103  : 	}
; 104  : 	*ptResult= tLeft + tRight;

  00018	8b 45 08	 mov	 eax, DWORD PTR _ptResult$[ebp]
  0001b	03 ca		 add	 ecx, edx
  0001d	89 08		 mov	 DWORD PTR [eax], ecx

; 105  : 	return S_OK;

  0001f	33 c0		 xor	 eax, eax

; 106  : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??$AtlAdd@I@ATL@@YAJPAIII@Z ENDP			; ATL::AtlAdd<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0CComBSTR@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
__AtlSafeAllocaManager$1 = -4				; size = 4
_nConvertedLen$1$ = 8					; size = 4
_pSrc$ = 8						; size = 4
??0CComBSTR@ATL@@QAE@PBD@Z PROC				; ATL::CComBSTR::CComBSTR, COMDAT
; _this$ = ecx

; 1370 :     CComBSTR(_In_opt_z_ LPCSTR pSrc)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1371 :     {
; 1372 :         if (pSrc != NULL)

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _pSrc$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi
  0000c	85 db		 test	 ebx, ebx
  0000e	74 62		 je	 SHORT $LN2@CComBSTR

; 1373 :         {
; 1374 :             m_str = A2WBSTR(pSrc);

  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	6a ff		 push	 -1
  00016	53		 push	 ebx
  00017	6a 00		 push	 0
  00019	6a 03		 push	 3
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __AtlSafeAllocaManager$1[ebp], 0
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00028	89 45 08	 mov	 DWORD PTR _nConvertedLen$1$[ebp], eax
  0002b	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  0002e	51		 push	 ecx
  0002f	6a 00		 push	 0
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysAllocStringLen@8
  00037	8b f8		 mov	 edi, eax
  00039	85 ff		 test	 edi, edi
  0003b	74 2d		 je	 SHORT $LN11@CComBSTR
  0003d	ff 75 08	 push	 DWORD PTR _nConvertedLen$1$[ebp]
  00040	57		 push	 edi
  00041	6a ff		 push	 -1
  00043	53		 push	 ebx
  00044	6a 00		 push	 0
  00046	6a 03		 push	 3
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  0004e	3b 45 08	 cmp	 eax, DWORD PTR _nConvertedLen$1$[ebp]
  00051	74 17		 je	 SHORT $LN11@CComBSTR
  00053	57		 push	 edi
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
  0005a	8d 4d fc	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$1[ebp]
  0005d	e8 00 00 00 00	 call	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
  00062	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00068	eb 19		 jmp	 SHORT $LN32@CComBSTR
$LN11@CComBSTR:
  0006a	89 3e		 mov	 DWORD PTR [esi], edi

; 1375 :             if (!*this)

  0006c	85 ff		 test	 edi, edi
  0006e	75 08		 jne	 SHORT $LN3@CComBSTR
  00070	eb 11		 jmp	 SHORT $LN32@CComBSTR
$LN2@CComBSTR:

; 1378 :             }
; 1379 :         }
; 1380 :         else
; 1381 :         {
; 1382 :             m_str = NULL;

  00072	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@CComBSTR:
  00078	5f		 pop	 edi

; 1383 :         }
; 1384 :     }

  00079	8b c6		 mov	 eax, esi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
$LN32@CComBSTR:

; 1376 :             {
; 1377 :                 AtlThrow(E_OUTOFMEMORY);

  00083	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00088	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN34@CComBSTR:
$LN31@CComBSTR:
  0008d	cc		 int	 3
??0CComBSTR@ATL@@QAE@PBD@Z ENDP				; ATL::CComBSTR::CComBSTR
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ?AppendBytes@CComBSTR@ATL@@QAEJPBDH@Z
_TEXT	SEGMENT
_nSize$1$ = -4						; size = 4
_lpsz$ = 8						; size = 4
_b$1$ = 12						; size = 4
_nLen$ = 12						; size = 4
?AppendBytes@CComBSTR@ATL@@QAEJPBDH@Z PROC		; ATL::CComBSTR::AppendBytes, COMDAT
; _this$ = ecx

; 1074 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1075 :         if (lpsz == NULL || nLen == 0)

  00004	83 7d 08 00	 cmp	 DWORD PTR _lpsz$[ebp], 0
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	8b d9		 mov	 ebx, ecx
  0000c	0f 84 9f 00 00
	00		 je	 $LN4@AppendByte
  00012	8b 75 0c	 mov	 esi, DWORD PTR _nLen$[ebp]
  00015	85 f6		 test	 esi, esi
  00017	0f 84 94 00 00
	00		 je	 $LN4@AppendByte

; 1078 :         }
; 1079 :         else if (nLen < 0)

  0001d	79 0d		 jns	 SHORT $LN5@AppendByte

; 1080 :         {
; 1081 :             return E_INVALIDARG;

  0001f	5e		 pop	 esi
  00020	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00025	5b		 pop	 ebx

; 1105 :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
$LN5@AppendByte:
  0002c	57		 push	 edi

; 1082 :         }
; 1083 :                 
; 1084 :         const unsigned int n1 = ByteLength();		

  0002d	ff 33		 push	 DWORD PTR [ebx]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysStringByteLen@4

; 1085 :         unsigned int nSize = 0;
; 1086 :         HRESULT hr = AtlAdd<unsigned int>(&nSize, n1, nLen);

  00035	83 c9 ff	 or	 ecx, -1
  00038	8b f8		 mov	 edi, eax
  0003a	2b cf		 sub	 ecx, edi
  0003c	3b ce		 cmp	 ecx, esi
  0003e	72 63		 jb	 SHORT $LN18@AppendByte
  00040	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]

; 1090 :         }
; 1091 :                          
; 1092 :         BSTR b = ::SysAllocStringByteLen(NULL, nSize);

  00043	50		 push	 eax
  00044	6a 00		 push	 0
  00046	89 45 fc	 mov	 DWORD PTR _nSize$1$[ebp], eax
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysAllocStringByteLen@8
  0004f	89 45 0c	 mov	 DWORD PTR _b$1$[ebp], eax

; 1093 :         if (b == NULL)

  00052	85 c0		 test	 eax, eax
  00054	75 0e		 jne	 SHORT $LN7@AppendByte

; 1094 :         {
; 1095 :             return E_OUTOFMEMORY;

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  0005d	5b		 pop	 ebx

; 1105 :     }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
$LN7@AppendByte:

; 1096 :         }
; 1097 :         
; 1098 :         Checked::memcpy_s(b, nSize, m_str, n1);

  00064	57		 push	 edi
  00065	ff 33		 push	 DWORD PTR [ebx]
  00067	8d 0c 37	 lea	 ecx, DWORD PTR [edi+esi]
  0006a	51		 push	 ecx
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ; ATL::Checked::memcpy_s

; 1099 :         Checked::memcpy_s(((char*)b) + n1, nLen, lpsz, nLen);

  00071	56		 push	 esi
  00072	ff 75 08	 push	 DWORD PTR _lpsz$[ebp]
  00075	56		 push	 esi
  00076	8b 75 0c	 mov	 esi, DWORD PTR _b$1$[ebp]
  00079	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ; ATL::Checked::memcpy_s

; 1100 :         
; 1101 :         *((OLECHAR*)(((char*)b) + nSize)) = '\0';

  00082	8b 45 fc	 mov	 eax, DWORD PTR _nSize$1$[ebp]
  00085	83 c4 20	 add	 esp, 32			; 00000020H
  00088	33 c9		 xor	 ecx, ecx
  0008a	66 89 0c 06	 mov	 WORD PTR [esi+eax], cx

; 1102 :         SysFreeString(m_str);

  0008e	ff 33		 push	 DWORD PTR [ebx]
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
  00096	5f		 pop	 edi

; 1103 :         m_str = b;

  00097	89 33		 mov	 DWORD PTR [ebx], esi

; 1104 :         return S_OK;

  00099	33 c0		 xor	 eax, eax
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx

; 1105 :     }

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 08 00	 ret	 8
$LN18@AppendByte:
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi

; 1087 :         if (FAILED(hr))
; 1088 :         {
; 1089 :             return hr;

  000a5	b8 16 02 07 80	 mov	 eax, -2147024362	; 80070216H
  000aa	5b		 pop	 ebx

; 1105 :     }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 08 00	 ret	 8
$LN4@AppendByte:
  000b1	5e		 pop	 esi

; 1076 :         {
; 1077 :             return S_OK;

  000b2	33 c0		 xor	 eax, eax
  000b4	5b		 pop	 ebx

; 1105 :     }

  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 08 00	 ret	 8
?AppendBytes@CComBSTR@ATL@@QAEJPBDH@Z ENDP		; ATL::CComBSTR::AppendBytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??7CComBSTR@ATL@@QBE_NXZ
_TEXT	SEGMENT
??7CComBSTR@ATL@@QBE_NXZ PROC				; ATL::CComBSTR::operator!, COMDAT
; _this$ = ecx

; 972  :     {

  00000	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00003	0f 94 c0	 sete	 al

; 973  :         return (m_str == NULL);
; 974  :     }

  00006	c3		 ret	 0
??7CComBSTR@ATL@@QBE_NXZ ENDP				; ATL::CComBSTR::operator!
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??ICComBSTR@ATL@@QAEPAPA_WXZ
_TEXT	SEGMENT
??ICComBSTR@ATL@@QAEPAPA_WXZ PROC			; ATL::CComBSTR::operator&, COMDAT
; _this$ = ecx

; 889  : #ifndef ATL_NO_CCOMBSTR_ADDRESS_OF_ASSERT
; 890  :         ATLASSERT(!*this);
; 891  : #endif
; 892  :         return &m_str;

  00000	8b c1		 mov	 eax, ecx

; 893  :     }

  00002	c3		 ret	 0
??ICComBSTR@ATL@@QAEPAPA_WXZ ENDP			; ATL::CComBSTR::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??BCComBSTR@ATL@@QBEPA_WXZ
_TEXT	SEGMENT
??BCComBSTR@ATL@@QBEPA_WXZ PROC				; ATL::CComBSTR::operator wchar_t *, COMDAT
; _this$ = ecx

; 877  :         return m_str;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 878  :     }

  00002	c3		 ret	 0
??BCComBSTR@ATL@@QBEPA_WXZ ENDP				; ATL::CComBSTR::operator wchar_t *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ?ByteLength@CComBSTR@ATL@@QBEIXZ
_TEXT	SEGMENT
?ByteLength@CComBSTR@ATL@@QBEIXZ PROC			; ATL::CComBSTR::ByteLength, COMDAT
; _this$ = ecx

; 872  :         return ::SysStringByteLen(m_str);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysStringByteLen@4

; 873  :     }

  00008	c3		 ret	 0
?ByteLength@CComBSTR@ATL@@QBEIXZ ENDP			; ATL::CComBSTR::ByteLength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??1CComBSTR@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CComBSTR@ATL@@QAE@XZ PROC				; ATL::CComBSTR::~CComBSTR, COMDAT
; _this$ = ecx

; 1661 :     ::SysFreeString(m_str);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4

; 1662 : }

  00008	c3		 ret	 0
??1CComBSTR@ATL@@QAE@XZ ENDP				; ATL::CComBSTR::~CComBSTR
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0CComBSTR@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CComBSTR@ATL@@QAE@XZ PROC				; ATL::CComBSTR::CComBSTR, COMDAT
; _this$ = ecx

; 714  :     {
; 715  :         m_str = NULL;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 716  :     }	

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0CComBSTR@ATL@@QAE@XZ ENDP				; ATL::CComBSTR::CComBSTR
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 275  : 		return m_hInst;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 276  : 	}

  00003	c3		 ret	 0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Term@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 140  : 		DeleteCriticalSection(&m_sec);

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 141  : 		return S_OK;

  00007	33 c0		 xor	 eax, eax

; 142  : 	}

  00009	c3		 ret	 0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Init@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx

; 129  : 		HRESULT hRes = S_OK;
; 130  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

  00000	6a 00		 push	 0
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8
  00009	85 c0		 test	 eax, eax
  0000b	75 13		 jne	 SHORT $LN10@Init

; 131  : 		{
; 132  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00013	85 c0		 test	 eax, eax
  00015	7e 0b		 jle	 SHORT $LN9@Init
  00017	0f b7 c0	 movzx	 eax, ax
  0001a	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H

; 136  : 	}

  0001f	c3		 ret	 0
$LN10@Init:

; 133  : 		}
; 134  : 
; 135  : 		return hRes;

  00020	33 c0		 xor	 eax, eax

; 131  : 		{
; 132  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

$LN9@Init:

; 136  : 	}

  00022	c3		 ret	 0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??1CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::~CComCriticalSection, COMDAT
; _this$ = ecx

; 115  : 	}

  00000	c3		 ret	 0
??1CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::~CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 108  : 	CComCriticalSection() throw()

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 109  : 	{
; 110  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));
; 111  : 	}

  00003	8b c1		 mov	 eax, ecx
  00005	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00008	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  0000d	c3		 ret	 0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlwinverapi.h
;	COMDAT ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z
_TEXT	SEGMENT
_lpCriticalSection$ = 8					; size = 4
_dwSpinCount$ = 12					; size = 4
_Flags$ = 16						; size = 4
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z PROC ; ATL::_AtlInitializeCriticalSectionEx, COMDAT

; 727  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 728  : #if (NTDDI_VERSION >= NTDDI_VISTA) && !defined(_USING_V110_SDK71_) && !defined(_ATL_XP_TARGETING)
; 729  : 	// InitializeCriticalSectionEx is available in Vista or later, desktop or store apps
; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);
; 731  : #else
; 732  : 	UNREFERENCED_PARAMETER(Flags);
; 733  : 
; 734  : 	// ...otherwise fall back to using InitializeCriticalSectionAndSpinCount.
; 735  : 	return ::InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);

  00003	ff 75 0c	 push	 DWORD PTR _dwSpinCount$[ebp]
  00006	ff 75 08	 push	 DWORD PTR _lpCriticalSection$[ebp]
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8

; 736  : #endif
; 737  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ENDP ; ATL::_AtlInitializeCriticalSectionEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlchecked.h
;	COMDAT ?AtlCrtErrorCheck@ATL@@YAHH@Z
_TEXT	SEGMENT
_nError$ = 8						; size = 4
?AtlCrtErrorCheck@ATL@@YAHH@Z PROC			; ATL::AtlCrtErrorCheck, COMDAT

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 32   : 	switch(nError)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _nError$[ebp]
  00006	83 f9 50	 cmp	 ecx, 80			; 00000050H
  00009	77 26		 ja	 SHORT $LN7@AtlCrtErro
  0000b	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR $LN9@AtlCrtErro[ecx]
  00012	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN12@AtlCrtErro[eax*4]
$LN6@AtlCrtErro:

; 46   : 		break;
; 47   : 	}
; 48   : 	return nError;

  00019	8b c1		 mov	 eax, ecx

; 49   : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN11@AtlCrtErro:

; 33   : 	{
; 34   : 	case ENOMEM:
; 35   : 		AtlThrow(E_OUTOFMEMORY);

  0001d	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00022	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN13@AtlCrtErro:
$LN5@AtlCrtErro:

; 36   : 		break;
; 37   : 	case EINVAL:
; 38   : 	case ERANGE:
; 39   : 		AtlThrow(E_INVALIDARG);

  00027	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0002c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN14@AtlCrtErro:
$LN7@AtlCrtErro:

; 40   : 		break;
; 41   : 	case 0:
; 42   : 	case STRUNCATE:
; 43   : 		break;
; 44   : 	default:
; 45   : 		AtlThrow(E_FAIL);

  00031	68 05 40 00 80	 push	 -2147467259		; 80004005H
  00036	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN15@AtlCrtErro:
$LN10@AtlCrtErro:
  0003b	90		 npad	 1
$LN12@AtlCrtErro:

; 49   : }

  0003c	00 00 00 00	 DD	 $LN6@AtlCrtErro
  00040	00 00 00 00	 DD	 $LN11@AtlCrtErro
  00044	00 00 00 00	 DD	 $LN5@AtlCrtErro
  00048	00 00 00 00	 DD	 $LN7@AtlCrtErro
$LN9@AtlCrtErro:
  0004c	00		 DB	 0
  0004d	03		 DB	 3
  0004e	03		 DB	 3
  0004f	03		 DB	 3
  00050	03		 DB	 3
  00051	03		 DB	 3
  00052	03		 DB	 3
  00053	03		 DB	 3
  00054	03		 DB	 3
  00055	03		 DB	 3
  00056	03		 DB	 3
  00057	03		 DB	 3
  00058	01		 DB	 1
  00059	03		 DB	 3
  0005a	03		 DB	 3
  0005b	03		 DB	 3
  0005c	03		 DB	 3
  0005d	03		 DB	 3
  0005e	03		 DB	 3
  0005f	03		 DB	 3
  00060	03		 DB	 3
  00061	03		 DB	 3
  00062	02		 DB	 2
  00063	03		 DB	 3
  00064	03		 DB	 3
  00065	03		 DB	 3
  00066	03		 DB	 3
  00067	03		 DB	 3
  00068	03		 DB	 3
  00069	03		 DB	 3
  0006a	03		 DB	 3
  0006b	03		 DB	 3
  0006c	03		 DB	 3
  0006d	03		 DB	 3
  0006e	02		 DB	 2
  0006f	03		 DB	 3
  00070	03		 DB	 3
  00071	03		 DB	 3
  00072	03		 DB	 3
  00073	03		 DB	 3
  00074	03		 DB	 3
  00075	03		 DB	 3
  00076	03		 DB	 3
  00077	03		 DB	 3
  00078	03		 DB	 3
  00079	03		 DB	 3
  0007a	03		 DB	 3
  0007b	03		 DB	 3
  0007c	03		 DB	 3
  0007d	03		 DB	 3
  0007e	03		 DB	 3
  0007f	03		 DB	 3
  00080	03		 DB	 3
  00081	03		 DB	 3
  00082	03		 DB	 3
  00083	03		 DB	 3
  00084	03		 DB	 3
  00085	03		 DB	 3
  00086	03		 DB	 3
  00087	03		 DB	 3
  00088	03		 DB	 3
  00089	03		 DB	 3
  0008a	03		 DB	 3
  0008b	03		 DB	 3
  0008c	03		 DB	 3
  0008d	03		 DB	 3
  0008e	03		 DB	 3
  0008f	03		 DB	 3
  00090	03		 DB	 3
  00091	03		 DB	 3
  00092	03		 DB	 3
  00093	03		 DB	 3
  00094	03		 DB	 3
  00095	03		 DB	 3
  00096	03		 DB	 3
  00097	03		 DB	 3
  00098	03		 DB	 3
  00099	03		 DB	 3
  0009a	03		 DB	 3
  0009b	03		 DB	 3
  0009c	00		 DB	 0
?AtlCrtErrorCheck@ATL@@YAHH@Z ENDP			; ATL::AtlCrtErrorCheck
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 66   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 67   : #ifdef _AFX
; 68   : 	if( hr == E_OUTOFMEMORY )
; 69   : 	{
; 70   : 		AfxThrowMemoryException();
; 71   : 	}
; 72   : 	else
; 73   : 	{
; 74   : 		AfxThrowOleException( hr );
; 75   : 	}
; 76   : #else
; 77   : 	throw CAtlException( hr );

  00003	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00006	89 45 08	 mov	 DWORD PTR $T1[ebp], eax
  00009	8d 45 08	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	68 00 00 00 00	 push	 OFFSET __TI1?AVCAtlException@ATL@@
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN6@AtlThrowIm:
$LN5@AtlThrowIm:
  00017	cc		 int	 3
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
??0CAtlException@ATL@@QAE@J@Z PROC			; ATL::CAtlException::CAtlException, COMDAT
; _this$ = ecx

; 44   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		m_hr( hr )

  00003	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 	}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0CAtlException@ATL@@QAE@J@Z ENDP			; ATL::CAtlException::CAtlException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	ff 75 0c	 push	 DWORD PTR _dwExceptionFlags$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR _dwExceptionCode$[ebp]
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16

; 32   : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 712  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 713  : 		// Walk the list and free the buffers
; 714  : 		while (m_pHead != NULL)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 14		 je	 SHORT $LN3@CAtlSafeAl
$LL2@CAtlSafeAl:

; 715  : 		{
; 716  : 			CAtlSafeAllocBufferNode* p = m_pHead;

  00008	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 717  : 			m_pHead = m_pHead->m_pNext;
; 718  : 			Allocator::Free(p);

  0000a	51		 push	 ecx
  0000b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000d	89 06		 mov	 DWORD PTR [esi], eax
  0000f	e8 00 00 00 00	 call	 _free
  00014	83 c4 04	 add	 esp, 4
  00017	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0001a	75 ec		 jne	 SHORT $LL2@CAtlSafeAl
$LN3@CAtlSafeAl:
  0001c	5e		 pop	 esi

; 719  : 		}
; 720  : 	}

  0001d	c3		 ret	 0
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 696  : 	CAtlSafeAllocBufferManager() : m_pHead(NULL)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 698  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlconv.h
;	COMDAT ?A2WBSTR@@YAPA_WPBDH@Z
_TEXT	SEGMENT
_nConvertedLen$1$ = 8					; size = 4
_lp$ = 8						; size = 4
_nLen$ = 12						; size = 4
?A2WBSTR@@YAPA_WPBDH@Z PROC				; A2WBSTR, COMDAT

; 1144 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1145 : 	if (lp == NULL || nLen == 0)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _lp$[ebp]
  00007	57		 push	 edi
  00008	85 db		 test	 ebx, ebx
  0000a	74 5b		 je	 SHORT $LN3@A2WBSTR
  0000c	8b 7d 0c	 mov	 edi, DWORD PTR _nLen$[ebp]
  0000f	85 ff		 test	 edi, edi
  00011	74 54		 je	 SHORT $LN3@A2WBSTR

; 1147 : 	USES_CONVERSION_EX;
; 1148 : 	BSTR str = NULL;
; 1149 : 
; 1150 : 	int nConvertedLen = MultiByteToWideChar(_acp_ex, 0, lp, nLen, NULL, 0);

  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	57		 push	 edi
  00018	53		 push	 ebx
  00019	6a 00		 push	 0
  0001b	6a 03		 push	 3
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00023	89 45 08	 mov	 DWORD PTR _nConvertedLen$1$[ebp], eax

; 1151 : 
; 1152 : 	int nAllocLen = nConvertedLen;

  00026	8b c8		 mov	 ecx, eax

; 1153 : 	if (nLen == -1)

  00028	83 ff ff	 cmp	 edi, -1
  0002b	75 03		 jne	 SHORT $LN4@A2WBSTR

; 1154 : 		nAllocLen -= 1;  // Don't allocate terminating '\0'

  0002d	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
$LN4@A2WBSTR:
  00030	56		 push	 esi

; 1155 : 	str = ::SysAllocStringLen(NULL, nAllocLen);

  00031	51		 push	 ecx
  00032	6a 00		 push	 0
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysAllocStringLen@8
  0003a	8b f0		 mov	 esi, eax

; 1156 : 
; 1157 : 	if (str != NULL)

  0003c	85 f6		 test	 esi, esi
  0003e	74 20		 je	 SHORT $LL15@A2WBSTR

; 1158 : 	{
; 1159 : 		int nResult;
; 1160 : 		nResult = MultiByteToWideChar(_acp_ex, 0, lp, nLen, str, nConvertedLen);

  00040	ff 75 08	 push	 DWORD PTR _nConvertedLen$1$[ebp]
  00043	56		 push	 esi
  00044	57		 push	 edi
  00045	53		 push	 ebx
  00046	6a 00		 push	 0
  00048	6a 03		 push	 3
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 1161 : 		ATLASSERT(nResult == nConvertedLen);
; 1162 : 		if (nResult != nConvertedLen)

  00050	3b 45 08	 cmp	 eax, DWORD PTR _nConvertedLen$1$[ebp]
  00053	74 0b		 je	 SHORT $LL15@A2WBSTR

; 1163 : 		{
; 1164 : ATLPREFAST_SUPPRESS(6102)
; 1165 : 			SysFreeString(str);

  00055	56		 push	 esi
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
  0005c	33 f6		 xor	 esi, esi
  0005e	66 90		 npad	 2

; 1166 : ATLPREFAST_UNSUPPRESS()
; 1167 : 			return NULL;
; 1168 : 		}
; 1169 : 
; 1170 : 	}
; 1171 : 	return str;

$LL15@A2WBSTR:
  00060	8b c6		 mov	 eax, esi
  00062	5e		 pop	 esi
  00063	5f		 pop	 edi
  00064	5b		 pop	 ebx

; 1172 : }

  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
$LN3@A2WBSTR:
  00067	5f		 pop	 edi

; 1146 : 		return NULL;

  00068	33 c0		 xor	 eax, eax
  0006a	5b		 pop	 ebx

; 1172 : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?A2WBSTR@@YAPA_WPBDH@Z ENDP				; A2WBSTR
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC			; ATL::_AtlGetConversionACP, COMDAT

; 106  : #ifdef _CONVERSION_DONT_USE_THREAD_LOCALE
; 107  : 	return CP_ACP;
; 108  : #else
; 109  : 	return CP_THREAD_ACP;

  00000	b8 03 00 00 00	 mov	 eax, 3

; 110  : #endif
; 111  : }

  00005	c3		 ret	 0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC			; ATL::CCRTAllocator::Free, COMDAT

; 282  : 		free(p);

  00000	e9 00 00 00 00	 jmp	 _free
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\atlmfc\include\atlchecked.h
;	COMDAT ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S1max$ = 12						; size = 4
__S2$ = 16						; size = 4
__N$ = 20						; size = 4
?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z PROC		; ATL::Checked::memcpy_s, COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  00003	ff 75 14	 push	 DWORD PTR __N$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __S2$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __S1max$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __S1$[ebp]
  0000f	e8 00 00 00 00	 call	 _memcpy_s
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 70   : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ENDP		; ATL::Checked::memcpy_s
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GContainer@ForEach@GostCrypt@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GContainer@ForEach@GostCrypt@@UAEPAXI@Z PROC		; GostCrypt::ForEach::Container::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00010	74 0b		 je	 SHORT $LN7@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_GContainer@ForEach@GostCrypt@@UAEPAXI@Z ENDP		; GostCrypt::ForEach::Container::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?InnerIsNotEnd@Container@ForEach@GostCrypt@@QBE_NXZ
_TEXT	SEGMENT
?InnerIsNotEnd@Container@ForEach@GostCrypt@@QBE_NXZ PROC ; GostCrypt::ForEach::Container::InnerIsNotEnd, COMDAT
; _this$ = ecx

; 23   : 			bool InnerIsNotEnd () const { return InnerEndCondition = !InnerEndCondition; }

  00000	33 c0		 xor	 eax, eax
  00002	38 41 05	 cmp	 BYTE PTR [ecx+5], al
  00005	0f 94 c0	 sete	 al
  00008	88 41 05	 mov	 BYTE PTR [ecx+5], al
  0000b	c3		 ret	 0
?InnerIsNotEnd@Container@ForEach@GostCrypt@@QBE_NXZ ENDP ; GostCrypt::ForEach::Container::InnerIsNotEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ?Continue@Container@ForEach@GostCrypt@@QBEXXZ
_TEXT	SEGMENT
?Continue@Container@ForEach@GostCrypt@@QBEXXZ PROC	; GostCrypt::ForEach::Container::Continue, COMDAT
; _this$ = ecx

; 22   : 			void Continue () const { InnerContinue = true; }

  00000	c6 41 04 01	 mov	 BYTE PTR [ecx+4], 1
  00004	c3		 ret	 0
?Continue@Container@ForEach@GostCrypt@@QBEXXZ ENDP	; GostCrypt::ForEach::Container::Continue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??1Container@ForEach@GostCrypt@@UAE@XZ
_TEXT	SEGMENT
??1Container@ForEach@GostCrypt@@UAE@XZ PROC		; GostCrypt::ForEach::Container::~Container, COMDAT
; _this$ = ecx

; 20   : 			virtual ~Container () { }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00006	c3		 ret	 0
??1Container@ForEach@GostCrypt@@UAE@XZ ENDP		; GostCrypt::ForEach::Container::~Container
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\platform\foreach.h
;	COMDAT ??0Container@ForEach@GostCrypt@@QAE@XZ
_TEXT	SEGMENT
??0Container@ForEach@GostCrypt@@QAE@XZ PROC		; GostCrypt::ForEach::Container::Container, COMDAT
; _this$ = ecx

; 19   : 			Container () : InnerContinue (true), InnerEndCondition (false) { }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Container@ForEach@GostCrypt@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	66 c7 41 04 01
	00		 mov	 WORD PTR [ecx+4], 1
  0000e	c3		 ret	 0
??0Container@ForEach@GostCrypt@@QAE@XZ ENDP		; GostCrypt::ForEach::Container::Container
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran, COMDAT
; _this$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	72 04		 jb	 SHORT $LN17@Check_offs

; 2273 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN17@Check_offs:

; 2272 : 			_Xran();

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN19@Check_offs:
$LN16@Check_offs:
  00019	cc		 int	 3
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen, COMDAT
; _this$ = ecx

; 2266 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2249 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 29		 je	 SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00010	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00014	72 23		 jb	 SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0e		 je	 SHORT $LN57@Tidy

; 2256 : 				_Traits::copy(this->_Bx()._Buf,

  0001d	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00020	50		 push	 eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	e8 00 00 00 00	 call	 _memcpy
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@Tidy:

; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  0002b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002e	8b ce		 mov	 ecx, esi
  00030	40		 inc	 eax
  00031	50		 push	 eax
  00032	53		 push	 ebx
  00033	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
  00038	5b		 pop	 ebx
$LN4@Tidy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00039	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7

; 2261 : 		_Eos(_Newsize);

  00040	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00044	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00047	72 0e		 jb	 SHORT $LN94@Tidy
  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	33 c9		 xor	 ecx, ecx
  0004d	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 2262 : 		}

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8

; 2261 : 		_Eos(_Newsize);

$LN94@Tidy:
  00057	33 c0		 xor	 eax, eax
  00059	66 89 04 7e	 mov	 WORD PTR [esi+edi*2], ax
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi

; 2262 : 		}

  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	74 2e		 je	 SHORT $LN4@Inside
  0000b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000e	83 f8 08	 cmp	 eax, 8
  00011	72 04		 jb	 SHORT $LN16@Inside
  00013	8b 31		 mov	 esi, DWORD PTR [ecx]
  00015	eb 02		 jmp	 SHORT $LN17@Inside
$LN16@Inside:
  00017	8b f1		 mov	 esi, ecx
$LN17@Inside:
  00019	3b d6		 cmp	 edx, esi
  0001b	72 1c		 jb	 SHORT $LN4@Inside
  0001d	83 f8 08	 cmp	 eax, 8
  00020	72 04		 jb	 SHORT $LN30@Inside
  00022	8b 31		 mov	 esi, DWORD PTR [ecx]
  00024	eb 02		 jmp	 SHORT $LN31@Inside
$LN30@Inside:
  00026	8b f1		 mov	 esi, ecx
$LN31@Inside:
  00028	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002b	8d 04 46	 lea	 eax, DWORD PTR [esi+eax*2]
  0002e	3b c2		 cmp	 eax, edx
  00030	76 07		 jbe	 SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

  00032	b0 01		 mov	 al, 1
  00034	5e		 pop	 esi

; 2244 : 		}

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

  00039	32 c0		 xor	 al, al
  0003b	5e		 pop	 esi

; 2244 : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2225 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH
  0000d	77 5b		 ja	 SHORT $LN89@Grow

; 2227 : 		if (this->_Myres() < _Newsize)

  0000f	39 71 14	 cmp	 DWORD PTR [ecx+20], esi
  00012	73 13		 jae	 SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00014	ff 71 10	 push	 DWORD PTR [ecx+16]
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0001d	85 f6		 test	 esi, esi
  0001f	5e		 pop	 esi
  00020	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00027	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  0002b	74 1f		 je	 SHORT $LN5@Grow
  0002d	83 fe 08	 cmp	 esi, 8
  00030	73 1a		 jae	 SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  00032	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00035	3b f0		 cmp	 esi, eax
  00037	0f 42 c6	 cmovb	 eax, esi
  0003a	50		 push	 eax
  0003b	6a 01		 push	 1
  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
  00042	85 f6		 test	 esi, esi
  00044	5e		 pop	 esi
  00045	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

  0004c	85 f6		 test	 esi, esi
  0004e	75 12		 jne	 SHORT $LN88@Grow

; 2233 : 			_Eos(0);	// new size is zero, just null terminate

  00050	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00054	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  00057	72 02		 jb	 SHORT $LN80@Grow
  00059	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN80@Grow:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 f6		 test	 esi, esi
  0005f	66 89 01	 mov	 WORD PTR [ecx], ax
$LN88@Grow:
  00062	0f 95 c0	 setne	 al
  00065	5e		 pop	 esi

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
$LN89@Grow:

; 2226 : 			_Xlen();	// result too long

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0006f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN91@Grow:
$LN87@Grow:
  00074	cc		 int	 3
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

  00003	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00007	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0000a	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000d	72 0c		 jb	 SHORT $LN11@Eos
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	33 c9		 xor	 ecx, ecx
  00013	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx

; 2220 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

$LN11@Eos:
  0001b	33 c0		 xor	 eax, eax
  0001d	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax

; 2220 : 		}

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$1$ = -24						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f8		 mov	 edi, eax
  00035	83 cf 07	 or	 edi, 7

; 2184 : 		if (max_size() < _Newres)

  00038	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  0003e	76 04		 jbe	 SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

  00040	8b f8		 mov	 edi, eax
  00042	eb 27		 jmp	 SHORT $LN108@Copy
$LN2@Copy:

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  00044	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00047	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0004c	f7 e7		 mul	 edi
  0004e	8b cb		 mov	 ecx, ebx
  00050	d1 e9		 shr	 ecx, 1
  00052	d1 ea		 shr	 edx, 1
  00054	3b ca		 cmp	 ecx, edx
  00056	76 13		 jbe	 SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00058	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH

; 2189 : 			_Newres = this->_Myres()

  0005d	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]
  00060	2b c1		 sub	 eax, ecx
  00062	3b d8		 cmp	 ebx, eax
  00064	76 05		 jbe	 SHORT $LN108@Copy

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()

  00066	bf fe ff ff 7f	 mov	 edi, 2147483646		; 7ffffffeH
$LN108@Copy:

; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  0006b	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0006e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00075	50		 push	 eax
  00076	8b ce		 mov	 ecx, esi
  00078	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  0007d	8b d0		 mov	 edx, eax
  0007f	eb 29		 jmp	 SHORT $LN429@Copy
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  00081	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00084	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax
  0008a	40		 inc	 eax
  0008b	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0008e	50		 push	 eax
  0008f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00093	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
  00098	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

  0009b	b8 00 00 00 00	 mov	 eax, $LN426@Copy
  000a0	c3		 ret	 0
$LN426@Copy:
  000a1	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000a4	8b 7d 08	 mov	 edi, DWORD PTR __Newres$[ebp]
  000a7	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN429@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

  000aa	8b 5d 0c	 mov	 ebx, DWORD PTR __Oldlen$[ebp]
  000ad	89 55 e8	 mov	 DWORD PTR __Ptr$1$[ebp], edx
  000b0	85 db		 test	 ebx, ebx
  000b2	74 1e		 je	 SHORT $LN260@Copy

; 2208 : 			_Traits::copy(_Unfancy(_Ptr), this->_Myptr(),

  000b4	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000b8	72 04		 jb	 SHORT $LN251@Copy
  000ba	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000bc	eb 02		 jmp	 SHORT $LN252@Copy
$LN251@Copy:
  000be	8b ce		 mov	 ecx, esi
$LN252@Copy:
  000c0	85 db		 test	 ebx, ebx
  000c2	74 0e		 je	 SHORT $LN260@Copy
  000c4	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  000c7	50		 push	 eax
  000c8	51		 push	 ecx
  000c9	52		 push	 edx
  000ca	e8 00 00 00 00	 call	 _memcpy
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN260@Copy:

; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);

  000d2	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000d5	83 f8 08	 cmp	 eax, 8
  000d8	72 0b		 jb	 SHORT $LN266@Copy
  000da	40		 inc	 eax
  000db	8b ce		 mov	 ecx, esi
  000dd	50		 push	 eax
  000de	ff 36		 push	 DWORD PTR [esi]
  000e0	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN266@Copy:
  000e5	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  000ec	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000f0	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000f7	72 04		 jb	 SHORT $LN356@Copy
  000f9	8b 06		 mov	 eax, DWORD PTR [esi]
  000fb	eb 02		 jmp	 SHORT $LN357@Copy
$LN356@Copy:
  000fd	8b c6		 mov	 eax, esi
$LN357@Copy:
  000ff	33 c9		 xor	 ecx, ecx
  00101	66 89 08	 mov	 WORD PTR [eax], cx

; 2211 : 		this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Ptr);

  00104	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  00107	89 06		 mov	 DWORD PTR [esi], eax

; 2212 : 		this->_Myres() = _Newres;

  00109	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 2213 : 		_Eos(_Oldlen);

  0010c	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00110	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00113	72 02		 jb	 SHORT $LN420@Copy
  00115	8b f0		 mov	 esi, eax
$LN420@Copy:
  00117	33 c0		 xor	 eax, eax
  00119	66 89 04 5e	 mov	 WORD PTR [esi+ebx*2], ax

; 2214 : 		}

  0011d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00120	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00127	59		 pop	 ecx
  00128	5f		 pop	 edi
  00129	5e		 pop	 esi
  0012a	5b		 pop	 ebx
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

  00131	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00134	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00137	83 f8 08	 cmp	 eax, 8
  0013a	72 0b		 jb	 SHORT $LN144@Copy
  0013c	40		 inc	 eax
  0013d	8b ce		 mov	 ecx, esi
  0013f	50		 push	 eax
  00140	ff 36		 push	 DWORD PTR [esi]
  00142	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN144@Copy:
  00147	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0014e	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00152	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00159	72 02		 jb	 SHORT $LN235@Copy
  0015b	8b 36		 mov	 esi, DWORD PTR [esi]
$LN235@Copy:
  0015d	33 c0		 xor	 eax, eax

; 2203 : 			_RERAISE;

  0015f	50		 push	 eax
  00160	50		 push	 eax
  00161	66 89 06	 mov	 WORD PTR [esi], ax
  00164	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN430@Copy:
$LN428@Copy:
  00169	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::get_allocator, COMDAT
; _this$ = ecx

; 2168 : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2169 : 		allocator_type _Ret(this->_Getal());
; 2170 : 		return (_Ret);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2171 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

  00009	39 45 0c	 cmp	 DWORD PTR __Size$[ebp], eax
  0000c	0f 46 45 0c	 cmovbe	 eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr, COMDAT
; _this$ = ecx

; 2088 : 		{	// return [_Off, _Off + _Count) as new string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 2089 : 		return (_Myt(*this, _Off, _Count, get_allocator()));

  00005	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	33 c0		 xor	 eax, eax
  0000d	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00017	51		 push	 ecx
  00018	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0001f	8b ce		 mov	 ecx, esi
  00021	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00028	66 89 06	 mov	 WORD PTR [esi], ax
  0002b	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi

; 2090 : 		}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 0c 00	 ret	 12			; 0000000cH
?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::empty, COMDAT
; _this$ = ecx

; 1803 : 		{	// test if sequence is empty

  00000	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00004	0f 94 c0	 sete	 al

; 1804 : 		return (this->_Mysize() == 0);
; 1805 : 		}

  00007	c3		 ret	 0
?empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::reserve, COMDAT
; _this$ = ecx

; 1793 : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Newcap$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f8		 cmp	 edi, eax
  0000f	77 22		 ja	 SHORT $LN47@reserve
  00011	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  00014	74 1d		 je	 SHORT $LN47@reserve

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

  00016	6a 01		 push	 1
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
  0001e	84 c0		 test	 al, al
  00020	74 11		 je	 SHORT $LN47@reserve

; 1798 : 				_Eos(_Size);

  00022	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00026	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00029	72 02		 jb	 SHORT $LN42@reserve
  0002b	8b 36		 mov	 esi, DWORD PTR [esi]
$LN42@reserve:
  0002d	33 c0		 xor	 eax, eax
  0002f	66 89 04 7e	 mov	 WORD PTR [esi+edi*2], ax
$LN47@reserve:
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi

; 1799 : 			}
; 1800 : 		}

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::capacity, COMDAT
; _this$ = ecx

; 1789 : 		return (this->_Myres());

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1790 : 		}

  00003	c3		 ret	 0
?capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH

; 1772 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT
; _this$ = ecx

; 1765 : 		return (this->_Mysize());

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1766 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 1743 : 		return (this->_Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN13@c_str
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1744 : 		}

  00008	c3		 ret	 0

; 1743 : 		return (this->_Myptr());

$LN13@c_str:
  00009	8b c1		 mov	 eax, ecx

; 1744 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1348 : 		_Check_offset(_Off);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	0f 82 88 00 00
	00		 jb	 $LN95@erase

; 1349 : 		if (this->_Mysize() - _Off <= _Count)

  00015	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00018	8b c7		 mov	 eax, edi
  0001a	2b c1		 sub	 eax, ecx
  0001c	3b c2		 cmp	 eax, edx
  0001e	77 27		 ja	 SHORT $LN2@erase

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

  00020	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  00023	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00027	72 10		 jb	 SHORT $LN41@erase
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	33 d2		 xor	 edx, edx
  0002d	5f		 pop	 edi
  0002e	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1357 : 			}
; 1358 : 		return (*this);

  00032	8b c6		 mov	 eax, esi
  00034	5e		 pop	 esi

; 1359 : 		}

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

$LN41@erase:
  00039	8b c6		 mov	 eax, esi
  0003b	33 d2		 xor	 edx, edx
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1359 : 		}

  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
$LN2@erase:

; 1351 : 		else if (0 < _Count)

  00047	85 d2		 test	 edx, edx
  00049	74 4a		 je	 SHORT $LN92@erase

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;

  0004b	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0004f	72 04		 jb	 SHORT $LN58@erase
  00051	8b 06		 mov	 eax, DWORD PTR [esi]
  00053	eb 02		 jmp	 SHORT $LN59@erase
$LN58@erase:
  00055	8b c6		 mov	 eax, esi
$LN59@erase:

; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

  00057	2b fa		 sub	 edi, edx
  00059	53		 push	 ebx
  0005a	8d 1c 48	 lea	 ebx, DWORD PTR [eax+ecx*2]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  0005d	8b c7		 mov	 eax, edi
  0005f	2b c1		 sub	 eax, ecx
  00061	74 10		 je	 SHORT $LN74@erase
  00063	03 c0		 add	 eax, eax
  00065	50		 push	 eax
  00066	8d 04 53	 lea	 eax, DWORD PTR [ebx+edx*2]
  00069	50		 push	 eax
  0006a	53		 push	 ebx
  0006b	e8 00 00 00 00	 call	 _memmove
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@erase:

; 1356 : 			_Eos(_Newsize);

  00073	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00077	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0007a	5b		 pop	 ebx
  0007b	72 10		 jb	 SHORT $LN87@erase
  0007d	8b 06		 mov	 eax, DWORD PTR [esi]
  0007f	33 c9		 xor	 ecx, ecx
  00081	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1357 : 			}
; 1358 : 		return (*this);

  00085	8b c6		 mov	 eax, esi
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 1359 : 		}

  00089	5d		 pop	 ebp
  0008a	c2 08 00	 ret	 8

; 1356 : 			_Eos(_Newsize);

$LN87@erase:
  0008d	8b c6		 mov	 eax, esi
  0008f	33 c9		 xor	 ecx, ecx
  00091	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN92@erase:

; 1357 : 			}
; 1358 : 		return (*this);

  00095	5f		 pop	 edi
  00096	8b c6		 mov	 eax, esi
  00098	5e		 pop	 esi

; 1359 : 		}

  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
$LN95@erase:

; 1348 : 		_Check_offset(_Off);

  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000a2	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN97@erase:
$LN94@erase:
  000a7	cc		 int	 3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1341 : 		_Check_offset(_Off);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	72 29		 jb	 SHORT $LN37@erase

; 1342 : 		_Eos(_Off);

  0000b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000e	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00012	72 10		 jb	 SHORT $LN29@erase
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	56		 push	 esi
  00017	33 f6		 xor	 esi, esi
  00019	66 89 34 42	 mov	 WORD PTR [edx+eax*2], si

; 1343 : 		return (*this);

  0001d	8b c1		 mov	 eax, ecx
  0001f	5e		 pop	 esi

; 1344 : 		}

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4

; 1342 : 		_Eos(_Off);

$LN29@erase:
  00024	8b d1		 mov	 edx, ecx
  00026	56		 push	 esi
  00027	33 f6		 xor	 esi, esi
  00029	66 89 34 42	 mov	 WORD PTR [edx+eax*2], si

; 1343 : 		return (*this);

  0002d	8b c1		 mov	 eax, ecx
  0002f	5e		 pop	 esi

; 1344 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN37@erase:

; 1341 : 		_Check_offset(_Off);

  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00039	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN39@erase:
$LN36@erase:
  0003e	cc		 int	 3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z
_TEXT	SEGMENT
tv845 = 8						; size = 4
tv843 = 8						; size = 4
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
tv846 = 16						; size = 4
__Roff$ = 16						; size = 4
tv848 = 20						; size = 4
__Count$ = 20						; size = 4
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert, COMDAT
; _this$ = ecx

; 1223 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 1224 : 		_Check_offset(_Off);

  00008	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000b	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  0000e	0f 82 76 01 00
	00		 jb	 $LN291@insert

; 1225 : 		_Right._Check_offset(_Roff);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00017	8b 55 10	 mov	 edx, DWORD PTR __Roff$[ebp]
  0001a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0001d	3b c2		 cmp	 eax, edx
  0001f	0f 82 6f 01 00
	00		 jb	 $LN293@insert

; 1226 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00025	8b 7d 14	 mov	 edi, DWORD PTR __Count$[ebp]
  00028	2b c2		 sub	 eax, edx
  0002a	3b f8		 cmp	 edi, eax
  0002c	0f 47 f8	 cmova	 edi, eax

; 1227 : 		if (npos - this->_Mysize() <= _Count)

  0002f	8b c1		 mov	 eax, ecx
  00031	f7 d0		 not	 eax
  00033	3b c7		 cmp	 eax, edi
  00035	0f 86 63 01 00
	00		 jbe	 $LN294@insert

; 1229 : 
; 1230 : 		const size_type _Num = this->_Mysize() + _Count;

  0003b	8d 1c 39	 lea	 ebx, DWORD PTR [ecx+edi]

; 1231 : 		if (0 < _Count && _Grow(_Num))

  0003e	85 ff		 test	 edi, edi
  00040	0f 84 3b 01 00
	00		 je	 $LN285@insert
  00046	81 fb fe ff ff
	7f		 cmp	 ebx, 2147483646		; 7ffffffeH
  0004c	0f 87 56 01 00
	00		 ja	 $LN295@insert
  00052	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00055	73 20		 jae	 SHORT $LN75@insert
  00057	51		 push	 ecx
  00058	53		 push	 ebx
  00059	8b ce		 mov	 ecx, esi
  0005b	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00060	85 db		 test	 ebx, ebx
  00062	0f 84 19 01 00
	00		 je	 $LN285@insert
$LN289@insert:

; 1232 : 			{	// make room and insert new stuff
; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00068	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0006b	83 f8 08	 cmp	 eax, 8
  0006e	72 32		 jb	 SHORT $LN178@insert
  00070	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00072	89 4d 14	 mov	 DWORD PTR tv848[ebp], ecx
  00075	eb 2e		 jmp	 SHORT $LN179@insert

; 1231 : 		if (0 < _Count && _Grow(_Num))

$LN75@insert:
  00077	85 db		 test	 ebx, ebx
  00079	75 ed		 jne	 SHORT $LN289@insert
  0007b	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  0007e	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00082	72 10		 jb	 SHORT $LN152@insert
  00084	8b 06		 mov	 eax, DWORD PTR [esi]
  00086	33 c9		 xor	 ecx, ecx
  00088	5f		 pop	 edi
  00089	66 89 08	 mov	 WORD PTR [eax], cx

; 1244 : 			}
; 1245 : 		return (*this);

  0008c	8b c6		 mov	 eax, esi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx

; 1246 : 		}

  00090	5d		 pop	 ebp
  00091	c2 10 00	 ret	 16			; 00000010H

; 1231 : 		if (0 < _Count && _Grow(_Num))

$LN152@insert:
  00094	8b c6		 mov	 eax, esi
  00096	33 c9		 xor	 ecx, ecx
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx
  0009b	66 89 08	 mov	 WORD PTR [eax], cx

; 1246 : 		}

  0009e	5d		 pop	 ebp
  0009f	c2 10 00	 ret	 16			; 00000010H

; 1232 : 			{	// make room and insert new stuff
; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

$LN178@insert:
  000a2	89 75 14	 mov	 DWORD PTR tv848[ebp], esi
$LN179@insert:
  000a5	83 f8 08	 cmp	 eax, 8
  000a8	72 04		 jb	 SHORT $LN192@insert
  000aa	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000ac	eb 02		 jmp	 SHORT $LN193@insert
$LN192@insert:
  000ae	8b ce		 mov	 ecx, esi
$LN193@insert:
  000b0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b3	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000b6	2b c2		 sub	 eax, edx
  000b8	74 1c		 je	 SHORT $LN199@insert
  000ba	03 c0		 add	 eax, eax
  000bc	50		 push	 eax
  000bd	8b 45 14	 mov	 eax, DWORD PTR tv848[ebp]
  000c0	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  000c3	50		 push	 eax
  000c4	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  000c7	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _memmove
  000d0	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN199@insert:

; 1234 : 				this->_Myptr() + _Off,
; 1235 : 				this->_Mysize() - _Off);	// empty out hole
; 1236 : 			if (this == &_Right)

  000d6	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  000d9	3b f1		 cmp	 esi, ecx
  000db	75 4c		 jne	 SHORT $LN4@insert

; 1237 : 				_Traits::move(this->_Myptr() + _Off,

  000dd	8b 45 10	 mov	 eax, DWORD PTR __Roff$[ebp]
  000e0	3b d0		 cmp	 edx, eax
  000e2	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  000e5	0f 43 c8	 cmovae	 ecx, eax
  000e8	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000eb	83 f8 08	 cmp	 eax, 8
  000ee	72 0a		 jb	 SHORT $LN212@insert
  000f0	8b 16		 mov	 edx, DWORD PTR [esi]
  000f2	89 55 10	 mov	 DWORD PTR tv846[ebp], edx
  000f5	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000f8	eb 03		 jmp	 SHORT $LN213@insert
$LN212@insert:
  000fa	89 75 10	 mov	 DWORD PTR tv846[ebp], esi
$LN213@insert:
  000fd	83 f8 08	 cmp	 eax, 8
  00100	72 07		 jb	 SHORT $LN226@insert
  00102	8b 06		 mov	 eax, DWORD PTR [esi]
  00104	89 45 08	 mov	 DWORD PTR tv845[ebp], eax
  00107	eb 03		 jmp	 SHORT $LN227@insert
$LN226@insert:
  00109	89 75 08	 mov	 DWORD PTR tv845[ebp], esi
$LN227@insert:
  0010c	85 ff		 test	 edi, edi
  0010e	74 4f		 je	 SHORT $LN267@insert
  00110	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00113	50		 push	 eax
  00114	8b 45 10	 mov	 eax, DWORD PTR tv846[ebp]
  00117	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  0011a	50		 push	 eax
  0011b	8b 45 08	 mov	 eax, DWORD PTR tv845[ebp]
  0011e	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 _memmove

; 1238 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1239 : 						_Count);	// substring
; 1240 : 			else

  00127	eb 33		 jmp	 SHORT $LN290@insert
$LN4@insert:

; 1241 : 				_Traits::copy(this->_Myptr() + _Off,

  00129	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  0012d	72 02		 jb	 SHORT $LN246@insert
  0012f	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN246@insert:
  00131	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00135	72 07		 jb	 SHORT $LN260@insert
  00137	8b 06		 mov	 eax, DWORD PTR [esi]
  00139	89 45 08	 mov	 DWORD PTR tv843[ebp], eax
  0013c	eb 03		 jmp	 SHORT $LN261@insert
$LN260@insert:
  0013e	89 75 08	 mov	 DWORD PTR tv843[ebp], esi
$LN261@insert:
  00141	85 ff		 test	 edi, edi
  00143	74 1a		 je	 SHORT $LN267@insert
  00145	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00148	50		 push	 eax
  00149	8b 45 10	 mov	 eax, DWORD PTR __Roff$[ebp]
  0014c	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0014f	50		 push	 eax
  00150	8b 45 08	 mov	 eax, DWORD PTR tv843[ebp]
  00153	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 _memcpy
$LN290@insert:
  0015c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN267@insert:

; 1242 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1243 : 			_Eos(_Num);

  0015f	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00163	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00166	72 11		 jb	 SHORT $LN280@insert
  00168	8b 06		 mov	 eax, DWORD PTR [esi]
  0016a	33 c9		 xor	 ecx, ecx
  0016c	5f		 pop	 edi
  0016d	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx

; 1244 : 			}
; 1245 : 		return (*this);

  00171	8b c6		 mov	 eax, esi
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx

; 1246 : 		}

  00175	5d		 pop	 ebp
  00176	c2 10 00	 ret	 16			; 00000010H

; 1242 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1243 : 			_Eos(_Num);

$LN280@insert:
  00179	8b c6		 mov	 eax, esi
  0017b	33 c9		 xor	 ecx, ecx
  0017d	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx
$LN285@insert:

; 1244 : 			}
; 1245 : 		return (*this);

  00181	5f		 pop	 edi
  00182	8b c6		 mov	 eax, esi
  00184	5e		 pop	 esi
  00185	5b		 pop	 ebx

; 1246 : 		}

  00186	5d		 pop	 ebp
  00187	c2 10 00	 ret	 16			; 00000010H
$LN291@insert:

; 1224 : 		_Check_offset(_Off);

  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0018f	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN296@insert:
$LN293@insert:

; 1225 : 		_Right._Check_offset(_Roff);

  00194	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00199	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN297@insert:
$LN294@insert:

; 1228 : 			_Xlen();	// result too long

  0019e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  001a3	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN298@insert:
$LN295@insert:

; 1231 : 		if (0 < _Count && _Grow(_Num))

  001a8	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  001ad	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN299@insert:
$LN287@insert:
  001b2	cc		 int	 3
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert, COMDAT
; _this$ = ecx

; 1217 : 		{	// insert _Right at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1218 : 		return (insert(_Off, _Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 0c	 push	 DWORD PTR __Right$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  0000d	e8 00 00 00 00	 call	 ?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert

; 1219 : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?insert@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000d	75 0e		 jne	 SHORT $LN5@assign
  0000f	33 c0		 xor	 eax, eax
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00018	5e		 pop	 esi

; 1183 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

$LN5@assign:
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL7@assign:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL7@assign
  0002e	2b c7		 sub	 eax, edi
  00030	8b ce		 mov	 ecx, esi
  00032	5f		 pop	 edi
  00033	d1 f8		 sar	 eax, 1
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0003c	5e		 pop	 esi

; 1183 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1166 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1167 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 48		 je	 SHORT $LN2@assign
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 08	 cmp	 ecx, 8
  00014	72 04		 jb	 SHORT $LN20@assign
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN21@assign
$LN20@assign:
  0001a	8b c6		 mov	 eax, esi
$LN21@assign:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 36		 jb	 SHORT $LN2@assign
  00020	83 f9 08	 cmp	 ecx, 8
  00023	72 04		 jb	 SHORT $LN34@assign
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN35@assign
$LN34@assign:
  00029	8b d6		 mov	 edx, esi
$LN35@assign:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00031	3b c3		 cmp	 eax, ebx
  00033	76 21		 jbe	 SHORT $LN2@assign

; 1168 : 			return (assign(*this,

  00035	83 f9 08	 cmp	 ecx, 8
  00038	72 04		 jb	 SHORT $LN57@assign
  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	eb 02		 jmp	 SHORT $LN58@assign
$LN57@assign:
  0003e	8b c6		 mov	 eax, esi
$LN58@assign:
  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	2b d8		 sub	 ebx, eax
  00045	8b ce		 mov	 ecx, esi
  00047	d1 fb		 sar	 ebx, 1
  00049	53		 push	 ebx
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 1177 : 		}

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN2@assign:
  00056	57		 push	 edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  00057	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0005a	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00060	0f 87 88 00 00
	00		 ja	 $LN189@assign
  00066	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00069	73 19		 jae	 SHORT $LN63@assign
  0006b	ff 76 10	 push	 DWORD PTR [esi+16]
  0006e	8b ce		 mov	 ecx, esi
  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00076	85 ff		 test	 edi, edi
  00078	74 6b		 je	 SHORT $LN183@assign
$LN188@assign:

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  0007a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0007e	72 2f		 jb	 SHORT $LN158@assign
  00080	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00082	eb 2d		 jmp	 SHORT $LN159@assign

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN63@assign:
  00084	85 ff		 test	 edi, edi
  00086	75 f2		 jne	 SHORT $LN188@assign
  00088	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0008c	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0008f	72 10		 jb	 SHORT $LN140@assign
  00091	8b 06		 mov	 eax, DWORD PTR [esi]
  00093	33 c9		 xor	 ecx, ecx
  00095	5f		 pop	 edi
  00096	66 89 08	 mov	 WORD PTR [eax], cx

; 1175 : 			}
; 1176 : 		return (*this);

  00099	8b c6		 mov	 eax, esi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx

; 1177 : 		}

  0009d	5d		 pop	 ebp
  0009e	c2 08 00	 ret	 8

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN140@assign:
  000a1	8b c6		 mov	 eax, esi
  000a3	33 c9		 xor	 ecx, ecx
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx
  000a8	66 89 08	 mov	 WORD PTR [eax], cx

; 1177 : 		}

  000ab	5d		 pop	 ebp
  000ac	c2 08 00	 ret	 8

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

$LN158@assign:
  000af	8b ce		 mov	 ecx, esi
$LN159@assign:
  000b1	85 ff		 test	 edi, edi
  000b3	74 0e		 je	 SHORT $LN165@assign
  000b5	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  000b8	50		 push	 eax
  000b9	53		 push	 ebx
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 _memcpy
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN165@assign:

; 1174 : 			_Eos(_Count);

  000c3	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000c7	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ca	72 11		 jb	 SHORT $LN178@assign
  000cc	8b 06		 mov	 eax, DWORD PTR [esi]
  000ce	33 c9		 xor	 ecx, ecx
  000d0	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1175 : 			}
; 1176 : 		return (*this);

  000d4	8b c6		 mov	 eax, esi
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx

; 1177 : 		}

  000d9	5d		 pop	 ebp
  000da	c2 08 00	 ret	 8

; 1174 : 			_Eos(_Count);

$LN178@assign:
  000dd	8b c6		 mov	 eax, esi
  000df	33 c9		 xor	 ecx, ecx
  000e1	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN183@assign:

; 1175 : 			}
; 1176 : 		return (*this);

  000e5	5f		 pop	 edi
  000e6	8b c6		 mov	 eax, esi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx

; 1177 : 		}

  000ea	5d		 pop	 ebp
  000eb	c2 08 00	 ret	 8
$LN189@assign:

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f3	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN191@assign:
$LN186@assign:
  000f8	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1150 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 e3 00 00
	00		 jb	 $LN210@assign

; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00019	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
  0001c	2b c1		 sub	 eax, ecx
  0001e	3b f8		 cmp	 edi, eax
  00020	0f 47 f8	 cmova	 edi, eax

; 1152 : 
; 1153 : 		if (this == &_Right)

  00023	3b f3		 cmp	 esi, ebx
  00025	75 33		 jne	 SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  0002d	0f 82 d3 00 00
	00		 jb	 $LN212@assign
  00033	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00036	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0003a	72 04		 jb	 SHORT $LN63@assign
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	eb 02		 jmp	 SHORT $LN64@assign
$LN63@assign:
  00040	8b d6		 mov	 edx, esi
$LN64@assign:
  00042	33 ff		 xor	 edi, edi
  00044	51		 push	 ecx
  00045	57		 push	 edi
  00046	8b ce		 mov	 ecx, esi
  00048	66 89 3c 42	 mov	 WORD PTR [edx+eax*2], di
  0004c	e8 00 00 00 00	 call	 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
  00051	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  00052	8b c6		 mov	 eax, esi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx

; 1162 : 		}

  00056	5d		 pop	 ebp
  00057	c2 0c 00	 ret	 12			; 0000000cH
$LN2@assign:

; 1155 : 		else if (_Grow(_Count))

  0005a	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00060	0f 87 aa 00 00
	00		 ja	 $LN213@assign
  00066	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00069	73 24		 jae	 SHORT $LN72@assign
  0006b	ff 76 10	 push	 DWORD PTR [esi+16]
  0006e	8b ce		 mov	 ecx, esi
  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  00076	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  00079	85 ff		 test	 edi, edi
  0007b	74 76		 je	 SHORT $LN205@assign
$LN209@assign:

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

  0007d	83 7b 14 08	 cmp	 DWORD PTR [ebx+20], 8
  00081	72 02		 jb	 SHORT $LN166@assign
  00083	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN166@assign:
  00085	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00089	72 2f		 jb	 SHORT $LN180@assign
  0008b	8b 16		 mov	 edx, DWORD PTR [esi]
  0008d	eb 2d		 jmp	 SHORT $LN181@assign

; 1155 : 		else if (_Grow(_Count))

$LN72@assign:
  0008f	85 ff		 test	 edi, edi
  00091	75 ea		 jne	 SHORT $LN209@assign
  00093	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00097	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0009a	72 10		 jb	 SHORT $LN149@assign
  0009c	8b 06		 mov	 eax, DWORD PTR [esi]
  0009e	33 c9		 xor	 ecx, ecx
  000a0	5f		 pop	 edi
  000a1	66 89 08	 mov	 WORD PTR [eax], cx

; 1160 : 			}
; 1161 : 		return (*this);

  000a4	8b c6		 mov	 eax, esi
  000a6	5e		 pop	 esi
  000a7	5b		 pop	 ebx

; 1162 : 		}

  000a8	5d		 pop	 ebp
  000a9	c2 0c 00	 ret	 12			; 0000000cH

; 1155 : 		else if (_Grow(_Count))

$LN149@assign:
  000ac	8b c6		 mov	 eax, esi
  000ae	33 c9		 xor	 ecx, ecx
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	66 89 08	 mov	 WORD PTR [eax], cx

; 1162 : 		}

  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

$LN180@assign:
  000ba	8b d6		 mov	 edx, esi
$LN181@assign:
  000bc	85 ff		 test	 edi, edi
  000be	74 11		 je	 SHORT $LN187@assign
  000c0	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  000c3	50		 push	 eax
  000c4	8d 04 4b	 lea	 eax, DWORD PTR [ebx+ecx*2]
  000c7	50		 push	 eax
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 _memcpy
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN187@assign:

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

  000d1	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000d5	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000d8	72 11		 jb	 SHORT $LN200@assign
  000da	8b 06		 mov	 eax, DWORD PTR [esi]
  000dc	33 c9		 xor	 ecx, ecx
  000de	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1160 : 			}
; 1161 : 		return (*this);

  000e2	8b c6		 mov	 eax, esi
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 1162 : 		}

  000e7	5d		 pop	 ebp
  000e8	c2 0c 00	 ret	 12			; 0000000cH

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

$LN200@assign:
  000eb	8b c6		 mov	 eax, esi
  000ed	33 c9		 xor	 ecx, ecx
  000ef	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN205@assign:

; 1160 : 			}
; 1161 : 		return (*this);

  000f3	5f		 pop	 edi
  000f4	8b c6		 mov	 eax, esi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx

; 1162 : 		}

  000f8	5d		 pop	 ebp
  000f9	c2 0c 00	 ret	 12			; 0000000cH
$LN210@assign:

; 1150 : 		_Right._Check_offset(_Roff);

  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00101	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN214@assign:
$LN212@assign:

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0010b	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN215@assign:
$LN213@assign:

; 1155 : 		else if (_Grow(_Count))

  00110	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00115	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN216@assign:
$LN207@assign:
  0011a	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1143 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1144 : 		return (assign(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 1145 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1105 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000d	75 0e		 jne	 SHORT $LN5@append
  0000f	33 c0		 xor	 eax, eax
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00018	5e		 pop	 esi

; 1108 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

$LN5@append:
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL7@append:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL7@append
  0002e	2b c7		 sub	 eax, edi
  00030	8b ce		 mov	 ecx, esi
  00032	5f		 pop	 edi
  00033	d1 f8		 sar	 eax, 1
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  0003c	5e		 pop	 esi

; 1108 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1087 : 		{	// append [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1088 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1089 : 		if (_Inside(_Ptr))

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	74 48		 je	 SHORT $LN2@append
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 08	 cmp	 ecx, 8
  00014	72 04		 jb	 SHORT $LN21@append
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN22@append
$LN21@append:
  0001a	8b c6		 mov	 eax, esi
$LN22@append:
  0001c	3b f8		 cmp	 edi, eax
  0001e	72 36		 jb	 SHORT $LN2@append
  00020	83 f9 08	 cmp	 ecx, 8
  00023	72 04		 jb	 SHORT $LN35@append
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN36@append
$LN35@append:
  00029	8b d6		 mov	 edx, esi
$LN36@append:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00031	3b c7		 cmp	 eax, edi
  00033	76 21		 jbe	 SHORT $LN2@append

; 1090 : 			return (append(*this,

  00035	83 f9 08	 cmp	 ecx, 8
  00038	72 04		 jb	 SHORT $LN58@append
  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	eb 02		 jmp	 SHORT $LN59@append
$LN58@append:
  0003e	8b c6		 mov	 eax, esi
$LN59@append:
  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	2b f8		 sub	 edi, eax
  00045	8b ce		 mov	 ecx, esi
  00047	d1 ff		 sar	 edi, 1
  00049	57		 push	 edi
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi

; 1102 : 		}

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN2@append:

; 1091 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1092 : 		if (npos - this->_Mysize() <= _Count)

  00056	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00059	8b c2		 mov	 eax, edx
  0005b	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005e	f7 d0		 not	 eax
  00060	3b c1		 cmp	 eax, ecx
  00062	0f 86 a7 00 00
	00		 jbe	 $LN219@append

; 1094 : 
; 1095 : 		const size_type _Num = this->_Mysize() + _Count;

  00068	53		 push	 ebx
  00069	8d 1c 0a	 lea	 ebx, DWORD PTR [edx+ecx]

; 1096 : 		if (0 < _Count && _Grow(_Num))

  0006c	85 c9		 test	 ecx, ecx
  0006e	0f 84 92 00 00
	00		 je	 $LN213@append
  00074	81 fb fe ff ff
	7f		 cmp	 ebx, 2147483646		; 7ffffffeH
  0007a	0f 87 99 00 00
	00		 ja	 $LN221@append
  00080	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00083	73 1a		 jae	 SHORT $LN85@append
  00085	52		 push	 edx
  00086	53		 push	 ebx
  00087	8b ce		 mov	 ecx, esi
  00089	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0008e	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00091	85 db		 test	 ebx, ebx
  00093	74 71		 je	 SHORT $LN213@append
$LN218@append:

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

  00095	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  00099	72 2f		 jb	 SHORT $LN179@append
  0009b	8b 16		 mov	 edx, DWORD PTR [esi]
  0009d	eb 2d		 jmp	 SHORT $LN180@append

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN85@append:
  0009f	85 db		 test	 ebx, ebx
  000a1	75 f2		 jne	 SHORT $LN218@append
  000a3	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000a6	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000aa	72 10		 jb	 SHORT $LN162@append
  000ac	8b 06		 mov	 eax, DWORD PTR [esi]
  000ae	33 c9		 xor	 ecx, ecx
  000b0	5b		 pop	 ebx
  000b1	5f		 pop	 edi
  000b2	66 89 08	 mov	 WORD PTR [eax], cx

; 1100 : 			}
; 1101 : 		return (*this);

  000b5	8b c6		 mov	 eax, esi
  000b7	5e		 pop	 esi

; 1102 : 		}

  000b8	5d		 pop	 ebp
  000b9	c2 08 00	 ret	 8

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN162@append:
  000bc	8b c6		 mov	 eax, esi
  000be	33 c9		 xor	 ecx, ecx
  000c0	5b		 pop	 ebx
  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	66 89 08	 mov	 WORD PTR [eax], cx

; 1102 : 		}

  000c6	5d		 pop	 ebp
  000c7	c2 08 00	 ret	 8

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

$LN179@append:
  000ca	8b d6		 mov	 edx, esi
$LN180@append:
  000cc	85 c9		 test	 ecx, ecx
  000ce	74 14		 je	 SHORT $LN195@append
  000d0	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  000d3	50		 push	 eax
  000d4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000d7	57		 push	 edi
  000d8	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _memcpy
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN195@append:

; 1099 : 			_Eos(_Num);

  000e4	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000e8	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  000eb	72 11		 jb	 SHORT $LN208@append
  000ed	8b 06		 mov	 eax, DWORD PTR [esi]
  000ef	33 c9		 xor	 ecx, ecx
  000f1	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx

; 1100 : 			}
; 1101 : 		return (*this);

  000f5	8b c6		 mov	 eax, esi
  000f7	5b		 pop	 ebx
  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi

; 1102 : 		}

  000fa	5d		 pop	 ebp
  000fb	c2 08 00	 ret	 8

; 1099 : 			_Eos(_Num);

$LN208@append:
  000fe	8b c6		 mov	 eax, esi
  00100	33 c9		 xor	 ecx, ecx
  00102	66 89 0c 58	 mov	 WORD PTR [eax+ebx*2], cx
$LN213@append:

; 1100 : 			}
; 1101 : 		return (*this);

  00106	5b		 pop	 ebx
  00107	5f		 pop	 edi
  00108	8b c6		 mov	 eax, esi
  0010a	5e		 pop	 esi

; 1102 : 		}

  0010b	5d		 pop	 ebp
  0010c	c2 08 00	 ret	 8
$LN219@append:

; 1093 : 			_Xlen();	// result too long

  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00114	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN222@append:
$LN221@append:

; 1096 : 		if (0 < _Count && _Grow(_Num))

  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN223@append:
$LN216@append:
  00123	cc		 int	 3
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1071 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 d0 00 00
	00		 jb	 $LN203@append

; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

  00019	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0001c	2b c1		 sub	 eax, ecx
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00021	3b c8		 cmp	 ecx, eax
  00023	0f 47 c8	 cmova	 ecx, eax
  00026	8b c2		 mov	 eax, edx
  00028	f7 d0		 not	 eax
  0002a	89 4d 10	 mov	 DWORD PTR __Count$[ebp], ecx
  0002d	3b c1		 cmp	 eax, ecx
  0002f	0f 86 be 00 00
	00		 jbe	 $LN205@append

; 1075 : 
; 1076 : 		const size_type _Num = this->_Mysize() + _Count;

  00035	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 1077 : 		if (0 < _Count && _Grow(_Num))

  00038	85 c9		 test	 ecx, ecx
  0003a	0f 84 a0 00 00
	00		 je	 $LN198@append
  00040	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00046	0f 87 b1 00 00
	00		 ja	 $LN206@append
  0004c	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0004f	73 22		 jae	 SHORT $LN56@append
  00051	52		 push	 edx
  00052	57		 push	 edi
  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
  0005a	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005d	85 ff		 test	 edi, edi
  0005f	74 7f		 je	 SHORT $LN198@append
$LN202@append:

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

  00061	83 7b 14 08	 cmp	 DWORD PTR [ebx+20], 8
  00065	72 02		 jb	 SHORT $LN150@append
  00067	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN150@append:
  00069	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0006d	72 2f		 jb	 SHORT $LN164@append
  0006f	8b 16		 mov	 edx, DWORD PTR [esi]
  00071	eb 2d		 jmp	 SHORT $LN165@append

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN56@append:
  00073	85 ff		 test	 edi, edi
  00075	75 ea		 jne	 SHORT $LN202@append
  00077	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0007a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0007e	72 10		 jb	 SHORT $LN133@append
  00080	8b 06		 mov	 eax, DWORD PTR [esi]
  00082	33 c9		 xor	 ecx, ecx
  00084	5f		 pop	 edi
  00085	66 89 08	 mov	 WORD PTR [eax], cx

; 1082 : 			}
; 1083 : 		return (*this);

  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx

; 1084 : 		}

  0008c	5d		 pop	 ebp
  0008d	c2 0c 00	 ret	 12			; 0000000cH

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN133@append:
  00090	8b c6		 mov	 eax, esi
  00092	33 c9		 xor	 ecx, ecx
  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	66 89 08	 mov	 WORD PTR [eax], cx

; 1084 : 		}

  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

$LN164@append:
  0009e	8b d6		 mov	 edx, esi
$LN165@append:
  000a0	85 c9		 test	 ecx, ecx
  000a2	74 1a		 je	 SHORT $LN180@append
  000a4	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  000a7	50		 push	 eax
  000a8	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  000ab	8d 04 43	 lea	 eax, DWORD PTR [ebx+eax*2]
  000ae	50		 push	 eax
  000af	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b2	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _memcpy
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN180@append:

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

  000be	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  000c2	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000c5	72 11		 jb	 SHORT $LN193@append
  000c7	8b 06		 mov	 eax, DWORD PTR [esi]
  000c9	33 c9		 xor	 ecx, ecx
  000cb	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx

; 1082 : 			}
; 1083 : 		return (*this);

  000cf	8b c6		 mov	 eax, esi
  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	5b		 pop	 ebx

; 1084 : 		}

  000d4	5d		 pop	 ebp
  000d5	c2 0c 00	 ret	 12			; 0000000cH

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

$LN193@append:
  000d8	8b c6		 mov	 eax, esi
  000da	33 c9		 xor	 ecx, ecx
  000dc	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
$LN198@append:

; 1082 : 			}
; 1083 : 		return (*this);

  000e0	5f		 pop	 edi
  000e1	8b c6		 mov	 eax, esi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx

; 1084 : 		}

  000e5	5d		 pop	 ebp
  000e6	c2 0c 00	 ret	 12			; 0000000cH
$LN203@append:

; 1071 : 		_Right._Check_offset(_Roff);

  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000ee	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN207@append:
$LN205@append:

; 1074 : 			_Xlen();	// result too long

  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f8	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN208@append:
$LN206@append:

; 1077 : 		if (0 < _Count && _Grow(_Num))

  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00102	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN209@append:
$LN200@append:
  00107	cc		 int	 3
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 1064 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1065 : 		return (append(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 1066 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=, COMDAT
; _this$ = ecx

; 1054 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1055 : 		return (append(_Ptr));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000d	75 0e		 jne	 SHORT $LN7@operator
  0000f	33 c0		 xor	 eax, eax
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00018	5e		 pop	 esi

; 1056 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4

; 1055 : 		return (append(_Ptr));

$LN7@operator:
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL9@operator:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL9@operator
  0002e	2b c7		 sub	 eax, edi
  00030	8b ce		 mov	 ecx, esi
  00032	5f		 pop	 edi
  00033	d1 f8		 sar	 eax, 1
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  0003c	5e		 pop	 esi

; 1056 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=, COMDAT
; _this$ = ecx

; 1049 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1050 : 		return (append(_Right));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 1051 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 1039 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1040 : 		return (assign(_Ptr));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0000d	75 0e		 jne	 SHORT $LN7@operator
  0000f	33 c0		 xor	 eax, eax
  00011	50		 push	 eax
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00018	5e		 pop	 esi

; 1041 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4

; 1040 : 		return (assign(_Ptr));

$LN7@operator:
  0001d	8b c2		 mov	 eax, edx
  0001f	57		 push	 edi
  00020	8d 78 02	 lea	 edi, DWORD PTR [eax+2]
$LL9@operator:
  00023	66 8b 08	 mov	 cx, WORD PTR [eax]
  00026	83 c0 02	 add	 eax, 2
  00029	66 85 c9	 test	 cx, cx
  0002c	75 f5		 jne	 SHORT $LL9@operator
  0002e	2b c7		 sub	 eax, edi
  00030	8b ce		 mov	 ecx, esi
  00032	5f		 pop	 edi
  00033	d1 f8		 sar	 eax, 1
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  0003c	5e		 pop	 esi

; 1041 : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 1023 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1024 : 		if (this != &_Right)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b f0		 cmp	 esi, eax
  0000b	74 0a		 je	 SHORT $LN134@operator

; 1025 : 			{	// different, assign it
; 1026 : 			if (this->_Getal() != _Right._Getal()
; 1027 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1028 : 				{	// change allocator before copying
; 1029 : 				_Tidy(true);
; 1030 : 				this->_Copy_alloc(_Right._Getal());
; 1031 : 				}
; 1032 : 
; 1033 : 			assign(_Right);

  0000d	6a ff		 push	 -1
  0000f	6a 00		 push	 0
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN134@operator:

; 1034 : 			}
; 1035 : 		return (*this);

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi

; 1036 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1017 : 		_Tidy(true);

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 08	 cmp	 eax, 8
  00009	72 09		 jb	 SHORT $LN6@basic_stri
  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
$LN6@basic_stri:
  00014	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0001b	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	72 09		 jb	 SHORT $LN96@basic_stri
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	33 c9		 xor	 ecx, ecx
  0002c	5e		 pop	 esi
  0002d	66 89 08	 mov	 WORD PTR [eax], cx

; 1018 : 		}

  00030	c3		 ret	 0

; 1017 : 		_Tidy(true);

$LN96@basic_stri:
  00031	33 c0		 xor	 eax, eax
  00033	66 89 06	 mov	 WORD PTR [esi], ax
  00036	5e		 pop	 esi

; 1018 : 		}

  00037	c3		 ret	 0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv, COMDAT
; _this$ = ecx

; 961  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0000e	73 17		 jae	 SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	83 c0 01	 add	 eax, 1
  00016	74 1d		 je	 SHORT $LN3@Assign_rv
  00018	03 c0		 add	 eax, eax
  0001a	50		 push	 eax
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 964  : 				_Right._Mysize() + 1);
; 965  : 		else

  00025	eb 0e		 jmp	 SHORT $LN3@Assign_rv
$LN2@Assign_rv:

; 966  : 			{	// copy pointer
; 967  : 			this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Right._Bx()._Ptr);

  00027	85 ff		 test	 edi, edi
  00029	74 04		 je	 SHORT $LN86@Assign_rv
  0002b	8b 06		 mov	 eax, DWORD PTR [esi]
  0002d	89 07		 mov	 DWORD PTR [edi], eax
$LN86@Assign_rv:

; 968  : 			_Right._Bx()._Ptr = pointer();

  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

  00035	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00038	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

  0003b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0003e	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 972  : 		_Right._Tidy();

  00041	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00048	83 7e 14 08	 cmp	 DWORD PTR [esi+20], 8
  0004c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00053	72 0d		 jb	 SHORT $LN231@Assign_rv
  00055	8b 06		 mov	 eax, DWORD PTR [esi]
  00057	33 c9		 xor	 ecx, ecx
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	66 89 08	 mov	 WORD PTR [eax], cx

; 973  : 		}

  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4

; 972  : 		_Right._Tidy();

$LN231@Assign_rv:
  00062	33 c0		 xor	 eax, eax
  00064	5f		 pop	 edi
  00065	66 89 06	 mov	 WORD PTR [esi], ax
  00068	5e		 pop	 esi

; 973  : 		}

  00069	5d		 pop	 ebp
  0006a	c2 04 00	 ret	 4
?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 911  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 912  : 		_Tidy();
; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00004	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	33 c0		 xor	 eax, eax
  0000b	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00012	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00019	66 89 06	 mov	 WORD PTR [esi], ax
  0001c	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv

; 914  : 		}

  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00012	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00019	66 89 06	 mov	 WORD PTR [esi], ax
  0001c	66 39 02	 cmp	 WORD PTR [edx], ax
  0001f	75 12		 jne	 SHORT $LN113@basic_stri
  00021	33 c9		 xor	 ecx, ecx
  00023	51		 push	 ecx
  00024	52		 push	 edx
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 839  : 		}

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

$LN113@basic_stri:
  00033	8b ca		 mov	 ecx, edx
  00035	57		 push	 edi
  00036	8d 79 02	 lea	 edi, DWORD PTR [ecx+2]
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL115@basic_stri:
  00040	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00043	83 c1 02	 add	 ecx, 2
  00046	66 85 c0	 test	 ax, ax
  00049	75 f5		 jne	 SHORT $LL115@basic_stri
  0004b	2b cf		 sub	 ecx, edi
  0004d	d1 f9		 sar	 ecx, 1
  0004f	5f		 pop	 edi
  00050	51		 push	 ecx
  00051	52		 push	 edx
  00052	8b ce		 mov	 ecx, esi
  00054	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 839  : 		}

  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 822  : 		{	// construct from [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 823  : 		_Tidy();
; 824  : 		assign(_Ptr, _Count);

  00004	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	33 c0		 xor	 eax, eax
  0000b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000e	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00015	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001c	66 89 06	 mov	 WORD PTR [esi], ax
  0001f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 825  : 		}

  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$ = 20						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 815  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 816  : 		_Tidy();
; 817  : 		assign(_Right, _Roff, _Count);

  00004	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	33 c0		 xor	 eax, eax
  0000b	ff 75 0c	 push	 DWORD PTR __Roff$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00011	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00018	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001f	66 89 06	 mov	 WORD PTR [esi], ax
  00022	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 818  : 		}

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c2 10 00	 ret	 16			; 00000010H
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@IIABV?$allocator@_W@1@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 795  : 		_Tidy();

  00000	33 c0		 xor	 eax, eax
  00002	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7
  00009	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00010	66 89 01	 mov	 WORD PTR [ecx], ax

; 796  : 		}

  00013	8b c1		 mov	 eax, ecx
  00015	c3		 ret	 0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 781  : 		_Tidy();

  00006	33 c0		 xor	 eax, eax

; 782  : 		assign(_Right, 0, npos);

  00008	6a ff		 push	 -1
  0000a	50		 push	 eax
  0000b	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000e	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00015	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001c	66 89 06	 mov	 WORD PTR [esi], ax
  0001f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 783  : 		}

  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres, COMDAT
; _this$ = ecx

; 739  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 740  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 735  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 730  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 725  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

  00000	8b c1		 mov	 eax, ecx

; 715  : 		}

  00002	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 708  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 703  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 698  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 693  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 602  : 		_Pocca(_Getal(), _Al);
; 603  : 		}

  00000	c2 04 00	 ret	 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

; 588  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 590  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 583  : 		return (_Get_data()._Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 584  : 		}

  00008	c3		 ret	 0

; 583  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 584  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 578  : 		return (_Get_data()._Myptr());

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 579  : 		}

  00008	c3		 ret	 0

; 578  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 579  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 534  : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 08	 cmp	 DWORD PTR [ecx+20], 8
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 499  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1009 : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000e	77 30		 ja	 SHORT $LN16@deallocate
  00010	03 c0		 add	 eax, eax
  00012	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00017	72 1a		 jb	 SHORT $LN7@deallocate
  00019	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001c	75 27		 jne	 SHORT $LN18@deallocate
  0001e	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00021	3b c1		 cmp	 eax, ecx
  00023	73 25		 jae	 SHORT $LN19@deallocate
  00025	2b c8		 sub	 ecx, eax
  00027	83 f9 04	 cmp	 ecx, 4
  0002a	72 23		 jb	 SHORT $LN20@deallocate
  0002c	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0002f	77 23		 ja	 SHORT $LN21@deallocate
  00031	8b c8		 mov	 ecx, eax
$LN7@deallocate:
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4

; 988  : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00040	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:
  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  00059	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 977  : 		}

  00003	5d		 pop	 ebp

; 976  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 870  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@_W@std@@QBEIXZ PROC		; std::allocator<wchar_t>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 750  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@_W@std@@QBEIXZ ENDP		; std::allocator<wchar_t>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z PROC		; std::allocator<wchar_t>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00013	77 3b		 ja	 SHORT $LN14@allocate
  00015	03 c0		 add	 eax, eax
  00017	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001c	72 23		 jb	 SHORT $LN6@allocate
  0001e	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00021	3b c8		 cmp	 ecx, eax
  00023	76 30		 jbe	 SHORT $LN16@allocate
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002b	8b c8		 mov	 ecx, eax
  0002d	83 c4 04	 add	 esp, 4
  00030	85 c9		 test	 ecx, ecx
  00032	74 26		 je	 SHORT $LN17@allocate
  00034	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00037	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0003a	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00047	83 c4 04	 add	 esp, 4
  0004a	85 c0		 test	 eax, eax
  0004c	75 bc		 jne	 SHORT $LN12@allocate
  0004e	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:
  00050	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:
  00055	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:
  0005a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:
  0005f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00064	cc		 int	 3
?allocate@?$allocator@_W@std@@QAEPA_WI@Z ENDP		; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000e	77 30		 ja	 SHORT $LN13@deallocate
  00010	03 c0		 add	 eax, eax
  00012	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00017	72 1a		 jb	 SHORT $LN5@deallocate
  00019	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001c	75 27		 jne	 SHORT $LN15@deallocate
  0001e	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00021	3b c1		 cmp	 eax, ecx
  00023	73 25		 jae	 SHORT $LN16@deallocate
  00025	2b c8		 sub	 ecx, eax
  00027	83 f9 04	 cmp	 ecx, 4
  0002a	72 23		 jb	 SHORT $LN17@deallocate
  0002c	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0002f	77 23		 ja	 SHORT $LN18@deallocate
  00031	8b c8		 mov	 ecx, eax
$LN5@deallocate:
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4

; 721  : 		}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00040	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:
  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:
  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  00059	cc		 int	 3
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@_W@std@@QAE@ABV01@@Z PROC		; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@_W@std@@QAE@ABV01@@Z ENDP		; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_W@std@@QAE@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gios_base@std@@UAEPAXI@Z PROC			; std::ios_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Gios_base@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	56		 push	 esi
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7ios_base@std@@6B@
  00033	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00038	83 c4 04	 add	 esp, 4
  0003b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003f	74 0b		 je	 SHORT $LN7@scalar
  00041	6a 38		 push	 56			; 00000038H
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00049	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0004c	8b c6		 mov	 eax, esi
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00051	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00058	59		 pop	 ecx
  00059	5e		 pop	 esi
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gios_base@std@@UAEPAXI@Z$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_Gios_base@std@@UAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Gios_base@std@@UAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Gios_base@std@@UAEPAXI@Z ENDP			; std::ios_base::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?_Init@ios_base@std@@IAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?_Init@ios_base@std@@IAEXXZ PROC			; std::ios_base::_Init, COMDAT
; _this$ = ecx

; 538  : 		{	// initialize a new ios_base

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Init@ios_base@std@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 539  : 		_Ploc = 0;
; 540  : 		_Stdstr = 0;
; 541  : 		_Except = goodbit;
; 542  : 		_Fmtfl = (fmtflags)(skipws | dec);
; 543  : 		_Prec = 6;
; 544  : 		_Wide = 0;
; 545  : 		_Arr = 0;
; 546  : 		_Calls = 0;
; 547  : 		clear(goodbit);

  00026	6a 00		 push	 0
  00028	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
  0002f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00036	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0003d	c7 46 14 01 02
	00 00		 mov	 DWORD PTR [esi+20], 513	; 00000201H
  00044	c7 46 18 06 00
	00 00		 mov	 DWORD PTR [esi+24], 6
  0004b	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00052	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  00059	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  00060	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00067	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
  0006e	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH@Z ; std::ios_base::clear

; 548  : 		_Ploc = new locale;

  00073	6a 08		 push	 8
  00075	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007a	8b f8		 mov	 edi, eax
  0007c	83 c4 04	 add	 esp, 4
  0007f	85 ff		 test	 edi, edi
  00081	74 28		 je	 SHORT $LN3@Init
  00083	6a 01		 push	 1
  00085	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0008c	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  00091	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00094	83 c4 04	 add	 esp, 4
  00097	89 7e 30	 mov	 DWORD PTR [esi+48], edi

; 549  : 		}

  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a4	59		 pop	 ecx
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
$LN3@Init:

; 548  : 		_Ploc = new locale;

  000ab	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0

; 549  : 		}

  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Init@ios_base@std@@IAEXXZ$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$?_Init@ios_base@std@@IAEXXZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Init@ios_base@std@@IAEXXZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Init@ios_base@std@@IAEXXZ ENDP			; std::ios_base::_Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ??0ios_base@std@@IAE@XZ
_TEXT	SEGMENT
??0ios_base@std@@IAE@XZ PROC				; std::ios_base::ios_base, COMDAT
; _this$ = ecx

; 534  : 		{	// default constructor

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@

; 535  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0ios_base@std@@IAE@XZ ENDP				; std::ios_base::ios_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ??1ios_base@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ios_base@std@@UAE@XZ PROC				; std::ios_base::~ios_base, COMDAT
; _this$ = ecx

; 523  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1ios_base@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 524  : 		_Ios_base_dtor(this);

  00022	51		 push	 ecx
  00023	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ios_base@std@@6B@
  00029	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0002e	83 c4 04	 add	 esp, 4

; 525  : 		}

  00031	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00034	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003b	59		 pop	 ecx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ios_base@std@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ios_base@std@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ios_base@std@@UAE@XZ ENDP				; std::ios_base::~ios_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 434  : 		{	// get locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 435  : 		return (*_Ploc);

  00024	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00027	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0002e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00031	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	ff 52 04	 call	 DWORD PTR [edx+4]
  00043	8b c6		 mov	 eax, esi

; 436  : 		}

  00045	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00048	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004f	59		 pop	 ecx
  00050	5e		 pop	 esi
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getloc@ios_base@std@@QBE?AVlocale@2@XZ$1:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$?getloc@ios_base@std@@QBE?AVlocale@2@XZ:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?width@ios_base@std@@QAE_J_J@Z
_TEXT	SEGMENT
__Newwidth$ = 8						; size = 8
?width@ios_base@std@@QAE_J_J@Z PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 427  : 		{	// set width to argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  : 		streamsize _Oldwidth = _Wide;

  00003	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00006	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00009	56		 push	 esi

; 429  : 		_Wide = _Newwidth;

  0000a	8b 75 08	 mov	 esi, DWORD PTR __Newwidth$[ebp]
  0000d	89 71 20	 mov	 DWORD PTR [ecx+32], esi
  00010	8b 75 0c	 mov	 esi, DWORD PTR __Newwidth$[ebp+4]
  00013	89 71 24	 mov	 DWORD PTR [ecx+36], esi
  00016	5e		 pop	 esi

; 430  : 		return (_Oldwidth);
; 431  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?width@ios_base@std@@QAE_J_J@Z ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?width@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
?width@ios_base@std@@QBE_JXZ PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 423  : 		return (_Wide);

  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]

; 424  : 		}

  00006	c3		 ret	 0
?width@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?precision@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
?precision@ios_base@std@@QBE_JXZ PROC			; std::ios_base::precision, COMDAT
; _this$ = ecx

; 411  : 		return (_Prec);

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 412  : 		}

  00006	c3		 ret	 0
?precision@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::precision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 378  : 		return (_Fmtfl);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 379  : 		}

  00003	c3		 ret	 0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 338  : 		{	// test if no state bits are set

  00000	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00004	0f 94 c0	 sete	 al

; 339  : 		return (rdstate() == goodbit);
; 340  : 		}

  00007	c3		 ret	 0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 315  : 		return (_Mystate);

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 316  : 		}

  00003	c3		 ret	 0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -20						; size = 20
__State$ = 8						; size = 4
?clear@ios_base@std@@QAEXH@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 302  : 		{	// set state to argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 303  : 		clear(_State, false);

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	83 e0 17	 and	 eax, 23			; 00000017H
  0000c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0000f	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00012	23 c8		 and	 ecx, eax
  00014	74 22		 je	 SHORT $LN11@clear
  00016	f6 c1 04	 test	 cl, 4
  00019	75 23		 jne	 SHORT $LN52@clear
  0001b	f6 c1 02	 test	 cl, 2
  0001e	74 0c		 je	 SHORT $LN10@clear
  00020	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  0002a	eb 1c		 jmp	 SHORT $LN51@clear
$LN10@clear:
  0002c	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  00036	eb 10		 jmp	 SHORT $LN51@clear
$LN11@clear:

; 304  : 		}

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
$LN52@clear:

; 303  : 		clear(_State, false);

  0003e	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN51@clear:
  00048	50		 push	 eax
  00049	6a 01		 push	 1
  0004b	8d 4d ec	 lea	 ecx, DWORD PTR $T1[ebp]
  0004e	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00053	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00058	8d 45 ec	 lea	 eax, DWORD PTR $T1[ebp]
  0005b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN54@clear:
$LN50@clear:
  00068	cc		 int	 3
?clear@ios_base@std@@QAEXH@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T1 = -20						; size = 20
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 287  : 		{	// set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 288  : 		_Mystate = (iostate)(_State & _Statmask);

  00003	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	83 e0 17	 and	 eax, 23			; 00000017H
  0000c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 289  : 		if ((_Mystate & _Except) == 0)

  0000f	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00012	23 c8		 and	 ecx, eax
  00014	74 28		 je	 SHORT $LN9@clear

; 290  : 			;
; 291  : 		else if (_Reraise)

  00016	80 7d 0c 00	 cmp	 BYTE PTR __Reraise$[ebp], 0
  0001a	75 28		 jne	 SHORT $LN49@clear

; 293  : 		else if (_Mystate & _Except & badbit)

  0001c	f6 c1 04	 test	 cl, 4
  0001f	75 2c		 jne	 SHORT $LN51@clear

; 295  : 		else if (_Mystate & _Except & failbit)

  00021	f6 c1 02	 test	 cl, 2
  00024	74 0c		 je	 SHORT $LN8@clear

; 296  : 			_THROW_NCEE(failure, "ios_base::failbit set");

  00026	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
  00030	eb 25		 jmp	 SHORT $LN48@clear
$LN8@clear:

; 297  : 		else
; 298  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

  00032	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
  0003c	eb 19		 jmp	 SHORT $LN48@clear
$LN9@clear:

; 299  : 		}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
$LN49@clear:

; 292  : 			_RERAISE;

  00044	6a 00		 push	 0
  00046	6a 00		 push	 0
  00048	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN52@clear:
$LN51@clear:

; 294  : 			_THROW_NCEE(failure, "ios_base::badbit set");

  0004d	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN48@clear:
  00057	50		 push	 eax
  00058	6a 01		 push	 1
  0005a	8d 4d ec	 lea	 ecx, DWORD PTR $T1[ebp]
  0005d	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  00062	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00067	8d 45 ec	 lea	 eax, DWORD PTR $T1[ebp]
  0006a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_7failure@ios_base@std@@6B@
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN53@clear:
$LN47@clear:
  00077	cc		 int	 3
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 14		 push	 20			; 00000014H
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00010	50		 push	 eax
  00011	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
  00017	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001b	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ___std_exception_copy
  00024	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
  0002a	83 c4 08	 add	 esp, 8
  0002d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00030	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00039	8b c7		 mov	 eax, edi
  0003b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7failure@ios_base@std@@6B@
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx
  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 238  : 			{	// construct with message

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 237  : 			: system_error(_Errcode, _Message)

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00007	56		 push	 esi
  00008	ff 75 08	 push	 DWORD PTR __Message$[ebp]

; 238  : 			{	// construct with message

  0000b	8b f1		 mov	 esi, ecx
  0000d	ff 70 04	 push	 DWORD PTR [eax+4]
  00010	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00013	ff 30		 push	 DWORD PTR [eax]
  00015	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  0001a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@

; 239  : 			}

  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ
_TEXT	SEGMENT
??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ PROC ; std::_Immortalize<std::_Iostream_error_category>, COMDAT

; 698  : 	/* MAGIC */ static _Immortalizer<_Ty> _Static;

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __tls_index
  0000c	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
  00014	3b 81 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[ecx]
  0001a	7f 06		 jg	 SHORT $LN22@Immortaliz
$LN20@Immortaliz:

; 699  : 	return (*reinterpret_cast<_Ty *>(&_Static._Storage));

  0001c	b8 00 00 00 00	 mov	 eax, OFFSET ?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Static

; 700  : 	}

  00021	c3		 ret	 0
$LN22@Immortaliz:

; 698  : 	/* MAGIC */ static _Immortalizer<_Ty> _Static;

  00022	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
  00027	e8 00 00 00 00	 call	 __Init_thread_header
  0002c	83 c4 04	 add	 esp, 4
  0002f	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA, -1 ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
  00036	75 e4		 jne	 SHORT $LN20@Immortaliz
  00038	68 00 00 00 00	 push	 OFFSET ??__F_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ@YAXXZ ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::`dynamic atexit destructor for '_Static''
  0003d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A, OFFSET ??_7_Iostream_error_category@std@@6B@
  00047	c7 05 04 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?_Static@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4U?$_Immortalizer@V_Iostream_error_category@std@@@1@A+4, 5
  00051	e8 00 00 00 00	 call	 _atexit
  00056	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4HA ; TSS0<`template-parameter-2',unsigned int,std::V_Iostream_error_category::mortalize>
  0005b	e8 00 00 00 00	 call	 __Init_thread_footer
  00060	83 c4 08	 add	 esp, 8
  00063	eb b7		 jmp	 SHORT $LN20@Immortaliz
??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ENDP ; std::_Immortalize<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
  00010	74 0b		 je	 SHORT $LN13@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN13@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@
  00006	c3		 ret	 0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 626  : 		{	// convert to name of error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 627  : 		if (_Errcode == (int)io_errc::stream)

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000e	56		 push	 esi

; 628  : 			return ("iostream stream error");

  0000f	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00012	83 f8 01	 cmp	 eax, 1
  00015	75 28		 jne	 SHORT $LN2@message
  00017	6a 15		 push	 21			; 00000015H
  00019	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00020	8b ce		 mov	 ecx, esi
  00022	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
  0002e	c6 06 00	 mov	 BYTE PTR [esi], 0
  00031	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 629  : 		else
; 630  : 			return (_Generic_error_category::message(_Errcode));

  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi

; 631  : 		}

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN2@message:

; 629  : 		else
; 630  : 			return (_Generic_error_category::message(_Errcode));

  0003f	50		 push	 eax
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi

; 631  : 		}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 622  : 		return ("iostream");

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 623  : 		}

  00005	c3		 ret	 0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 616  : 		{	// default constructor

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Iostream_error_category@std@@6B@

; 617  : 		_Addr = _Iostream_addr;
; 618  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 05 00
	00 00		 mov	 DWORD PTR [ecx+4], 5
  0000f	c3		 ret	 0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
  00010	74 0b		 je	 SHORT $LN10@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@
  00006	c3		 ret	 0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 605  : 		{	// convert to name of error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 606  : 		return (_Syserror_map(_Errcode));

  00005	ff 75 0c	 push	 DWORD PTR __Errcode$[ebp]
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000f	e8 00 00 00 00	 call	 ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map
  00014	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00017	8b d0		 mov	 edx, eax
  00019	83 c4 04	 add	 esp, 4
  0001c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00023	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002a	c6 06 00	 mov	 BYTE PTR [esi], 0
  0002d	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00030	75 14		 jne	 SHORT $LN115@message
  00032	33 c9		 xor	 ecx, ecx
  00034	51		 push	 ecx
  00035	52		 push	 edx
  00036	8b ce		 mov	 ecx, esi
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi

; 607  : 		}

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 606  : 		return (_Syserror_map(_Errcode));

$LN115@message:
  00046	8b ca		 mov	 ecx, edx
  00048	57		 push	 edi
  00049	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
  0004c	0f 1f 40 00	 npad	 4
$LL117@message:
  00050	8a 01		 mov	 al, BYTE PTR [ecx]
  00052	41		 inc	 ecx
  00053	84 c0		 test	 al, al
  00055	75 f9		 jne	 SHORT $LL117@message
  00057	2b cf		 sub	 ecx, edi
  00059	5f		 pop	 edi
  0005a	51		 push	 ecx
  0005b	52		 push	 edx
  0005c	8b ce		 mov	 ecx, esi
  0005e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00063	8b c6		 mov	 eax, esi
  00065	5e		 pop	 esi

; 607  : 		}

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 601  : 		return ("generic");

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 602  : 		}

  00005	c3		 ret	 0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 595  : 		{	// default constructor

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Generic_error_category@std@@6B@

; 596  : 		_Addr = _Generic_addr;
; 597  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 03 00
	00 00		 mov	 DWORD PTR [ecx+4], 3
  0000f	c3		 ret	 0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN15@scalar
  0001e	6a 14		 push	 20			; 00000014H
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN15@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00010	50		 push	 eax
  00011	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
  00017	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001b	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ___std_exception_copy
  00024	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
  0002a	83 c4 08	 add	 esp, 8
  0002d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00030	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00039	8b c7		 mov	 eax, edi
  0003b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7system_error@std@@6B@
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx
  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@PBD@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0system_error@std@@QAE@Verror_code@1@PBD@Z PROC	; std::system_error::system_error, COMDAT
; _this$ = ecx

; 548  : 		{	// construct from error code and message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f1		 mov	 esi, ecx
  0002c	89 75 d4	 mov	 DWORD PTR _this$[ebp], esi
  0002f	8b 55 10	 mov	 edx, DWORD PTR __Message$[ebp]

; 547  : 		: _Mybase(_Errcode, _Message)

  00032	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
  00039	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0
  00040	c6 45 d8 00	 mov	 BYTE PTR $T2[ebp], 0
  00044	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00047	75 04		 jne	 SHORT $LN115@system_err
  00049	33 c9		 xor	 ecx, ecx
  0004b	eb 0e		 jmp	 SHORT $LN116@system_err
$LN115@system_err:
  0004d	8b ca		 mov	 ecx, edx
  0004f	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL218@system_err:
  00052	8a 01		 mov	 al, BYTE PTR [ecx]
  00054	41		 inc	 ecx
  00055	84 c0		 test	 al, al
  00057	75 f9		 jne	 SHORT $LL218@system_err
  00059	2b cf		 sub	 ecx, edi
$LN116@system_err:
  0005b	51		 push	 ecx
  0005c	52		 push	 edx
  0005d	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00060	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00065	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  00068	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006f	50		 push	 eax
  00070	ff 75 0c	 push	 DWORD PTR __Errcode$[ebp+4]
  00073	8b ce		 mov	 ecx, esi
  00075	ff 75 08	 push	 DWORD PTR __Errcode$[ebp]
  00078	e8 00 00 00 00	 call	 ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
  0007d	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp+20]
  00080	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00083	72 0d		 jb	 SHORT $LN219@system_err
  00085	41		 inc	 ecx
  00086	51		 push	 ecx
  00087	ff 75 d8	 push	 DWORD PTR $T2[ebp]
  0008a	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0008d	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN219@system_err:

; 549  : 		}

  00092	8b c6		 mov	 eax, esi

; 548  : 		{	// construct from error code and message string

  00094	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@

; 549  : 		}

  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a4	59		 pop	 ecx
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000aa	33 cd		 xor	 ecx, ebp
  000ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0system_error@std@@QAE@Verror_code@1@PBD@Z ENDP	; std::system_error::system_error
; Function compile flags: /Ogtp
;	COMDAT ??_G_System_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_System_error@std@@UAEPAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 14		 push	 20			; 00000014H
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_G_System_error@std@@UAEPAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0_System_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0_System_error@std@@QAE@ABV01@@Z PROC			; std::_System_error::_System_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00010	50		 push	 eax
  00011	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
  00017	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0001b	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ___std_exception_copy
  00024	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
  0002a	83 c4 08	 add	 esp, 8
  0002d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00030	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00039	8b c7		 mov	 eax, edi
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
??0_System_error@std@@QAE@ABV01@@Z ENDP			; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_System_error@std@@UAE@XZ
_TEXT	SEGMENT
??1_System_error@std@@UAE@XZ PROC			; std::_System_error::~_System_error, COMDAT
; _this$ = ecx
  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1_System_error@std@@UAE@XZ ENDP			; std::_System_error::~_System_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__InitData$1 = -36					; size = 8
_this$ = -32						; size = 4
$T2 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 523  : 		{	// construct from error code and message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR __Message$[ebp]
  00013	56		 push	 esi
  00014	83 ec 18	 sub	 esp, 24			; 00000018H
  00017	8b f1		 mov	 esi, ecx
  00019	8b cc		 mov	 ecx, esp
  0001b	89 75 e0	 mov	 DWORD PTR _this$[ebp], esi
  0001e	6a ff		 push	 -1
  00020	6a 00		 push	 0
  00022	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH
  00029	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00030	50		 push	 eax
  00031	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00034	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00039	ff 75 0c	 push	 DWORD PTR __Errcode$[ebp+4]
  0003c	8d 45 e4	 lea	 eax, DWORD PTR $T2[ebp]
  0003f	ff 75 08	 push	 DWORD PTR __Errcode$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
  00048	8b c8		 mov	 ecx, eax
  0004a	83 c4 24	 add	 esp, 36			; 00000024H
  0004d	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00051	72 02		 jb	 SHORT $LN147@System_err

; 522  : 		: runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode)

  00053	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN147@System_err:
  00055	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00058	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0005e	0f 57 c0	 xorps	 xmm0, xmm0
  00061	89 4d dc	 mov	 DWORD PTR __InitData$1[ebp], ecx
  00064	50		 push	 eax
  00065	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00069	8d 45 dc	 lea	 eax, DWORD PTR __InitData$1[ebp]
  0006c	50		 push	 eax
  0006d	c6 45 e0 01	 mov	 BYTE PTR __InitData$1[ebp+4], 1
  00071	e8 00 00 00 00	 call	 ___std_exception_copy
  00076	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp+20]
  00079	83 c4 08	 add	 esp, 8
  0007c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
  00082	83 f8 10	 cmp	 eax, 16			; 00000010H
  00085	72 0d		 jb	 SHORT $LN158@System_err
  00087	40		 inc	 eax
  00088	8d 4d e4	 lea	 ecx, DWORD PTR $T2[ebp]
  0008b	50		 push	 eax
  0008c	ff 75 e4	 push	 DWORD PTR $T2[ebp]
  0008f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN158@System_err:
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Errcode$[ebp]

; 524  : 		}

  00097	8b c6		 mov	 eax, esi
  00099	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR __Errcode$[ebp+4]
  0009f	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_System_error@std@@6B@
  000ab	33 cd		 xor	 ecx, ebp
  000ad	5e		 pop	 esi
  000ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 0c 00	 ret	 12			; 0000000cH
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
_TEXT	SEGMENT
$T2 = -44						; size = 4
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 8
__Message$ = 20						; size = 24
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z PROC ; std::_System_error::_Makestr, COMDAT

; 513  : 		{	// compose error message

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0002c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00033	83 7d 24 00	 cmp	 DWORD PTR __Message$[ebp+16], 0
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 514  : 		if (!_Message.empty())

  0003e	74 0f		 je	 SHORT $LN2@Makestr

; 515  : 			_Message.append(": ");

  00040	6a 02		 push	 2
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
  00047	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  0004a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2@Makestr:

; 516  : 		_Message.append(_Errcode.message());

  0004f	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  00052	50		 push	 eax
  00053	8d 4d 0c	 lea	 ecx, DWORD PTR __Errcode$[ebp]
  00056	e8 00 00 00 00	 call	 ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
  0005b	6a ff		 push	 -1
  0005d	6a 00		 push	 0
  0005f	50		 push	 eax
  00060	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  00063	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00067	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0006c	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp+20]
  0006f	83 f8 10	 cmp	 eax, 16			; 00000010H
  00072	72 0d		 jb	 SHORT $LN34@Makestr
  00074	40		 inc	 eax
  00075	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00078	50		 push	 eax
  00079	ff 75 d8	 push	 DWORD PTR $T3[ebp]
  0007c	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN34@Makestr:

; 517  : 		return (_Message);

  00081	8d 45 14	 lea	 eax, DWORD PTR __Message$[ebp]
  00084	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0008b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00092	8b ce		 mov	 ecx, esi
  00094	50		 push	 eax
  00095	c6 06 00	 mov	 BYTE PTR [esi], 0
  00098	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
  0009d	8b 4d 28	 mov	 ecx, DWORD PTR __Message$[ebp+20]
  000a0	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000a3	72 0d		 jb	 SHORT $LN355@Makestr
  000a5	41		 inc	 ecx
  000a6	51		 push	 ecx
  000a7	ff 75 14	 push	 DWORD PTR __Message$[ebp]
  000aa	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  000ad	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN355@Makestr:
  000b2	8b c6		 mov	 eax, esi

; 518  : 		}

  000b4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000be	59		 pop	 ecx
  000bf	5e		 pop	 esi
  000c0	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c3	33 cd		 xor	 ecx, ebp
  000c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ENDP ; std::_System_error::_Makestr
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??8std@@YA_NABVerror_condition@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??8std@@YA_NABVerror_condition@0@0@Z PROC		; std::operator==, COMDAT

; 392  : 	{	// test errors for equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 393  : 	return (_Left.category() == _Right.category()

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Right$[ebp]
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00010	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00013	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00016	75 0b		 jne	 SHORT $LN3@operator
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	3b 06		 cmp	 eax, DWORD PTR [esi]
  0001c	75 05		 jne	 SHORT $LN3@operator
  0001e	b0 01		 mov	 al, 1
  00020	5e		 pop	 esi

; 394  : 		&& _Left.value() == _Right.value());
; 395  : 	}

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
$LN3@operator:

; 393  : 	return (_Left.category() == _Right.category()

  00023	32 c0		 xor	 al, al
  00025	5e		 pop	 esi

; 394  : 		&& _Left.value() == _Right.value());
; 395  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??8std@@YA_NABVerror_condition@0@0@Z ENDP		; std::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 346  : 		return (*_Mycat);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 347  : 		}

  00003	c3		 ret	 0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 341  : 		return (_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 342  : 		}

  00002	c3		 ret	 0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 307  : 		{	// construct from error code and category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 306  : 		: _Myval(_Val), _Mycat(&_Cat)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Cat$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 308  : 		}

  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT
; _this$ = ecx

; 279  : 		{	// get name of error code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 280  : 		return (category().message(value()));

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	ff 31		 push	 DWORD PTR [ecx]
  00009	8b c8		 mov	 ecx, eax
  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00012	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00015	8b 10		 mov	 edx, DWORD PTR [eax]
  00017	ff 52 08	 call	 DWORD PTR [edx+8]
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 281  : 		}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 273  : 		return (*_Mycat);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 274  : 		}

  00003	c3		 ret	 0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 268  : 		return (_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 269  : 		}

  00002	c3		 ret	 0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0error_code@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_code@std@@QAE@HABVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT
; _this$ = ecx

; 234  : 		{	// construct from error code and category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 233  : 		: _Myval(_Val), _Mycat(&_Cat)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Cat$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 235  : 		}

  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0error_code@std@@QAE@HABVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
  00010	74 0b		 je	 SHORT $LN7@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 191  : 		{	// compare categories for equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0000c	0f 94 c0	 sete	 al

; 192  : 		return (_Addr == _Right._Addr);
; 193  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 462  : 	{	// test if conditions same for this category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 463  : 	return (*this == _Code.category() && _Code.value() == _Errval);

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __Code$[ebp]
  0000a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000d	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00010	75 0e		 jne	 SHORT $LN3@equivalent
  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	3b 45 0c	 cmp	 eax, DWORD PTR __Errval$[ebp]
  00017	75 07		 jne	 SHORT $LN3@equivalent
  00019	b0 01		 mov	 al, 1
  0001b	5e		 pop	 esi

; 464  : 	}

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
$LN3@equivalent:

; 463  : 	return (*this == _Code.category() && _Code.value() == _Errval);

  00020	32 c0		 xor	 al, al
  00022	5e		 pop	 esi

; 464  : 	}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 455  : 	{	// test if error code same condition

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 456  : 	return (default_error_condition(_Errval) == _Cond);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8d 55 f8	 lea	 edx, DWORD PTR $T1[ebp]
  00008	83 ec 08	 sub	 esp, 8
  0000b	56		 push	 esi
  0000c	ff 75 08	 push	 DWORD PTR __Errval$[ebp]
  0000f	52		 push	 edx
  00010	ff 50 0c	 call	 DWORD PTR [eax+12]
  00013	8b 75 0c	 mov	 esi, DWORD PTR __Cond$[ebp]
  00016	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001f	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00022	75 0f		 jne	 SHORT $LN5@equivalent
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	3b 06		 cmp	 eax, DWORD PTR [esi]
  00028	75 09		 jne	 SHORT $LN5@equivalent
  0002a	b0 01		 mov	 al, 1
  0002c	5e		 pop	 esi

; 457  : 	}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8

; 456  : 	return (default_error_condition(_Errval) == _Cond);

$LN5@equivalent:
  00033	32 c0		 xor	 al, al
  00035	5e		 pop	 esi

; 457  : 	}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 448  : 	{	// make error_condition for error code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 449  : 	return (error_condition(_Errval, *this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Errval$[ebp]
  00009	89 10		 mov	 DWORD PTR [eax], edx
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 450  : 	}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 174  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@

; 175  : 		}

  00006	c3		 ret	 0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 169  : 		{	// default constructor

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@

; 170  : 		_Addr = reinterpret_cast<uintptr_t>(this);
; 171  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  0000b	c3		 ret	 0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?iostream_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?iostream_category@std@@YAABVerror_category@1@XZ PROC	; std::iostream_category, COMDAT

; 709  : 	return (_Immortalize<_Iostream_error_category>());

  00000	e9 00 00 00 00	 jmp	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
?iostream_category@std@@YAABVerror_category@1@XZ ENDP	; std::iostream_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errno$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z PROC ; std::make_error_code, COMDAT

; 479  : 	{	// make an error_code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 480  : 	return (error_code((int)_Errno, iostream_category()));

  00003	e8 00 00 00 00	 call	 ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
  00008	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Errno$[ebp]
  0000e	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00011	8b c2		 mov	 eax, edx
  00013	89 0a		 mov	 DWORD PTR [edx], ecx

; 481  : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@_W@std@@MAEPAXI@Z PROC			; std::ctype<wchar_t>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@_W@std@@6B@
  00010	74 0b		 je	 SHORT $LN5@scalar
  00012	ff 76 0c	 push	 DWORD PTR [esi+12]
  00015	e8 00 00 00 00	 call	 _free
  0001a	83 c4 04	 add	 esp, 4
$LN5@scalar:
  0001d	ff 76 14	 push	 DWORD PTR [esi+20]
  00020	e8 00 00 00 00	 call	 _free
  00025	83 c4 04	 add	 esp, 4
  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002e	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00032	74 0b		 je	 SHORT $LN17@scalar
  00034	6a 44		 push	 68			; 00000044H
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003c	83 c4 08	 add	 esp, 8
$LN17@scalar:
  0003f	8b c6		 mov	 eax, esi
  00041	5e		 pop	 esi
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
??_G?$ctype@_W@std@@MAEPAXI@Z ENDP			; std::ctype<wchar_t>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z
_TEXT	SEGMENT
__Mbst$1 = -28						; size = 8
tv164 = -20						; size = 4
tv168 = -16						; size = 4
__Buf$2 = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dflt$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z PROC	; std::ctype<wchar_t>::do_narrow, COMDAT
; _this$ = ecx

; 2779 : 		{	// narrow elements in [_First, _Last) to chars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 14	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00014	33 d2		 xor	 edx, edx
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0001e	2b fe		 sub	 edi, esi
  00020	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv168[ebp], 0
  00027	47		 inc	 edi
  00028	d1 ef		 shr	 edi, 1
  0002a	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0002d	0f 47 fa	 cmova	 edi, edx

; 2780 : 		_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2781 : 		for (; _First != _Last; ++_First, ++_Dest)

  00030	85 ff		 test	 edi, edi
  00032	74 4e		 je	 SHORT $LN14@do_narrow
  00034	83 c1 18	 add	 ecx, 24			; 00000018H
  00037	89 4d ec	 mov	 DWORD PTR tv164[ebp], ecx
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL4@do_narrow:

; 2782 : 			*_Dest = _Donarrow(*_First, _Dflt);

  00040	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00043	0f 57 c0	 xorps	 xmm0, xmm0
  00046	51		 push	 ecx
  00047	8d 4d e4	 lea	 ecx, DWORD PTR __Mbst$1[ebp]
  0004a	66 0f d6 45 e4	 movq	 QWORD PTR __Mbst$1[ebp], xmm0
  0004f	51		 push	 ecx
  00050	50		 push	 eax
  00051	8d 45 f4	 lea	 eax, DWORD PTR __Buf$2[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 __Wcrtomb
  0005a	0f b6 4d 10	 movzx	 ecx, BYTE PTR __Dflt$[ebp]
  0005e	8d 5b 01	 lea	 ebx, DWORD PTR [ebx+1]
  00061	0f b6 55 f4	 movzx	 edx, BYTE PTR __Buf$2[ebp]
  00065	83 c4 10	 add	 esp, 16			; 00000010H
  00068	83 f8 01	 cmp	 eax, 1
  0006b	8b 45 f0	 mov	 eax, DWORD PTR tv168[ebp]
  0006e	0f 45 d1	 cmovne	 edx, ecx
  00071	8b 4d ec	 mov	 ecx, DWORD PTR tv164[ebp]
  00074	40		 inc	 eax
  00075	88 53 ff	 mov	 BYTE PTR [ebx-1], dl
  00078	83 c6 02	 add	 esi, 2
  0007b	89 45 f0	 mov	 DWORD PTR tv168[ebp], eax
  0007e	3b c7		 cmp	 eax, edi
  00080	75 be		 jne	 SHORT $LL4@do_narrow
$LN14@do_narrow:

; 2783 : 		return (_First);
; 2784 : 		}

  00082	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00085	8b c6		 mov	 eax, esi
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	33 cd		 xor	 ecx, ebp
  0008b	5b		 pop	 ebx
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z ENDP	; std::ctype<wchar_t>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_narrow@?$ctype@_W@std@@MBED_WD@Z
_TEXT	SEGMENT
__Mbst$1 = -20						; size = 8
__Buf$2 = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
__Ch$ = 8						; size = 2
__Dflt$ = 12						; size = 1
?do_narrow@?$ctype@_W@std@@MBED_WD@Z PROC		; std::ctype<wchar_t>::do_narrow, COMDAT
; _this$ = ecx

; 2773 : 		{	// narrow element to char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2774 : 		return (_Donarrow(_Ch, _Dflt));

  00010	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	50		 push	 eax
  00017	8d 45 ec	 lea	 eax, DWORD PTR __Mbst$1[ebp]
  0001a	66 0f d6 45 ec	 movq	 QWORD PTR __Mbst$1[ebp], xmm0
  0001f	50		 push	 eax
  00020	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00023	8d 45 f4	 lea	 eax, DWORD PTR __Buf$2[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __Wcrtomb
  0002c	0f b6 4d 0c	 movzx	 ecx, BYTE PTR __Dflt$[ebp]
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	0f b6 55 f4	 movzx	 edx, BYTE PTR __Buf$2[ebp]
  00037	83 f8 01	 cmp	 eax, 1
  0003a	0f 45 d1	 cmovne	 edx, ecx

; 2775 : 		}

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	33 cd		 xor	 ecx, ebp
  00042	8a c2		 mov	 al, dl
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
?do_narrow@?$ctype@_W@std@@MBED_WD@Z ENDP		; std::ctype<wchar_t>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Donarrow@?$ctype@_W@std@@IBED_WD@Z
_TEXT	SEGMENT
__Mbst$ = -20						; size = 8
__Buf$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
__Ch$ = 8						; size = 2
__Dflt$ = 12						; size = 1
?_Donarrow@?$ctype@_W@std@@IBED_WD@Z PROC		; std::ctype<wchar_t>::_Donarrow, COMDAT
; _this$ = ecx

; 2765 : 		{	// narrow element to char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2766 : 		char _Buf[MB_LEN_MAX];
; 2767 : 		_Mbstinit(_Mbst);
; 2768 : 		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1

  00010	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	50		 push	 eax
  00017	8d 45 ec	 lea	 eax, DWORD PTR __Mbst$[ebp]
  0001a	66 0f d6 45 ec	 movq	 QWORD PTR __Mbst$[ebp], xmm0
  0001f	50		 push	 eax
  00020	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00023	8d 45 f4	 lea	 eax, DWORD PTR __Buf$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __Wcrtomb
  0002c	0f b6 4d 0c	 movzx	 ecx, BYTE PTR __Dflt$[ebp]
  00030	83 c4 10	 add	 esp, 16			; 00000010H
  00033	0f b6 55 f4	 movzx	 edx, BYTE PTR __Buf$[ebp]
  00037	83 f8 01	 cmp	 eax, 1
  0003a	0f 45 d1	 cmovne	 edx, ecx

; 2769 : 			? _Dflt : _Buf[0]);
; 2770 : 		}

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	33 cd		 xor	 ecx, ebp
  00042	8a c2		 mov	 al, dl
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
?_Donarrow@?$ctype@_W@std@@IBED_WD@Z ENDP		; std::ctype<wchar_t>::_Donarrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z
_TEXT	SEGMENT
__Mbst$1 = -16						; size = 8
tv129 = -8						; size = 4
tv160 = -4						; size = 4
__Wc$2 = 8						; size = 2
__First$ = 8						; size = 4
__Byte$ = 12						; size = 1
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z PROC		; std::ctype<wchar_t>::do_widen, COMDAT
; _this$ = ecx

; 2757 : 		{	// widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000a	33 d2		 xor	 edx, edx
  0000c	57		 push	 edi
  0000d	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  00010	2b fe		 sub	 edi, esi
  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv160[ebp], 0
  00019	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  0001c	0f 47 fa	 cmova	 edi, edx

; 2758 : 		_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2759 : 		for (; _First != _Last; ++_First, ++_Dest)

  0001f	85 ff		 test	 edi, edi
  00021	74 56		 je	 SHORT $LN12@do_widen
  00023	83 c1 18	 add	 ecx, 24			; 00000018H
  00026	53		 push	 ebx
  00027	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  0002a	89 4d f8	 mov	 DWORD PTR tv129[ebp], ecx
  0002d	0f 1f 00	 npad	 3
$LL4@do_widen:

; 2760 : 			*_Dest = _Dowiden(*_First);

  00030	8a 06		 mov	 al, BYTE PTR [esi]
  00032	0f 57 c0	 xorps	 xmm0, xmm0
  00035	88 45 0c	 mov	 BYTE PTR __Byte$[ebp], al
  00038	8d 45 f0	 lea	 eax, DWORD PTR __Mbst$1[ebp]
  0003b	51		 push	 ecx
  0003c	50		 push	 eax
  0003d	6a 01		 push	 1
  0003f	8d 45 0c	 lea	 eax, DWORD PTR __Byte$[ebp]
  00042	66 0f d6 45 f0	 movq	 QWORD PTR __Mbst$1[ebp], xmm0
  00047	50		 push	 eax
  00048	8d 45 08	 lea	 eax, DWORD PTR __Wc$2[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 __Mbrtowc
  00051	0f b7 4d 08	 movzx	 ecx, WORD PTR __Wc$2[ebp]
  00055	8d 5b 02	 lea	 ebx, DWORD PTR [ebx+2]
  00058	83 c4 14	 add	 esp, 20			; 00000014H
  0005b	85 c0		 test	 eax, eax
  0005d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00062	0f 48 c8	 cmovs	 ecx, eax
  00065	8b 45 fc	 mov	 eax, DWORD PTR tv160[ebp]
  00068	40		 inc	 eax
  00069	66 89 4b fe	 mov	 WORD PTR [ebx-2], cx
  0006d	8b 4d f8	 mov	 ecx, DWORD PTR tv129[ebp]
  00070	46		 inc	 esi
  00071	89 45 fc	 mov	 DWORD PTR tv160[ebp], eax
  00074	3b c7		 cmp	 eax, edi
  00076	75 b8		 jne	 SHORT $LL4@do_widen
  00078	5b		 pop	 ebx
$LN12@do_widen:
  00079	5f		 pop	 edi

; 2761 : 		return (_First);

  0007a	8b c6		 mov	 eax, esi
  0007c	5e		 pop	 esi

; 2762 : 		}

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z ENDP		; std::ctype<wchar_t>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_widen@?$ctype@_W@std@@MBE_WD@Z
_TEXT	SEGMENT
__Mbst$1 = -12						; size = 8
__Wc$2 = -4						; size = 2
__Byte$ = 8						; size = 1
__Byte$ = 8						; size = 1
?do_widen@?$ctype@_W@std@@MBE_WD@Z PROC			; std::ctype<wchar_t>::do_widen, COMDAT
; _this$ = ecx

; 2751 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2752 : 		return (_Dowiden(_Byte));

  00006	8a 45 08	 mov	 al, BYTE PTR __Byte$[ebp]
  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	88 45 08	 mov	 BYTE PTR __Byte$[ebp], al
  0000f	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00012	50		 push	 eax
  00013	8d 45 f4	 lea	 eax, DWORD PTR __Mbst$1[ebp]
  00016	66 0f d6 45 f4	 movq	 QWORD PTR __Mbst$1[ebp], xmm0
  0001b	50		 push	 eax
  0001c	6a 01		 push	 1
  0001e	8d 45 08	 lea	 eax, DWORD PTR __Byte$[ebp]
  00021	50		 push	 eax
  00022	8d 45 fc	 lea	 eax, DWORD PTR __Wc$2[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 __Mbrtowc
  0002b	0f b7 4d fc	 movzx	 ecx, WORD PTR __Wc$2[ebp]
  0002f	83 c4 14	 add	 esp, 20			; 00000014H
  00032	85 c0		 test	 eax, eax
  00034	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00039	0f 48 ca	 cmovs	 ecx, edx
  0003c	66 8b c1	 mov	 ax, cx

; 2753 : 		}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?do_widen@?$ctype@_W@std@@MBE_WD@Z ENDP			; std::ctype<wchar_t>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Dowiden@?$ctype@_W@std@@IBE_WD@Z
_TEXT	SEGMENT
__Mbst$ = -12						; size = 8
__Wc$ = -4						; size = 2
__Byte$ = 8						; size = 1
?_Dowiden@?$ctype@_W@std@@IBE_WD@Z PROC			; std::ctype<wchar_t>::_Dowiden, COMDAT
; _this$ = ecx

; 2743 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2744 : 		_Mbstinit(_Mbst);
; 2745 : 		wchar_t _Wc;
; 2746 : 		return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0

  00006	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	50		 push	 eax
  0000d	8d 45 f4	 lea	 eax, DWORD PTR __Mbst$[ebp]
  00010	66 0f d6 45 f4	 movq	 QWORD PTR __Mbst$[ebp], xmm0
  00015	50		 push	 eax
  00016	6a 01		 push	 1
  00018	8d 45 08	 lea	 eax, DWORD PTR __Byte$[ebp]
  0001b	50		 push	 eax
  0001c	8d 45 fc	 lea	 eax, DWORD PTR __Wc$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 __Mbrtowc
  00025	0f b7 4d fc	 movzx	 ecx, WORD PTR __Wc$[ebp]
  00029	83 c4 14	 add	 esp, 20			; 00000014H
  0002c	85 c0		 test	 eax, eax
  0002e	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00033	0f 48 ca	 cmovs	 ecx, edx
  00036	66 8b c1	 mov	 ax, cx

; 2747 : 			? (wchar_t)WEOF : _Wc);
; 2748 : 		}

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Dowiden@?$ctype@_W@std@@IBE_WD@Z ENDP			; std::ctype<wchar_t>::_Dowiden
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv131 = 12						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z PROC	; std::ctype<wchar_t>::do_toupper, COMDAT
; _this$ = ecx

; 2735 : 		{	// convert [_First, _Last) in place to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	43		 inc	 ebx
  00010	d1 eb		 shr	 ebx, 1
  00012	57		 push	 edi
  00013	33 ff		 xor	 edi, edi
  00015	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00018	0f 47 da	 cmova	 ebx, edx

; 2736 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2737 : 		for (; _First != _Last; ++_First)

  0001b	85 db		 test	 ebx, ebx
  0001d	74 21		 je	 SHORT $LN10@do_toupper
  0001f	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00022	89 45 0c	 mov	 DWORD PTR tv131[ebp], eax
$LL4@do_toupper:

; 2738 : 			*_First = _Towupper(*_First, &_Ctype);

  00025	50		 push	 eax
  00026	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 __Towupper
  0002f	66 89 06	 mov	 WORD PTR [esi], ax
  00032	47		 inc	 edi
  00033	8b 45 0c	 mov	 eax, DWORD PTR tv131[ebp]
  00036	83 c4 08	 add	 esp, 8
  00039	83 c6 02	 add	 esi, 2
  0003c	3b fb		 cmp	 edi, ebx
  0003e	75 e5		 jne	 SHORT $LL4@do_toupper
$LN10@do_toupper:
  00040	5f		 pop	 edi

; 2739 : 		return ((const _Elem *)_First);

  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 2740 : 		}

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z ENDP	; std::ctype<wchar_t>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_toupper@?$ctype@_W@std@@MBE_W_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?do_toupper@?$ctype@_W@std@@MBE_W_W@Z PROC		; std::ctype<wchar_t>::do_toupper, COMDAT
; _this$ = ecx

; 2729 : 		{	// convert element to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2730 : 		return (_Towupper(_Ch, &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  0000a	e8 00 00 00 00	 call	 __Towupper
  0000f	83 c4 08	 add	 esp, 8

; 2731 : 		}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?do_toupper@?$ctype@_W@std@@MBE_W_W@Z ENDP		; std::ctype<wchar_t>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv131 = 12						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z PROC	; std::ctype<wchar_t>::do_tolower, COMDAT
; _this$ = ecx

; 2721 : 		{	// convert [_First, _Last) in place to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	43		 inc	 ebx
  00010	d1 eb		 shr	 ebx, 1
  00012	57		 push	 edi
  00013	33 ff		 xor	 edi, edi
  00015	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00018	0f 47 da	 cmova	 ebx, edx

; 2722 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2723 : 		for (; _First != _Last; ++_First)

  0001b	85 db		 test	 ebx, ebx
  0001d	74 21		 je	 SHORT $LN10@do_tolower
  0001f	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00022	89 45 0c	 mov	 DWORD PTR tv131[ebp], eax
$LL4@do_tolower:

; 2724 : 			*_First = _Towlower(*_First, &_Ctype);

  00025	50		 push	 eax
  00026	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 __Towlower
  0002f	66 89 06	 mov	 WORD PTR [esi], ax
  00032	47		 inc	 edi
  00033	8b 45 0c	 mov	 eax, DWORD PTR tv131[ebp]
  00036	83 c4 08	 add	 esp, 8
  00039	83 c6 02	 add	 esi, 2
  0003c	3b fb		 cmp	 edi, ebx
  0003e	75 e5		 jne	 SHORT $LL4@do_tolower
$LN10@do_tolower:
  00040	5f		 pop	 edi

; 2725 : 		return ((const _Elem *)_First);

  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 2726 : 		}

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z ENDP	; std::ctype<wchar_t>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_tolower@?$ctype@_W@std@@MBE_W_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 2
?do_tolower@?$ctype@_W@std@@MBE_W_W@Z PROC		; std::ctype<wchar_t>::do_tolower, COMDAT
; _this$ = ecx

; 2715 : 		{	// convert element to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2716 : 		return (_Towlower(_Ch, &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  0000a	e8 00 00 00 00	 call	 __Towlower
  0000f	83 c4 08	 add	 esp, 8

; 2717 : 		}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?do_tolower@?$ctype@_W@std@@MBE_W_W@Z ENDP		; std::ctype<wchar_t>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z PROC	; std::ctype<wchar_t>::do_scan_not, COMDAT
; _this$ = ecx

; 2707 : 		{	// find first in [_First, _Last) not fitting mask classification

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 2708 : 		_DEBUG_RANGE(_First, _Last);
; 2709 : 		for (; _First != _Last && is(_Maskval, *_First); ++_First)

  00005	8b 75 0c	 mov	 esi, DWORD PTR __First$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	3b f7		 cmp	 esi, edi
  00010	74 1b		 je	 SHORT $LN12@do_scan_no
$LL4@do_scan_no:
  00012	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00015	8b cb		 mov	 ecx, ebx
  00017	8b 13		 mov	 edx, DWORD PTR [ebx]
  00019	50		 push	 eax
  0001a	ff 75 08	 push	 DWORD PTR __Maskval$[ebp]
  0001d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00020	ff d0		 call	 eax
  00022	84 c0		 test	 al, al
  00024	74 07		 je	 SHORT $LN12@do_scan_no
  00026	83 c6 02	 add	 esi, 2
  00029	3b f7		 cmp	 esi, edi
  0002b	75 e5		 jne	 SHORT $LL4@do_scan_no
$LN12@do_scan_no:
  0002d	5f		 pop	 edi

; 2710 : 			;
; 2711 : 		return (_First);

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx

; 2712 : 		}

  00032	5d		 pop	 ebp
  00033	c2 0c 00	 ret	 12			; 0000000cH
?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z ENDP	; std::ctype<wchar_t>::do_scan_not
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z PROC	; std::ctype<wchar_t>::do_scan_is, COMDAT
; _this$ = ecx

; 2698 : 		{	// find first in [_First, _Last) that fits mask classification

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 2699 : 		_DEBUG_RANGE(_First, _Last);
; 2700 : 		for (; _First != _Last && !is(_Maskval, *_First); ++_First)

  00005	8b 75 0c	 mov	 esi, DWORD PTR __First$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	3b f7		 cmp	 esi, edi
  00010	74 1b		 je	 SHORT $LN12@do_scan_is
$LL4@do_scan_is:
  00012	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00015	8b cb		 mov	 ecx, ebx
  00017	8b 13		 mov	 edx, DWORD PTR [ebx]
  00019	50		 push	 eax
  0001a	ff 75 08	 push	 DWORD PTR __Maskval$[ebp]
  0001d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00020	ff d0		 call	 eax
  00022	84 c0		 test	 al, al
  00024	75 07		 jne	 SHORT $LN12@do_scan_is
  00026	83 c6 02	 add	 esi, 2
  00029	3b f7		 cmp	 esi, edi
  0002b	75 e5		 jne	 SHORT $LL4@do_scan_is
$LN12@do_scan_is:
  0002d	5f		 pop	 edi

; 2701 : 			;
; 2702 : 		return (_First);

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx

; 2703 : 		}

  00032	5d		 pop	 ebp
  00033	c2 0c 00	 ret	 12			; 0000000cH
?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z ENDP	; std::ctype<wchar_t>::do_scan_is
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z PROC		; std::ctype<wchar_t>::do_is, COMDAT
; _this$ = ecx

; 2691 : 		{	// get mask sequence for elements in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2692 : 		_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2693 : 		return (_CSTD _Getwctypes(_First, _Last, _Dest, &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 __Getwctypes
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 2694 : 		}

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z ENDP		; std::ctype<wchar_t>::do_is
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_is@?$ctype@_W@std@@MBE_NF_W@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 2
?do_is@?$ctype@_W@std@@MBE_NF_W@Z PROC			; std::ctype<wchar_t>::do_is, COMDAT
; _this$ = ecx

; 2685 : 		{	// test if element fits any mask classifications

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2686 : 		return ((_CSTD _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  0000a	e8 00 00 00 00	 call	 __Getwctype
  0000f	83 c4 08	 add	 esp, 8
  00012	66 85 45 08	 test	 WORD PTR __Maskval$[ebp], ax
  00016	0f 95 c0	 setne	 al

; 2687 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?do_is@?$ctype@_W@std@@MBE_NF_W@Z ENDP			; std::ctype<wchar_t>::do_is
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Init@?$ctype@_W@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T1 = -60						; size = 44
$T2 = -16						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$ctype@_W@std@@IAEXABV_Locinfo@2@@Z PROC	; std::ctype<wchar_t>::_Init, COMDAT
; _this$ = ecx

; 2679 : 		{	// initialize from _Lobj

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 2680 : 		_Ctype = _Lobj._Getctype();

  00006	8d 45 f0	 lea	 eax, DWORD PTR $T2[ebp]
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 __Getctype
  00012	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]

; 2681 : 		_Cvt = _Lobj._Getcvt();

  00015	8d 45 c4	 lea	 eax, DWORD PTR $T1[ebp]
  00018	50		 push	 eax
  00019	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0
  0001d	e8 00 00 00 00	 call	 __Getcvt
  00022	83 c4 08	 add	 esp, 8
  00025	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00028	0f 11 46 18	 movups	 XMMWORD PTR [esi+24], xmm0
  0002c	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  00030	0f 11 46 28	 movups	 XMMWORD PTR [esi+40], xmm0
  00034	f3 0f 7e 40 20	 movq	 xmm0, QWORD PTR [eax+32]
  00039	66 0f d6 46 38	 movq	 QWORD PTR [esi+56], xmm0
  0003e	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00041	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00044	5e		 pop	 esi

; 2682 : 		}

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
?_Init@?$ctype@_W@std@@IAEXABV_Locinfo@2@@Z ENDP	; std::ctype<wchar_t>::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??1?$ctype@_W@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@_W@std@@MAE@XZ PROC				; std::ctype<wchar_t>::~ctype<wchar_t>, COMDAT
; _this$ = ecx

; 2671 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2672 : 		if (_Ctype._Delfl)

  00003	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@_W@std@@6B@
  0000d	74 0b		 je	 SHORT $LN2@ctype

; 2673 : 			_CSTD free((void *)_Ctype._Table);

  0000f	ff 76 0c	 push	 DWORD PTR [esi+12]
  00012	e8 00 00 00 00	 call	 _free
  00017	83 c4 04	 add	 esp, 4
$LN2@ctype:

; 2674 : 
; 2675 : 		_CSTD free(_Ctype._LocaleName);

  0001a	ff 76 14	 push	 DWORD PTR [esi+20]
  0001d	e8 00 00 00 00	 call	 _free
  00022	83 c4 04	 add	 esp, 4

; 2676 : 		}

  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0002b	5e		 pop	 esi
  0002c	c3		 ret	 0
??1?$ctype@_W@std@@MAE@XZ ENDP				; std::ctype<wchar_t>::~ctype<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 52
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<wchar_t>::_Getcat, COMDAT

; 2662 : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2663 : 		if (_Ppf != 0 && *_Ppf == 0)

  00028	8b 75 08	 mov	 esi, DWORD PTR __Ppf$[ebp]
  0002b	33 db		 xor	 ebx, ebx
  0002d	89 5d f0	 mov	 DWORD PTR $T3[ebp], ebx
  00030	85 f6		 test	 esi, esi
  00032	74 60		 je	 SHORT $LN19@Getcat
  00034	39 1e		 cmp	 DWORD PTR [esi], ebx
  00036	75 5c		 jne	 SHORT $LN19@Getcat

; 2664 : 			*_Ppf = new ctype<_Elem>(

  00038	6a 44		 push	 68			; 00000044H
  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	8b f8		 mov	 edi, eax
  00041	83 c4 04	 add	 esp, 4
  00044	89 7d 08	 mov	 DWORD PTR $T4[ebp], edi
  00047	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0004a	85 ff		 test	 edi, edi
  0004c	74 35		 je	 SHORT $LN4@Getcat
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR __Ploc$[ebp]
  00051	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00054	85 c9		 test	 ecx, ecx
  00056	75 07		 jne	 SHORT $LN12@Getcat
  00058	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0005d	eb 0a		 jmp	 SHORT $LN17@Getcat
$LN12@Getcat:
  0005f	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00062	85 c0		 test	 eax, eax
  00064	75 03		 jne	 SHORT $LN17@Getcat
  00066	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
$LN17@Getcat:
  00069	50		 push	 eax
  0006a	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0006d	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00072	6a 00		 push	 0
  00074	50		 push	 eax
  00075	8b cf		 mov	 ecx, edi
  00077	bb 01 00 00 00	 mov	 ebx, 1
  0007c	e8 00 00 00 00	 call	 ??0?$ctype@_W@std@@QAE@ABV_Locinfo@1@I@Z ; std::ctype<wchar_t>::ctype<wchar_t>
  00081	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00083	33 c0		 xor	 eax, eax
$LN5@Getcat:
  00085	89 06		 mov	 DWORD PTR [esi], eax
  00087	f6 c3 01	 test	 bl, 1
  0008a	74 08		 je	 SHORT $LN19@Getcat
  0008c	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0008f	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN19@Getcat:

; 2665 : 				_Locinfo(_Ploc->c_str()));
; 2666 : 		return (_X_CTYPE);

  00094	b8 02 00 00 00	 mov	 eax, 2

; 2667 : 		}

  00099	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a3	59		 pop	 ecx
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	5b		 pop	 ebx
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 44		 push	 68			; 00000044H
  00002	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<wchar_t>::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0?$ctype@_W@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
$T1 = -64						; size = 44
$T2 = -20						; size = 16
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@_W@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<wchar_t>::ctype<wchar_t>, COMDAT
; _this$ = ecx

; 2656 : 		{	// construct from specified locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 2655 : 		: ctype_base(_Refs)

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  00009	56		 push	 esi

; 2656 : 		{	// construct from specified locale

  0000a	8b f1		 mov	 esi, ecx
  0000c	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000f	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2657 : 		_Init(_Lobj);

  00012	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00015	50		 push	 eax
  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@_W@std@@6B@
  0001c	e8 00 00 00 00	 call	 __Getctype
  00021	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00024	8d 45 c0	 lea	 eax, DWORD PTR $T1[ebp]
  00027	50		 push	 eax
  00028	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0
  0002c	e8 00 00 00 00	 call	 __Getcvt
  00031	83 c4 08	 add	 esp, 8
  00034	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00037	0f 11 46 18	 movups	 XMMWORD PTR [esi+24], xmm0
  0003b	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  0003f	0f 11 46 28	 movups	 XMMWORD PTR [esi+40], xmm0
  00043	f3 0f 7e 40 20	 movq	 xmm0, QWORD PTR [eax+32]
  00048	66 0f d6 46 38	 movq	 QWORD PTR [esi+56], xmm0
  0004d	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00050	89 46 40	 mov	 DWORD PTR [esi+64], eax

; 2658 : 		}

  00053	8b c6		 mov	 eax, esi
  00055	5e		 pop	 esi
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
??0?$ctype@_W@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<wchar_t>::ctype<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?widen@?$ctype@_W@std@@QBE_WD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?widen@?$ctype@_W@std@@QBE_WD@Z PROC			; std::ctype<wchar_t>::widen, COMDAT
; _this$ = ecx

; 2623 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2624 : 		return (do_widen(_Byte));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2625 : 		}

  00005	5d		 pop	 ebp

; 2624 : 		return (do_widen(_Byte));

  00006	ff 60 30	 jmp	 DWORD PTR [eax+48]
?widen@?$ctype@_W@std@@QBE_WD@Z ENDP			; std::ctype<wchar_t>::widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?is@?$ctype@_W@std@@QBE_NF_W@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 2
?is@?$ctype@_W@std@@QBE_NF_W@Z PROC			; std::ctype<wchar_t>::is, COMDAT
; _this$ = ecx

; 2580 : 		{	// test if element fits any mask classifications

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2581 : 		return (do_is(_Maskval, _Ch));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 2582 : 		}

  00008	5d		 pop	 ebp

; 2581 : 		return (do_is(_Maskval, _Ch));

  00009	ff e0		 jmp	 eax
?is@?$ctype@_W@std@@QBE_NF_W@Z ENDP			; std::ctype<wchar_t>::is
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 553  : 	{	// get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 554  :  #if _NO_LOCALES
; 555  : 	static _Wrap_facet<_Facet> _Wfac;
; 556  : 	return (*(_Facet *)&_Wfac);
; 557  : 
; 558  :  #else /* _NO_LOCALES */
; 559  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  00028	6a 00		 push	 0
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 560  : 		const locale::facet *_Psave =
; 561  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 562  : 
; 563  : 		size_t _Id = _Facet::id;

  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
  00038	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	89 5d f0	 mov	 DWORD PTR __Psave$5[ebp], ebx
  00048	85 ff		 test	 edi, edi
  0004a	75 2f		 jne	 SHORT $LN11@use_facet
  0004c	57		 push	 edi
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00055	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, edi ; std::ctype<char>::id
  0005b	75 10		 jne	 SHORT $LN12@use_facet
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00062	40		 inc	 eax
  00063	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, eax ; std::ctype<char>::id
$LN12@use_facet:
  0006d	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00070	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00075	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
$LN11@use_facet:

; 564  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0007e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00081	3b 79 0c	 cmp	 edi, DWORD PTR [ecx+12]
  00084	73 0c		 jae	 SHORT $LN20@use_facet
  00086	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00089	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  0008c	85 f6		 test	 esi, esi
  0008e	75 77		 jne	 SHORT $LN7@use_facet
  00090	eb 02		 jmp	 SHORT $LN28@use_facet
$LN20@use_facet:
  00092	33 f6		 xor	 esi, esi
$LN28@use_facet:
  00094	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00098	74 10		 je	 SHORT $LN17@use_facet
  0009a	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  0009f	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  000a2	73 0a		 jae	 SHORT $LN29@use_facet
  000a4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000a7	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
$LN17@use_facet:

; 565  : 
; 566  : 		if (_Pf != 0)

  000aa	85 f6		 test	 esi, esi
  000ac	75 59		 jne	 SHORT $LN7@use_facet
$LN29@use_facet:

; 567  : 			;	// got facet from locale
; 568  : 		else if (_Psave != 0)

  000ae	85 db		 test	 ebx, ebx
  000b0	74 04		 je	 SHORT $LN4@use_facet

; 569  : 			_Pf = _Psave;	// lazy facet already allocated

  000b2	8b f3		 mov	 esi, ebx
  000b4	eb 51		 jmp	 SHORT $LN7@use_facet
$LN4@use_facet:

; 570  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  000b6	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  000b9	8d 45 f0	 lea	 eax, DWORD PTR __Psave$5[ebp]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
  000c2	83 c4 08	 add	 esp, 8
  000c5	83 f8 ff	 cmp	 eax, -1
  000c8	75 24		 jne	 SHORT $LN6@use_facet

; 571  : 
; 572  :  #if _HAS_EXCEPTIONS
; 573  : 
; 574  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000ca	0f 57 c0	 xorps	 xmm0, xmm0
  000cd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7bad_cast@std@@6B@
  000d4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  000d9	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  000dc	66 0f d6 45 e0	 movq	 QWORD PTR $T2[ebp+4], xmm0
  000e1	50		 push	 eax
  000e2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  000e9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@use_facet:
$LN6@use_facet:

; 575  : 
; 576  :  #else /* _HAS_EXCEPTIONS */
; 577  : 			abort();	// lazy disallowed
; 578  :  #endif /* _HAS_EXCEPTIONS */
; 579  : 
; 580  : 		else
; 581  : 			{	// queue up lazy facet for destruction
; 582  : 			_Pf = _Psave;

  000ee	8b 75 f0	 mov	 esi, DWORD PTR __Psave$5[ebp]

; 583  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 584  : 
; 585  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 586  : 			_Pfmod->_Incref();

  000f1	8b ce		 mov	 ecx, esi
  000f3	89 35 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<char> >::_Psave
  000f9	8b 16		 mov	 edx, DWORD PTR [esi]
  000fb	ff 52 04	 call	 DWORD PTR [edx+4]

; 587  : 
; 588  :  #if defined(_M_CEE)
; 589  : 			_Facet_Register_m(_Pfmod);
; 590  : 
; 591  :  #else /* defined(_M_CEE) */
; 592  : 			_Facet_Register(_Pfmod);

  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  00104	83 c4 04	 add	 esp, 4
$LN7@use_facet:

; 593  :  #endif /* defined(_M_CEE) */
; 594  : 			}
; 595  : 
; 596  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  00107	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0010a	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0010f	8b c6		 mov	 eax, esi

; 597  : 	_END_LOCK()
; 598  :  #endif /* _NO_LOCALES */
; 599  : 	}	// end of use_facet body

  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN31@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
; Function compile flags: /Ogtp
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  0000f	85 c0		 test	 eax, eax
  00011	7e 0a		 jle	 SHORT $LN22@scalar
  00013	ff 76 0c	 push	 DWORD PTR [esi+12]
  00016	e8 00 00 00 00	 call	 _free
  0001b	eb 0a		 jmp	 SHORT $LN23@scalar
$LN22@scalar:
  0001d	79 0b		 jns	 SHORT $LN10@scalar
  0001f	ff 76 0c	 push	 DWORD PTR [esi+12]
  00022	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
$LN23@scalar:
  00027	83 c4 04	 add	 esp, 4
$LN10@scalar:
  0002a	ff 76 14	 push	 DWORD PTR [esi+20]
  0002d	e8 00 00 00 00	 call	 _free
  00032	83 c4 04	 add	 esp, 4
  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  0003b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003f	74 0b		 je	 SHORT $LN21@scalar
  00041	6a 18		 push	 24			; 00000018H
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00049	83 c4 08	 add	 esp, 8
$LN21@scalar:
  0004c	8b c6		 mov	 eax, esi
  0004e	5e		 pop	 esi
  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2558 : 		{	// narrow elements in [_First, _Last) to chars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2559 : 		_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2560 : 		_CSTD memcpy(_Dest, _First, _Last - _First);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	52		 push	 edx
  0000d	ff 75 14	 push	 DWORD PTR __Dest$[ebp]
  00010	e8 00 00 00 00	 call	 _memcpy

; 2561 : 		return (_Last);

  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2562 : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2552 : 		{	// narrow char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2553 : 		return (_Ch);

  00003	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]

; 2554 : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2545 : 		{	// widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2546 : 		_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2547 : 		_CSTD memcpy(_Dest, _First, _Last - _First);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	52		 push	 edx
  0000d	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00010	e8 00 00 00 00	 call	 _memcpy

; 2548 : 		return (_Last);

  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2549 : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2539 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2540 : 		return (_Byte);

  00003	8a 45 08	 mov	 al, BYTE PTR __Byte$[ebp]

; 2541 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv132 = 12						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2531 : 		{	// convert [_First, _Last) in place to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	57		 push	 edi
  00010	33 ff		 xor	 edi, edi
  00012	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00015	0f 47 da	 cmova	 ebx, edx

; 2532 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2533 : 		for (; _First != _Last; ++_First)

  00018	85 db		 test	 ebx, ebx
  0001a	74 1e		 je	 SHORT $LN10@do_toupper
  0001c	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  0001f	89 45 0c	 mov	 DWORD PTR tv132[ebp], eax
$LL4@do_toupper:

; 2534 : 			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);

  00022	50		 push	 eax
  00023	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __Toupper
  0002c	88 06		 mov	 BYTE PTR [esi], al
  0002e	47		 inc	 edi
  0002f	8b 45 0c	 mov	 eax, DWORD PTR tv132[ebp]
  00032	83 c4 08	 add	 esp, 8
  00035	46		 inc	 esi
  00036	3b fb		 cmp	 edi, ebx
  00038	75 e8		 jne	 SHORT $LL4@do_toupper
$LN10@do_toupper:
  0003a	5f		 pop	 edi

; 2535 : 		return ((const _Elem *)_First);

  0003b	8b c6		 mov	 eax, esi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx

; 2536 : 		}

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2525 : 		{	// convert element to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2526 : 		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __Toupper
  00011	83 c4 08	 add	 esp, 8

; 2527 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv132 = 12						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2517 : 		{	// convert [_First, _Last) in place to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	33 d2		 xor	 edx, edx
  00009	56		 push	 esi
  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000d	2b de		 sub	 ebx, esi
  0000f	57		 push	 edi
  00010	33 ff		 xor	 edi, edi
  00012	3b 75 0c	 cmp	 esi, DWORD PTR __Last$[ebp]
  00015	0f 47 da	 cmova	 ebx, edx

; 2518 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2519 : 		for (; _First != _Last; ++_First)

  00018	85 db		 test	 ebx, ebx
  0001a	74 1e		 je	 SHORT $LN10@do_tolower
  0001c	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  0001f	89 45 0c	 mov	 DWORD PTR tv132[ebp], eax
$LL4@do_tolower:

; 2520 : 			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);

  00022	50		 push	 eax
  00023	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __Tolower
  0002c	88 06		 mov	 BYTE PTR [esi], al
  0002e	47		 inc	 edi
  0002f	8b 45 0c	 mov	 eax, DWORD PTR tv132[ebp]
  00032	83 c4 08	 add	 esp, 8
  00035	46		 inc	 esi
  00036	3b fb		 cmp	 edi, ebx
  00038	75 e8		 jne	 SHORT $LL4@do_tolower
$LN10@do_tolower:
  0003a	5f		 pop	 edi

; 2521 : 		return ((const _Elem *)_First);

  0003b	8b c6		 mov	 eax, esi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx

; 2522 : 		}

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2511 : 		{	// convert element to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2512 : 		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));

  00003	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00006	50		 push	 eax
  00007	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __Tolower
  00011	83 c4 08	 add	 esp, 8

; 2513 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 2501 : 		{	// free any allocated storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2502 : 		if (0 < _Ctype._Delfl)

  00003	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00006	85 c0		 test	 eax, eax
  00008	7e 18		 jle	 SHORT $LN6@Tidy

; 2503 : 			_CSTD free((void *)_Ctype._Table);

  0000a	ff 76 0c	 push	 DWORD PTR [esi+12]
  0000d	e8 00 00 00 00	 call	 _free

; 2505 : 			delete[] _Ctype._Table;

  00012	83 c4 04	 add	 esp, 4

; 2506 : 
; 2507 : 		_CSTD free(_Ctype._LocaleName);

  00015	ff 76 14	 push	 DWORD PTR [esi+20]
  00018	e8 00 00 00 00	 call	 _free
  0001d	83 c4 04	 add	 esp, 4
  00020	5e		 pop	 esi

; 2508 : 		}

  00021	c3		 ret	 0
$LN6@Tidy:

; 2504 : 		else if (_Ctype._Delfl < 0)

  00022	79 0b		 jns	 SHORT $LN4@Tidy

; 2505 : 			delete[] _Ctype._Table;

  00024	ff 76 0c	 push	 DWORD PTR [esi+12]
  00027	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002c	83 c4 04	 add	 esp, 4
$LN4@Tidy:

; 2506 : 
; 2507 : 		_CSTD free(_Ctype._LocaleName);

  0002f	ff 76 14	 push	 DWORD PTR [esi+20]
  00032	e8 00 00 00 00	 call	 _free
  00037	83 c4 04	 add	 esp, 4
  0003a	5e		 pop	 esi

; 2508 : 		}

  0003b	c3		 ret	 0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 2496 : 		{	// initialize from _Lobj

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 2497 : 		_Ctype = _Lobj._Getctype();

  00006	8d 45 f0	 lea	 eax, DWORD PTR $T1[ebp]
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 __Getctype
  00012	83 c4 04	 add	 esp, 4
  00015	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00018	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0
  0001c	5e		 pop	 esi

; 2498 : 		}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2491 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2492 : 		_Tidy();

  00003	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  0000c	85 c0		 test	 eax, eax
  0000e	7e 0a		 jle	 SHORT $LN17@ctype
  00010	ff 76 0c	 push	 DWORD PTR [esi+12]
  00013	e8 00 00 00 00	 call	 _free
  00018	eb 0a		 jmp	 SHORT $LN18@ctype
$LN17@ctype:
  0001a	79 0b		 jns	 SHORT $LN6@ctype
  0001c	ff 76 0c	 push	 DWORD PTR [esi+12]
  0001f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
$LN18@ctype:
  00024	83 c4 04	 add	 esp, 4
$LN6@ctype:
  00027	ff 76 14	 push	 DWORD PTR [esi+20]
  0002a	e8 00 00 00 00	 call	 _free
  0002f	83 c4 04	 add	 esp, 4

; 2493 : 		}

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00038	5e		 pop	 esi
  00039	c3		 ret	 0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -84						; size = 52
$T3 = -32						; size = 16
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T5 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2468 : 		{	// return locale category mask and construct standard facet

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2469 : 		if (_Ppf != 0 && *_Ppf == 0)

  00028	8b 7d 08	 mov	 edi, DWORD PTR __Ppf$[ebp]
  0002b	33 db		 xor	 ebx, ebx
  0002d	89 5d f0	 mov	 DWORD PTR $T4[ebp], ebx
  00030	85 ff		 test	 edi, edi
  00032	74 76		 je	 SHORT $LN34@Getcat
  00034	39 1f		 cmp	 DWORD PTR [edi], ebx
  00036	75 72		 jne	 SHORT $LN34@Getcat

; 2470 : 			*_Ppf = new ctype<_Elem>(

  00038	6a 18		 push	 24			; 00000018H
  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	8b f0		 mov	 esi, eax
  00041	83 c4 04	 add	 esp, 4
  00044	89 75 08	 mov	 DWORD PTR $T5[ebp], esi
  00047	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0004a	85 f6		 test	 esi, esi
  0004c	74 4b		 je	 SHORT $LN4@Getcat
  0004e	8b 45 0c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00051	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00054	85 c9		 test	 ecx, ecx
  00056	75 07		 jne	 SHORT $LN12@Getcat
  00058	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0005d	eb 0a		 jmp	 SHORT $LN17@Getcat
$LN12@Getcat:
  0005f	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00062	85 c0		 test	 eax, eax
  00064	75 03		 jne	 SHORT $LN17@Getcat
  00066	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
$LN17@Getcat:
  00069	50		 push	 eax
  0006a	8d 4d ac	 lea	 ecx, DWORD PTR $T2[ebp]
  0006d	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00072	8d 45 e0	 lea	 eax, DWORD PTR $T3[ebp]
  00075	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0007c	50		 push	 eax
  0007d	bb 01 00 00 00	 mov	 ebx, 1
  00082	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  00088	e8 00 00 00 00	 call	 __Getctype
  0008d	83 c4 04	 add	 esp, 4
  00090	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00093	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0
  00097	eb 02		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00099	33 f6		 xor	 esi, esi
$LN5@Getcat:
  0009b	89 37		 mov	 DWORD PTR [edi], esi
  0009d	f6 c3 01	 test	 bl, 1
  000a0	74 08		 je	 SHORT $LN34@Getcat
  000a2	8d 4d ac	 lea	 ecx, DWORD PTR $T2[ebp]
  000a5	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN34@Getcat:

; 2471 : 				_Locinfo(_Ploc->c_str()));
; 2472 : 		return (_X_CTYPE);

  000aa	b8 02 00 00 00	 mov	 eax, 2

; 2473 : 		}

  000af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b9	59		 pop	 ecx
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 18		 push	 24			; 00000018H
  00002	8b 45 08	 mov	 eax, DWORD PTR $T5[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
$T1 = -20						; size = 16
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 2462 : 		{	// construct from current locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 2461 : 		: ctype_base(_Refs)

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  00009	56		 push	 esi

; 2462 : 		{	// construct from current locale

  0000a	8b f1		 mov	 esi, ecx
  0000c	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000f	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2463 : 		_Init(_Lobj);

  00012	8d 45 ec	 lea	 eax, DWORD PTR $T1[ebp]
  00015	50		 push	 eax
  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
  0001c	e8 00 00 00 00	 call	 __Getctype
  00021	83 c4 04	 add	 esp, 4
  00024	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]

; 2464 : 		}

  00027	8b c6		 mov	 eax, esi
  00029	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0
  0002d	5e		 pop	 esi
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<char>::ctype<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z PROC		; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2421 : 		{	// widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2422 : 		return (do_widen(_First, _Last, _Dest));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 2423 : 		}

  00005	5d		 pop	 ebp

; 2422 : 		return (do_widen(_First, _Last, _Dest));

  00006	ff 60 1c	 jmp	 DWORD PTR [eax+28]
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?widen@?$ctype@D@std@@QBEDD@Z PROC			; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2415 : 		{	// widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2416 : 		return (do_widen(_Byte));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 40 20	 mov	 eax, DWORD PTR [eax+32]

; 2417 : 		}

  00008	5d		 pop	 ebp

; 2416 : 		return (do_widen(_Byte));

  00009	ff e0		 jmp	 eax
?widen@?$ctype@D@std@@QBEDD@Z ENDP			; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN13@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN13@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 2108 : 		}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 2103 : 		{	// default constructor

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2102 : 		: locale::facet(_Refs)

  00004	8b 45 08	 mov	 eax, DWORD PTR __Refs$[ebp]
  00007	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2104 : 		}

  0000a	8b c1		 mov	 eax, ecx
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ctype_base@std@@6B@
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Glocale@std@@QAEPAXI@Z PROC				; std::locale::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Glocale@std@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002f	85 c9		 test	 ecx, ecx
  00031	74 11		 je	 SHORT $LN7@scalar
  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	ff 50 08	 call	 DWORD PTR [eax+8]
  00038	85 c0		 test	 eax, eax
  0003a	74 08		 je	 SHORT $LN7@scalar
  0003c	8b 10		 mov	 edx, DWORD PTR [eax]
  0003e	8b c8		 mov	 ecx, eax
  00040	6a 01		 push	 1
  00042	ff 12		 call	 DWORD PTR [edx]
$LN7@scalar:
  00044	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00048	74 0b		 je	 SHORT $LN10@scalar
  0004a	6a 08		 push	 8
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00052	83 c4 08	 add	 esp, 8
$LN10@scalar:
  00055	8b c6		 mov	 eax, esi
  00057	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00061	59		 pop	 ecx
  00062	5e		 pop	 esi
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Glocale@std@@QAEPAXI@Z$0:
  00000	e8 00 00 00 00	 call	 ___std_terminate
  00005	c3		 ret	 0
__ehhandler$??_Glocale@std@@QAEPAXI@Z:
  00006	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000d	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00010	33 c8		 xor	 ecx, eax
  00012	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00017	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Glocale@std@@QAEPAXI@Z
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Glocale@std@@QAEPAXI@Z ENDP				; std::locale::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 458  : 		{	// look up a facet in locale object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 459  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __Id$[ebp]
  0000a	3b 71 0c	 cmp	 esi, DWORD PTR [ecx+12]
  0000d	73 0c		 jae	 SHORT $LN6@Getfacet
  0000f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00012	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]

; 460  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 461  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00015	85 c0		 test	 eax, eax
  00017	75 21		 jne	 SHORT $LN3@Getfacet
  00019	eb 02		 jmp	 SHORT $LN10@Getfacet
$LN6@Getfacet:

; 459  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  0001b	33 c0		 xor	 eax, eax
$LN10@Getfacet:

; 460  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 461  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  0001d	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00021	74 17		 je	 SHORT $LN3@Getfacet

; 462  : 			return (_Facptr);	// found facet or not transparent
; 463  : 		else
; 464  : 			{	// look in current locale
; 465  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  00023	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 466  : 			return (_Id < _Ptr0->_Facetcount

  00028	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  0002b	73 0b		 jae	 SHORT $LN8@Getfacet
  0002d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00030	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00033	5e		 pop	 esi

; 467  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 468  : 				: 0);	// no entry in current locale
; 469  : 			}
; 470  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN8@Getfacet:

; 466  : 			return (_Id < _Ptr0->_Facetcount

  00038	33 c0		 xor	 eax, eax
$LN3@Getfacet:
  0003a	5e		 pop	 esi

; 467  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 468  : 				: 0);	// no entry in current locale
; 469  : 			}
; 470  : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?c_str@locale@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@locale@std@@QBEPBDXZ PROC			; std::locale::c_str, COMDAT
; _this$ = ecx

; 454  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 06		 jne	 SHORT $LN3@c_str
  00007	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@

; 455  : 		}

  0000c	c3		 ret	 0
$LN3@c_str:

; 454  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

  0000d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00010	85 c9		 test	 ecx, ecx
  00012	74 03		 je	 SHORT $LN7@c_str
  00014	8b c1		 mov	 eax, ecx

; 455  : 		}

  00016	c3		 ret	 0

; 454  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

$LN7@c_str:
  00017	83 c0 1c	 add	 eax, 28			; 0000001cH

; 455  : 		}

  0001a	c3		 ret	 0
?c_str@locale@std@@QBEPBDXZ ENDP			; std::locale::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 430  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1locale@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 431  : 		if (_Ptr != 0)

  00022	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00025	85 c9		 test	 ecx, ecx
  00027	74 11		 je	 SHORT $LN4@locale

; 432  : 			delete _Ptr->_Decref();

  00029	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002b	ff 50 08	 call	 DWORD PTR [eax+8]
  0002e	85 c0		 test	 eax, eax
  00030	74 08		 je	 SHORT $LN4@locale
  00032	8b 10		 mov	 edx, DWORD PTR [eax]
  00034	8b c8		 mov	 ecx, eax
  00036	6a 01		 push	 1
  00038	ff 12		 call	 DWORD PTR [edx]
$LN4@locale:

; 433  : 		}

  0003a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00044	59		 pop	 ecx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1locale@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1locale@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0locale@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??0locale@std@@QAE@XZ PROC				; std::locale::locale, COMDAT
; _this$ = ecx

; 331  : 		{	// construct from current locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0locale@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 330  : 		: _Ptr(_Init(true))

  00025	6a 01		 push	 1
  00027	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  0002c	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0002f	83 c4 04	 add	 esp, 4

; 332  : 		}

  00032	8b c6		 mov	 eax, esi
  00034	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00037	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003e	59		 pop	 ecx
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0locale@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0locale@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0locale@std@@QAE@XZ ENDP				; std::locale::locale
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 325  : 		{	// construct by copying

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0locale@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 324  : 		: _Ptr(_Right._Ptr)

  00025	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00028	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 326  : 		_Ptr->_Incref();

  0002e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00030	ff 50 04	 call	 DWORD PTR [eax+4]

; 327  : 		}

  00033	8b c6		 mov	 eax, esi
  00035	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00038	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003f	59		 pop	 ecx
  00040	5e		 pop	 esi
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0locale@std@@QAE@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0locale@std@@QAE@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
; Function compile flags: /Ogtp
;	COMDAT ??_Gfacet@locale@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@MAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN10@scalar
  00012	6a 08		 push	 8
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN10@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_Gfacet@locale@std@@MAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??1facet@locale@std@@MAE@XZ
_TEXT	SEGMENT
??1facet@locale@std@@MAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 172  : 			}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	c3		 ret	 0
??1facet@locale@std@@MAE@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 165  : 		explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 166  : 			{	// construct with initial reference count
; 167  : 			_Init_atomic_counter(_Myrefs, (_Atomic_integral_t)_Initrefs);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Initrefs$[ebp]
  00007	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 168  : 			}

  0000a	8b c1		 mov	 eax, ecx
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
_TEXT	SEGMENT
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ PROC	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 155  : 			if (_MT_DECR(_Myrefs) == 0)

  00000	83 c8 ff	 or	 eax, -1
  00003	f0 0f c1 41 04	 lock	  xadd	 DWORD PTR [ecx+4], eax
  00008	b8 00 00 00 00	 mov	 eax, 0
  0000d	0f 44 c1	 cmove	 eax, ecx

; 156  : 				return (this);
; 157  : 			else
; 158  : 				return (0);
; 159  : 			}

  00010	c3		 ret	 0
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ENDP	; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UAEXXZ
_TEXT	SEGMENT
?_Incref@facet@locale@std@@UAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 150  : 			_MT_INCR(_Myrefs);

  00000	f0 ff 41 04	 lock	  inc	 DWORD PTR [ecx+4]

; 151  : 			}

  00004	c3		 ret	 0
?_Incref@facet@locale@std@@UAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$1 = -4						; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 114  : 			{	// get stamp, with lazy allocation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 115  : 			if (_Id == 0)

  00007	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0000a	75 24		 jne	 SHORT $LN6@operator

; 116  : 				{	// still zero, allocate stamp
; 117  : 				_BEGIN_LOCK(_LOCK_LOCALE)

  0000c	6a 00		 push	 0
  0000e	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  00011	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 118  : 					if (_Id == 0)

  00016	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00019	75 0d		 jne	 SHORT $LN3@operator

; 119  : 						_Id = ++_Id_cnt;

  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00020	40		 inc	 eax
  00021	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  00026	89 06		 mov	 DWORD PTR [esi], eax
$LN3@operator:

; 120  : 				_END_LOCK()

  00028	8d 4d fc	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  0002b	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
$LN6@operator:

; 121  : 				}
; 122  : 			return (_Id);

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	5e		 pop	 esi

; 123  : 			}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 110  : 			{	// construct with specified stamp value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 109  : 			: _Id(_Val)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 111  : 			}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G_Facet_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Facet_base@std@@UAEPAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
  00010	74 0b		 je	 SHORT $LN7@scalar
  00012	6a 04		 push	 4
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G_Facet_base@std@@UAEPAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0_Facet_base@std@@QAE@XZ
_TEXT	SEGMENT
??0_Facet_base@std@@QAE@XZ PROC				; std::_Facet_base::_Facet_base, COMDAT
; _this$ = ecx
  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0_Facet_base@std@@QAE@XZ ENDP				; std::_Facet_base::_Facet_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xfacet
;	COMDAT ??1_Facet_base@std@@UAE@XZ
_TEXT	SEGMENT
??1_Facet_base@std@@UAE@XZ PROC				; std::_Facet_base::~_Facet_base, COMDAT
; _this$ = ecx

; 24   : 		{	// ensure that derived classes can be destroyed properly

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@

; 25   : 		}

  00006	c3		 ret	 0
??1_Facet_base@std@@UAE@XZ ENDP				; std::_Facet_base::~_Facet_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@_W@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@_W@std@@AAEXXZ PROC			; std::_Yarn<wchar_t>::_Tidy, COMDAT
; _this$ = ecx

; 3796 : 		{	// discard any string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3797 : 		if (_Myptr != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN4@Tidy

; 3798 : 
; 3799 :  #ifdef _DEBUG
; 3800 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3801 : 
; 3802 :  #else /* _DEBUG */
; 3803 : 			_CSTD free(_Myptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN4@Tidy:

; 3804 :  #endif /* _DEBUG */
; 3805 : 
; 3806 : 		_Myptr = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 3807 : 		}

  00019	c3		 ret	 0
?_Tidy@?$_Yarn@_W@std@@AAEXXZ ENDP			; std::_Yarn<wchar_t>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 3770 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3771 : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Yarn
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN6@Yarn:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 3772 : 		}

  00019	c3		 ret	 0
??1?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 3719 : 		: _Myptr(0), _Nul(0)

  00000	33 c0		 xor	 eax, eax
  00002	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00008	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 3721 : 		}

  0000c	8b c1		 mov	 eax, ecx
  0000e	c3		 ret	 0
??0?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@D@std@@AAEXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT
; _this$ = ecx

; 3796 : 		{	// discard any string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3797 : 		if (_Myptr != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN4@Tidy

; 3798 : 
; 3799 :  #ifdef _DEBUG
; 3800 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3801 : 
; 3802 :  #else /* _DEBUG */
; 3803 : 			_CSTD free(_Myptr);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN4@Tidy:

; 3804 :  #endif /* _DEBUG */
; 3805 : 
; 3806 : 		_Myptr = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 3807 : 		}

  00019	c3		 ret	 0
?_Tidy@?$_Yarn@D@std@@AAEXXZ ENDP			; std::_Yarn<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?c_str@?$_Yarn@D@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$_Yarn@D@std@@QBEPBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT
; _this$ = ecx

; 3781 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	75 03		 jne	 SHORT $LN4@c_str
  00006	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
$LN4@c_str:

; 3782 : 		}

  00009	c3		 ret	 0
?c_str@?$_Yarn@D@std@@QBEPBDXZ ENDP			; std::_Yarn<char>::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 3770 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3771 : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Yarn
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4
$LN6@Yarn:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	5e		 pop	 esi

; 3772 : 		}

  00019	c3		 ret	 0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT
; _this$ = ecx

; 3719 : 		: _Myptr(0), _Nul(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 3721 : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  0000c	c3		 ret	 0
??0?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Gettrue@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Gettrue, COMDAT
; _this$ = ecx

; 172  : 		return ("true");

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04LOAJBDKD@true?$AA@

; 173  : 		}

  00005	c3		 ret	 0
?_Gettrue@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Gettrue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Getfalse@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Getfalse, COMDAT
; _this$ = ecx

; 167  : 		return ("false");

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05LAPONLG@false?$AA@

; 168  : 		}

  00005	c3		 ret	 0
?_Getfalse@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Getfalse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ PROC		; std::_Locinfo::_Getlconv, COMDAT
; _this$ = ecx

; 127  : 		return (localeconv());

  00000	e9 00 00 00 00	 jmp	 _localeconv
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ENDP		; std::_Locinfo::_Getlconv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT
$T1 = -44						; size = 44
___$ReturnUdt$ = 8					; size = 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ PROC		; std::_Locinfo::_Getcvt, COMDAT
; _this$ = ecx

; 121  : 		{	// return codecvt stuff

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 122  : 		return (::_Getcvt());

  00006	8d 45 d4	 lea	 eax, DWORD PTR $T1[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __Getcvt
  0000f	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00012	83 c4 04	 add	 esp, 4
  00015	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00018	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0001b	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  0001e	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  00022	0f 11 42 10	 movups	 XMMWORD PTR [edx+16], xmm0
  00026	f3 0f 7e 40 20	 movq	 xmm0, QWORD PTR [eax+32]
  0002b	8b c2		 mov	 eax, edx
  0002d	66 0f d6 42 20	 movq	 QWORD PTR [edx+32], xmm0
  00032	89 4a 28	 mov	 DWORD PTR [edx+40], ecx

; 123  : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ENDP		; std::_Locinfo::_Getcvt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 116  : 		{	// return ctype stuff

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 117  : 		return (::_Getctype());

  00006	8d 45 f0	 lea	 eax, DWORD PTR $T1[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __Getctype
  0000f	83 c4 04	 add	 esp, 4
  00012	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00015	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00018	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0

; 118  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 94   : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Locinfo@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 95   : 		_Locinfo_dtor(this);

  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor

; 96   : 		}

  0002b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c0		 test	 eax, eax
  00033	74 09		 je	 SHORT $LN7@Locinfo
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _free
  0003b	83 c4 04	 add	 esp, 4
$LN7@Locinfo:
  0003e	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
  00045	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00048	85 c0		 test	 eax, eax
  0004a	74 09		 je	 SHORT $LN13@Locinfo
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _free
  00052	83 c4 04	 add	 esp, 4
$LN13@Locinfo:
  00055	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  0005c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0005f	85 c0		 test	 eax, eax
  00061	74 09		 je	 SHORT $LN19@Locinfo
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _free
  00069	83 c4 04	 add	 esp, 4
$LN19@Locinfo:
  0006c	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00073	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00076	85 c0		 test	 eax, eax
  00078	74 09		 je	 SHORT $LN25@Locinfo
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _free
  00080	83 c4 04	 add	 esp, 4
$LN25@Locinfo:
  00083	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  0008a	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0008d	85 c0		 test	 eax, eax
  0008f	74 09		 je	 SHORT $LN31@Locinfo
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 _free
  00097	83 c4 04	 add	 esp, 4
$LN31@Locinfo:
  0009a	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  000a1	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000a4	85 c0		 test	 eax, eax
  000a6	74 09		 je	 SHORT $LN37@Locinfo
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _free
  000ae	83 c4 04	 add	 esp, 4
$LN37@Locinfo:
  000b1	8b ce		 mov	 ecx, esi
  000b3	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  000ba	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  000bf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c9	59		 pop	 ecx
  000ca	5e		 pop	 esi
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Locinfo@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__InitData$3 = -24					; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 76   : 		{	// construct from NTBS

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_Locinfo@std@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 73   : 		: _Lock(_LOCK_LOCALE)

  0002b	6a 00		 push	 0
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 76   : 		{	// construct from NTBS

  00039	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00040	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0
  00044	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  0004b	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  0004f	33 c0		 xor	 eax, eax
  00051	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00058	66 89 46 18	 mov	 WORD PTR [esi+24], ax
  0005c	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  0005f	66 89 46 20	 mov	 WORD PTR [esi+32], ax
  00063	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00066	88 46 28	 mov	 BYTE PTR [esi+40], al
  00069	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0006c	88 46 30	 mov	 BYTE PTR [esi+48], al

; 77   : 		if (_Pch == 0)

  0006f	8b 45 08	 mov	 eax, DWORD PTR __Pch$[ebp]
  00072	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00076	85 c0		 test	 eax, eax
  00078	75 3f		 jne	 SHORT $LN2@Locinfo

; 78   : 			_THROW_NCEE(runtime_error, "bad locale name");

  0007a	8d 45 e0	 lea	 eax, DWORD PTR $T2[ebp+4]
  0007d	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7exception@std@@6B@
  00084	50		 push	 eax
  00085	8d 45 e8	 lea	 eax, DWORD PTR __InitData$3[ebp]
  00088	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __InitData$3[ebp], OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
  0008f	0f 57 c0	 xorps	 xmm0, xmm0
  00092	c6 45 ec 01	 mov	 BYTE PTR __InitData$3[ebp+4], 1
  00096	50		 push	 eax
  00097	66 0f d6 45 e0	 movq	 QWORD PTR $T2[ebp+4], xmm0
  0009c	e8 00 00 00 00	 call	 ___std_exception_copy
  000a1	83 c4 08	 add	 esp, 8
  000a4	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ??_7runtime_error@std@@6B@
  000ab	8d 45 dc	 lea	 eax, DWORD PTR $T2[ebp]
  000ae	68 00 00 00 00	 push	 OFFSET __TI2?AVruntime_error@std@@
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN29@Locinfo:
$LN2@Locinfo:

; 79   : 		_Locinfo_ctor(this, _Pch);

  000b9	50		 push	 eax
  000ba	56		 push	 esi
  000bb	e8 00 00 00 00	 call	 ?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
  000c0	83 c4 08	 add	 esp, 8

; 80   : 		}

  000c3	8b c6		 mov	 eax, esi
  000c5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cf	59		 pop	 ecx
  000d0	5e		 pop	 esi
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c2 04 00	 ret	 4
$LN28@Locinfo:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 14	 add	 ecx, 20			; 00000014H
  00024	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002f	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5:
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 24	 add	 ecx, 36			; 00000024H
  0003a	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6:
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00045	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
  0004a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00051	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00054	33 c8		 xor	 ecx, eax
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
  00060	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
; Function compile flags: /Ogtp
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_cast@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx
  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 125  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 126  :     }

  00003	8b c1		 mov	 eax, ecx
  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0
  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@
  00017	c3		 ret	 0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
__InitData$1 = -8					; size = 8
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@PBD@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 168  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 167  : 		: _Mybase(_Message)

  00006	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	56		 push	 esi

; 168  : 		{	// construct from message string

  0000d	8b f1		 mov	 esi, ecx
  0000f	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  00012	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  00015	89 45 f8	 mov	 DWORD PTR __InitData$1[ebp], eax
  00018	8d 45 f8	 lea	 eax, DWORD PTR __InitData$1[ebp]
  0001b	52		 push	 edx
  0001c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00022	50		 push	 eax
  00023	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00027	c6 45 fc 01	 mov	 BYTE PTR __InitData$1[ebp+4], 1
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	83 c4 08	 add	 esp, 8
  00033	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 169  : 		}

  00039	8b c6		 mov	 eax, esi
  0003b	5e		 pop	 esi
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@PBD@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__InitData$1 = -8					; size = 8
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 162  : 		: _Mybase(_Message.c_str())

  00006	8b 55 08	 mov	 edx, DWORD PTR __Message$[ebp]
  00009	56		 push	 esi

; 163  : 		{	// construct from message string

  0000a	8b f1		 mov	 esi, ecx
  0000c	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000f	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00013	72 02		 jb	 SHORT $LN17@runtime_er

; 162  : 		: _Mybase(_Message.c_str())

  00015	8b 12		 mov	 edx, DWORD PTR [edx]
$LN17@runtime_er:
  00017	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00020	0f 57 c0	 xorps	 xmm0, xmm0
  00023	89 55 f8	 mov	 DWORD PTR __InitData$1[ebp], edx
  00026	50		 push	 eax
  00027	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0002b	8d 45 f8	 lea	 eax, DWORD PTR __InitData$1[ebp]
  0002e	50		 push	 eax
  0002f	c6 45 fc 01	 mov	 BYTE PTR __InitData$1[ebp+4], 1
  00033	e8 00 00 00 00	 call	 ___std_exception_copy
  00038	83 c4 08	 add	 esp, 8

; 163  : 		{	// construct from message string

  0003b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 164  : 		}

  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00009	72 04		 jb	 SHORT $LN17@Check_offs

; 2273 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
$LN17@Check_offs:

; 2272 : 			_Xran();

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN19@Check_offs:
$LN16@Check_offs:
  00019	cc		 int	 3
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2266 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2249 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 26		 je	 SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 20		 jb	 SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN57@Tidy

; 2256 : 				_Traits::copy(this->_Bx()._Buf,

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@Tidy:

; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00028	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002b	8b ce		 mov	 ecx, esi
  0002d	40		 inc	 eax
  0002e	50		 push	 eax
  0002f	53		 push	 ebx
  00030	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  00035	5b		 pop	 ebx
$LN4@Tidy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00036	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2261 : 		_Eos(_Newsize);

  0003d	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00041	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00044	72 0c		 jb	 SHORT $LN92@Tidy
  00046	8b 06		 mov	 eax, DWORD PTR [esi]
  00048	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi

; 2262 : 		}

  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8

; 2261 : 		_Eos(_Newsize);

$LN92@Tidy:
  00052	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 2262 : 		}

  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	74 2d		 je	 SHORT $LN4@Inside
  0000b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00011	72 04		 jb	 SHORT $LN16@Inside
  00013	8b 31		 mov	 esi, DWORD PTR [ecx]
  00015	eb 02		 jmp	 SHORT $LN17@Inside
$LN16@Inside:
  00017	8b f1		 mov	 esi, ecx
$LN17@Inside:
  00019	3b d6		 cmp	 edx, esi
  0001b	72 1b		 jb	 SHORT $LN4@Inside
  0001d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00020	72 04		 jb	 SHORT $LN30@Inside
  00022	8b 31		 mov	 esi, DWORD PTR [ecx]
  00024	eb 02		 jmp	 SHORT $LN31@Inside
$LN30@Inside:
  00026	8b f1		 mov	 esi, ecx
$LN31@Inside:
  00028	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002b	03 c6		 add	 eax, esi
  0002d	3b c2		 cmp	 eax, edx
  0002f	76 07		 jbe	 SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

  00031	b0 01		 mov	 al, 1
  00033	5e		 pop	 esi

; 2244 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 2244 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2225 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0000a	77 59		 ja	 SHORT $LN89@Grow

; 2227 : 		if (this->_Myres() < _Newsize)

  0000c	39 71 14	 cmp	 DWORD PTR [ecx+20], esi
  0000f	73 13		 jae	 SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00011	ff 71 10	 push	 DWORD PTR [ecx+16]
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0001a	85 f6		 test	 esi, esi
  0001c	5e		 pop	 esi
  0001d	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00024	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  00028	74 1f		 je	 SHORT $LN5@Grow
  0002a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0002d	73 1a		 jae	 SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  0002f	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00032	3b f0		 cmp	 esi, eax
  00034	0f 42 c6	 cmovb	 eax, esi
  00037	50		 push	 eax
  00038	6a 01		 push	 1
  0003a	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  0003f	85 f6		 test	 esi, esi
  00041	5e		 pop	 esi
  00042	0f 95 c0	 setne	 al

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

  00049	85 f6		 test	 esi, esi
  0004b	75 10		 jne	 SHORT $LN88@Grow

; 2233 : 			_Eos(0);	// new size is zero, just null terminate

  0004d	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00051	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  00054	72 02		 jb	 SHORT $LN80@Grow
  00056	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN80@Grow:
  00058	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0005b	85 f6		 test	 esi, esi
$LN88@Grow:
  0005d	0f 95 c0	 setne	 al
  00060	5e		 pop	 esi

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do
; 2235 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN89@Grow:

; 2226 : 			_Xlen();	// result too long

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0006a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN91@Grow:
$LN87@Grow:
  0006f	cc		 int	 3
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0000a	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0000d	72 0a		 jb	 SHORT $LN11@Eos
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0

; 2220 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

$LN11@Eos:
  00019	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0

; 2220 : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f8		 mov	 edi, eax
  00035	83 cf 0f	 or	 edi, 15			; 0000000fH

; 2184 : 		if (max_size() < _Newres)

  00038	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0003b	76 04		 jbe	 SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

  0003d	8b f8		 mov	 edi, eax
  0003f	eb 27		 jmp	 SHORT $LN108@Copy
$LN2@Copy:

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  00041	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00044	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00049	f7 e7		 mul	 edi
  0004b	8b cb		 mov	 ecx, ebx
  0004d	d1 e9		 shr	 ecx, 1
  0004f	d1 ea		 shr	 edx, 1
  00051	3b ca		 cmp	 ecx, edx
  00053	76 13		 jbe	 SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 2189 : 			_Newres = this->_Myres()

  0005a	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]
  0005d	2b c1		 sub	 eax, ecx
  0005f	3b d8		 cmp	 ebx, eax
  00061	76 05		 jbe	 SHORT $LN108@Copy

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()

  00063	bf fe ff ff ff	 mov	 edi, -2			; fffffffeH
$LN108@Copy:

; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  00068	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0006b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00072	85 c0		 test	 eax, eax
  00074	75 04		 jne	 SHORT $LN136@Copy
  00076	33 db		 xor	 ebx, ebx
  00078	eb 6d		 jmp	 SHORT $LN19@Copy
$LN136@Copy:
  0007a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0007f	72 29		 jb	 SHORT $LN138@Copy
  00081	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00084	3b c8		 cmp	 ecx, eax
  00086	77 05		 ja	 SHORT $LN140@Copy
  00088	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN435@Copy:
$LN140@Copy:
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00093	83 c4 04	 add	 esp, 4
  00096	85 c0		 test	 eax, eax
  00098	75 05		 jne	 SHORT $LN141@Copy
  0009a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN436@Copy:
$LN141@Copy:
  0009f	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  000a2	83 e3 e0	 and	 ebx, -32		; ffffffe0H
  000a5	89 43 fc	 mov	 DWORD PTR [ebx-4], eax
  000a8	eb 3d		 jmp	 SHORT $LN19@Copy
$LN138@Copy:
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b0	8b d8		 mov	 ebx, eax
  000b2	83 c4 04	 add	 esp, 4
  000b5	85 db		 test	 ebx, ebx
  000b7	75 2e		 jne	 SHORT $LN19@Copy
  000b9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN437@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000be	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  000c1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax
  000c7	40		 inc	 eax
  000c8	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  000cb	50		 push	 eax
  000cc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000d0	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  000d5	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

  000d8	b8 00 00 00 00	 mov	 eax, $LN432@Copy
  000dd	c3		 ret	 0
$LN432@Copy:
  000de	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000e1	8b 7d 08	 mov	 edi, DWORD PTR __Newres$[ebp]
  000e4	8b 5d e8	 mov	 ebx, DWORD PTR __Ptr$[ebp]
$LN19@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

  000e7	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  000ea	85 c0		 test	 eax, eax
  000ec	74 1b		 je	 SHORT $LN270@Copy

; 2208 : 			_Traits::copy(_Unfancy(_Ptr), this->_Myptr(),

  000ee	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000f2	72 04		 jb	 SHORT $LN261@Copy
  000f4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000f6	eb 02		 jmp	 SHORT $LN262@Copy
$LN261@Copy:
  000f8	8b ce		 mov	 ecx, esi
$LN262@Copy:
  000fa	85 c0		 test	 eax, eax
  000fc	74 0b		 je	 SHORT $LN270@Copy
  000fe	50		 push	 eax
  000ff	51		 push	 ecx
  00100	53		 push	 ebx
  00101	e8 00 00 00 00	 call	 _memcpy
  00106	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN270@Copy:

; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);

  00109	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0010c	83 f8 10	 cmp	 eax, 16			; 00000010H
  0010f	72 0b		 jb	 SHORT $LN274@Copy
  00111	40		 inc	 eax
  00112	8b ce		 mov	 ecx, esi
  00114	50		 push	 eax
  00115	ff 36		 push	 DWORD PTR [esi]
  00117	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN274@Copy:
  0011c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00123	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00127	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0012e	72 04		 jb	 SHORT $LN362@Copy
  00130	8b 06		 mov	 eax, DWORD PTR [esi]
  00132	eb 02		 jmp	 SHORT $LN363@Copy
$LN362@Copy:
  00134	8b c6		 mov	 eax, esi
$LN363@Copy:
  00136	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2211 : 		this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Ptr);
; 2212 : 		this->_Myres() = _Newres;
; 2213 : 		_Eos(_Oldlen);

  00139	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  0013c	89 1e		 mov	 DWORD PTR [esi], ebx
  0013e	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00141	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00145	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00148	72 02		 jb	 SHORT $LN426@Copy
  0014a	8b f3		 mov	 esi, ebx
$LN426@Copy:
  0014c	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0

; 2214 : 		}

  00150	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00153	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015a	59		 pop	 ecx
  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

  00164	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00167	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0016a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0016d	72 0b		 jb	 SHORT $LN156@Copy
  0016f	40		 inc	 eax
  00170	8b ce		 mov	 ecx, esi
  00172	50		 push	 eax
  00173	ff 36		 push	 DWORD PTR [esi]
  00175	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN156@Copy:
  0017a	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00181	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00185	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0018c	72 02		 jb	 SHORT $LN245@Copy
  0018e	8b 36		 mov	 esi, DWORD PTR [esi]
$LN245@Copy:

; 2203 : 			_RERAISE;

  00190	6a 00		 push	 0
  00192	6a 00		 push	 0
  00194	c6 06 00	 mov	 BYTE PTR [esi], 0
  00197	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN438@Copy:
$LN434@Copy:
  0019c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2175 : 		if (_Count == 1)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b d1		 mov	 edx, ecx
  00008	83 f8 01	 cmp	 eax, 1
  0000b	75 15		 jne	 SHORT $LN2@Chassign

; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);

  0000d	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00011	72 02		 jb	 SHORT $LN16@Chassign
  00013	8b 12		 mov	 edx, DWORD PTR [edx]
$LN16@Chassign:
  00015	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00018	8a 4d 10	 mov	 cl, BYTE PTR __Ch$[ebp]
  0001b	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 2179 : 		}

  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Chassign:

; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

  00022	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00026	72 02		 jb	 SHORT $LN33@Chassign
  00028	8b 12		 mov	 edx, DWORD PTR [edx]
$LN33@Chassign:
  0002a	50		 push	 eax
  0002b	0f be 45 10	 movsx	 eax, BYTE PTR __Ch$[ebp]
  0002f	50		 push	 eax
  00030	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00033	03 c2		 add	 eax, edx
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _memset
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2179 : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$ = ecx

; 2168 : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2169 : 		allocator_type _Ret(this->_Getal());
; 2170 : 		return (_Ret);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2171 : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

  00009	39 45 0c	 cmp	 DWORD PTR __Size$[ebp], eax
  0000c	0f 46 45 0c	 cmovbe	 eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT
; _this$ = ecx

; 2088 : 		{	// return [_Off, _Off + _Count) as new string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 2089 : 		return (_Myt(*this, _Off, _Count, get_allocator()));

  00005	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00008	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00015	51		 push	 ecx
  00016	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001d	8b ce		 mov	 ecx, esi
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	c6 06 00	 mov	 BYTE PTR [esi], 0
  00029	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi

; 2090 : 		}

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind, COMDAT
; _this$ = ecx

; 1934 : 		{	// look for [_Ptr, <null>) beginning before _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1935 : 		_DEBUG_POINTER(_Ptr);
; 1936 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 11		 jne	 SHORT $LN5@rfind
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
  00018	5e		 pop	 esi

; 1937 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8

; 1935 : 		_DEBUG_POINTER(_Ptr);
; 1936 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));

$LN5@rfind:
  0001d	8b d6		 mov	 edx, esi
  0001f	57		 push	 edi
  00020	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@rfind:
  00023	8a 02		 mov	 al, BYTE PTR [edx]
  00025	42		 inc	 edx
  00026	84 c0		 test	 al, al
  00028	75 f9		 jne	 SHORT $LL7@rfind
  0002a	2b d7		 sub	 edx, edi
  0002c	5f		 pop	 edi
  0002d	52		 push	 edx
  0002e	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
  00037	5e		 pop	 esi

; 1937 : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
tv298 = 15						; size = 1
__Count$ = 16						; size = 4
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind, COMDAT
; _this$ = ecx

; 1912 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1913 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1914 : 		if (_Count == 0)

  00004	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	75 10		 jne	 SHORT $LN5@rfind

; 1915 : 			return (_Off < this->_Mysize() ? _Off

  0000e	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00011	39 45 0c	 cmp	 DWORD PTR __Off$[ebp], eax
  00014	5f		 pop	 edi
  00015	0f 42 45 0c	 cmovb	 eax, DWORD PTR __Off$[ebp]
  00019	5b		 pop	 ebx

; 1931 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 0c 00	 ret	 12			; 0000000cH
$LN5@rfind:

; 1916 : 				: this->_Mysize());	// null always matches
; 1917 : 		if (_Count <= this->_Mysize())

  0001e	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00021	56		 push	 esi
  00022	3b d9		 cmp	 ebx, ecx
  00024	77 5a		 ja	 SHORT $LN93@rfind

; 1918 : 			{	// room for match, look for it
; 1919 : 			const _Elem *_Uptr = this->_Myptr() +

  00026	2b cb		 sub	 ecx, ebx
  00028	39 4d 0c	 cmp	 DWORD PTR __Off$[ebp], ecx
  0002b	0f 42 4d 0c	 cmovb	 ecx, DWORD PTR __Off$[ebp]
  0002f	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00033	72 04		 jb	 SHORT $LN70@rfind
  00035	8b 07		 mov	 eax, DWORD PTR [edi]
  00037	eb 02		 jmp	 SHORT $LN71@rfind
$LN70@rfind:
  00039	8b c7		 mov	 eax, edi
$LN71@rfind:
  0003b	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 1923 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1924 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)

  0003e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00041	8a 08		 mov	 cl, BYTE PTR [eax]
  00043	88 4d 0f	 mov	 BYTE PTR tv298[ebp], cl
$LL4@rfind:
  00046	38 0e		 cmp	 BYTE PTR [esi], cl
  00048	75 0f		 jne	 SHORT $LN7@rfind
  0004a	53		 push	 ebx
  0004b	50		 push	 eax
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	85 c0		 test	 eax, eax
  00057	74 14		 je	 SHORT $LN92@rfind
$LN7@rfind:

; 1926 : 				else if (_Uptr == this->_Myptr())

  00059	8b cf		 mov	 ecx, edi
  0005b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
  00060	3b f0		 cmp	 esi, eax
  00062	74 1c		 je	 SHORT $LN93@rfind

; 1920 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1921 : 					: this->_Mysize() - _Count);
; 1922 : 			for (; ; --_Uptr)

  00064	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00067	4e		 dec	 esi
  00068	8a 4d 0f	 mov	 cl, BYTE PTR tv298[ebp]
  0006b	eb d9		 jmp	 SHORT $LL4@rfind
$LN92@rfind:

; 1925 : 					return (_Uptr - this->_Myptr());	// found a match

  0006d	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00071	72 02		 jb	 SHORT $LN87@rfind
  00073	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN87@rfind:
  00075	2b f7		 sub	 esi, edi
  00077	8b c6		 mov	 eax, esi
  00079	5e		 pop	 esi
  0007a	5f		 pop	 edi
  0007b	5b		 pop	 ebx

; 1931 : 		}

  0007c	5d		 pop	 ebp
  0007d	c2 0c 00	 ret	 12			; 0000000cH
$LN93@rfind:
  00080	5e		 pop	 esi
  00081	5f		 pop	 edi

; 1927 : 					break;	// at beginning, no more chance for match
; 1928 : 			}
; 1929 : 
; 1930 : 		return (npos);	// no match

  00082	83 c8 ff	 or	 eax, -1
  00085	5b		 pop	 ebx

; 1931 : 		}

  00086	5d		 pop	 ebp
  00087	c2 0c 00	 ret	 12			; 0000000cH
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1875 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1876 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1877 : 		if (_Count == 0 && _Off <= this->_Mysize())

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00007	53		 push	 ebx
  00008	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000b	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000e	85 db		 test	 ebx, ebx
  00010	75 0e		 jne	 SHORT $LN5@find
  00012	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00015	77 09		 ja	 SHORT $LN5@find

; 1878 : 			return (_Off);	// null string always matches (if inside string)

  00017	8b c2		 mov	 eax, edx
  00019	5b		 pop	 ebx

; 1892 : 		}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
$LN5@find:
  00020	56		 push	 esi

; 1879 : 
; 1880 : 		size_type _Nm;
; 1881 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))

  00021	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  00024	57		 push	 edi
  00025	3b d6		 cmp	 edx, esi
  00027	73 6a		 jae	 SHORT $LN3@find
  00029	2b f2		 sub	 esi, edx
  0002b	3b de		 cmp	 ebx, esi
  0002d	77 64		 ja	 SHORT $LN3@find

; 1882 : 			{	// room for match, look for it
; 1883 : 			const _Elem *_Uptr, *_Vptr;
; 1884 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	2b c3		 sub	 eax, ebx
  00036	03 f0		 add	 esi, eax
  00038	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0003c	72 02		 jb	 SHORT $LN46@find
  0003e	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN46@find:
  00040	8d 1c 11	 lea	 ebx, DWORD PTR [ecx+edx]
$LL4@find:

; 1885 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;

  00043	85 f6		 test	 esi, esi
  00045	74 4c		 je	 SHORT $LN3@find
  00047	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004a	56		 push	 esi
  0004b	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0004e	50		 push	 eax
  0004f	53		 push	 ebx
  00050	e8 00 00 00 00	 call	 _memchr
  00055	8b f8		 mov	 edi, eax
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	85 ff		 test	 edi, edi
  0005c	74 35		 je	 SHORT $LN3@find

; 1887 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)

  0005e	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00061	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00064	57		 push	 edi
  00065	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	85 c0		 test	 eax, eax
  0006f	74 0a		 je	 SHORT $LN69@find

; 1886 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)

  00071	2b df		 sub	 ebx, edi
  00073	4b		 dec	 ebx
  00074	03 f3		 add	 esi, ebx
  00076	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]
  00079	eb c8		 jmp	 SHORT $LL4@find
$LN69@find:

; 1888 : 					return (_Uptr - this->_Myptr());	// found a match

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  0007e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00082	72 02		 jb	 SHORT $LN64@find
  00084	8b 00		 mov	 eax, DWORD PTR [eax]
$LN64@find:
  00086	2b f8		 sub	 edi, eax
  00088	8b c7		 mov	 eax, edi
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx

; 1892 : 		}

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 0c 00	 ret	 12			; 0000000cH
$LN3@find:
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi

; 1889 : 			}
; 1890 : 
; 1891 : 		return (npos);	// no match

  00095	83 c8 ff	 or	 eax, -1
  00098	5b		 pop	 ebx

; 1892 : 		}

  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Off$ = 12						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1869 : 		{	// look for _Right beginning at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1870 : 		return (find(_Right._Myptr(), _Off, _Right.size()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0000a	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0000d	72 02		 jb	 SHORT $LN26@find
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN26@find:
  00011	52		 push	 edx
  00012	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find

; 1871 : 		}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIABV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 1803 : 		{	// test if sequence is empty

  00000	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00004	0f 94 c0	 sete	 al

; 1804 : 		return (this->_Mysize() == 0);
; 1805 : 		}

  00007	c3		 ret	 0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx

; 1793 : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Newcap$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f8		 cmp	 edi, eax
  0000f	77 20		 ja	 SHORT $LN47@reserve
  00011	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  00014	74 1b		 je	 SHORT $LN47@reserve

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

  00016	6a 01		 push	 1
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  0001e	84 c0		 test	 al, al
  00020	74 0f		 je	 SHORT $LN47@reserve

; 1798 : 				_Eos(_Size);

  00022	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00026	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00029	72 02		 jb	 SHORT $LN42@reserve
  0002b	8b 36		 mov	 esi, DWORD PTR [esi]
$LN42@reserve:
  0002d	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
$LN47@reserve:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi

; 1799 : 			}
; 1800 : 		}

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity, COMDAT
; _this$ = ecx

; 1789 : 		return (this->_Myres());

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1790 : 		}

  00003	c3		 ret	 0
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Ch$ = 12						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1780 : 		{	// determine new length, padding with _Ch elements as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1781 : 		if (_Newsize <= this->_Mysize())

  00003	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00009	3b c2		 cmp	 eax, edx
  0000b	77 13		 ja	 SHORT $LN2@resize

; 1782 : 			_Eos(_Newsize);

  0000d	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00010	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00014	72 02		 jb	 SHORT $LN25@resize
  00016	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN25@resize:
  00018	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1785 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
$LN2@resize:

; 1783 : 		else
; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

  00020	2b c2		 sub	 eax, edx
  00022	89 45 08	 mov	 DWORD PTR __Newsize$[ebp], eax

; 1785 : 		}

  00025	5d		 pop	 ebp

; 1783 : 		else
; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

  00026	e9 00 00 00 00	 jmp	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1775 : 		{	// determine new length, padding with null elements as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1776 : 		resize(_Newsize, _Elem());

  00003	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00009	3b c2		 cmp	 eax, edx
  0000b	77 13		 ja	 SHORT $LN4@resize
  0000d	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00010	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00014	72 02		 jb	 SHORT $LN27@resize
  00016	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN27@resize:
  00018	c6 04 01 00	 mov	 BYTE PTR [ecx+eax], 0

; 1777 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4

; 1776 : 		resize(_Newsize, _Elem());

$LN4@resize:
  00020	6a 00		 push	 0
  00022	2b c2		 sub	 eax, edx
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1777 : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1772 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1765 : 		return (this->_Mysize());

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1766 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1743 : 		return (this->_Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN13@c_str
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1744 : 		}

  00008	c3		 ret	 0

; 1743 : 		return (this->_Myptr());

$LN13@c_str:
  00009	8b c1		 mov	 eax, ecx

; 1744 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1692 : 		{	// subscript nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1693 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1694 : 		if (this->_Mysize() < _Off)	// sic
; 1695 : 			_DEBUG_ERROR("string subscript out of range");
; 1696 : 
; 1697 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1698 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1699 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1700 : 
; 1701 : 		return (this->_Myptr()[_Off]);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	72 02		 jb	 SHORT $LN13@operator
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN13@operator:
  0000e	03 c1		 add	 eax, ecx

; 1702 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1679 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1680 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1681 : 		if (this->_Mysize() < _Off)	// sic
; 1682 : 			_DEBUG_ERROR("string subscript out of range");
; 1683 : 
; 1684 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1685 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1686 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1687 : 
; 1688 : 		return (this->_Myptr()[_Off]);

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	72 02		 jb	 SHORT $LN13@operator
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN13@operator:
  0000e	03 c1		 add	 eax, ecx

; 1689 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 1606 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1607 : 		auto _Mydata = &this->_Get_data();
; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	72 10		 jb	 SHORT $LN11@end
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0000e	03 c8		 add	 ecx, eax
  00010	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00013	89 08		 mov	 DWORD PTR [eax], ecx

; 1609 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4

; 1607 : 		auto _Mydata = &this->_Get_data();
; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

$LN11@end:
  00019	8b c1		 mov	 eax, ecx
  0001b	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0001e	03 c8		 add	 ecx, eax
  00020	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 1609 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 1594 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1595 : 		auto _Mydata = &this->_Get_data();
; 1596 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));

  00003	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	72 02		 jb	 SHORT $LN11@begin
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN11@begin:
  0000e	89 08		 mov	 DWORD PTR [eax], ecx

; 1597 : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1584 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1585 : 		if (_First2 == _Last2)

  00003	8b 45 10	 mov	 eax, DWORD PTR __First2$[ebp]
  00006	8b 55 14	 mov	 edx, DWORD PTR __Last2$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	3b c2		 cmp	 eax, edx
  0000e	75 36		 jne	 SHORT $LN2@replace

; 1586 : 			erase(_First - begin(), _Last - _First);

  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00013	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00016	2b c8		 sub	 ecx, eax
  00018	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0001c	72 14		 jb	 SHORT $LN24@replace
  0001e	8b 16		 mov	 edx, DWORD PTR [esi]
  00020	2b c2		 sub	 eax, edx
  00022	51		 push	 ecx
  00023	50		 push	 eax
  00024	8b ce		 mov	 ecx, esi
  00026	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  0002b	8b c6		 mov	 eax, esi
  0002d	5e		 pop	 esi

; 1591 : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 10 00	 ret	 16			; 00000010H

; 1586 : 			erase(_First - begin(), _Last - _First);

$LN24@replace:
  00032	8b d6		 mov	 edx, esi
  00034	51		 push	 ecx
  00035	2b c2		 sub	 eax, edx
  00037	8b ce		 mov	 ecx, esi
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  0003f	8b c6		 mov	 eax, esi
  00041	5e		 pop	 esi

; 1591 : 		}

  00042	5d		 pop	 ebp
  00043	c2 10 00	 ret	 16			; 00000010H
$LN2@replace:

; 1587 : 		else
; 1588 : 			replace(_First - begin(), _Last - _First,

  00046	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00049	2b d0		 sub	 edx, eax
  0004b	53		 push	 ebx
  0004c	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0004f	2b d9		 sub	 ebx, ecx
  00051	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00055	57		 push	 edi
  00056	72 04		 jb	 SHORT $LN76@replace
  00058	8b 3e		 mov	 edi, DWORD PTR [esi]
  0005a	eb 02		 jmp	 SHORT $LN77@replace
$LN76@replace:
  0005c	8b fe		 mov	 edi, esi
$LN77@replace:
  0005e	52		 push	 edx
  0005f	50		 push	 eax
  00060	2b cf		 sub	 ecx, edi
  00062	53		 push	 ebx
  00063	51		 push	 ecx
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
  0006b	5f		 pop	 edi
  0006c	5b		 pop	 ebx

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi

; 1591 : 		}

  00070	5d		 pop	 ebp
  00071	c2 10 00	 ret	 16			; 00000010H
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z
_TEXT	SEGMENT
__Nm$1$ = -8						; size = 4
tv890 = -4						; size = 4
tv887 = -4						; size = 4
__Off$ = 8						; size = 4
tv891 = 12						; size = 4
tv888 = 12						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1453 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1454 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1455 : 		if (_Inside(_Ptr))

  00003	8b 55 10	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	85 d2		 test	 edx, edx
  0000f	74 4d		 je	 SHORT $LN2@replace
  00011	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00014	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00017	72 04		 jb	 SHORT $LN24@replace
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	eb 02		 jmp	 SHORT $LN25@replace
$LN24@replace:
  0001d	8b c6		 mov	 eax, esi
$LN25@replace:
  0001f	3b d0		 cmp	 edx, eax
  00021	72 3b		 jb	 SHORT $LN2@replace
  00023	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00026	72 04		 jb	 SHORT $LN38@replace
  00028	8b 3e		 mov	 edi, DWORD PTR [esi]
  0002a	eb 02		 jmp	 SHORT $LN39@replace
$LN38@replace:
  0002c	8b fe		 mov	 edi, esi
$LN39@replace:
  0002e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00031	03 c7		 add	 eax, edi
  00033	3b c2		 cmp	 eax, edx
  00035	76 27		 jbe	 SHORT $LN2@replace

; 1456 : 			return (replace(_Off, _N0, *this,

  00037	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0003a	72 04		 jb	 SHORT $LN61@replace
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	eb 02		 jmp	 SHORT $LN62@replace
$LN61@replace:
  00040	8b c6		 mov	 eax, esi
$LN62@replace:
  00042	ff 75 14	 push	 DWORD PTR __Count$[ebp]
  00045	2b d0		 sub	 edx, eax
  00047	8b ce		 mov	 ecx, esi
  00049	52		 push	 edx
  0004a	56		 push	 esi
  0004b	ff 75 0c	 push	 DWORD PTR __N0$[ebp]
  0004e	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00051	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 1480 : 		}

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 10 00	 ret	 16			; 00000010H
$LN2@replace:

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);

  0005e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00061	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00064	3b c8		 cmp	 ecx, eax
  00066	0f 82 61 01 00
	00		 jb	 $LN312@replace

; 1460 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1461 : 		if (npos - _Count <= this->_Mysize() - _N0)

  0006c	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  0006f	8b f9		 mov	 edi, ecx
  00071	2b f8		 sub	 edi, eax
  00073	8b c2		 mov	 eax, edx
  00075	53		 push	 ebx
  00076	8b 5d 0c	 mov	 ebx, DWORD PTR __N0$[ebp]
  00079	f7 d0		 not	 eax
  0007b	3b df		 cmp	 ebx, edi
  0007d	0f 47 df	 cmova	 ebx, edi
  00080	2b cb		 sub	 ecx, ebx
  00082	3b c1		 cmp	 eax, ecx
  00084	0f 86 4d 01 00
	00		 jbe	 $LN314@replace

; 1463 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;

  0008a	2b fb		 sub	 edi, ebx
  0008c	89 7d f8	 mov	 DWORD PTR __Nm$1$[ebp], edi

; 1464 : 
; 1465 : 		if (_Count < _N0)

  0008f	3b d3		 cmp	 edx, ebx
  00091	73 43		 jae	 SHORT $LN145@replace

; 1466 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00093	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00096	83 f8 10	 cmp	 eax, 16			; 00000010H
  00099	72 07		 jb	 SHORT $LN124@replace
  0009b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0009d	89 4d 0c	 mov	 DWORD PTR tv891[ebp], ecx
  000a0	eb 03		 jmp	 SHORT $LN125@replace
$LN124@replace:
  000a2	89 75 0c	 mov	 DWORD PTR tv891[ebp], esi
$LN125@replace:
  000a5	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a8	72 07		 jb	 SHORT $LN138@replace
  000aa	8b 06		 mov	 eax, DWORD PTR [esi]
  000ac	89 45 fc	 mov	 DWORD PTR tv890[ebp], eax
  000af	eb 03		 jmp	 SHORT $LN139@replace
$LN138@replace:
  000b1	89 75 fc	 mov	 DWORD PTR tv890[ebp], esi
$LN139@replace:
  000b4	85 ff		 test	 edi, edi
  000b6	74 1e		 je	 SHORT $LN145@replace
  000b8	8b 45 0c	 mov	 eax, DWORD PTR tv891[ebp]
  000bb	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  000be	03 c3		 add	 eax, ebx
  000c0	57		 push	 edi
  000c1	50		 push	 eax
  000c2	8b 45 fc	 mov	 eax, DWORD PTR tv890[ebp]
  000c5	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  000c8	03 c2		 add	 eax, edx
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _memmove
  000d0	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN145@replace:

; 1467 : 				this->_Myptr() + _Off + _N0,
; 1468 : 				_Nm);	// smaller hole, move tail up
; 1469 : 		const size_type _Num = this->_Mysize() + _Count - _N0;

  000d6	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000d9	8b f8		 mov	 edi, eax
  000db	2b fb		 sub	 edi, ebx
  000dd	03 fa		 add	 edi, edx

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

  000df	85 d2		 test	 edx, edx
  000e1	75 08		 jne	 SHORT $LN6@replace
  000e3	85 db		 test	 ebx, ebx
  000e5	0f 84 d7 00 00
	00		 je	 $LN306@replace
$LN6@replace:
  000eb	83 ff fe	 cmp	 edi, -2			; fffffffeH
  000ee	0f 87 ed 00 00
	00		 ja	 $LN315@replace
  000f4	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  000f7	73 27		 jae	 SHORT $LN157@replace
  000f9	50		 push	 eax
  000fa	57		 push	 edi
  000fb	8b ce		 mov	 ecx, esi
  000fd	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00102	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  00105	85 ff		 test	 edi, edi
  00107	0f 84 b5 00 00
	00		 je	 $LN306@replace
$LN311@replace:

; 1472 : 			{	// make room and rearrange
; 1473 : 			if (_N0 < _Count)

  0010d	3b da		 cmp	 ebx, edx
  0010f	73 71		 jae	 SHORT $LN272@replace

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

  00111	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00114	83 f8 10	 cmp	 eax, 16			; 00000010H
  00117	72 32		 jb	 SHORT $LN251@replace
  00119	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0011b	89 4d 0c	 mov	 DWORD PTR tv888[ebp], ecx
  0011e	eb 2e		 jmp	 SHORT $LN252@replace

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

$LN157@replace:
  00120	85 ff		 test	 edi, edi
  00122	75 e9		 jne	 SHORT $LN311@replace
  00124	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00127	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0012b	72 10		 jb	 SHORT $LN234@replace
  0012d	8b 06		 mov	 eax, DWORD PTR [esi]
  0012f	5b		 pop	 ebx
  00130	5f		 pop	 edi
  00131	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1478 : 			}
; 1479 : 		return (*this);

  00134	8b c6		 mov	 eax, esi
  00136	5e		 pop	 esi

; 1480 : 		}

  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c2 10 00	 ret	 16			; 00000010H

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

$LN234@replace:
  0013d	8b c6		 mov	 eax, esi
  0013f	5b		 pop	 ebx
  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1480 : 		}

  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c2 10 00	 ret	 16			; 00000010H

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

$LN251@replace:
  0014b	89 75 0c	 mov	 DWORD PTR tv888[ebp], esi
$LN252@replace:
  0014e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00151	72 07		 jb	 SHORT $LN265@replace
  00153	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00155	89 4d fc	 mov	 DWORD PTR tv887[ebp], ecx
  00158	eb 03		 jmp	 SHORT $LN266@replace
$LN265@replace:
  0015a	89 75 fc	 mov	 DWORD PTR tv887[ebp], esi
$LN266@replace:
  0015d	8b 45 f8	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00160	85 c0		 test	 eax, eax
  00162	74 1e		 je	 SHORT $LN272@replace
  00164	50		 push	 eax
  00165	8b 45 0c	 mov	 eax, DWORD PTR tv888[ebp]
  00168	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  0016b	03 c3		 add	 eax, ebx
  0016d	50		 push	 eax
  0016e	8b 45 fc	 mov	 eax, DWORD PTR tv887[ebp]
  00171	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00174	03 c2		 add	 eax, edx
  00176	50		 push	 eax
  00177	e8 00 00 00 00	 call	 _memmove
  0017c	8b 55 14	 mov	 edx, DWORD PTR __Count$[ebp]
  0017f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN272@replace:

; 1475 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1476 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

  00182	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00186	72 04		 jb	 SHORT $LN283@replace
  00188	8b 06		 mov	 eax, DWORD PTR [esi]
  0018a	eb 02		 jmp	 SHORT $LN284@replace
$LN283@replace:
  0018c	8b c6		 mov	 eax, esi
$LN284@replace:
  0018e	85 d2		 test	 edx, edx
  00190	74 10		 je	 SHORT $LN290@replace
  00192	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00195	52		 push	 edx
  00196	ff 75 10	 push	 DWORD PTR __Ptr$[ebp]
  00199	50		 push	 eax
  0019a	e8 00 00 00 00	 call	 _memcpy
  0019f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN290@replace:

; 1477 : 			_Eos(_Num);

  001a2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  001a6	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  001a9	72 11		 jb	 SHORT $LN301@replace
  001ab	8b 06		 mov	 eax, DWORD PTR [esi]
  001ad	5b		 pop	 ebx
  001ae	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1478 : 			}
; 1479 : 		return (*this);

  001b2	8b c6		 mov	 eax, esi
  001b4	5f		 pop	 edi
  001b5	5e		 pop	 esi

; 1480 : 		}

  001b6	8b e5		 mov	 esp, ebp
  001b8	5d		 pop	 ebp
  001b9	c2 10 00	 ret	 16			; 00000010H

; 1477 : 			_Eos(_Num);

$LN301@replace:
  001bc	8b c6		 mov	 eax, esi
  001be	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN306@replace:

; 1478 : 			}
; 1479 : 		return (*this);

  001c2	5b		 pop	 ebx
  001c3	5f		 pop	 edi
  001c4	8b c6		 mov	 eax, esi
  001c6	5e		 pop	 esi

; 1480 : 		}

  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	c2 10 00	 ret	 16			; 00000010H
$LN312@replace:

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);

  001cd	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  001d2	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN316@replace:
$LN314@replace:

; 1462 : 			_Xlen();	// result too long

  001d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  001dc	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN317@replace:
$LN315@replace:

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

  001e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  001e6	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN318@replace:
$LN309@replace:
  001eb	cc		 int	 3
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z
_TEXT	SEGMENT
tv1828 = -8						; size = 4
tv1825 = -8						; size = 4
__Max_effective_size$1$ = -8				; size = 4
__Nm$1$ = -4						; size = 4
tv1824 = 8						; size = 4
tv1821 = 8						; size = 4
tv1817 = 8						; size = 4
tv1813 = 8						; size = 4
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
tv1809 = 16						; size = 4
tv1807 = 16						; size = 4
tv1805 = 16						; size = 4
__Right$ = 16						; size = 4
tv1819 = 20						; size = 4
__Roff$ = 20						; size = 4
tv1798 = 24						; size = 4
__Newsize$1$ = 24					; size = 4
__Count$ = 24						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1389 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 1390 : 		_Check_offset(_Off);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00011	3b c3		 cmp	 eax, ebx
  00013	0f 82 95 03 00
	00		 jb	 $LN600@replace

; 1391 : 		_Right._Check_offset(_Roff);

  00019	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001c	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
  0001f	3b 7d 14	 cmp	 edi, DWORD PTR __Roff$[ebp]
  00022	0f 82 90 03 00
	00		 jb	 $LN602@replace

; 1392 : 		_N0 = _Clamp_suffix_size(_Off, _N0);

  00028	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0002b	2b c3		 sub	 eax, ebx
  0002d	3b d0		 cmp	 edx, eax
  0002f	89 45 fc	 mov	 DWORD PTR __Nm$1$[ebp], eax
  00032	0f 47 d0	 cmova	 edx, eax

; 1393 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00035	2b 7d 14	 sub	 edi, DWORD PTR __Roff$[ebp]

; 1394 : 		if (npos - _Count <= this->_Mysize() - _N0)

  00038	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0003b	89 7d f8	 mov	 DWORD PTR __Max_effective_size$1$[ebp], edi
  0003e	8b 7d 18	 mov	 edi, DWORD PTR __Count$[ebp]
  00041	3b 7d f8	 cmp	 edi, DWORD PTR __Max_effective_size$1$[ebp]
  00044	89 55 0c	 mov	 DWORD PTR __N0$[ebp], edx
  00047	0f 47 7d f8	 cmova	 edi, DWORD PTR __Max_effective_size$1$[ebp]
  0004b	2b c2		 sub	 eax, edx
  0004d	89 45 18	 mov	 DWORD PTR tv1798[ebp], eax
  00050	8b c7		 mov	 eax, edi
  00052	f7 d0		 not	 eax
  00054	3b 45 18	 cmp	 eax, DWORD PTR tv1798[ebp]
  00057	0f 86 65 03 00
	00		 jbe	 $LN603@replace

; 1396 : 
; 1397 : 		const size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1398 : 		const size_type _Newsize = this->_Mysize() + _Count - _N0;

  0005d	8b 5d 18	 mov	 ebx, DWORD PTR tv1798[ebp]
  00060	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00063	03 df		 add	 ebx, edi
  00065	2b c2		 sub	 eax, edx
  00067	89 5d 18	 mov	 DWORD PTR __Newsize$1$[ebp], ebx

; 1399 : 		if (this->_Mysize() < _Newsize)

  0006a	39 5e 10	 cmp	 DWORD PTR [esi+16], ebx
  0006d	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  00070	89 45 fc	 mov	 DWORD PTR __Nm$1$[ebp], eax
  00073	73 53		 jae	 SHORT $LN194@replace

; 1400 : 			_Grow(_Newsize);

  00075	83 7d 18 fe	 cmp	 DWORD PTR __Newsize$1$[ebp], -2 ; fffffffeH
  00079	0f 87 4d 03 00
	00		 ja	 $LN604@replace
  0007f	8b 5d 18	 mov	 ebx, DWORD PTR __Newsize$1$[ebp]
  00082	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00085	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  00088	73 18		 jae	 SHORT $LN112@replace
  0008a	ff 76 10	 push	 DWORD PTR [esi+16]
  0008d	8b ce		 mov	 ecx, esi
  0008f	ff 75 18	 push	 DWORD PTR __Newsize$1$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00097	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0009a	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  000a0	eb 26		 jmp	 SHORT $LN194@replace
$LN112@replace:
  000a2	83 7d 18 00	 cmp	 DWORD PTR __Newsize$1$[ebp], 0
  000a6	75 20		 jne	 SHORT $LN194@replace
  000a8	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  000af	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b3	72 07		 jb	 SHORT $LN189@replace
  000b5	8b 1e		 mov	 ebx, DWORD PTR [esi]
  000b7	89 5d f8	 mov	 DWORD PTR tv1828[ebp], ebx
  000ba	eb 03		 jmp	 SHORT $LN190@replace
$LN189@replace:
  000bc	89 75 f8	 mov	 DWORD PTR tv1828[ebp], esi
$LN190@replace:
  000bf	8b 5d f8	 mov	 ebx, DWORD PTR tv1828[ebp]
  000c2	c6 03 00	 mov	 BYTE PTR [ebx], 0
  000c5	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
$LN194@replace:

; 1401 : 
; 1402 : 		if (_Count == _N0)

  000c8	3b fa		 cmp	 edi, edx
  000ca	75 2b		 jne	 SHORT $LN4@replace

; 1403 : 			{	// only one movement required, so _Traits::move handles any overlap
; 1404 : 			_Traits::move(this->_Myptr() + _Off,

  000cc	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  000d0	72 02		 jb	 SHORT $LN206@replace
  000d2	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN206@replace:
  000d4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000d8	72 04		 jb	 SHORT $LN220@replace
  000da	8b 16		 mov	 edx, DWORD PTR [esi]
  000dc	eb 02		 jmp	 SHORT $LN221@replace
$LN220@replace:
  000de	8b d6		 mov	 edx, esi
$LN221@replace:
  000e0	85 ff		 test	 edi, edi
  000e2	0f 84 9a 02 00
	00		 je	 $LN579@replace
  000e8	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  000eb	03 c1		 add	 eax, ecx
  000ed	57		 push	 edi
  000ee	50		 push	 eax
  000ef	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  000f2	e9 82 02 00 00	 jmp	 $LN598@replace
$LN4@replace:

; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (this != &_Right)

  000f7	3b f1		 cmp	 esi, ecx
  000f9	74 77		 je	 SHORT $LN6@replace

; 1408 : 			{	// no overlap, just move down and copy in new stuff
; 1409 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  000fb	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000ff	72 0a		 jb	 SHORT $LN238@replace
  00101	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00103	89 5d f8	 mov	 DWORD PTR tv1825[ebp], ebx
  00106	8b 5d 08	 mov	 ebx, DWORD PTR __Off$[ebp]
  00109	eb 03		 jmp	 SHORT $LN239@replace
$LN238@replace:
  0010b	89 75 f8	 mov	 DWORD PTR tv1825[ebp], esi
$LN239@replace:
  0010e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00112	72 0a		 jb	 SHORT $LN252@replace
  00114	8b 16		 mov	 edx, DWORD PTR [esi]
  00116	89 55 08	 mov	 DWORD PTR tv1824[ebp], edx
  00119	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0011c	eb 03		 jmp	 SHORT $LN253@replace
$LN252@replace:
  0011e	89 75 08	 mov	 DWORD PTR tv1824[ebp], esi
$LN253@replace:
  00121	85 c0		 test	 eax, eax
  00123	74 1c		 je	 SHORT $LN259@replace
  00125	50		 push	 eax
  00126	8b 45 f8	 mov	 eax, DWORD PTR tv1825[ebp]
  00129	03 c3		 add	 eax, ebx
  0012b	03 c2		 add	 eax, edx
  0012d	50		 push	 eax
  0012e	8b 45 08	 mov	 eax, DWORD PTR tv1824[ebp]
  00131	03 c3		 add	 eax, ebx
  00133	03 c7		 add	 eax, edi
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 _memmove
  0013b	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0013e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN259@replace:

; 1410 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1411 : 			_Traits::copy(this->_Myptr() + _Off,

  00141	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00145	72 02		 jb	 SHORT $LN270@replace
  00147	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN270@replace:
  00149	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0014d	72 04		 jb	 SHORT $LN284@replace
  0014f	8b 16		 mov	 edx, DWORD PTR [esi]
  00151	eb 02		 jmp	 SHORT $LN285@replace
$LN284@replace:
  00153	8b d6		 mov	 edx, esi
$LN285@replace:
  00155	85 ff		 test	 edi, edi
  00157	0f 84 25 02 00
	00		 je	 $LN579@replace
  0015d	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  00160	03 c1		 add	 eax, ecx
  00162	57		 push	 edi
  00163	50		 push	 eax
  00164	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 _memcpy
  0016d	e9 0d 02 00 00	 jmp	 $LN599@replace
$LN6@replace:

; 1412 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1413 : 			}
; 1414 : 		else if (_Count < _N0)

  00172	3b fa		 cmp	 edi, edx
  00174	73 73		 jae	 SHORT $LN8@replace

; 1415 : 			{	// hole doesn't get larger, just copy in substring
; 1416 : 			_Traits::move(this->_Myptr() + _Off,

  00176	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00179	83 f8 10	 cmp	 eax, 16			; 00000010H
  0017c	72 07		 jb	 SHORT $LN302@replace
  0017e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00180	89 4d 08	 mov	 DWORD PTR tv1821[ebp], ecx
  00183	eb 03		 jmp	 SHORT $LN303@replace
$LN302@replace:
  00185	89 75 08	 mov	 DWORD PTR tv1821[ebp], esi
$LN303@replace:
  00188	83 f8 10	 cmp	 eax, 16			; 00000010H
  0018b	72 04		 jb	 SHORT $LN316@replace
  0018d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0018f	eb 02		 jmp	 SHORT $LN317@replace
$LN316@replace:
  00191	8b ce		 mov	 ecx, esi
$LN317@replace:
  00193	85 ff		 test	 edi, edi
  00195	74 17		 je	 SHORT $LN323@replace
  00197	8b 45 08	 mov	 eax, DWORD PTR tv1821[ebp]
  0019a	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  0019d	57		 push	 edi
  0019e	50		 push	 eax
  0019f	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  001a2	50		 push	 eax
  001a3	e8 00 00 00 00	 call	 _memmove
  001a8	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  001ab	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN323@replace:

; 1417 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1418 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  001ae	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001b1	83 f8 10	 cmp	 eax, 16			; 00000010H
  001b4	72 07		 jb	 SHORT $LN334@replace
  001b6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001b8	89 4d 14	 mov	 DWORD PTR tv1819[ebp], ecx
  001bb	eb 03		 jmp	 SHORT $LN335@replace
$LN334@replace:
  001bd	89 75 14	 mov	 DWORD PTR tv1819[ebp], esi
$LN335@replace:
  001c0	83 f8 10	 cmp	 eax, 16			; 00000010H
  001c3	72 04		 jb	 SHORT $LN348@replace
  001c5	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001c7	eb 02		 jmp	 SHORT $LN349@replace
$LN348@replace:
  001c9	8b ce		 mov	 ecx, esi
$LN349@replace:
  001cb	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  001ce	85 c0		 test	 eax, eax
  001d0	0f 84 ac 01 00
	00		 je	 $LN579@replace
  001d6	50		 push	 eax
  001d7	8b 45 14	 mov	 eax, DWORD PTR tv1819[ebp]
  001da	03 c3		 add	 eax, ebx
  001dc	03 c2		 add	 eax, edx
  001de	50		 push	 eax
  001df	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  001e2	03 c7		 add	 eax, edi
  001e4	e9 90 01 00 00	 jmp	 $LN598@replace
$LN8@replace:

; 1419 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1420 : 			}
; 1421 : 		else if (_Roff <= _Off)

  001e9	8b 4d 14	 mov	 ecx, DWORD PTR __Roff$[ebp]
  001ec	3b cb		 cmp	 ecx, ebx
  001ee	77 6b		 ja	 SHORT $LN10@replace

; 1422 : 			{	// hole gets larger, substring begins before hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  001f0	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  001f3	83 f9 10	 cmp	 ecx, 16			; 00000010H
  001f6	72 0a		 jb	 SHORT $LN366@replace
  001f8	8b 16		 mov	 edx, DWORD PTR [esi]
  001fa	89 55 08	 mov	 DWORD PTR tv1817[ebp], edx
  001fd	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  00200	eb 03		 jmp	 SHORT $LN367@replace
$LN366@replace:
  00202	89 75 08	 mov	 DWORD PTR tv1817[ebp], esi
$LN367@replace:
  00205	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00208	72 04		 jb	 SHORT $LN380@replace
  0020a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0020c	eb 02		 jmp	 SHORT $LN381@replace
$LN380@replace:
  0020e	8b ce		 mov	 ecx, esi
$LN381@replace:
  00210	85 c0		 test	 eax, eax
  00212	74 17		 je	 SHORT $LN387@replace
  00214	50		 push	 eax
  00215	8b 45 08	 mov	 eax, DWORD PTR tv1817[ebp]
  00218	03 c3		 add	 eax, ebx
  0021a	03 c2		 add	 eax, edx
  0021c	50		 push	 eax
  0021d	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00220	03 c7		 add	 eax, edi
  00222	50		 push	 eax
  00223	e8 00 00 00 00	 call	 _memmove
  00228	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN387@replace:

; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,

  0022b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0022e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00231	72 04		 jb	 SHORT $LN398@replace
  00233	8b 16		 mov	 edx, DWORD PTR [esi]
  00235	eb 02		 jmp	 SHORT $LN399@replace
$LN398@replace:
  00237	8b d6		 mov	 edx, esi
$LN399@replace:
  00239	83 f8 10	 cmp	 eax, 16			; 00000010H
  0023c	72 04		 jb	 SHORT $LN412@replace
  0023e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00240	eb 02		 jmp	 SHORT $LN413@replace
$LN412@replace:
  00242	8b ce		 mov	 ecx, esi
$LN413@replace:
  00244	85 ff		 test	 edi, edi
  00246	0f 84 36 01 00
	00		 je	 $LN579@replace
  0024c	8b 45 14	 mov	 eax, DWORD PTR __Roff$[ebp]
  0024f	03 c2		 add	 eax, edx
  00251	57		 push	 edi
  00252	50		 push	 eax
  00253	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00256	e9 1e 01 00 00	 jmp	 $LN598@replace
$LN10@replace:

; 1426 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1427 : 			}
; 1428 : 		else if (_Off + _N0 <= _Roff)

  0025b	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  0025e	3b c1		 cmp	 eax, ecx

; 1429 : 			{	// hole gets larger, substring begins after hole
; 1430 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00260	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00263	77 6d		 ja	 SHORT $LN12@replace
  00265	83 f8 10	 cmp	 eax, 16			; 00000010H
  00268	72 07		 jb	 SHORT $LN430@replace
  0026a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0026c	89 4d 08	 mov	 DWORD PTR tv1813[ebp], ecx
  0026f	eb 03		 jmp	 SHORT $LN431@replace
$LN430@replace:
  00271	89 75 08	 mov	 DWORD PTR tv1813[ebp], esi
$LN431@replace:
  00274	83 f8 10	 cmp	 eax, 16			; 00000010H
  00277	72 04		 jb	 SHORT $LN444@replace
  00279	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0027b	eb 02		 jmp	 SHORT $LN445@replace
$LN444@replace:
  0027d	8b ce		 mov	 ecx, esi
$LN445@replace:
  0027f	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00282	85 c0		 test	 eax, eax
  00284	74 1a		 je	 SHORT $LN451@replace
  00286	50		 push	 eax
  00287	8b 45 08	 mov	 eax, DWORD PTR tv1813[ebp]
  0028a	03 c3		 add	 eax, ebx
  0028c	03 c2		 add	 eax, edx
  0028e	50		 push	 eax
  0028f	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00292	03 c7		 add	 eax, edi
  00294	50		 push	 eax
  00295	e8 00 00 00 00	 call	 _memmove
  0029a	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  0029d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN451@replace:

; 1431 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1432 : 			_Traits::move(this->_Myptr() + _Off,

  002a0	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  002a3	83 f9 10	 cmp	 ecx, 16			; 00000010H
  002a6	72 04		 jb	 SHORT $LN462@replace
  002a8	8b 06		 mov	 eax, DWORD PTR [esi]
  002aa	eb 02		 jmp	 SHORT $LN463@replace
$LN462@replace:
  002ac	8b c6		 mov	 eax, esi
$LN463@replace:
  002ae	83 f9 10	 cmp	 ecx, 16			; 00000010H
  002b1	72 04		 jb	 SHORT $LN476@replace
  002b3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002b5	eb 02		 jmp	 SHORT $LN477@replace
$LN476@replace:
  002b7	8b ce		 mov	 ecx, esi
$LN477@replace:
  002b9	85 ff		 test	 edi, edi
  002bb	0f 84 c1 00 00
	00		 je	 $LN579@replace
  002c1	2b c2		 sub	 eax, edx
  002c3	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  002c6	03 c7		 add	 eax, edi
  002c8	57		 push	 edi
  002c9	50		 push	 eax
  002ca	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]

; 1433 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1434 : 				_Count);	// fill hole
; 1435 : 			}
; 1436 : 		else

  002cd	e9 a7 00 00 00	 jmp	 $LN598@replace
$LN12@replace:

; 1437 : 			{	// hole gets larger, substring begins in hole
; 1438 : 			_Traits::move(this->_Myptr() + _Off,

  002d2	83 f8 10	 cmp	 eax, 16			; 00000010H
  002d5	72 07		 jb	 SHORT $LN494@replace
  002d7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002d9	89 4d 10	 mov	 DWORD PTR tv1809[ebp], ecx
  002dc	eb 03		 jmp	 SHORT $LN495@replace
$LN494@replace:
  002de	89 75 10	 mov	 DWORD PTR tv1809[ebp], esi
$LN495@replace:
  002e1	83 f8 10	 cmp	 eax, 16			; 00000010H
  002e4	72 04		 jb	 SHORT $LN508@replace
  002e6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002e8	eb 02		 jmp	 SHORT $LN509@replace
$LN508@replace:
  002ea	8b ce		 mov	 ecx, esi
$LN509@replace:
  002ec	85 d2		 test	 edx, edx
  002ee	74 17		 je	 SHORT $LN515@replace
  002f0	8b 45 10	 mov	 eax, DWORD PTR tv1809[ebp]
  002f3	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  002f6	52		 push	 edx
  002f7	50		 push	 eax
  002f8	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  002fb	50		 push	 eax
  002fc	e8 00 00 00 00	 call	 _memmove
  00301	8b 55 0c	 mov	 edx, DWORD PTR __N0$[ebp]
  00304	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN515@replace:

; 1439 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00307	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0030a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0030d	72 07		 jb	 SHORT $LN526@replace
  0030f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00311	89 4d 10	 mov	 DWORD PTR tv1807[ebp], ecx
  00314	eb 03		 jmp	 SHORT $LN527@replace
$LN526@replace:
  00316	89 75 10	 mov	 DWORD PTR tv1807[ebp], esi
$LN527@replace:
  00319	83 f8 10	 cmp	 eax, 16			; 00000010H
  0031c	72 04		 jb	 SHORT $LN540@replace
  0031e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00320	eb 02		 jmp	 SHORT $LN541@replace
$LN540@replace:
  00322	8b ce		 mov	 ecx, esi
$LN541@replace:
  00324	8b 45 fc	 mov	 eax, DWORD PTR __Nm$1$[ebp]
  00327	85 c0		 test	 eax, eax
  00329	74 17		 je	 SHORT $LN547@replace
  0032b	50		 push	 eax
  0032c	8b 45 10	 mov	 eax, DWORD PTR tv1807[ebp]
  0032f	03 c3		 add	 eax, ebx
  00331	03 c2		 add	 eax, edx
  00333	50		 push	 eax
  00334	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00337	03 c7		 add	 eax, edi
  00339	50		 push	 eax
  0033a	e8 00 00 00 00	 call	 _memmove
  0033f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN547@replace:

; 1441 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1442 : 			_Traits::move(this->_Myptr() + _Off + _N0,

  00342	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00345	83 f8 10	 cmp	 eax, 16			; 00000010H
  00348	72 07		 jb	 SHORT $LN558@replace
  0034a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0034c	89 4d 10	 mov	 DWORD PTR tv1805[ebp], ecx
  0034f	eb 03		 jmp	 SHORT $LN559@replace
$LN558@replace:
  00351	89 75 10	 mov	 DWORD PTR tv1805[ebp], esi
$LN559@replace:
  00354	83 f8 10	 cmp	 eax, 16			; 00000010H
  00357	72 04		 jb	 SHORT $LN572@replace
  00359	8b 16		 mov	 edx, DWORD PTR [esi]
  0035b	eb 02		 jmp	 SHORT $LN573@replace
$LN572@replace:
  0035d	8b d6		 mov	 edx, esi
$LN573@replace:
  0035f	8b 4d 0c	 mov	 ecx, DWORD PTR __N0$[ebp]
  00362	8b c7		 mov	 eax, edi
  00364	2b c1		 sub	 eax, ecx
  00366	74 1a		 je	 SHORT $LN579@replace
  00368	50		 push	 eax
  00369	8b 45 10	 mov	 eax, DWORD PTR tv1805[ebp]
  0036c	03 45 14	 add	 eax, DWORD PTR __Roff$[ebp]
  0036f	03 c7		 add	 eax, edi
  00371	50		 push	 eax
  00372	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00375	03 c2		 add	 eax, edx
  00377	03 c1		 add	 eax, ecx
$LN598@replace:
  00379	50		 push	 eax
  0037a	e8 00 00 00 00	 call	 _memmove
$LN599@replace:
  0037f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN579@replace:

; 1443 : 				this->_Myptr() + _Roff + _Count,
; 1444 : 				_Count - _N0);	// fill rest of new hole
; 1445 : 			}
; 1446 : 
; 1447 : 		_Eos(_Newsize);

  00382	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00386	8b 4d 18	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]
  00389	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0038c	72 11		 jb	 SHORT $LN590@replace
  0038e	8b 06		 mov	 eax, DWORD PTR [esi]
  00390	5f		 pop	 edi
  00391	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1448 : 		return (*this);

  00395	8b c6		 mov	 eax, esi
  00397	5e		 pop	 esi
  00398	5b		 pop	 ebx

; 1449 : 		}

  00399	8b e5		 mov	 esp, ebp
  0039b	5d		 pop	 ebp
  0039c	c2 14 00	 ret	 20			; 00000014H

; 1443 : 				this->_Myptr() + _Roff + _Count,
; 1444 : 				_Count - _N0);	// fill rest of new hole
; 1445 : 			}
; 1446 : 
; 1447 : 		_Eos(_Newsize);

$LN590@replace:
  0039f	8b c6		 mov	 eax, esi
  003a1	5f		 pop	 edi
  003a2	5e		 pop	 esi
  003a3	5b		 pop	 ebx
  003a4	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1449 : 		}

  003a8	8b e5		 mov	 esp, ebp
  003aa	5d		 pop	 ebp
  003ab	c2 14 00	 ret	 20			; 00000014H
$LN600@replace:

; 1390 : 		_Check_offset(_Off);

  003ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  003b3	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN605@replace:
$LN602@replace:

; 1391 : 		_Right._Check_offset(_Roff);

  003b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  003bd	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN606@replace:
$LN603@replace:

; 1395 : 			_Xlen();	// result too long

  003c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  003c7	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN607@replace:
$LN604@replace:

; 1400 : 			_Grow(_Newsize);

  003cc	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  003d1	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN608@replace:
$LN597@replace:
  003d6	cc		 int	 3
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear, COMDAT
; _this$ = ecx

; 1378 : 		_Eos(0);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0000b	72 06		 jb	 SHORT $LN13@clear
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1379 : 		}

  00012	c3		 ret	 0

; 1378 : 		_Eos(0);

$LN13@clear:
  00013	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 1379 : 		}

  00016	c3		 ret	 0
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1348 : 		_Check_offset(_Off);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	72 7e		 jb	 SHORT $LN93@erase

; 1349 : 		if (this->_Mysize() - _Off <= _Count)

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00014	8b c7		 mov	 eax, edi
  00016	2b c1		 sub	 eax, ecx
  00018	3b c2		 cmp	 eax, edx
  0001a	77 23		 ja	 SHORT $LN2@erase

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

  0001c	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0001f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00023	72 0e		 jb	 SHORT $LN41@erase
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	5f		 pop	 edi
  00028	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1357 : 			}
; 1358 : 		return (*this);

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi

; 1359 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)

$LN41@erase:
  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 1359 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN2@erase:

; 1351 : 		else if (0 < _Count)

  0003f	85 d2		 test	 edx, edx
  00041	74 44		 je	 SHORT $LN90@erase

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;

  00043	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00047	72 04		 jb	 SHORT $LN58@erase
  00049	8b 06		 mov	 eax, DWORD PTR [esi]
  0004b	eb 02		 jmp	 SHORT $LN59@erase
$LN58@erase:
  0004d	8b c6		 mov	 eax, esi
$LN59@erase:

; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

  0004f	2b fa		 sub	 edi, edx
  00051	53		 push	 ebx
  00052	8d 1c 08	 lea	 ebx, DWORD PTR [eax+ecx]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00055	8b c7		 mov	 eax, edi
  00057	2b c1		 sub	 eax, ecx
  00059	74 0e		 je	 SHORT $LN74@erase
  0005b	50		 push	 eax
  0005c	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  0005f	50		 push	 eax
  00060	53		 push	 ebx
  00061	e8 00 00 00 00	 call	 _memmove
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@erase:

; 1356 : 			_Eos(_Newsize);

  00069	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0006d	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00070	5b		 pop	 ebx
  00071	72 0e		 jb	 SHORT $LN85@erase
  00073	8b 06		 mov	 eax, DWORD PTR [esi]
  00075	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1357 : 			}
; 1358 : 		return (*this);

  00079	8b c6		 mov	 eax, esi
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 1359 : 		}

  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8

; 1356 : 			_Eos(_Newsize);

$LN85@erase:
  00081	8b c6		 mov	 eax, esi
  00083	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN90@erase:

; 1357 : 			}
; 1358 : 		return (*this);

  00087	5f		 pop	 edi
  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi

; 1359 : 		}

  0008b	5d		 pop	 ebp
  0008c	c2 08 00	 ret	 8
$LN93@erase:

; 1348 : 		_Check_offset(_Off);

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00094	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN95@erase:
$LN92@erase:
  00099	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1341 : 		_Check_offset(_Off);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	72 21		 jb	 SHORT $LN37@erase

; 1342 : 		_Eos(_Off);

  0000b	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000e	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00012	72 0c		 jb	 SHORT $LN29@erase
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 1343 : 		return (*this);

  0001a	8b c1		 mov	 eax, ecx

; 1344 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4

; 1342 : 		_Eos(_Off);

$LN29@erase:
  00020	8b d1		 mov	 edx, ecx
  00022	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0

; 1343 : 		return (*this);

  00026	8b c1		 mov	 eax, ecx

; 1344 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN37@erase:

; 1341 : 		_Check_offset(_Off);

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00031	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN39@erase:
$LN36@erase:
  00036	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
tv544 = 12						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1278 : 		{	// insert _Count * _Ch at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1279 : 		_Check_offset(_Off);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000e	3b ca		 cmp	 ecx, edx
  00010	0f 82 d2 00 00
	00		 jb	 $LN188@insert

; 1280 : 		if (npos - this->_Mysize() <= _Count)

  00016	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00019	8b c1		 mov	 eax, ecx
  0001b	f7 d0		 not	 eax
  0001d	3b c3		 cmp	 eax, ebx
  0001f	0f 86 cd 00 00
	00		 jbe	 $LN190@insert

; 1282 : 		const size_type _Num = this->_Mysize() + _Count;

  00025	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]

; 1283 : 		if (0 < _Count && _Grow(_Num))

  00028	85 db		 test	 ebx, ebx
  0002a	0f 84 af 00 00
	00		 je	 $LN183@insert
  00030	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00033	0f 87 c3 00 00
	00		 ja	 $LN191@insert
  00039	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0003c	73 23		 jae	 SHORT $LN43@insert
  0003e	51		 push	 ecx
  0003f	57		 push	 edi
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00047	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  0004a	85 ff		 test	 edi, edi
  0004c	0f 84 8d 00 00
	00		 je	 $LN183@insert
$LN187@insert:

; 1284 : 			{	// make room and insert new stuff
; 1285 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00052	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00055	83 f8 10	 cmp	 eax, 16			; 00000010H
  00058	72 2e		 jb	 SHORT $LN146@insert
  0005a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005c	89 4d 0c	 mov	 DWORD PTR tv544[ebp], ecx
  0005f	eb 2a		 jmp	 SHORT $LN147@insert

; 1283 : 		if (0 < _Count && _Grow(_Num))

$LN43@insert:
  00061	85 ff		 test	 edi, edi
  00063	75 ed		 jne	 SHORT $LN187@insert
  00065	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00068	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0006c	72 0e		 jb	 SHORT $LN120@insert
  0006e	8b 06		 mov	 eax, DWORD PTR [esi]
  00070	5f		 pop	 edi
  00071	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1290 : 			}
; 1291 : 		return (*this);

  00074	8b c6		 mov	 eax, esi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx

; 1292 : 		}

  00078	5d		 pop	 ebp
  00079	c2 0c 00	 ret	 12			; 0000000cH

; 1283 : 		if (0 < _Count && _Grow(_Num))

$LN120@insert:
  0007c	8b c6		 mov	 eax, esi
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1292 : 		}

  00084	5d		 pop	 ebp
  00085	c2 0c 00	 ret	 12			; 0000000cH

; 1284 : 			{	// make room and insert new stuff
; 1285 : 			_Traits::move(this->_Myptr() + _Off + _Count,

$LN146@insert:
  00088	89 75 0c	 mov	 DWORD PTR tv544[ebp], esi
$LN147@insert:
  0008b	83 f8 10	 cmp	 eax, 16			; 00000010H
  0008e	72 04		 jb	 SHORT $LN160@insert
  00090	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00092	eb 02		 jmp	 SHORT $LN161@insert
$LN160@insert:
  00094	8b ce		 mov	 ecx, esi
$LN161@insert:
  00096	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00099	2b c2		 sub	 eax, edx
  0009b	74 18		 je	 SHORT $LN167@insert
  0009d	50		 push	 eax
  0009e	8b 45 0c	 mov	 eax, DWORD PTR tv544[ebp]
  000a1	03 c2		 add	 eax, edx
  000a3	50		 push	 eax
  000a4	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  000a7	03 c3		 add	 eax, ebx
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _memmove
  000af	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN167@insert:

; 1286 : 				this->_Myptr() + _Off,
; 1287 : 				this->_Mysize() - _Off);	// empty out hole
; 1288 : 			_Chassign(_Off, _Count, _Ch);	// fill hole

  000b5	ff 75 10	 push	 DWORD PTR __Ch$[ebp]
  000b8	8b ce		 mov	 ecx, esi
  000ba	53		 push	 ebx
  000bb	52		 push	 edx
  000bc	e8 00 00 00 00	 call	 ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 1289 : 			_Eos(_Num);

  000c1	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000c5	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000c8	72 0f		 jb	 SHORT $LN178@insert
  000ca	8b 06		 mov	 eax, DWORD PTR [esi]
  000cc	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1290 : 			}
; 1291 : 		return (*this);

  000d0	8b c6		 mov	 eax, esi
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx

; 1292 : 		}

  000d5	5d		 pop	 ebp
  000d6	c2 0c 00	 ret	 12			; 0000000cH

; 1289 : 			_Eos(_Num);

$LN178@insert:
  000d9	8b c6		 mov	 eax, esi
  000db	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN183@insert:

; 1290 : 			}
; 1291 : 		return (*this);

  000df	5f		 pop	 edi
  000e0	8b c6		 mov	 eax, esi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx

; 1292 : 		}

  000e4	5d		 pop	 ebp
  000e5	c2 0c 00	 ret	 12			; 0000000cH
$LN188@insert:

; 1279 : 		_Check_offset(_Off);

  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000ed	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN192@insert:
$LN190@insert:

; 1281 : 			_Xlen();	// result too long

  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f7	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN193@insert:
$LN191@insert:

; 1283 : 		if (0 < _Count && _Grow(_Num))

  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00101	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN194@insert:
$LN185@insert:
  00106	cc		 int	 3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1271 : 		{	// insert [_Ptr, <null>) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1272 : 		_DEBUG_POINTER(_Ptr);
; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 11		 jne	 SHORT $LN5@insert
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00013	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00018	5e		 pop	 esi

; 1274 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8

; 1272 : 		_DEBUG_POINTER(_Ptr);
; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

$LN5@insert:
  0001d	8b d6		 mov	 edx, esi
  0001f	57		 push	 edi
  00020	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@insert:
  00023	8a 02		 mov	 al, BYTE PTR [edx]
  00025	42		 inc	 edx
  00026	84 c0		 test	 al, al
  00028	75 f9		 jne	 SHORT $LL7@insert
  0002a	2b d7		 sub	 edx, edi
  0002c	5f		 pop	 edi
  0002d	52		 push	 edx
  0002e	56		 push	 esi
  0002f	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  00032	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00037	5e		 pop	 esi

; 1274 : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z
_TEXT	SEGMENT
tv774 = -4						; size = 4
__Off$ = 8						; size = 4
tv775 = 12						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1250 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1251 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1252 : 		if (_Inside(_Ptr))

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	85 db		 test	 ebx, ebx
  0000d	74 4a		 je	 SHORT $LN2@insert
  0000f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00012	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00015	72 04		 jb	 SHORT $LN21@insert
  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	eb 02		 jmp	 SHORT $LN22@insert
$LN21@insert:
  0001b	8b c6		 mov	 eax, esi
$LN22@insert:
  0001d	3b d8		 cmp	 ebx, eax
  0001f	72 38		 jb	 SHORT $LN2@insert
  00021	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00024	72 04		 jb	 SHORT $LN35@insert
  00026	8b 16		 mov	 edx, DWORD PTR [esi]
  00028	eb 02		 jmp	 SHORT $LN36@insert
$LN35@insert:
  0002a	8b d6		 mov	 edx, esi
$LN36@insert:
  0002c	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002f	03 c2		 add	 eax, edx
  00031	3b c3		 cmp	 eax, ebx
  00033	76 24		 jbe	 SHORT $LN2@insert

; 1253 : 			return (insert(_Off, *this,

  00035	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00038	72 04		 jb	 SHORT $LN58@insert
  0003a	8b 06		 mov	 eax, DWORD PTR [esi]
  0003c	eb 02		 jmp	 SHORT $LN59@insert
$LN58@insert:
  0003e	8b c6		 mov	 eax, esi
$LN59@insert:
  00040	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00043	2b d8		 sub	 ebx, eax
  00045	8b ce		 mov	 ecx, esi
  00047	53		 push	 ebx
  00048	56		 push	 esi
  00049	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  0004c	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx

; 1268 : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 0c 00	 ret	 12			; 0000000cH
$LN2@insert:

; 1254 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1255 : 		_Check_offset(_Off);

  00059	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0005c	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  0005f	0f 82 f9 00 00
	00		 jb	 $LN264@insert

; 1256 : 		if (npos - this->_Mysize() <= _Count)

  00065	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  00068	8b c1		 mov	 eax, ecx
  0006a	f7 d0		 not	 eax
  0006c	3b c2		 cmp	 eax, edx
  0006e	0f 86 f4 00 00
	00		 jbe	 $LN266@insert

; 1258 : 		const size_type _Num = this->_Mysize() + _Count;

  00074	57		 push	 edi
  00075	8d 3c 11	 lea	 edi, DWORD PTR [ecx+edx]

; 1259 : 		if (0 < _Count && _Grow(_Num))

  00078	85 d2		 test	 edx, edx
  0007a	0f 84 d3 00 00
	00		 je	 $LN258@insert
  00080	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00083	0f 87 e9 00 00
	00		 ja	 $LN267@insert
  00089	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0008c	73 23		 jae	 SHORT $LN100@insert
  0008e	51		 push	 ecx
  0008f	57		 push	 edi
  00090	8b ce		 mov	 ecx, esi
  00092	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00097	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  0009a	85 ff		 test	 edi, edi
  0009c	0f 84 b1 00 00
	00		 je	 $LN258@insert
$LN263@insert:

; 1260 : 			{	// make room and insert new stuff
; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  000a2	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000a5	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a8	72 32		 jb	 SHORT $LN203@insert
  000aa	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000ac	89 4d 0c	 mov	 DWORD PTR tv775[ebp], ecx
  000af	eb 2e		 jmp	 SHORT $LN204@insert

; 1259 : 		if (0 < _Count && _Grow(_Num))

$LN100@insert:
  000b1	85 ff		 test	 edi, edi
  000b3	75 ed		 jne	 SHORT $LN263@insert
  000b5	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000b8	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000bc	72 10		 jb	 SHORT $LN177@insert
  000be	8b 06		 mov	 eax, DWORD PTR [esi]
  000c0	5f		 pop	 edi
  000c1	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1266 : 			}
; 1267 : 		return (*this);

  000c4	8b c6		 mov	 eax, esi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx

; 1268 : 		}

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 0c 00	 ret	 12			; 0000000cH

; 1259 : 		if (0 < _Count && _Grow(_Num))

$LN177@insert:
  000ce	8b c6		 mov	 eax, esi
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1268 : 		}

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 0c 00	 ret	 12			; 0000000cH

; 1260 : 			{	// make room and insert new stuff
; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

$LN203@insert:
  000dc	89 75 0c	 mov	 DWORD PTR tv775[ebp], esi
$LN204@insert:
  000df	83 f8 10	 cmp	 eax, 16			; 00000010H
  000e2	72 07		 jb	 SHORT $LN217@insert
  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	89 45 fc	 mov	 DWORD PTR tv774[ebp], eax
  000e9	eb 03		 jmp	 SHORT $LN218@insert
$LN217@insert:
  000eb	89 75 fc	 mov	 DWORD PTR tv774[ebp], esi
$LN218@insert:
  000ee	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  000f4	2b c1		 sub	 eax, ecx
  000f6	74 1a		 je	 SHORT $LN224@insert
  000f8	50		 push	 eax
  000f9	8b 45 0c	 mov	 eax, DWORD PTR tv775[ebp]
  000fc	03 c1		 add	 eax, ecx
  000fe	50		 push	 eax
  000ff	8b 45 fc	 mov	 eax, DWORD PTR tv774[ebp]
  00102	03 c1		 add	 eax, ecx
  00104	03 c2		 add	 eax, edx
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 _memmove
  0010c	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0010f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN224@insert:

; 1262 : 				this->_Myptr() + _Off,
; 1263 : 				this->_Mysize() - _Off);	// empty out hole
; 1264 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

  00112	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00116	72 04		 jb	 SHORT $LN235@insert
  00118	8b 16		 mov	 edx, DWORD PTR [esi]
  0011a	eb 02		 jmp	 SHORT $LN236@insert
$LN235@insert:
  0011c	8b d6		 mov	 edx, esi
$LN236@insert:
  0011e	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00121	85 c0		 test	 eax, eax
  00123	74 0e		 je	 SHORT $LN242@insert
  00125	50		 push	 eax
  00126	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00129	53		 push	 ebx
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _memcpy
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN242@insert:

; 1265 : 			_Eos(_Num);

  00133	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00137	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0013a	72 11		 jb	 SHORT $LN253@insert
  0013c	8b 06		 mov	 eax, DWORD PTR [esi]
  0013e	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1266 : 			}
; 1267 : 		return (*this);

  00142	8b c6		 mov	 eax, esi
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx

; 1268 : 		}

  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 0c 00	 ret	 12			; 0000000cH

; 1265 : 			_Eos(_Num);

$LN253@insert:
  0014d	8b c6		 mov	 eax, esi
  0014f	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN258@insert:

; 1266 : 			}
; 1267 : 		return (*this);

  00153	5f		 pop	 edi
  00154	8b c6		 mov	 eax, esi
  00156	5e		 pop	 esi
  00157	5b		 pop	 ebx

; 1268 : 		}

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 0c 00	 ret	 12			; 0000000cH
$LN264@insert:

; 1254 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1255 : 		_Check_offset(_Off);

  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00163	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN268@insert:
$LN266@insert:

; 1257 : 			_Xlen();	// result too long

  00168	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0016d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN269@insert:
$LN267@insert:

; 1259 : 		if (0 < _Count && _Grow(_Num))

  00172	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00177	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN270@insert:
$LN261@insert:
  0017c	cc		 int	 3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z
_TEXT	SEGMENT
tv860 = 8						; size = 4
tv857 = 8						; size = 4
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
tv849 = 16						; size = 4
__Roff$ = 16						; size = 4
tv862 = 20						; size = 4
__Count$ = 20						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1223 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 1224 : 		_Check_offset(_Off);

  00008	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000b	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  0000e	0f 82 55 01 00
	00		 jb	 $LN285@insert

; 1225 : 		_Right._Check_offset(_Roff);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00017	8b 55 10	 mov	 edx, DWORD PTR __Roff$[ebp]
  0001a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0001d	3b c2		 cmp	 eax, edx
  0001f	0f 82 4e 01 00
	00		 jb	 $LN287@insert

; 1226 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00025	8b 7d 14	 mov	 edi, DWORD PTR __Count$[ebp]
  00028	2b c2		 sub	 eax, edx
  0002a	3b f8		 cmp	 edi, eax
  0002c	0f 47 f8	 cmova	 edi, eax

; 1227 : 		if (npos - this->_Mysize() <= _Count)

  0002f	8b c1		 mov	 eax, ecx
  00031	f7 d0		 not	 eax
  00033	3b c7		 cmp	 eax, edi
  00035	0f 86 42 01 00
	00		 jbe	 $LN288@insert

; 1229 : 
; 1230 : 		const size_type _Num = this->_Mysize() + _Count;

  0003b	8d 1c 39	 lea	 ebx, DWORD PTR [ecx+edi]

; 1231 : 		if (0 < _Count && _Grow(_Num))

  0003e	85 ff		 test	 edi, edi
  00040	0f 84 1a 01 00
	00		 je	 $LN279@insert
  00046	83 fb fe	 cmp	 ebx, -2			; fffffffeH
  00049	0f 87 38 01 00
	00		 ja	 $LN289@insert
  0004f	39 5e 14	 cmp	 DWORD PTR [esi+20], ebx
  00052	73 20		 jae	 SHORT $LN75@insert
  00054	51		 push	 ecx
  00055	53		 push	 ebx
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0005d	85 db		 test	 ebx, ebx
  0005f	0f 84 fb 00 00
	00		 je	 $LN279@insert
$LN283@insert:

; 1232 : 			{	// make room and insert new stuff
; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

  00065	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00068	83 f8 10	 cmp	 eax, 16			; 00000010H
  0006b	72 2d		 jb	 SHORT $LN178@insert
  0006d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0006f	89 4d 14	 mov	 DWORD PTR tv862[ebp], ecx
  00072	eb 29		 jmp	 SHORT $LN179@insert

; 1231 : 		if (0 < _Count && _Grow(_Num))

$LN75@insert:
  00074	85 db		 test	 ebx, ebx
  00076	75 ed		 jne	 SHORT $LN283@insert
  00078	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  0007b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0007f	72 0d		 jb	 SHORT $LN152@insert
  00081	8b 06		 mov	 eax, DWORD PTR [esi]
  00083	5f		 pop	 edi
  00084	88 18		 mov	 BYTE PTR [eax], bl

; 1244 : 			}
; 1245 : 		return (*this);

  00086	8b c6		 mov	 eax, esi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx

; 1246 : 		}

  0008a	5d		 pop	 ebp
  0008b	c2 10 00	 ret	 16			; 00000010H

; 1231 : 		if (0 < _Count && _Grow(_Num))

$LN152@insert:
  0008e	8b c6		 mov	 eax, esi
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1246 : 		}

  00096	5d		 pop	 ebp
  00097	c2 10 00	 ret	 16			; 00000010H

; 1232 : 			{	// make room and insert new stuff
; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

$LN178@insert:
  0009a	89 75 14	 mov	 DWORD PTR tv862[ebp], esi
$LN179@insert:
  0009d	83 f8 10	 cmp	 eax, 16			; 00000010H
  000a0	72 04		 jb	 SHORT $LN192@insert
  000a2	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000a4	eb 02		 jmp	 SHORT $LN193@insert
$LN192@insert:
  000a6	8b ce		 mov	 ecx, esi
$LN193@insert:
  000a8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000ab	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000ae	2b c2		 sub	 eax, edx
  000b0	74 18		 je	 SHORT $LN199@insert
  000b2	50		 push	 eax
  000b3	8b 45 14	 mov	 eax, DWORD PTR tv862[ebp]
  000b6	03 c2		 add	 eax, edx
  000b8	50		 push	 eax
  000b9	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  000bc	03 c7		 add	 eax, edi
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _memmove
  000c4	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN199@insert:

; 1234 : 				this->_Myptr() + _Off,
; 1235 : 				this->_Mysize() - _Off);	// empty out hole
; 1236 : 			if (this == &_Right)

  000ca	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  000cd	3b f0		 cmp	 esi, eax
  000cf	75 42		 jne	 SHORT $LN4@insert

; 1237 : 				_Traits::move(this->_Myptr() + _Off,

  000d1	8b 45 10	 mov	 eax, DWORD PTR __Roff$[ebp]
  000d4	3b d0		 cmp	 edx, eax
  000d6	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  000d9	0f 43 c8	 cmovae	 ecx, eax
  000dc	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000df	89 4d 10	 mov	 DWORD PTR tv849[ebp], ecx
  000e2	83 f8 10	 cmp	 eax, 16			; 00000010H
  000e5	72 07		 jb	 SHORT $LN210@insert
  000e7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000e9	89 4d 08	 mov	 DWORD PTR tv860[ebp], ecx
  000ec	eb 03		 jmp	 SHORT $LN211@insert
$LN210@insert:
  000ee	89 75 08	 mov	 DWORD PTR tv860[ebp], esi
$LN211@insert:
  000f1	83 f8 10	 cmp	 eax, 16			; 00000010H
  000f4	72 04		 jb	 SHORT $LN224@insert
  000f6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000f8	eb 02		 jmp	 SHORT $LN225@insert
$LN224@insert:
  000fa	8b ce		 mov	 ecx, esi
$LN225@insert:
  000fc	85 ff		 test	 edi, edi
  000fe	74 42		 je	 SHORT $LN263@insert
  00100	8b 45 10	 mov	 eax, DWORD PTR tv849[ebp]
  00103	03 45 08	 add	 eax, DWORD PTR tv860[ebp]
  00106	57		 push	 edi
  00107	50		 push	 eax
  00108	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 _memmove

; 1238 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1239 : 						_Count);	// substring
; 1240 : 			else

  00111	eb 2c		 jmp	 SHORT $LN284@insert
$LN4@insert:

; 1241 : 				_Traits::copy(this->_Myptr() + _Off,

  00113	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00117	72 02		 jb	 SHORT $LN242@insert
  00119	8b 00		 mov	 eax, DWORD PTR [eax]
$LN242@insert:
  0011b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0011f	72 07		 jb	 SHORT $LN256@insert
  00121	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00123	89 4d 08	 mov	 DWORD PTR tv857[ebp], ecx
  00126	eb 03		 jmp	 SHORT $LN257@insert
$LN256@insert:
  00128	89 75 08	 mov	 DWORD PTR tv857[ebp], esi
$LN257@insert:
  0012b	85 ff		 test	 edi, edi
  0012d	74 13		 je	 SHORT $LN263@insert
  0012f	03 45 10	 add	 eax, DWORD PTR __Roff$[ebp]
  00132	57		 push	 edi
  00133	50		 push	 eax
  00134	8b 45 08	 mov	 eax, DWORD PTR tv857[ebp]
  00137	03 c2		 add	 eax, edx
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 _memcpy
$LN284@insert:
  0013f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN263@insert:

; 1242 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1243 : 			_Eos(_Num);

  00142	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00146	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00149	72 0f		 jb	 SHORT $LN274@insert
  0014b	8b 06		 mov	 eax, DWORD PTR [esi]
  0014d	5f		 pop	 edi
  0014e	c6 04 18 00	 mov	 BYTE PTR [eax+ebx], 0

; 1244 : 			}
; 1245 : 		return (*this);

  00152	8b c6		 mov	 eax, esi
  00154	5e		 pop	 esi
  00155	5b		 pop	 ebx

; 1246 : 		}

  00156	5d		 pop	 ebp
  00157	c2 10 00	 ret	 16			; 00000010H

; 1242 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1243 : 			_Eos(_Num);

$LN274@insert:
  0015a	8b c6		 mov	 eax, esi
  0015c	c6 04 18 00	 mov	 BYTE PTR [eax+ebx], 0
$LN279@insert:

; 1244 : 			}
; 1245 : 		return (*this);

  00160	5f		 pop	 edi
  00161	8b c6		 mov	 eax, esi
  00163	5e		 pop	 esi
  00164	5b		 pop	 ebx

; 1246 : 		}

  00165	5d		 pop	 ebp
  00166	c2 10 00	 ret	 16			; 00000010H
$LN285@insert:

; 1224 : 		_Check_offset(_Off);

  00169	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0016e	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN290@insert:
$LN287@insert:

; 1225 : 		_Right._Check_offset(_Roff);

  00173	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00178	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN291@insert:
$LN288@insert:

; 1228 : 			_Xlen();	// result too long

  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00182	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN292@insert:
$LN289@insert:

; 1231 : 		if (0 < _Count && _Grow(_Num))

  00187	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0018c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN293@insert:
$LN281@insert:
  00191	cc		 int	 3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1217 : 		{	// insert _Right at _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1218 : 		return (insert(_Off, _Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 0c	 push	 DWORD PTR __Right$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  0000d	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1219 : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1186 : 		{	// assign _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1187 : 		if (_Count == npos)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	83 ff ff	 cmp	 edi, -1
  0000d	0f 84 9d 00 00
	00		 je	 $LN151@assign

; 1189 : 
; 1190 : 		if (_Grow(_Count))

  00013	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00016	0f 87 9e 00 00
	00		 ja	 $LN153@assign
  0001c	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0001f	73 21		 jae	 SHORT $LN10@assign
  00021	ff 76 10	 push	 DWORD PTR [esi+16]
  00024	57		 push	 edi
  00025	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0002a	85 ff		 test	 edi, edi
  0002c	74 7a		 je	 SHORT $LN146@assign
$LN150@assign:

; 1191 : 			{	// make room and assign new stuff
; 1192 : 			_Chassign(0, _Count, _Ch);

  0002e	83 ff 01	 cmp	 edi, 1
  00031	75 3d		 jne	 SHORT $LN95@assign
  00033	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00037	72 2e		 jb	 SHORT $LN108@assign
  00039	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003b	8a 45 0c	 mov	 al, BYTE PTR __Ch$[ebp]
  0003e	88 01		 mov	 BYTE PTR [ecx], al
  00040	eb 49		 jmp	 SHORT $LN96@assign

; 1189 : 
; 1190 : 		if (_Grow(_Count))

$LN10@assign:
  00042	85 ff		 test	 edi, edi
  00044	75 e8		 jne	 SHORT $LN150@assign
  00046	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0004a	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0004d	72 0d		 jb	 SHORT $LN87@assign
  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	5f		 pop	 edi
  00052	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1194 : 			}
; 1195 : 		return (*this);

  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi

; 1196 : 		}

  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8

; 1189 : 
; 1190 : 		if (_Grow(_Count))

$LN87@assign:
  0005c	8b c6		 mov	 eax, esi
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1196 : 		}

  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8

; 1191 : 			{	// make room and assign new stuff
; 1192 : 			_Chassign(0, _Count, _Ch);

$LN108@assign:
  00067	8a 45 0c	 mov	 al, BYTE PTR __Ch$[ebp]
  0006a	8b ce		 mov	 ecx, esi
  0006c	88 01		 mov	 BYTE PTR [ecx], al
  0006e	eb 1b		 jmp	 SHORT $LN96@assign
$LN95@assign:
  00070	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00074	72 04		 jb	 SHORT $LN125@assign
  00076	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00078	eb 02		 jmp	 SHORT $LN126@assign
$LN125@assign:
  0007a	8b ce		 mov	 ecx, esi
$LN126@assign:
  0007c	0f be 45 0c	 movsx	 eax, BYTE PTR __Ch$[ebp]
  00080	57		 push	 edi
  00081	50		 push	 eax
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _memset
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN96@assign:

; 1193 : 			_Eos(_Count);

  0008b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0008f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00092	72 0e		 jb	 SHORT $LN141@assign
  00094	8b 06		 mov	 eax, DWORD PTR [esi]
  00096	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1194 : 			}
; 1195 : 		return (*this);

  0009a	8b c6		 mov	 eax, esi
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi

; 1196 : 		}

  0009e	5d		 pop	 ebp
  0009f	c2 08 00	 ret	 8

; 1193 : 			_Eos(_Count);

$LN141@assign:
  000a2	8b c6		 mov	 eax, esi
  000a4	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN146@assign:

; 1194 : 			}
; 1195 : 		return (*this);

  000a8	5f		 pop	 edi
  000a9	8b c6		 mov	 eax, esi
  000ab	5e		 pop	 esi

; 1196 : 		}

  000ac	5d		 pop	 ebp
  000ad	c2 08 00	 ret	 8
$LN151@assign:

; 1188 : 			_Xlen();	// result too long

  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000b5	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN154@assign:
$LN153@assign:

; 1189 : 
; 1190 : 		if (_Grow(_Count))

  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000bf	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN155@assign:
$LN148@assign:
  000c4	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN5@assign
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00015	5e		 pop	 esi

; 1183 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

$LN5@assign:
  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@assign:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL7@assign
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00031	5e		 pop	 esi

; 1183 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1166 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1167 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 57		 je	 SHORT $LN2@assign
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN20@assign
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN21@assign
$LN20@assign:
  0001a	8b c6		 mov	 eax, esi
$LN21@assign:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 45		 jb	 SHORT $LN2@assign
  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN34@assign
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN35@assign
$LN34@assign:
  00029	8b d6		 mov	 edx, esi
$LN35@assign:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	03 c2		 add	 eax, edx
  00030	3b c3		 cmp	 eax, ebx
  00032	76 31		 jbe	 SHORT $LN2@assign

; 1168 : 			return (assign(*this,

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 16		 jb	 SHORT $LN57@assign
  00039	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	8b ce		 mov	 ecx, esi
  00040	2b d8		 sub	 ebx, eax
  00042	53		 push	 ebx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 1177 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8

; 1168 : 			return (assign(*this,

$LN57@assign:
  0004f	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00052	8b c6		 mov	 eax, esi
  00054	8b ce		 mov	 ecx, esi
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 1177 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN2@assign:
  00065	57		 push	 edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  00066	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00069	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0006c	77 7d		 ja	 SHORT $LN187@assign
  0006e	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00071	73 19		 jae	 SHORT $LN63@assign
  00073	ff 76 10	 push	 DWORD PTR [esi+16]
  00076	8b ce		 mov	 ecx, esi
  00078	57		 push	 edi
  00079	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0007e	85 ff		 test	 edi, edi
  00080	74 60		 je	 SHORT $LN181@assign
$LN186@assign:

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  00082	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00086	72 2b		 jb	 SHORT $LN158@assign
  00088	8b 06		 mov	 eax, DWORD PTR [esi]
  0008a	eb 29		 jmp	 SHORT $LN159@assign

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN63@assign:
  0008c	85 ff		 test	 edi, edi
  0008e	75 f2		 jne	 SHORT $LN186@assign
  00090	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00094	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00097	72 0e		 jb	 SHORT $LN140@assign
  00099	8b 06		 mov	 eax, DWORD PTR [esi]
  0009b	5f		 pop	 edi
  0009c	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1175 : 			}
; 1176 : 		return (*this);

  0009f	8b c6		 mov	 eax, esi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx

; 1177 : 		}

  000a3	5d		 pop	 ebp
  000a4	c2 08 00	 ret	 8

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

$LN140@assign:
  000a7	8b c6		 mov	 eax, esi
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1177 : 		}

  000af	5d		 pop	 ebp
  000b0	c2 08 00	 ret	 8

; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

$LN158@assign:
  000b3	8b c6		 mov	 eax, esi
$LN159@assign:
  000b5	85 ff		 test	 edi, edi
  000b7	74 0b		 je	 SHORT $LN165@assign
  000b9	57		 push	 edi
  000ba	53		 push	 ebx
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN165@assign:

; 1174 : 			_Eos(_Count);

  000c4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000c8	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000cb	72 0f		 jb	 SHORT $LN176@assign
  000cd	8b 06		 mov	 eax, DWORD PTR [esi]
  000cf	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1175 : 			}
; 1176 : 		return (*this);

  000d3	8b c6		 mov	 eax, esi
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx

; 1177 : 		}

  000d8	5d		 pop	 ebp
  000d9	c2 08 00	 ret	 8

; 1174 : 			_Eos(_Count);

$LN176@assign:
  000dc	8b c6		 mov	 eax, esi
  000de	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN181@assign:

; 1175 : 			}
; 1176 : 		return (*this);

  000e2	5f		 pop	 edi
  000e3	8b c6		 mov	 eax, esi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 1177 : 		}

  000e7	5d		 pop	 ebp
  000e8	c2 08 00	 ret	 8
$LN187@assign:

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f0	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN189@assign:
$LN184@assign:
  000f5	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1150 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 e9 00 00
	00		 jb	 $LN208@assign

; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

  00019	8b 7d 10	 mov	 edi, DWORD PTR __Count$[ebp]
  0001c	2b c1		 sub	 eax, ecx
  0001e	3b f8		 cmp	 edi, eax
  00020	0f 47 f8	 cmova	 edi, eax

; 1152 : 
; 1153 : 		if (this == &_Right)

  00023	3b f3		 cmp	 esi, ebx
  00025	75 47		 jne	 SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  00027	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0002a	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  0002d	0f 82 d9 00 00
	00		 jb	 $LN210@assign
  00033	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00036	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0003a	72 19		 jb	 SHORT $LN63@assign
  0003c	8b 16		 mov	 edx, DWORD PTR [esi]
  0003e	51		 push	 ecx
  0003f	6a 00		 push	 0
  00041	8b ce		 mov	 ecx, esi
  00043	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
  00047	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0004c	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  0004d	8b c6		 mov	 eax, esi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx

; 1162 : 		}

  00051	5d		 pop	 ebp
  00052	c2 0c 00	 ret	 12			; 0000000cH

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

$LN63@assign:
  00055	8b d6		 mov	 edx, esi
  00057	51		 push	 ecx
  00058	6a 00		 push	 0
  0005a	8b ce		 mov	 ecx, esi
  0005c	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
  00060	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00065	5f		 pop	 edi

; 1160 : 			}
; 1161 : 		return (*this);

  00066	8b c6		 mov	 eax, esi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 1162 : 		}

  0006a	5d		 pop	 ebp
  0006b	c2 0c 00	 ret	 12			; 0000000cH
$LN2@assign:

; 1155 : 		else if (_Grow(_Count))

  0006e	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00071	0f 87 9f 00 00
	00		 ja	 $LN211@assign
  00077	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0007a	73 24		 jae	 SHORT $LN72@assign
  0007c	ff 76 10	 push	 DWORD PTR [esi+16]
  0007f	8b ce		 mov	 ecx, esi
  00081	57		 push	 edi
  00082	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00087	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0008a	85 ff		 test	 edi, edi
  0008c	74 6b		 je	 SHORT $LN203@assign
$LN207@assign:

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

  0008e	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00092	72 02		 jb	 SHORT $LN166@assign
  00094	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN166@assign:
  00096	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0009a	72 2b		 jb	 SHORT $LN180@assign
  0009c	8b 16		 mov	 edx, DWORD PTR [esi]
  0009e	eb 29		 jmp	 SHORT $LN181@assign

; 1155 : 		else if (_Grow(_Count))

$LN72@assign:
  000a0	85 ff		 test	 edi, edi
  000a2	75 ea		 jne	 SHORT $LN207@assign
  000a4	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000a8	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ab	72 0e		 jb	 SHORT $LN149@assign
  000ad	8b 06		 mov	 eax, DWORD PTR [esi]
  000af	5f		 pop	 edi
  000b0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1160 : 			}
; 1161 : 		return (*this);

  000b3	8b c6		 mov	 eax, esi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx

; 1162 : 		}

  000b7	5d		 pop	 ebp
  000b8	c2 0c 00	 ret	 12			; 0000000cH

; 1155 : 		else if (_Grow(_Count))

$LN149@assign:
  000bb	8b c6		 mov	 eax, esi
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1162 : 		}

  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH

; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),

$LN180@assign:
  000c7	8b d6		 mov	 edx, esi
$LN181@assign:
  000c9	85 ff		 test	 edi, edi
  000cb	74 0e		 je	 SHORT $LN187@assign
  000cd	57		 push	 edi
  000ce	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  000d1	50		 push	 eax
  000d2	52		 push	 edx
  000d3	e8 00 00 00 00	 call	 _memcpy
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN187@assign:

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

  000db	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000df	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000e2	72 0f		 jb	 SHORT $LN198@assign
  000e4	8b 06		 mov	 eax, DWORD PTR [esi]
  000e6	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1160 : 			}
; 1161 : 		return (*this);

  000ea	8b c6		 mov	 eax, esi
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx

; 1162 : 		}

  000ef	5d		 pop	 ebp
  000f0	c2 0c 00	 ret	 12			; 0000000cH

; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);

$LN198@assign:
  000f3	8b c6		 mov	 eax, esi
  000f5	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN203@assign:

; 1160 : 			}
; 1161 : 		return (*this);

  000f9	5f		 pop	 edi
  000fa	8b c6		 mov	 eax, esi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx

; 1162 : 		}

  000fe	5d		 pop	 ebp
  000ff	c2 0c 00	 ret	 12			; 0000000cH
$LN208@assign:

; 1150 : 		_Right._Check_offset(_Roff);

  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00107	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN212@assign:
$LN210@assign:

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

  0010c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00111	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN213@assign:
$LN211@assign:

; 1155 : 		else if (_Grow(_Count))

  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN214@assign:
$LN205@assign:
  00120	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1143 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1144 : 		return (assign(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1111 : 		{	// append _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1112 : 		if (npos - this->_Mysize() <= _Count)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0000e	8b c1		 mov	 eax, ecx
  00010	f7 d0		 not	 eax
  00012	3b c3		 cmp	 eax, ebx
  00014	76 7a		 jbe	 SHORT $LN141@append

; 1114 : 
; 1115 : 		const size_type _Num = this->_Mysize() + _Count;

  00016	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]

; 1116 : 		if (0 < _Count && _Grow(_Num))

  00019	85 db		 test	 ebx, ebx
  0001b	74 6a		 je	 SHORT $LN136@append
  0001d	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00020	77 78		 ja	 SHORT $LN143@append
  00022	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00025	73 33		 jae	 SHORT $LN28@append
  00027	51		 push	 ecx
  00028	57		 push	 edi
  00029	8b ce		 mov	 ecx, esi
  0002b	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00030	85 ff		 test	 edi, edi
  00032	74 53		 je	 SHORT $LN136@append
$LN140@append:

; 1117 : 			{	// make room and append new stuff using assign
; 1118 : 			_Chassign(this->_Mysize(), _Count, _Ch);

  00034	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  00037	8b ce		 mov	 ecx, esi
  00039	53		 push	 ebx
  0003a	ff 76 10	 push	 DWORD PTR [esi+16]
  0003d	e8 00 00 00 00	 call	 ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 1119 : 			_Eos(_Num);

  00042	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00046	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00049	72 36		 jb	 SHORT $LN131@append
  0004b	8b 06		 mov	 eax, DWORD PTR [esi]
  0004d	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1120 : 			}
; 1121 : 		return (*this);

  00051	8b c6		 mov	 eax, esi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx

; 1122 : 		}

  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8

; 1116 : 		if (0 < _Count && _Grow(_Num))

$LN28@append:
  0005a	85 ff		 test	 edi, edi
  0005c	75 d6		 jne	 SHORT $LN140@append
  0005e	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00061	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00065	72 0e		 jb	 SHORT $LN105@append
  00067	8b 06		 mov	 eax, DWORD PTR [esi]
  00069	5f		 pop	 edi
  0006a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1120 : 			}
; 1121 : 		return (*this);

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx

; 1122 : 		}

  00071	5d		 pop	 ebp
  00072	c2 08 00	 ret	 8

; 1116 : 		if (0 < _Count && _Grow(_Num))

$LN105@append:
  00075	8b c6		 mov	 eax, esi
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1122 : 		}

  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8

; 1119 : 			_Eos(_Num);

$LN131@append:
  00081	8b c6		 mov	 eax, esi
  00083	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN136@append:

; 1120 : 			}
; 1121 : 		return (*this);

  00087	5f		 pop	 edi
  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx

; 1122 : 		}

  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
$LN141@append:

; 1113 : 			_Xlen();	// result too long

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00095	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN144@append:
$LN143@append:

; 1116 : 		if (0 < _Count && _Grow(_Num))

  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0009f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN145@append:
$LN138@append:
  000a4	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1105 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN5@append
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00015	5e		 pop	 esi

; 1108 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

$LN5@append:
  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@append:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL7@append
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00031	5e		 pop	 esi

; 1108 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1087 : 		{	// append [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1088 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1089 : 		if (_Inside(_Ptr))

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 db		 test	 ebx, ebx
  0000c	74 57		 je	 SHORT $LN2@append
  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN21@append
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	eb 02		 jmp	 SHORT $LN22@append
$LN21@append:
  0001a	8b c6		 mov	 eax, esi
$LN22@append:
  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 45		 jb	 SHORT $LN2@append
  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN35@append
  00025	8b 16		 mov	 edx, DWORD PTR [esi]
  00027	eb 02		 jmp	 SHORT $LN36@append
$LN35@append:
  00029	8b d6		 mov	 edx, esi
$LN36@append:
  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	03 c2		 add	 eax, edx
  00030	3b c3		 cmp	 eax, ebx
  00032	76 31		 jbe	 SHORT $LN2@append

; 1090 : 			return (append(*this,

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 16		 jb	 SHORT $LN58@append
  00039	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	8b ce		 mov	 ecx, esi
  00040	2b d8		 sub	 ebx, eax
  00042	53		 push	 ebx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 1102 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8

; 1090 : 			return (append(*this,

$LN58@append:
  0004f	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00052	8b c6		 mov	 eax, esi
  00054	8b ce		 mov	 ecx, esi
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 1102 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN2@append:

; 1091 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1092 : 		if (npos - this->_Mysize() <= _Count)

  00065	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00068	8b c2		 mov	 eax, edx
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0006d	f7 d0		 not	 eax
  0006f	3b c1		 cmp	 eax, ecx
  00071	0f 86 98 00 00
	00		 jbe	 $LN217@append

; 1094 : 
; 1095 : 		const size_type _Num = this->_Mysize() + _Count;

  00077	57		 push	 edi
  00078	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 1096 : 		if (0 < _Count && _Grow(_Num))

  0007b	85 c9		 test	 ecx, ecx
  0007d	0f 84 83 00 00
	00		 je	 $LN211@append
  00083	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00086	0f 87 8d 00 00
	00		 ja	 $LN219@append
  0008c	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0008f	73 1a		 jae	 SHORT $LN85@append
  00091	52		 push	 edx
  00092	57		 push	 edi
  00093	8b ce		 mov	 ecx, esi
  00095	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0009d	85 ff		 test	 edi, edi
  0009f	74 65		 je	 SHORT $LN211@append
$LN216@append:

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

  000a1	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000a5	72 2b		 jb	 SHORT $LN179@append
  000a7	8b 16		 mov	 edx, DWORD PTR [esi]
  000a9	eb 29		 jmp	 SHORT $LN180@append

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN85@append:
  000ab	85 ff		 test	 edi, edi
  000ad	75 f2		 jne	 SHORT $LN216@append
  000af	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000b2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b6	72 0e		 jb	 SHORT $LN162@append
  000b8	8b 06		 mov	 eax, DWORD PTR [esi]
  000ba	5f		 pop	 edi
  000bb	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1100 : 			}
; 1101 : 		return (*this);

  000be	8b c6		 mov	 eax, esi
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx

; 1102 : 		}

  000c2	5d		 pop	 ebp
  000c3	c2 08 00	 ret	 8

; 1096 : 		if (0 < _Count && _Grow(_Num))

$LN162@append:
  000c6	8b c6		 mov	 eax, esi
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1102 : 		}

  000ce	5d		 pop	 ebp
  000cf	c2 08 00	 ret	 8

; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

$LN179@append:
  000d2	8b d6		 mov	 edx, esi
$LN180@append:
  000d4	85 c9		 test	 ecx, ecx
  000d6	74 10		 je	 SHORT $LN195@append
  000d8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000db	51		 push	 ecx
  000dc	03 c2		 add	 eax, edx
  000de	53		 push	 ebx
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _memcpy
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN195@append:

; 1099 : 			_Eos(_Num);

  000e8	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000ec	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000ef	72 0f		 jb	 SHORT $LN206@append
  000f1	8b 06		 mov	 eax, DWORD PTR [esi]
  000f3	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1100 : 			}
; 1101 : 		return (*this);

  000f7	8b c6		 mov	 eax, esi
  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx

; 1102 : 		}

  000fc	5d		 pop	 ebp
  000fd	c2 08 00	 ret	 8

; 1099 : 			_Eos(_Num);

$LN206@append:
  00100	8b c6		 mov	 eax, esi
  00102	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN211@append:

; 1100 : 			}
; 1101 : 		return (*this);

  00106	5f		 pop	 edi
  00107	8b c6		 mov	 eax, esi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx

; 1102 : 		}

  0010b	5d		 pop	 ebp
  0010c	c2 08 00	 ret	 8
$LN217@append:

; 1093 : 			_Xlen();	// result too long

  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00114	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN220@append:
$LN219@append:

; 1096 : 		if (0 < _Count && _Grow(_Num))

  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN221@append:
$LN214@append:
  00123	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1071 : 		_Right._Check_offset(_Roff);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000d	57		 push	 edi
  0000e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00011	3b c1		 cmp	 eax, ecx
  00013	0f 82 c0 00 00
	00		 jb	 $LN201@append

; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

  00019	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0001c	2b c1		 sub	 eax, ecx
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00021	3b c8		 cmp	 ecx, eax
  00023	0f 47 c8	 cmova	 ecx, eax
  00026	8b c2		 mov	 eax, edx
  00028	f7 d0		 not	 eax
  0002a	89 4d 10	 mov	 DWORD PTR __Count$[ebp], ecx
  0002d	3b c1		 cmp	 eax, ecx
  0002f	0f 86 ae 00 00
	00		 jbe	 $LN203@append

; 1075 : 
; 1076 : 		const size_type _Num = this->_Mysize() + _Count;

  00035	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 1077 : 		if (0 < _Count && _Grow(_Num))

  00038	85 c9		 test	 ecx, ecx
  0003a	0f 84 90 00 00
	00		 je	 $LN196@append
  00040	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00043	0f 87 a4 00 00
	00		 ja	 $LN204@append
  00049	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  0004c	73 22		 jae	 SHORT $LN56@append
  0004e	52		 push	 edx
  0004f	57		 push	 edi
  00050	8b ce		 mov	 ecx, esi
  00052	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00057	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005a	85 ff		 test	 edi, edi
  0005c	74 72		 je	 SHORT $LN196@append
$LN200@append:

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

  0005e	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00062	72 02		 jb	 SHORT $LN150@append
  00064	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN150@append:
  00066	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0006a	72 2b		 jb	 SHORT $LN164@append
  0006c	8b 16		 mov	 edx, DWORD PTR [esi]
  0006e	eb 29		 jmp	 SHORT $LN165@append

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN56@append:
  00070	85 ff		 test	 edi, edi
  00072	75 ea		 jne	 SHORT $LN200@append
  00074	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00077	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0007b	72 0e		 jb	 SHORT $LN133@append
  0007d	8b 06		 mov	 eax, DWORD PTR [esi]
  0007f	5f		 pop	 edi
  00080	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1082 : 			}
; 1083 : 		return (*this);

  00083	8b c6		 mov	 eax, esi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx

; 1084 : 		}

  00087	5d		 pop	 ebp
  00088	c2 0c 00	 ret	 12			; 0000000cH

; 1077 : 		if (0 < _Count && _Grow(_Num))

$LN133@append:
  0008b	8b c6		 mov	 eax, esi
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1084 : 		}

  00093	5d		 pop	 ebp
  00094	c2 0c 00	 ret	 12			; 0000000cH

; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

$LN164@append:
  00097	8b d6		 mov	 edx, esi
$LN165@append:
  00099	85 c9		 test	 ecx, ecx
  0009b	74 15		 je	 SHORT $LN180@append
  0009d	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  000a0	03 c3		 add	 eax, ebx
  000a2	51		 push	 ecx
  000a3	50		 push	 eax
  000a4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000a7	03 c2		 add	 eax, edx
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _memcpy
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN180@append:

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

  000b2	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b6	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  000b9	72 0f		 jb	 SHORT $LN191@append
  000bb	8b 06		 mov	 eax, DWORD PTR [esi]
  000bd	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 1082 : 			}
; 1083 : 		return (*this);

  000c1	8b c6		 mov	 eax, esi
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx

; 1084 : 		}

  000c6	5d		 pop	 ebp
  000c7	c2 0c 00	 ret	 12			; 0000000cH

; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);

$LN191@append:
  000ca	8b c6		 mov	 eax, esi
  000cc	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN196@append:

; 1082 : 			}
; 1083 : 		return (*this);

  000d0	5f		 pop	 edi
  000d1	8b c6		 mov	 eax, esi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx

; 1084 : 		}

  000d5	5d		 pop	 ebp
  000d6	c2 0c 00	 ret	 12			; 0000000cH
$LN201@append:

; 1071 : 		_Right._Check_offset(_Roff);

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000de	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN205@append:
$LN203@append:

; 1074 : 			_Xlen();	// result too long

  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000e8	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN206@append:
$LN204@append:

; 1077 : 		if (0 < _Count && _Grow(_Num))

  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f2	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN207@append:
$LN198@append:
  000f7	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1064 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1065 : 		return (append(_Right, 0, npos));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1066 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1059 : 		{	// append 1 * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1060 : 		return (append((size_type)1, _Ch));

  00003	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00006	6a 01		 push	 1
  00008	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1061 : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1054 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1055 : 		return (append(_Ptr));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN7@operator
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00015	5e		 pop	 esi

; 1056 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1055 : 		return (append(_Ptr));

$LN7@operator:
  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL9@operator:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL9@operator
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00031	5e		 pop	 esi

; 1056 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1049 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1050 : 		return (append(_Right));

  00003	6a ff		 push	 -1
  00005	6a 00		 push	 0
  00007	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1051 : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1039 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1040 : 		return (assign(_Ptr));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN7@operator
  0000c	33 d2		 xor	 edx, edx
  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00015	5e		 pop	 esi

; 1041 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4

; 1040 : 		return (assign(_Ptr));

$LN7@operator:
  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL9@operator:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL9@operator
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00031	5e		 pop	 esi

; 1041 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1023 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1024 : 		if (this != &_Right)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b f0		 cmp	 esi, eax
  0000b	74 0a		 je	 SHORT $LN132@operator

; 1025 : 			{	// different, assign it
; 1026 : 			if (this->_Getal() != _Right._Getal()
; 1027 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1028 : 				{	// change allocator before copying
; 1029 : 				_Tidy(true);
; 1030 : 				this->_Copy_alloc(_Right._Getal());
; 1031 : 				}
; 1032 : 
; 1033 : 			assign(_Right);

  0000d	6a ff		 push	 -1
  0000f	6a 00		 push	 0
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN132@operator:

; 1034 : 			}
; 1035 : 		return (*this);

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi

; 1036 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1017 : 		_Tidy(true);

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 10	 cmp	 eax, 16			; 00000010H
  00009	72 09		 jb	 SHORT $LN6@basic_stri
  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN6@basic_stri:
  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  0001b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	72 07		 jb	 SHORT $LN94@basic_stri
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	5e		 pop	 esi
  0002b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1018 : 		}

  0002e	c3		 ret	 0

; 1017 : 		_Tidy(true);

$LN94@basic_stri:
  0002f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00032	5e		 pop	 esi

; 1018 : 		}

  00033	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 961  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0000e	73 15		 jae	 SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	83 c0 01	 add	 eax, 1
  00016	74 1b		 je	 SHORT $LN3@Assign_rv
  00018	50		 push	 eax
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 964  : 				_Right._Mysize() + 1);
; 965  : 		else

  00023	eb 0e		 jmp	 SHORT $LN3@Assign_rv
$LN2@Assign_rv:

; 966  : 			{	// copy pointer
; 967  : 			this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Right._Bx()._Ptr);

  00025	85 ff		 test	 edi, edi
  00027	74 04		 je	 SHORT $LN84@Assign_rv
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	89 07		 mov	 DWORD PTR [edi], eax
$LN84@Assign_rv:

; 968  : 			_Right._Bx()._Ptr = pointer();

  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

  00033	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00036	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

  00039	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0003c	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 972  : 		_Right._Tidy();

  0003f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00046	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0004a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00051	72 0b		 jb	 SHORT $LN227@Assign_rv
  00053	8b 06		 mov	 eax, DWORD PTR [esi]
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	c6 00 00	 mov	 BYTE PTR [eax], 0

; 973  : 		}

  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4

; 972  : 		_Right._Tidy();

$LN227@Assign_rv:
  0005e	5f		 pop	 edi
  0005f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00062	5e		 pop	 esi

; 973  : 		}

  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 946  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 947  : 		if (this == &_Right)

  00025	3b 75 08	 cmp	 esi, DWORD PTR __Right$[ebp]
  00028	74 38		 je	 SHORT $LN275@assign

; 948  : 			;
; 949  : 		else if (get_allocator() != _Right.get_allocator()
; 950  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 951  : 			*this = _Right;
; 952  : 		else
; 953  : 			{	// not same, clear this and steal from _Right
; 954  : 			_Tidy(true);

  0002a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00030	72 09		 jb	 SHORT $LN177@assign
  00032	40		 inc	 eax
  00033	50		 push	 eax
  00034	ff 36		 push	 DWORD PTR [esi]
  00036	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN177@assign:
  0003b	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00042	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00046	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004d	72 04		 jb	 SHORT $LN265@assign
  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	eb 02		 jmp	 SHORT $LN266@assign
$LN265@assign:
  00053	8b c6		 mov	 eax, esi
$LN266@assign:

; 955  : 			_Assign_rv(_STD forward<_Myt>(_Right));

  00055	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00058	8b ce		 mov	 ecx, esi
  0005a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0005d	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN275@assign:

; 956  : 			}
; 957  : 		return (*this);

  00062	8b c6		 mov	 eax, esi

; 958  : 		}

  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5e		 pop	 esi
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 928  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 929  : 		if (this != &_Right)

  00025	3b 75 08	 cmp	 esi, DWORD PTR __Right$[ebp]
  00028	74 38		 je	 SHORT $LN294@operator

; 930  : 			{	// different, assign it
; 931  : 			_Tidy(true);

  0002a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00030	72 09		 jb	 SHORT $LN10@operator
  00032	40		 inc	 eax
  00033	50		 push	 eax
  00034	ff 36		 push	 DWORD PTR [esi]
  00036	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN10@operator:
  0003b	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00042	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00046	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0004d	72 04		 jb	 SHORT $LN98@operator
  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	eb 02		 jmp	 SHORT $LN99@operator
$LN98@operator:
  00053	8b c6		 mov	 eax, esi
$LN99@operator:

; 932  : 
; 933  : 			if (_Alty::propagate_on_container_move_assignment::value
; 934  : 				&& this->_Getal() != _Right._Getal())
; 935  : 				this->_Move_alloc(_Right._Getal());
; 936  : 
; 937  : 			if (this->_Getal() != _Right._Getal())
; 938  : 				assign(_Right.begin(), _Right.end());
; 939  : 			else
; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

  00055	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00058	8b ce		 mov	 ecx, esi
  0005a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0005d	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN294@operator:

; 941  : 			}
; 942  : 		return (*this);

  00062	8b c6		 mov	 eax, esi

; 943  : 		}

  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5e		 pop	 esi
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 911  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 912  : 		_Tidy();
; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00004	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00017	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001a	e8 00 00 00 00	 call	 ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 914  : 		}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 850  : 		{	// construct from _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 851  : 		_Tidy();
; 852  : 		assign(_Count, _Ch);

  00004	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  0000c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00013	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001a	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 853  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00017	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001a	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0001d	75 12		 jne	 SHORT $LN111@basic_stri
  0001f	33 d2		 xor	 edx, edx
  00021	52		 push	 edx
  00022	51		 push	 ecx
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 839  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);

$LN111@basic_stri:
  00031	8b d1		 mov	 edx, ecx
  00033	57		 push	 edi
  00034	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL113@basic_stri:
  00037	8a 02		 mov	 al, BYTE PTR [edx]
  00039	42		 inc	 edx
  0003a	84 c0		 test	 al, al
  0003c	75 f9		 jne	 SHORT $LL113@basic_stri
  0003e	2b d7		 sub	 edx, edi
  00040	5f		 pop	 edi
  00041	52		 push	 edx
  00042	51		 push	 ecx
  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 839  : 		}

  0004a	8b c6		 mov	 eax, esi
  0004c	5e		 pop	 esi
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 822  : 		{	// construct from [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 823  : 		_Tidy();
; 824  : 		assign(_Ptr, _Count);

  00004	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00013	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001a	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 825  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$ = 20						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 815  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 816  : 		_Tidy();
; 817  : 		assign(_Right, _Roff, _Count);

  00004	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 0c	 push	 DWORD PTR __Roff$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00016	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001d	c6 06 00	 mov	 BYTE PTR [esi], 0
  00020	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 818  : 		}

  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	5d		 pop	 ebp
  00029	c2 10 00	 ret	 16			; 00000010H
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 795  : 		_Tidy();

  00000	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 796  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00013	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 781  : 		_Tidy();
; 782  : 		assign(_Right, 0, npos);

  00006	6a ff		 push	 -1
  00008	6a 00		 push	 0
  0000a	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0000d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
  00014	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0001e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 783  : 		}

  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 321  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 316  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 301  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 296  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 739  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 740  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 735  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 730  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 725  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

  00000	8b c1		 mov	 eax, ecx

; 715  : 		}

  00002	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 708  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 703  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 698  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 693  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc, COMDAT
; _this$ = ecx

; 607  : 		_Pocma(_Getal(), _Al);
; 608  : 		}

  00000	c2 04 00	 ret	 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 602  : 		_Pocca(_Getal(), _Al);
; 603  : 		}

  00000	c2 04 00	 ret	 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 588  : 		: _Mypair(_Zero_then_variadic_args_t())

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 590  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 583  : 		return (_Get_data()._Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 584  : 		}

  00008	c3		 ret	 0

; 583  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 584  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 578  : 		return (_Get_data()._Myptr());

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 579  : 		}

  00008	c3		 ret	 0

; 578  : 		return (_Get_data()._Myptr());

$LN11@Myptr:
  00009	8b c1		 mov	 eax, ecx

; 579  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 534  : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

  00009	8b c1		 mov	 eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 499  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

  00000	83 c8 ff	 or	 eax, -1

; 1009 : 		}

  00003	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000d	72 19		 jb	 SHORT $LN7@deallocate
  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $LN16@deallocate
  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00016	3b c8		 cmp	 ecx, eax
  00018	73 20		 jae	 SHORT $LN18@deallocate
  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 1e		 jb	 SHORT $LN19@deallocate
  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 1e		 ja	 SHORT $LN20@deallocate
  00026	8b c1		 mov	 eax, ecx
$LN7@deallocate:
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 988  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN16@deallocate:

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

  00035	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN18@deallocate:
  0003a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN19@deallocate:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN20@deallocate:
  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN15@deallocate:
  00049	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 976  : 		return (_Mybase::allocate(_Count));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN6@allocate
$LN15@allocate:

; 977  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 976  : 		return (_Mybase::allocate(_Count));

$LN6@allocate:
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 23		 jb	 SHORT $LN8@allocate
  00015	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00018	3b c8		 cmp	 ecx, eax
  0001a	76 2b		 jbe	 SHORT $LN17@allocate
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	8b c8		 mov	 ecx, eax
  00024	83 c4 04	 add	 esp, 4
  00027	85 c9		 test	 ecx, ecx
  00029	74 21		 je	 SHORT $LN19@allocate
  0002b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002e	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00031	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 977  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4

; 976  : 		return (_Mybase::allocate(_Count));

$LN8@allocate:
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 c5		 jne	 SHORT $LN15@allocate
  00045	eb 0a		 jmp	 SHORT $LN20@allocate
$LN17@allocate:
  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN21@allocate:
$LN19@allocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN20@allocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@allocate:
$LN16@allocate:
  00056	cc		 int	 3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 963  : 		_Mybase::operator=(_STD move(_Right));
; 964  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 965  : 		}

  00002	c2 04 00	 ret	 4
??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 947  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 937  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::address, COMDAT
; _this$ = ecx

; 925  : 		{	// return address of mutable _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 926  : 		return (pointer_traits<pointer>::pointer_to(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 927  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

  00006	5d		 pop	 ebp
  00007	c2 08 00	 ret	 8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 875  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

  00000	83 c8 ff	 or	 eax, -1

; 870  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	83 c8 ff	 or	 eax, -1

; 750  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 726  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN4@allocate:
  0000e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00013	72 23		 jb	 SHORT $LN6@allocate
  00015	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  00018	3b c8		 cmp	 ecx, eax
  0001a	76 2b		 jbe	 SHORT $LN14@allocate
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	8b c8		 mov	 ecx, eax
  00024	83 c4 04	 add	 esp, 4
  00027	85 c9		 test	 ecx, ecx
  00029	74 21		 je	 SHORT $LN16@allocate
  0002b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002e	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00031	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 726  : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

$LN6@allocate:
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 c5		 jne	 SHORT $LN12@allocate
  00045	eb 0a		 jmp	 SHORT $LN17@allocate
$LN14@allocate:
  00047	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN18@allocate:
$LN16@allocate:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@allocate:
$LN17@allocate:
  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@allocate:
$LN13@allocate:
  00056	cc		 int	 3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0000a	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000d	72 19		 jb	 SHORT $LN5@deallocate
  0000f	a8 1f		 test	 al, 31			; 0000001fH
  00011	75 22		 jne	 SHORT $LN13@deallocate
  00013	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00016	3b c8		 cmp	 ecx, eax
  00018	73 20		 jae	 SHORT $LN15@deallocate
  0001a	2b c1		 sub	 eax, ecx
  0001c	83 f8 04	 cmp	 eax, 4
  0001f	72 1e		 jb	 SHORT $LN16@deallocate
  00021	83 f8 23	 cmp	 eax, 35			; 00000023H
  00024	77 1e		 ja	 SHORT $LN17@deallocate
  00026	8b c1		 mov	 eax, ecx
$LN5@deallocate:
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002e	83 c4 04	 add	 esp, 4

; 721  : 		}

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
$LN13@deallocate:

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00035	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
$LN15@deallocate:
  0003a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN16@deallocate:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN17@deallocate:
  00044	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN12@deallocate:
  00049	cc		 int	 3
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xatomic0.h
;	COMDAT ?_Init_atomic_counter@std@@YAXAAKK@Z
_TEXT	SEGMENT
__Counter$ = 8						; size = 4
__Value$ = 12						; size = 4
?_Init_atomic_counter@std@@YAXAAKK@Z PROC		; std::_Init_atomic_counter, COMDAT

; 62   : 	{	// non-atomically initialize counter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	_Counter = _Value;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Counter$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Value$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 64   : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?_Init_atomic_counter@std@@YAXAAKK@Z ENDP		; std::_Init_atomic_counter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 95   : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 133  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	void *_Ptr = 0;
; 50   : 
; 51   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 56   : 		_Xbad_alloc();	// report no memory
; 57   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 66   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 67   : 			_Xbad_alloc();	// report no memory
; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else
; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ
_TEXT	SEGMENT
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ PROC ; std::_Iterator_base0::_Getcont, COMDAT
; _this$ = ecx

; 59   : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 60   : 		}

  00002	c3		 ret	 0
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ENDP ; std::_Iterator_base0::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z PROC	; std::_Container_base0::_Swap_all, COMDAT
; _this$ = ecx

; 48   : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z ENDP	; std::_Container_base0::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 606  : 		return (EOF);

  00000	83 c8 ff	 or	 eax, -1

; 607  : 		}

  00003	c3		 ret	 0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?not_eof@?$char_traits@D@std@@SAHABH@Z PROC		; std::char_traits<char>::not_eof, COMDAT

; 600  : 		{	// return anything but EOF

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 601  : 		return (_Meta != eof() ? _Meta : !eof());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	33 c0		 xor	 eax, eax
  0000a	83 f9 ff	 cmp	 ecx, -1
  0000d	0f 45 c1	 cmovne	 eax, ecx

; 602  : 		}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?not_eof@?$char_traits@D@std@@SAHABH@Z ENDP		; std::char_traits<char>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 594  : 		{	// test for metacharacter equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000d	0f 94 c0	 sete	 al

; 595  : 		return (_Left == _Right);
; 596  : 		}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT

; 588  : 		{	// convert character to metacharacter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 589  : 		return ((unsigned char)_Ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00006	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 590  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT

; 582  : 		{	// convert metacharacter to character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 583  : 		return ((_Elem)_Meta);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00006	8a 00		 mov	 al, BYTE PTR [eax]

; 584  : 		}

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq@?$char_traits@D@std@@SA_NABD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq@?$char_traits@D@std@@SA_NABD0@Z PROC		; std::char_traits<char>::eq, COMDAT

; 570  : 		{	// test for element equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000b	3a 08		 cmp	 cl, BYTE PTR [eax]
  0000d	0f 94 c0	 sete	 al

; 571  : 		return (_Left == _Right);
; 572  : 		}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?eq@?$char_traits@D@std@@SA_NABD0@Z ENDP		; std::char_traits<char>::eq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 564  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 565  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000b	88 08		 mov	 BYTE PTR [eax], cl

; 566  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 559  : 		{	// assign _Count * _Ch to [_First, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00003	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00006	0f be 45 10	 movsx	 eax, BYTE PTR __Ch$[ebp]
  0000a	50		 push	 eax
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 _memset
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 561  : 		}

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 552  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 553  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@move
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@move:

; 553  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  00012	5d		 pop	 ebp

; 553  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?find@?$char_traits@D@std@@SAPBDPBDIABD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 4
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z PROC		; std::char_traits<char>::find, COMDAT

; 545  : 		{	// look for _Ch in [_First, _First + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 546  : 		return (_Count == 0 ? (const _Elem *)0

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN3@find

; 547  : 			: (const _Elem *)_CSTD memchr(_First, _Ch, _Count));
; 548  : 		}

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN3@find:

; 546  : 		return (_Count == 0 ? (const _Elem *)0

  0000c	50		 push	 eax
  0000d	8b 45 10	 mov	 eax, DWORD PTR __Ch$[ebp]
  00010	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00017	e8 00 00 00 00	 call	 _memchr
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 547  : 			: (const _Elem *)_CSTD memchr(_First, _Ch, _Count));
; 548  : 		}

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z ENDP		; std::char_traits<char>::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 530  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 530  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  00012	5d		 pop	 ebp

; 530  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 522  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 523  : 		return (*_First == 0 ? 0

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	80 38 00	 cmp	 BYTE PTR [eax], 0
  00009	75 04		 jne	 SHORT $LN3@length
  0000b	33 c0		 xor	 eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

  0000f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL5@length:
  00012	8a 08		 mov	 cl, BYTE PTR [eax]
  00014	40		 inc	 eax
  00015	84 c9		 test	 cl, cl
  00017	75 f9		 jne	 SHORT $LL5@length
  00019	2b c2		 sub	 eax, edx

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC		; std::char_traits<char>::compare, COMDAT

; 516  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 517  : 		return (_Count == 0 ? 0

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN3@compare
  0000a	33 c0		 xor	 eax, eax

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN3@compare:

; 517  : 		return (_Count == 0 ? 0

  0000e	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00011	56		 push	 esi
  00012	8b 75 0c	 mov	 esi, DWORD PTR __First2$[ebp]
  00015	83 e9 04	 sub	 ecx, 4
  00018	72 17		 jb	 SHORT $LN7@compare
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL8@compare:
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	3b 06		 cmp	 eax, DWORD PTR [esi]
  00024	75 10		 jne	 SHORT $LN6@compare
  00026	83 c2 04	 add	 edx, 4
  00029	83 c6 04	 add	 esi, 4
  0002c	83 e9 04	 sub	 ecx, 4
  0002f	73 ef		 jae	 SHORT $LL8@compare
$LN7@compare:
  00031	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00034	74 35		 je	 SHORT $LN5@compare
$LN6@compare:
  00036	8a 02		 mov	 al, BYTE PTR [edx]
  00038	3a 06		 cmp	 al, BYTE PTR [esi]
  0003a	75 27		 jne	 SHORT $LN9@compare
  0003c	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  0003f	74 2a		 je	 SHORT $LN5@compare
  00041	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00044	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00047	75 1a		 jne	 SHORT $LN9@compare
  00049	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0004c	74 1d		 je	 SHORT $LN5@compare
  0004e	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00051	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00054	75 0d		 jne	 SHORT $LN9@compare
  00056	83 f9 ff	 cmp	 ecx, -1
  00059	74 10		 je	 SHORT $LN5@compare
  0005b	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  0005e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00061	74 08		 je	 SHORT $LN5@compare
$LN9@compare:
  00063	1b c0		 sbb	 eax, eax
  00065	83 c8 01	 or	 eax, 1
  00068	5e		 pop	 esi

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
$LN5@compare:

; 517  : 		return (_Count == 0 ? 0

  0006b	33 c0		 xor	 eax, eax
  0006d	5e		 pop	 esi

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@_W@std@@SAGXZ
_TEXT	SEGMENT
?eof@?$char_traits@_W@std@@SAGXZ PROC			; std::char_traits<wchar_t>::eof, COMDAT

; 386  : 		return (WEOF);

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 387  : 		}

  00005	c3		 ret	 0
?eof@?$char_traits@_W@std@@SAGXZ ENDP			; std::char_traits<wchar_t>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@_W@std@@SAGABG@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?not_eof@?$char_traits@_W@std@@SAGABG@Z PROC		; std::char_traits<wchar_t>::not_eof, COMDAT

; 380  : 		{	// return anything but EOF

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 381  : 		return (_Meta != eof() ? _Meta : !eof());

  00003	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00006	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0000b	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0000e	66 3b c1	 cmp	 ax, cx
  00011	75 02		 jne	 SHORT $LN4@not_eof
  00013	33 c0		 xor	 eax, eax
$LN4@not_eof:

; 382  : 		}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?not_eof@?$char_traits@_W@std@@SAGABG@Z ENDP		; std::char_traits<wchar_t>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z PROC	; std::char_traits<wchar_t>::eq_int_type, COMDAT

; 374  : 		{	// test for metacharacter equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	66 8b 08	 mov	 cx, WORD PTR [eax]
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	66 3b 08	 cmp	 cx, WORD PTR [eax]
  0000f	0f 94 c0	 sete	 al

; 375  : 		return (_Left == _Right);
; 376  : 		}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z ENDP	; std::char_traits<wchar_t>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z PROC	; std::char_traits<wchar_t>::to_int_type, COMDAT

; 368  : 		{	// convert character to metacharacter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  : 		return (_Ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ch$[ebp]
  00006	66 8b 00	 mov	 ax, WORD PTR [eax]

; 370  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z ENDP	; std::char_traits<wchar_t>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@_W@std@@SA_WABG@Z PROC	; std::char_traits<wchar_t>::to_char_type, COMDAT

; 362  : 		{	// convert metacharacter to character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 363  : 		return (_Meta);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Meta$[ebp]
  00006	66 8b 00	 mov	 ax, WORD PTR [eax]

; 364  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?to_char_type@?$char_traits@_W@std@@SA_WABG@Z ENDP	; std::char_traits<wchar_t>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq@?$char_traits@_W@std@@SA_NAB_W0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq@?$char_traits@_W@std@@SA_NAB_W0@Z PROC		; std::char_traits<wchar_t>::eq, COMDAT

; 350  : 		{	// test for element equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	66 8b 08	 mov	 cx, WORD PTR [eax]
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	66 3b 08	 cmp	 cx, WORD PTR [eax]
  0000f	0f 94 c0	 sete	 al

; 351  : 		return (_Left == _Right);
; 352  : 		}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?eq@?$char_traits@_W@std@@SA_NAB_W0@Z ENDP		; std::char_traits<wchar_t>::eq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 344  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 345  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	66 8b 08	 mov	 cx, WORD PTR [eax]
  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	66 89 08	 mov	 WORD PTR [eax], cx

; 346  : 		}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z PROC	; std::char_traits<wchar_t>::move, COMDAT

; 332  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 333  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@move
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 334  : 			: (_Elem *)_CSTD wmemmove(_First1, _First2, _Count));
; 335  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@move:

; 333  : 		return (_Count == 0 ? _First1

  0000f	03 c0		 add	 eax, eax
  00011	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 334  : 			: (_Elem *)_CSTD wmemmove(_First1, _First2, _Count));
; 335  : 		}

  00014	5d		 pop	 ebp

; 333  : 		return (_Count == 0 ? _First1

  00015	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ENDP	; std::char_traits<wchar_t>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z PROC	; std::char_traits<wchar_t>::copy, COMDAT

; 309  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 310  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 311  : 			: (_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));
; 312  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 310  : 		return (_Count == 0 ? _First1

  0000f	03 c0		 add	 eax, eax
  00011	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 311  : 			: (_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));
; 312  : 		}

  00014	5d		 pop	 ebp

; 310  : 		return (_Count == 0 ? _First1

  00015	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ENDP	; std::char_traits<wchar_t>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@_W@std@@SAIPB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@_W@std@@SAIPB_W@Z PROC		; std::char_traits<wchar_t>::length, COMDAT

; 302  : 		{	// find length of null-terminated sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 303  : 		return (*_First == 0 ? 0

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	66 83 38 00	 cmp	 WORD PTR [eax], 0
  0000a	75 04		 jne	 SHORT $LN3@length
  0000c	33 c0		 xor	 eax, eax

; 304  : 			: _CSTD wcslen(_First));
; 305  : 		}

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN3@length:

; 303  : 		return (*_First == 0 ? 0

  00010	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
$LL5@length:
  00013	66 8b 08	 mov	 cx, WORD PTR [eax]
  00016	83 c0 02	 add	 eax, 2
  00019	66 85 c9	 test	 cx, cx
  0001c	75 f5		 jne	 SHORT $LL5@length
  0001e	2b c2		 sub	 eax, edx
  00020	d1 f8		 sar	 eax, 1

; 304  : 			: _CSTD wcslen(_First));
; 305  : 		}

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?length@?$char_traits@_W@std@@SAIPB_W@Z ENDP		; std::char_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 94   :         return;
; 95   :     }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_alloc@std@@QAE@XZ PROC				; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 115  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 116  :     }

  00003	8b c1		 mov	 eax, ecx
  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0
  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
  00017	c3		 ret	 0
??0bad_alloc@std@@QAE@XZ ENDP				; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 89   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 90   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 85   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 68   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 60   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 61   :         _Data._What = _Message;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  0000f	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0
  00014	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 62   :     }

  00017	8b c1		 mov	 eax, ecx
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -8					; size = 8
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 53   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 54   :         __std_exception_data _InitData = { _Message, true };

  00006	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	56		 push	 esi
  0000d	8b f1		 mov	 esi, ecx
  0000f	89 45 f8	 mov	 DWORD PTR __InitData$[ebp], eax
  00012	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  00015	c6 45 fc 01	 mov	 BYTE PTR __InitData$[ebp+4], 1

; 55   :         __std_exception_copy(&_InitData, &_Data);

  00019	52		 push	 edx
  0001a	8d 45 f8	 lea	 eax, DWORD PTR __InitData$[ebp]
  0001d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00023	50		 push	 eax
  00024	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00028	e8 00 00 00 00	 call	 ___std_exception_copy
  0002d	83 c4 08	 add	 esp, 8

; 56   :     }

  00030	8b c6		 mov	 eax, esi
  00032	5e		 pop	 esi
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemmove
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemmove PROC						; COMDAT

; 244  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00006	03 c0		 add	 eax, eax
  00008	89 45 10	 mov	 DWORD PTR __N$[ebp], eax

; 248  :         #pragma warning(pop)
; 249  :     }

  0000b	5d		 pop	 ebp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

  0000c	e9 00 00 00 00	 jmp	 _memmove
_wmemmove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 231  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00006	03 c0		 add	 eax, eax
  00008	89 45 10	 mov	 DWORD PTR __N$[ebp], eax

; 235  :         #pragma warning(pop)
; 236  :     }

  0000b	5d		 pop	 ebp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0000c	e9 00 00 00 00	 jmp	 _memcpy
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1834 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1835 :         int _Result;
; 1836 :         va_list _ArgList;
; 1837 :         __crt_va_start(_ArgList, _Format);
; 1838 :         _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s
  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1839 :         __crt_va_end(_ArgList);
; 1840 :         return _Result;
; 1841 :     }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsprintf_s_l PROC					; COMDAT

; 1493 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1499 : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@PB_W@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@PB_W@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<wchar_t const *>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@PB_W@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT __snwprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snwprintf PROC					; COMDAT

; 1673 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1674 :     int _Result;
; 1675 :     va_list _ArgList;
; 1676 :     __crt_va_start(_ArgList, _Format);
; 1677 : 
; 1678 :     #pragma warning(push)
; 1679 :     #pragma warning(disable: 4996) // Deprecation
; 1680 :     _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vswprintf
  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1681 :     #pragma warning(pop)
; 1682 : 
; 1683 :     __crt_va_end(_ArgList);
; 1684 :     return _Result;
; 1685 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__snwprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT __vsnwprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnwprintf_l PROC					; COMDAT

; 1056 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1057 :     int const _Result = __stdio_common_vswprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vswprintf

; 1058 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1059 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1060 : 
; 1061 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1062 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnwprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _frexpl
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 4
_frexpl	PROC						; COMDAT

; 849  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 850  :     return frexp((double)_X, _Y);

  00003	ff 75 10	 push	 DWORD PTR __Y$[ebp]
  00006	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR __X$[ebp]
  0000b	83 ec 08	 sub	 esp, 8
  0000e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00013	e8 00 00 00 00	 call	 _frexp
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 851  : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_frexpl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _fabsl
_TEXT	SEGMENT
tv68 = -8						; size = 8
__X$ = 8						; size = 8
_fabsl	PROC						; COMDAT

; 828  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 829  :     return fabs((double)_X);

  00006	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR __X$[ebp]
  0000b	0f 54 05 00 00
	00 00		 andps	 xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00012	f2 0f 11 45 f8	 movsd	 QWORD PTR tv68[ebp], xmm0
  00017	dd 45 f8	 fld	 QWORD PTR tv68[ebp]

; 830  : }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_fabsl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	7e 08		 jle	 SHORT $LN4@HRESULT_FR
  0000a	0f b7 c0	 movzx	 eax, ax
  0000d	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
$LN4@HRESULT_FR:
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 17787: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17788:     volatile char *vptr = (volatile char *)ptr;
; 17789: 
; 17790: #if defined(_M_AMD64)
; 17791: 
; 17792:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 17793: 
; 17794: #else
; 17795: 
; 17796:     while (cnt) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR _cnt$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	8b c8		 mov	 ecx, eax
  0000b	85 d2		 test	 edx, edx
  0000d	74 0c		 je	 SHORT $LN3@RtlSecureZ
  0000f	90		 npad	 1
$LL2@RtlSecureZ:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

  00013	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 17809:         cnt--;

  00016	83 ea 01	 sub	 edx, 1
  00019	75 f5		 jne	 SHORT $LL2@RtlSecureZ
$LN3@RtlSecureZ:

; 17810:     }
; 17811: 
; 17812: #endif // _M_AMD64
; 17813: 
; 17814:     return ptr;
; 17815: }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_memcpy_s.h
;	COMDAT _memcpy_s
_TEXT	SEGMENT
__Destination$ = 8					; size = 4
__DestinationSize$ = 12					; size = 4
__Source$ = 16						; size = 4
__SourceSize$ = 20					; size = 4
_memcpy_s PROC						; COMDAT

; 41   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 42   :         if (_SourceSize == 0)

  00004	8b 75 14	 mov	 esi, DWORD PTR __SourceSize$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 05		 jne	 SHORT $LN2@memcpy_s

; 43   :         {
; 44   :             return 0;

  0000b	33 c0		 xor	 eax, eax
  0000d	5e		 pop	 esi

; 61   :     }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN2@memcpy_s:

; 45   :         }
; 46   : 
; 47   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Destination$[ebp]
  00013	85 c0		 test	 eax, eax
  00015	75 18		 jne	 SHORT $LN3@memcpy_s
  00017	e8 00 00 00 00	 call	 __errno
  0001c	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  00022	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00027	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  0002c	5e		 pop	 esi

; 61   :     }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN3@memcpy_s:
  0002f	53		 push	 ebx

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  00030	8b 5d 10	 mov	 ebx, DWORD PTR __Source$[ebp]
  00033	57		 push	 edi
  00034	8b 7d 0c	 mov	 edi, DWORD PTR __DestinationSize$[ebp]
  00037	85 db		 test	 ebx, ebx
  00039	74 16		 je	 SHORT $LN5@memcpy_s
  0003b	3b fe		 cmp	 edi, esi
  0003d	72 12		 jb	 SHORT $LN5@memcpy_s

; 57   :         }
; 58   : 
; 59   :         memcpy(_Destination, _Source, _SourceSize);

  0003f	56		 push	 esi
  00040	53		 push	 ebx
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _memcpy
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 60   :         return 0;

  0004a	33 c0		 xor	 eax, eax
  0004c	5f		 pop	 edi
  0004d	5b		 pop	 ebx
  0004e	5e		 pop	 esi

; 61   :     }

  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
$LN5@memcpy_s:

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

  00051	57		 push	 edi
  00052	6a 00		 push	 0
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _memset
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  0005d	85 db		 test	 ebx, ebx
  0005f	75 1a		 jne	 SHORT $LN6@memcpy_s
  00061	e8 00 00 00 00	 call	 __errno
  00066	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  0006c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@memcpy_s:

; 54   : 
; 55   :             // Unreachable, but required to suppress /analyze warnings:
; 56   :             return EINVAL;

  00071	5f		 pop	 edi
  00072	5b		 pop	 ebx
  00073	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00078	5e		 pop	 esi

; 61   :     }

  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN6@memcpy_s:

; 53   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

  0007b	3b fe		 cmp	 edi, esi
  0007d	73 f2		 jae	 SHORT $LN7@memcpy_s
  0007f	e8 00 00 00 00	 call	 __errno
  00084	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  0008a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0008f	5f		 pop	 edi
  00090	5b		 pop	 ebx
  00091	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  00096	5e		 pop	 esi

; 61   :     }

  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
_memcpy_s ENDP
_TEXT	ENDS
END
