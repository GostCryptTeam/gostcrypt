; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Common\EncryptionThreadPool.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_EncryptionThreadPoolBeginKeyDerivation
PUBLIC	_EncryptionThreadPoolDoWork
PUBLIC	_EncryptionThreadPoolStart
PUBLIC	_EncryptionThreadPoolStop
PUBLIC	_GetEncryptionThreadCount
PUBLIC	_GetMaxEncryptionThreadCount
PUBLIC	_IsEncryptionThreadPoolRunning
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__ResetEvent@4:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateMutexA@12:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	__imp__GetSystemInfo@4:PROC
EXTRN	__beginthreadex:PROC
EXTRN	__endthreadex:PROC
EXTRN	_GetMaxPkcs5OutSize:PROC
EXTRN	_EncryptDataUnitsCurrentThread:PROC
EXTRN	_DecryptDataUnitsCurrentThread:PROC
EXTRN	_derive_key_whirlpool:PROC
EXTRN	_derive_key_gosthash:PROC
EXTRN	_derive_key_stribog:PROC
EXTRN	_memset:PROC
_BSS	SEGMENT
_ThreadPoolRunning DD 01H DUP (?)
_StopPending DD	01H DUP (?)
_ThreadCount DD	01H DUP (?)
_ThreadHandles DD 040H DUP (?)
_WorkItemQueue DB 02000H DUP (?)
_EnqueuePosition DD 01H DUP (?)
_DequeuePosition DD 01H DUP (?)
_EnqueueMutex DD 01H DUP (?)
_DequeueMutex DD 01H DUP (?)
_WorkItemReadyEvent DD 01H DUP (?)
_WorkItemCompletedEvent DD 01H DUP (?)
_BSS	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\encryptionthreadpool.c
;	COMDAT _EncryptionThreadProc@4
_TEXT	SEGMENT
_threadArg$ = 8						; size = 4
_EncryptionThreadProc@4 PROC				; COMDAT

; 164  : 	EncryptionThreadPoolWorkItem *workItem;
; 165  : 
; 166  : 	while (!StopPending)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _StopPending, 0
  00007	0f 85 c2 01 00
	00		 jne	 $LN42@Encryption
  0000d	53		 push	 ebx
  0000e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__SetEvent@4
  00014	57		 push	 edi
  00015	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WaitForSingleObject@8
  0001b	56		 push	 esi
  0001c	0f 1f 40 00	 npad	 4
$LL2@Encryption:

; 167  : 	{
; 168  : 		GST_ACQUIRE_MUTEX (&DequeueMutex);

  00020	6a ff		 push	 -1
  00022	ff 35 00 00 00
	00		 push	 DWORD PTR _DequeueMutex
  00028	ff d7		 call	 edi

; 169  : 
; 170  : 		workItem = &WorkItemQueue[DequeuePosition++];

  0002a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _DequeuePosition
  00030	ff 05 00 00 00
	00		 inc	 DWORD PTR _DequeuePosition
  00036	c1 e6 06	 shl	 esi, 6
  00039	81 c6 00 00 00
	00		 add	 esi, OFFSET _WorkItemQueue

; 171  : 
; 172  : 		if (DequeuePosition >= GST_ENC_THREAD_POOL_QUEUE_SIZE)

  0003f	81 3d 00 00 00
	00 80 00 00 00	 cmp	 DWORD PTR _DequeuePosition, 128 ; 00000080H
  00049	7c 0a		 jl	 SHORT $LN34@Encryption

; 173  : 			DequeuePosition = 0;

  0004b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DequeuePosition, 0
$LN34@Encryption:

; 174  : 
; 175  : 		while (!StopPending && GetWorkItemState (workItem) != WorkItemReady)

  00055	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _StopPending, 0
  0005c	75 20		 jne	 SHORT $LN41@Encryption
  0005e	66 90		 npad	 2
$LL4@Encryption:
  00060	33 c0		 xor	 eax, eax
  00062	f0 0f c1 06	 lock	  xadd	 DWORD PTR [esi], eax
  00066	83 f8 01	 cmp	 eax, 1
  00069	74 13		 je	 SHORT $LN41@Encryption

; 176  : 		{
; 177  : 			GST_WAIT_EVENT (WorkItemReadyEvent);

  0006b	6a ff		 push	 -1
  0006d	ff 35 00 00 00
	00		 push	 DWORD PTR _WorkItemReadyEvent
  00073	ff d7		 call	 edi
  00075	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _StopPending, 0
  0007c	74 e2		 je	 SHORT $LL4@Encryption
$LN41@Encryption:

; 178  : 		}
; 179  : 
; 180  : 		SetWorkItemState (workItem, WorkItemBusy);

  0007e	b8 02 00 00 00	 mov	 eax, 2
  00083	87 06		 xchg	 DWORD PTR [esi], eax

; 181  : 
; 182  : 		GST_RELEASE_MUTEX (&DequeueMutex);

  00085	ff 35 00 00 00
	00		 push	 DWORD PTR _DequeueMutex
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 183  : 
; 184  : 		if (StopPending)

  00091	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _StopPending, 0
  00098	0f 85 2e 01 00
	00		 jne	 $LN45@Encryption

; 185  : 			break;
; 186  : 
; 187  : 		switch (workItem->Type)

  0009e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000a1	83 e8 00	 sub	 eax, 0
  000a4	0f 84 d6 00 00
	00		 je	 $LN13@Encryption
  000aa	83 e8 01	 sub	 eax, 1
  000ad	0f 84 b7 00 00
	00		 je	 $LN12@Encryption
  000b3	83 e8 01	 sub	 eax, 1
  000b6	74 0c		 je	 SHORT $LN14@Encryption

; 227  : 
; 228  : 		default:
; 229  : 			GST_THROW_FATAL_EXCEPTION;

  000b8	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  000bf	e9 d3 00 00 00	 jmp	 $LN6@Encryption
$LN14@Encryption:

; 195  : 			break;
; 196  : 
; 197  : 		case DeriveKeyWork:
; 198  : 			switch (workItem->KeyDerivation.Pkcs5Prf)

  000c4	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  000c7	83 e8 01	 sub	 eax, 1
  000ca	74 4f		 je	 SHORT $LN17@Encryption
  000cc	83 e8 01	 sub	 eax, 1
  000cf	74 2c		 je	 SHORT $LN16@Encryption
  000d1	83 e8 01	 sub	 eax, 1
  000d4	74 09		 je	 SHORT $LN15@Encryption

; 212  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());
; 213  : 				break;
; 214  : 			default:		
; 215  : 				GST_THROW_FATAL_EXCEPTION;

  000d6	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
  000dd	eb 5b		 jmp	 SHORT $LN8@Encryption
$LN15@Encryption:

; 199  : 			{
; 200  : #ifndef GST_WINDOWS_BOOT
; 201  : 			case WHIRLPOOL:
; 202  : 				derive_key_whirlpool (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,

  000df	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  000e4	50		 push	 eax
  000e5	ff 76 20	 push	 DWORD PTR [esi+32]
  000e8	ff 76 24	 push	 DWORD PTR [esi+36]
  000eb	6a 40		 push	 64			; 00000040H
  000ed	ff 76 3c	 push	 DWORD PTR [esi+60]
  000f0	ff 76 34	 push	 DWORD PTR [esi+52]
  000f3	ff 76 30	 push	 DWORD PTR [esi+48]
  000f6	e8 00 00 00 00	 call	 _derive_key_whirlpool

; 203  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());
; 204  : 				break;

  000fb	eb 3a		 jmp	 SHORT $LN46@Encryption
$LN16@Encryption:

; 205  : 			case GOSTHASH:
; 206  : 				derive_key_gosthash (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,

  000fd	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00102	50		 push	 eax
  00103	ff 76 20	 push	 DWORD PTR [esi+32]
  00106	ff 76 24	 push	 DWORD PTR [esi+36]
  00109	6a 40		 push	 64			; 00000040H
  0010b	ff 76 3c	 push	 DWORD PTR [esi+60]
  0010e	ff 76 34	 push	 DWORD PTR [esi+52]
  00111	ff 76 30	 push	 DWORD PTR [esi+48]
  00114	e8 00 00 00 00	 call	 _derive_key_gosthash

; 207  : 					workItem->KeyDerivation.IterationCount, workItem->KeyDerivation.DerivedKey, GetMaxPkcs5OutSize());
; 208  : 				break;

  00119	eb 1c		 jmp	 SHORT $LN46@Encryption
$LN17@Encryption:

; 209  : #endif
; 210  : 			case STRIBOG:
; 211  : 				derive_key_stribog (workItem->KeyDerivation.Password, workItem->KeyDerivation.PasswordLength, workItem->KeyDerivation.Salt, PKCS5_SALT_SIZE,

  0011b	e8 00 00 00 00	 call	 _GetMaxPkcs5OutSize
  00120	50		 push	 eax
  00121	ff 76 20	 push	 DWORD PTR [esi+32]
  00124	ff 76 24	 push	 DWORD PTR [esi+36]
  00127	6a 40		 push	 64			; 00000040H
  00129	ff 76 3c	 push	 DWORD PTR [esi+60]
  0012c	ff 76 34	 push	 DWORD PTR [esi+52]
  0012f	ff 76 30	 push	 DWORD PTR [esi+48]
  00132	e8 00 00 00 00	 call	 _derive_key_stribog
$LN46@Encryption:
  00137	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN8@Encryption:

; 216  : 			} 
; 217  : 
; 218  : 			InterlockedExchange (workItem->KeyDerivation.CompletionFlag, TRUE);

  0013a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0013d	b9 01 00 00 00	 mov	 ecx, 1
  00142	87 08		 xchg	 DWORD PTR [eax], ecx

; 219  : 			GST_SET_EVENT (*workItem->KeyDerivation.CompletionEvent);

  00144	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00147	ff 30		 push	 DWORD PTR [eax]
  00149	ff d3		 call	 ebx

; 220  : 			
; 221  : 			if (InterlockedDecrement (workItem->KeyDerivation.OutstandingWorkItemCount) == 0)

  0014b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0014e	83 c9 ff	 or	 ecx, -1
  00151	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00155	75 07		 jne	 SHORT $LN19@Encryption

; 222  : 				GST_SET_EVENT (*workItem->KeyDerivation.NoOutstandingWorkItemEvent);

  00157	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0015a	ff 30		 push	 DWORD PTR [eax]
  0015c	ff d3		 call	 ebx
$LN19@Encryption:

; 223  : 
; 224  : 			SetWorkItemState (workItem, WorkItemFree);

  0015e	33 c0		 xor	 eax, eax
  00160	87 06		 xchg	 DWORD PTR [esi], eax

; 225  : 			GST_SET_EVENT (WorkItemCompletedEvent);

  00162	ff 35 00 00 00
	00		 push	 DWORD PTR _WorkItemCompletedEvent

; 226  : 			continue;

  00168	eb 53		 jmp	 SHORT $LN47@Encryption
$LN12@Encryption:

; 188  : 		{
; 189  : 		case DecryptDataUnitsWork:
; 190  : 			DecryptDataUnitsCurrentThread (workItem->Encryption.Data, &workItem->Encryption.StartUnitNo, workItem->Encryption.UnitCount, workItem->Encryption.CryptoInfo);

  0016a	ff 76 18	 push	 DWORD PTR [esi+24]
  0016d	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  00170	6a 00		 push	 0
  00172	ff 76 28	 push	 DWORD PTR [esi+40]
  00175	50		 push	 eax
  00176	ff 76 1c	 push	 DWORD PTR [esi+28]
  00179	e8 00 00 00 00	 call	 _DecryptDataUnitsCurrentThread

; 191  : 			break;

  0017e	eb 14		 jmp	 SHORT $LN48@Encryption
$LN13@Encryption:

; 192  : 
; 193  : 		case EncryptDataUnitsWork:
; 194  : 			EncryptDataUnitsCurrentThread (workItem->Encryption.Data, &workItem->Encryption.StartUnitNo, workItem->Encryption.UnitCount, workItem->Encryption.CryptoInfo);

  00180	ff 76 18	 push	 DWORD PTR [esi+24]
  00183	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  00186	6a 00		 push	 0
  00188	ff 76 28	 push	 DWORD PTR [esi+40]
  0018b	50		 push	 eax
  0018c	ff 76 1c	 push	 DWORD PTR [esi+28]
  0018f	e8 00 00 00 00	 call	 _EncryptDataUnitsCurrentThread
$LN48@Encryption:
  00194	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@Encryption:

; 230  : 		}
; 231  : 
; 232  : 		if (workItem != workItem->FirstFragment)

  00197	3b 76 0c	 cmp	 esi, DWORD PTR [esi+12]
  0019a	74 0c		 je	 SHORT $LN21@Encryption

; 233  : 		{
; 234  : 			SetWorkItemState (workItem, WorkItemFree);

  0019c	33 c0		 xor	 eax, eax
  0019e	87 06		 xchg	 DWORD PTR [esi], eax

; 235  : 			GST_SET_EVENT (WorkItemCompletedEvent);

  001a0	ff 35 00 00 00
	00		 push	 DWORD PTR _WorkItemCompletedEvent
  001a6	ff d3		 call	 ebx
$LN21@Encryption:

; 236  : 		}
; 237  : 
; 238  : 		if (InterlockedDecrement (&workItem->FirstFragment->OutstandingFragmentCount) == 0)

  001a8	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  001ab	83 c8 ff	 or	 eax, -1
  001ae	83 c1 10	 add	 ecx, 16			; 00000010H
  001b1	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  001b5	75 08		 jne	 SHORT $LN22@Encryption

; 239  : 			GST_SET_EVENT (workItem->FirstFragment->ItemCompletedEvent);

  001b7	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  001ba	ff 70 08	 push	 DWORD PTR [eax+8]
$LN47@Encryption:
  001bd	ff d3		 call	 ebx
$LN22@Encryption:

; 164  : 	EncryptionThreadPoolWorkItem *workItem;
; 165  : 
; 166  : 	while (!StopPending)

  001bf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _StopPending, 0
  001c6	0f 84 54 fe ff
	ff		 je	 $LL2@Encryption
$LN45@Encryption:
  001cc	5e		 pop	 esi
  001cd	5f		 pop	 edi
  001ce	5b		 pop	 ebx
$LN42@Encryption:

; 240  : 	}
; 241  : 
; 242  : #ifdef DEVICE_DRIVER
; 243  : 	PsTerminateSystemThread (STATUS_SUCCESS);
; 244  : #else
; 245  : 	_endthreadex (0);

  001cf	6a 00		 push	 0
  001d1	e8 00 00 00 00	 call	 __endthreadex
  001d6	83 c4 04	 add	 esp, 4

; 246  :     return 0;

  001d9	33 c0		 xor	 eax, eax

; 247  : #endif
; 248  : }

  001db	c2 04 00	 ret	 4
_EncryptionThreadProc@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\encryptionthreadpool.c
;	COMDAT _SetWorkItemState
_TEXT	SEGMENT
_workItem$ = 8						; size = 4
_newState$ = 12						; size = 4
_SetWorkItemState PROC					; COMDAT

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 146  : 	InterlockedExchange ((LONG *) &workItem->State, (LONG) newState);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _newState$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _workItem$[ebp]
  00009	87 08		 xchg	 DWORD PTR [eax], ecx

; 147  : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
_SetWorkItemState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\encryptionthreadpool.c
;	COMDAT _GetWorkItemState
_TEXT	SEGMENT
_workItem$ = 8						; size = 4
_GetWorkItemState PROC					; COMDAT

; 130  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 131  : 	return InterlockedExchangeAdd ((LONG *) &workItem->State, 0);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _workItem$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax

; 132  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
_GetWorkItemState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\encryptionthreadpool.c
;	COMDAT _IsEncryptionThreadPoolRunning
_TEXT	SEGMENT
_IsEncryptionThreadPoolRunning PROC			; COMDAT

; 612  : 	return ThreadPoolRunning;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadPoolRunning

; 613  : }

  00005	c3		 ret	 0
_IsEncryptionThreadPoolRunning ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\encryptionthreadpool.c
;	COMDAT _GetMaxEncryptionThreadCount
_TEXT	SEGMENT
_GetMaxEncryptionThreadCount PROC			; COMDAT

; 599  : 	return GST_ENC_THREAD_POOL_MAX_THREAD_COUNT;

  00000	b8 40 00 00 00	 mov	 eax, 64			; 00000040H

; 600  : }

  00005	c3		 ret	 0
_GetMaxEncryptionThreadCount ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\encryptionthreadpool.c
;	COMDAT _GetEncryptionThreadCount
_TEXT	SEGMENT
_GetEncryptionThreadCount PROC				; COMDAT

; 586  : 	return ThreadPoolRunning ? ThreadCount : 0;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _ThreadPoolRunning
  00005	f7 d8		 neg	 eax
  00007	1b c0		 sbb	 eax, eax
  00009	23 05 00 00 00
	00		 and	 eax, DWORD PTR _ThreadCount

; 587  : }

  0000f	c3		 ret	 0
_GetEncryptionThreadCount ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\encryptionthreadpool.c
;	COMDAT _EncryptionThreadPoolStop
_TEXT	SEGMENT
_EncryptionThreadPoolStop PROC				; COMDAT

; 368  : 	size_t i;
; 369  : 
; 370  : 	if (!ThreadPoolRunning)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ThreadPoolRunning, 0
  00007	0f 84 97 00 00
	00		 je	 $LN1@Encryption

; 371  : 		return;
; 372  : 
; 373  : 	StopPending = TRUE;
; 374  : 	GST_SET_EVENT (WorkItemReadyEvent);

  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	ff 35 00 00 00
	00		 push	 DWORD PTR _WorkItemReadyEvent
  00015	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _StopPending, 1
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 375  : 
; 376  : 	for (i = 0; i < ThreadCount; ++i)

  00025	33 f6		 xor	 esi, esi
  00027	39 35 00 00 00
	00		 cmp	 DWORD PTR _ThreadCount, esi
  0002d	76 1a		 jbe	 SHORT $LN3@Encryption
  0002f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WaitForSingleObject@8
$LL4@Encryption:

; 377  : 	{
; 378  : #ifdef DEVICE_DRIVER
; 379  : 		GSTStopThread (ThreadHandles[i], &WorkItemReadyEvent);
; 380  : #else
; 381  : 		GST_WAIT_EVENT (ThreadHandles[i]);

  00035	6a ff		 push	 -1
  00037	ff 34 b5 00 00
	00 00		 push	 DWORD PTR _ThreadHandles[esi*4]
  0003e	ff d7		 call	 edi
  00040	46		 inc	 esi
  00041	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR _ThreadCount
  00047	72 ec		 jb	 SHORT $LL4@Encryption
$LN3@Encryption:

; 382  : #endif
; 383  : 	}
; 384  : 
; 385  : 	ThreadCount = 0;
; 386  : 
; 387  : #ifndef DEVICE_DRIVER
; 388  : 	CloseHandle (DequeueMutex);

  00049	ff 35 00 00 00
	00		 push	 DWORD PTR _DequeueMutex
  0004f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CloseHandle@4
  00055	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ThreadCount, 0
  0005f	ff d7		 call	 edi

; 389  : 	CloseHandle (EnqueueMutex);

  00061	ff 35 00 00 00
	00		 push	 DWORD PTR _EnqueueMutex
  00067	ff d7		 call	 edi

; 390  : 
; 391  : 	CloseHandle (WorkItemReadyEvent);

  00069	ff 35 00 00 00
	00		 push	 DWORD PTR _WorkItemReadyEvent
  0006f	ff d7		 call	 edi

; 392  : 	CloseHandle (WorkItemCompletedEvent);

  00071	ff 35 00 00 00
	00		 push	 DWORD PTR _WorkItemCompletedEvent
  00077	ff d7		 call	 edi

; 393  : 
; 394  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)

  00079	33 f6		 xor	 esi, esi
  0007b	0f 1f 44 00 00	 npad	 5
$LL7@Encryption:

; 395  : 	{
; 396  : 		if (WorkItemQueue[i].ItemCompletedEvent)

  00080	8b 86 08 00 00
	00		 mov	 eax, DWORD PTR _WorkItemQueue[esi+8]
  00086	85 c0		 test	 eax, eax
  00088	74 03		 je	 SHORT $LN5@Encryption

; 397  : 			CloseHandle (WorkItemQueue[i].ItemCompletedEvent);

  0008a	50		 push	 eax
  0008b	ff d7		 call	 edi
$LN5@Encryption:

; 393  : 
; 394  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)

  0008d	83 c6 40	 add	 esi, 64			; 00000040H
  00090	81 fe 00 20 00
	00		 cmp	 esi, 8192		; 00002000H
  00096	72 e8		 jb	 SHORT $LL7@Encryption

; 398  : 	}
; 399  : #endif
; 400  : 
; 401  : 	ThreadPoolRunning = FALSE;

  00098	5f		 pop	 edi
  00099	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ThreadPoolRunning, 0
  000a3	5e		 pop	 esi
$LN1@Encryption:

; 402  : }

  000a4	c3		 ret	 0
_EncryptionThreadPoolStop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\encryptionthreadpool.c
;	COMDAT _EncryptionThreadPoolStart
_TEXT	SEGMENT
_sysInfo$1 = -36					; size = 36
_encryptionFreeCpuCount$ = 8				; size = 4
_EncryptionThreadPoolStart PROC				; COMDAT

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 269  : 	size_t cpuCount, i;
; 270  : 
; 271  : 	if (ThreadPoolRunning)

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ThreadPoolRunning, 0
  0000d	74 09		 je	 SHORT $LN8@Encryption

; 272  : 		return TRUE;

  0000f	b8 01 00 00 00	 mov	 eax, 1

; 356  : }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN8@Encryption:
  00018	57		 push	 edi

; 273  : 
; 274  : #ifdef DEVICE_DRIVER
; 275  : 	cpuCount = GetCpuCount();
; 276  : #else
; 277  : 	{
; 278  : 		SYSTEM_INFO sysInfo;
; 279  : 		GetSystemInfo (&sysInfo);

  00019	8d 45 dc	 lea	 eax, DWORD PTR _sysInfo$1[ebp]
  0001c	50		 push	 eax
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemInfo@4

; 280  : 		cpuCount = sysInfo.dwNumberOfProcessors;

  00023	8b 7d f0	 mov	 edi, DWORD PTR _sysInfo$1[ebp+20]

; 281  : 	}
; 282  : #endif
; 283  : 
; 284  : 	if (cpuCount > encryptionFreeCpuCount)

  00026	8b 45 08	 mov	 eax, DWORD PTR _encryptionFreeCpuCount$[ebp]
  00029	3b f8		 cmp	 edi, eax
  0002b	76 02		 jbe	 SHORT $LN9@Encryption

; 285  : 		cpuCount -= encryptionFreeCpuCount;

  0002d	2b f8		 sub	 edi, eax
$LN9@Encryption:

; 286  : 
; 287  : 	if (cpuCount < 2)

  0002f	83 ff 02	 cmp	 edi, 2
  00032	73 0a		 jae	 SHORT $LN10@Encryption

; 288  : 		return TRUE;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	5f		 pop	 edi

; 356  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN10@Encryption:
  0003e	53		 push	 ebx

; 289  : 
; 290  : 	if (cpuCount > GST_ENC_THREAD_POOL_MAX_THREAD_COUNT)
; 291  : 		cpuCount = GST_ENC_THREAD_POOL_MAX_THREAD_COUNT;
; 292  : 
; 293  : 	StopPending = FALSE;
; 294  : 	DequeuePosition = 0;
; 295  : 	EnqueuePosition = 0;
; 296  : 
; 297  : #ifdef DEVICE_DRIVER
; 298  : 	KeInitializeEvent (&WorkItemReadyEvent, SynchronizationEvent, FALSE);
; 299  : 	KeInitializeEvent (&WorkItemCompletedEvent, SynchronizationEvent, FALSE);
; 300  : #else
; 301  : 	WorkItemReadyEvent = CreateEvent (NULL, FALSE, FALSE, NULL);

  0003f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CreateEventA@16
  00045	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	3b f8		 cmp	 edi, eax
  00050	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _StopPending, 0
  0005a	6a 00		 push	 0
  0005c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _DequeuePosition, 0
  00066	0f 47 f8	 cmova	 edi, eax
  00069	6a 00		 push	 0
  0006b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _EnqueuePosition, 0
  00075	ff d3		 call	 ebx
  00077	a3 00 00 00 00	 mov	 DWORD PTR _WorkItemReadyEvent, eax

; 302  : 	if (!WorkItemReadyEvent)

  0007c	85 c0		 test	 eax, eax
  0007e	74 13		 je	 SHORT $LN33@Encryption

; 303  : 		return FALSE;
; 304  : 	
; 305  : 	WorkItemCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);

  00080	6a 00		 push	 0
  00082	6a 00		 push	 0
  00084	6a 00		 push	 0
  00086	6a 00		 push	 0
  00088	ff d3		 call	 ebx
  0008a	a3 00 00 00 00	 mov	 DWORD PTR _WorkItemCompletedEvent, eax

; 306  : 	if (!WorkItemCompletedEvent)

  0008f	85 c0		 test	 eax, eax
  00091	75 08		 jne	 SHORT $LN13@Encryption
$LN33@Encryption:
  00093	5b		 pop	 ebx

; 307  : 		return FALSE;

  00094	33 c0		 xor	 eax, eax
  00096	5f		 pop	 edi

; 356  : }

  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
$LN13@Encryption:
  0009b	56		 push	 esi

; 308  : #endif
; 309  : 	
; 310  : #ifdef DEVICE_DRIVER
; 311  : 	ExInitializeFastMutex (&DequeueMutex);
; 312  : 	ExInitializeFastMutex (&EnqueueMutex);
; 313  : #else
; 314  : 	DequeueMutex = CreateMutex (NULL, FALSE, NULL);

  0009c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CreateMutexA@12
  000a2	6a 00		 push	 0
  000a4	6a 00		 push	 0
  000a6	6a 00		 push	 0
  000a8	ff d6		 call	 esi
  000aa	a3 00 00 00 00	 mov	 DWORD PTR _DequeueMutex, eax

; 315  : 	if (!DequeueMutex)

  000af	85 c0		 test	 eax, eax
  000b1	0f 84 b7 00 00
	00		 je	 $LN32@Encryption

; 316  : 		return FALSE;
; 317  : 
; 318  : 	EnqueueMutex = CreateMutex (NULL, FALSE, NULL);

  000b7	6a 00		 push	 0
  000b9	6a 00		 push	 0
  000bb	6a 00		 push	 0
  000bd	ff d6		 call	 esi
  000bf	a3 00 00 00 00	 mov	 DWORD PTR _EnqueueMutex, eax

; 319  : 	if (!EnqueueMutex)

  000c4	85 c0		 test	 eax, eax
  000c6	0f 84 a2 00 00
	00		 je	 $LN32@Encryption

; 320  : 		return FALSE;
; 321  : #endif
; 322  : 
; 323  : 	memset (WorkItemQueue, 0, sizeof (WorkItemQueue));

  000cc	68 00 20 00 00	 push	 8192			; 00002000H
  000d1	6a 00		 push	 0
  000d3	68 00 00 00 00	 push	 OFFSET _WorkItemQueue
  000d8	e8 00 00 00 00	 call	 _memset
  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 324  : 
; 325  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)

  000e0	33 f6		 xor	 esi, esi
$LL4@Encryption:

; 326  : 	{
; 327  : 		WorkItemQueue[i].State = WorkItemFree;
; 328  : 
; 329  : #ifdef DEVICE_DRIVER
; 330  : 		KeInitializeEvent (&WorkItemQueue[i].ItemCompletedEvent, SynchronizationEvent, FALSE);
; 331  : #else
; 332  : 		WorkItemQueue[i].ItemCompletedEvent = CreateEvent (NULL, FALSE, FALSE, NULL);

  000e2	6a 00		 push	 0
  000e4	6a 00		 push	 0
  000e6	6a 00		 push	 0
  000e8	6a 00		 push	 0
  000ea	c7 86 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _WorkItemQueue[esi], 0
  000f4	ff d3		 call	 ebx
  000f6	89 86 08 00 00
	00		 mov	 DWORD PTR _WorkItemQueue[esi+8], eax

; 333  : 		if (!WorkItemQueue[i].ItemCompletedEvent)

  000fc	85 c0		 test	 eax, eax
  000fe	74 69		 je	 SHORT $LN21@Encryption

; 324  : 
; 325  : 	for (i = 0; i < sizeof (WorkItemQueue) / sizeof (WorkItemQueue[0]); ++i)

  00100	83 c6 40	 add	 esi, 64			; 00000040H
  00103	81 fe 00 20 00
	00		 cmp	 esi, 8192		; 00002000H
  00109	72 d7		 jb	 SHORT $LL4@Encryption

; 337  : 		}
; 338  : #endif
; 339  : 	}
; 340  : 
; 341  : 	for (ThreadCount = 0; ThreadCount < cpuCount; ++ThreadCount)

  0010b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ThreadCount, 0
  00115	85 ff		 test	 edi, edi
  00117	74 3a		 je	 SHORT $LN6@Encryption
  00119	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@Encryption:

; 342  : 	{
; 343  : #ifdef DEVICE_DRIVER
; 344  : 		if (!NT_SUCCESS (GSTStartThread (EncryptionThreadProc, NULL, &ThreadHandles[ThreadCount])))
; 345  : #else
; 346  : 		if (!(ThreadHandles[ThreadCount] = (HANDLE) _beginthreadex (NULL, 0, EncryptionThreadProc, NULL, 0, NULL)))

  00120	6a 00		 push	 0
  00122	6a 00		 push	 0
  00124	6a 00		 push	 0
  00126	68 00 00 00 00	 push	 OFFSET _EncryptionThreadProc@4
  0012b	6a 00		 push	 0
  0012d	6a 00		 push	 0
  0012f	e8 00 00 00 00	 call	 __beginthreadex
  00134	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ThreadCount
  0013a	83 c4 18	 add	 esp, 24			; 00000018H
  0013d	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _ThreadHandles[ecx*4], eax
  00144	85 c0		 test	 eax, eax
  00146	74 21		 je	 SHORT $LN21@Encryption

; 337  : 		}
; 338  : #endif
; 339  : 	}
; 340  : 
; 341  : 	for (ThreadCount = 0; ThreadCount < cpuCount; ++ThreadCount)

  00148	41		 inc	 ecx
  00149	89 0d 00 00 00
	00		 mov	 DWORD PTR _ThreadCount, ecx
  0014f	3b cf		 cmp	 ecx, edi
  00151	72 cd		 jb	 SHORT $LL7@Encryption
$LN6@Encryption:
  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx

; 347  : #endif
; 348  : 		{
; 349  : 			EncryptionThreadPoolStop();
; 350  : 			return FALSE;
; 351  : 		}
; 352  : 	}
; 353  : 
; 354  : 	ThreadPoolRunning = TRUE;

  00155	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _ThreadPoolRunning, 1

; 355  : 	return TRUE;

  0015f	b8 01 00 00 00	 mov	 eax, 1
  00164	5f		 pop	 edi

; 356  : }

  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
$LN21@Encryption:

; 334  : 		{
; 335  : 			EncryptionThreadPoolStop();

  00169	e8 00 00 00 00	 call	 _EncryptionThreadPoolStop
$LN32@Encryption:
  0016e	5e		 pop	 esi
  0016f	5b		 pop	 ebx

; 336  : 			return FALSE;

  00170	33 c0		 xor	 eax, eax
  00172	5f		 pop	 edi

; 356  : }

  00173	8b e5		 mov	 esp, ebp
  00175	5d		 pop	 ebp
  00176	c3		 ret	 0
_EncryptionThreadPoolStart ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\encryptionthreadpool.c
;	COMDAT _EncryptionThreadPoolDoWork
_TEXT	SEGMENT
_fragmentStartUnitNo$1$ = -24				; size = 4
_fragmentData$1$ = -20					; size = 4
tv278 = -16						; size = 4
_remainder$1$ = -12					; size = 4
_fragmentStartUnitNo$2$ = -8				; size = 4
_fragmentCount$1$ = -4					; size = 4
_type$ = 8						; size = 4
_data$ = 12						; size = 4
_startUnitNo$ = 16					; size = 4
_firstFragmentWorkItem$1$ = 20				; size = 4
_unitCount$ = 20					; size = 4
_cryptoInfo$ = 24					; size = 4
_EncryptionThreadPoolDoWork PROC			; COMDAT

; 474  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 475  : 	uint32 fragmentCount;
; 476  : 	uint32 unitsPerFragment;
; 477  : 	uint32 remainder;
; 478  : 
; 479  : 	byte *fragmentData;
; 480  : 	uint64 fragmentStartUnitNo;
; 481  : 
; 482  : 	EncryptionThreadPoolWorkItem *workItem;
; 483  : 	EncryptionThreadPoolWorkItem *firstFragmentWorkItem;
; 484  : 	
; 485  : 	if (unitCount == 0)

  00003	8b 45 14	 mov	 eax, DWORD PTR _unitCount$[ebp]
  00006	83 ec 18	 sub	 esp, 24			; 00000018H
  00009	85 c0		 test	 eax, eax
  0000b	0f 84 ef 01 00
	00		 je	 $LN2@Encryption

; 486  : 		return;
; 487  : 	
; 488  : 	if (!ThreadPoolRunning || unitCount == 1)

  00011	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ThreadPoolRunning, 0
  00018	0f 84 9e 01 00
	00		 je	 $LN12@Encryption
  0001e	83 f8 01	 cmp	 eax, 1
  00021	0f 84 95 01 00
	00		 je	 $LN12@Encryption

; 502  : 		}
; 503  : 
; 504  : 		return;
; 505  : 	}
; 506  : 
; 507  : 	if (unitCount <= ThreadCount)

  00027	53		 push	 ebx
  00028	56		 push	 esi
  00029	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _ThreadCount

; 508  : 	{
; 509  : 		fragmentCount = unitCount;
; 510  : 		unitsPerFragment = 1;
; 511  : 		remainder = 0;

  0002f	33 d2		 xor	 edx, edx
  00031	89 75 fc	 mov	 DWORD PTR _fragmentCount$1$[ebp], esi
  00034	57		 push	 edi
  00035	3b c6		 cmp	 eax, esi
  00037	77 0d		 ja	 SHORT $LN16@Encryption
  00039	8b f0		 mov	 esi, eax
  0003b	89 55 f4	 mov	 DWORD PTR _remainder$1$[ebp], edx
  0003e	89 75 fc	 mov	 DWORD PTR _fragmentCount$1$[ebp], esi
  00041	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]

; 512  : 	}

  00044	eb 0c		 jmp	 SHORT $LN18@Encryption
$LN16@Encryption:

; 513  : 	else
; 514  : 	{
; 515  : 		/* Note that it is not efficient to divide the data into fragments smaller than a few hundred bytes.
; 516  : 		The reason is that the overhead associated with thread handling would in most cases make a multi-threaded 
; 517  : 		process actually slower than a single-threaded process. */
; 518  : 
; 519  : 		fragmentCount = ThreadCount;
; 520  : 		unitsPerFragment = unitCount / ThreadCount;

  00046	f7 f6		 div	 esi
  00048	89 55 f4	 mov	 DWORD PTR _remainder$1$[ebp], edx
  0004b	8b f8		 mov	 edi, eax

; 521  : 		remainder = unitCount % ThreadCount;
; 522  : 
; 523  : 		if (remainder > 0)

  0004d	85 d2		 test	 edx, edx
  0004f	74 01		 je	 SHORT $LN18@Encryption

; 524  : 			++unitsPerFragment;

  00051	47		 inc	 edi
$LN18@Encryption:

; 525  : 	}
; 526  : 	
; 527  : 	fragmentData = data;

  00052	8b 45 0c	 mov	 eax, DWORD PTR _data$[ebp]

; 528  : 	fragmentStartUnitNo = startUnitNo->Value;
; 529  : 
; 530  : 	GST_ACQUIRE_MUTEX (&EnqueueMutex);

  00055	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__WaitForSingleObject@8
  0005b	89 45 ec	 mov	 DWORD PTR _fragmentData$1$[ebp], eax
  0005e	8b 45 10	 mov	 eax, DWORD PTR _startUnitNo$[ebp]
  00061	6a ff		 push	 -1
  00063	ff 35 00 00 00
	00		 push	 DWORD PTR _EnqueueMutex
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006e	89 4d e8	 mov	 DWORD PTR _fragmentStartUnitNo$1$[ebp], ecx
  00071	89 45 f8	 mov	 DWORD PTR _fragmentStartUnitNo$2$[ebp], eax
  00074	ff d3		 call	 ebx

; 531  : 	firstFragmentWorkItem = &WorkItemQueue[EnqueuePosition];

  00076	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _EnqueuePosition

; 532  : 
; 533  : 	while (GetWorkItemState (firstFragmentWorkItem) != WorkItemFree)

  0007c	33 c0		 xor	 eax, eax
  0007e	c1 e1 06	 shl	 ecx, 6
  00081	81 c1 00 00 00
	00		 add	 ecx, OFFSET _WorkItemQueue
  00087	89 4d 14	 mov	 DWORD PTR _firstFragmentWorkItem$1$[ebp], ecx
  0008a	f0 0f c1 01	 lock	  xadd	 DWORD PTR [ecx], eax
  0008e	85 c0		 test	 eax, eax
  00090	74 1c		 je	 SHORT $LN5@Encryption
  00092	8b f1		 mov	 esi, ecx
$LL4@Encryption:

; 534  : 	{
; 535  : 		GST_WAIT_EVENT (WorkItemCompletedEvent);

  00094	6a ff		 push	 -1
  00096	ff 35 00 00 00
	00		 push	 DWORD PTR _WorkItemCompletedEvent
  0009c	ff d3		 call	 ebx
  0009e	33 c0		 xor	 eax, eax
  000a0	f0 0f c1 06	 lock	  xadd	 DWORD PTR [esi], eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 ec		 jne	 SHORT $LL4@Encryption
  000a8	8b 75 fc	 mov	 esi, DWORD PTR _fragmentCount$1$[ebp]
  000ab	8b 4d 14	 mov	 ecx, DWORD PTR _firstFragmentWorkItem$1$[ebp]
$LN5@Encryption:

; 536  : 	}
; 537  : 
; 538  : 	firstFragmentWorkItem->OutstandingFragmentCount = fragmentCount;

  000ae	89 71 10	 mov	 DWORD PTR [ecx+16], esi

; 539  : 
; 540  : 	while (fragmentCount-- > 0)

  000b1	85 f6		 test	 esi, esi
  000b3	0f 84 d6 00 00
	00		 je	 $LN35@Encryption

; 536  : 	}
; 537  : 
; 538  : 	firstFragmentWorkItem->OutstandingFragmentCount = fragmentCount;

  000b9	8b d7		 mov	 edx, edi
  000bb	c1 e2 09	 shl	 edx, 9
  000be	89 55 f0	 mov	 DWORD PTR tv278[ebp], edx
$LL6@Encryption:

; 539  : 
; 540  : 	while (fragmentCount-- > 0)

  000c1	4e		 dec	 esi
  000c2	89 75 fc	 mov	 DWORD PTR _fragmentCount$1$[ebp], esi

; 541  : 	{
; 542  : 		workItem = &WorkItemQueue[EnqueuePosition++];

  000c5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _EnqueuePosition
  000cb	ff 05 00 00 00
	00		 inc	 DWORD PTR _EnqueuePosition
  000d1	c1 e6 06	 shl	 esi, 6
  000d4	81 c6 00 00 00
	00		 add	 esi, OFFSET _WorkItemQueue

; 543  : 		if (EnqueuePosition >= GST_ENC_THREAD_POOL_QUEUE_SIZE)

  000da	81 3d 00 00 00
	00 80 00 00 00	 cmp	 DWORD PTR _EnqueuePosition, 128 ; 00000080H
  000e4	7c 0a		 jl	 SHORT $LN32@Encryption

; 544  : 			EnqueuePosition = 0;

  000e6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _EnqueuePosition, 0
$LN32@Encryption:

; 545  : 
; 546  : 		while (GetWorkItemState (workItem) != WorkItemFree)

  000f0	33 c0		 xor	 eax, eax
  000f2	f0 0f c1 06	 lock	  xadd	 DWORD PTR [esi], eax
  000f6	85 c0		 test	 eax, eax
  000f8	74 20		 je	 SHORT $LN9@Encryption
  000fa	66 0f 1f 44 00
	00		 npad	 6
$LL8@Encryption:

; 547  : 		{
; 548  : 			GST_WAIT_EVENT (WorkItemCompletedEvent);

  00100	6a ff		 push	 -1
  00102	ff 35 00 00 00
	00		 push	 DWORD PTR _WorkItemCompletedEvent
  00108	ff d3		 call	 ebx
  0010a	33 c0		 xor	 eax, eax
  0010c	f0 0f c1 06	 lock	  xadd	 DWORD PTR [esi], eax
  00110	85 c0		 test	 eax, eax
  00112	75 ec		 jne	 SHORT $LL8@Encryption
  00114	8b 4d 14	 mov	 ecx, DWORD PTR _firstFragmentWorkItem$1$[ebp]
  00117	8b 55 f0	 mov	 edx, DWORD PTR tv278[ebp]
$LN9@Encryption:

; 549  : 		}
; 550  : 
; 551  : 		workItem->Type = type;

  0011a	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]

; 552  : 		workItem->FirstFragment = firstFragmentWorkItem;
; 553  : 
; 554  : 		workItem->Encryption.CryptoInfo = cryptoInfo;
; 555  : 		workItem->Encryption.Data = fragmentData;
; 556  : 		workItem->Encryption.UnitCount = unitsPerFragment;
; 557  : 		workItem->Encryption.StartUnitNo.Value = fragmentStartUnitNo;

  0011d	8b 5d f8	 mov	 ebx, DWORD PTR _fragmentStartUnitNo$2$[ebp]
  00120	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00123	8b 45 18	 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00126	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00129	8b 45 ec	 mov	 eax, DWORD PTR _fragmentData$1$[ebp]
  0012c	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR _fragmentStartUnitNo$1$[ebp]
  00132	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 558  : 
; 559  :  		fragmentData += unitsPerFragment * ENCRYPTION_DATA_UNIT_SIZE;

  00135	03 c2		 add	 eax, edx
  00137	89 4e 20	 mov	 DWORD PTR [esi+32], ecx

; 560  : 		fragmentStartUnitNo += unitsPerFragment;

  0013a	03 cf		 add	 ecx, edi
  0013c	89 45 ec	 mov	 DWORD PTR _fragmentData$1$[ebp], eax
  0013f	83 55 f8 00	 adc	 DWORD PTR _fragmentStartUnitNo$2$[ebp], 0

; 561  : 
; 562  : 		if (remainder > 0 && --remainder == 0)

  00143	8b 45 f4	 mov	 eax, DWORD PTR _remainder$1$[ebp]
  00146	89 5e 24	 mov	 DWORD PTR [esi+36], ebx
  00149	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__WaitForSingleObject@8
  0014f	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  00152	89 4d e8	 mov	 DWORD PTR _fragmentStartUnitNo$1$[ebp], ecx
  00155	85 c0		 test	 eax, eax
  00157	74 12		 je	 SHORT $LN20@Encryption
  00159	83 e8 01	 sub	 eax, 1
  0015c	89 45 f4	 mov	 DWORD PTR _remainder$1$[ebp], eax
  0015f	75 0a		 jne	 SHORT $LN20@Encryption

; 563  : 			--unitsPerFragment;

  00161	4f		 dec	 edi
  00162	81 ea 00 02 00
	00		 sub	 edx, 512		; 00000200H
  00168	89 55 f0	 mov	 DWORD PTR tv278[ebp], edx
$LN20@Encryption:

; 564  : 
; 565  : 		SetWorkItemState (workItem, WorkItemReady);

  0016b	b8 01 00 00 00	 mov	 eax, 1
  00170	87 06		 xchg	 DWORD PTR [esi], eax

; 566  : 		GST_SET_EVENT (WorkItemReadyEvent);

  00172	ff 35 00 00 00
	00		 push	 DWORD PTR _WorkItemReadyEvent
  00178	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
  0017e	8b 75 fc	 mov	 esi, DWORD PTR _fragmentCount$1$[ebp]
  00181	8b 4d 14	 mov	 ecx, DWORD PTR _firstFragmentWorkItem$1$[ebp]
  00184	8b 55 f0	 mov	 edx, DWORD PTR tv278[ebp]
  00187	85 f6		 test	 esi, esi
  00189	0f 85 32 ff ff
	ff		 jne	 $LL6@Encryption
$LN35@Encryption:

; 567  : 	}
; 568  : 
; 569  : 	GST_RELEASE_MUTEX (&EnqueueMutex);

  0018f	ff 35 00 00 00
	00		 push	 DWORD PTR _EnqueueMutex
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 570  : 
; 571  : 	GST_WAIT_EVENT (firstFragmentWorkItem->ItemCompletedEvent);

  0019b	8b 75 14	 mov	 esi, DWORD PTR _firstFragmentWorkItem$1$[ebp]
  0019e	6a ff		 push	 -1
  001a0	ff 76 08	 push	 DWORD PTR [esi+8]
  001a3	ff d3		 call	 ebx

; 572  : 	SetWorkItemState (firstFragmentWorkItem, WorkItemFree);

  001a5	33 c0		 xor	 eax, eax
  001a7	87 06		 xchg	 DWORD PTR [esi], eax

; 573  : 	GST_SET_EVENT (WorkItemCompletedEvent);

  001a9	ff 35 00 00 00
	00		 push	 DWORD PTR _WorkItemCompletedEvent
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4
  001b5	5f		 pop	 edi
  001b6	5e		 pop	 esi
  001b7	5b		 pop	 ebx

; 574  : }

  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c3		 ret	 0
$LN12@Encryption:

; 489  : 	{
; 490  : 		switch (type)

  001bc	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
  001bf	83 e9 00	 sub	 ecx, 0
  001c2	74 28		 je	 SHORT $LN14@Encryption
  001c4	83 e9 01	 sub	 ecx, 1
  001c7	74 0b		 je	 SHORT $LN13@Encryption

; 498  : 			break;
; 499  : 
; 500  : 		default:
; 501  : 			GST_THROW_FATAL_EXCEPTION;

  001c9	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0

; 574  : }

  001d0	8b e5		 mov	 esp, ebp
  001d2	5d		 pop	 ebp
  001d3	c3		 ret	 0
$LN13@Encryption:

; 491  : 		{
; 492  : 		case DecryptDataUnitsWork:
; 493  : 			DecryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  001d4	ff 75 18	 push	 DWORD PTR _cryptoInfo$[ebp]
  001d7	6a 00		 push	 0
  001d9	50		 push	 eax
  001da	ff 75 10	 push	 DWORD PTR _startUnitNo$[ebp]
  001dd	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  001e0	e8 00 00 00 00	 call	 _DecryptDataUnitsCurrentThread

; 494  : 			break;
; 495  : 
; 496  : 		case EncryptDataUnitsWork:
; 497  : 			EncryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  001e5	83 c4 14	 add	 esp, 20			; 00000014H

; 574  : }

  001e8	8b e5		 mov	 esp, ebp
  001ea	5d		 pop	 ebp
  001eb	c3		 ret	 0
$LN14@Encryption:

; 494  : 			break;
; 495  : 
; 496  : 		case EncryptDataUnitsWork:
; 497  : 			EncryptDataUnitsCurrentThread (data, startUnitNo, unitCount, cryptoInfo);

  001ec	ff 75 18	 push	 DWORD PTR _cryptoInfo$[ebp]
  001ef	6a 00		 push	 0
  001f1	50		 push	 eax
  001f2	ff 75 10	 push	 DWORD PTR _startUnitNo$[ebp]
  001f5	ff 75 0c	 push	 DWORD PTR _data$[ebp]
  001f8	e8 00 00 00 00	 call	 _EncryptDataUnitsCurrentThread
  001fd	83 c4 14	 add	 esp, 20			; 00000014H
$LN2@Encryption:

; 574  : }

  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c3		 ret	 0
_EncryptionThreadPoolDoWork ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\encryptionthreadpool.c
;	COMDAT _EncryptionThreadPoolBeginKeyDerivation
_TEXT	SEGMENT
_completionEvent$ = 8					; size = 4
_noOutstandingWorkItemEvent$ = 12			; size = 4
_completionFlag$ = 16					; size = 4
_outstandingWorkItemCount$ = 20				; size = 4
_pkcs5Prf$ = 24						; size = 4
_password$ = 28						; size = 4
_passwordLength$ = 32					; size = 4
_salt$ = 36						; size = 4
_iterationCount$ = 40					; size = 4
_derivedKey$ = 44					; size = 4
_EncryptionThreadPoolBeginKeyDerivation PROC		; COMDAT

; 423  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 424  : 	EncryptionThreadPoolWorkItem *workItem;
; 425  : 
; 426  : 	if (!ThreadPoolRunning)

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ThreadPoolRunning, 0
  0000a	75 07		 jne	 SHORT $LN4@Encryption

; 427  : 		GST_THROW_FATAL_EXCEPTION;

  0000c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ds:0, 0
$LN4@Encryption:
  00013	56		 push	 esi
  00014	57		 push	 edi

; 428  : 
; 429  : 	GST_ACQUIRE_MUTEX (&EnqueueMutex);

  00015	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WaitForSingleObject@8
  0001b	6a ff		 push	 -1
  0001d	ff 35 00 00 00
	00		 push	 DWORD PTR _EnqueueMutex
  00023	ff d7		 call	 edi

; 430  : 
; 431  : 	workItem = &WorkItemQueue[EnqueuePosition++];

  00025	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _EnqueuePosition
  0002b	ff 05 00 00 00
	00		 inc	 DWORD PTR _EnqueuePosition
  00031	c1 e6 06	 shl	 esi, 6
  00034	81 c6 00 00 00
	00		 add	 esi, OFFSET _WorkItemQueue

; 432  : 	if (EnqueuePosition >= GST_ENC_THREAD_POOL_QUEUE_SIZE)

  0003a	81 3d 00 00 00
	00 80 00 00 00	 cmp	 DWORD PTR _EnqueuePosition, 128 ; 00000080H
  00044	7c 0a		 jl	 SHORT $LN11@Encryption

; 433  : 		EnqueuePosition = 0;

  00046	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _EnqueuePosition, 0
$LN11@Encryption:

; 434  : 
; 435  : 	while (GetWorkItemState (workItem) != WorkItemFree)

  00050	33 c0		 xor	 eax, eax
  00052	f0 0f c1 06	 lock	  xadd	 DWORD PTR [esi], eax
  00056	85 c0		 test	 eax, eax
  00058	74 1a		 je	 SHORT $LN3@Encryption
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL2@Encryption:

; 436  : 	{
; 437  : 		GST_WAIT_EVENT (WorkItemCompletedEvent);

  00060	6a ff		 push	 -1
  00062	ff 35 00 00 00
	00		 push	 DWORD PTR _WorkItemCompletedEvent
  00068	ff d7		 call	 edi
  0006a	33 c0		 xor	 eax, eax
  0006c	f0 0f c1 06	 lock	  xadd	 DWORD PTR [esi], eax
  00070	85 c0		 test	 eax, eax
  00072	75 ec		 jne	 SHORT $LL2@Encryption
$LN3@Encryption:

; 438  : 	}
; 439  : 
; 440  : 	workItem->Type = DeriveKeyWork;
; 441  : 	workItem->KeyDerivation.CompletionEvent = completionEvent;

  00074	8b 45 08	 mov	 eax, DWORD PTR _completionEvent$[ebp]

; 442  : 	workItem->KeyDerivation.CompletionFlag = completionFlag;
; 443  : 	workItem->KeyDerivation.DerivedKey = derivedKey;
; 444  : 	workItem->KeyDerivation.IterationCount = iterationCount;
; 445  : 	workItem->KeyDerivation.NoOutstandingWorkItemEvent = noOutstandingWorkItemEvent;

  00077	8b 55 0c	 mov	 edx, DWORD PTR _noOutstandingWorkItemEvent$[ebp]

; 446  : 	workItem->KeyDerivation.OutstandingWorkItemCount = outstandingWorkItemCount;

  0007a	8b 4d 14	 mov	 ecx, DWORD PTR _outstandingWorkItemCount$[ebp]
  0007d	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00080	8b 45 10	 mov	 eax, DWORD PTR _completionFlag$[ebp]
  00083	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00086	8b 45 2c	 mov	 eax, DWORD PTR _derivedKey$[ebp]
  00089	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0008c	8b 45 28	 mov	 eax, DWORD PTR _iterationCount$[ebp]
  0008f	89 46 24	 mov	 DWORD PTR [esi+36], eax

; 447  : 	workItem->KeyDerivation.Password = password;

  00092	8b 45 1c	 mov	 eax, DWORD PTR _password$[ebp]
  00095	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 448  : 	workItem->KeyDerivation.PasswordLength = passwordLength;

  00098	8b 45 20	 mov	 eax, DWORD PTR _passwordLength$[ebp]
  0009b	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 449  : 	workItem->KeyDerivation.Pkcs5Prf = pkcs5Prf;

  0009e	8b 45 18	 mov	 eax, DWORD PTR _pkcs5Prf$[ebp]
  000a1	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 450  : 	workItem->KeyDerivation.Salt = salt;

  000a4	8b 45 24	 mov	 eax, DWORD PTR _salt$[ebp]
  000a7	c7 46 04 02 00
	00 00		 mov	 DWORD PTR [esi+4], 2
  000ae	89 56 28	 mov	 DWORD PTR [esi+40], edx
  000b1	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  000b4	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 451  : 
; 452  : 	InterlockedIncrement (outstandingWorkItemCount);

  000b7	f0 ff 01	 lock	  inc	 DWORD PTR [ecx]

; 453  : 	GST_CLEAR_EVENT (*noOutstandingWorkItemEvent);

  000ba	ff 32		 push	 DWORD PTR [edx]
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResetEvent@4

; 454  : 
; 455  : 	SetWorkItemState (workItem, WorkItemReady);

  000c2	b8 01 00 00 00	 mov	 eax, 1
  000c7	87 06		 xchg	 DWORD PTR [esi], eax

; 456  : 	GST_SET_EVENT (WorkItemReadyEvent);

  000c9	ff 35 00 00 00
	00		 push	 DWORD PTR _WorkItemReadyEvent
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEvent@4

; 457  : 	GST_RELEASE_MUTEX (&EnqueueMutex);

  000d5	ff 35 00 00 00
	00		 push	 DWORD PTR _EnqueueMutex
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi

; 458  : }

  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
_EncryptionThreadPoolBeginKeyDerivation ENDP
_TEXT	ENDS
END
