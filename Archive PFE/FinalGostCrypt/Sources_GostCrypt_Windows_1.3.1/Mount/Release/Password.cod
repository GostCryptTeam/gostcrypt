; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	C:\Users\Alexis\Documents\FinalGostCrypt\Sources_GostCrypt_Windows_1.3.1\Common\Password.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_VerifyPasswordAndUpdate
PUBLIC	_CheckPasswordLength
PUBLIC	_CheckPasswordCharEncoding
PUBLIC	_ChangePwd
PUBLIC	??_C@_0BI@FPFPGNBO@PASSWORD_LENGTH_WARNING?$AA@	; `string'
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__FlushFileBuffers@4:PROC
EXTRN	__imp__GetFileSizeEx@8:PROC
EXTRN	__imp__GetFileTime@16:PROC
EXTRN	__imp__SetFilePointerEx@20:PROC
EXTRN	__imp__SetFileTime@16:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__EnableWindow@8:PROC
EXTRN	__imp__GetWindowTextA@12:PROC
EXTRN	__imp__GetWindowTextW@12:PROC
EXTRN	__imp__GetWindowTextLengthA@4:PROC
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	_crypto_close:PROC
EXTRN	_ReadVolumeHeader:PROC
EXTRN	_CreateVolumeHeaderInMemory:PROC
EXTRN	_ReadEffectiveVolumeHeader:PROC
EXTRN	_WriteEffectiveVolumeHeader:PROC
EXTRN	_WriteRandomDataToReservedHeaderAreas:PROC
EXTRN	_CreateFullVolumePath:PROC
EXTRN	_FakeDosNameForDevice:PROC
EXTRN	_RemoveFakeDosName:PROC
EXTRN	_WaitCursor:PROC
EXTRN	_NormalCursor:PROC
EXTRN	_UserEnrichRandomPool:PROC
EXTRN	_handleError:PROC
EXTRN	_IsUacSupported:PROC
EXTRN	_GetPartitionInfo:PROC
EXTRN	_EnableElevatedCursorChange:PROC
EXTRN	_GetString:PROC
EXTRN	_Randinit:PROC
EXTRN	_RandStop:PROC
EXTRN	_RandSetHashFunction:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__allmul:PROC
EXTRN	_memset:PROC
EXTRN	_bPreserveTimestamp:DWORD
EXTRN	_lpszTitle:DWORD
EXTRN	_UacElevated:DWORD
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_0BI@FPFPGNBO@PASSWORD_LENGTH_WARNING?$AA@
CONST	SEGMENT
??_C@_0BI@FPFPGNBO@PASSWORD_LENGTH_WARNING?$AA@ DB 'PASSWORD_LENGTH_WARNI'
	DB	'NG', 00H					; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\password.c
;	COMDAT _ChangePwd
_TEXT	SEGMENT
_ftCreationTime$ = -1456				; size = 8
_ftLastAccessTime$ = -1448				; size = 8
_ftLastWriteTime$ = -1440				; size = 8
_dwResult$1 = -1432					; size = 4
tv258 = -1428						; size = 8
_fileSize$2 = -1420					; size = 8
_bytesRead$ = -1412					; size = 4
_hwndDlg$GSCopy$1$ = -1408				; size = 4
_nDosLinkCreated$1$ = -1404				; size = 4
_bTimeStampValid$1$ = -1400				; size = 4
_ci$ = -1396						; size = 4
_volumeType$1$ = -1392					; size = 4
_newPassword$GSCopy$1$ = -1388				; size = 4
_dwError$1$ = -1388					; size = 4
_oldPassword$GSCopy$1$ = -1384				; size = 4
_backupHeader$1$ = -1384				; size = 4
_hostSize$2$ = -1380					; size = 4
_hostSize$1$ = -1376					; size = 4
_headerOffset$ = -1372					; size = 8
_headerOffset$1$ = -1368				; size = 4
_headerOffset$2$ = -1364				; size = 4
_bDevice$ = -1360					; size = 4
_cryptoInfo$ = -1356					; size = 4
_diskInfo$3 = -1352					; size = 32
_driveInfo$ = -1320					; size = 24
_szDosDevice$ = -1296					; size = 260
_szCFDevice$ = -1036					; size = 260
_buffer$ = -776						; size = 512
_szDiskFile$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_lpszVolume$ = 8					; size = 4
_oldPassword$ = 12					; size = 4
_newPassword$ = 16					; size = 4
_pkcs5$ = 20						; size = 4
_hwndDlg$ = 24						; size = 4
_ChangePwd PROC						; COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 05 00
	00		 sub	 esp, 1456		; 000005b0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _oldPassword$[ebp]
  00016	8b 4d 10	 mov	 ecx, DWORD PTR _newPassword$[ebp]
  00019	8b 55 18	 mov	 edx, DWORD PTR _hwndDlg$[ebp]
  0001c	53		 push	 ebx
  0001d	8b 5d 08	 mov	 ebx, DWORD PTR _lpszVolume$[ebp]
  00020	56		 push	 esi
  00021	57		 push	 edi

; 194  : 	int nDosLinkCreated = 1, nStatus = ERR_OS_ERROR;
; 195  : 	char szDiskFile[GST_MAX_PATH], szCFDevice[GST_MAX_PATH];
; 196  : 	char szDosDevice[GST_MAX_PATH];
; 197  : 	char buffer[GST_VOLUME_HEADER_EFFECTIVE_SIZE];
; 198  : 	PCRYPTO_INFO cryptoInfo = NULL, ci = NULL;
; 199  : 	void *dev = INVALID_HANDLE_VALUE;

  00022	83 cf ff	 or	 edi, -1
  00025	89 85 98 fa ff
	ff		 mov	 DWORD PTR _oldPassword$GSCopy$1$[ebp], eax

; 200  : 	DWORD dwError;
; 201  : 	DWORD bytesRead;
; 202  : 	BOOL bDevice;
; 203  : 	unsigned __int64 hostSize = 0;
; 204  : 	int volumeType;
; 205  : 	int wipePass;
; 206  : 	FILETIME ftCreationTime;
; 207  : 	FILETIME ftLastWriteTime;
; 208  : 	FILETIME ftLastAccessTime;
; 209  : 	BOOL bTimeStampValid = FALSE;
; 210  : 	LARGE_INTEGER headerOffset;
; 211  : 	BOOL backupHeader;
; 212  : 	DISK_GEOMETRY driveInfo;
; 213  : 
; 214  : 	if (oldPassword->Length == 0 || newPassword->Length == 0) return -1;

  0002b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002e	be 01 00 00 00	 mov	 esi, 1
  00033	89 8d 94 fa ff
	ff		 mov	 DWORD PTR _newPassword$GSCopy$1$[ebp], ecx
  00039	89 95 80 fa ff
	ff		 mov	 DWORD PTR _hwndDlg$GSCopy$1$[ebp], edx
  0003f	c7 85 84 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR _nDosLinkCreated$1$[ebp], 1
  00049	c7 85 b4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _cryptoInfo$[ebp], 0
  00053	c7 85 8c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _ci$[ebp], 0
  0005d	c7 85 88 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _bTimeStampValid$1$[ebp], 0
  00067	0f 84 7b 06 00
	00		 je	 $LN18@ChangePwd
  0006d	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00070	0f 84 72 06 00
	00		 je	 $LN18@ChangePwd

; 215  : 
; 216  : 	WaitCursor ();

  00076	e8 00 00 00 00	 call	 _WaitCursor

; 217  : 
; 218  : 	CreateFullVolumePath (szDiskFile, lpszVolume, &bDevice);

  0007b	8d 85 b0 fa ff
	ff		 lea	 eax, DWORD PTR _bDevice$[ebp]
  00081	50		 push	 eax
  00082	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szDiskFile$[ebp]
  00088	53		 push	 ebx
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 _CreateFullVolumePath
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 219  : 
; 220  : 	if (bDevice == FALSE)

  00092	83 bd b0 fa ff
	ff 00		 cmp	 DWORD PTR _bDevice$[ebp], 0
  00099	75 1c		 jne	 SHORT $LN19@ChangePwd

; 221  : 	{
; 222  : 		strcpy (szCFDevice, szDiskFile);

  0009b	33 c9		 xor	 ecx, ecx
  0009d	0f 1f 00	 npad	 3
$LL67@ChangePwd:
  000a0	8a 84 0d f8 fe
	ff ff		 mov	 al, BYTE PTR _szDiskFile$[ebp+ecx]
  000a7	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000aa	88 84 0d f3 fb
	ff ff		 mov	 BYTE PTR _szCFDevice$[ebp+ecx-1], al
  000b1	84 c0		 test	 al, al
  000b3	75 eb		 jne	 SHORT $LL67@ChangePwd

; 223  : 	}

  000b5	eb 2d		 jmp	 SHORT $LN21@ChangePwd
$LN19@ChangePwd:

; 224  : 	else
; 225  : 	{
; 226  : 		nDosLinkCreated = FakeDosNameForDevice (szDiskFile, szDosDevice, szCFDevice, FALSE);

  000b7	6a 00		 push	 0
  000b9	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _szCFDevice$[ebp]
  000bf	50		 push	 eax
  000c0	8d 85 f0 fa ff
	ff		 lea	 eax, DWORD PTR _szDosDevice$[ebp]
  000c6	50		 push	 eax
  000c7	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szDiskFile$[ebp]
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 _FakeDosNameForDevice
  000d3	83 c4 10	 add	 esp, 16			; 00000010H
  000d6	89 85 84 fa ff
	ff		 mov	 DWORD PTR _nDosLinkCreated$1$[ebp], eax

; 227  : 		
; 228  : 		if (nDosLinkCreated != 0)

  000dc	85 c0		 test	 eax, eax
  000de	0f 85 f1 04 00
	00		 jne	 $error$123
$LN21@ChangePwd:

; 229  : 			goto error;
; 230  : 	}
; 231  : 
; 232  : 	dev = CreateFile (szCFDevice, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

  000e4	6a 00		 push	 0
  000e6	6a 00		 push	 0
  000e8	6a 03		 push	 3
  000ea	6a 00		 push	 0
  000ec	6a 03		 push	 3
  000ee	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  000f3	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _szCFDevice$[ebp]
  000f9	50		 push	 eax
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00100	8b f8		 mov	 edi, eax

; 233  : 
; 234  : 	if (dev == INVALID_HANDLE_VALUE) 

  00102	83 ff ff	 cmp	 edi, -1
  00105	0f 84 ca 04 00
	00		 je	 $error$123

; 235  : 		goto error;
; 236  : 
; 237  : 	if (bDevice)

  0010b	83 bd b0 fa ff
	ff 00		 cmp	 DWORD PTR _bDevice$[ebp], 0
  00112	0f 84 a4 00 00
	00		 je	 $LN23@ChangePwd

; 238  : 	{
; 239  : 		/* This is necessary to determine the hidden volume header offset */
; 240  : 
; 241  : 		if (dev == INVALID_HANDLE_VALUE)
; 242  : 		{
; 243  : 			goto error;
; 244  : 		}
; 245  : 		else
; 246  : 		{
; 247  : 			PARTITION_INFORMATION diskInfo;
; 248  : 			DWORD dwResult;
; 249  : 			BOOL bResult;
; 250  : 
; 251  : 			bResult = DeviceIoControl (dev, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0,

  00118	6a 00		 push	 0
  0011a	8d 85 68 fa ff
	ff		 lea	 eax, DWORD PTR _dwResult$1[ebp]
  00120	50		 push	 eax
  00121	6a 18		 push	 24			; 00000018H
  00123	8d 85 d8 fa ff
	ff		 lea	 eax, DWORD PTR _driveInfo$[ebp]
  00129	50		 push	 eax
  0012a	6a 00		 push	 0
  0012c	6a 00		 push	 0
  0012e	68 00 00 07 00	 push	 458752			; 00070000H
  00133	57		 push	 edi
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32

; 252  : 				&driveInfo, sizeof (driveInfo), &dwResult, NULL);
; 253  : 
; 254  : 			if (!bResult)

  0013a	85 c0		 test	 eax, eax
  0013c	0f 84 93 04 00
	00		 je	 $error$123

; 255  : 				goto error;
; 256  : 
; 257  : 			bResult = GetPartitionInfo (lpszVolume, &diskInfo);

  00142	8d 85 b8 fa ff
	ff		 lea	 eax, DWORD PTR _diskInfo$3[ebp]
  00148	50		 push	 eax
  00149	53		 push	 ebx
  0014a	e8 00 00 00 00	 call	 _GetPartitionInfo
  0014f	83 c4 08	 add	 esp, 8

; 258  : 
; 259  : 			if (bResult)

  00152	85 c0		 test	 eax, eax
  00154	74 1a		 je	 SHORT $LN28@ChangePwd

; 260  : 			{
; 261  : 				hostSize = diskInfo.PartitionLength.QuadPart;

  00156	8b 9d c0 fa ff
	ff		 mov	 ebx, DWORD PTR _diskInfo$3[ebp+8]
  0015c	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _diskInfo$3[ebp+12]
  00162	89 9d a0 fa ff
	ff		 mov	 DWORD PTR _hostSize$1$[ebp], ebx
  00168	89 85 9c fa ff
	ff		 mov	 DWORD PTR _hostSize$2$[ebp], eax

; 262  : 			}

  0016e	eb 3e		 jmp	 SHORT $LN29@ChangePwd
$LN28@ChangePwd:

; 263  : 			else
; 264  : 			{
; 265  : 				hostSize = driveInfo.Cylinders.QuadPart * driveInfo.BytesPerSector *

  00170	8b 85 e4 fa ff
	ff		 mov	 eax, DWORD PTR _driveInfo$[ebp+12]
  00176	f7 a5 e8 fa ff
	ff		 mul	 DWORD PTR _driveInfo$[ebp+16]
  0017c	6a 00		 push	 0
  0017e	ff b5 ec fa ff
	ff		 push	 DWORD PTR _driveInfo$[ebp+20]
  00184	52		 push	 edx
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 __allmul
  0018b	ff b5 dc fa ff
	ff		 push	 DWORD PTR _driveInfo$[ebp+4]
  00191	ff b5 d8 fa ff
	ff		 push	 DWORD PTR _driveInfo$[ebp]
  00197	52		 push	 edx
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 __allmul
  0019e	8b d8		 mov	 ebx, eax
  001a0	89 85 a0 fa ff
	ff		 mov	 DWORD PTR _hostSize$1$[ebp], eax
  001a6	8b c2		 mov	 eax, edx
  001a8	89 95 9c fa ff
	ff		 mov	 DWORD PTR _hostSize$2$[ebp], edx
$LN29@ChangePwd:

; 266  : 					driveInfo.SectorsPerTrack * driveInfo.TracksPerCylinder;
; 267  : 			}
; 268  : 
; 269  : 			if (hostSize == 0)

  001ae	8b cb		 mov	 ecx, ebx
  001b0	0b c8		 or	 ecx, eax
  001b2	75 36		 jne	 SHORT $LN24@ChangePwd

; 270  : 			{
; 271  : 				nStatus = ERR_VOL_SIZE_WRONG;

  001b4	8d 71 07	 lea	 esi, DWORD PTR [ecx+7]

; 272  : 				goto error;

  001b7	e9 19 04 00 00	 jmp	 $error$123
$LN23@ChangePwd:

; 273  : 			}
; 274  : 		}
; 275  : 	}
; 276  : 	else
; 277  : 	{
; 278  : 		LARGE_INTEGER fileSize;
; 279  : 		if (!GetFileSizeEx (dev, &fileSize))

  001bc	8d 85 74 fa ff
	ff		 lea	 eax, DWORD PTR _fileSize$2[ebp]
  001c2	50		 push	 eax
  001c3	57		 push	 edi
  001c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSizeEx@8
  001ca	85 c0		 test	 eax, eax
  001cc	0f 84 03 04 00
	00		 je	 $error$123

; 280  : 		{
; 281  : 			nStatus = ERR_OS_ERROR;
; 282  : 			goto error;
; 283  : 		}
; 284  : 
; 285  : 		hostSize = fileSize.QuadPart;

  001d2	8b 85 74 fa ff
	ff		 mov	 eax, DWORD PTR _fileSize$2[ebp]
  001d8	89 85 a0 fa ff
	ff		 mov	 DWORD PTR _hostSize$1$[ebp], eax
  001de	8b 85 78 fa ff
	ff		 mov	 eax, DWORD PTR _fileSize$2[ebp+4]
  001e4	89 85 9c fa ff
	ff		 mov	 DWORD PTR _hostSize$2$[ebp], eax
$LN24@ChangePwd:

; 286  : 	}
; 287  : 
; 288  : 	if (Randinit ())

  001ea	e8 00 00 00 00	 call	 _Randinit
  001ef	85 c0		 test	 eax, eax
  001f1	0f 85 de 03 00
	00		 jne	 $error$123

; 289  : 		goto error;
; 290  : 
; 291  : 	if (!bDevice && bPreserveTimestamp)

  001f7	39 85 b0 fa ff
	ff		 cmp	 DWORD PTR _bDevice$[ebp], eax
  001fd	75 30		 jne	 SHORT $LN34@ChangePwd
  001ff	39 05 00 00 00
	00		 cmp	 DWORD PTR _bPreserveTimestamp, eax
  00205	74 28		 je	 SHORT $LN34@ChangePwd

; 292  : 	{
; 293  : 		if (GetFileTime ((HANDLE) dev, &ftCreationTime, &ftLastAccessTime, &ftLastWriteTime) == 0)

  00207	8d 85 60 fa ff
	ff		 lea	 eax, DWORD PTR _ftLastWriteTime$[ebp]
  0020d	50		 push	 eax
  0020e	8d 85 58 fa ff
	ff		 lea	 eax, DWORD PTR _ftLastAccessTime$[ebp]
  00214	50		 push	 eax
  00215	8d 85 50 fa ff
	ff		 lea	 eax, DWORD PTR _ftCreationTime$[ebp]
  0021b	50		 push	 eax
  0021c	57		 push	 edi
  0021d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileTime@16
  00223	f7 d8		 neg	 eax
  00225	1b c0		 sbb	 eax, eax
  00227	f7 d8		 neg	 eax
  00229	89 85 88 fa ff
	ff		 mov	 DWORD PTR _bTimeStampValid$1$[ebp], eax
$LN34@ChangePwd:

; 294  : 			bTimeStampValid = FALSE;
; 295  : 		else
; 296  : 			bTimeStampValid = TRUE;
; 297  : 	}
; 298  : 
; 299  : 	for (volumeType = GST_VOLUME_TYPE_NORMAL; volumeType < GST_VOLUME_TYPE_COUNT; volumeType++)

  0022f	8b 8d a8 fa ff
	ff		 mov	 ecx, DWORD PTR _headerOffset$[ebp+4]
  00235	33 db		 xor	 ebx, ebx
  00237	8b 95 a4 fa ff
	ff		 mov	 edx, DWORD PTR _headerOffset$[ebp]
  0023d	89 9d 90 fa ff
	ff		 mov	 DWORD PTR _volumeType$1$[ebp], ebx
  00243	89 8d ac fa ff
	ff		 mov	 DWORD PTR _headerOffset$2$[ebp], ecx
  00249	89 95 a8 fa ff
	ff		 mov	 DWORD PTR _headerOffset$1$[ebp], edx
  0024f	90		 npad	 1
$LL4@ChangePwd:

; 300  : 	{
; 301  : 		// Seek the volume header
; 302  : 		switch (volumeType)

  00250	8b c3		 mov	 eax, ebx
  00252	83 e8 00	 sub	 eax, 0
  00255	74 61		 je	 SHORT $LN36@ChangePwd
  00257	83 e8 01	 sub	 eax, 1
  0025a	74 34		 je	 SHORT $LN37@ChangePwd
  0025c	83 e8 01	 sub	 eax, 1
  0025f	75 7a		 jne	 SHORT $LN5@ChangePwd

; 314  : 
; 315  : 		case GST_VOLUME_TYPE_HIDDEN_LEGACY:
; 316  : 			if (bDevice && driveInfo.BytesPerSector != GST_SECTOR_SIZE_LEGACY)

  00261	39 85 b0 fa ff
	ff		 cmp	 DWORD PTR _bDevice$[ebp], eax
  00267	74 10		 je	 SHORT $LN40@ChangePwd
  00269	81 bd ec fa ff
	ff 00 02 00 00	 cmp	 DWORD PTR _driveInfo$[ebp+20], 512 ; 00000200H
  00273	0f 85 f6 00 00
	00		 jne	 $LN2@ChangePwd
$LN40@ChangePwd:

; 317  : 				continue;
; 318  : 
; 319  : 			headerOffset.QuadPart = hostSize - GST_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  00279	8b 95 a0 fa ff
	ff		 mov	 edx, DWORD PTR _hostSize$1$[ebp]
  0027f	8b 8d 9c fa ff
	ff		 mov	 ecx, DWORD PTR _hostSize$2$[ebp]
  00285	81 ea 00 06 00
	00		 sub	 edx, 1536		; 00000600H
  0028b	83 d9 00	 sbb	 ecx, 0
  0028e	eb 3f		 jmp	 SHORT $LN120@ChangePwd
$LN37@ChangePwd:

; 306  : 			break;
; 307  : 
; 308  : 		case GST_VOLUME_TYPE_HIDDEN:
; 309  : 			if (GST_HIDDEN_VOLUME_HEADER_OFFSET + GST_VOLUME_HEADER_SIZE > hostSize)

  00290	83 bd 9c fa ff
	ff 00		 cmp	 DWORD PTR _hostSize$2$[ebp], 0
  00297	0f 82 d2 00 00
	00		 jb	 $LN2@ChangePwd
  0029d	77 10		 ja	 SHORT $LN110@ChangePwd
  0029f	81 bd a0 fa ff
	ff 00 00 02 00	 cmp	 DWORD PTR _hostSize$1$[ebp], 131072 ; 00020000H
  002a9	0f 82 c0 00 00
	00		 jb	 $LN2@ChangePwd
$LN110@ChangePwd:

; 310  : 				continue;
; 311  : 
; 312  : 			headerOffset.QuadPart = GST_HIDDEN_VOLUME_HEADER_OFFSET;

  002af	ba 00 00 01 00	 mov	 edx, 65536		; 00010000H
  002b4	33 c9		 xor	 ecx, ecx

; 313  : 			break;

  002b6	eb 17		 jmp	 SHORT $LN120@ChangePwd
$LN36@ChangePwd:
  002b8	0f 57 c0	 xorps	 xmm0, xmm0

; 303  : 		{
; 304  : 		case GST_VOLUME_TYPE_NORMAL:
; 305  : 			headerOffset.QuadPart = GST_VOLUME_HEADER_OFFSET;

  002bb	66 0f 13 85 a4
	fa ff ff	 movlpd	 QWORD PTR _headerOffset$[ebp], xmm0
  002c3	8b 8d a8 fa ff
	ff		 mov	 ecx, DWORD PTR _headerOffset$[ebp+4]
  002c9	8b 95 a4 fa ff
	ff		 mov	 edx, DWORD PTR _headerOffset$[ebp]
$LN120@ChangePwd:
  002cf	89 8d ac fa ff
	ff		 mov	 DWORD PTR _headerOffset$2$[ebp], ecx
  002d5	89 95 a8 fa ff
	ff		 mov	 DWORD PTR _headerOffset$1$[ebp], edx
$LN5@ChangePwd:

; 320  : 			break;
; 321  : 		}
; 322  : 
; 323  : 		if (!SetFilePointerEx ((HANDLE) dev, headerOffset, NULL, FILE_BEGIN))

  002db	6a 00		 push	 0
  002dd	6a 00		 push	 0
  002df	51		 push	 ecx
  002e0	52		 push	 edx
  002e1	57		 push	 edi
  002e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  002e8	85 c0		 test	 eax, eax
  002ea	0f 84 e0 02 00
	00		 je	 $LN80@ChangePwd

; 326  : 			goto error;
; 327  : 		}
; 328  : 
; 329  : 		/* Read in volume header */
; 330  : 		if (!ReadEffectiveVolumeHeader (bDevice, dev, buffer, &bytesRead))

  002f0	8d 85 7c fa ff
	ff		 lea	 eax, DWORD PTR _bytesRead$[ebp]
  002f6	50		 push	 eax
  002f7	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  002fd	50		 push	 eax
  002fe	57		 push	 edi
  002ff	ff b5 b0 fa ff
	ff		 push	 DWORD PTR _bDevice$[ebp]
  00305	e8 00 00 00 00	 call	 _ReadEffectiveVolumeHeader
  0030a	83 c4 10	 add	 esp, 16			; 00000010H
  0030d	85 c0		 test	 eax, eax
  0030f	0f 84 bb 02 00
	00		 je	 $LN80@ChangePwd

; 331  : 		{
; 332  : 			nStatus = ERR_OS_ERROR;
; 333  : 			goto error;
; 334  : 		}
; 335  : 
; 336  : 		if (bytesRead != sizeof (buffer))

  00315	81 bd 7c fa ff
	ff 00 02 00 00	 cmp	 DWORD PTR _bytesRead$[ebp], 512 ; 00000200H
  0031f	74 16		 je	 SHORT $LN43@ChangePwd

; 337  : 		{
; 338  : 			// Windows may report EOF when reading sectors from the last cluster of a device formatted as NTFS 
; 339  : 			memset (buffer, 0, sizeof (buffer));

  00321	68 00 02 00 00	 push	 512			; 00000200H
  00326	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  0032c	6a 00		 push	 0
  0032e	50		 push	 eax
  0032f	e8 00 00 00 00	 call	 _memset
  00334	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN43@ChangePwd:

; 340  : 		}
; 341  : 
; 342  : 		/* Try to decrypt the header */
; 343  : 
; 344  : 		nStatus = ReadVolumeHeader (FALSE, buffer, oldPassword, &cryptoInfo, NULL);

  00337	6a 00		 push	 0
  00339	8d 85 b4 fa ff
	ff		 lea	 eax, DWORD PTR _cryptoInfo$[ebp]
  0033f	50		 push	 eax
  00340	ff b5 98 fa ff
	ff		 push	 DWORD PTR _oldPassword$GSCopy$1$[ebp]
  00346	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  0034c	50		 push	 eax
  0034d	6a 00		 push	 0
  0034f	e8 00 00 00 00	 call	 _ReadVolumeHeader
  00354	8b f0		 mov	 esi, eax
  00356	83 c4 14	 add	 esp, 20			; 00000014H

; 345  : 		if (nStatus == ERR_CIPHER_INIT_WEAK_KEY)

  00359	83 fe 12	 cmp	 esi, 18			; 00000012H
  0035c	74 34		 je	 SHORT $LN49@ChangePwd

; 346  : 			nStatus = 0;	// We can ignore this error here
; 347  : 
; 348  : 		if (nStatus == ERR_PASSWORD_WRONG)

  0035e	83 fe 03	 cmp	 esi, 3
  00361	75 1c		 jne	 SHORT $LN45@ChangePwd
  00363	8b 8d ac fa ff
	ff		 mov	 ecx, DWORD PTR _headerOffset$2$[ebp]
  00369	8b 95 a8 fa ff
	ff		 mov	 edx, DWORD PTR _headerOffset$1$[ebp]
$LN2@ChangePwd:

; 294  : 			bTimeStampValid = FALSE;
; 295  : 		else
; 296  : 			bTimeStampValid = TRUE;
; 297  : 	}
; 298  : 
; 299  : 	for (volumeType = GST_VOLUME_TYPE_NORMAL; volumeType < GST_VOLUME_TYPE_COUNT; volumeType++)

  0036f	43		 inc	 ebx
  00370	89 9d 90 fa ff
	ff		 mov	 DWORD PTR _volumeType$1$[ebp], ebx
  00376	83 fb 03	 cmp	 ebx, 3
  00379	0f 8c d1 fe ff
	ff		 jl	 $LL4@ChangePwd
$LN45@ChangePwd:

; 349  : 		{
; 350  : 			continue;		// Try next volume type
; 351  : 		}
; 352  : 		else if (nStatus != 0)
; 353  : 		{
; 354  : 			cryptoInfo = NULL;
; 355  : 			goto error;
; 356  : 		}
; 357  : 		else 
; 358  : 			break;
; 359  : 	}
; 360  : 
; 361  : 	if (nStatus != 0)

  0037f	85 f6		 test	 esi, esi
  00381	74 0f		 je	 SHORT $LN49@ChangePwd

; 362  : 	{
; 363  : 		cryptoInfo = NULL;

  00383	c7 85 b4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _cryptoInfo$[ebp], 0

; 364  : 		goto error;

  0038d	e9 43 02 00 00	 jmp	 $error$123
$LN49@ChangePwd:

; 365  : 	}
; 366  : 
; 367  : 	if (cryptoInfo->HeaderFlags & GST_HEADER_FLAG_ENCRYPTED_SYSTEM)

  00392	8b 85 b4 fa ff
	ff		 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00398	f6 80 08 1f 00
	00 01		 test	 BYTE PTR [eax+7944], 1
  0039f	74 0a		 je	 SHORT $LN50@ChangePwd

; 368  : 	{
; 369  : 		nStatus = ERR_SYS_HIDVOL_HEAD_REENC_MODE_WRONG;

  003a1	be 1f 00 00 00	 mov	 esi, 31			; 0000001fH

; 370  : 		goto error;

  003a6	e9 2a 02 00 00	 jmp	 $error$123
$LN50@ChangePwd:

; 371  : 	}
; 372  : 
; 373  : 	// Change the PKCS-5 PRF if requested by user
; 374  : 	if (pkcs5 != 0)

  003ab	8b 4d 14	 mov	 ecx, DWORD PTR _pkcs5$[ebp]
  003ae	85 c9		 test	 ecx, ecx
  003b0	74 0c		 je	 SHORT $LN51@ChangePwd

; 375  : 		cryptoInfo->pkcs5 = pkcs5;

  003b2	89 88 94 1e 00
	00		 mov	 DWORD PTR [eax+7828], ecx
  003b8	8b 85 b4 fa ff
	ff		 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
$LN51@ChangePwd:

; 376  : 
; 377  : 	RandSetHashFunction (cryptoInfo->pkcs5);

  003be	ff b0 94 1e 00
	00		 push	 DWORD PTR [eax+7828]
  003c4	e8 00 00 00 00	 call	 _RandSetHashFunction

; 378  : 
; 379  : 	NormalCursor();

  003c9	e8 00 00 00 00	 call	 _NormalCursor

; 380  : 	UserEnrichRandomPool (hwndDlg);

  003ce	8b 9d 80 fa ff
	ff		 mov	 ebx, DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  003d4	53		 push	 ebx
  003d5	e8 00 00 00 00	 call	 _UserEnrichRandomPool

; 381  : 	EnableElevatedCursorChange (hwndDlg);

  003da	53		 push	 ebx
  003db	e8 00 00 00 00	 call	 _EnableElevatedCursorChange
  003e0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 382  : 	WaitCursor();

  003e3	e8 00 00 00 00	 call	 _WaitCursor

; 383  : 
; 384  : 	/* Re-encrypt the volume header */ 
; 385  : 	backupHeader = FALSE;

  003e8	8b 95 b4 fa ff
	ff		 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  003ee	33 c0		 xor	 eax, eax
  003f0	89 85 98 fa ff
	ff		 mov	 DWORD PTR _backupHeader$1$[ebp], eax
  003f6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL7@ChangePwd:

; 386  : 
; 387  : 	while (TRUE)
; 388  : 	{
; 389  : 		/**
; 390  : 		 *
; 391  : 		 *	The header will be re-encrypted PRAND_DISK_WIPE_PASSES times to prevent adversaries from using 
; 392  : 		 *	techniques such as magnetic force microscopy or magnetic force scanning tunnelling microscopy
; 393  : 		 *	to recover the overwritten header. According to Peter Gutmann, data should be overwritten 22
; 394  : 		 *	times (ideally, 35 times) using non-random patterns and pseudorandom data. However, as users might
; 395  : 		 *	impatiently interupt the process (etc.) we will not use the Gutmann's patterns but will write the
; 396  : 		 *	valid re-encrypted header, i.e. pseudorandom data, and there will be many more passes than Guttman
; 397  : 		 *	recommends. During each pass we will write a valid working header. Each pass will use the same master
; 398  : 		 *	key, and also the same header key, secondary key (XTS), etc., derived from the new password. The only
; 399  : 		 *	item that will be different for each pass will be the salt. This is sufficient to cause each "version"
; 400  : 		 *	of the header to differ substantially and in a random manner from the versions written during the
; 401  : 		 *	other passes. 
; 402  : 		 *
; 403  : 		 */
; 404  : 
; 405  : 		for (wipePass = 0; wipePass < PRAND_DISK_WIPE_PASSES; wipePass++)

  00400	33 db		 xor	 ebx, ebx
$LL11@ChangePwd:

; 406  : 		{
; 407  : 			// Prepare new volume header
; 408  : 			nStatus = CreateVolumeHeaderInMemory (FALSE,

  00402	8b 85 90 fa ff
	ff		 mov	 eax, DWORD PTR _volumeType$1$[ebp]
  00408	83 f8 01	 cmp	 eax, 1
  0040b	74 1e		 je	 SHORT $LN68@ChangePwd
  0040d	83 f8 02	 cmp	 eax, 2
  00410	74 19		 je	 SHORT $LN68@ChangePwd
  00412	0f 57 c0	 xorps	 xmm0, xmm0
  00415	66 0f 13 85 6c
	fa ff ff	 movlpd	 QWORD PTR tv258[ebp], xmm0
  0041d	8b 8d 70 fa ff
	ff		 mov	 ecx, DWORD PTR tv258[ebp+4]
  00423	8b b5 6c fa ff
	ff		 mov	 esi, DWORD PTR tv258[ebp]
  00429	eb 0c		 jmp	 SHORT $LN69@ChangePwd
$LN68@ChangePwd:
  0042b	8b b2 b8 1e 00
	00		 mov	 esi, DWORD PTR [edx+7864]
  00431	8b 8a bc 1e 00
	00		 mov	 ecx, DWORD PTR [edx+7868]
$LN69@ChangePwd:
  00437	33 c0		 xor	 eax, eax
  00439	81 fb ff 00 00
	00		 cmp	 ebx, 255		; 000000ffH
  0043f	0f 9c c0	 setl	 al
  00442	50		 push	 eax
  00443	ff b2 e8 1e 00
	00		 push	 DWORD PTR [edx+7912]
  00449	0f b7 82 e0 1e
	00 00		 movzx	 eax, WORD PTR [edx+7904]
  00450	ff b2 08 1f 00
	00		 push	 DWORD PTR [edx+7944]
  00456	50		 push	 eax
  00457	ff b2 04 1f 00
	00		 push	 DWORD PTR [edx+7940]
  0045d	8d 85 8c fa ff
	ff		 lea	 eax, DWORD PTR _ci$[ebp]
  00463	ff b2 00 1f 00
	00		 push	 DWORD PTR [edx+7936]
  00469	ff b2 fc 1e 00
	00		 push	 DWORD PTR [edx+7932]
  0046f	ff b2 f8 1e 00
	00		 push	 DWORD PTR [edx+7928]
  00475	51		 push	 ecx
  00476	56		 push	 esi
  00477	ff b2 f4 1e 00
	00		 push	 DWORD PTR [edx+7924]
  0047d	ff b2 f0 1e 00
	00		 push	 DWORD PTR [edx+7920]
  00483	50		 push	 eax
  00484	8d 82 50 1c 00
	00		 lea	 eax, DWORD PTR [edx+7248]
  0048a	50		 push	 eax
  0048b	ff b2 94 1e 00
	00		 push	 DWORD PTR [edx+7828]
  00491	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  00497	ff b5 94 fa ff
	ff		 push	 DWORD PTR _newPassword$GSCopy$1$[ebp]
  0049d	ff 72 04	 push	 DWORD PTR [edx+4]
  004a0	ff 32		 push	 DWORD PTR [edx]
  004a2	50		 push	 eax
  004a3	6a 00		 push	 0
  004a5	e8 00 00 00 00	 call	 _CreateVolumeHeaderInMemory
  004aa	8b f0		 mov	 esi, eax
  004ac	83 c4 50	 add	 esp, 80			; 00000050H

; 409  : 				buffer,
; 410  : 				cryptoInfo->ea,
; 411  : 				cryptoInfo->mode,
; 412  : 				newPassword,
; 413  : 				cryptoInfo->pkcs5,
; 414  : 				cryptoInfo->master_keydata,
; 415  : 				&ci,
; 416  : 				cryptoInfo->VolumeSize.Value,
; 417  : 				(volumeType == GST_VOLUME_TYPE_HIDDEN || volumeType == GST_VOLUME_TYPE_HIDDEN_LEGACY) ? cryptoInfo->hiddenVolumeSize : 0,
; 418  : 				cryptoInfo->EncryptedAreaStart.Value,
; 419  : 				cryptoInfo->EncryptedAreaLength.Value,
; 420  : 				cryptoInfo->RequiredProgramVersion,
; 421  : 				cryptoInfo->HeaderFlags,
; 422  : 				cryptoInfo->SectorSize,
; 423  : 				wipePass < PRAND_DISK_WIPE_PASSES - 1);
; 424  : 
; 425  : 			if (ci != NULL)

  004af	8b 85 8c fa ff
	ff		 mov	 eax, DWORD PTR _ci$[ebp]
  004b5	85 c0		 test	 eax, eax
  004b7	74 09		 je	 SHORT $LN52@ChangePwd

; 426  : 				crypto_close (ci);

  004b9	50		 push	 eax
  004ba	e8 00 00 00 00	 call	 _crypto_close
  004bf	83 c4 04	 add	 esp, 4
$LN52@ChangePwd:

; 427  : 
; 428  : 			if (nStatus != 0)

  004c2	85 f6		 test	 esi, esi
  004c4	0f 85 0b 01 00
	00		 jne	 $error$123

; 429  : 				goto error;
; 430  : 
; 431  : 			if (!SetFilePointerEx ((HANDLE) dev, headerOffset, NULL, FILE_BEGIN))

  004ca	56		 push	 esi
  004cb	56		 push	 esi
  004cc	8b b5 ac fa ff
	ff		 mov	 esi, DWORD PTR _headerOffset$2$[ebp]
  004d2	56		 push	 esi
  004d3	ff b5 a8 fa ff
	ff		 push	 DWORD PTR _headerOffset$1$[ebp]
  004d9	57		 push	 edi
  004da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointerEx@20
  004e0	85 c0		 test	 eax, eax
  004e2	0f 84 e8 00 00
	00		 je	 $LN80@ChangePwd

; 432  : 			{
; 433  : 				nStatus = ERR_OS_ERROR;
; 434  : 				goto error;
; 435  : 			}
; 436  : 
; 437  : 			if (!WriteEffectiveVolumeHeader (bDevice, dev, buffer))

  004e8	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  004ee	50		 push	 eax
  004ef	57		 push	 edi
  004f0	ff b5 b0 fa ff
	ff		 push	 DWORD PTR _bDevice$[ebp]
  004f6	e8 00 00 00 00	 call	 _WriteEffectiveVolumeHeader
  004fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  004fe	85 c0		 test	 eax, eax
  00500	0f 84 ca 00 00
	00		 je	 $LN80@ChangePwd

; 441  : 			}
; 442  : 
; 443  : 			if (bDevice
; 444  : 				&& !cryptoInfo->LegacyVolume
; 445  : 				&& !cryptoInfo->hiddenVolume
; 446  : 				&& cryptoInfo->HeaderVersion == 4
; 447  : 				&& (cryptoInfo->HeaderFlags & GST_HEADER_FLAG_NONSYS_INPLACE_ENC) != 0
; 448  : 				&& (cryptoInfo->HeaderFlags & ~GST_HEADER_FLAG_NONSYS_INPLACE_ENC) == 0)

  00506	83 bd b0 fa ff
	ff 00		 cmp	 DWORD PTR _bDevice$[ebp], 0
  0050d	74 58		 je	 SHORT $LN57@ChangePwd
  0050f	8b 8d b4 fa ff
	ff		 mov	 ecx, DWORD PTR _cryptoInfo$[ebp]
  00515	83 b9 e4 1e 00
	00 00		 cmp	 DWORD PTR [ecx+7908], 0
  0051c	75 49		 jne	 SHORT $LN57@ChangePwd
  0051e	83 b9 48 04 00
	00 00		 cmp	 DWORD PTR [ecx+1096], 0
  00525	75 40		 jne	 SHORT $LN57@ChangePwd
  00527	66 83 b9 4c 04
	00 00 04	 cmp	 WORD PTR [ecx+1100], 4
  0052f	75 36		 jne	 SHORT $LN57@ChangePwd
  00531	83 b9 08 1f 00
	00 02		 cmp	 DWORD PTR [ecx+7944], 2
  00538	75 2d		 jne	 SHORT $LN57@ChangePwd

; 449  : 			{
; 450  : 				nStatus = WriteRandomDataToReservedHeaderAreas (dev, cryptoInfo, cryptoInfo->VolumeSize.Value, !backupHeader, backupHeader);

  0053a	8b 85 98 fa ff
	ff		 mov	 eax, DWORD PTR _backupHeader$1$[ebp]
  00540	50		 push	 eax
  00541	83 f0 01	 xor	 eax, 1
  00544	50		 push	 eax
  00545	ff b1 f4 1e 00
	00		 push	 DWORD PTR [ecx+7924]
  0054b	ff b1 f0 1e 00
	00		 push	 DWORD PTR [ecx+7920]
  00551	51		 push	 ecx
  00552	57		 push	 edi
  00553	e8 00 00 00 00	 call	 _WriteRandomDataToReservedHeaderAreas
  00558	8b f0		 mov	 esi, eax
  0055a	83 c4 18	 add	 esp, 24			; 00000018H

; 451  : 				if (nStatus != ERR_SUCCESS)

  0055d	85 f6		 test	 esi, esi
  0055f	75 74		 jne	 SHORT $error$123
  00561	8b b5 ac fa ff
	ff		 mov	 esi, DWORD PTR _headerOffset$2$[ebp]
$LN57@ChangePwd:

; 452  : 					goto error;
; 453  : 			}
; 454  : 
; 455  : 			FlushFileBuffers (dev);

  00567	57		 push	 edi
  00568	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FlushFileBuffers@4
  0056e	43		 inc	 ebx
  0056f	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  00575	7d 0b		 jge	 SHORT $LN118@ChangePwd

; 386  : 
; 387  : 	while (TRUE)
; 388  : 	{
; 389  : 		/**
; 390  : 		 *
; 391  : 		 *	The header will be re-encrypted PRAND_DISK_WIPE_PASSES times to prevent adversaries from using 
; 392  : 		 *	techniques such as magnetic force microscopy or magnetic force scanning tunnelling microscopy
; 393  : 		 *	to recover the overwritten header. According to Peter Gutmann, data should be overwritten 22
; 394  : 		 *	times (ideally, 35 times) using non-random patterns and pseudorandom data. However, as users might
; 395  : 		 *	impatiently interupt the process (etc.) we will not use the Gutmann's patterns but will write the
; 396  : 		 *	valid re-encrypted header, i.e. pseudorandom data, and there will be many more passes than Guttman
; 397  : 		 *	recommends. During each pass we will write a valid working header. Each pass will use the same master
; 398  : 		 *	key, and also the same header key, secondary key (XTS), etc., derived from the new password. The only
; 399  : 		 *	item that will be different for each pass will be the salt. This is sufficient to cause each "version"
; 400  : 		 *	of the header to differ substantially and in a random manner from the versions written during the
; 401  : 		 *	other passes. 
; 402  : 		 *
; 403  : 		 */
; 404  : 
; 405  : 		for (wipePass = 0; wipePass < PRAND_DISK_WIPE_PASSES; wipePass++)

  00577	8b 95 b4 fa ff
	ff		 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  0057d	e9 80 fe ff ff	 jmp	 $LL11@ChangePwd
$LN118@ChangePwd:
  00582	8b 85 98 fa ff
	ff		 mov	 eax, DWORD PTR _backupHeader$1$[ebp]
  00588	85 c0		 test	 eax, eax

; 456  : 		}
; 457  : 
; 458  : 		if (backupHeader || cryptoInfo->LegacyVolume)

  0058a	75 40		 jne	 SHORT $LN86@ChangePwd
  0058c	8b 95 b4 fa ff
	ff		 mov	 edx, DWORD PTR _cryptoInfo$[ebp]
  00592	39 82 e4 1e 00
	00		 cmp	 DWORD PTR [edx+7908], eax
  00598	75 32		 jne	 SHORT $LN86@ChangePwd

; 459  : 			break;
; 460  : 			
; 461  : 		backupHeader = TRUE;
; 462  : 		headerOffset.QuadPart += hostSize - GST_VOLUME_HEADER_GROUP_SIZE;

  0059a	8b 8d a0 fa ff
	ff		 mov	 ecx, DWORD PTR _hostSize$1$[ebp]
  005a0	8b 85 9c fa ff
	ff		 mov	 eax, DWORD PTR _hostSize$2$[ebp]
  005a6	81 e9 00 00 02
	00		 sub	 ecx, 131072		; 00020000H
  005ac	c7 85 98 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR _backupHeader$1$[ebp], 1
  005b6	83 d8 00	 sbb	 eax, 0
  005b9	01 8d a8 fa ff
	ff		 add	 DWORD PTR _headerOffset$1$[ebp], ecx
  005bf	13 f0		 adc	 esi, eax
  005c1	89 b5 ac fa ff
	ff		 mov	 DWORD PTR _headerOffset$2$[ebp], esi

; 463  : 	}

  005c7	e9 34 fe ff ff	 jmp	 $LL7@ChangePwd
$LN86@ChangePwd:

; 464  : 
; 465  : 	/* Password successfully changed */
; 466  : 	nStatus = 0;

  005cc	33 f6		 xor	 esi, esi

; 438  : 			{
; 439  : 				nStatus = ERR_OS_ERROR;
; 440  : 				goto error;

  005ce	eb 05		 jmp	 SHORT $error$123
$LN80@ChangePwd:

; 324  : 		{
; 325  : 			nStatus = ERR_OS_ERROR;

  005d0	be 01 00 00 00	 mov	 esi, 1
$error$123:

; 467  : 
; 468  : error:
; 469  : 	dwError = GetLastError ();

  005d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 470  : 
; 471  : 	burn (buffer, sizeof (buffer));

  005db	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  005e1	89 85 94 fa ff
	ff		 mov	 DWORD PTR _dwError$1$[ebp], eax
  005e7	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  005ec	8b c1		 mov	 eax, ecx
  005ee	8b da		 mov	 ebx, edx
$LL71@ChangePwd:
  005f0	c6 00 00	 mov	 BYTE PTR [eax], 0
  005f3	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  005f6	83 eb 01	 sub	 ebx, 1
  005f9	75 f5		 jne	 SHORT $LL71@ChangePwd
  005fb	0f 1f 44 00 00	 npad	 5
$LL15@ChangePwd:
  00600	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00603	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00606	83 ea 01	 sub	 edx, 1
  00609	75 f5		 jne	 SHORT $LL15@ChangePwd

; 472  : 
; 473  : 	if (cryptoInfo != NULL)

  0060b	8b 85 b4 fa ff
	ff		 mov	 eax, DWORD PTR _cryptoInfo$[ebp]
  00611	85 c0		 test	 eax, eax
  00613	74 09		 je	 SHORT $LN60@ChangePwd

; 474  : 		crypto_close (cryptoInfo);

  00615	50		 push	 eax
  00616	e8 00 00 00 00	 call	 _crypto_close
  0061b	83 c4 04	 add	 esp, 4
$LN60@ChangePwd:

; 475  : 
; 476  : 	if (bTimeStampValid)

  0061e	83 bd 88 fa ff
	ff 00		 cmp	 DWORD PTR _bTimeStampValid$1$[ebp], 0
  00625	74 1c		 je	 SHORT $LN61@ChangePwd

; 477  : 		SetFileTime (dev, &ftCreationTime, &ftLastAccessTime, &ftLastWriteTime);

  00627	8d 85 60 fa ff
	ff		 lea	 eax, DWORD PTR _ftLastWriteTime$[ebp]
  0062d	50		 push	 eax
  0062e	8d 85 58 fa ff
	ff		 lea	 eax, DWORD PTR _ftLastAccessTime$[ebp]
  00634	50		 push	 eax
  00635	8d 85 50 fa ff
	ff		 lea	 eax, DWORD PTR _ftCreationTime$[ebp]
  0063b	50		 push	 eax
  0063c	57		 push	 edi
  0063d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFileTime@16
$LN61@ChangePwd:

; 478  : 
; 479  : 	if (dev != INVALID_HANDLE_VALUE)

  00643	83 ff ff	 cmp	 edi, -1
  00646	74 07		 je	 SHORT $LN62@ChangePwd

; 480  : 		CloseHandle ((HANDLE) dev);

  00648	57		 push	 edi
  00649	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN62@ChangePwd:

; 481  : 
; 482  : 	if (nDosLinkCreated == 0)

  0064f	83 bd 84 fa ff
	ff 00		 cmp	 DWORD PTR _nDosLinkCreated$1$[ebp], 0
  00656	75 16		 jne	 SHORT $LN63@ChangePwd

; 483  : 		RemoveFakeDosName (szDiskFile, szDosDevice);

  00658	8d 85 f0 fa ff
	ff		 lea	 eax, DWORD PTR _szDosDevice$[ebp]
  0065e	50		 push	 eax
  0065f	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szDiskFile$[ebp]
  00665	50		 push	 eax
  00666	e8 00 00 00 00	 call	 _RemoveFakeDosName
  0066b	83 c4 08	 add	 esp, 8
$LN63@ChangePwd:

; 484  : 
; 485  : 	RandStop (FALSE);

  0066e	6a 00		 push	 0
  00670	e8 00 00 00 00	 call	 _RandStop
  00675	83 c4 04	 add	 esp, 4

; 486  : 	NormalCursor ();

  00678	e8 00 00 00 00	 call	 _NormalCursor

; 487  : 
; 488  : 	SetLastError (dwError);

  0067d	8b bd 94 fa ff
	ff		 mov	 edi, DWORD PTR _dwError$1$[ebp]
  00683	57		 push	 edi
  00684	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 489  : 
; 490  : 	if (nStatus == ERR_OS_ERROR && dwError == ERROR_ACCESS_DENIED
; 491  : 		&& bDevice
; 492  : 		&& !UacElevated
; 493  : 		&& IsUacSupported ())

  0068a	83 fe 01	 cmp	 esi, 1
  0068d	75 33		 jne	 SHORT $LN64@ChangePwd
  0068f	83 ff 05	 cmp	 edi, 5
  00692	75 32		 jne	 SHORT $LN104@ChangePwd
  00694	83 bd b0 fa ff
	ff 00		 cmp	 DWORD PTR _bDevice$[ebp], 0
  0069b	74 29		 je	 SHORT $LN104@ChangePwd
  0069d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _UacElevated, 0
  006a4	75 20		 jne	 SHORT $LN104@ChangePwd
  006a6	e8 00 00 00 00	 call	 _IsUacSupported
  006ab	85 c0		 test	 eax, eax
  006ad	74 17		 je	 SHORT $LN104@ChangePwd

; 494  : 		return nStatus;

  006af	5f		 pop	 edi
  006b0	8b c6		 mov	 eax, esi
  006b2	5e		 pop	 esi
  006b3	5b		 pop	 ebx

; 500  : }

  006b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006b7	33 cd		 xor	 ecx, ebp
  006b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006be	8b e5		 mov	 esp, ebp
  006c0	5d		 pop	 ebp
  006c1	c3		 ret	 0
$LN64@ChangePwd:

; 495  : 
; 496  : 	if (nStatus != 0)

  006c2	85 f6		 test	 esi, esi
  006c4	74 0f		 je	 SHORT $LN65@ChangePwd
$LN104@ChangePwd:

; 497  : 		handleError (hwndDlg, nStatus);

  006c6	56		 push	 esi
  006c7	ff b5 80 fa ff
	ff		 push	 DWORD PTR _hwndDlg$GSCopy$1$[ebp]
  006cd	e8 00 00 00 00	 call	 _handleError
  006d2	83 c4 08	 add	 esp, 8
$LN65@ChangePwd:

; 498  : 
; 499  : 	return nStatus;

  006d5	5f		 pop	 edi
  006d6	8b c6		 mov	 eax, esi
  006d8	5e		 pop	 esi
  006d9	5b		 pop	 ebx

; 500  : }

  006da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006dd	33 cd		 xor	 ecx, ebp
  006df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006e4	8b e5		 mov	 esp, ebp
  006e6	5d		 pop	 ebp
  006e7	c3		 ret	 0
$LN18@ChangePwd:
  006e8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006eb	83 c8 ff	 or	 eax, -1
  006ee	5f		 pop	 edi
  006ef	5e		 pop	 esi
  006f0	33 cd		 xor	 ecx, ebp
  006f2	5b		 pop	 ebx
  006f3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006f8	8b e5		 mov	 esp, ebp
  006fa	5d		 pop	 ebp
  006fb	c3		 ret	 0
_ChangePwd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\password.c
;	COMDAT _CheckPasswordCharEncoding
_TEXT	SEGMENT
_s$1 = -136						; size = 130
__$ArrayPad$ = -4					; size = 4
_hPassword$ = 8						; size = 4
_ptrPw$ = 12						; size = 4
_CheckPasswordCharEncoding PROC				; COMDAT

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _hPassword$[ebp]
  00017	57		 push	 edi

; 103  : 	int i, len;
; 104  : 	
; 105  : 	if (hPassword == NULL)

  00018	85 f6		 test	 esi, esi
  0001a	75 3d		 jne	 SHORT $LN13@CheckPassw

; 106  : 	{
; 107  : 		unsigned char *pw;
; 108  : 		len = ptrPw->Length;

  0001c	8b 45 0c	 mov	 eax, DWORD PTR _ptrPw$[ebp]
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]

; 109  : 		pw = (unsigned char *) ptrPw->Text;

  00021	8d 70 04	 lea	 esi, DWORD PTR [eax+4]

; 110  : 
; 111  : 		for (i = 0; i < len; i++)

  00024	33 c0		 xor	 eax, eax
  00026	85 d2		 test	 edx, edx
  00028	0f 8e 94 00 00
	00		 jle	 $LN20@CheckPassw
  0002e	66 90		 npad	 2
$LL4@CheckPassw:

; 112  : 		{
; 113  : 			if (pw[i] >= 0x7f || pw[i] < 0x20)	// A non-ASCII or non-printable character?

  00030	8a 0c 30	 mov	 cl, BYTE PTR [eax+esi]
  00033	80 f9 7f	 cmp	 cl, 127			; 0000007fH
  00036	73 0f		 jae	 SHORT $LN30@CheckPassw
  00038	80 f9 20	 cmp	 cl, 32			; 00000020H
  0003b	72 0a		 jb	 SHORT $LN30@CheckPassw

; 110  : 
; 111  : 		for (i = 0; i < len; i++)

  0003d	40		 inc	 eax
  0003e	3b c2		 cmp	 eax, edx
  00040	7c ee		 jl	 SHORT $LL4@CheckPassw

; 128  : 		{
; 129  : 			if (s[i] >= 0x7f || s[i] < 0x20)	// A non-ASCII or non-printable character?

  00042	e9 7b 00 00 00	 jmp	 $LN20@CheckPassw
$LN30@CheckPassw:
  00047	5f		 pop	 edi

; 114  : 				return FALSE;

  00048	33 c0		 xor	 eax, eax
  0004a	5e		 pop	 esi

; 136  : 			return FALSE; 
; 137  : 	}
; 138  : 
; 139  : 	return TRUE;
; 140  : }

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004e	33 cd		 xor	 ecx, ebp
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN13@CheckPassw:

; 115  : 		}
; 116  : 	}
; 117  : 	else
; 118  : 	{
; 119  : 		wchar_t s[MAX_PASSWORD + 1];
; 120  : 		len = GetWindowTextLength (hPassword);

  00059	56		 push	 esi
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextLengthA@4
  00060	8b f8		 mov	 edi, eax

; 121  : 
; 122  : 		if (len > MAX_PASSWORD)

  00062	83 ff 40	 cmp	 edi, 64			; 00000040H
  00065	7f e0		 jg	 SHORT $LN30@CheckPassw

; 123  : 			return FALSE; 
; 124  : 
; 125  : 		GetWindowTextW (hPassword, s, sizeof (s) / sizeof (wchar_t));

  00067	6a 41		 push	 65			; 00000041H
  00069	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _s$1[ebp]
  0006f	50		 push	 eax
  00070	56		 push	 esi
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextW@12

; 126  : 
; 127  : 		for (i = 0; i < len; i++)

  00077	33 c0		 xor	 eax, eax
  00079	85 ff		 test	 edi, edi
  0007b	7e 1a		 jle	 SHORT $LN10@CheckPassw
  0007d	0f 1f 00	 npad	 3
$LL7@CheckPassw:

; 128  : 		{
; 129  : 			if (s[i] >= 0x7f || s[i] < 0x20)	// A non-ASCII or non-printable character?

  00080	0f b7 8c 45 78
	ff ff ff	 movzx	 ecx, WORD PTR _s$1[ebp+eax*2]
  00088	83 f9 7f	 cmp	 ecx, 127		; 0000007fH
  0008b	73 0a		 jae	 SHORT $LN10@CheckPassw
  0008d	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00090	72 05		 jb	 SHORT $LN10@CheckPassw

; 126  : 
; 127  : 		for (i = 0; i < len; i++)

  00092	40		 inc	 eax
  00093	3b c7		 cmp	 eax, edi
  00095	7c e9		 jl	 SHORT $LL7@CheckPassw
$LN10@CheckPassw:

; 130  : 				break;
; 131  : 		}
; 132  : 
; 133  : 		burn (s, sizeof(s));

  00097	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _s$1[ebp]
  0009d	ba 82 00 00 00	 mov	 edx, 130		; 00000082H
  000a2	53		 push	 ebx
  000a3	8b da		 mov	 ebx, edx
  000a5	8b f1		 mov	 esi, ecx
$LL23@CheckPassw:
  000a7	c6 06 00	 mov	 BYTE PTR [esi], 0
  000aa	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  000ad	83 eb 01	 sub	 ebx, 1
  000b0	75 f5		 jne	 SHORT $LL23@CheckPassw
  000b2	5b		 pop	 ebx
$LL11@CheckPassw:
  000b3	c6 01 00	 mov	 BYTE PTR [ecx], 0
  000b6	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000b9	83 ea 01	 sub	 edx, 1
  000bc	75 f5		 jne	 SHORT $LL11@CheckPassw

; 134  : 
; 135  : 		if (i < len)

  000be	3b c7		 cmp	 eax, edi
  000c0	7c 85		 jl	 SHORT $LN30@CheckPassw
$LN20@CheckPassw:

; 136  : 			return FALSE; 
; 137  : 	}
; 138  : 
; 139  : 	return TRUE;
; 140  : }

  000c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c5	b8 01 00 00 00	 mov	 eax, 1
  000ca	5f		 pop	 edi
  000cb	33 cd		 xor	 ecx, ebp
  000cd	5e		 pop	 esi
  000ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
_CheckPasswordCharEncoding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\password.c
;	COMDAT _CheckPasswordLength
_TEXT	SEGMENT
_hwndDlg$ = 8						; size = 4
_hwndItem$ = 12						; size = 4
_CheckPasswordLength PROC				; COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 155  : 	if (GetWindowTextLength (hwndItem) < PASSWORD_LEN_WARNING)

  00003	ff 75 0c	 push	 DWORD PTR _hwndItem$[ebp]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextLengthA@4
  0000c	83 f8 14	 cmp	 eax, 20			; 00000014H
  0000f	7d 2b		 jge	 SHORT $LN3@CheckPassw

; 156  : 	{
; 157  : #ifndef _DEBUG
; 158  : 		if (MessageBoxW (hwndDlg, GetString ("PASSWORD_LENGTH_WARNING"), lpszTitle, MB_YESNO|MB_ICONWARNING|MB_DEFBUTTON2) != IDYES)

  00011	68 34 01 00 00	 push	 308			; 00000134H
  00016	ff 35 00 00 00
	00		 push	 DWORD PTR _lpszTitle
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FPFPGNBO@PASSWORD_LENGTH_WARNING?$AA@
  00021	e8 00 00 00 00	 call	 _GetString
  00026	83 c4 04	 add	 esp, 4
  00029	50		 push	 eax
  0002a	ff 75 08	 push	 DWORD PTR _hwndDlg$[ebp]
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxW@16
  00033	83 f8 06	 cmp	 eax, 6
  00036	74 04		 je	 SHORT $LN3@CheckPassw

; 159  : 			return FALSE;

  00038	33 c0		 xor	 eax, eax

; 163  : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN3@CheckPassw:

; 160  : #endif
; 161  : 	}
; 162  : 	return TRUE;

  0003c	b8 01 00 00 00	 mov	 eax, 1

; 163  : }

  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
_CheckPasswordLength ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\alexis\documents\finalgostcrypt\sources_gostcrypt_windows_1.3.1\common\password.c
;	COMDAT _VerifyPasswordAndUpdate
_TEXT	SEGMENT
_hButton$GSCopy$1$ = -152				; size = 4
_szPassword$GSCopy$1$ = -148				; size = 4
_k$1$ = -144						; size = 4
_szTmp2$ = -140						; size = 65
_szTmp1$ = -72						; size = 65
__$ArrayPad$ = -4					; size = 4
_hwndDlg$ = 8						; size = 4
_hButton$ = 12						; size = 4
_hPassword$ = 16					; size = 4
_hVerify$ = 20						; size = 4
_szPassword$ = 24					; size = 4
_szVerify$ = 28						; size = 4
_keyFilesEnabled$ = 32					; size = 4
_VerifyPasswordAndUpdate PROC				; COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _hButton$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 1c	 mov	 ebx, DWORD PTR _szVerify$[ebp]
  0001a	56		 push	 esi
  0001b	8b 75 10	 mov	 esi, DWORD PTR _hPassword$[ebp]
  0001e	57		 push	 edi
  0001f	8b 7d 14	 mov	 edi, DWORD PTR _hVerify$[ebp]
  00022	89 85 68 ff ff
	ff		 mov	 DWORD PTR _hButton$GSCopy$1$[ebp], eax
  00028	8b 45 18	 mov	 eax, DWORD PTR _szPassword$[ebp]

; 56   : 	char szTmp1[MAX_PASSWORD + 1];
; 57   : 	char szTmp2[MAX_PASSWORD + 1];
; 58   : 	int k = GetWindowTextLength (hPassword);

  0002b	56		 push	 esi
  0002c	89 85 6c ff ff
	ff		 mov	 DWORD PTR _szPassword$GSCopy$1$[ebp], eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextLengthA@4
  00038	89 85 70 ff ff
	ff		 mov	 DWORD PTR _k$1$[ebp], eax

; 59   : 	BOOL bEnable = FALSE;
; 60   : 
; 61   : 	if (hwndDlg);		/* Remove warning */ // useless
; 62   : 
; 63   : 	GetWindowText (hPassword, szTmp1, sizeof (szTmp1));

  0003e	8d 45 b8	 lea	 eax, DWORD PTR _szTmp1$[ebp]
  00041	6a 41		 push	 65			; 00000041H
  00043	50		 push	 eax
  00044	56		 push	 esi
  00045	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetWindowTextA@12
  0004b	ff d6		 call	 esi

; 64   : 	GetWindowText (hVerify, szTmp2, sizeof (szTmp2));

  0004d	6a 41		 push	 65			; 00000041H
  0004f	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00055	50		 push	 eax
  00056	57		 push	 edi
  00057	ff d6		 call	 esi

; 65   : 
; 66   : 	if (strcmp (szTmp1, szTmp2) != 0)

  00059	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _szTmp2$[ebp]
  0005f	8d 45 b8	 lea	 eax, DWORD PTR _szTmp1$[ebp]
$LL53@VerifyPass:
  00062	8a 10		 mov	 dl, BYTE PTR [eax]
  00064	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00066	75 1a		 jne	 SHORT $LN54@VerifyPass
  00068	84 d2		 test	 dl, dl
  0006a	74 12		 je	 SHORT $LN55@VerifyPass
  0006c	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0006f	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00072	75 0e		 jne	 SHORT $LN54@VerifyPass
  00074	83 c0 02	 add	 eax, 2
  00077	83 c1 02	 add	 ecx, 2
  0007a	84 d2		 test	 dl, dl
  0007c	75 e4		 jne	 SHORT $LL53@VerifyPass
$LN55@VerifyPass:
  0007e	33 c0		 xor	 eax, eax
  00080	eb 05		 jmp	 SHORT $LN56@VerifyPass
$LN54@VerifyPass:
  00082	1b c0		 sbb	 eax, eax
  00084	83 c8 01	 or	 eax, 1
$LN56@VerifyPass:
  00087	85 c0		 test	 eax, eax
  00089	74 04		 je	 SHORT $LN13@VerifyPass

; 67   : 		bEnable = FALSE;

  0008b	33 ff		 xor	 edi, edi
  0008d	eb 18		 jmp	 SHORT $LN16@VerifyPass
$LN13@VerifyPass:

; 68   : 	else
; 69   : 	{
; 70   : 		if (k >= MIN_PASSWORD || keyFilesEnabled)

  0008f	83 bd 70 ff ff
	ff 01		 cmp	 DWORD PTR _k$1$[ebp], 1
  00096	7d 0a		 jge	 SHORT $LN17@VerifyPass
  00098	83 7d 20 00	 cmp	 DWORD PTR _keyFilesEnabled$[ebp], 0
  0009c	75 04		 jne	 SHORT $LN17@VerifyPass

; 72   : 		else
; 73   : 			bEnable = FALSE;

  0009e	33 ff		 xor	 edi, edi
  000a0	eb 05		 jmp	 SHORT $LN16@VerifyPass
$LN17@VerifyPass:

; 71   : 			bEnable = TRUE;

  000a2	bf 01 00 00 00	 mov	 edi, 1
$LN16@VerifyPass:

; 74   : 	}
; 75   : 
; 76   : 	if (szPassword != NULL)

  000a7	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _szPassword$GSCopy$1$[ebp]
  000ad	85 c9		 test	 ecx, ecx
  000af	74 25		 je	 SHORT $LN18@VerifyPass

; 77   : 		memcpy (szPassword, szTmp1, sizeof (szTmp1));

  000b1	0f 10 45 b8	 movups	 xmm0, XMMWORD PTR _szTmp1$[ebp]
  000b5	8a 45 f8	 mov	 al, BYTE PTR _szTmp1$[ebp+64]
  000b8	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  000bb	0f 10 45 c8	 movups	 xmm0, XMMWORD PTR _szTmp1$[ebp+16]
  000bf	0f 11 41 10	 movups	 XMMWORD PTR [ecx+16], xmm0
  000c3	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR _szTmp1$[ebp+32]
  000c7	0f 11 41 20	 movups	 XMMWORD PTR [ecx+32], xmm0
  000cb	0f 10 45 e8	 movups	 xmm0, XMMWORD PTR _szTmp1$[ebp+48]
  000cf	0f 11 41 30	 movups	 XMMWORD PTR [ecx+48], xmm0
  000d3	88 41 40	 mov	 BYTE PTR [ecx+64], al
$LN18@VerifyPass:

; 78   : 
; 79   : 	if (szVerify != NULL)

  000d6	85 db		 test	 ebx, ebx
  000d8	74 28		 je	 SHORT $LN4@VerifyPass

; 80   : 		memcpy (szVerify, szTmp2, sizeof (szTmp2));

  000da	0f 10 85 74 ff
	ff ff		 movups	 xmm0, XMMWORD PTR _szTmp2$[ebp]
  000e1	8a 45 b4	 mov	 al, BYTE PTR _szTmp2$[ebp+64]
  000e4	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0
  000e7	0f 10 45 84	 movups	 xmm0, XMMWORD PTR _szTmp2$[ebp+16]
  000eb	0f 11 43 10	 movups	 XMMWORD PTR [ebx+16], xmm0
  000ef	0f 10 45 94	 movups	 xmm0, XMMWORD PTR _szTmp2$[ebp+32]
  000f3	0f 11 43 20	 movups	 XMMWORD PTR [ebx+32], xmm0
  000f7	0f 10 45 a4	 movups	 xmm0, XMMWORD PTR _szTmp2$[ebp+48]
  000fb	0f 11 43 30	 movups	 XMMWORD PTR [ebx+48], xmm0
  000ff	88 43 40	 mov	 BYTE PTR [ebx+64], al
$LN4@VerifyPass:

; 81   : 
; 82   : 	burn (szTmp1, sizeof (szTmp1));

  00102	8d 45 b8	 lea	 eax, DWORD PTR _szTmp1$[ebp]
  00105	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  0010a	8b f1		 mov	 esi, ecx
  0010c	8b d0		 mov	 edx, eax
  0010e	66 90		 npad	 2
$LL22@VerifyPass:
  00110	c6 02 00	 mov	 BYTE PTR [edx], 0
  00113	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00116	83 ee 01	 sub	 esi, 1
  00119	75 f5		 jne	 SHORT $LL22@VerifyPass
  0011b	0f 1f 44 00 00	 npad	 5
$LL5@VerifyPass:
  00120	c6 00 00	 mov	 BYTE PTR [eax], 0
  00123	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00126	83 e9 01	 sub	 ecx, 1
  00129	75 f5		 jne	 SHORT $LL5@VerifyPass

; 83   : 	burn (szTmp2, sizeof (szTmp2));

  0012b	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _szTmp2$[ebp]
  00131	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  00136	8b f1		 mov	 esi, ecx
  00138	8b d0		 mov	 edx, eax
  0013a	66 0f 1f 44 00
	00		 npad	 6
$LL26@VerifyPass:
  00140	c6 02 00	 mov	 BYTE PTR [edx], 0
  00143	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00146	83 ee 01	 sub	 esi, 1
  00149	75 f5		 jne	 SHORT $LL26@VerifyPass
  0014b	0f 1f 44 00 00	 npad	 5
$LL10@VerifyPass:
  00150	c6 00 00	 mov	 BYTE PTR [eax], 0
  00153	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00156	83 e9 01	 sub	 ecx, 1
  00159	75 f5		 jne	 SHORT $LL10@VerifyPass

; 84   : 
; 85   : 	EnableWindow (hButton, bEnable);

  0015b	57		 push	 edi
  0015c	ff b5 68 ff ff
	ff		 push	 DWORD PTR _hButton$GSCopy$1$[ebp]
  00162	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnableWindow@8

; 86   : }

  00168	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	33 cd		 xor	 ecx, ebp
  0016f	5b		 pop	 ebx
  00170	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00175	8b e5		 mov	 esp, ebp
  00177	5d		 pop	 ebp
  00178	c3		 ret	 0
_VerifyPasswordAndUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 17787: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17788:     volatile char *vptr = (volatile char *)ptr;
; 17789: 
; 17790: #if defined(_M_AMD64)
; 17791: 
; 17792:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 17793: 
; 17794: #else
; 17795: 
; 17796:     while (cnt) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR _cnt$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00009	8b c8		 mov	 ecx, eax
  0000b	85 d2		 test	 edx, edx
  0000d	74 0c		 je	 SHORT $LN3@RtlSecureZ
  0000f	90		 npad	 1
$LL2@RtlSecureZ:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

  00010	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

  00013	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 17809:         cnt--;

  00016	83 ea 01	 sub	 edx, 1
  00019	75 f5		 jne	 SHORT $LL2@RtlSecureZ
$LN3@RtlSecureZ:

; 17810:     }
; 17811: 
; 17812: #endif // _M_AMD64
; 17813: 
; 17814:     return ptr;
; 17815: }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
END
