;	Static Name Aliases
;
;	$S1777_?options@?3??RepairMenu@@YAXXZ@4QAPBDA	EQU	?options@?3??RepairMenu@@YAXXZ@4QAPBDA
	TITLE   ..\bootmain.cpp
	.MODEL  SMALL
	.386p
	.387
_TEXT	SEGMENT  WORD USE16 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT  WORD USE16 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD USE16 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD USE16 PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
PUBLIC  ??_C@_0BH@CKJE@Bootable?5Partitions?3?$AN?6?$AA@
PUBLIC  ??_C@_0BL@HDPH@Please?5decrypt?5it?5first?4?$AN?6?$AA@
PUBLIC  ??_C@_02PIMC@?$AN?6?$AA@
PUBLIC  ??_C@_03NMHE@y?$AN?6?$AA@
PUBLIC  ??_C@_0BF@LODE@Skip?5all?5bad?5sectors?$AA@
PUBLIC  ??_C@_03EDHP@n?$AN?6?$AA@
PUBLIC  ??_C@_0CK@MNCE@?9?5Connect?5system?5drive?5to?5?$CISATA?$CJ@
PUBLIC  ??_C@_07MCKD@Drive?3?5?$AA@
PUBLIC  ??_C@_0O@LEMN@?0?5Partition?3?5?$AA@
PUBLIC  ??_C@_08PFEJ@?0?5Size?3?5?$AA@
PUBLIC  ??_C@_0CJ@BABO@It?5appears?5you?5are?5creating?5a?5hi@
PUBLIC  ??_C@_0CA@HAB@Press?51?99?5to?5select?5partition?3?5?$AA@
PUBLIC  ??_C@_0BA@LKAJ@Is?5this?5correct?$AA@
PUBLIC  ??_C@_01KHLB@?$FL?$AA@
PUBLIC  ??_C@_0DK@PFGO@Please?5remove?5the?5Rescue?5Disk?5fr@
PUBLIC  ??_C@_05EFLO@?$FN?5?5?5?5?$AA@
PUBLIC  ??_C@_0BC@DHAO@?$FLEsc?$FN?5?5Cancel?$AN?6?$AN?6?$AA@
PUBLIC  ??_C@_0BH@NEPP@To?5select?0?5press?51?99?3?5?$AA@
PUBLIC  ??_C@_0CA@FBFB@BIOS?5reserved?5too?5much?5memory?3?5?$AA@
PUBLIC  ??_C@_0DM@HBD@?9?5Upgrade?5BIOS?$AN?6?9?5Use?5a?5differen@
PUBLIC  ??_C@_0BM@IDKA@No?5bootable?5partition?5found?$AA@
PUBLIC  ??_C@_0P@EOMF@Enter?5password?$AA@
PUBLIC  ??_C@_0BG@GEFN@?5for?5hidden?5system?3?$AN?6?$AA@
PUBLIC  ??_C@_02HFBK@?3?5?$AA@
PUBLIC  ??_C@_0BE@LMLE@?$ANDrive?5decrypted?4?$AN?6?$AA@
PUBLIC  ??_C@_0BJ@HKIB@?$AN?6Decryption?5deferred?4?$AN?6?$AA@
PUBLIC  ??_C@_0IK@PKKH@?$AN?6Use?5only?5if?5Windows?5cannot?5sta@
PUBLIC  ??_C@_0M@EMPJ@Decrypt?5now?$AA@
PUBLIC  ??_C@_0BM@NMNK@Warning?3?5Caps?5Lock?5is?5on?4?$AN?6?$AA@
PUBLIC  ??_C@_0BI@KFOG@Incorrect?5password?4?$AN?6?$AN?6?$AA@
PUBLIC  ??_C@_0BN@MGAM@Original?5header?5preserved?4?$AN?6?$AA@
PUBLIC  ??_C@_0L@CGGC@Available?5?$AA@
PUBLIC  ??_C@_0HN@LBMO@If?5you?5are?5sure?5the?5password?5is?5@
PUBLIC  ??_C@_0HG@PFFC@?$AN?6To?5safely?5interrupt?5and?5defer?5@
PUBLIC  ??_C@_03KPOF@?3?$AN?6?$AA@
PUBLIC  ??_C@_0CM@CODF@WARNING?3?5Drive?50?5contains?5a?5vali@
PUBLIC  ??_C@_0P@JAC@Modify?5drive?50?$AA@
PUBLIC  ??_C@_0BP@JLCA@?5GostCrypt?5Rescue?5Disk?51?43?41?$AN?6?$AA@
PUBLIC  ??_C@_0BJ@CIJ@?5?5?5?5Keyboard?5Controls?3?$AN?6?$AA@
PUBLIC  ??_C@_0M@NCBA@?5?5?5?5?$FLEsc?$FN?5?5?$AA@
PUBLIC  ??_C@_0CD@GJAD@Skip?5Authentication?5?$CIBoot?5Manage@
PUBLIC  ??_C@_0CL@PPMD@Permanently?5decrypt?5system?5parti@
PUBLIC  ??_C@_0O@MJCG@?$AN?6?5?5?5?5?$FLF8?$FN?5?5?5?$AA@
PUBLIC  ??_C@_0N@BNAP@?$ANRemaining?3?5?$AA@
PUBLIC  ??_C@_0BO@BJJG@Restore?5GostCrypt?5Boot?5Loader?$AA@
PUBLIC  ??_C@_0P@KAON@Repair?5Options?$AA@
PUBLIC  ??_C@_0CB@OIIA@Restore?5key?5data?5?$CIvolume?5header?$CJ@
PUBLIC  ??_C@_0N@DGHN@Booting?4?4?4?$AN?6?$AA@
PUBLIC  ??_C@_0BP@PLOE@Restore?5original?5system?5loader?$AA@
PUBLIC  ??_C@_0BG@JPHD@GostCrypt?5Boot?5Loader?$AA@
PUBLIC  ??_C@_06IEHP@Header?$AA@
PUBLIC  ??_C@_09LGPG@?$DP?5?$CIy?1n?$CJ?3?5?$AA@
PUBLIC  ??_C@_0O@MJLK@System?5loader?$AA@
PUBLIC  ??_C@_0N@HIBI@?5restored?4?$AN?6?$AA@
PUBLIC  ??_C@_0CI@CJAH@Is?5the?5system?5partition?1drive?5de@
EXTRN	__acrtused:ABS
EXTRN	_ReadVolumeHeader:NEAR
EXTRN	__aNulshr:NEAR
EXTRN	??H@YA?ATUINT64_STRUCT@@ABT0@K@Z:NEAR
EXTRN	?Beep@@YAXXZ:NEAR
EXTRN	?PrintSectorCountInMB@@YAXABTUINT64_STRUCT@@@Z:NEAR
EXTRN	?ClearBiosKeystrokeBuffer@@YAXXZ:NEAR
EXTRN	??Y@YAAATUINT64_STRUCT@@AAT0@ABT0@@Z:NEAR
EXTRN	?ClearScreen@@YAXXZ:NEAR
EXTRN	?ReadWriteMBR@@YAEDED@Z:NEAR
EXTRN	??G@YA?ATUINT64_STRUCT@@ABT0@0@Z:NEAR
EXTRN	_GetCrc32:NEAR
EXTRN	??G@YA?ATUINT64_STRUCT@@ABT0@K@Z:NEAR
EXTRN	?EscKeyPressed@@YADXZ:NEAR
EXTRN	?GetKeyboardChar@@YAEXZ:NEAR
EXTRN	_memcpy:NEAR
EXTRN	?GetKeyboardChar@@YAEPAE@Z:NEAR
EXTRN	??5@YA?ATUINT64_STRUCT@@ABT0@H@Z:NEAR
EXTRN	?GetShiftFlags@@YAEXZ:NEAR
EXTRN	??6@YA?ATUINT64_STRUCT@@ABT0@H@Z:NEAR
EXTRN	?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z:NEAR
EXTRN	?GetString@@YAHPADI@Z:NEAR
EXTRN	?InitVideoMode@@YAXXZ:NEAR
EXTRN	_DecryptDataUnits:NEAR
EXTRN	?IsPrintable@@YADD@Z:NEAR
EXTRN	?ReadSectors@@YAEPAEEABUChsAddress@@ED@Z:NEAR
EXTRN	?Print@@YAXPBD@Z:NEAR
EXTRN	?Print@@YAXK@Z:NEAR
EXTRN	?PrintBackspace@@YAXXZ:NEAR
EXTRN	?ReadWriteSectors@@YAEDIIEABTUINT64_STRUCT@@ID@Z:NEAR
EXTRN	_EncryptBuffer:NEAR
EXTRN	?InstallInterruptFilters@@YADXZ:NEAR
EXTRN	_EraseMemory:NEAR
EXTRN	?PrintChar@@YAXD@Z:NEAR
EXTRN	??N@YADABTUINT64_STRUCT@@0@Z:NEAR
EXTRN	?PrintCharAtCursor@@YAXD@Z:NEAR
EXTRN	_DecryptBuffer:NEAR
EXTRN	?GetActivePartition@@YADE@Z:NEAR
EXTRN	?PrintEndl@@YAXXZ:NEAR
EXTRN	?WriteSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z:NEAR
EXTRN	?CopyMemory@@YAXPAXIII@Z:NEAR
EXTRN	?PrintEndl@@YAXH@Z:NEAR
EXTRN	?GetDriveGeometry@@YAEEAAUDriveGeometry@@D@Z:NEAR
EXTRN	?PrintRepeatedChar@@YAXDH@Z:NEAR
EXTRN	?CopyMemory@@YAXIIPAXI@Z:NEAR
EXTRN	?PrintError@@YAXPBD@Z:NEAR
EXTRN	_crypto_open:NEAR
EXTRN	?PrintErrorNoEndl@@YAXPBD@Z:NEAR
EXTRN	?GetDrivePartitions@@YAEEPAUPartition@@IAAID0D@Z:NEAR
EXTRN	_crypto_close:NEAR
EXTRN	?LbaToChs@@YAXABUDriveGeometry@@ABTUINT64_STRUCT@@AAUChsAddress@@@Z:NEAR
EXTRN	?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A:WORD
EXTRN	?EncryptedVirtualPartition@@3UPartition@@A:BYTE
EXTRN	?ActivePartition@@3UPartition@@A:BYTE
EXTRN	?PartitionFollowingActive@@3UPartition@@A:BYTE
EXTRN	?ExtraBootPartitionPresent@@3DA:BYTE
EXTRN	?HiddenVolumeStartUnitNo@@3TUINT64_STRUCT@@A:QWORD
EXTRN	?HiddenVolumeStartSector@@3TUINT64_STRUCT@@A:QWORD
EXTRN	?SectorBuffer@@3QAEA:BYTE
EXTRN	?BootSectorFlags@@3EA:BYTE
EXTRN	?BootLoaderDrive@@3EA:BYTE
EXTRN	?BootDrive@@3EA:BYTE
EXTRN	?BootDriveGeometryValid@@3DA:BYTE
EXTRN	?BootDriveGeometry@@3UDriveGeometry@@A:DWORD
EXTRN	?PreventNormalSystemBoot@@3DA:BYTE
EXTRN	?PreventBootMenu@@3DA:BYTE
EXTRN	?BootStarted@@3DA:BYTE
_DATA      SEGMENT
??_C@_0BP@JLCA@?5GostCrypt?5Rescue?5Disk?51?43?41?$AN?6?$AA@	DB	' GostCrypt Rescue Disk 1.3.1',  0dH,  0aH,  00H
	ORG	$-31
??_C@_0BJ@CIJ@?5?5?5?5Keyboard?5Controls?3?$AN?6?$AA@	DB	'    Keyboard Controls:',  0dH,  0aH,  00H
	ORG	$-25
??_C@_0M@NCBA@?5?5?5?5?$FLEsc?$FN?5?5?$AA@	DB	'    [Esc]  ',  00H
	ORG	$-12
??_C@_0CD@GJAD@Skip?5Authentication?5?$CIBoot?5Manage@	DB	'Skip Authentication (Boot Manager)',  00H
	ORG	$-35
??_C@_0O@MJCG@?$AN?6?5?5?5?5?$FLF8?$FN?5?5?5?$AA@	DB	0dH,  0aH, '    [F8]   ',  00H
	ORG	$-14
??_C@_0P@KAON@Repair?5Options?$AA@	DB	'Repair Options',  00H
	ORG	$-15
??_C@_09LGPG@?$DP?5?$CIy?1n?$CJ?3?5?$AA@	DB	'? (y/n): ',  00H
	ORG	$-10
??_C@_03NMHE@y?$AN?6?$AA@	DB	'y',  0dH,  0aH,  00H
	ORG	$-4
??_C@_03EDHP@n?$AN?6?$AA@	DB	'n',  0dH,  0aH,  00H
	ORG	$-4
??_C@_01KHLB@?$FL?$AA@	DB	'[',  00H
	ORG	$-2
??_C@_05EFLO@?$FN?5?5?5?5?$AA@	DB	']    ',  00H
	ORG	$-6
??_C@_0BC@DHAO@?$FLEsc?$FN?5?5Cancel?$AN?6?$AN?6?$AA@	DB	'[Esc]  Cancel',  0dH,  0aH,  0dH,  0aH,  00H
	ORG	$-18
??_C@_0BH@NEPP@To?5select?0?5press?51?99?3?5?$AA@	DB	'To select, press 1-9: ',  00H
	ORG	$-23
??_C@_0P@EOMF@Enter?5password?$AA@	DB	'Enter password',  00H
	ORG	$-15
??_C@_0BG@GEFN@?5for?5hidden?5system?3?$AN?6?$AA@	DB	' for hidden system:',  0dH,  0aH,  00H
	ORG	$-22
??_C@_02HFBK@?3?5?$AA@	DB	': ',  00H
	ORG	$-3
??_C@_0N@DGHN@Booting?4?4?4?$AN?6?$AA@	DB	'Booting...',  0dH,  0aH,  00H
	ORG	$-13
??_C@_0CA@FBFB@BIOS?5reserved?5too?5much?5memory?3?5?$AA@	DB	'BIOS reserved too much memory: ',  00H
	ORG	$-32
??_C@_0DM@HBD@?9?5Upgrade?5BIOS?$AN?6?9?5Use?5a?5differen@	DB	'- Upgrade BIOS',  0dH,  0aH, '- Use a different motherboard '
	DB	'model/brand',  0dH,  0aH,  00H
	ORG	$-60
??_C@_0BM@NMNK@Warning?3?5Caps?5Lock?5is?5on?4?$AN?6?$AA@	DB	'Warning: Caps Lock is on.',  0dH,  0aH,  00H
	ORG	$-28
??_C@_0BI@KFOG@Incorrect?5password?4?$AN?6?$AN?6?$AA@	DB	'Incorrect password.',  0dH,  0aH,  0dH,  0aH,  00H
	ORG	$-24
??_C@_0HN@LBMO@If?5you?5are?5sure?5the?5password?5is?5@	DB	'If you are sure the password is correct, the key data may be'
	DB	' damaged.',  0dH,  0aH, 'If so, use ''Repair Options'' > ''R'
	DB	'estore key data''.',  0dH,  0aH,  0dH,  0aH,  00H
	ORG	$-125
??_C@_0BM@IDKA@No?5bootable?5partition?5found?$AA@	DB	'No bootable partition found',  00H
	ORG	$-28
??_C@_0BH@CKJE@Bootable?5Partitions?3?$AN?6?$AA@	DB	'Bootable Partitions:',  0dH,  0aH,  00H
	ORG	$-23
??_C@_02PIMC@?$AN?6?$AA@	DB	0dH,  0aH,  00H
	ORG	$-3
??_C@_07MCKD@Drive?3?5?$AA@	DB	'Drive: ',  00H
	ORG	$-8
??_C@_0O@LEMN@?0?5Partition?3?5?$AA@	DB	', Partition: ',  00H
	ORG	$-14
??_C@_08PFEJ@?0?5Size?3?5?$AA@	DB	', Size: ',  00H
	ORG	$-9
??_C@_0CA@HAB@Press?51?99?5to?5select?5partition?3?5?$AA@	DB	'Press 1-9 to select partition: ',  00H
	ORG	$-32
??_C@_0IK@PKKH@?$AN?6Use?5only?5if?5Windows?5cannot?5sta@	DB	0dH,  0aH, 'Use only if Windows cannot start. Decryption und'
	DB	'er Windows is much faster',  0dH,  0aH, '(in GostCrypt, sele'
	DB	'ct ''System'' > ''Permanently Decrypt'').',  0dH,  0aH,  0dH
	DB	0aH,  00H
	ORG	$-138
??_C@_0M@EMPJ@Decrypt?5now?$AA@	DB	'Decrypt now',  00H
	ORG	$-12
??_C@_0HG@PFFC@?$AN?6To?5safely?5interrupt?5and?5defer?5@	DB	0dH,  0aH, 'To safely interrupt and defer decryption, press '
	DB	'Esc.',  0dH,  0aH, 'WARNING: You can turn off power only aft'
	DB	'er you press Esc.',  0dH,  0aH,  0dH,  0aH,  00H
	ORG	$-118
??_C@_0N@BNAP@?$ANRemaining?3?5?$AA@	DB	0dH, 'Remaining: ',  00H
	ORG	$-13
??_C@_0BF@LODE@Skip?5all?5bad?5sectors?$AA@	DB	'Skip all bad sectors',  00H
	ORG	$-21
??_C@_0BE@LMLE@?$ANDrive?5decrypted?4?$AN?6?$AA@	DB	0dH, 'Drive decrypted.',  0dH,  0aH,  00H
	ORG	$-20
??_C@_0BJ@HKIB@?$AN?6Decryption?5deferred?4?$AN?6?$AA@	DB	0dH,  0aH, 'Decryption deferred.',  0dH,  0aH,  00H
	ORG	$-25
??_C@_0L@CGGC@Available?5?$AA@	DB	'Available ',  00H
	ORG	$-11
??_C@_03KPOF@?3?$AN?6?$AA@	DB	':',  0dH,  0aH,  00H
	ORG	$-4
??_C@_0CL@PPMD@Permanently?5decrypt?5system?5parti@	DB	'Permanently decrypt system partition/drive',  00H
	ORG	$-43
??_C@_0BO@BJJG@Restore?5GostCrypt?5Boot?5Loader?$AA@	DB	'Restore GostCrypt Boot Loader',  00H
	ORG	$-30
??_C@_0CB@OIIA@Restore?5key?5data?5?$CIvolume?5header?$CJ@	DB	'Restore key data (volume header)',  00H
	ORG	$-33
??_C@_0BP@PLOE@Restore?5original?5system?5loader?$AA@	DB	'Restore original system loader',  00H
	ORG	$-31
$S1777_?options@?3??RepairMenu@@YAXXZ@4QAPBDA	DW	DGROUP:??_C@_0CL@PPMD@Permanently?5decrypt?5system?5parti@
	DW	DGROUP:??_C@_0BO@BJJG@Restore?5GostCrypt?5Boot?5Loader?$AA@
	DW	DGROUP:??_C@_0CB@OIIA@Restore?5key?5data?5?$CIvolume?5header?$CJ@
	DW	DGROUP:??_C@_0BP@PLOE@Restore?5original?5system?5loader?$AA@
	ORG	$-8
??_C@_0CI@CJAH@Is?5the?5system?5partition?1drive?5de@	DB	'Is the system partition/drive decrypted',  00H
	ORG	$-40
??_C@_0BL@HDPH@Please?5decrypt?5it?5first?4?$AN?6?$AA@	DB	'Please decrypt it first.',  0dH,  0aH,  00H
	ORG	$-27
??_C@_0BN@MGAM@Original?5header?5preserved?4?$AN?6?$AA@	DB	'Original header preserved.',  0dH,  0aH,  00H
	ORG	$-29
??_C@_0CM@CODF@WARNING?3?5Drive?50?5contains?5a?5vali@	DB	'WARNING: Drive 0 contains a valid header!',  0dH,  0aH,  00H
	ORG	$-44
??_C@_0P@JAC@Modify?5drive?50?$AA@	DB	'Modify drive 0',  00H
	ORG	$-15
??_C@_0BG@JPHD@GostCrypt?5Boot?5Loader?$AA@	DB	'GostCrypt Boot Loader',  00H
	ORG	$-22
??_C@_06IEHP@Header?$AA@	DB	'Header',  00H
	ORG	$-7
??_C@_0O@MJLK@System?5loader?$AA@	DB	'System loader',  00H
	ORG	$-14
??_C@_0N@HIBI@?5restored?4?$AN?6?$AA@	DB	' restored.',  0dH,  0aH,  00H
	ORG	$-13
??_C@_0CK@MNCE@?9?5Connect?5system?5drive?5to?5?$CISATA?$CJ@	DB	'- Connect system drive to (SATA) port 1',  0dH,  0aH,  00H
	ORG	$-42
??_C@_0CJ@BABO@It?5appears?5you?5are?5creating?5a?5hi@	DB	'It appears you are creating a hidden OS.',  00H
	ORG	$-41
??_C@_0BA@LKAJ@Is?5this?5correct?$AA@	DB	'Is this correct',  00H
	ORG	$-16
??_C@_0DK@PFGO@Please?5remove?5the?5Rescue?5Disk?5fr@	DB	'Please remove the Rescue Disk from the drive and restart.',  00H
_DATA      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT

?InitScreen@@YAXXZ	PROC NEAR	; InitScreen COMDAT
;|*** /**
;|***  *
;|***  *	\file BootMain.cpp
;|***  *	\brief Graphical interface and main boot functions
;|***  *	\version 1.3.1
;|***  *	\date 13/12/2016
;|***  *
;|***  */
;|*** 
;|*** /**
;|***  *	
;|***  *	Copyright (c) 2008-2011 TrueCrypt Developers Association. All rights reserved.
;|***  *	
;|***  *	Governed by the TrueCrypt License 3.0 the full text of which is contained in
;|***  *	the file License.txt included in TrueCrypt binary and source code distribution
;|***  *	packages.
;|***  *	
;|***  */
;|*** 
;|*** #include "Crc.h"
;|*** #include "Crypto.h"
;|*** #include "Password.h"
;|*** #include "Volumes.h"
;|*** 
;|*** #include "Platform.h"
;|*** #include "Bios.h"
;|*** #include "BootConfig.h"
;|*** #include "BootMain.h"
;|*** #include "BootDefs.h"
;|*** #include "BootCommon.h"
;|*** #include "BootConsoleIo.h"
;|*** #include "BootDebug.h"
;|*** #include "BootDiskIo.h"
;|*** #include "BootEncryptedIo.h"
;|*** #include "BootMemory.h"
;|*** #include "BootStrings.h"
;|*** #include "IntFilter.h"
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void InitScreen ()
;|***  *	\brief Clear the screen, print title and print a delimitation bar
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void InitScreen ()
;|*** {
; Line 47
;	title = -2
;|*** 	ClearScreen();
; Line 48
	*** 000000	e8 00 00 		call	?ClearScreen@@YAXXZ	; ClearScreen
;|*** 
;|*** 	const char *title =
;|*** #ifndef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 		" GostCrypt Boot Loader "
;|*** #else
;|*** 		" GostCrypt Rescue Disk "
;|*** #endif
;|*** 		VERSION_STRING "\r\n";
;|*** 
;|*** 	Print (title);
; Line 58
	*** 000003	68 00 00 		push	OFFSET DGROUP:??_C@_0BP@JLCA@?5GostCrypt?5Rescue?5Disk?51?43?41?$AN?6?$AA@
	*** 000006	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000009	5b 			pop	bx
;|*** 
;|*** 	PrintRepeatedChar ('\xDC', GST_BIOS_MAX_CHARS_PER_LINE);
; Line 60
	*** 00000a	6a 50 			push	80	;0050H
	*** 00000c	6a dc 			push	-36	;ffdcH
	*** 00000e	e8 00 00 		call	?PrintRepeatedChar@@YAXDH@Z	; PrintRepeatedChar
	*** 000011	83 c4 04 		add	sp,4
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 	if (CustomUserMessage[0])
;|*** 	{
;|*** 		PrintEndl();
;|*** 		Print (CustomUserMessage);
;|*** 	}
;|*** #endif
;|*** 
;|*** 	PrintEndl (2);
; Line 70
	*** 000014	6a 02 			push	2
	*** 000016	e8 00 00 		call	?PrintEndl@@YAXH@Z	; PrintEndl
	*** 000019	5b 			pop	bx
;|*** }
; Line 71
	*** 00001a	c3 			ret	

?InitScreen@@YAXXZ	ENDP

?PrintMainMenu@@YAXXZ	PROC NEAR	; PrintMainMenu COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void PrintMainMenu ()
;|***  *	\brief Print the main menu (Boot manager and repair options)
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void PrintMainMenu ()
;|*** {
;|*** 	if (PreventBootMenu)
; Line 83
	*** 000000	80 3e 00 00 00 		cmp	BYTE PTR ?PreventBootMenu@@3DA,0	;PreventBootMenu
	*** 000005	75 29 			jne	SHORT $EX1454
;|*** 		return;
;|*** 
;|*** 	Print ("    Keyboard Controls:\r\n");
; Line 86
	*** 000007	68 00 00 		push	OFFSET DGROUP:??_C@_0BJ@CIJ@?5?5?5?5Keyboard?5Controls?3?$AN?6?$AA@
	*** 00000a	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00000d	5b 			pop	bx
;|*** 	Print ("    [Esc]  ");
; Line 87
	*** 00000e	68 00 00 		push	OFFSET DGROUP:??_C@_0M@NCBA@?5?5?5?5?$FLEsc?$FN?5?5?$AA@
	*** 000011	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000014	5b 			pop	bx
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 	Print ((BootSectorFlags & GST_BOOT_CFG_MASK_HIDDEN_OS_CREATION_PHASE) != GST_HIDDEN_OS_CREATION_PHASE_NONE
;|*** 		? "Boot Non-Hidden System (Boot Manager)"
;|*** 		: "Skip Authentication (Boot Manager)");
;|*** 	
;|*** #else // GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 	Print ("Skip Authentication (Boot Manager)");
; Line 97
	*** 000015	68 00 00 		push	OFFSET DGROUP:??_C@_0CD@GJAD@Skip?5Authentication?5?$CIBoot?5Manage@
	*** 000018	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00001b	5b 			pop	bx
;|*** 	Print ("\r\n    [F8]   "); Print ("Repair Options");
; Line 98
	*** 00001c	68 00 00 		push	OFFSET DGROUP:??_C@_0O@MJCG@?$AN?6?5?5?5?5?$FLF8?$FN?5?5?5?$AA@
	*** 00001f	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000022	5b 			pop	bx
	*** 000023	68 00 00 		push	OFFSET DGROUP:??_C@_0P@KAON@Repair?5Options?$AA@
	*** 000026	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000029	5b 			pop	bx
;|*** 
;|*** #endif // GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 	PrintEndl (3);
; Line 102
	*** 00002a	6a 03 			push	3
	*** 00002c	e8 00 00 		call	?PrintEndl@@YAXH@Z	; PrintEndl
	*** 00002f	5b 			pop	bx
;|*** }
; Line 103
					$EX1454:
	*** 000030	c3 			ret	

?PrintMainMenu@@YAXXZ	ENDP

?IsMenuKey@@YADE@Z	PROC NEAR	; IsMenuKey COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static bool IsMenuKey (byte scanCode)
;|***  *	\brief Check if it is a menu key (F8)
;|***  *	\param[in] byte scanCode
;|***  *	\return static bool scanCode == GST_MENU_KEY_REPAIR
;|***  *			false if !GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|***  *
;|***  */
;|*** static bool IsMenuKey (byte scanCode)
;|*** {
; Line 116
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	scanCode = 4
;|*** #ifdef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 	return scanCode == GST_MENU_KEY_REPAIR;
; Line 118
	*** 000003	80 7e 04 42 		cmp	BYTE PTR [bp+4],66	;0042H	;scanCode
	*** 000007	75 04 			jne	SHORT $L1880
	*** 000009	b0 01 			mov	al,1
	*** 00000b	c9 			leave	
	*** 00000c	c3 			ret	
					$L1880:
	*** 00000d	32 c0 			xor	al,al
;|*** #else
;|*** 	return false;
;|*** #endif
;|*** }
; Line 122
	*** 00000f	c9 			leave	
	*** 000010	c3 			ret	

?IsMenuKey@@YADE@Z	ENDP

?AskYesNo@@YADPBD@Z	PROC NEAR	; AskYesNo COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static bool AskYesNo (const char *message)
;|***  *	\brief Ask yes or no to user
;|***  *	\param[in] const char * message
;|***  *	\return static bool true if 'yes' is entered
;|***  *			false if 'no'
;|***  *
;|***  */
;|*** static bool AskYesNo (const char *message)
;|*** {
; Line 135
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	message = 4
;|*** 	Print (message);
; Line 136
	*** 000003	ff 76 04 		push	WORD PTR [bp+4]	;message
	*** 000006	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000009	5b 			pop	bx
;|*** 	Print ("? (y/n): ");
; Line 137
	*** 00000a	68 00 00 		push	OFFSET DGROUP:??_C@_09LGPG@?$DP?5?$CIy?1n?$CJ?3?5?$AA@
	*** 00000d	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000010	5b 			pop	bx
;|*** 	while (true)
; Line 138
	*** 000011	eb 1a 			jmp	SHORT $L1938
					$FC1467:
;|*** 	{
;|*** 		switch (GetKeyboardChar())
; Line 140
	*** 000013	2d 0b 00 		sub	ax,11	;000bH
	*** 000016	7c 12 			jl	SHORT $SD1477
	*** 000018	70 10 			jo	SHORT $SD1477
	*** 00001a	48 			dec	ax
	*** 00001b	7e 25 			jle	SHORT $SC1473
	*** 00001d	2d 14 00 		sub	ax,20	;0014H
	*** 000020	74 15 			je	SHORT $SC1475
	*** 000022	2d 0b 00 		sub	ax,11	;000bH
	*** 000025	7c 03 			jl	SHORT $SD1477
	*** 000027	48 			dec	ax
	*** 000028	7e 18 			jle	SHORT $SC1473
;|*** 		{
;|*** 		case 'y':
;|*** 		case 'Y':
;|*** 		case 'z':
;|*** 		case 'Z':
;|*** 			Print ("y\r\n");
;|*** 			return true;
;|*** 
;|*** 		case 'n':
;|*** 		case 'N':
;|*** 			Print ("n\r\n");
;|*** 			return false;
;|*** 
;|*** 		default:
; Line 154
					$SD1477:
;|*** 			Beep();
; Line 155
	*** 00002a	e8 00 00 		call	?Beep@@YAXXZ	; Beep
;|*** 		}
; Line 156
					$L1938:
	*** 00002d	e8 00 00 		call	?GetKeyboardChar@@YAEXZ	; GetKeyboardChar
	*** 000030	2a e4 			sub	ah,ah
	*** 000032	2d 4e 00 		sub	ax,78	;004eH
	*** 000035	75 dc 			jne	SHORT $FC1467
;|*** 		case 'n':
; Line 149
					$SC1475:
;|*** 		case 'N':
;|*** 			Print ("n\r\n");
; Line 151
	*** 000037	68 00 00 		push	OFFSET DGROUP:??_C@_03EDHP@n?$AN?6?$AA@
	*** 00003a	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00003d	5b 			pop	bx
;|*** 			return false;
; Line 152
	*** 00003e	32 c0 			xor	al,al
	*** 000040	c9 			leave	
	*** 000041	c3 			ret	
;|*** 		case 'y':
; Line 142
					$SC1473:
;|*** 		case 'Y':
;|*** 		case 'z':
;|*** 		case 'Z':
;|*** 			Print ("y\r\n");
; Line 146
	*** 000042	68 00 00 		push	OFFSET DGROUP:??_C@_03NMHE@y?$AN?6?$AA@
	*** 000045	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000048	5b 			pop	bx
;|*** 			return true;
; Line 147
	*** 000049	b0 01 			mov	al,1
;|*** 
;|*** 		case 'n':
;|*** 		case 'N':
;|*** 			Print ("n\r\n");
;|*** 			return false;
;|*** 
;|*** 		default:
;|*** 			Beep();
;|*** 		}
;|*** 	}
;|*** }
; Line 158
	*** 00004b	c9 			leave	
	*** 00004c	c3 			ret	

?AskYesNo@@YADPBD@Z	ENDP

?AskSelection@@YAHQAPBDI@Z	PROC NEAR	; AskSelection COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static int AskSelection (const char *options[], size_t optionCount)
;|***  *	\brief Print options and wait for selection
;|***  *	\param[in] size_t optionCount
;|***  *	\param[in] const char * options[]
;|***  *	\return static int 0 if (GetString (&str, 1) == 0)
;|***  *			(str - '0') else
;|***  *
;|***  */
;|*** static int AskSelection (const char *options[], size_t optionCount)
;|*** {
; Line 172
	*** 000000	c8 02 00 00 		enter	2,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	options = 4
;	optionCount = 6
;	register si = i
;	str = -1
;|*** 	for (int i = 0; i < optionCount; ++i)
; Line 173
	*** 000006	33 f6 			xor	si,si
	*** 000008	8b 7e 06 		mov	di,WORD PTR [bp+6]	;optionCount
	*** 00000b	eb 2f 			jmp	SHORT $L1939
					$F1482:
;|*** 	{
;|*** 		Print ("["); Print (i + 1); Print ("]    ");
; Line 175
	*** 00000d	68 00 00 		push	OFFSET DGROUP:??_C@_01KHLB@?$FL?$AA@
	*** 000010	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000013	5b 			pop	bx
	*** 000014	8d 44 01 		lea	ax,WORD PTR [si+1]
	*** 000017	99 			cwd	
	*** 000018	52 			push	dx
	*** 000019	50 			push	ax
	*** 00001a	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 00001d	83 c4 04 		add	sp,4
	*** 000020	68 00 00 		push	OFFSET DGROUP:??_C@_05EFLO@?$FN?5?5?5?5?$AA@
	*** 000023	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000026	5b 			pop	bx
;|*** 		Print (options[i]);
; Line 176
	*** 000027	8b de 			mov	bx,si
	*** 000029	03 de 			add	bx,si
	*** 00002b	03 5e 04 		add	bx,WORD PTR [bp+4]	;options
	*** 00002e	ff 37 			push	WORD PTR [bx]
	*** 000030	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000033	5b 			pop	bx
;|*** 		PrintEndl();
; Line 177
	*** 000034	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 	for (int i = 0; i < optionCount; ++i)
; Line 173
	*** 000037	8d 44 01 		lea	ax,WORD PTR [si+1]
	*** 00003a	8b f0 			mov	si,ax
					$L1939:
	*** 00003c	3b f7 			cmp	si,di
	*** 00003e	72 cd 			jb	SHORT $F1482
;|*** 	{
;|*** 		Print ("["); Print (i + 1); Print ("]    ");
;|*** 		Print (options[i]);
;|*** 		PrintEndl();
;|*** 	}
;|*** 	Print ("[Esc]  Cancel\r\n\r\n");
; Line 179
	*** 000040	68 00 00 		push	OFFSET DGROUP:??_C@_0BC@DHAO@?$FLEsc?$FN?5?5Cancel?$AN?6?$AN?6?$AA@
	*** 000043	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000046	5b 			pop	bx
;|*** 
;|*** 	Print ("To select, press 1-9: ");
; Line 181
	*** 000047	68 00 00 		push	OFFSET DGROUP:??_C@_0BH@NEPP@To?5select?0?5press?51?99?3?5?$AA@
	*** 00004a	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00004d	5b 			pop	bx
;|*** 
;|*** 	char str;
;|*** 
;|*** 	while (true)
; Line 185
	*** 00004e	eb 17 			jmp	SHORT $L1940
					$FC1491:
;|*** 	{
;|*** 		if (GetString (&str, 1) == 0)
;|*** 			return 0;
;|*** 
;|*** 		if (str >= '1' && str <= optionCount + '0')
; Line 190
	*** 000050	80 7e ff 31 		cmp	BYTE PTR [bp-1],49	;0031H	;str
	*** 000054	7c 0b 			jl	SHORT $I1494
	*** 000056	8a 46 ff 		mov	al,BYTE PTR [bp-1]	;str
	*** 000059	98 			cbw	
	*** 00005a	8d 4d 30 		lea	cx,WORD PTR [di+48]
	*** 00005d	3b c8 			cmp	cx,ax
	*** 00005f	73 18 			jae	SHORT $L1886
;|*** 			return str - '0';
;|*** 
;|*** 		Beep();
; Line 193
					$I1494:
	*** 000061	e8 00 00 		call	?Beep@@YAXXZ	; Beep
;|*** 		PrintBackspace();
; Line 194
	*** 000064	e8 00 00 		call	?PrintBackspace@@YAXXZ	; PrintBackspace
;|*** 	}
; Line 195
					$L1940:
	*** 000067	6a 01 			push	1
	*** 000069	8d 46 ff 		lea	ax,WORD PTR [bp-1]	;str
	*** 00006c	50 			push	ax
	*** 00006d	e8 00 00 		call	?GetString@@YAHPADI@Z	; GetString
	*** 000070	83 c4 04 		add	sp,4
	*** 000073	0b c0 			or	ax,ax
	*** 000075	75 d9 			jne	SHORT $FC1491
;|*** 			return 0;
; Line 188
	*** 000077	eb 07 			jmp	SHORT $EX1480
					$L1886:
;|*** 
;|*** 		if (str >= '1' && str <= optionCount + '0')
;|*** 			return str - '0';
; Line 191
	*** 000079	8a 46 ff 		mov	al,BYTE PTR [bp-1]	;str
	*** 00007c	98 			cbw	
	*** 00007d	2d 30 00 		sub	ax,48	;0030H
;|*** 
;|*** 		Beep();
;|*** 		PrintBackspace();
;|*** 	}
;|*** }
; Line 196
					$EX1480:
	*** 000080	5e 			pop	si
	*** 000081	5f 			pop	di
	*** 000082	c9 			leave	
	*** 000083	c3 			ret	

?AskSelection@@YAHQAPBDI@Z	ENDP

?AskPassword@@YAEAAUPassword@@@Z	PROC NEAR	; AskPassword COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static byte AskPassword (Password &password)
;|***  *	\brief Ask password to user
;|***  *	\param[in] Password & password
;|***  *	\return static byte
;|***  *
;|***  */
;|*** static byte AskPassword (Password &password)
;|*** {
; Line 208
	*** 000000	c8 02 00 00 		enter	2,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	password = 4
;	register si = pos
;	scanCode = -2
;	asciiCode = -1
;|*** 	size_t pos = 0;
; Line 209
	*** 000006	33 f6 			xor	si,si
;|*** 	byte scanCode;
;|*** 	byte asciiCode;
;|*** 
;|*** 	Print ("Enter password");
; Line 213
	*** 000008	68 00 00 		push	OFFSET DGROUP:??_C@_0P@EOMF@Enter?5password?$AA@
	*** 00000b	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00000e	5b 			pop	bx
;|*** 	Print (PreventNormalSystemBoot ? " for hidden system:\r\n" : ": ");
; Line 214
	*** 00000f	80 3e 00 00 00 		cmp	BYTE PTR ?PreventNormalSystemBoot@@3DA,0	;PreventNormalSystemBoot
	*** 000014	74 05 			je	SHORT $L1888
	*** 000016	b8 00 00 		mov	ax,OFFSET DGROUP:??_C@_0BG@GEFN@?5for?5hidden?5system?3?$AN?6?$AA@
	*** 000019	eb 03 			jmp	SHORT $L1889
					$L1888:
	*** 00001b	b8 00 00 		mov	ax,OFFSET DGROUP:??_C@_02HFBK@?3?5?$AA@
					$L1889:
	*** 00001e	50 			push	ax
	*** 00001f	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000022	5b 			pop	bx
	*** 000023	8b 7e 04 		mov	di,WORD PTR [bp+4]	;password
;|*** 
;|*** 	while (true)
; Line 216
	*** 000026	eb 4c 			jmp	SHORT $L1942
					$FC1504:
;|*** 	{
;|*** 		asciiCode = GetKeyboardChar (&scanCode);
; Line 218
	*** 000028	2d 0e 00 		sub	ax,14	;000eH
	*** 00002b	0f 84 85 00 		je	$SC1510
;|*** 
;|*** 		switch (scanCode)
;|*** 		{
;|*** 		case GST_BIOS_KEY_ENTER:
;|*** 			ClearBiosKeystrokeBuffer();
;|*** 			PrintEndl();
;|*** 
;|*** 			password.Length = pos;
;|*** 			return scanCode;
;|*** 
;|*** 		case GST_BIOS_KEY_BACKSPACE:
;|*** 			if (pos > 0)
;|*** 			{
;|*** 				if (pos < MAX_PASSWORD)
;|*** 					PrintBackspace();
;|*** 				else
;|*** 					PrintCharAtCursor (' ');
;|*** 
;|*** 				--pos;
;|*** 			}
;|*** 			continue;
;|*** 
;|*** 		default:
;|*** 			if (scanCode == GST_BIOS_KEY_ESC || IsMenuKey (scanCode))
; Line 242
	*** 00002f	80 7e fe 01 		cmp	BYTE PTR [bp-2],1	;scanCode
	*** 000033	74 6b 			je	SHORT $I1517
	*** 000035	8a 46 fe 		mov	al,BYTE PTR [bp-2]	;scanCode
	*** 000038	50 			push	ax
	*** 000039	e8 00 00 		call	?IsMenuKey@@YADE@Z	; IsMenuKey
	*** 00003c	5b 			pop	bx
	*** 00003d	0a c0 			or	al,al
	*** 00003f	75 5f 			jne	SHORT $I1517
;|*** 			{
;|*** 				burn (password.Text, sizeof (password.Text));
;|*** 				ClearBiosKeystrokeBuffer();
;|*** 
;|*** 				PrintEndl();
;|*** 				return scanCode;
;|*** 			}
;|*** 		}
;|*** 
;|*** 		if (!IsPrintable (asciiCode) || pos == MAX_PASSWORD)
; Line 252
	*** 000041	8a 46 ff 		mov	al,BYTE PTR [bp-1]	;asciiCode
	*** 000044	50 			push	ax
	*** 000045	e8 00 00 		call	?IsPrintable@@YADD@Z	; IsPrintable
	*** 000048	5b 			pop	bx
	*** 000049	0a c0 			or	al,al
	*** 00004b	74 24 			je	SHORT $I1519
	*** 00004d	83 fe 40 		cmp	si,64	;0040H
	*** 000050	74 1f 			je	SHORT $I1519
;|*** 		{
;|*** 			Beep();
;|*** 			continue;
;|*** 		}
;|*** 
;|*** 		password.Text[pos++] = asciiCode;
; Line 258
	*** 000052	8a 46 ff 		mov	al,BYTE PTR [bp-1]	;asciiCode
	*** 000055	8b de 			mov	bx,si
	*** 000057	03 df 			add	bx,di
	*** 000059	46 			inc	si
	*** 00005a	88 47 04 		mov	BYTE PTR [bx+4],al
;|*** 		if (pos < MAX_PASSWORD)
; Line 259
	*** 00005d	83 fe 40 		cmp	si,64	;0040H
	*** 000060	73 08 			jae	SHORT $I1520
;|*** 			PrintChar ('*');
; Line 260
	*** 000062	6a 2a 			push	42	;002aH
	*** 000064	e8 00 00 		call	?PrintChar@@YAXD@Z	; PrintChar
					$L1941:
	*** 000067	5b 			pop	bx
;|*** 		else
; Line 261
	*** 000068	eb 0a 			jmp	SHORT $L1942
					$I1520:
;|*** 			PrintCharAtCursor ('*');
; Line 262
	*** 00006a	6a 2a 			push	42	;002aH
	*** 00006c	e8 00 00 		call	?PrintCharAtCursor@@YAXD@Z	; PrintCharAtCursor
	*** 00006f	eb f6 			jmp	SHORT $L1941
;|*** 		if (!IsPrintable (asciiCode) || pos == MAX_PASSWORD)
; Line 252
					$I1519:
;|*** 		{
;|*** 			Beep();
; Line 254
	*** 000071	e8 00 00 		call	?Beep@@YAXXZ	; Beep
;|*** 			continue;
; Line 255
					$L1942:
	*** 000074	8d 46 fe 		lea	ax,WORD PTR [bp-2]	;scanCode
	*** 000077	50 			push	ax
	*** 000078	e8 00 00 		call	?GetKeyboardChar@@YAEPAE@Z	; GetKeyboardChar
	*** 00007b	5b 			pop	bx
	*** 00007c	88 46 ff 		mov	BYTE PTR [bp-1],al	;asciiCode
;|*** 		switch (scanCode)
; Line 220
	*** 00007f	8a 46 fe 		mov	al,BYTE PTR [bp-2]	;scanCode
	*** 000082	2a e4 			sub	ah,ah
;|*** 		{
;|*** 		case GST_BIOS_KEY_ENTER:
;|*** 			ClearBiosKeystrokeBuffer();
;|*** 			PrintEndl();
;|*** 
;|*** 			password.Length = pos;
;|*** 			return scanCode;
;|*** 
;|*** 		case GST_BIOS_KEY_BACKSPACE:
;|*** 			if (pos > 0)
;|*** 			{
;|*** 				if (pos < MAX_PASSWORD)
;|*** 					PrintBackspace();
;|*** 				else
;|*** 					PrintCharAtCursor (' ');
;|*** 
;|*** 				--pos;
;|*** 			}
;|*** 			continue;
;|*** 
;|*** 		default:
;|*** 			if (scanCode == GST_BIOS_KEY_ESC || IsMenuKey (scanCode))
;|*** 			{
;|*** 				burn (password.Text, sizeof (password.Text));
;|*** 				ClearBiosKeystrokeBuffer();
;|*** 
;|*** 				PrintEndl();
;|*** 				return scanCode;
;|*** 			}
;|*** 		}
; Line 250
	*** 000084	2d 0e 00 		sub	ax,14	;000eH
	*** 000087	75 9f 			jne	SHORT $FC1504
;|*** 			if (pos > 0)
; Line 230
	*** 000089	0b f6 			or	si,si
	*** 00008b	74 e7 			je	SHORT $L1942
;|*** 			{
;|*** 				if (pos < MAX_PASSWORD)
; Line 232
	*** 00008d	83 fe 40 		cmp	si,64	;0040H
	*** 000090	73 05 			jae	SHORT $I1513
;|*** 					PrintBackspace();
; Line 233
	*** 000092	e8 00 00 		call	?PrintBackspace@@YAXXZ	; PrintBackspace
;|*** 				else
; Line 234
	*** 000095	eb 06 			jmp	SHORT $I1514
					$I1513:
;|*** 					PrintCharAtCursor (' ');
; Line 235
	*** 000097	6a 20 			push	32	;0020H
	*** 000099	e8 00 00 		call	?PrintCharAtCursor@@YAXD@Z	; PrintCharAtCursor
	*** 00009c	5b 			pop	bx
					$I1514:
;|*** 
;|*** 				--pos;
; Line 237
	*** 00009d	4e 			dec	si
;|*** 			}
;|*** 			continue;
; Line 239
	*** 00009e	eb d4 			jmp	SHORT $L1942
;|*** 
;|*** 		default:
;|*** 			if (scanCode == GST_BIOS_KEY_ESC || IsMenuKey (scanCode))
; Line 242
					$I1517:
;|*** 			{
;|*** 				burn (password.Text, sizeof (password.Text));
; Line 244
	*** 0000a0	6a 41 			push	65	;0041H
	*** 0000a2	8d 45 04 		lea	ax,WORD PTR [di+4]
	*** 0000a5	50 			push	ax
	*** 0000a6	e8 00 00 		call	_EraseMemory
	*** 0000a9	83 c4 04 		add	sp,4
;|*** 				ClearBiosKeystrokeBuffer();
; Line 245
	*** 0000ac	e8 00 00 		call	?ClearBiosKeystrokeBuffer@@YAXXZ	; ClearBiosKeystrokeBuffer
;|*** 
;|*** 				PrintEndl();
; Line 247
	*** 0000af	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
	*** 0000b2	eb 0d 			jmp	SHORT $L1943
;|*** 		case GST_BIOS_KEY_ENTER:
; Line 222
					$SC1510:
;|*** 			ClearBiosKeystrokeBuffer();
; Line 223
	*** 0000b4	e8 00 00 		call	?ClearBiosKeystrokeBuffer@@YAXXZ	; ClearBiosKeystrokeBuffer
;|*** 			PrintEndl();
; Line 224
	*** 0000b7	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 
;|*** 			password.Length = pos;
; Line 226
	*** 0000ba	89 35 			mov	WORD PTR [di],si
	*** 0000bc	c7 45 02 00 00 		mov	WORD PTR [di+2],0
;|*** 			return scanCode;
; Line 227
					$L1943:
	*** 0000c1	8a 46 fe 		mov	al,BYTE PTR [bp-2]	;scanCode
;|*** 
;|*** 		case GST_BIOS_KEY_BACKSPACE:
;|*** 			if (pos > 0)
;|*** 			{
;|*** 				if (pos < MAX_PASSWORD)
;|*** 					PrintBackspace();
;|*** 				else
;|*** 					PrintCharAtCursor (' ');
;|*** 
;|*** 				--pos;
;|*** 			}
;|*** 			continue;
;|*** 
;|*** 		default:
;|*** 			if (scanCode == GST_BIOS_KEY_ESC || IsMenuKey (scanCode))
;|*** 			{
;|*** 				burn (password.Text, sizeof (password.Text));
;|*** 				ClearBiosKeystrokeBuffer();
;|*** 
;|*** 				PrintEndl();
;|*** 				return scanCode;
;|*** 			}
;|*** 		}
;|*** 
;|*** 		if (!IsPrintable (asciiCode) || pos == MAX_PASSWORD)
;|*** 		{
;|*** 			Beep();
;|*** 			continue;
;|*** 		}
;|*** 
;|*** 		password.Text[pos++] = asciiCode;
;|*** 		if (pos < MAX_PASSWORD)
;|*** 			PrintChar ('*');
;|*** 		else
;|*** 			PrintCharAtCursor ('*');
;|*** 	}
;|*** }
; Line 264
	*** 0000c4	5e 			pop	si
	*** 0000c5	5f 			pop	di
	*** 0000c6	c9 			leave	
	*** 0000c7	c3 			ret	

?AskPassword@@YAEAAUPassword@@@Z	ENDP

?ExecuteBootSector@@YAXEPAE@Z	PROC NEAR	; ExecuteBootSector COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void ExecuteBootSector (byte drive, byte *sectorBuffer)
;|***  *	\brief Execute the boot sector (MBR)
;|***  *	\param[in] byte * sectorBuffer
;|***  *	\param[in] byte drive
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void ExecuteBootSector (byte drive, byte *sectorBuffer)
;|*** {
; Line 277
	*** 000000	c8 04 00 00 		enter	4,0
	*** 000004	56 			push	si
;	addr = -4
;	sectorBuffer = 6
;	drive = 4
;|*** 	Print ("Booting...\r\n");
; Line 278
	*** 000005	68 00 00 		push	OFFSET DGROUP:??_C@_0N@DGHN@Booting?4?4?4?$AN?6?$AA@
	*** 000008	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00000b	5b 			pop	bx
;|*** 	CopyMemory (sectorBuffer, 0x0000, 0x7c00, GST_LB_SIZE);
; Line 279
	*** 00000c	66 68 00 7c 00 02 	push	DWORD PTR 33586176	;02007c00H
	*** 000012	6a 00 			push	0
	*** 000014	ff 76 06 		push	WORD PTR [bp+6]	;sectorBuffer
	*** 000017	e8 00 00 		call	?CopyMemory@@YAXPAXIII@Z	; CopyMemory
	*** 00001a	83 c4 08 		add	sp,8
;|*** 
;|*** 	BootStarted = true;
; Line 281
	*** 00001d	c6 06 00 00 01 		mov	BYTE PTR ?BootStarted@@3DA,1	;BootStarted
;|*** 
;|*** 	uint32 addr = 0x7c00;
; Line 283
	*** 000022	66 c7 46 fc 00 7c 00 00 mov	DWORD PTR [bp-4],31744	;00007c00H	;addr
;|*** 	__asm
;|*** 	{
;|*** 		cli
; Line 286
	*** 00002a	fa 			cli	
;|*** 		mov dl, drive	// Boot drive
; Line 287
	*** 00002b	8a 56 04 		mov	dl,BYTE PTR [bp+4]	;drive
;|*** 		mov dh, 0
; Line 288
	*** 00002e	b6 00 			mov	dh,0
;|*** 		xor ax, ax
; Line 289
	*** 000030	33 c0 			xor	ax,ax
;|*** 		mov si, ax
; Line 290
	*** 000032	8b f0 			mov	si,ax
;|*** 		mov ds, ax
; Line 291
	*** 000034	8e d8 			mov	ds,ax
;|*** 		mov es, ax
; Line 292
	*** 000036	8e c0 			mov	es,ax
;|*** 		mov ss, ax
; Line 293
	*** 000038	8e d0 			mov	ss,ax
;|*** 		mov sp, 0x7c00
; Line 294
	*** 00003a	bc 00 7c 		mov	sp,31744	;7c00H
;|*** 		sti
; Line 295
	*** 00003d	fb 			sti	
;|*** 
;|*** 		jmp cs:addr
; Line 297
	*** 00003e	2e ff 6e fc 		jmp	DWORD PTR cs:[bp-4]	;addr
;|*** 	}
; Line 298
;|*** }
; Line 299
	*** 000042	5e 			pop	si
	*** 000043	c9 			leave	
	*** 000044	c3 			ret	

?ExecuteBootSector@@YAXEPAE@Z	ENDP

?OpenVolume@@YADEAAUPassword@@PAPAUCRYPTO_INFO_t@@PAKDD@Z	PROC NEAR	; OpenVolume COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static bool OpenVolume (byte drive, Password &password, CRYPTO_INFO **cryptoInfo, uint32 *headerSaltCrc32, bool skipNormal, bool skipHidden)
;|***  *	\brief Open a Volume
;|***  *	\param[in] bool skipHidden
;|***  *	\param[in] bool skipNormal
;|***  *	\param[in] uint32 * headerSaltCrc32
;|***  *	\param[in] CRYPTO_INFO ** cryptoInfo
;|***  *	\param[in] Password & password
;|***  *	\param[in] byte drive
;|***  *	\return static bool (volumeType != 3)
;|***  *
;|***  */
;|*** static bool OpenVolume (byte drive, Password &password, CRYPTO_INFO **cryptoInfo, uint32 *headerSaltCrc32, bool skipNormal, bool skipHidden)
;|*** {
; Line 315
	*** 000000	c8 14 00 00 		enter	20,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	headerSec = -12
;	drive = 4
;	password = 6
;	cryptoInfo = 8
;	headerSaltCrc32 = 10
;	skipNormal = 12
;	skipHidden = 14
;	volumeType = -4
;	hiddenVolume = -1
;|*** 	int volumeType;
;|*** 	bool hiddenVolume;
;|*** 	uint64 headerSec;
;|*** 
;|*** 	AcquireSectorBuffer();
;|*** 
;|*** 	for (volumeType = 1; volumeType <= 2; ++volumeType)
; Line 322
	*** 000006	c7 46 fc 01 00 		mov	WORD PTR [bp-4],1	;volumeType
					$F1537:
	*** 00000b	83 7e fc 02 		cmp	WORD PTR [bp-4],2	;volumeType
	*** 00000f	0f 8f d5 00 		jg	$FB1539
;|*** 	{
;|*** 		hiddenVolume = (volumeType == 2);
;|*** 
;|*** 		if (hiddenVolume)
; Line 326
	*** 000013	75 04 			jne	SHORT $L1892
	*** 000015	b0 01 			mov	al,1
	*** 000017	eb 02 			jmp	SHORT $L1893
					$L1892:
	*** 000019	32 c0 			xor	al,al
					$L1893:
	*** 00001b	88 46 ff 		mov	BYTE PTR [bp-1],al	;hiddenVolume
	*** 00001e	0a c0 			or	al,al
	*** 000020	74 43 			je	SHORT $I1540
;|*** 		{
;|*** 			if (skipHidden || PartitionFollowingActive.Drive != drive || PartitionFollowingActive.SectorCount <= ActivePartition.SectorCount)
; Line 328
	*** 000022	80 7e 0e 00 		cmp	BYTE PTR [bp+14],0	;skipHidden
	*** 000026	0f 85 a0 00 		jne	$FC1538
	*** 00002a	a0 01 00 		mov	al,BYTE PTR ?PartitionFollowingActive@@3UPartition@@A+1	;PartitionFollowingActive
	*** 00002d	38 46 04 		cmp	BYTE PTR [bp+4],al	;drive
	*** 000030	0f 85 96 00 		jne	$FC1538
	*** 000034	68 0e 00 		push	OFFSET ?ActivePartition@@3UPartition@@A+14	;ActivePartition
	*** 000037	68 0e 00 		push	OFFSET ?PartitionFollowingActive@@3UPartition@@A+14	;PartitionFollowingActive
	*** 00003a	e8 00 00 		call	??N@YADABTUINT64_STRUCT@@0@Z	; operator<=
	*** 00003d	83 c4 04 		add	sp,4
	*** 000040	0a c0 			or	al,al
	*** 000042	0f 85 84 00 		jne	$FC1538
;|*** 				continue;
;|*** 
;|*** 			headerSec = PartitionFollowingActive.StartSector + GST_HIDDEN_VOLUME_HEADER_OFFSET / GST_LB_SIZE;
; Line 331
	*** 000046	6a 00 			push	0
	*** 000048	68 80 00 		push	128	;0080H
	*** 00004b	68 16 00 		push	OFFSET ?PartitionFollowingActive@@3UPartition@@A+22	;PartitionFollowingActive
	*** 00004e	8d 46 ec 		lea	ax,WORD PTR [bp-20]
	*** 000051	50 			push	ax
	*** 000052	e8 00 00 		call	??H@YA?ATUINT64_STRUCT@@ABT0@K@Z	; operator+
	*** 000055	83 c4 08 		add	sp,8
	*** 000058	8d 7e f4 		lea	di,WORD PTR [bp-12]	;headerSec
	*** 00005b	8b f0 			mov	si,ax
	*** 00005d	16 			push	ss
	*** 00005e	07 			pop	es
	*** 00005f	66 a5 			movsd
	*** 000061	66 a5 			movsd
;|*** 		}
;|*** 		else
; Line 333
	*** 000063	eb 15 			jmp	SHORT $I1544
					$I1540:
;|*** 		{
;|*** 			if (skipNormal)
; Line 335
	*** 000065	80 7e 0c 00 		cmp	BYTE PTR [bp+12],0	;skipNormal
	*** 000069	75 5f 			jne	SHORT $FC1538
;|*** 				continue;
;|*** 
;|*** 			headerSec.HighPart = 0;
; Line 338
	*** 00006b	66 2b c0 		sub	eax,eax
	*** 00006e	66 89 46 f8 		mov	DWORD PTR [bp-8],eax
;|*** 			headerSec.LowPart = GST_BOOT_VOLUME_HEADER_SECTOR;
; Line 339
	*** 000072	c7 46 f4 3e 00 		mov	WORD PTR [bp-12],62	;003eH	;headerSec
	*** 000077	89 46 f6 		mov	WORD PTR [bp-10],ax
;|*** 		}
; Line 340
					$I1544:
;|*** 
;|*** 		if (ReadSectors (SectorBuffer, drive, headerSec, 1) != BiosResultSuccess)
; Line 342
	*** 00007a	6a 00 			push	0
	*** 00007c	6a 01 			push	1
	*** 00007e	8d 46 f4 		lea	ax,WORD PTR [bp-12]	;headerSec
	*** 000081	50 			push	ax
	*** 000082	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000085	50 			push	ax
	*** 000086	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000089	e8 00 00 		call	?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; ReadSectors
	*** 00008c	83 c4 0a 		add	sp,10	;000aH
	*** 00008f	0a c0 			or	al,al
	*** 000091	75 37 			jne	SHORT $FC1538
;|*** 			continue;
;|*** 
;|*** 		if (ReadVolumeHeader (!hiddenVolume, (char *) SectorBuffer, &password, cryptoInfo, nullptr) == ERR_SUCCESS)
; Line 345
	*** 000093	6a 00 			push	0
	*** 000095	66 ff 76 06 		push	DWORD PTR [bp+6]	;password
	*** 000099	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 00009c	80 7e ff 01 		cmp	BYTE PTR [bp-1],1	;hiddenVolume
	*** 0000a0	1a c0 			sbb	al,al
	*** 0000a2	f6 d8 			neg	al
	*** 0000a4	50 			push	ax
	*** 0000a5	e8 00 00 		call	_ReadVolumeHeader
	*** 0000a8	83 c4 0a 		add	sp,10	;000aH
	*** 0000ab	0b c0 			or	ax,ax
	*** 0000ad	75 1b 			jne	SHORT $FC1538
;|*** 		{
;|*** 			// Prevent opening a non-system hidden volume
;|*** 			if (hiddenVolume && !((*cryptoInfo)->HeaderFlags & GST_HEADER_FLAG_ENCRYPTED_SYSTEM))
; Line 348
	*** 0000af	80 7e ff 00 		cmp	BYTE PTR [bp-1],0	;hiddenVolume
	*** 0000b3	74 1b 			je	SHORT $I1549
	*** 0000b5	8b 5e 08 		mov	bx,WORD PTR [bp+8]	;cryptoInfo
	*** 0000b8	8b 1f 			mov	bx,WORD PTR [bx]
	*** 0000ba	f6 87 5e 04 01 		test	BYTE PTR [bx+1118],1
	*** 0000bf	75 0f 			jne	SHORT $I1549
;|*** 			{
;|*** 				crypto_close (*cryptoInfo);
; Line 350
	*** 0000c1	8b 5e 08 		mov	bx,WORD PTR [bp+8]	;cryptoInfo
	*** 0000c4	ff 37 			push	WORD PTR [bx]
	*** 0000c6	e8 00 00 		call	_crypto_close
	*** 0000c9	5b 			pop	bx
;|*** 	for (volumeType = 1; volumeType <= 2; ++volumeType)
; Line 322
					$FC1538:
	*** 0000ca	ff 46 fc 		inc	WORD PTR [bp-4]	;volumeType
	*** 0000cd	e9 3b ff 		jmp	$F1537
;|*** 	{
;|*** 		hiddenVolume = (volumeType == 2);
;|*** 
;|*** 		if (hiddenVolume)
;|*** 		{
;|*** 			if (skipHidden || PartitionFollowingActive.Drive != drive || PartitionFollowingActive.SectorCount <= ActivePartition.SectorCount)
;|*** 				continue;
;|*** 
;|*** 			headerSec = PartitionFollowingActive.StartSector + GST_HIDDEN_VOLUME_HEADER_OFFSET / GST_LB_SIZE;
;|*** 		}
;|*** 		else
;|*** 		{
;|*** 			if (skipNormal)
;|*** 				continue;
;|*** 
;|*** 			headerSec.HighPart = 0;
;|*** 			headerSec.LowPart = GST_BOOT_VOLUME_HEADER_SECTOR;
;|*** 		}
;|*** 
;|*** 		if (ReadSectors (SectorBuffer, drive, headerSec, 1) != BiosResultSuccess)
;|*** 			continue;
;|*** 
;|*** 		if (ReadVolumeHeader (!hiddenVolume, (char *) SectorBuffer, &password, cryptoInfo, nullptr) == ERR_SUCCESS)
;|*** 		{
;|*** 			// Prevent opening a non-system hidden volume
;|*** 			if (hiddenVolume && !((*cryptoInfo)->HeaderFlags & GST_HEADER_FLAG_ENCRYPTED_SYSTEM))
;|*** 			{
;|*** 				crypto_close (*cryptoInfo);
;|*** 				continue;
;|*** 			}
;|*** 
;|*** 			if (headerSaltCrc32)
; Line 354
					$I1549:
	*** 0000d0	39 46 0a 		cmp	WORD PTR [bp+10],ax	;headerSaltCrc32
	*** 0000d3	74 13 			je	SHORT $FB1539
;|*** 				*headerSaltCrc32 = GetCrc32 (SectorBuffer, PKCS5_SALT_SIZE);
; Line 355
	*** 0000d5	6a 40 			push	64	;0040H
	*** 0000d7	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 0000da	e8 00 00 		call	_GetCrc32
	*** 0000dd	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;headerSaltCrc32
	*** 0000e0	83 c4 04 		add	sp,4
	*** 0000e3	89 07 			mov	WORD PTR [bx],ax
	*** 0000e5	89 57 02 		mov	WORD PTR [bx+2],dx
;|*** 
;|*** 			break;
;|*** 		}
;|*** 	}
; Line 359
					$FB1539:
;|*** 
;|*** 	ReleaseSectorBuffer();
;|*** 	return volumeType != 3;
; Line 362
	*** 0000e8	83 7e fc 03 		cmp	WORD PTR [bp-4],3	;volumeType
	*** 0000ec	74 04 			je	SHORT $L1896
	*** 0000ee	b0 01 			mov	al,1
	*** 0000f0	eb 02 			jmp	SHORT $L1897
					$L1896:
	*** 0000f2	32 c0 			xor	al,al
					$L1897:
;|*** }
; Line 363
	*** 0000f4	5e 			pop	si
	*** 0000f5	5f 			pop	di
	*** 0000f6	c9 			leave	
	*** 0000f7	c3 			ret	

?OpenVolume@@YADEAAUPassword@@PAPAUCRYPTO_INFO_t@@PAKDD@Z	ENDP

?CheckMemoryRequirements@@YADXZ	PROC NEAR	; CheckMemoryRequirements COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static bool CheckMemoryRequirements ()
;|***  *	\brief Check the memory requirements and print it
;|***  *	\return static bool false if codeSeg == GST_BOOT_LOADER_LOWMEM_SEGMENT
;|***  *			true else
;|***  *
;|***  */
;|*** static bool CheckMemoryRequirements ()
;|*** {
; Line 375
	*** 000000	c8 04 00 00 		enter	4,0
;	codeSeg = -2
;|*** 	uint16 codeSeg;
;|*** 	__asm mov codeSeg, cs
; Line 377
	*** 000004	8c 4e fe 		mov	WORD PTR [bp-2],cs	;codeSeg
;|*** 	if (codeSeg == GST_BOOT_LOADER_LOWMEM_SEGMENT)
; Line 378
	*** 000007	81 7e fe 00 20 		cmp	WORD PTR [bp-2],8192	;2000H	;codeSeg
	*** 00000c	75 2e 			jne	SHORT $I1555
;|*** 	{
; Line 379
;	memFree = -4
;|*** 		PrintErrorNoEndl ("BIOS reserved too much memory: ");
; Line 380
	*** 00000e	68 00 00 		push	OFFSET DGROUP:??_C@_0CA@FBFB@BIOS?5reserved?5too?5much?5memory?3?5?$AA@
	*** 000011	e8 00 00 		call	?PrintErrorNoEndl@@YAXPBD@Z	; PrintErrorNoEndl
	*** 000014	5b 			pop	bx
;|*** 
;|*** 		uint16 memFree;
;|*** 		__asm
;|*** 		{
;|*** 			push es
; Line 385
	*** 000015	06 			push	es
;|*** 			xor ax, ax
; Line 386
	*** 000016	33 c0 			xor	ax,ax
;|*** 			mov es, ax
; Line 387
	*** 000018	8e c0 			mov	es,ax
;|*** 			mov ax, es:[0x413]
; Line 388
	*** 00001a	26 8b 06 13 04 		mov	ax,WORD PTR es:1043
;|*** 			mov memFree, ax
; Line 389
	*** 00001f	89 46 fc 		mov	WORD PTR [bp-4],ax	;memFree
;|*** 			pop es
; Line 390
	*** 000022	07 			pop	es
;|*** 		}
; Line 391
;|*** 
;|*** 		Print (memFree);
; Line 393
	*** 000023	6a 00 			push	0
	*** 000025	ff 76 fc 		push	WORD PTR [bp-4]	;memFree
	*** 000028	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 00002b	83 c4 04 		add	sp,4
;|*** 		PrintEndl();
; Line 394
	*** 00002e	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 		Print (GST_BOOT_STR_UPGRADE_BIOS);
; Line 395
	*** 000031	68 00 00 		push	OFFSET DGROUP:??_C@_0DM@HBD@?9?5Upgrade?5BIOS?$AN?6?9?5Use?5a?5differen@
	*** 000034	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000037	5b 			pop	bx
;|*** 
;|*** 		return false;
; Line 397
	*** 000038	32 c0 			xor	al,al
	*** 00003a	c9 			leave	
	*** 00003b	c3 			ret	
;|*** 	}
;|*** 
;|*** 	return true;
; Line 400
					$I1555:
	*** 00003c	b0 01 			mov	al,1
;|*** }
; Line 401
	*** 00003e	c9 			leave	
	*** 00003f	c3 			ret	

?CheckMemoryRequirements@@YADXZ	ENDP

?MountVolume@@YADEAAEDD@Z	PROC NEAR	; MountVolume COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static bool MountVolume (byte drive, byte &exitKey, bool skipNormal, bool skipHidden)
;|***  *	\brief Mount a volume and print Errors/Warnings
;|***  *	\param[in] bool skipHidden
;|***  *	\param[in] bool skipNormal
;|***  *	\param[in] byte & exitKey
;|***  *	\param[in] byte drive
;|***  *	\return static bool false if exitKey != GST_BIOS_KEY_ENTER
;|***  *			true else
;|***  *
;|***  */
;|*** static bool MountVolume (byte drive, byte &exitKey, bool skipNormal, bool skipHidden)
;|*** {
; Line 417
	*** 000000	c8 0a 00 00 		enter	10,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	drive = 4
;	exitKey = 6
;	skipNormal = 8
;	skipHidden = 10
;	bootArguments = -2
;	register di = incorrectPasswordCount
;|*** 	BootArguments *bootArguments = (BootArguments *) GST_BOOT_LOADER_ARGS_OFFSET;
;|*** 	int incorrectPasswordCount = 0;
; Line 419
	*** 000006	33 ff 			xor	di,di
;|*** 
;|*** 	EraseMemory (bootArguments, sizeof (*bootArguments));
; Line 421
	*** 000008	6a 76 			push	118	;0076H
	*** 00000a	b8 10 00 		mov	ax,16	;0010H
	*** 00000d	89 46 fe 		mov	WORD PTR [bp-2],ax	;bootArguments
	*** 000010	50 			push	ax
	*** 000011	e8 00 00 		call	_EraseMemory
	*** 000014	83 c4 04 		add	sp,4
	*** 000017	8b 76 06 		mov	si,WORD PTR [bp+6]	;exitKey
;|*** 
;|*** 	// Open volume header
;|*** 	while (true)
; Line 424
	*** 00001a	eb 3f 			jmp	SHORT $L1944
					$FC1569:
;|*** 	{
;|*** 		exitKey = AskPassword (bootArguments->BootPassword);
;|*** 
;|*** 		if (exitKey != GST_BIOS_KEY_ENTER)
;|*** 			return false;
;|*** 
;|*** 		if (OpenVolume (BootDrive, bootArguments->BootPassword, &BootCryptoInfo, &bootArguments->HeaderSaltCrc32, skipNormal, skipHidden))
; Line 431
	*** 00001c	8a 46 0a 		mov	al,BYTE PTR [bp+10]	;skipHidden
	*** 00001f	50 			push	ax
	*** 000020	8a 46 08 		mov	al,BYTE PTR [bp+8]	;skipNormal
	*** 000023	50 			push	ax
	*** 000024	6a 1e 			push	30	;001eH
	*** 000026	68 00 00 		push	OFFSET ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 000029	6a 22 			push	34	;0022H
	*** 00002b	a0 00 00 		mov	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 00002e	50 			push	ax
	*** 00002f	e8 00 00 		call	?OpenVolume@@YADEAAUPassword@@PAPAUCRYPTO_INFO_t@@PAKDD@Z	; OpenVolume
	*** 000032	83 c4 0c 		add	sp,12	;000cH
	*** 000035	0a c0 			or	al,al
	*** 000037	75 33 			jne	SHORT $L1902
;|*** 			break;
;|*** 
;|*** 		if (GetShiftFlags() & GST_BIOS_SHIFTMASK_CAPSLOCK)
; Line 434
	*** 000039	e8 00 00 		call	?GetShiftFlags@@YAEXZ	; GetShiftFlags
	*** 00003c	a8 40 			test	al,64	;0040H
	*** 00003e	74 07 			je	SHORT $I1573
;|*** 			Print ("Warning: Caps Lock is on.\r\n");
; Line 435
	*** 000040	68 00 00 		push	OFFSET DGROUP:??_C@_0BM@NMNK@Warning?3?5Caps?5Lock?5is?5on?4?$AN?6?$AA@
	*** 000043	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000046	5b 			pop	bx
;|*** 
;|*** 		Print ("Incorrect password.\r\n\r\n");
; Line 437
					$I1573:
	*** 000047	68 00 00 		push	OFFSET DGROUP:??_C@_0BI@KFOG@Incorrect?5password?4?$AN?6?$AN?6?$AA@
	*** 00004a	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00004d	5b 			pop	bx
;|*** 
;|*** 		if (++incorrectPasswordCount == 4)
; Line 439
	*** 00004e	47 			inc	di
	*** 00004f	83 ff 04 		cmp	di,4
	*** 000052	75 07 			jne	SHORT $L1944
;|*** 		{
;|*** #ifdef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 			Print ("If you are sure the password is correct, the key data may be damaged.\r\n"
;|*** 				   "If so, use 'Repair Options' > 'Restore key data'.\r\n\r\n");
; Line 443
	*** 000054	68 00 00 		push	OFFSET DGROUP:??_C@_0HN@LBMO@If?5you?5are?5sure?5the?5password?5is?5@
	*** 000057	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00005a	5b 			pop	bx
;|*** #else
;|*** 			Print ("If you are sure the password is correct, the key data may be damaged. Boot your\r\n"
;|*** 				   "GostCrypt Rescue Disk and select 'Repair Options' > 'Restore key data'.\r\n\r\n");
;|*** #endif
;|*** 		}
;|*** 	}
; Line 449
					$L1944:
	*** 00005b	6a 22 			push	34	;0022H
	*** 00005d	e8 00 00 		call	?AskPassword@@YAEAAUPassword@@@Z	; AskPassword
	*** 000060	5b 			pop	bx
	*** 000061	88 04 			mov	BYTE PTR [si],al
;|*** 		if (exitKey != GST_BIOS_KEY_ENTER)
; Line 428
	*** 000063	3c 1c 			cmp	al,28	;001cH
	*** 000065	74 b5 			je	SHORT $FC1569
;|*** 			return false;
; Line 429
	*** 000067	32 c0 			xor	al,al
	*** 000069	e9 17 01 		jmp	$EX1564
					$L1902:
;|*** 
;|*** 		if (OpenVolume (BootDrive, bootArguments->BootPassword, &BootCryptoInfo, &bootArguments->HeaderSaltCrc32, skipNormal, skipHidden))
;|*** 			break;
;|*** 
;|*** 		if (GetShiftFlags() & GST_BIOS_SHIFTMASK_CAPSLOCK)
;|*** 			Print ("Warning: Caps Lock is on.\r\n");
;|*** 
;|*** 		Print ("Incorrect password.\r\n\r\n");
;|*** 
;|*** 		if (++incorrectPasswordCount == 4)
;|*** 		{
;|*** #ifdef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 			Print ("If you are sure the password is correct, the key data may be damaged.\r\n"
;|*** 				   "If so, use 'Repair Options' > 'Restore key data'.\r\n\r\n");
;|*** #else
;|*** 			Print ("If you are sure the password is correct, the key data may be damaged. Boot your\r\n"
;|*** 				   "GostCrypt Rescue Disk and select 'Repair Options' > 'Restore key data'.\r\n\r\n");
;|*** #endif
;|*** 		}
;|*** 	}
;|*** 
;|*** 	// Setup boot arguments
;|*** 	bootArguments->BootLoaderVersion = VERSION_NUM;
; Line 452
	*** 00006c	c7 06 18 00 00 13 	mov	WORD PTR 24,4864	;1300H
;|*** 	bootArguments->CryptoInfoOffset = (uint16) BootCryptoInfo;
; Line 453
	*** 000072	a1 00 00 		mov	ax,WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 000075	89 06 1a 00 		mov	WORD PTR 26,ax
;|*** 	bootArguments->CryptoInfoLength = sizeof (*BootCryptoInfo);
; Line 454
	*** 000079	c7 06 1c 00 62 04 	mov	WORD PTR 28,1122	;0462H
;|*** 
;|*** 	if (BootCryptoInfo->hiddenVolume)
; Line 456
	*** 00007f	8b 1e 00 00 		mov	bx,WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 000083	80 bf 44 04 00 		cmp	BYTE PTR [bx+1092],0
	*** 000088	74 1c 			je	SHORT $I1579
;|*** 		bootArguments->HiddenSystemPartitionStart = PartitionFollowingActive.StartSector << GST_LB_SIZE_BIT_SHIFT_DIVISOR;
; Line 457
	*** 00008a	6a 09 			push	9
	*** 00008c	68 16 00 		push	OFFSET ?PartitionFollowingActive@@3UPartition@@A+22	;PartitionFollowingActive
	*** 00008f	8d 46 f6 		lea	ax,WORD PTR [bp-10]
	*** 000092	50 			push	ax
	*** 000093	e8 00 00 		call	??6@YA?ATUINT64_STRUCT@@ABT0@H@Z	; operator<<
	*** 000096	83 c4 06 		add	sp,6
	*** 000099	ba 6a 00 		mov	dx,106	;006aH
	*** 00009c	8b fa 			mov	di,dx
	*** 00009e	8b f0 			mov	si,ax
	*** 0000a0	1e 			push	ds
	*** 0000a1	07 			pop	es
	*** 0000a2	66 a5 			movsd
	*** 0000a4	66 a5 			movsd
;|*** 
;|*** 	if (ExtraBootPartitionPresent)
; Line 459
					$I1579:
	*** 0000a6	80 3e 00 00 00 		cmp	BYTE PTR ?ExtraBootPartitionPresent@@3DA,0	;ExtraBootPartitionPresent
	*** 0000ab	74 05 			je	SHORT $D1582
;|*** 		bootArguments->Flags |= GST_BOOT_ARGS_FLAG_EXTRA_BOOT_PARTITION;
; Line 460
	*** 0000ad	80 0e 7a 00 01 		or	BYTE PTR 122,1
;|*** 
;|*** 	GST_SET_BOOT_ARGUMENTS_SIGNATURE	(bootArguments->Signature);
; Line 462
					$D1582:
	*** 0000b2	c6 06 10 00 54 		mov	BYTE PTR 16,84	;0054H
	*** 0000b7	c6 06 11 00 52 		mov	BYTE PTR 17,82	;0052H
	*** 0000bc	c6 06 12 00 55 		mov	BYTE PTR 18,85	;0055H
	*** 0000c1	c6 06 13 00 45 		mov	BYTE PTR 19,69	;0045H
	*** 0000c6	c6 06 14 00 11 		mov	BYTE PTR 20,17	;0011H
	*** 0000cb	c6 06 15 00 23 		mov	BYTE PTR 21,35	;0023H
	*** 0000d0	c6 06 16 00 45 		mov	BYTE PTR 22,69	;0045H
	*** 0000d5	c6 06 17 00 66 		mov	BYTE PTR 23,102	;0066H
;|*** 
;|*** 	// Setup virtual encrypted partition
;|*** 	if (BootCryptoInfo->EncryptedAreaLength.HighPart != 0 || BootCryptoInfo->EncryptedAreaLength.LowPart != 0)
; Line 465
	*** 0000da	8b 1e 00 00 		mov	bx,WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 0000de	66 83 bf 5a 04 00 	cmp	DWORD PTR [bx+1114],0
	*** 0000e4	75 12 			jne	SHORT $I1586
	*** 0000e6	8b 87 58 04 		mov	ax,WORD PTR [bx+1112]
	*** 0000ea	0b 87 56 04 		or	ax,WORD PTR [bx+1110]
	*** 0000ee	75 08 			jne	SHORT $I1586
;|*** 	{
;|*** 		EncryptedVirtualPartition.Drive = BootDrive;
;|*** 
;|*** 		EncryptedVirtualPartition.StartSector = BootCryptoInfo->EncryptedAreaStart >> GST_LB_SIZE_BIT_SHIFT_DIVISOR;
;|*** 		
;|*** 		HiddenVolumeStartUnitNo = EncryptedVirtualPartition.StartSector;
;|*** 		HiddenVolumeStartSector = PartitionFollowingActive.StartSector;
;|*** 		HiddenVolumeStartSector += EncryptedVirtualPartition.StartSector;
;|*** 
;|*** 		EncryptedVirtualPartition.SectorCount = BootCryptoInfo->EncryptedAreaLength >> GST_LB_SIZE_BIT_SHIFT_DIVISOR;
;|*** 
;|*** 		EncryptedVirtualPartition.EndSector = EncryptedVirtualPartition.SectorCount - 1;
;|*** 		EncryptedVirtualPartition.EndSector += EncryptedVirtualPartition.StartSector;
;|*** 	}
;|*** 	else
;|*** 	{
;|*** 		// Drive not encrypted
;|*** 		EncryptedVirtualPartition.Drive = GST_INVALID_BIOS_DRIVE;
; Line 483
	*** 0000f0	c6 06 01 00 7f 		mov	BYTE PTR ?EncryptedVirtualPartition@@3UPartition@@A+1,127	;007fH	;EncryptedVirtualPartition
	*** 0000f5	e9 89 00 		jmp	$I1590
;|*** 	if (BootCryptoInfo->EncryptedAreaLength.HighPart != 0 || BootCryptoInfo->EncryptedAreaLength.LowPart != 0)
; Line 465
					$I1586:
;|*** 	{
;|*** 		EncryptedVirtualPartition.Drive = BootDrive;
; Line 467
	*** 0000f8	a0 00 00 		mov	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 0000fb	a2 01 00 		mov	BYTE PTR ?EncryptedVirtualPartition@@3UPartition@@A+1,al	;EncryptedVirtualPartition
;|*** 
;|*** 		EncryptedVirtualPartition.StartSector = BootCryptoInfo->EncryptedAreaStart >> GST_LB_SIZE_BIT_SHIFT_DIVISOR;
; Line 469
	*** 0000fe	6a 09 			push	9
	*** 000100	8d 87 4e 04 		lea	ax,WORD PTR [bx+1102]
	*** 000104	50 			push	ax
	*** 000105	8d 46 f6 		lea	ax,WORD PTR [bp-10]
	*** 000108	50 			push	ax
	*** 000109	e8 00 00 		call	??5@YA?ATUINT64_STRUCT@@ABT0@H@Z	; operator>>
	*** 00010c	83 c4 06 		add	sp,6
	*** 00010f	ba 16 00 		mov	dx,OFFSET ?EncryptedVirtualPartition@@3UPartition@@A+22	;EncryptedVirtualPartition
	*** 000112	8b fa 			mov	di,dx
	*** 000114	8b f0 			mov	si,ax
	*** 000116	1e 			push	ds
	*** 000117	07 			pop	es
	*** 000118	66 a5 			movsd
	*** 00011a	66 a5 			movsd
;|*** 		
;|*** 		HiddenVolumeStartUnitNo = EncryptedVirtualPartition.StartSector;
; Line 471
	*** 00011c	b8 00 00 		mov	ax,OFFSET ?HiddenVolumeStartUnitNo@@3TUINT64_STRUCT@@A	;HiddenVolumeStartUnitNo
	*** 00011f	8b f8 			mov	di,ax
	*** 000121	8b f2 			mov	si,dx
	*** 000123	66 a5 			movsd
	*** 000125	66 a5 			movsd
;|*** 		HiddenVolumeStartSector = PartitionFollowingActive.StartSector;
; Line 472
	*** 000127	b8 00 00 		mov	ax,OFFSET ?HiddenVolumeStartSector@@3TUINT64_STRUCT@@A	;HiddenVolumeStartSector
	*** 00012a	8b f8 			mov	di,ax
	*** 00012c	be 16 00 		mov	si,OFFSET ?PartitionFollowingActive@@3UPartition@@A+22	;PartitionFollowingActive
	*** 00012f	66 a5 			movsd
	*** 000131	66 a5 			movsd
;|*** 		HiddenVolumeStartSector += EncryptedVirtualPartition.StartSector;
; Line 473
	*** 000133	52 			push	dx
	*** 000134	50 			push	ax
	*** 000135	e8 00 00 		call	??Y@YAAATUINT64_STRUCT@@AAT0@ABT0@@Z	; operator+=
	*** 000138	83 c4 04 		add	sp,4
;|*** 
;|*** 		EncryptedVirtualPartition.SectorCount = BootCryptoInfo->EncryptedAreaLength >> GST_LB_SIZE_BIT_SHIFT_DIVISOR;
; Line 475
	*** 00013b	6a 09 			push	9
	*** 00013d	a1 00 00 		mov	ax,WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 000140	05 56 04 		add	ax,1110	;0456H
	*** 000143	50 			push	ax
	*** 000144	8d 46 f6 		lea	ax,WORD PTR [bp-10]
	*** 000147	50 			push	ax
	*** 000148	e8 00 00 		call	??5@YA?ATUINT64_STRUCT@@ABT0@H@Z	; operator>>
	*** 00014b	83 c4 06 		add	sp,6
	*** 00014e	ba 0e 00 		mov	dx,OFFSET ?EncryptedVirtualPartition@@3UPartition@@A+14	;EncryptedVirtualPartition
	*** 000151	8b fa 			mov	di,dx
	*** 000153	8b f0 			mov	si,ax
	*** 000155	1e 			push	ds
	*** 000156	07 			pop	es
	*** 000157	66 a5 			movsd
	*** 000159	66 a5 			movsd
;|*** 
;|*** 		EncryptedVirtualPartition.EndSector = EncryptedVirtualPartition.SectorCount - 1;
; Line 477
	*** 00015b	6a 00 			push	0
	*** 00015d	6a 01 			push	1
	*** 00015f	52 			push	dx
	*** 000160	8d 46 f6 		lea	ax,WORD PTR [bp-10]
	*** 000163	50 			push	ax
	*** 000164	e8 00 00 		call	??G@YA?ATUINT64_STRUCT@@ABT0@K@Z	; operator-
	*** 000167	83 c4 08 		add	sp,8
	*** 00016a	ba 04 00 		mov	dx,OFFSET ?EncryptedVirtualPartition@@3UPartition@@A+4	;EncryptedVirtualPartition
	*** 00016d	8b fa 			mov	di,dx
	*** 00016f	8b f0 			mov	si,ax
	*** 000171	1e 			push	ds
	*** 000172	07 			pop	es
	*** 000173	66 a5 			movsd
	*** 000175	66 a5 			movsd
;|*** 		EncryptedVirtualPartition.EndSector += EncryptedVirtualPartition.StartSector;
; Line 478
	*** 000177	68 16 00 		push	OFFSET ?EncryptedVirtualPartition@@3UPartition@@A+22	;EncryptedVirtualPartition
	*** 00017a	52 			push	dx
	*** 00017b	e8 00 00 		call	??Y@YAAATUINT64_STRUCT@@AAT0@ABT0@@Z	; operator+=
	*** 00017e	83 c4 04 		add	sp,4
;|*** 	}
;|*** 	else
;|*** 	{
;|*** 		// Drive not encrypted
;|*** 		EncryptedVirtualPartition.Drive = GST_INVALID_BIOS_DRIVE;
;|*** 	}
; Line 484
					$I1590:
;|*** 
;|*** 	return true;
; Line 486
	*** 000181	b0 01 			mov	al,1
;|*** }
; Line 487
					$EX1564:
	*** 000183	5e 			pop	si
	*** 000184	5f 			pop	di
	*** 000185	c9 			leave	
	*** 000186	c3 			ret	

?MountVolume@@YADEAAEDD@Z	ENDP

?GetSystemPartitions@@YADE@Z	PROC NEAR	; GetSystemPartitions COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static bool GetSystemPartitions (byte drive)
;|***  *	\brief Get drive partition (system partitions)
;|***  *	\param[in] byte drive
;|***  *	\return static bool false if !GetActivePartition (drive)
;|***  *			true else
;|***  *
;|***  */
;|*** static bool GetSystemPartitions (byte drive)
;|*** {
; Line 500
	*** 000000	c8 02 00 00 		enter	2,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	drive = 4
;	partCount = -2
;|*** 	size_t partCount;
;|*** 
;|*** 	if (!GetActivePartition (drive))
; Line 503
	*** 000006	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000009	50 			push	ax
	*** 00000a	e8 00 00 		call	?GetActivePartition@@YADE@Z	; GetActivePartition
	*** 00000d	5b 			pop	bx
	*** 00000e	0a c0 			or	al,al
	*** 000010	74 63 			je	SHORT $EX1593
;|*** 		return false;
;|*** 
;|*** 	// Find partition following the active one
;|*** 	GetDrivePartitions (drive, &PartitionFollowingActive, 1, partCount, false, &ActivePartition);
; Line 507
	*** 000012	6a 00 			push	0
	*** 000014	68 00 00 		push	OFFSET ?ActivePartition@@3UPartition@@A	;ActivePartition
	*** 000017	6a 00 			push	0
	*** 000019	8d 46 fe 		lea	ax,WORD PTR [bp-2]	;partCount
	*** 00001c	50 			push	ax
	*** 00001d	6a 01 			push	1
	*** 00001f	68 00 00 		push	OFFSET ?PartitionFollowingActive@@3UPartition@@A	;PartitionFollowingActive
	*** 000022	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000025	50 			push	ax
	*** 000026	e8 00 00 		call	?GetDrivePartitions@@YAEEPAUPartition@@IAAID0D@Z	; GetDrivePartitions
	*** 000029	83 c4 0e 		add	sp,14	;000eH
;|*** 
;|*** 	// If there is an extra boot partition, use the partitions following it.
;|*** 	// The real boot partition is determined in BootEncryptedDrive().
;|*** 	if (ActivePartition.SectorCount.HighPart == 0 && ActivePartition.SectorCount.LowPart <= GST_MAX_EXTRA_BOOT_PARTITION_SIZE / GST_LB_SIZE
;|*** 		&& PartitionFollowingActive.Drive != GST_INVALID_BIOS_DRIVE)
; Line 512
	*** 00002c	a1 14 00 		mov	ax,WORD PTR ?ActivePartition@@3UPartition@@A+20	;ActivePartition
	*** 00002f	0b 06 12 00 		or	ax,WORD PTR ?ActivePartition@@3UPartition@@A+18	;ActivePartition
	*** 000033	75 3e 			jne	SHORT $I1596
	*** 000035	66 81 3e 0e 00 00 00 10 00 cmp	DWORD PTR ?ActivePartition@@3UPartition@@A+14,1048576	;00100000H	;ActivePartition
	*** 00003e	77 33 			ja	SHORT $I1596
					$L1903:
	*** 000040	80 3e 01 00 7f 		cmp	BYTE PTR ?PartitionFollowingActive@@3UPartition@@A+1,127	;007fH	;PartitionFollowingActive
	*** 000045	74 2c 			je	SHORT $I1596
;|*** 	{
;|*** 		ExtraBootPartitionPresent = true;
; Line 514
	*** 000047	c6 06 00 00 01 		mov	BYTE PTR ?ExtraBootPartitionPresent@@3DA,1	;ExtraBootPartitionPresent
;|*** 
;|*** 		ActivePartition = PartitionFollowingActive;
; Line 516
	*** 00004c	b8 00 00 		mov	ax,OFFSET ?ActivePartition@@3UPartition@@A	;ActivePartition
	*** 00004f	8b f8 			mov	di,ax
	*** 000051	be 00 00 		mov	si,OFFSET ?PartitionFollowingActive@@3UPartition@@A	;PartitionFollowingActive
	*** 000054	1e 			push	ds
	*** 000055	07 			pop	es
	*** 000056	b9 10 00 		mov	cx,16	;0010H
	*** 000059	f3 			rep
	*** 00005a	a5 			movsw
;|*** 		GetDrivePartitions (drive, &PartitionFollowingActive, 1, partCount, false, &ActivePartition);
; Line 517
	*** 00005b	6a 00 			push	0
	*** 00005d	50 			push	ax
	*** 00005e	6a 00 			push	0
	*** 000060	8d 46 fe 		lea	ax,WORD PTR [bp-2]	;partCount
	*** 000063	50 			push	ax
	*** 000064	6a 01 			push	1
	*** 000066	68 00 00 		push	OFFSET ?PartitionFollowingActive@@3UPartition@@A	;PartitionFollowingActive
	*** 000069	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 00006c	50 			push	ax
	*** 00006d	e8 00 00 		call	?GetDrivePartitions@@YAEEPAUPartition@@IAAID0D@Z	; GetDrivePartitions
	*** 000070	83 c4 0e 		add	sp,14	;000eH
;|*** 	}
;|*** 
;|*** 	return true;
; Line 520
					$I1596:
	*** 000073	b0 01 			mov	al,1
;|*** }
; Line 521
					$EX1593:
	*** 000075	5e 			pop	si
	*** 000076	5f 			pop	di
	*** 000077	c9 			leave	
	*** 000078	c3 			ret	

?GetSystemPartitions@@YADE@Z	ENDP

?BootEncryptedDrive@@YAEXZ	PROC NEAR	; BootEncryptedDrive COMDAT
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static byte BootEncryptedDrive ()
;|***  *	\brief Execute boot sector of the active partition if no errors
;|***  *	\return static byte, exitKey if !MountVolume (BootDrive, exitKey, PreventNormalSystemBoot, false)
;|***  *			scanCode else
;|***  *
;|***  */
;|*** static byte BootEncryptedDrive ()
;|*** {
; Line 532
	*** 000000	c8 0c 00 00 		enter	12,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	exitKey = -1
;	scanCode = -2
;	bootArguments = -4
;|*** 	BootArguments *bootArguments = (BootArguments *) GST_BOOT_LOADER_ARGS_OFFSET;
; Line 533
	*** 000006	c7 46 fc 10 00 		mov	WORD PTR [bp-4],16	;0010H	;bootArguments
;|*** 	byte exitKey;
;|*** 	BootCryptoInfo = NULL;
; Line 535
	*** 00000b	c7 06 00 00 00 00 	mov	WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A,0	;BootCryptoInfo
;|*** 
;|*** 	if (!GetSystemPartitions (BootDrive))
; Line 537
	*** 000011	a0 00 00 		mov	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 000014	50 			push	ax
	*** 000015	e8 00 00 		call	?GetSystemPartitions@@YADE@Z	; GetSystemPartitions
	*** 000018	5b 			pop	bx
	*** 000019	0a c0 			or	al,al
	*** 00001b	0f 84 90 00 		je	$err1603
;|*** 		goto err;
;|*** 
;|*** 	if (!MountVolume (BootDrive, exitKey, PreventNormalSystemBoot, false))
; Line 540
	*** 00001f	6a 00 			push	0
	*** 000021	a0 00 00 		mov	al,BYTE PTR ?PreventNormalSystemBoot@@3DA	;PreventNormalSystemBoot
	*** 000024	50 			push	ax
	*** 000025	8d 46 ff 		lea	ax,WORD PTR [bp-1]	;exitKey
	*** 000028	50 			push	ax
	*** 000029	a0 00 00 		mov	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 00002c	50 			push	ax
	*** 00002d	e8 00 00 		call	?MountVolume@@YADEAAEDD@Z	; MountVolume
	*** 000030	83 c4 08 		add	sp,8
	*** 000033	0a c0 			or	al,al
	*** 000035	75 06 			jne	SHORT $I1605
;|*** 		return exitKey;
; Line 541
	*** 000037	8a 46 ff 		mov	al,BYTE PTR [bp-1]	;exitKey
	*** 00003a	e9 f1 00 		jmp	$EX1598
;|*** 	
;|*** 	if (!CheckMemoryRequirements ())
; Line 543
					$I1605:
	*** 00003d	e8 00 00 		call	?CheckMemoryRequirements@@YADXZ	; CheckMemoryRequirements
	*** 000040	0a c0 			or	al,al
	*** 000042	74 6b 			je	SHORT $err1603
;|*** 		goto err;
;|*** 
;|*** 	if (BootCryptoInfo->hiddenVolume)
; Line 546
	*** 000044	8b 1e 00 00 		mov	bx,WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 000048	80 bf 44 04 00 		cmp	BYTE PTR [bx+1092],0
	*** 00004d	74 2b 			je	SHORT $I1608
;|*** 	{
;|*** 		EncryptedVirtualPartition = ActivePartition;
; Line 548
	*** 00004f	b8 00 00 		mov	ax,OFFSET ?EncryptedVirtualPartition@@3UPartition@@A	;EncryptedVirtualPartition
	*** 000052	8b f8 			mov	di,ax
	*** 000054	be 00 00 		mov	si,OFFSET ?ActivePartition@@3UPartition@@A	;ActivePartition
	*** 000057	1e 			push	ds
	*** 000058	07 			pop	es
	*** 000059	b9 10 00 		mov	cx,16	;0010H
	*** 00005c	f3 			rep
	*** 00005d	a5 			movsw
;|*** 		bootArguments->DecoySystemPartitionStart = ActivePartition.StartSector << GST_LB_SIZE_BIT_SHIFT_DIVISOR;
; Line 549
	*** 00005e	6a 09 			push	9
	*** 000060	68 16 00 		push	OFFSET ?ActivePartition@@3UPartition@@A+22	;ActivePartition
	*** 000063	8d 46 f4 		lea	ax,WORD PTR [bp-12]
	*** 000066	50 			push	ax
	*** 000067	e8 00 00 		call	??6@YA?ATUINT64_STRUCT@@ABT0@H@Z	; operator<<
	*** 00006a	83 c4 06 		add	sp,6
	*** 00006d	ba 72 00 		mov	dx,114	;0072H
	*** 000070	8b fa 			mov	di,dx
	*** 000072	8b f0 			mov	si,ax
	*** 000074	1e 			push	ds
	*** 000075	07 			pop	es
	*** 000076	66 a5 			movsd
	*** 000078	66 a5 			movsd
;|*** 	}
;|*** 
;|*** 	if (ExtraBootPartitionPresent && !GetActivePartition (BootDrive))
; Line 552
					$I1608:
	*** 00007a	80 3e 00 00 00 		cmp	BYTE PTR ?ExtraBootPartitionPresent@@3DA,0	;ExtraBootPartitionPresent
	*** 00007f	74 0c 			je	SHORT $I1610
	*** 000081	a0 00 00 		mov	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 000084	50 			push	ax
	*** 000085	e8 00 00 		call	?GetActivePartition@@YADE@Z	; GetActivePartition
	*** 000088	5b 			pop	bx
	*** 000089	0a c0 			or	al,al
	*** 00008b	74 22 			je	SHORT $err1603
;|*** 		goto err;
;|*** 
;|*** 	if (ReadWriteMBR (false, ActivePartition.Drive) != BiosResultSuccess)
; Line 555
					$I1610:
	*** 00008d	6a 00 			push	0
	*** 00008f	a0 01 00 		mov	al,BYTE PTR ?ActivePartition@@3UPartition@@A+1	;ActivePartition
	*** 000092	50 			push	ax
	*** 000093	6a 00 			push	0
	*** 000095	e8 00 00 		call	?ReadWriteMBR@@YAEDED@Z	; ReadWriteMBR
	*** 000098	83 c4 06 		add	sp,6
	*** 00009b	0a c0 			or	al,al
	*** 00009d	75 10 			jne	SHORT $err1603
;|*** 		goto err;
;|*** 
;|*** 	bootArguments->BootDriveSignature = *(uint32 *) (SectorBuffer + 0x1b8);
; Line 558
	*** 00009f	66 a1 b8 01 		mov	eax,DWORD PTR ?SectorBuffer@@3QAEA+440	;SectorBuffer
	*** 0000a3	66 89 06 7e 00 		mov	DWORD PTR 126,eax
;|*** 
;|*** 	if (!InstallInterruptFilters())
; Line 560
	*** 0000a8	e8 00 00 		call	?InstallInterruptFilters@@YADXZ	; InstallInterruptFilters
	*** 0000ab	0a c0 			or	al,al
	*** 0000ad	75 31 			jne	SHORT $I1615
;|*** 		goto err;
;|*** 
;|*** 	bootArguments->BootArgumentsCrc32 = GetCrc32 ((byte *) bootArguments, (byte *) &bootArguments->BootArgumentsCrc32 - (byte *) bootArguments);
;|*** 
;|*** 	while (true)
;|*** 	{
;|*** 		// Execute boot sector of the active partition
;|*** 		if (ReadSectors (SectorBuffer, ActivePartition.Drive, ActivePartition.StartSector, 1) == BiosResultSuccess)
;|*** 		{
;|*** 			if (*(uint16 *) (SectorBuffer + 510) != 0xaa55)
;|*** 			{
;|*** 				PrintError (GST_BOOT_STR_NO_BOOT_PARTITION);
;|*** 				GetKeyboardChar();
;|*** 			}
;|*** 
;|*** 			ExecuteBootSector (ActivePartition.Drive, SectorBuffer);
;|*** 		}
;|*** 
;|*** 		GetKeyboardChar();
;|*** 	}
;|*** 
;|*** err:
; Line 582
					$err1603:
;|*** 	if (BootCryptoInfo)
; Line 583
	*** 0000af	83 3e 00 00 00 		cmp	WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A,0	;BootCryptoInfo
	*** 0000b4	74 0e 			je	SHORT $I1627
;|*** 	{
;|*** 		crypto_close (BootCryptoInfo);
; Line 585
	*** 0000b6	ff 36 00 00 		push	WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 0000ba	e8 00 00 		call	_crypto_close
	*** 0000bd	5b 			pop	bx
;|*** 		BootCryptoInfo = NULL;
; Line 586
	*** 0000be	c7 06 00 00 00 00 	mov	WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A,0	;BootCryptoInfo
;|*** 	}
;|*** 
;|*** 	EncryptedVirtualPartition.Drive = GST_INVALID_BIOS_DRIVE;
; Line 589
					$I1627:
	*** 0000c4	c6 06 01 00 7f 		mov	BYTE PTR ?EncryptedVirtualPartition@@3UPartition@@A+1,127	;007fH	;EncryptedVirtualPartition
;|*** 	EraseMemory ((void *) GST_BOOT_LOADER_ARGS_OFFSET, sizeof (BootArguments));
; Line 590
	*** 0000c9	6a 76 			push	118	;0076H
	*** 0000cb	6a 10 			push	16	;0010H
	*** 0000cd	e8 00 00 		call	_EraseMemory
	*** 0000d0	83 c4 04 		add	sp,4
;|*** 
;|*** 	byte scanCode;
;|*** 	GetKeyboardChar (&scanCode);
; Line 593
	*** 0000d3	8d 46 fe 		lea	ax,WORD PTR [bp-2]	;scanCode
	*** 0000d6	50 			push	ax
	*** 0000d7	e8 00 00 		call	?GetKeyboardChar@@YAEPAE@Z	; GetKeyboardChar
	*** 0000da	5b 			pop	bx
;|*** 	return scanCode;
; Line 594
	*** 0000db	8a 46 fe 		mov	al,BYTE PTR [bp-2]	;scanCode
	*** 0000de	eb 4e 			jmp	SHORT $EX1598
;|*** 	bootArguments->BootArgumentsCrc32 = GetCrc32 ((byte *) bootArguments, (byte *) &bootArguments->BootArgumentsCrc32 - (byte *) bootArguments);
; Line 563
					$I1615:
	*** 0000e0	6a 72 			push	114	;0072H
	*** 0000e2	6a 10 			push	16	;0010H
	*** 0000e4	e8 00 00 		call	_GetCrc32
	*** 0000e7	83 c4 04 		add	sp,4
	*** 0000ea	89 06 82 00 		mov	WORD PTR 130,ax
	*** 0000ee	89 16 84 00 		mov	WORD PTR 132,dx
;|*** 
;|*** 	while (true)
; Line 565
					$FC1621:
;|*** 	{
;|*** 		// Execute boot sector of the active partition
;|*** 		if (ReadSectors (SectorBuffer, ActivePartition.Drive, ActivePartition.StartSector, 1) == BiosResultSuccess)
; Line 568
	*** 0000f2	6a 00 			push	0
	*** 0000f4	6a 01 			push	1
	*** 0000f6	68 16 00 		push	OFFSET ?ActivePartition@@3UPartition@@A+22	;ActivePartition
	*** 0000f9	a0 01 00 		mov	al,BYTE PTR ?ActivePartition@@3UPartition@@A+1	;ActivePartition
	*** 0000fc	50 			push	ax
	*** 0000fd	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000100	e8 00 00 		call	?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; ReadSectors
	*** 000103	83 c4 0a 		add	sp,10	;000aH
	*** 000106	0a c0 			or	al,al
	*** 000108	75 1f 			jne	SHORT $I1623
;|*** 		{
;|*** 			if (*(uint16 *) (SectorBuffer + 510) != 0xaa55)
; Line 570
	*** 00010a	81 3e fe 01 55 aa 	cmp	WORD PTR ?SectorBuffer@@3QAEA+510,-21931	;aa55H	;SectorBuffer
	*** 000110	74 0a 			je	SHORT $I1625
;|*** 			{
;|*** 				PrintError (GST_BOOT_STR_NO_BOOT_PARTITION);
; Line 572
	*** 000112	68 00 00 		push	OFFSET DGROUP:??_C@_0BM@IDKA@No?5bootable?5partition?5found?$AA@
	*** 000115	e8 00 00 		call	?PrintError@@YAXPBD@Z	; PrintError
	*** 000118	5b 			pop	bx
;|*** 				GetKeyboardChar();
; Line 573
	*** 000119	e8 00 00 		call	?GetKeyboardChar@@YAEXZ	; GetKeyboardChar
;|*** 			}
;|*** 
;|*** 			ExecuteBootSector (ActivePartition.Drive, SectorBuffer);
; Line 576
					$I1625:
	*** 00011c	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 00011f	a0 01 00 		mov	al,BYTE PTR ?ActivePartition@@3UPartition@@A+1	;ActivePartition
	*** 000122	50 			push	ax
	*** 000123	e8 00 00 		call	?ExecuteBootSector@@YAXEPAE@Z	; ExecuteBootSector
	*** 000126	83 c4 04 		add	sp,4
;|*** 		}
;|*** 
;|*** 		GetKeyboardChar();
; Line 579
					$I1623:
	*** 000129	e8 00 00 		call	?GetKeyboardChar@@YAEXZ	; GetKeyboardChar
;|*** 	}
; Line 580
	*** 00012c	eb c4 			jmp	SHORT $FC1621
;|*** 
;|*** err:
;|*** 	if (BootCryptoInfo)
;|*** 	{
;|*** 		crypto_close (BootCryptoInfo);
;|*** 		BootCryptoInfo = NULL;
;|*** 	}
;|*** 
;|*** 	EncryptedVirtualPartition.Drive = GST_INVALID_BIOS_DRIVE;
;|*** 	EraseMemory ((void *) GST_BOOT_LOADER_ARGS_OFFSET, sizeof (BootArguments));
;|*** 
;|*** 	byte scanCode;
;|*** 	GetKeyboardChar (&scanCode);
;|*** 	return scanCode;
;|*** }
; Line 595
					$EX1598:
	*** 00012e	5e 			pop	si
	*** 00012f	5f 			pop	di
	*** 000130	c9 			leave	
	*** 000131	c3 			ret	

?BootEncryptedDrive@@YAEXZ	ENDP

?BootMenu@@YAXXZ	PROC NEAR	; BootMenu COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void BootMenu ()
;|***  *	\brief Find partition, print them, ask user and execute boot sector
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void BootMenu ()
;|*** {
; Line 606
	*** 000000	c8 2e 03 00 		enter	814,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	register si = i
;	partition = -2
;	register si = partition
;	result = -2
;	partitions = -812
;	bootablePartitions = -300
;	partitionCount = -12
;	bootablePartitionCount = -10
;	drive = -7
;	i = -6
;	partition = -2
;	partChar = -8
;|*** 	BiosResult result;
;|*** 	Partition partitions[16];
;|*** 	Partition bootablePartitions[9];
;|*** 	size_t partitionCount;
;|*** 	size_t bootablePartitionCount = 0;
; Line 611
	*** 000006	33 ff 			xor	di,di
;|*** 
;|*** 	for (byte drive = GST_FIRST_BIOS_DRIVE; drive <= GST_LAST_BIOS_DRIVE; ++drive)
; Line 613
	*** 000008	c6 46 f9 80 		mov	BYTE PTR [bp-7],128	;0080H	;drive
					$F1639:
;|*** 	{
;|*** 		if (GetDrivePartitions (drive, partitions, array_capacity (partitions), partitionCount, false, nullptr, true) == BiosResultSuccess)
; Line 615
	*** 00000c	6a 01 			push	1
	*** 00000e	6a 00 			push	0
	*** 000010	6a 00 			push	0
	*** 000012	8d 46 f4 		lea	ax,WORD PTR [bp-12]	;partitionCount
	*** 000015	50 			push	ax
	*** 000016	6a 10 			push	16	;0010H
	*** 000018	8d 86 d4 fc 		lea	ax,WORD PTR [bp-812]	;partitions
	*** 00001c	50 			push	ax
	*** 00001d	8a 46 f9 		mov	al,BYTE PTR [bp-7]	;drive
	*** 000020	50 			push	ax
	*** 000021	e8 00 00 		call	?GetDrivePartitions@@YAEEPAUPartition@@IAAID0D@Z	; GetDrivePartitions
	*** 000024	83 c4 0e 		add	sp,14	;000eH
	*** 000027	0a c0 			or	al,al
	*** 000029	0f 85 b1 00 		jne	$FC1640
	*** 00002d	89 7e f6 		mov	WORD PTR [bp-10],di	;bootablePartitionCount
;|*** 		{
;|*** 			for (size_t i = 0; i < partitionCount; ++i)
; Line 617
	*** 000030	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;i
	*** 000035	e9 99 00 		jmp	$L1947
					$F1644:
;|*** 			{
;|*** 				const Partition &partition = partitions[i];
;|*** 				result = ReadSectors (SectorBuffer, drive, partition.StartSector, 1);
;|*** 
;|*** 				if (result == BiosResultSuccess && *(uint16 *) (SectorBuffer + GST_LB_SIZE - 2) == 0xaa55)
; Line 622
	*** 000038	6a 00 			push	0
	*** 00003a	6a 01 			push	1
	*** 00003c	8b 76 fa 		mov	si,WORD PTR [bp-6]	;i
	*** 00003f	c1 e6 05 		shl	si,5
	*** 000042	8d 82 d4 fc 		lea	ax,WORD PTR [bp-812][si]
	*** 000046	89 46 fe 		mov	WORD PTR [bp-2],ax	;partition
	*** 000049	05 16 00 		add	ax,22	;0016H
	*** 00004c	50 			push	ax
	*** 00004d	8a 46 f9 		mov	al,BYTE PTR [bp-7]	;drive
	*** 000050	50 			push	ax
	*** 000051	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000054	e8 00 00 		call	?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; ReadSectors
	*** 000057	83 c4 0a 		add	sp,10	;000aH
	*** 00005a	0a c0 			or	al,al
	*** 00005c	75 70 			jne	SHORT $FC1645
	*** 00005e	81 3e fe 01 55 aa 	cmp	WORD PTR ?SectorBuffer@@3QAEA+510,-21931	;aa55H	;SectorBuffer
	*** 000064	75 68 			jne	SHORT $FC1645
;|*** 				{
;|*** 					// Windows writes boot loader on all NTFS/FAT filesytems it creates and, therefore,
;|*** 					// NTFS/FAT partitions must have the boot indicator set to be considered bootable.
;|*** 					if (!partition.Active
;|*** 						&& (*(uint32 *) (SectorBuffer + 3) == 0x5346544e  // 'NTFS'
;|*** 							|| *(uint32 *) (SectorBuffer + 3) == 0x41465845	&& SectorBuffer[7] == 'T' // 'exFAT'
;|*** 							|| *(uint16 *) (SectorBuffer + 54) == 0x4146 && SectorBuffer[56] == 'T' // 'FAT'
;|*** 							|| *(uint16 *) (SectorBuffer + 82) == 0x4146 && SectorBuffer[84] == 'T'))
; Line 630
	*** 000066	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;partition
	*** 000069	38 47 02 		cmp	BYTE PTR [bx+2],al
	*** 00006c	75 3b 			jne	SHORT $I1654
	*** 00006e	66 81 3e 03 00 4e 54 46 53 cmp	DWORD PTR ?SectorBuffer@@3QAEA+3,1397118030	;5346544eH	;SectorBuffer
	*** 000077	74 55 			je	SHORT $FC1645
					$L1915:
	*** 000079	66 81 3e 03 00 45 58 46 41 cmp	DWORD PTR ?SectorBuffer@@3QAEA+3,1095129157	;41465845H	;SectorBuffer
	*** 000082	75 07 			jne	SHORT $I1656
	*** 000084	80 3e 07 00 54 		cmp	BYTE PTR ?SectorBuffer@@3QAEA+7,84	;0054H	;SectorBuffer
	*** 000089	74 43 			je	SHORT $FC1645
					$I1656:
	*** 00008b	81 3e 36 00 46 41 	cmp	WORD PTR ?SectorBuffer@@3QAEA+54,16710	;4146H	;SectorBuffer
	*** 000091	75 07 			jne	SHORT $I1657
	*** 000093	80 3e 38 00 54 		cmp	BYTE PTR ?SectorBuffer@@3QAEA+56,84	;0054H	;SectorBuffer
	*** 000098	74 34 			je	SHORT $FC1645
					$I1657:
	*** 00009a	81 3e 52 00 46 41 	cmp	WORD PTR ?SectorBuffer@@3QAEA+82,16710	;4146H	;SectorBuffer
	*** 0000a0	75 07 			jne	SHORT $I1654
	*** 0000a2	80 3e 54 00 54 		cmp	BYTE PTR ?SectorBuffer@@3QAEA+84,84	;0054H	;SectorBuffer
	*** 0000a7	74 25 			je	SHORT $FC1645
;|*** 					{
;|*** 						continue;
;|*** 					}
;|*** 
;|*** 					// Bootable sector found
;|*** 					if (bootablePartitionCount < array_capacity (bootablePartitions))
; Line 636
					$I1654:
	*** 0000a9	83 7e f6 09 		cmp	WORD PTR [bp-10],9	;bootablePartitionCount
	*** 0000ad	73 1f 			jae	SHORT $FC1645
;|*** 						bootablePartitions[bootablePartitionCount++] = partition;
; Line 637
	*** 0000af	8b 76 f6 		mov	si,WORD PTR [bp-10]	;bootablePartitionCount
	*** 0000b2	c1 e6 05 		shl	si,5
	*** 0000b5	8d 82 d4 fe 		lea	ax,WORD PTR [bp-300][si]
	*** 0000b9	89 46 fc 		mov	WORD PTR [bp-4],ax
	*** 0000bc	ff 46 f6 		inc	WORD PTR [bp-10]	;bootablePartitionCount
	*** 0000bf	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;partition
	*** 0000c2	8b f0 			mov	si,ax
	*** 0000c4	1e 			push	ds
	*** 0000c5	07 			pop	es
	*** 0000c6	8b 7e fc 		mov	di,WORD PTR [bp-4]
	*** 0000c9	b9 10 00 		mov	cx,16	;0010H
	*** 0000cc	f3 			rep
	*** 0000cd	a5 			movsw
;|*** 			for (size_t i = 0; i < partitionCount; ++i)
; Line 617
					$FC1645:
	*** 0000ce	ff 46 fa 		inc	WORD PTR [bp-6]	;i
					$L1947:
	*** 0000d1	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;partitionCount
	*** 0000d4	39 46 fa 		cmp	WORD PTR [bp-6],ax	;i
	*** 0000d7	0f 82 5d ff 		jb	$F1644
	*** 0000db	8b 7e f6 		mov	di,WORD PTR [bp-10]	;bootablePartitionCount
;|*** 	for (byte drive = GST_FIRST_BIOS_DRIVE; drive <= GST_LAST_BIOS_DRIVE; ++drive)
; Line 613
					$FC1640:
	*** 0000de	fe 46 f9 		inc	BYTE PTR [bp-7]	;drive
	*** 0000e1	80 7e f9 8f 		cmp	BYTE PTR [bp-7],143	;008fH	;drive
	*** 0000e5	0f 86 23 ff 		jbe	$F1639
;|*** 	{
;|*** 		if (GetDrivePartitions (drive, partitions, array_capacity (partitions), partitionCount, false, nullptr, true) == BiosResultSuccess)
;|*** 		{
;|*** 			for (size_t i = 0; i < partitionCount; ++i)
;|*** 			{
;|*** 				const Partition &partition = partitions[i];
;|*** 				result = ReadSectors (SectorBuffer, drive, partition.StartSector, 1);
;|*** 
;|*** 				if (result == BiosResultSuccess && *(uint16 *) (SectorBuffer + GST_LB_SIZE - 2) == 0xaa55)
;|*** 				{
;|*** 					// Windows writes boot loader on all NTFS/FAT filesytems it creates and, therefore,
;|*** 					// NTFS/FAT partitions must have the boot indicator set to be considered bootable.
;|*** 					if (!partition.Active
;|*** 						&& (*(uint32 *) (SectorBuffer + 3) == 0x5346544e  // 'NTFS'
;|*** 							|| *(uint32 *) (SectorBuffer + 3) == 0x41465845	&& SectorBuffer[7] == 'T' // 'exFAT'
;|*** 							|| *(uint16 *) (SectorBuffer + 54) == 0x4146 && SectorBuffer[56] == 'T' // 'FAT'
;|*** 							|| *(uint16 *) (SectorBuffer + 82) == 0x4146 && SectorBuffer[84] == 'T'))
;|*** 					{
;|*** 						continue;
;|*** 					}
;|*** 
;|*** 					// Bootable sector found
;|*** 					if (bootablePartitionCount < array_capacity (bootablePartitions))
;|*** 						bootablePartitions[bootablePartitionCount++] = partition;
;|*** 				}
;|*** 			}
;|*** 		}
;|*** 	}
;|*** 
;|*** 	if (bootablePartitionCount < 1)
; Line 643
	*** 0000e9	83 ff 01 		cmp	di,1
	*** 0000ec	73 0d 			jae	SHORT $L1914
;|*** 	{
;|*** 		PrintError (GST_BOOT_STR_NO_BOOT_PARTITION);
; Line 645
	*** 0000ee	68 00 00 		push	OFFSET DGROUP:??_C@_0BM@IDKA@No?5bootable?5partition?5found?$AA@
	*** 0000f1	e8 00 00 		call	?PrintError@@YAXPBD@Z	; PrintError
	*** 0000f4	5b 			pop	bx
;|*** 		GetKeyboardChar();
; Line 646
	*** 0000f5	e8 00 00 		call	?GetKeyboardChar@@YAEXZ	; GetKeyboardChar
;|*** 		return;
; Line 647
	*** 0000f8	e9 21 01 		jmp	$EX1632
					$L1914:
	*** 0000fb	89 7e f6 		mov	WORD PTR [bp-10],di	;bootablePartitionCount
;|*** 	}
;|*** 
;|*** 	char partChar;
;|*** 	while (true)
; Line 651
					$FC1662:
;|*** 	{
;|*** 		InitScreen();
; Line 653
	*** 0000fe	e8 00 00 		call	?InitScreen@@YAXXZ	; InitScreen
;|*** 		Print ("Bootable Partitions:\r\n");
; Line 654
	*** 000101	68 00 00 		push	OFFSET DGROUP:??_C@_0BH@CKJE@Bootable?5Partitions?3?$AN?6?$AA@
	*** 000104	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000107	5b 			pop	bx
;|*** 		PrintRepeatedChar ('\xC4', 20);
; Line 655
	*** 000108	6a 14 			push	20	;0014H
	*** 00010a	6a c4 			push	-60	;ffc4H
	*** 00010c	e8 00 00 		call	?PrintRepeatedChar@@YAXDH@Z	; PrintRepeatedChar
	*** 00010f	83 c4 04 		add	sp,4
;|*** 		Print ("\r\n");
; Line 656
	*** 000112	68 00 00 		push	OFFSET DGROUP:??_C@_02PIMC@?$AN?6?$AA@
	*** 000115	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000118	5b 			pop	bx
;|*** 
;|*** 		for (size_t i = 0; i < bootablePartitionCount; ++i)
; Line 658
	*** 000119	33 f6 			xor	si,si
	*** 00011b	eb 7c 			jmp	SHORT $L1946
					$F1667:
;|*** 		{
;|*** 			const Partition &partition = bootablePartitions[i];
; Line 660
	*** 00011d	8b c6 			mov	ax,si
	*** 00011f	c1 e0 05 		shl	ax,5
	*** 000122	8d 8e d4 fe 		lea	cx,WORD PTR [bp-300]	;bootablePartitions
	*** 000126	03 c1 			add	ax,cx
	*** 000128	89 46 fe 		mov	WORD PTR [bp-2],ax	;partition
;|*** 			Print ("["); Print (i + 1); Print ("]    ");
; Line 661
	*** 00012b	68 00 00 		push	OFFSET DGROUP:??_C@_01KHLB@?$FL?$AA@
	*** 00012e	89 86 d2 fc 		mov	WORD PTR [bp-814],ax
	*** 000132	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000135	5b 			pop	bx
	*** 000136	8d 44 01 		lea	ax,WORD PTR [si+1]
	*** 000139	6a 00 			push	0
	*** 00013b	50 			push	ax
	*** 00013c	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 00013f	83 c4 04 		add	sp,4
	*** 000142	68 00 00 		push	OFFSET DGROUP:??_C@_05EFLO@?$FN?5?5?5?5?$AA@
	*** 000145	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000148	5b 			pop	bx
;|*** 			Print ("Drive: "); Print (partition.Drive - GST_FIRST_BIOS_DRIVE);
; Line 662
	*** 000149	68 00 00 		push	OFFSET DGROUP:??_C@_07MCKD@Drive?3?5?$AA@
	*** 00014c	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00014f	5b 			pop	bx
	*** 000150	8b 9e d2 fc 		mov	bx,WORD PTR [bp-814]
	*** 000154	2a e4 			sub	ah,ah
	*** 000156	8a 47 01 		mov	al,BYTE PTR [bx+1]
	*** 000159	2d 80 00 		sub	ax,128	;0080H
	*** 00015c	99 			cwd	
	*** 00015d	52 			push	dx
	*** 00015e	50 			push	ax
	*** 00015f	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 000162	83 c4 04 		add	sp,4
;|*** 			Print (", Partition: "); Print (partition.Number + 1);
; Line 663
	*** 000165	68 00 00 		push	OFFSET DGROUP:??_C@_0O@LEMN@?0?5Partition?3?5?$AA@
	*** 000168	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00016b	5b 			pop	bx
	*** 00016c	8b 9e d2 fc 		mov	bx,WORD PTR [bp-814]
	*** 000170	2a e4 			sub	ah,ah
	*** 000172	8a 07 			mov	al,BYTE PTR [bx]
	*** 000174	40 			inc	ax
	*** 000175	99 			cwd	
	*** 000176	52 			push	dx
	*** 000177	50 			push	ax
	*** 000178	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 00017b	83 c4 04 		add	sp,4
;|*** 			Print (", Size: "); PrintSectorCountInMB (partition.SectorCount); PrintEndl();
; Line 664
	*** 00017e	68 00 00 		push	OFFSET DGROUP:??_C@_08PFEJ@?0?5Size?3?5?$AA@
	*** 000181	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000184	5b 			pop	bx
	*** 000185	8b 86 d2 fc 		mov	ax,WORD PTR [bp-814]
	*** 000189	05 0e 00 		add	ax,14	;000eH
	*** 00018c	50 			push	ax
	*** 00018d	e8 00 00 		call	?PrintSectorCountInMB@@YAXABTUINT64_STRUCT@@@Z	; PrintSectorCountInMB
	*** 000190	5b 			pop	bx
	*** 000191	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 		for (size_t i = 0; i < bootablePartitionCount; ++i)
; Line 658
	*** 000194	8d 44 01 		lea	ax,WORD PTR [si+1]
	*** 000197	8b f0 			mov	si,ax
					$L1946:
	*** 000199	3b f7 			cmp	si,di
	*** 00019b	0f 82 7e ff 		jb	$F1667
;|*** 		{
;|*** 			const Partition &partition = bootablePartitions[i];
;|*** 			Print ("["); Print (i + 1); Print ("]    ");
;|*** 			Print ("Drive: "); Print (partition.Drive - GST_FIRST_BIOS_DRIVE);
;|*** 			Print (", Partition: "); Print (partition.Number + 1);
;|*** 			Print (", Size: "); PrintSectorCountInMB (partition.SectorCount); PrintEndl();
;|*** 		}
;|*** 
;|*** 		if (bootablePartitionCount == 1)
; Line 667
	*** 00019f	83 ff 01 		cmp	di,1
	*** 0001a2	75 06 			jne	SHORT $I1674
;|*** 		{
;|*** 			// There's only one bootable partition so we'll boot it directly instead of showing boot manager
;|*** 			partChar = '1';
; Line 670
	*** 0001a4	c6 46 f8 31 		mov	BYTE PTR [bp-8],49	;0031H	;partChar
;|*** 		}
;|*** 		else
; Line 672
	*** 0001a8	eb 32 			jmp	SHORT $I1675
					$I1674:
;|*** 		{
;|*** 			Print ("[Esc]  Cancel\r\n\r\n");
; Line 674
	*** 0001aa	68 00 00 		push	OFFSET DGROUP:??_C@_0BC@DHAO@?$FLEsc?$FN?5?5Cancel?$AN?6?$AN?6?$AA@
	*** 0001ad	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 0001b0	5b 			pop	bx
;|*** 			Print ("Press 1-9 to select partition: ");
; Line 675
	*** 0001b1	68 00 00 		push	OFFSET DGROUP:??_C@_0CA@HAB@Press?51?99?5to?5select?5partition?3?5?$AA@
	*** 0001b4	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 0001b7	5b 			pop	bx
;|*** 
;|*** 			if (GetString (&partChar, 1) == 0)
; Line 677
	*** 0001b8	6a 01 			push	1
	*** 0001ba	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;partChar
	*** 0001bd	50 			push	ax
	*** 0001be	e8 00 00 		call	?GetString@@YAHPADI@Z	; GetString
	*** 0001c1	83 c4 04 		add	sp,4
	*** 0001c4	0b c0 			or	ax,ax
	*** 0001c6	74 54 			je	SHORT $EX1632
;|*** 				return;
;|*** 
;|*** 			PrintEndl();
; Line 680
	*** 0001c8	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 
;|*** 			if (partChar < '1' || partChar > '0' + bootablePartitionCount)
; Line 682
	*** 0001cb	80 7e f8 31 		cmp	BYTE PTR [bp-8],49	;0031H	;partChar
	*** 0001cf	7c 45 			jl	SHORT $I1679
	*** 0001d1	8a 46 f8 		mov	al,BYTE PTR [bp-8]	;partChar
	*** 0001d4	98 			cbw	
	*** 0001d5	8d 4d 30 		lea	cx,WORD PTR [di+48]
	*** 0001d8	3b c8 			cmp	cx,ax
	*** 0001da	72 3a 			jb	SHORT $I1679
;|*** 			{
;|*** 				Beep();
;|*** 				continue;
;|*** 			}
;|*** 		}
; Line 687
					$I1675:
;|*** 
;|*** 		const Partition &partition = bootablePartitions[partChar - '0' - 1];
; Line 689
	*** 0001dc	8a 46 f8 		mov	al,BYTE PTR [bp-8]	;partChar
	*** 0001df	98 			cbw	
	*** 0001e0	8b f0 			mov	si,ax
	*** 0001e2	c1 e6 05 		shl	si,5
	*** 0001e5	8d 86 b4 f8 		lea	ax,WORD PTR [bp-1868]
	*** 0001e9	03 f0 			add	si,ax
;|*** 
;|*** 		if (ReadSectors (SectorBuffer, partition.Drive, partition.StartSector, 1) == BiosResultSuccess)
; Line 691
	*** 0001eb	6a 00 			push	0
	*** 0001ed	6a 01 			push	1
	*** 0001ef	8d 44 16 		lea	ax,WORD PTR [si+22]
	*** 0001f2	50 			push	ax
	*** 0001f3	8a 44 01 		mov	al,BYTE PTR [si+1]
	*** 0001f6	50 			push	ax
	*** 0001f7	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 0001fa	e8 00 00 		call	?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; ReadSectors
	*** 0001fd	83 c4 0a 		add	sp,10	;000aH
	*** 000200	0a c0 			or	al,al
	*** 000202	0f 85 f8 fe 		jne	$FC1662
;|*** 		{
;|*** 			ExecuteBootSector (partition.Drive, SectorBuffer);
; Line 693
	*** 000206	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000209	8a 44 01 		mov	al,BYTE PTR [si+1]
	*** 00020c	50 			push	ax
	*** 00020d	e8 00 00 		call	?ExecuteBootSector@@YAXEPAE@Z	; ExecuteBootSector
	*** 000210	83 c4 04 		add	sp,4
;|*** 		}
;|*** 	}
; Line 695
	*** 000213	e9 e8 fe 		jmp	$FC1662
;|*** 			if (partChar < '1' || partChar > '0' + bootablePartitionCount)
; Line 682
					$I1679:
;|*** 			{
;|*** 				Beep();
; Line 684
	*** 000216	e8 00 00 		call	?Beep@@YAXXZ	; Beep
;|*** 				continue;
; Line 685
	*** 000219	e9 e2 fe 		jmp	$FC1662
;|*** 			}
;|*** 		}
;|*** 
;|*** 		const Partition &partition = bootablePartitions[partChar - '0' - 1];
;|*** 
;|*** 		if (ReadSectors (SectorBuffer, partition.Drive, partition.StartSector, 1) == BiosResultSuccess)
;|*** 		{
;|*** 			ExecuteBootSector (partition.Drive, SectorBuffer);
;|*** 		}
;|*** 	}
;|*** }
; Line 696
					$EX1632:
	*** 00021c	5e 			pop	si
	*** 00021d	5f 			pop	di
	*** 00021e	c9 			leave	
	*** 00021f	c3 			ret	

?BootMenu@@YAXXZ	ENDP

?DecryptDrive@@YAXE@Z	PROC NEAR	; DecryptDrive COMDAT
;|*** 
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static bool CopySystemPartitionToHiddenVolume (byte drive, byte &exitKey)
;|***  *	\brief Copy the system partition to the hidden volume
;|***  *	\param[in] byte & exitKey
;|***  *	\param[in] byte drive
;|***  *	\return static bool false if !MountVolume (drive, exitKey, true, false)
;|***  *			status else
;|***  *
;|***  */
;|*** static bool CopySystemPartitionToHiddenVolume (byte drive, byte &exitKey)
;|*** {
;|*** 	bool status = false;
;|*** 
;|*** 	uint64 sectorsRemaining;
;|*** 	uint64 sectorOffset;
;|*** 	sectorOffset.LowPart = 0;
;|*** 	sectorOffset.HighPart = 0;
;|*** 
;|*** 	int fragmentSectorCount = 0x7f; // Maximum safe value supported by BIOS
;|*** 	int statCount;
;|*** 
;|*** 	if (!CheckMemoryRequirements ())
;|*** 		goto err;
;|*** 
;|*** 	if (!GetSystemPartitions (drive))
;|*** 		goto err;
;|*** 
;|*** 	if (PartitionFollowingActive.Drive == GST_INVALID_BIOS_DRIVE)
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 
;|*** 	// Check if BIOS can read the last sector of the hidden system
;|*** 	AcquireSectorBuffer();
;|*** 
;|*** 	if (ReadSectors (SectorBuffer, PartitionFollowingActive.Drive, PartitionFollowingActive.EndSector - (GST_VOLUME_HEADER_GROUP_SIZE / GST_LB_SIZE - 2), 1) != BiosResultSuccess
;|*** 		|| GetCrc32 (SectorBuffer, sizeof (SectorBuffer)) != OuterVolumeBackupHeaderCrc)
;|*** 	{
;|*** 		PrintErrorNoEndl ("Your BIOS does not support large drives");
;|*** 		Print (IsLbaSupported (PartitionFollowingActive.Drive) ? " due to a bug" : "\r\n- Enable LBA in BIOS");
;|*** 		PrintEndl();
;|*** 		Print (GST_BOOT_STR_UPGRADE_BIOS);
;|*** 
;|*** 		ReleaseSectorBuffer();
;|*** 		goto err;
;|*** 	}
;|*** 
;|*** 	ReleaseSectorBuffer();
;|*** 
;|*** 	if (!MountVolume (drive, exitKey, true, false))
;|*** 		return false;
;|*** 
;|*** 	sectorsRemaining = EncryptedVirtualPartition.SectorCount;
;|*** 
;|*** 	if (!(sectorsRemaining == ActivePartition.SectorCount))
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 
;|*** 	InitScreen();
;|*** 	Print ("\r\nCopying system to hidden volume. To abort, press Esc.\r\n\r\n");
;|*** 
;|*** 	while (sectorsRemaining.HighPart != 0 || sectorsRemaining.LowPart != 0)
;|*** 	{
;|*** 		if (EscKeyPressed())
;|*** 		{
;|*** 			Print ("\rIf aborted, copying will have to start from the beginning (if attempted again).\r\n");
;|*** 			if (AskYesNo ("Abort"))
;|*** 				break;
;|*** 		}
;|*** 
;|*** 		if (sectorsRemaining.HighPart == 0 && sectorsRemaining.LowPart < fragmentSectorCount)
;|*** 			fragmentSectorCount = (int) sectorsRemaining.LowPart;
;|*** 
;|*** 		if (ReadWriteSectors (false, GST_BOOT_LOADER_BUFFER_SEGMENT, 0, drive, ActivePartition.StartSector + sectorOffset, fragmentSectorCount, false) != BiosResultSuccess)
;|*** 		{
;|*** 			Print ("To fix bad sectors: 1) Terminate 2) Encrypt and decrypt sys partition 3) Retry\r\n");
;|*** 			crypto_close (BootCryptoInfo);
;|*** 			goto err;
;|*** 		}
;|*** 
;|*** 		AcquireSectorBuffer();
;|*** 
;|*** 		for (int i = 0; i < fragmentSectorCount; ++i)
;|*** 		{
;|*** 			CopyMemory (GST_BOOT_LOADER_BUFFER_SEGMENT, i * GST_LB_SIZE, SectorBuffer, GST_LB_SIZE);
;|*** 
;|*** 			uint64 s = HiddenVolumeStartUnitNo + sectorOffset + i;
;|*** 			EncryptDataUnits (SectorBuffer, &s, 1, BootCryptoInfo);
;|*** 
;|*** 			CopyMemory (SectorBuffer, GST_BOOT_LOADER_BUFFER_SEGMENT, i * GST_LB_SIZE, GST_LB_SIZE);
;|*** 		} 
;|*** 
;|*** 		ReleaseSectorBuffer();
;|*** 
;|*** 		if (ReadWriteSectors (true, GST_BOOT_LOADER_BUFFER_SEGMENT, 0, drive, HiddenVolumeStartSector + sectorOffset, fragmentSectorCount, false) != BiosResultSuccess)
;|*** 		{
;|*** 			crypto_close (BootCryptoInfo);
;|*** 			goto err;
;|*** 		}
;|*** 
;|*** 		sectorsRemaining = sectorsRemaining - fragmentSectorCount;
;|*** 		sectorOffset = sectorOffset + fragmentSectorCount;
;|*** 
;|*** 		if (!(statCount++ & 0xf))
;|*** 		{
;|*** 			Print ("\rRemaining: ");
;|*** 			PrintSectorCountInMB (sectorsRemaining);
;|*** 		}
;|*** 	}
;|*** 
;|*** 	crypto_close (BootCryptoInfo);
;|*** 
;|*** 	if (sectorsRemaining.HighPart == 0 && sectorsRemaining.LowPart == 0)
;|*** 	{
;|*** 		status = true;
;|*** 		Print ("\rCopying completed.");
;|*** 	}
;|*** 
;|*** 	PrintEndl (2);
;|*** 	goto ret;
;|*** 
;|*** err:
;|*** 	exitKey = GST_BIOS_KEY_ESC;
;|*** 	GetKeyboardChar();
;|*** 
;|*** ret:
;|*** 	EraseMemory ((void *) GST_BOOT_LOADER_ARGS_OFFSET, sizeof (BootArguments));
;|*** 	return status;
;|*** }
;|*** 
;|*** 
;|*** #else // GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void DecryptDrive (byte drive)
;|***  *	\brief Decrypt the drive
;|***  *	\param[in] byte drive
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void DecryptDrive (byte drive)
;|*** {
; Line 842
	*** 000000	c8 3a 00 00 		enter	58,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	headerSector = -18
;	headerCryptoInfo = -10
;	encryptedAreaLength = -34
;	i = -6
;	drive = 4
;	headerCrc32 = -4
;	exitKey = -7
;	bootArguments = -2
;	headerUpdateRequired = -6
;	sectorsRemaining = -26
;	sector = -58
;	fragmentSectorCount = -4
;	statCount = -10
;	skipBadSectors = -5
;	i = -2
;	s = -18
;|*** 	byte exitKey;
;|*** 	if (!MountVolume (drive, exitKey, false, true))
; Line 844
	*** 000006	6a 01 			push	1
	*** 000008	6a 00 			push	0
	*** 00000a	8d 46 f9 		lea	ax,WORD PTR [bp-7]	;exitKey
	*** 00000d	50 			push	ax
	*** 00000e	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000011	50 			push	ax
	*** 000012	e8 00 00 		call	?MountVolume@@YADEAAEDD@Z	; MountVolume
	*** 000015	83 c4 08 		add	sp,8
	*** 000018	0a c0 			or	al,al
	*** 00001a	0f 84 3f 03 		je	$EX1684
;|*** 		return;
;|*** 
;|*** 	BootArguments *bootArguments = (BootArguments *) GST_BOOT_LOADER_ARGS_OFFSET;
; Line 847
	*** 00001e	c7 46 fe 10 00 		mov	WORD PTR [bp-2],16	;0010H	;bootArguments
;|*** 
;|*** 	bool headerUpdateRequired = false;
;|*** 	uint64 sectorsRemaining = EncryptedVirtualPartition.EndSector + 1 - EncryptedVirtualPartition.StartSector;
; Line 850
	*** 000023	68 16 00 		push	OFFSET ?EncryptedVirtualPartition@@3UPartition@@A+22	;EncryptedVirtualPartition
	*** 000026	6a 00 			push	0
	*** 000028	6a 01 			push	1
	*** 00002a	68 04 00 		push	OFFSET ?EncryptedVirtualPartition@@3UPartition@@A+4	;EncryptedVirtualPartition
	*** 00002d	8d 46 d6 		lea	ax,WORD PTR [bp-42]
	*** 000030	50 			push	ax
	*** 000031	e8 00 00 		call	??H@YA?ATUINT64_STRUCT@@ABT0@K@Z	; operator+
	*** 000034	83 c4 08 		add	sp,8
	*** 000037	50 			push	ax
	*** 000038	8d 46 ce 		lea	ax,WORD PTR [bp-50]
	*** 00003b	50 			push	ax
	*** 00003c	e8 00 00 		call	??G@YA?ATUINT64_STRUCT@@ABT0@0@Z	; operator-
	*** 00003f	83 c4 06 		add	sp,6
	*** 000042	8d 7e e6 		lea	di,WORD PTR [bp-26]	;sectorsRemaining
	*** 000045	8b f0 			mov	si,ax
	*** 000047	16 			push	ss
	*** 000048	07 			pop	es
	*** 000049	66 a5 			movsd
	*** 00004b	66 a5 			movsd
;|*** 	uint64 sector = EncryptedVirtualPartition.EndSector + 1;
; Line 851
	*** 00004d	6a 00 			push	0
	*** 00004f	6a 01 			push	1
	*** 000051	68 04 00 		push	OFFSET ?EncryptedVirtualPartition@@3UPartition@@A+4	;EncryptedVirtualPartition
	*** 000054	8d 46 ce 		lea	ax,WORD PTR [bp-50]
	*** 000057	50 			push	ax
	*** 000058	e8 00 00 		call	??H@YA?ATUINT64_STRUCT@@ABT0@K@Z	; operator+
	*** 00005b	83 c4 08 		add	sp,8
	*** 00005e	8d 7e c6 		lea	di,WORD PTR [bp-58]	;sector
	*** 000061	8b f0 			mov	si,ax
	*** 000063	16 			push	ss
	*** 000064	07 			pop	es
	*** 000065	66 a5 			movsd
	*** 000067	66 a5 			movsd
;|*** 
;|*** 	int fragmentSectorCount = 0x7f; // Maximum safe value supported by BIOS
; Line 853
	*** 000069	c7 46 fc 7f 00 		mov	WORD PTR [bp-4],127	;007fH	;headerCrc32
;|*** 	int statCount;
;|*** 
;|*** 	bool skipBadSectors = false;
; Line 856
	*** 00006e	32 c0 			xor	al,al
	*** 000070	88 46 fa 		mov	BYTE PTR [bp-6],al	;i
	*** 000073	88 46 fb 		mov	BYTE PTR [bp-5],al	;skipBadSectors
;|*** 
;|*** 	Print ("\r\nUse only if Windows cannot start. Decryption under Windows is much faster\r\n"
;|*** 			"(in GostCrypt, select 'System' > 'Permanently Decrypt').\r\n\r\n");
; Line 859
	*** 000076	68 00 00 		push	OFFSET DGROUP:??_C@_0IK@PKKH@?$AN?6Use?5only?5if?5Windows?5cannot?5sta@
	*** 000079	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00007c	5b 			pop	bx
;|*** 
;|*** 	if (!AskYesNo ("Decrypt now"))
; Line 861
	*** 00007d	68 00 00 		push	OFFSET DGROUP:??_C@_0M@EMPJ@Decrypt?5now?$AA@
	*** 000080	e8 00 00 		call	?AskYesNo@@YADPBD@Z	; AskYesNo
	*** 000083	5b 			pop	bx
	*** 000084	0a c0 			or	al,al
	*** 000086	75 0b 			jne	SHORT $I1699
;|*** 	{
;|*** 		crypto_close (BootCryptoInfo);
; Line 863
	*** 000088	ff 36 00 00 		push	WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 00008c	e8 00 00 		call	_crypto_close
	*** 00008f	5b 			pop	bx
;|*** 		goto ret;
; Line 864
	*** 000090	e9 c0 02 		jmp	$ret1701
;|*** 	}
;|*** 
;|*** 	if (EncryptedVirtualPartition.Drive == GST_INVALID_BIOS_DRIVE)
; Line 867
					$I1699:
	*** 000093	80 3e 01 00 7f 		cmp	BYTE PTR ?EncryptedVirtualPartition@@3UPartition@@A+1,127	;007fH	;EncryptedVirtualPartition
	*** 000098	75 0d 			jne	SHORT $I1703
;|*** 	{
;|*** 		// Drive already decrypted
;|*** 		sectorsRemaining.HighPart = 0;
; Line 870
	*** 00009a	66 2b c0 		sub	eax,eax
	*** 00009d	66 89 46 ea 		mov	DWORD PTR [bp-22],eax
;|*** 		sectorsRemaining.LowPart = 0;
; Line 871
	*** 0000a1	66 89 46 e6 		mov	DWORD PTR [bp-26],eax	;sectorsRemaining
;|*** 	}
;|*** 	else
; Line 873
	*** 0000a5	eb 07 			jmp	SHORT $L1918
					$I1703:
;|*** 	{
;|*** 		Print ("\r\nTo safely interrupt and defer decryption, press Esc.\r\n"
;|*** 			"WARNING: You can turn off power only after you press Esc.\r\n\r\n");
; Line 876
	*** 0000a7	68 00 00 		push	OFFSET DGROUP:??_C@_0HG@PFFC@?$AN?6To?5safely?5interrupt?5and?5defer?5@
	*** 0000aa	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 0000ad	5b 			pop	bx
					$L1918:
;|*** 	}
;|*** 
;|*** 	while (sectorsRemaining.HighPart != 0 || sectorsRemaining.LowPart != 0)
; Line 879
	*** 0000ae	66 83 7e ea 00 		cmp	DWORD PTR [bp-22],0
	*** 0000b3	75 07 			jne	SHORT $FB1709
	*** 0000b5	66 83 7e e6 00 		cmp	DWORD PTR [bp-26],0	;sectorsRemaining
	*** 0000ba	74 07 			je	SHORT $L1953
					$FB1709:
;|*** 	{
;|*** 		if (EscKeyPressed())
; Line 881
	*** 0000bc	e8 00 00 		call	?EscKeyPressed@@YADXZ	; EscKeyPressed
	*** 0000bf	0a c0 			or	al,al
	*** 0000c1	74 03 			je	SHORT $L1952
;|*** 			break;
;|*** 
;|*** 		if (sectorsRemaining.HighPart == 0 && sectorsRemaining.LowPart < fragmentSectorCount)
; Line 884
					$L1953:
	*** 0000c3	e9 64 01 		jmp	$FB1708
					$L1952:
	*** 0000c6	66 83 7e ea 00 		cmp	DWORD PTR [bp-22],0
	*** 0000cb	75 11 			jne	SHORT $I1711
	*** 0000cd	66 0f bf 46 fc 		movsx	eax,WORD PTR [bp-4]	;headerCrc32
	*** 0000d2	66 3b 46 e6 		cmp	eax,DWORD PTR [bp-26]	;sectorsRemaining
	*** 0000d6	76 06 			jbe	SHORT $I1711
					$L1924:
;|*** 			fragmentSectorCount = (int) sectorsRemaining.LowPart;
; Line 885
	*** 0000d8	8b 46 e6 		mov	ax,WORD PTR [bp-26]	;sectorsRemaining
	*** 0000db	89 46 fc 		mov	WORD PTR [bp-4],ax	;headerCrc32
;|*** 
;|*** 		sector = sector - fragmentSectorCount;
; Line 887
					$I1711:
	*** 0000de	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;headerCrc32
	*** 0000e1	99 			cwd	
	*** 0000e2	52 			push	dx
	*** 0000e3	50 			push	ax
	*** 0000e4	8d 46 c6 		lea	ax,WORD PTR [bp-58]	;sector
	*** 0000e7	50 			push	ax
	*** 0000e8	8d 4e d6 		lea	cx,WORD PTR [bp-42]
	*** 0000eb	51 			push	cx
	*** 0000ec	e8 00 00 		call	??G@YA?ATUINT64_STRUCT@@ABT0@K@Z	; operator-
	*** 0000ef	83 c4 08 		add	sp,8
	*** 0000f2	8d 7e c6 		lea	di,WORD PTR [bp-58]	;sector
	*** 0000f5	8b f0 			mov	si,ax
	*** 0000f7	16 			push	ss
	*** 0000f8	07 			pop	es
	*** 0000f9	66 a5 			movsd
	*** 0000fb	66 a5 			movsd
;|*** 
;|*** 		if (!(statCount++ & 0xf))
; Line 889
	*** 0000fd	8b 46 f6 		mov	ax,WORD PTR [bp-10]	;headerCryptoInfo
	*** 000100	ff 46 f6 		inc	WORD PTR [bp-10]	;headerCryptoInfo
	*** 000103	a8 0f 			test	al,15	;000fH
	*** 000105	75 0f 			jne	SHORT $I1714
;|*** 		{
;|*** 			Print ("\rRemaining: ");
; Line 891
	*** 000107	68 00 00 		push	OFFSET DGROUP:??_C@_0N@BNAP@?$ANRemaining?3?5?$AA@
	*** 00010a	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00010d	5b 			pop	bx
;|*** 			PrintSectorCountInMB (sectorsRemaining);
; Line 892
	*** 00010e	8d 46 e6 		lea	ax,WORD PTR [bp-26]	;sectorsRemaining
	*** 000111	50 			push	ax
	*** 000112	e8 00 00 		call	?PrintSectorCountInMB@@YAXABTUINT64_STRUCT@@@Z	; PrintSectorCountInMB
	*** 000115	5b 			pop	bx
;|*** 		}
;|*** 
;|*** 		if (ReadWriteSectors (false, GST_BOOT_LOADER_BUFFER_SEGMENT, 0, drive, sector, fragmentSectorCount, skipBadSectors) == BiosResultSuccess)
; Line 895
					$I1714:
	*** 000116	8a 46 fb 		mov	al,BYTE PTR [bp-5]	;skipBadSectors
	*** 000119	50 			push	ax
	*** 00011a	ff 76 fc 		push	WORD PTR [bp-4]	;headerCrc32
	*** 00011d	8d 46 c6 		lea	ax,WORD PTR [bp-58]	;sector
	*** 000120	50 			push	ax
	*** 000121	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000124	50 			push	ax
	*** 000125	6a 00 			push	0
	*** 000127	68 00 40 		push	16384	;4000H
	*** 00012a	6a 00 			push	0
	*** 00012c	e8 00 00 		call	?ReadWriteSectors@@YAEDIIEABTUINT64_STRUCT@@ID@Z	; ReadWriteSectors
	*** 00012f	83 c4 0e 		add	sp,14	;000eH
	*** 000132	0a c0 			or	al,al
	*** 000134	0f 85 90 00 		jne	$I1716
;|*** 		{
;|*** 			AcquireSectorBuffer();
;|*** 
;|*** 			for (int i = 0; i < fragmentSectorCount; ++i)
; Line 899
	*** 000138	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;bootArguments
	*** 00013d	eb 61 			jmp	SHORT $L1948
					$F1718:
;|*** 			{
;|*** 				CopyMemory (GST_BOOT_LOADER_BUFFER_SEGMENT, i * GST_LB_SIZE, SectorBuffer, GST_LB_SIZE);
; Line 901
	*** 00013f	68 00 02 		push	512	;0200H
	*** 000142	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000145	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;bootArguments
	*** 000148	c1 e0 09 		shl	ax,9
	*** 00014b	50 			push	ax
	*** 00014c	68 00 40 		push	16384	;4000H
	*** 00014f	8b f0 			mov	si,ax
	*** 000151	e8 00 00 		call	?CopyMemory@@YAXIIPAXI@Z	; CopyMemory
	*** 000154	83 c4 08 		add	sp,8
;|*** 
;|*** 				uint64 s = sector + i;
; Line 903
	*** 000157	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;bootArguments
	*** 00015a	99 			cwd	
	*** 00015b	52 			push	dx
	*** 00015c	50 			push	ax
	*** 00015d	8d 46 c6 		lea	ax,WORD PTR [bp-58]	;sector
	*** 000160	50 			push	ax
	*** 000161	8d 46 ce 		lea	ax,WORD PTR [bp-50]
	*** 000164	50 			push	ax
	*** 000165	e8 00 00 		call	??H@YA?ATUINT64_STRUCT@@ABT0@K@Z	; operator+
	*** 000168	83 c4 08 		add	sp,8
	*** 00016b	56 			push	si
	*** 00016c	8d 7e ee 		lea	di,WORD PTR [bp-18]	;headerSector
	*** 00016f	8b f0 			mov	si,ax
	*** 000171	16 			push	ss
	*** 000172	07 			pop	es
	*** 000173	66 a5 			movsd
	*** 000175	66 a5 			movsd
	*** 000177	5e 			pop	si
;|*** 				DecryptDataUnits (SectorBuffer, &s, 1, BootCryptoInfo);
; Line 904
	*** 000178	ff 36 00 00 		push	WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 00017c	6a 00 			push	0
	*** 00017e	6a 01 			push	1
	*** 000180	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;headerSector
	*** 000183	50 			push	ax
	*** 000184	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000187	e8 00 00 		call	_DecryptDataUnits
	*** 00018a	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|*** 				CopyMemory (SectorBuffer, GST_BOOT_LOADER_BUFFER_SEGMENT, i * GST_LB_SIZE, GST_LB_SIZE);
; Line 906
	*** 00018d	68 00 02 		push	512	;0200H
	*** 000190	56 			push	si
	*** 000191	68 00 40 		push	16384	;4000H
	*** 000194	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000197	e8 00 00 		call	?CopyMemory@@YAXPAXIII@Z	; CopyMemory
	*** 00019a	83 c4 08 		add	sp,8
;|*** 			for (int i = 0; i < fragmentSectorCount; ++i)
; Line 899
	*** 00019d	ff 46 fe 		inc	WORD PTR [bp-2]	;bootArguments
					$L1948:
	*** 0001a0	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;headerCrc32
	*** 0001a3	39 46 fe 		cmp	WORD PTR [bp-2],ax	;bootArguments
	*** 0001a6	7c 97 			jl	SHORT $F1718
;|*** 			{
;|*** 				CopyMemory (GST_BOOT_LOADER_BUFFER_SEGMENT, i * GST_LB_SIZE, SectorBuffer, GST_LB_SIZE);
;|*** 
;|*** 				uint64 s = sector + i;
;|*** 				DecryptDataUnits (SectorBuffer, &s, 1, BootCryptoInfo);
;|*** 
;|*** 				CopyMemory (SectorBuffer, GST_BOOT_LOADER_BUFFER_SEGMENT, i * GST_LB_SIZE, GST_LB_SIZE);
;|*** 			} 
;|*** 
;|*** 			ReleaseSectorBuffer();
;|*** 
;|*** 			if (ReadWriteSectors (true, GST_BOOT_LOADER_BUFFER_SEGMENT, 0, drive, sector, fragmentSectorCount, skipBadSectors) != BiosResultSuccess && !skipBadSectors)
; Line 911
	*** 0001a8	8a 46 fb 		mov	al,BYTE PTR [bp-5]	;skipBadSectors
	*** 0001ab	50 			push	ax
	*** 0001ac	ff 76 fc 		push	WORD PTR [bp-4]	;headerCrc32
	*** 0001af	8d 46 c6 		lea	ax,WORD PTR [bp-58]	;sector
	*** 0001b2	50 			push	ax
	*** 0001b3	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 0001b6	50 			push	ax
	*** 0001b7	6a 00 			push	0
	*** 0001b9	68 00 40 		push	16384	;4000H
	*** 0001bc	6a 01 			push	1
	*** 0001be	e8 00 00 		call	?ReadWriteSectors@@YAEDIIEABTUINT64_STRUCT@@ID@Z	; ReadWriteSectors
	*** 0001c1	83 c4 0e 		add	sp,14	;000eH
	*** 0001c4	0a c0 			or	al,al
	*** 0001c6	74 3c 			je	SHORT $I1726
;|*** 				goto askBadSectorSkip;
;|*** 		}
;|*** 		else if (!skipBadSectors)
; Line 914
					$I1716:
	*** 0001c8	80 7e fb 00 		cmp	BYTE PTR [bp-5],0	;skipBadSectors
	*** 0001cc	75 36 			jne	SHORT $I1726
;|*** 			goto askBadSectorSkip;
;|*** 
;|*** 		sectorsRemaining = sectorsRemaining - fragmentSectorCount;
;|*** 		headerUpdateRequired = true;
;|*** 		continue;
;|*** 
;|*** askBadSectorSkip:
;|*** 		if (!AskYesNo ("Skip all bad sectors"))
; Line 922
	*** 0001ce	68 00 00 		push	OFFSET DGROUP:??_C@_0BF@LODE@Skip?5all?5bad?5sectors?$AA@
	*** 0001d1	e8 00 00 		call	?AskYesNo@@YADPBD@Z	; AskYesNo
	*** 0001d4	5b 			pop	bx
	*** 0001d5	0a c0 			or	al,al
	*** 0001d7	74 51 			je	SHORT $FB1708
;|*** 			break;
;|*** 
;|*** 		skipBadSectors = true;
; Line 925
	*** 0001d9	c6 46 fb 01 		mov	BYTE PTR [bp-5],1	;skipBadSectors
;|*** 		sector = sector + fragmentSectorCount;
; Line 926
	*** 0001dd	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;headerCrc32
	*** 0001e0	99 			cwd	
	*** 0001e1	52 			push	dx
	*** 0001e2	50 			push	ax
	*** 0001e3	8d 46 c6 		lea	ax,WORD PTR [bp-58]	;sector
	*** 0001e6	50 			push	ax
	*** 0001e7	8d 4e ce 		lea	cx,WORD PTR [bp-50]
	*** 0001ea	51 			push	cx
	*** 0001eb	e8 00 00 		call	??H@YA?ATUINT64_STRUCT@@ABT0@K@Z	; operator+
	*** 0001ee	83 c4 08 		add	sp,8
	*** 0001f1	8d 7e c6 		lea	di,WORD PTR [bp-58]	;sector
	*** 0001f4	8b f0 			mov	si,ax
	*** 0001f6	16 			push	ss
	*** 0001f7	07 			pop	es
	*** 0001f8	66 a5 			movsd
	*** 0001fa	66 a5 			movsd
;|*** 		fragmentSectorCount = 1;
; Line 927
	*** 0001fc	c7 46 fc 01 00 		mov	WORD PTR [bp-4],1	;headerCrc32
;|*** 	}
; Line 928
	*** 000201	e9 aa fe 		jmp	$L1918
;|*** 		sectorsRemaining = sectorsRemaining - fragmentSectorCount;
; Line 917
					$I1726:
	*** 000204	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;headerCrc32
	*** 000207	99 			cwd	
	*** 000208	52 			push	dx
	*** 000209	50 			push	ax
	*** 00020a	8d 46 e6 		lea	ax,WORD PTR [bp-26]	;sectorsRemaining
	*** 00020d	50 			push	ax
	*** 00020e	8d 4e d6 		lea	cx,WORD PTR [bp-42]
	*** 000211	51 			push	cx
	*** 000212	e8 00 00 		call	??G@YA?ATUINT64_STRUCT@@ABT0@K@Z	; operator-
	*** 000215	83 c4 08 		add	sp,8
	*** 000218	8d 7e e6 		lea	di,WORD PTR [bp-26]	;sectorsRemaining
	*** 00021b	8b f0 			mov	si,ax
	*** 00021d	16 			push	ss
	*** 00021e	07 			pop	es
	*** 00021f	66 a5 			movsd
	*** 000221	66 a5 			movsd
;|*** 		headerUpdateRequired = true;
; Line 918
	*** 000223	c6 46 fa 01 		mov	BYTE PTR [bp-6],1	;i
;|*** 		continue;
; Line 919
	*** 000227	e9 84 fe 		jmp	$L1918
;|*** 
;|*** askBadSectorSkip:
;|*** 		if (!AskYesNo ("Skip all bad sectors"))
;|*** 			break;
;|*** 
;|*** 		skipBadSectors = true;
;|*** 		sector = sector + fragmentSectorCount;
;|*** 		fragmentSectorCount = 1;
;|*** 	}
; Line 928
					$FB1708:
;|*** 
;|*** 	crypto_close (BootCryptoInfo);
; Line 930
	*** 00022a	ff 36 00 00 		push	WORD PTR ?BootCryptoInfo@@3PAUCRYPTO_INFO_t@@A	;BootCryptoInfo
	*** 00022e	e8 00 00 		call	_crypto_close
	*** 000231	5b 			pop	bx
;|*** 
;|*** 	if (headerUpdateRequired)
; Line 932
	*** 000232	80 7e fa 00 		cmp	BYTE PTR [bp-6],0	;i
	*** 000236	0f 84 fc 00 		je	$I1733
;|*** 	{
;|*** 		AcquireSectorBuffer();
;|*** 		uint64 headerSector;
;|*** 		headerSector.HighPart = 0;
; Line 936
	*** 00023a	66 2b c0 		sub	eax,eax
	*** 00023d	66 89 46 f2 		mov	DWORD PTR [bp-14],eax
;|*** 		headerSector.LowPart = GST_BOOT_VOLUME_HEADER_SECTOR;
; Line 937
	*** 000241	c7 46 ee 3e 00 		mov	WORD PTR [bp-18],62	;003eH	;headerSector
	*** 000246	89 46 f0 		mov	WORD PTR [bp-16],ax
;|*** 
;|*** 		// Update encrypted area size in volume header
;|*** 
;|*** 		CRYPTO_INFO *headerCryptoInfo = crypto_open();
; Line 941
	*** 000249	e8 00 00 		call	_crypto_open
	*** 00024c	89 46 f6 		mov	WORD PTR [bp-10],ax	;headerCryptoInfo
;|*** 		while (ReadSectors (SectorBuffer, drive, headerSector, 1) != BiosResultSuccess);
; Line 942
					$FC1737:
	*** 00024f	6a 00 			push	0
	*** 000251	6a 01 			push	1
	*** 000253	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;headerSector
	*** 000256	50 			push	ax
	*** 000257	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 00025a	50 			push	ax
	*** 00025b	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 00025e	e8 00 00 		call	?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; ReadSectors
	*** 000261	83 c4 0a 		add	sp,10	;000aH
	*** 000264	0a c0 			or	al,al
	*** 000266	75 e7 			jne	SHORT $FC1737
;|*** 
;|*** 		if (ReadVolumeHeader (TRUE, (char *) SectorBuffer, &bootArguments->BootPassword, NULL, headerCryptoInfo) == 0)
; Line 944
	*** 000268	ff 76 f6 		push	WORD PTR [bp-10]	;headerCryptoInfo
	*** 00026b	6a 00 			push	0
	*** 00026d	6a 22 			push	34	;0022H
	*** 00026f	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000272	6a 01 			push	1
	*** 000274	e8 00 00 		call	_ReadVolumeHeader
	*** 000277	83 c4 0a 		add	sp,10	;000aH
	*** 00027a	0b c0 			or	ax,ax
	*** 00027c	0f 85 96 00 		jne	$I1740
;|*** 		{
;|*** 			DecryptBuffer (SectorBuffer + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, headerCryptoInfo);
; Line 946
	*** 000280	ff 76 f6 		push	WORD PTR [bp-10]	;headerCryptoInfo
	*** 000283	50 			push	ax
	*** 000284	68 c0 01 		push	448	;01c0H
	*** 000287	68 40 00 		push	OFFSET ?SectorBuffer@@3QAEA+64	;SectorBuffer
	*** 00028a	e8 00 00 		call	_DecryptBuffer
	*** 00028d	83 c4 08 		add	sp,8
;|*** 
;|*** 			uint64 encryptedAreaLength = sectorsRemaining << GST_LB_SIZE_BIT_SHIFT_DIVISOR;
; Line 948
	*** 000290	6a 09 			push	9
	*** 000292	8d 46 e6 		lea	ax,WORD PTR [bp-26]	;sectorsRemaining
	*** 000295	50 			push	ax
	*** 000296	8d 46 d6 		lea	ax,WORD PTR [bp-42]
	*** 000299	50 			push	ax
	*** 00029a	e8 00 00 		call	??6@YA?ATUINT64_STRUCT@@ABT0@H@Z	; operator<<
	*** 00029d	83 c4 06 		add	sp,6
	*** 0002a0	8d 7e de 		lea	di,WORD PTR [bp-34]	;encryptedAreaLength
	*** 0002a3	8b f0 			mov	si,ax
	*** 0002a5	16 			push	ss
	*** 0002a6	07 			pop	es
	*** 0002a7	66 a5 			movsd
	*** 0002a9	66 a5 			movsd
;|*** 
;|*** 			for (int i = 7; i >= 0; --i)
; Line 950
	*** 0002ab	c7 46 fa 07 00 		mov	WORD PTR [bp-6],7	;i
					$F1744:
;|*** 			{
;|*** 				SectorBuffer[GST_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH + i] = (byte) encryptedAreaLength.LowPart;
; Line 952
	*** 0002b0	8b 5e fa 		mov	bx,WORD PTR [bp-6]	;i
	*** 0002b3	8a 46 de 		mov	al,BYTE PTR [bp-34]	;encryptedAreaLength
	*** 0002b6	88 87 74 00 		mov	BYTE PTR ?SectorBuffer@@3QAEA[bx+116],al	;SectorBuffer
;|*** 				encryptedAreaLength = encryptedAreaLength >> 8;
; Line 953
	*** 0002ba	6a 08 			push	8
	*** 0002bc	8d 46 de 		lea	ax,WORD PTR [bp-34]	;encryptedAreaLength
	*** 0002bf	50 			push	ax
	*** 0002c0	8d 4e ce 		lea	cx,WORD PTR [bp-50]
	*** 0002c3	51 			push	cx
	*** 0002c4	e8 00 00 		call	??5@YA?ATUINT64_STRUCT@@ABT0@H@Z	; operator>>
	*** 0002c7	83 c4 06 		add	sp,6
	*** 0002ca	8d 7e de 		lea	di,WORD PTR [bp-34]	;encryptedAreaLength
	*** 0002cd	8b f0 			mov	si,ax
	*** 0002cf	16 			push	ss
	*** 0002d0	07 			pop	es
	*** 0002d1	66 a5 			movsd
	*** 0002d3	66 a5 			movsd
;|*** 			for (int i = 7; i >= 0; --i)
; Line 950
	*** 0002d5	ff 4e fa 		dec	WORD PTR [bp-6]	;i
	*** 0002d8	79 d6 			jns	SHORT $F1744
;|*** 			{
;|*** 				SectorBuffer[GST_HEADER_OFFSET_ENCRYPTED_AREA_LENGTH + i] = (byte) encryptedAreaLength.LowPart;
;|*** 				encryptedAreaLength = encryptedAreaLength >> 8;
;|*** 			}
;|*** 
;|*** 			uint32 headerCrc32 = GetCrc32 (SectorBuffer + GST_HEADER_OFFSET_MAGIC, GST_HEADER_OFFSET_HEADER_CRC - GST_HEADER_OFFSET_MAGIC);
; Line 956
	*** 0002da	68 bc 00 		push	188	;00bcH
	*** 0002dd	68 40 00 		push	OFFSET ?SectorBuffer@@3QAEA+64	;SectorBuffer
	*** 0002e0	e8 00 00 		call	_GetCrc32
	*** 0002e3	83 c4 04 		add	sp,4
	*** 0002e6	89 46 fc 		mov	WORD PTR [bp-4],ax	;headerCrc32
	*** 0002e9	89 56 fe 		mov	WORD PTR [bp-2],dx	;bootArguments
;|*** 
;|*** 			for (i = 3; i >= 0; --i)
; Line 958
	*** 0002ec	be 03 00 		mov	si,3
					$F1750:
;|*** 			{
;|*** 				SectorBuffer[GST_HEADER_OFFSET_HEADER_CRC + i] = (byte) headerCrc32;
; Line 960
	*** 0002ef	8a 46 fc 		mov	al,BYTE PTR [bp-4]	;headerCrc32
	*** 0002f2	88 84 fc 00 		mov	BYTE PTR ?SectorBuffer@@3QAEA[si+252],al	;SectorBuffer
;|*** 				headerCrc32 >>= 8;
; Line 961
	*** 0002f6	66 8b 46 fc 		mov	eax,DWORD PTR [bp-4]	;headerCrc32
	*** 0002fa	66 c1 e8 08 		shr	eax,8
	*** 0002fe	66 89 46 fc 		mov	DWORD PTR [bp-4],eax	;headerCrc32
;|*** 			for (i = 3; i >= 0; --i)
; Line 958
	*** 000302	4e 			dec	si
	*** 000303	79 ea 			jns	SHORT $F1750
;|*** 			{
;|*** 				SectorBuffer[GST_HEADER_OFFSET_HEADER_CRC + i] = (byte) headerCrc32;
;|*** 				headerCrc32 >>= 8;
;|*** 			}
;|*** 
;|*** 			EncryptBuffer (SectorBuffer + HEADER_ENCRYPTED_DATA_OFFSET, HEADER_ENCRYPTED_DATA_SIZE, headerCryptoInfo);
; Line 964
	*** 000305	ff 76 f6 		push	WORD PTR [bp-10]	;headerCryptoInfo
	*** 000308	6a 00 			push	0
	*** 00030a	68 c0 01 		push	448	;01c0H
	*** 00030d	68 40 00 		push	OFFSET ?SectorBuffer@@3QAEA+64	;SectorBuffer
	*** 000310	e8 00 00 		call	_EncryptBuffer
	*** 000313	83 c4 08 		add	sp,8
;|*** 		}
;|*** 
;|*** 		crypto_close (headerCryptoInfo);
; Line 967
					$I1740:
	*** 000316	ff 76 f6 		push	WORD PTR [bp-10]	;headerCryptoInfo
	*** 000319	e8 00 00 		call	_crypto_close
	*** 00031c	5b 			pop	bx
;|*** 
;|*** 		while (WriteSectors (SectorBuffer, drive, headerSector, 1) != BiosResultSuccess);
; Line 969
					$FC1755:
	*** 00031d	6a 00 			push	0
	*** 00031f	6a 01 			push	1
	*** 000321	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;headerSector
	*** 000324	50 			push	ax
	*** 000325	8a 46 04 		mov	al,BYTE PTR [bp+4]	;drive
	*** 000328	50 			push	ax
	*** 000329	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 00032c	e8 00 00 		call	?WriteSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; WriteSectors
	*** 00032f	83 c4 0a 		add	sp,10	;000aH
	*** 000332	0a c0 			or	al,al
	*** 000334	75 e7 			jne	SHORT $FC1755
;|*** 		ReleaseSectorBuffer();
;|*** 	}
;|*** 
;|*** 	if (sectorsRemaining.HighPart == 0 && sectorsRemaining.LowPart == 0)
; Line 973
					$I1733:
	*** 000336	66 83 7e ea 00 		cmp	DWORD PTR [bp-22],0
	*** 00033b	75 0c 			jne	SHORT $I1757
	*** 00033d	66 83 7e e6 00 		cmp	DWORD PTR [bp-26],0	;sectorsRemaining
	*** 000342	75 05 			jne	SHORT $I1757
;|*** 		Print ("\rDrive decrypted.\r\n");
; Line 974
	*** 000344	68 00 00 		push	OFFSET DGROUP:??_C@_0BE@LMLE@?$ANDrive?5decrypted?4?$AN?6?$AA@
	*** 000347	eb 03 			jmp	SHORT $L1951
					$I1757:
;|*** 	else
;|*** 		Print ("\r\nDecryption deferred.\r\n");
; Line 976
	*** 000349	68 00 00 		push	OFFSET DGROUP:??_C@_0BJ@HKIB@?$AN?6Decryption?5deferred?4?$AN?6?$AA@
					$L1951:
	*** 00034c	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00034f	5b 			pop	bx
;|*** 
;|*** 	GetKeyboardChar();
; Line 978
	*** 000350	e8 00 00 		call	?GetKeyboardChar@@YAEXZ	; GetKeyboardChar
;|*** ret:
; Line 979
					$ret1701:
;|*** 	EraseMemory (bootArguments, sizeof (*bootArguments));
; Line 980
	*** 000353	6a 76 			push	118	;0076H
	*** 000355	6a 10 			push	16	;0010H
	*** 000357	e8 00 00 		call	_EraseMemory
	*** 00035a	83 c4 04 		add	sp,4
;|*** }
; Line 981
					$EX1684:
	*** 00035d	5e 			pop	si
	*** 00035e	5f 			pop	di
	*** 00035f	c9 			leave	
	*** 000360	c3 			ret	

?DecryptDrive@@YAXE@Z	ENDP

?RepairMenu@@YAXXZ	PROC NEAR	; RepairMenu COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void RepairMenu ()
;|***  *	\brief When repair is pressed, print the repair menu and wait for instructions
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void RepairMenu ()
;|*** {
; Line 992
	*** 000000	c8 ac 00 00 		enter	172,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	writeConfirmed = -2
;	result = -10
;	sector = -28
;	chs = -20
;	mbrPartTable = -100
;	i = -4
;	validHeaderPresent = -1
;	masterKeyScheduleCrc = -12
;	password = -172
;	exitKey = -176
;	cryptoInfo = -8
;	bootLoaderDriveGeometry = -16
;	selection = -6
;|*** 	DriveGeometry bootLoaderDriveGeometry;
;|*** 
;|*** 	if (GetDriveGeometry (BootLoaderDrive, bootLoaderDriveGeometry, true) != BiosResultSuccess)
; Line 995
	*** 000006	6a 01 			push	1
	*** 000008	8d 46 f0 		lea	ax,WORD PTR [bp-16]	;bootLoaderDriveGeometry
	*** 00000b	50 			push	ax
	*** 00000c	a0 00 00 		mov	al,BYTE PTR ?BootLoaderDrive@@3EA	;BootLoaderDrive
	*** 00000f	50 			push	ax
	*** 000010	e8 00 00 		call	?GetDriveGeometry@@YAEEAAUDriveGeometry@@D@Z	; GetDriveGeometry
	*** 000013	83 c4 06 		add	sp,6
	*** 000016	0a c0 			or	al,al
	*** 000018	74 0d 			je	SHORT $L1926
;|*** 	{
;|*** 		// Some BIOSes may fail to get the geometry of an emulated floppy drive
;|*** 		bootLoaderDriveGeometry.Cylinders = 80;
; Line 998
	*** 00001a	c7 46 f0 50 00 		mov	WORD PTR [bp-16],80	;0050H	;bootLoaderDriveGeometry
;|*** 		bootLoaderDriveGeometry.Heads = 2;
; Line 999
	*** 00001f	c6 46 f2 02 		mov	BYTE PTR [bp-14],2
;|*** 		bootLoaderDriveGeometry.Sectors = 18;
; Line 1000
	*** 000023	c6 46 f3 12 		mov	BYTE PTR [bp-13],18	;0012H
					$L1926:
;|*** 	}
;|*** 
;|*** 	while (true)
;|*** 	{
;|*** 		InitScreen();
; Line 1005
	*** 000027	e8 00 00 		call	?InitScreen@@YAXXZ	; InitScreen
;|*** 		Print ("Available "); Print ("Repair Options"); Print (":\r\n");
; Line 1006
	*** 00002a	68 00 00 		push	OFFSET DGROUP:??_C@_0L@CGGC@Available?5?$AA@
	*** 00002d	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000030	5b 			pop	bx
	*** 000031	68 00 00 		push	OFFSET DGROUP:??_C@_0P@KAON@Repair?5Options?$AA@
	*** 000034	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000037	5b 			pop	bx
	*** 000038	68 00 00 		push	OFFSET DGROUP:??_C@_03KPOF@?3?$AN?6?$AA@
	*** 00003b	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00003e	5b 			pop	bx
;|*** 		PrintRepeatedChar ('\xC4', 25);
; Line 1007
	*** 00003f	6a 19 			push	25	;0019H
	*** 000041	6a c4 			push	-60	;ffc4H
	*** 000043	e8 00 00 		call	?PrintRepeatedChar@@YAXDH@Z	; PrintRepeatedChar
	*** 000046	83 c4 04 		add	sp,4
;|*** 		PrintEndl();
; Line 1008
	*** 000049	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 
;|*** 		enum
;|*** 		{
;|*** 			RestoreNone = 0,
;|*** 			DecryptVolume,
;|*** 			RestoreGostCryptLoader,
;|*** 			RestoreVolumeHeader,
;|*** 			RestoreOriginalSystemLoader
;|*** 		};
;|*** 
;|*** 		static const char *options[] = { "Permanently decrypt system partition/drive", "Restore GostCrypt Boot Loader", "Restore key data (volume header)", "Restore original system loader" };
;|*** 
;|*** 		int selection = AskSelection (options,
;|*** 			(BootSectorFlags & GST_BOOT_CFG_FLAG_RESCUE_DISK_ORIG_SYS_LOADER) ? array_capacity (options) : array_capacity (options) - 1);
; Line 1022
	*** 00004c	a0 00 00 		mov	al,BYTE PTR ?BootSectorFlags@@3EA	;BootSectorFlags
	*** 00004f	24 20 			and	al,32	;0020H
	*** 000051	3c 01 			cmp	al,1
	*** 000053	1b c0 			sbb	ax,ax
	*** 000055	05 04 00 		add	ax,4
	*** 000058	50 			push	ax
	*** 000059	68 00 00 		push	OFFSET DGROUP:$S1777_?options@?3??RepairMenu@@YAXXZ@4QAPBDA
	*** 00005c	e8 00 00 		call	?AskSelection@@YAHQAPBDI@Z	; AskSelection
	*** 00005f	83 c4 04 		add	sp,4
	*** 000062	8b f8 			mov	di,ax
;|*** 
;|*** 		PrintEndl();
; Line 1024
	*** 000064	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 
;|*** 		switch (selection)
; Line 1026
	*** 000067	8b c7 			mov	ax,di
;|*** 		{
;|*** 			case RestoreNone:
;|*** 				return;
;|*** 
;|*** 			case DecryptVolume:
;|*** 				DecryptDrive (BootDrive);
;|*** 				continue;
;|*** 
;|*** 			case RestoreOriginalSystemLoader:
;|*** 				if (!AskYesNo ("Is the system partition/drive decrypted"))
;|*** 				{
;|*** 					Print ("Please decrypt it first.\r\n");
;|*** 					GetKeyboardChar();
;|*** 					continue;
;|*** 				}
;|*** 				break;
;|*** 		}
; Line 1043
	*** 000069	0b c7 			or	ax,di
	*** 00006b	0f 84 1d 02 		je	$EX1762
	*** 00006f	48 			dec	ax
	*** 000070	74 1b 			je	SHORT $SC1788
	*** 000072	2d 03 00 		sub	ax,3
	*** 000075	74 20 			je	SHORT $SC1789
					$SB1784:
;|*** 
;|*** 		bool writeConfirmed = false;
; Line 1045
	*** 000077	c6 46 fe 00 		mov	BYTE PTR [bp-2],0	;writeConfirmed
;|*** 		BiosResult result;
;|*** 
;|*** 		uint64 sector;
;|*** 		sector.HighPart = 0;
; Line 1049
	*** 00007b	66 c7 46 e8 00 00 00 00 mov	DWORD PTR [bp-24],0
;|*** 		ChsAddress chs;
;|*** 
;|*** 		byte mbrPartTable[GST_LB_SIZE - GST_MAX_MBR_BOOT_CODE_SIZE];
;|*** 		AcquireSectorBuffer();
;|*** 
;|*** 		for (int i = (selection == RestoreVolumeHeader ? GST_BOOT_VOLUME_HEADER_SECTOR : GST_MBR_SECTOR);
; Line 1055
	*** 000083	83 ff 03 		cmp	di,3
	*** 000086	75 27 			jne	SHORT $L1935
	*** 000088	be 3e 00 		mov	si,62	;003eH
	*** 00008b	eb 24 			jmp	SHORT $L1936
;|*** 			case DecryptVolume:
; Line 1031
					$SC1788:
;|*** 				DecryptDrive (BootDrive);
; Line 1032
	*** 00008d	a0 00 00 		mov	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 000090	50 			push	ax
	*** 000091	e8 00 00 		call	?DecryptDrive@@YAXE@Z	; DecryptDrive
	*** 000094	5b 			pop	bx
;|*** 				continue;
; Line 1033
	*** 000095	eb 90 			jmp	SHORT $L1926
;|*** 
;|*** 			case RestoreOriginalSystemLoader:
; Line 1035
					$SC1789:
;|*** 				if (!AskYesNo ("Is the system partition/drive decrypted"))
; Line 1036
	*** 000097	68 00 00 		push	OFFSET DGROUP:??_C@_0CI@CJAH@Is?5the?5system?5partition?1drive?5de@
	*** 00009a	e8 00 00 		call	?AskYesNo@@YADPBD@Z	; AskYesNo
	*** 00009d	5b 			pop	bx
	*** 00009e	0a c0 			or	al,al
	*** 0000a0	75 d5 			jne	SHORT $SB1784
;|*** 				{
;|*** 					Print ("Please decrypt it first.\r\n");
; Line 1038
	*** 0000a2	68 00 00 		push	OFFSET DGROUP:??_C@_0BL@HDPH@Please?5decrypt?5it?5first?4?$AN?6?$AA@
					$L1956:
	*** 0000a5	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 0000a8	5b 			pop	bx
;|*** 					GetKeyboardChar();
; Line 1039
					$L1954:
	*** 0000a9	e8 00 00 		call	?GetKeyboardChar@@YAEXZ	; GetKeyboardChar
;|*** 					continue;
; Line 1040
	*** 0000ac	e9 78 ff 		jmp	$L1926
;|*** 				}
;|*** 				break;
;|*** 		}
; Line 1043
					$L1935:
	*** 0000af	33 f6 			xor	si,si
					$L1936:
	*** 0000b1	89 7e fa 		mov	WORD PTR [bp-6],di	;selection
;|*** 
;|*** 		bool writeConfirmed = false;
;|*** 		BiosResult result;
;|*** 
;|*** 		uint64 sector;
;|*** 		sector.HighPart = 0;
;|*** 		ChsAddress chs;
;|*** 
;|*** 		byte mbrPartTable[GST_LB_SIZE - GST_MAX_MBR_BOOT_CODE_SIZE];
;|*** 		AcquireSectorBuffer();
;|*** 
;|*** 		for (int i = (selection == RestoreVolumeHeader ? GST_BOOT_VOLUME_HEADER_SECTOR : GST_MBR_SECTOR);
;|*** 			i < GST_BOOT_LOADER_AREA_SECTOR_COUNT; ++i)
; Line 1056
					$F1799:
	*** 0000b4	83 fe 3f 		cmp	si,63	;003fH
	*** 0000b7	0f 8d ac 01 		jge	$done1839
;|*** 		{
;|*** 			sector.LowPart = i;
; Line 1058
	*** 0000bb	8b c6 			mov	ax,si
	*** 0000bd	99 			cwd	
	*** 0000be	89 76 e4 		mov	WORD PTR [bp-28],si	;sector
	*** 0000c1	89 56 e6 		mov	WORD PTR [bp-26],dx
;|*** 
;|*** 			if (selection == RestoreOriginalSystemLoader)
; Line 1060
	*** 0000c4	83 ff 04 		cmp	di,4
	*** 0000c7	75 06 			jne	SHORT $I1802
;|*** 				sector.LowPart += GST_ORIG_BOOT_LOADER_BACKUP_SECTOR;
; Line 1061
	*** 0000c9	83 46 e4 3f 		add	WORD PTR [bp-28],63	;003fH	;sector
	*** 0000cd	eb 09 			jmp	SHORT $L1955
					$I1802:
	*** 0000cf	83 ff 02 		cmp	di,2
	*** 0000d2	75 08 			jne	SHORT $I1803
;|*** 			else if (selection == RestoreGostCryptLoader)
;|*** 				sector.LowPart += GST_BOOT_LOADER_BACKUP_RESCUE_DISK_SECTOR;
; Line 1063
	*** 0000d4	83 46 e4 7e 		add	WORD PTR [bp-28],126	;007eH	;sector
					$L1955:
	*** 0000d8	83 56 e6 00 		adc	WORD PTR [bp-26],0
;|*** 
;|*** 			// The backup medium may be a floppy-emulated bootable CD. The emulation may fail if LBA addressing is used.
;|*** 			// Therefore, only CHS addressing can be used.
;|*** 			LbaToChs (bootLoaderDriveGeometry, sector, chs);
; Line 1067
					$I1803:
	*** 0000dc	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;chs
	*** 0000df	50 			push	ax
	*** 0000e0	8d 46 e4 		lea	ax,WORD PTR [bp-28]	;sector
	*** 0000e3	50 			push	ax
	*** 0000e4	8d 4e f0 		lea	cx,WORD PTR [bp-16]	;bootLoaderDriveGeometry
	*** 0000e7	51 			push	cx
	*** 0000e8	e8 00 00 		call	?LbaToChs@@YAXABUDriveGeometry@@ABTUINT64_STRUCT@@AAUChsAddress@@@Z	; LbaToChs
	*** 0000eb	83 c4 06 		add	sp,6
;|*** 			sector.LowPart = i;
; Line 1068
	*** 0000ee	8b c6 			mov	ax,si
	*** 0000f0	99 			cwd	
	*** 0000f1	89 76 e4 		mov	WORD PTR [bp-28],si	;sector
	*** 0000f4	89 56 e6 		mov	WORD PTR [bp-26],dx
;|*** 
;|*** 			if (i == GST_MBR_SECTOR)
; Line 1070
	*** 0000f7	0b f6 			or	si,si
	*** 0000f9	75 26 			jne	SHORT $I1805
;|*** 			{
;|*** 				// Read current partition table
;|*** 				result = ReadSectors (SectorBuffer, GST_FIRST_BIOS_DRIVE, sector, 1);
;|*** 				if (result != BiosResultSuccess)
; Line 1074
	*** 0000fb	56 			push	si
	*** 0000fc	6a 01 			push	1
	*** 0000fe	8d 46 e4 		lea	ax,WORD PTR [bp-28]	;sector
	*** 000101	50 			push	ax
	*** 000102	68 80 00 		push	128	;0080H
	*** 000105	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000108	e8 00 00 		call	?ReadSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; ReadSectors
	*** 00010b	83 c4 0a 		add	sp,10	;000aH
	*** 00010e	0a c0 			or	al,al
	*** 000110	75 28 			jne	SHORT $L1959
;|*** 					goto err;
;|*** 
;|*** 				memcpy (mbrPartTable, SectorBuffer + GST_MAX_MBR_BOOT_CODE_SIZE, sizeof (mbrPartTable));
; Line 1077
	*** 000112	6a 48 			push	72	;0048H
	*** 000114	68 b8 01 		push	OFFSET ?SectorBuffer@@3QAEA+440	;SectorBuffer
	*** 000117	8d 46 9c 		lea	ax,WORD PTR [bp-100]	;mbrPartTable
	*** 00011a	50 			push	ax
	*** 00011b	e8 00 00 		call	_memcpy
	*** 00011e	83 c4 06 		add	sp,6
;|*** 			}
;|*** 
;|*** 			result = ReadSectors (SectorBuffer, BootLoaderDrive, chs, 1);
; Line 1080
					$I1805:
;|*** 			if (result != BiosResultSuccess)
; Line 1081
	*** 000121	6a 00 			push	0
	*** 000123	6a 01 			push	1
	*** 000125	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;chs
	*** 000128	50 			push	ax
	*** 000129	a0 00 00 		mov	al,BYTE PTR ?BootLoaderDrive@@3EA	;BootLoaderDrive
	*** 00012c	50 			push	ax
	*** 00012d	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000130	e8 00 00 		call	?ReadSectors@@YAEPAEEABUChsAddress@@ED@Z	; ReadSectors
	*** 000133	83 c4 0a 		add	sp,10	;000aH
	*** 000136	0a c0 			or	al,al
	*** 000138	74 03 			je	SHORT $L1958
;|*** 				goto err;
;|*** 
;|*** 			if (i == GST_MBR_SECTOR)
; Line 1084
					$L1959:
	*** 00013a	e9 6c ff 		jmp	$L1954
					$L1958:
	*** 00013d	0b f6 			or	si,si
	*** 00013f	75 0f 			jne	SHORT $I1811
;|*** 			{
;|*** 				// Preserve current partition table
;|*** 				memcpy (SectorBuffer + GST_MAX_MBR_BOOT_CODE_SIZE, mbrPartTable, sizeof (mbrPartTable));
; Line 1087
	*** 000141	6a 48 			push	72	;0048H
	*** 000143	8d 46 9c 		lea	ax,WORD PTR [bp-100]	;mbrPartTable
	*** 000146	50 			push	ax
	*** 000147	68 b8 01 		push	OFFSET ?SectorBuffer@@3QAEA+440	;SectorBuffer
	*** 00014a	e8 00 00 		call	_memcpy
	*** 00014d	83 c4 06 		add	sp,6
;|*** 			}
;|*** 
;|*** 			// Volume header
;|*** 			if (i == GST_BOOT_VOLUME_HEADER_SECTOR)
; Line 1091
					$I1811:
	*** 000150	83 fe 3e 		cmp	si,62	;003eH
	*** 000153	0f 85 d5 00 		jne	$I1812
;|*** 			{
;|*** 				if (selection == RestoreGostCryptLoader)
; Line 1093
	*** 000157	83 ff 02 		cmp	di,2
	*** 00015a	0f 84 ff 00 		je	$FC1800
;|*** 					continue;
;|*** 
;|*** 				if (selection == RestoreVolumeHeader)
; Line 1096
	*** 00015e	83 ff 03 		cmp	di,3
	*** 000161	0f 85 c7 00 		jne	$I1812
	*** 000165	89 76 fc 		mov	WORD PTR [bp-4],si	;i
;|*** 				{
;|*** 					while (true)
; Line 1098
					$FC1816:
;|*** 					{
;|*** 						bool validHeaderPresent = false;
; Line 1100
	*** 000168	c6 46 ff 00 		mov	BYTE PTR [bp-1],0	;validHeaderPresent
;|*** 						uint32 masterKeyScheduleCrc;
;|*** 
;|*** 						Password password;
;|*** 						byte exitKey = AskPassword (password);
;|*** 
;|*** 						if (exitKey != GST_BIOS_KEY_ENTER)
; Line 1106
	*** 00016c	8d 86 54 ff 		lea	ax,WORD PTR [bp-172]	;password
	*** 000170	50 			push	ax
	*** 000171	e8 00 00 		call	?AskPassword@@YAEAAUPassword@@@Z	; AskPassword
	*** 000174	5b 			pop	bx
	*** 000175	3c 1c 			cmp	al,28	;001cH
	*** 000177	0f 85 ac fe 		jne	$L1926
;|*** 							goto abort;
;|*** 
;|*** 						CRYPTO_INFO *cryptoInfo;
;|*** 
;|*** 						CopyMemory (SectorBuffer, GST_BOOT_LOADER_BUFFER_SEGMENT, 0, GST_LB_SIZE);
; Line 1111
	*** 00017b	68 00 02 		push	512	;0200H
	*** 00017e	6a 00 			push	0
	*** 000180	68 00 40 		push	16384	;4000H
	*** 000183	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000186	e8 00 00 		call	?CopyMemory@@YAXPAXIII@Z	; CopyMemory
	*** 000189	83 c4 08 		add	sp,8
;|*** 						ReleaseSectorBuffer();
;|*** 
;|*** 						// Restore volume header only if the current one cannot be used
;|*** 						if (OpenVolume (GST_FIRST_BIOS_DRIVE, password, &cryptoInfo, nullptr, false, true))
; Line 1115
	*** 00018c	6a 01 			push	1
	*** 00018e	6a 00 			push	0
	*** 000190	6a 00 			push	0
	*** 000192	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;cryptoInfo
	*** 000195	50 			push	ax
	*** 000196	8d 86 54 ff 		lea	ax,WORD PTR [bp-172]	;password
	*** 00019a	50 			push	ax
	*** 00019b	68 80 00 		push	128	;0080H
	*** 00019e	e8 00 00 		call	?OpenVolume@@YADEAAUPassword@@PAPAUCRYPTO_INFO_t@@PAKDD@Z	; OpenVolume
	*** 0001a1	83 c4 0c 		add	sp,12	;000cH
	*** 0001a4	0a c0 			or	al,al
	*** 0001a6	74 21 			je	SHORT $I1826
;|*** 						{
;|*** 							validHeaderPresent = true;
; Line 1117
	*** 0001a8	c6 46 ff 01 		mov	BYTE PTR [bp-1],1	;validHeaderPresent
;|*** 							masterKeyScheduleCrc = GetCrc32 (cryptoInfo->ks, sizeof (cryptoInfo->ks));
; Line 1118
	*** 0001ac	68 20 02 		push	544	;0220H
	*** 0001af	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;cryptoInfo
	*** 0001b2	05 04 00 		add	ax,4
	*** 0001b5	50 			push	ax
	*** 0001b6	e8 00 00 		call	_GetCrc32
	*** 0001b9	83 c4 04 		add	sp,4
	*** 0001bc	89 46 f4 		mov	WORD PTR [bp-12],ax	;masterKeyScheduleCrc
	*** 0001bf	89 56 f6 		mov	WORD PTR [bp-10],dx	;result
;|*** 							crypto_close (cryptoInfo);
; Line 1119
	*** 0001c2	ff 76 f8 		push	WORD PTR [bp-8]	;cryptoInfo
	*** 0001c5	e8 00 00 		call	_crypto_close
	*** 0001c8	5b 			pop	bx
;|*** 						}
;|*** 
;|*** 						AcquireSectorBuffer();
; Line 1122
					$I1826:
;|*** 						CopyMemory (GST_BOOT_LOADER_BUFFER_SEGMENT, 0, SectorBuffer, GST_LB_SIZE);
; Line 1123
	*** 0001c9	68 00 02 		push	512	;0200H
	*** 0001cc	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 0001cf	6a 00 			push	0
	*** 0001d1	68 00 40 		push	16384	;4000H
	*** 0001d4	e8 00 00 		call	?CopyMemory@@YAXIIPAXI@Z	; CopyMemory
	*** 0001d7	83 c4 08 		add	sp,8
;|*** 
;|*** 						if (ReadVolumeHeader (TRUE, (char *) SectorBuffer, &password, &cryptoInfo, nullptr) == 0)
; Line 1125
	*** 0001da	6a 00 			push	0
	*** 0001dc	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;cryptoInfo
	*** 0001df	50 			push	ax
	*** 0001e0	8d 86 54 ff 		lea	ax,WORD PTR [bp-172]	;password
	*** 0001e4	50 			push	ax
	*** 0001e5	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 0001e8	6a 01 			push	1
	*** 0001ea	e8 00 00 		call	_ReadVolumeHeader
	*** 0001ed	83 c4 0a 		add	sp,10	;000aH
	*** 0001f0	0b c0 			or	ax,ax
	*** 0001f2	74 0a 			je	SHORT $L1929
;|*** 						{
;|*** 							if (validHeaderPresent)
;|*** 							{
;|*** 								if (masterKeyScheduleCrc == GetCrc32 (cryptoInfo->ks, sizeof (cryptoInfo->ks)))
;|*** 								{
;|*** 									Print ("Original header preserved.\r\n");
;|*** 									goto err;
;|*** 								}
;|*** 
;|*** 								Print ("WARNING: Drive 0 contains a valid header!\r\n");
;|*** 							}
;|*** 
;|*** 							crypto_close (cryptoInfo);
;|*** 							break;
;|*** 						}
;|*** 
;|*** 						Print ("Incorrect password.\r\n\r\n");
; Line 1142
	*** 0001f4	68 00 00 		push	OFFSET DGROUP:??_C@_0BI@KFOG@Incorrect?5password?4?$AN?6?$AN?6?$AA@
	*** 0001f7	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 0001fa	5b 			pop	bx
;|*** 					}
; Line 1143
	*** 0001fb	e9 6a ff 		jmp	$FC1816
					$L1929:
;|*** 							if (validHeaderPresent)
; Line 1127
	*** 0001fe	80 7e ff 00 		cmp	BYTE PTR [bp-1],0	;validHeaderPresent
	*** 000202	74 21 			je	SHORT $I1829
;|*** 							{
;|*** 								if (masterKeyScheduleCrc == GetCrc32 (cryptoInfo->ks, sizeof (cryptoInfo->ks)))
; Line 1129
	*** 000204	68 20 02 		push	544	;0220H
	*** 000207	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;cryptoInfo
	*** 00020a	05 04 00 		add	ax,4
	*** 00020d	50 			push	ax
	*** 00020e	e8 00 00 		call	_GetCrc32
	*** 000211	83 c4 04 		add	sp,4
	*** 000214	3b 46 f4 		cmp	ax,WORD PTR [bp-12]	;masterKeyScheduleCrc
	*** 000217	75 05 			jne	SHORT $L1937
	*** 000219	3b 56 f6 		cmp	dx,WORD PTR [bp-10]	;result
	*** 00021c	74 43 			je	SHORT $L1930
					$L1937:
;|*** 								{
;|*** 									Print ("Original header preserved.\r\n");
;|*** 									goto err;
;|*** 								}
;|*** 
;|*** 								Print ("WARNING: Drive 0 contains a valid header!\r\n");
; Line 1135
	*** 00021e	68 00 00 		push	OFFSET DGROUP:??_C@_0CM@CODF@WARNING?3?5Drive?50?5contains?5a?5vali@
	*** 000221	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000224	5b 			pop	bx
;|*** 							}
;|*** 
;|*** 							crypto_close (cryptoInfo);
; Line 1138
					$I1829:
	*** 000225	ff 76 f8 		push	WORD PTR [bp-8]	;cryptoInfo
	*** 000228	e8 00 00 		call	_crypto_close
	*** 00022b	5b 			pop	bx
;|*** 							break;
;|*** 						}
;|*** 
;|*** 						Print ("Incorrect password.\r\n\r\n");
;|*** 					}
;|*** 				}
;|*** 			}
;|*** 
;|*** 			if (!writeConfirmed && !AskYesNo ("Modify drive 0"))
; Line 1147
					$I1812:
	*** 00022c	80 7e fe 00 		cmp	BYTE PTR [bp-2],0	;writeConfirmed
	*** 000230	75 0d 			jne	SHORT $I1834
	*** 000232	68 00 00 		push	OFFSET DGROUP:??_C@_0P@JAC@Modify?5drive?50?$AA@
	*** 000235	e8 00 00 		call	?AskYesNo@@YADPBD@Z	; AskYesNo
	*** 000238	5b 			pop	bx
	*** 000239	0a c0 			or	al,al
	*** 00023b	0f 84 e8 fd 		je	$L1926
;|*** 				goto abort;
;|*** 			writeConfirmed = true;
; Line 1149
					$I1834:
	*** 00023f	c6 46 fe 01 		mov	BYTE PTR [bp-2],1	;writeConfirmed
;|*** 
;|*** 			if (WriteSectors (SectorBuffer, GST_FIRST_BIOS_DRIVE, sector, 1) != BiosResultSuccess)
; Line 1151
	*** 000243	6a 00 			push	0
	*** 000245	6a 01 			push	1
	*** 000247	8d 46 e4 		lea	ax,WORD PTR [bp-28]	;sector
	*** 00024a	50 			push	ax
	*** 00024b	68 80 00 		push	128	;0080H
	*** 00024e	68 00 00 		push	OFFSET ?SectorBuffer@@3QAEA	;SectorBuffer
	*** 000251	e8 00 00 		call	?WriteSectors@@YAEPAEEABTUINT64_STRUCT@@ID@Z	; WriteSectors
	*** 000254	83 c4 0a 		add	sp,10	;000aH
	*** 000257	0a c0 			or	al,al
	*** 000259	0f 85 4c fe 		jne	$L1954
;|*** 			i < GST_BOOT_LOADER_AREA_SECTOR_COUNT; ++i)
; Line 1056
					$FC1800:
	*** 00025d	46 			inc	si
	*** 00025e	e9 53 fe 		jmp	$F1799
					$L1930:
;|*** 		{
;|*** 			sector.LowPart = i;
;|*** 
;|*** 			if (selection == RestoreOriginalSystemLoader)
;|*** 				sector.LowPart += GST_ORIG_BOOT_LOADER_BACKUP_SECTOR;
;|*** 			else if (selection == RestoreGostCryptLoader)
;|*** 				sector.LowPart += GST_BOOT_LOADER_BACKUP_RESCUE_DISK_SECTOR;
;|*** 
;|*** 			// The backup medium may be a floppy-emulated bootable CD. The emulation may fail if LBA addressing is used.
;|*** 			// Therefore, only CHS addressing can be used.
;|*** 			LbaToChs (bootLoaderDriveGeometry, sector, chs);
;|*** 			sector.LowPart = i;
;|*** 
;|*** 			if (i == GST_MBR_SECTOR)
;|*** 			{
;|*** 				// Read current partition table
;|*** 				result = ReadSectors (SectorBuffer, GST_FIRST_BIOS_DRIVE, sector, 1);
;|*** 				if (result != BiosResultSuccess)
;|*** 					goto err;
;|*** 
;|*** 				memcpy (mbrPartTable, SectorBuffer + GST_MAX_MBR_BOOT_CODE_SIZE, sizeof (mbrPartTable));
;|*** 			}
;|*** 
;|*** 			result = ReadSectors (SectorBuffer, BootLoaderDrive, chs, 1);
;|*** 			if (result != BiosResultSuccess)
;|*** 				goto err;
;|*** 
;|*** 			if (i == GST_MBR_SECTOR)
;|*** 			{
;|*** 				// Preserve current partition table
;|*** 				memcpy (SectorBuffer + GST_MAX_MBR_BOOT_CODE_SIZE, mbrPartTable, sizeof (mbrPartTable));
;|*** 			}
;|*** 
;|*** 			// Volume header
;|*** 			if (i == GST_BOOT_VOLUME_HEADER_SECTOR)
;|*** 			{
;|*** 				if (selection == RestoreGostCryptLoader)
;|*** 					continue;
;|*** 
;|*** 				if (selection == RestoreVolumeHeader)
;|*** 				{
;|*** 					while (true)
;|*** 					{
;|*** 						bool validHeaderPresent = false;
;|*** 						uint32 masterKeyScheduleCrc;
;|*** 
;|*** 						Password password;
;|*** 						byte exitKey = AskPassword (password);
;|*** 
;|*** 						if (exitKey != GST_BIOS_KEY_ENTER)
;|*** 							goto abort;
;|*** 
;|*** 						CRYPTO_INFO *cryptoInfo;
;|*** 
;|*** 						CopyMemory (SectorBuffer, GST_BOOT_LOADER_BUFFER_SEGMENT, 0, GST_LB_SIZE);
;|*** 						ReleaseSectorBuffer();
;|*** 
;|*** 						// Restore volume header only if the current one cannot be used
;|*** 						if (OpenVolume (GST_FIRST_BIOS_DRIVE, password, &cryptoInfo, nullptr, false, true))
;|*** 						{
;|*** 							validHeaderPresent = true;
;|*** 							masterKeyScheduleCrc = GetCrc32 (cryptoInfo->ks, sizeof (cryptoInfo->ks));
;|*** 							crypto_close (cryptoInfo);
;|*** 						}
;|*** 
;|*** 						AcquireSectorBuffer();
;|*** 						CopyMemory (GST_BOOT_LOADER_BUFFER_SEGMENT, 0, SectorBuffer, GST_LB_SIZE);
;|*** 
;|*** 						if (ReadVolumeHeader (TRUE, (char *) SectorBuffer, &password, &cryptoInfo, nullptr) == 0)
;|*** 						{
;|*** 							if (validHeaderPresent)
;|*** 							{
;|*** 								if (masterKeyScheduleCrc == GetCrc32 (cryptoInfo->ks, sizeof (cryptoInfo->ks)))
;|*** 								{
;|*** 									Print ("Original header preserved.\r\n");
; Line 1131
	*** 000261	68 00 00 		push	OFFSET DGROUP:??_C@_0BN@MGAM@Original?5header?5preserved?4?$AN?6?$AA@
	*** 000264	e9 3e fe 		jmp	$L1956
;|*** 									goto err;
;|*** 								}
;|*** 
;|*** 								Print ("WARNING: Drive 0 contains a valid header!\r\n");
;|*** 							}
;|*** 
;|*** 							crypto_close (cryptoInfo);
;|*** 							break;
;|*** 						}
;|*** 
;|*** 						Print ("Incorrect password.\r\n\r\n");
;|*** 					}
;|*** 				}
;|*** 			}
;|*** 
;|*** 			if (!writeConfirmed && !AskYesNo ("Modify drive 0"))
;|*** 				goto abort;
;|*** 			writeConfirmed = true;
;|*** 
;|*** 			if (WriteSectors (SectorBuffer, GST_FIRST_BIOS_DRIVE, sector, 1) != BiosResultSuccess)
;|*** 				goto err;
;|*** 		}
;|*** done:
; Line 1154
					$done1839:
;|*** 		switch (selection)
; Line 1155
	*** 000267	8b c7 			mov	ax,di
;|*** 		{
;|*** 		case RestoreGostCryptLoader:
;|*** 			Print ("GostCrypt Boot Loader");
;|*** 			break;
;|*** 
;|*** 		case RestoreVolumeHeader:
;|*** 			Print ("Header");
;|*** 			break;
;|*** 
;|*** 		case RestoreOriginalSystemLoader:
;|*** 			Print ("System loader");
;|*** 			break;
;|*** 		}
; Line 1168
	*** 000269	48 			dec	ax
	*** 00026a	48 			dec	ax
	*** 00026b	74 08 			je	SHORT $SC1844
	*** 00026d	48 			dec	ax
	*** 00026e	74 0a 			je	SHORT $SC1846
	*** 000270	48 			dec	ax
	*** 000271	74 0c 			je	SHORT $SC1848
	*** 000273	eb 11 			jmp	SHORT $SB1841
;|*** 		case RestoreGostCryptLoader:
; Line 1157
					$SC1844:
;|*** 			Print ("GostCrypt Boot Loader");
; Line 1158
	*** 000275	68 00 00 		push	OFFSET DGROUP:??_C@_0BG@JPHD@GostCrypt?5Boot?5Loader?$AA@
	*** 000278	eb 08 			jmp	SHORT $L1957
;|*** 			break;
;|*** 
;|*** 		case RestoreVolumeHeader:
; Line 1161
					$SC1846:
;|*** 			Print ("Header");
; Line 1162
	*** 00027a	68 00 00 		push	OFFSET DGROUP:??_C@_06IEHP@Header?$AA@
	*** 00027d	eb 03 			jmp	SHORT $L1957
;|*** 			break;
;|*** 
;|*** 		case RestoreOriginalSystemLoader:
; Line 1165
					$SC1848:
;|*** 			Print ("System loader");
; Line 1166
	*** 00027f	68 00 00 		push	OFFSET DGROUP:??_C@_0O@MJLK@System?5loader?$AA@
					$L1957:
	*** 000282	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 000285	5b 			pop	bx
;|*** 			break;
;|*** 		}
; Line 1168
					$SB1841:
;|*** 		Print (" restored.\r\n");
; Line 1169
	*** 000286	68 00 00 		push	OFFSET DGROUP:??_C@_0N@HIBI@?5restored?4?$AN?6?$AA@
	*** 000289	e9 19 fe 		jmp	$L1956
;|*** 
;|*** err:	GetKeyboardChar();
;|*** abort:	ReleaseSectorBuffer();
;|*** 	}
;|*** }
; Line 1174
					$EX1762:
	*** 00028c	5e 			pop	si
	*** 00028d	5f 			pop	di
	*** 00028e	c9 			leave	
	*** 00028f	c3 			ret	

?RepairMenu@@YAXXZ	ENDP
	PUBLIC	__acrtused
__acrtused	PROC NEAR	;  COMDAT
;|*** 
;|*** #endif // GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 
;|*** #ifndef DEBUG
;|*** /**
;|***  *
;|***  *	\fn extern "C" void _acrtused ()
;|***  *	\brief Required by linker
;|***  *	\return void
;|***  *
;|***  */
;|*** extern "C" void _acrtused () { }  // Required by linker
; Line 1187
	*** 000000	c3 			ret	

__acrtused	ENDP
	PUBLIC	_main
_main	PROC NEAR	;  COMDAT
;|*** #endif
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void main ()
;|***  *	\brief Initialize video mode and screen, determine boot drive and its geometry and print the main menu
;|***  *	\return void
;|***  *
;|***  */
;|*** void main ()
;|*** {
; Line 1198
	*** 000000	c8 02 00 00 		enter	2,0
;|*** 	__asm mov BootLoaderDrive, dl
; Line 1199
	*** 000004	88 16 00 00 		mov	BYTE PTR ?BootLoaderDrive@@3EA,dl	;BootLoaderDrive
;|*** 	__asm mov BootSectorFlags, dh
; Line 1200
	*** 000008	88 36 00 00 		mov	BYTE PTR ?BootSectorFlags@@3EA,dh	;BootSectorFlags
;|*** 
;|*** #ifdef GST_BOOT_TRACING_ENABLED
;|*** 	InitDebugPort();
;|*** #endif
;|*** 
;|*** #ifdef GST_BOOT_STACK_CHECKING_ENABLED
;|*** 	InitStackChecker();
;|*** #endif
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 	ReadBootSectorUserConfiguration();
;|*** #endif
;|*** 
;|*** 	InitVideoMode();
; Line 1214
	*** 00000c	e8 00 00 		call	?InitVideoMode@@YAXXZ	; InitVideoMode
;|*** 	InitScreen();
; Line 1215
	*** 00000f	e8 00 00 		call	?InitScreen@@YAXXZ	; InitScreen
;|*** 
;|*** 	// Determine boot drive
;|*** 	BootDrive = BootLoaderDrive;
;|*** 	if (BootDrive < GST_FIRST_BIOS_DRIVE)
; Line 1219
	*** 000012	a0 00 00 		mov	al,BYTE PTR ?BootLoaderDrive@@3EA	;BootLoaderDrive
	*** 000015	a2 00 00 		mov	BYTE PTR ?BootDrive@@3EA,al	;BootDrive
	*** 000018	3c 80 			cmp	al,128	;0080H
	*** 00001a	73 05 			jae	SHORT $I1857
;|*** 		BootDrive = GST_FIRST_BIOS_DRIVE;
; Line 1220
	*** 00001c	c6 06 00 00 80 		mov	BYTE PTR ?BootDrive@@3EA,128	;0080H	;BootDrive
;|*** 
;|*** 	// Query boot drive geometry
;|*** 	if (GetDriveGeometry (BootDrive, BootDriveGeometry) != BiosResultSuccess)
; Line 1223
					$I1857:
	*** 000021	6a 00 			push	0
	*** 000023	68 00 00 		push	OFFSET ?BootDriveGeometry@@3UDriveGeometry@@A	;BootDriveGeometry
	*** 000026	a0 00 00 		mov	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 000029	50 			push	ax
	*** 00002a	e8 00 00 		call	?GetDriveGeometry@@YAEEAAUDriveGeometry@@D@Z	; GetDriveGeometry
	*** 00002d	83 c4 06 		add	sp,6
	*** 000030	0a c0 			or	al,al
	*** 000032	74 21 			je	SHORT $I1858
;|*** 	{
;|*** 		BootDrive = GST_FIRST_BIOS_DRIVE;
;|*** 		if (GetDriveGeometry (BootDrive, BootDriveGeometry) != BiosResultSuccess)
; Line 1226
	*** 000034	6a 00 			push	0
	*** 000036	68 00 00 		push	OFFSET ?BootDriveGeometry@@3UDriveGeometry@@A	;BootDriveGeometry
	*** 000039	b0 80 			mov	al,128	;0080H
	*** 00003b	a2 00 00 		mov	BYTE PTR ?BootDrive@@3EA,al	;BootDrive
	*** 00003e	50 			push	ax
	*** 00003f	e8 00 00 		call	?GetDriveGeometry@@YAEEAAUDriveGeometry@@D@Z	; GetDriveGeometry
	*** 000042	83 c4 06 		add	sp,6
	*** 000045	0a c0 			or	al,al
	*** 000047	74 0c 			je	SHORT $I1858
;|*** 		{
;|*** #ifdef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 			Print ("- Connect system drive to (SATA) port 1\r\n");
; Line 1229
	*** 000049	68 00 00 		push	OFFSET DGROUP:??_C@_0CK@MNCE@?9?5Connect?5system?5drive?5to?5?$CISATA?$CJ@
	*** 00004c	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 00004f	5b 			pop	bx
;|*** #endif
;|*** 			GetKeyboardChar();
; Line 1231
	*** 000050	e8 00 00 		call	?GetKeyboardChar@@YAEXZ	; GetKeyboardChar
;|*** 		}
;|*** 		else
; Line 1233
	*** 000053	eb 05 			jmp	SHORT $I1862
					$I1858:
;|*** 			BootDriveGeometryValid = true;
;|*** 	}
;|*** 	else
;|*** 		BootDriveGeometryValid = true;
; Line 1237
	*** 000055	c6 06 00 00 01 		mov	BYTE PTR ?BootDriveGeometryValid@@3DA,1	;BootDriveGeometryValid
					$I1862:
;|*** 
;|*** #ifdef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 	// Check whether the user is not using the Rescue Disk to create a hidden system
;|*** 
;|*** 	if (ReadWriteMBR (false, BootDrive, true) == BiosResultSuccess
;|*** 		&& *(uint32 *) (SectorBuffer + 6) == 0x65757254
;|*** 		&& *(uint32 *) (SectorBuffer + 10) == 0x70797243
;|*** 		&& (SectorBuffer[GST_BOOT_SECTOR_CONFIG_OFFSET] & GST_BOOT_CFG_MASK_HIDDEN_OS_CREATION_PHASE) != GST_HIDDEN_OS_CREATION_PHASE_NONE)
; Line 1246
	*** 00005a	6a 01 			push	1
	*** 00005c	a0 00 00 		mov	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 00005f	50 			push	ax
	*** 000060	6a 00 			push	0
	*** 000062	e8 00 00 		call	?ReadWriteMBR@@YAEDED@Z	; ReadWriteMBR
	*** 000065	83 c4 06 		add	sp,6
	*** 000068	0a c0 			or	al,al
	*** 00006a	75 3b 			jne	SHORT $L1960
	*** 00006c	66 81 3e 06 00 54 72 75 65 cmp	DWORD PTR ?SectorBuffer@@3QAEA+6,1702195796	;65757254H	;SectorBuffer
	*** 000075	75 30 			jne	SHORT $L1960
	*** 000077	66 81 3e 0a 00 43 72 79 70 cmp	DWORD PTR ?SectorBuffer@@3QAEA+10,1887007299	;70797243H	;SectorBuffer
	*** 000080	75 25 			jne	SHORT $L1960
	*** 000082	f6 06 b7 01 c0 		test	BYTE PTR ?SectorBuffer@@3QAEA+439,192	;00c0H	;SectorBuffer
	*** 000087	74 1e 			je	SHORT $L1960
;|*** 	{
;|*** 		PrintError ("It appears you are creating a hidden OS.");
; Line 1248
	*** 000089	68 00 00 		push	OFFSET DGROUP:??_C@_0CJ@BABO@It?5appears?5you?5are?5creating?5a?5hi@
	*** 00008c	e8 00 00 		call	?PrintError@@YAXPBD@Z	; PrintError
	*** 00008f	5b 			pop	bx
;|*** 		if (AskYesNo ("Is this correct"))
; Line 1249
	*** 000090	68 00 00 		push	OFFSET DGROUP:??_C@_0BA@LKAJ@Is?5this?5correct?$AA@
	*** 000093	e8 00 00 		call	?AskYesNo@@YADPBD@Z	; AskYesNo
	*** 000096	5b 			pop	bx
	*** 000097	0a c0 			or	al,al
	*** 000099	74 0c 			je	SHORT $L1960
;|*** 		{
;|*** 			Print ("Please remove the Rescue Disk from the drive and restart.");
; Line 1251
	*** 00009b	68 00 00 		push	OFFSET DGROUP:??_C@_0DK@PFGO@Please?5remove?5the?5Rescue?5Disk?5fr@
	*** 00009e	e8 00 00 		call	?Print@@YAXPBD@Z	; Print
	*** 0000a1	5b 			pop	bx
;|*** 			while (true);
; Line 1252
					$FC1871:
	*** 0000a2	eb fe 			jmp	SHORT $FC1871
					$FC1874:
;|*** 		}
;|*** 	}
;|*** 
;|*** #endif // GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 
;|*** 	// Main menu
;|*** 
;|*** 	while (true)
;|*** 	{
; Line 1262
;	exitKey = -2
;|*** 		byte exitKey;
;|*** 		InitScreen();
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 		// Hidden system setup
;|*** 		byte hiddenSystemCreationPhase = BootSectorFlags & GST_BOOT_CFG_MASK_HIDDEN_OS_CREATION_PHASE;
;|*** 
;|*** 		if (hiddenSystemCreationPhase != GST_HIDDEN_OS_CREATION_PHASE_NONE)
;|*** 		{
;|*** 			PreventNormalSystemBoot = true;
;|*** 			PrintMainMenu();
;|*** 
;|*** 			if (hiddenSystemCreationPhase == GST_HIDDEN_OS_CREATION_PHASE_CLONING)
;|*** 			{
;|*** 				if (CopySystemPartitionToHiddenVolume (BootDrive, exitKey))
;|*** 				{
;|*** 					BootSectorFlags = (BootSectorFlags & ~GST_BOOT_CFG_MASK_HIDDEN_OS_CREATION_PHASE) | GST_HIDDEN_OS_CREATION_PHASE_WIPING;
;|*** 					UpdateBootSectorConfiguration (BootLoaderDrive);
;|*** 				}
;|*** 				else if (exitKey == GST_BIOS_KEY_ESC)
;|*** 					goto bootMenu;
;|*** 				else
;|*** 					continue;
;|*** 			}
;|*** 		}
;|*** 		else
;|*** 			PrintMainMenu();
;|*** 
;|*** 		exitKey = BootEncryptedDrive();
;|*** 
;|*** #else // GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 		
;|*** 		PrintMainMenu();
;|*** 		exitKey = BootEncryptedDrive();
;|*** 
;|*** 		if (exitKey == GST_MENU_KEY_REPAIR)
;|*** 		{
;|*** 			RepairMenu();
; Line 1301
	*** 0000a4	e8 00 00 		call	?RepairMenu@@YAXXZ	; RepairMenu
;|*** 			continue;
; Line 1302
					$L1960:
	*** 0000a7	e8 00 00 		call	?InitScreen@@YAXXZ	; InitScreen
;|*** 		PrintMainMenu();
; Line 1296
	*** 0000aa	e8 00 00 		call	?PrintMainMenu@@YAXXZ	; PrintMainMenu
;|*** 		exitKey = BootEncryptedDrive();
;|*** 
;|*** 		if (exitKey == GST_MENU_KEY_REPAIR)
; Line 1299
	*** 0000ad	e8 00 00 		call	?BootEncryptedDrive@@YAEXZ	; BootEncryptedDrive
	*** 0000b0	3c 42 			cmp	al,66	;0042H
	*** 0000b2	74 f0 			je	SHORT $FC1874
;|*** 		{
;|*** 			RepairMenu();
;|*** 			continue;
;|*** 		}
;|*** 
;|*** #endif // GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** bootMenu:
;|*** 		if (!PreventBootMenu)
; Line 1308
	*** 0000b4	80 3e 00 00 00 		cmp	BYTE PTR ?PreventBootMenu@@3DA,0	;PreventBootMenu
	*** 0000b9	75 ec 			jne	SHORT $L1960
;|*** 			BootMenu();
; Line 1309
	*** 0000bb	e8 00 00 		call	?BootMenu@@YAXXZ	; BootMenu
;|*** 	}
; Line 1310
	*** 0000be	eb e7 			jmp	SHORT $L1960

_main	ENDP
_TEXT	ENDS
END
;|*** }
