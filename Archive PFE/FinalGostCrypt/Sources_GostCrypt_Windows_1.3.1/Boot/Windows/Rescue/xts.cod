;	Static Name Aliases
;
	TITLE   ..\..\..\common\xts.c
	.MODEL  SMALL
	.386p
	.387
_TEXT	SEGMENT  WORD USE16 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT  WORD USE16 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD USE16 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD USE16 PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
EXTRN	_ThrowFatalException:NEAR
EXTRN	_CipherGetKeyScheduleSize:NEAR
EXTRN	_memcpy:NEAR
EXTRN	_XorKeySchedule:NEAR
EXTRN	_EncipherBlock:NEAR
EXTRN	_DecipherBlock:NEAR
_TEXT      SEGMENT
	ASSUME	CS: _TEXT

Uint64ToLE16ByteArray	PROC NEAR	;  COMDAT
;|*** /**
;|***  *
;|***  *	\file Xts.c
;|***  *	\brief Manage the XTS encryption which consists of switching bytes in blocks before encrypting them.
;|***  *			It covers 32 and 64 bytes platforms. there are optimized function for parallel and non parallel.
;|***  *	\version 1.3.1
;|***  *	\date 23/01/2017
;|***  *
;|***  */
;|*** 
;|*** /**
;|***  *
;|***  *	Copyright (c) 2008-2010 TrueCrypt Developers Association. All rights reserved.
;|***  *	
;|***  *	Governed by the TrueCrypt License 3.0 the full text of which is contained in
;|***  *	the file License.txt included in TrueCrypt binary and source code distribution
;|***  *	packages.
;|***  *
;|***  */
;|*** 
;|*** /* If native 64-bit data types are not available, define GST_NO_COMPILER_INT64. 
;|*** 
;|*** For big-endian platforms define BYTE_ORDER as BIG_ENDIAN. */
;|*** 
;|*** 
;|*** #ifdef GST_MINIMIZE_CODE_SIZE
;|*** //	Preboot/boot version
;|*** #	ifndef GST_NO_COMPILER_INT64
;|*** #		define GST_NO_COMPILER_INT64
;|*** #	endif
;|*** #	pragma optimize ("tl", on)
;|*** #endif
;|*** 
;|*** #ifdef GST_NO_COMPILER_INT64
;|*** #	include <memory.h>
;|*** #endif
;|*** 
;|*** #include "Xts.h"
;|*** 
;|*** #ifndef GST_NO_COMPILER_INT64
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void EncryptBufferXTS (unsigned __int8 *buffer, GST_LARGEST_COMPILER_UINT length, const UINT64_STRUCT *startDataUnitNo, unsigned int startCipherBlockNo, unsigned __int8 *ks, unsigned __int8 *ks2, int cipher)
;|***  *	\brief length: number of bytes to encrypt; may be larger than one data unit and must be divisible by the cipher block size
;|***  *			ks: the primary key schedule
;|***  *			ks2: the secondary key schedule
;|***  *			startDataUnitNo: The sequential number of the data unit with which the buffer starts.
;|***  *			startCipherBlockNo: The sequential number of the first plaintext block to encrypt inside the data unit startDataUnitNo.
;|***  *								When encrypting the data unit from its first block, startCipherBlockNo is 0. 
;|***  *								The startCipherBlockNo value applies only to the first data unit in the buffer; each successive
;|***  *								data unit is encrypted from its first block. The start of the buffer does not have to be
;|***  *								aligned with the start of a data unit. If it is aligned, startCipherBlockNo must be 0; if it
;|***  *								is not aligned, startCipherBlockNo must reflect the misalignment accordingly.
;|***  *	\param[in] unsigned __int8 * buffer
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT length
;|***  *	\param[in] const UINT64_STRUCT * startDataUnitNo
;|***  *	\param[in] unsigned int startCipherBlockNo
;|***  *	\param[in] unsigned __int8 * ks
;|***  *	\param[in] unsigned __int8 * ks2
;|***  *	\param[in] int cipher
;|***  *	\return void
;|***  *
;|***  */
;|*** void EncryptBufferXTS (unsigned __int8 *buffer,
;|*** 					   GST_LARGEST_COMPILER_UINT length,
;|*** 					   const UINT64_STRUCT *startDataUnitNo,
;|*** 					   unsigned int startCipherBlockNo,
;|*** 					   unsigned __int8 *ks,
;|*** 					   unsigned __int8 *ks2,
;|*** 					   int cipher)
;|*** {
;|*** 	if (CipherSupportsIntraDataUnitParallelization (cipher))
;|*** 		EncryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);
;|*** 	else
;|*** 		EncryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void EncryptBufferXTS8Byte(unsigned __int8 *buffer, GST_LARGEST_COMPILER_UINT length, const UINT64_STRUCT *startDataUnitNo, unsigned int startCipherBlockNo, unsigned __int8 *ks, unsigned __int8 *ks2, int cipher)
;|***  *	\brief The goal is to switch some byte of a encrypted data with the next encrypted data.
;|***  *			This doesn't hurt the algorithm security and add a switching parameter to the encryption.
;|***  *			On a 32-byte data it switches data with another block of data Then encrypt it.
;|***  *	\param[in] unsigned __int8 * buffer
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT length
;|***  *	\param[in] const UINT64_STRUCT * startDataUnitNo
;|***  *	\param[in] unsigned int startCipherBlockNo
;|***  *	\param[in] unsigned __int8 * ks
;|***  *	\param[in] unsigned __int8 * ks2
;|***  *	\param[in] int cipher
;|***  *	\return void
;|***  *
;|***  */
;|*** void EncryptBufferXTS8Byte(unsigned __int8 *buffer,
;|*** 						GST_LARGEST_COMPILER_UINT length,
;|*** 						const UINT64_STRUCT *startDataUnitNo,
;|*** 						unsigned int startCipherBlockNo,
;|*** 						unsigned __int8 *ks,
;|*** 						unsigned __int8 *ks2,
;|*** 						int cipher)
;|*** {
;|*** 	unsigned __int8 finalCarry;
;|*** 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK_SMALL];
;|*** 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK_SMALL];
;|*** 	unsigned __int32 *whiteningValuePtr32 = (unsigned __int32 *)whiteningValue;
;|*** 	unsigned __int32 *bufPtr = (unsigned __int32 *)buffer;
;|*** 	unsigned __int32 startBlock = startCipherBlockNo, endBlock, block;
;|*** 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
;|*** 	unsigned __int8 xor_ks[MAX_EXPANDED_KEY];
;|*** 
;|*** 	dataUnitNo = startDataUnitNo->Value;
;|*** 	*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64(dataUnitNo);
;|*** 
;|*** 	if (length % BYTES_PER_XTS_BLOCK_SMALL)
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 
;|*** 	blockCount = length / BYTES_PER_XTS_BLOCK_SMALL;
;|*** 
;|*** 	memcpy(xor_ks, ks, CipherGetKeyScheduleSize(cipher));
;|*** 
;|*** 	while (blockCount > 0)
;|*** 	{
;|*** 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT_SMALL)
;|*** 			endBlock = startBlock + (unsigned __int32) blockCount;
;|*** 		else
;|*** 			endBlock = BLOCKS_PER_XTS_DATA_UNIT_SMALL;
;|*** 
;|*** 		whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
;|*** 
;|*** 		//Generate first whitening value
;|*** 		*whiteningValuePtr32 = *((unsigned __int32 *) byteBufUnitNo);
;|*** 		*(whiteningValuePtr32+1) = *((unsigned __int32 *) byteBufUnitNo+1);
;|*** 		EncipherBlock (cipher, whiteningValue, ks2);
;|*** 
;|*** 		//XOR ks with the current DataUnitNo
;|*** 		XorKeySchedule(cipher, ks, xor_ks, byteBufUnitNo, 8);
;|*** 
;|*** 		//Generate subsequent whitening values for blocks
;|*** 		for (block = 0; block < endBlock; block++)
;|*** 		{
;|*** 			if (block >= startBlock)
;|*** 			{
;|*** 				//Pre-whitening
;|*** 				*bufPtr++ ^= *whiteningValuePtr32++;
;|*** 				*bufPtr-- ^= *whiteningValuePtr32--;
;|*** 
;|*** 				//Actual encryption
;|*** 				EncipherBlock(cipher, bufPtr, xor_ks);
;|*** 
;|*** 				//Post-whitening
;|*** 				*bufPtr++ ^= *whiteningValuePtr32++;
;|*** 				*bufPtr++ ^= *whiteningValuePtr32;
;|*** 			}
;|*** 			else
;|*** 				whiteningValuePtr32++;
;|*** 
;|*** 			//Derive the next whitening value
;|*** #if BYTE_ORDER == LITTLE_ENDIAN
;|*** 
;|*** 			//Little-endian platforms
;|*** 			finalCarry = (*whiteningValuePtr32 & 0x80000000) ? 27 : 0;
;|*** 
;|*** 			*whiteningValuePtr32-- <<= 1;
;|*** 
;|*** 			if (*whiteningValuePtr32 & 0x80000000)
;|*** 				*(whiteningValuePtr32 + 1) |= 1;
;|*** 
;|*** 			*whiteningValuePtr32 <<= 1;
;|*** #else
;|*** 			//Big-endian platforms
;|*** 			finalCarry = (*whiteningValuePtr32 & 0x80) ? 27 : 0;
;|*** 
;|*** 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
;|*** 
;|*** 			whiteningValuePtr32--;
;|*** 
;|*** 			if (*whiteningValuePtr32 & 0x80)
;|*** 				*(whiteningValuePtr32 + 1) |= 0x01000000;
;|*** 
;|*** 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
;|*** #endif
;|*** 			whiteningValue[0] ^= finalCarry;
;|*** 		}
;|*** 		blockCount -= endBlock - startBlock;
;|*** 		startBlock = 0;
;|*** 		dataUnitNo++;
;|*** 		*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);
;|*** 	}
;|*** 	FAST_ERASE32(whiteningValue, sizeof(whiteningValue));
;|*** }
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void EncryptBufferXTSParallel (unsigned __int8 *buffer, GST_LARGEST_COMPILER_UINT length, const UINT64_STRUCT *startDataUnitNo, unsigned int startCipherBlockNo, unsigned __int8 *ks, unsigned __int8 *ks2, int cipher)
;|***  *	\brief Optimized for encryption algorithms supporting intra-data-unit parallelization.
;|***  *			Encrypt data and add a switching parameter when encrypting.
;|***  *			On a 64-byte data it switches a 16bytes data with another block of data Then encrypt it.
;|***  *	\param[in] unsigned __int8 * buffer
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT length
;|***  *	\param[in] const UINT64_STRUCT * startDataUnitNo
;|***  *	\param[in] unsigned int startCipherBlockNo
;|***  *	\param[in] unsigned __int8 * ks
;|***  *	\param[in] unsigned __int8 * ks2
;|***  *	\param[in] int cipher
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void EncryptBufferXTSParallel (unsigned __int8 *buffer,
;|*** 					   GST_LARGEST_COMPILER_UINT length,
;|*** 					   const UINT64_STRUCT *startDataUnitNo,
;|*** 					   unsigned int startCipherBlockNo,
;|*** 					   unsigned __int8 *ks,
;|*** 					   unsigned __int8 *ks2,
;|*** 					   int cipher)
;|*** {
;|*** 	unsigned __int8 finalCarry;
;|*** 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
;|*** 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;
;|*** 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
;|*** 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
;|*** 	unsigned __int64 *dataUnitBufPtr;
;|*** 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
;|*** 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;
;|*** 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
;|*** 
;|*** 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
;|*** 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
;|*** 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
;|*** 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
;|*** 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
;|*** 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
;|*** 
;|*** 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
;|*** 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
;|*** 	dataUnitNo = startDataUnitNo->Value;
;|*** 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
;|*** 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
;|*** 
;|*** 	if (length % BYTES_PER_XTS_BLOCK)
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 
;|*** 	blockCount = length / BYTES_PER_XTS_BLOCK;
;|*** 
;|*** 	// Process all blocks in the buffer
;|*** 	while (blockCount > 0)
;|*** 	{
;|*** 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
;|*** 			endBlock = startBlock + (unsigned int) blockCount;
;|*** 		else
;|*** 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;
;|*** 
;|*** 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
;|*** 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
;|*** 
;|*** 		// Encrypt the data unit number using the secondary key (in order to generate the first 
;|*** 		// whitening value for this data unit)
;|*** 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);
;|*** 		*(whiteningValuePtr64 + 1) = 0;
;|*** 		EncipherBlock (cipher, whiteningValue, ks2);
;|*** 
;|*** 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
;|*** 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
;|*** 		for (block = 0; block < endBlock; block++)
;|*** 		{
;|*** 			if (block >= startBlock)
;|*** 			{
;|*** 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;
;|*** 				*whiteningValuesPtr64-- = *whiteningValuePtr64;
;|*** 			}
;|*** 			else
;|*** 				whiteningValuePtr64++;
;|*** 
;|*** 			// Derive the next whitening value
;|*** 
;|*** #if BYTE_ORDER == LITTLE_ENDIAN
;|*** 
;|*** 			// Little-endian platforms
;|*** 
;|*** 			finalCarry = 
;|*** 				(*whiteningValuePtr64 & 0x8000000000000000) ?
;|*** 				135 : 0;
;|*** 
;|*** 			*whiteningValuePtr64-- <<= 1;
;|*** 
;|*** 			if (*whiteningValuePtr64 & 0x8000000000000000)
;|*** 				*(whiteningValuePtr64 + 1) |= 1;	
;|*** 
;|*** 			*whiteningValuePtr64 <<= 1;
;|*** #else
;|*** 
;|*** 			// Big-endian platforms
;|*** 
;|*** 			finalCarry = 
;|*** 				(*whiteningValuePtr64 & 0x80) ?
;|*** 				135 : 0;
;|*** 
;|*** 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
;|*** 
;|*** 			whiteningValuePtr64--;
;|*** 
;|*** 			if (*whiteningValuePtr64 & 0x80)
;|*** 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
;|*** 
;|*** 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
;|*** #endif
;|*** 
;|*** 			whiteningValue[0] ^= finalCarry;
;|*** 		}
;|*** 
;|*** 		dataUnitBufPtr = bufPtr;
;|*** 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
;|*** 
;|*** 		// Encrypt all blocks in this data unit
;|*** 
;|*** 		for (block = startBlock; block < endBlock; block++)
;|*** 		{
;|*** 			// Pre-whitening
;|*** 			*bufPtr++ ^= *whiteningValuesPtr64--;
;|*** 			*bufPtr++ ^= *whiteningValuesPtr64--;
;|*** 		}
;|*** 
;|*** 		// Actual encryption
;|*** 		EncipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);
;|*** 		
;|*** 		bufPtr = dataUnitBufPtr;
;|*** 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
;|*** 
;|*** 		for (block = startBlock; block < endBlock; block++)
;|*** 		{
;|*** 			// Post-whitening
;|*** 			*bufPtr++ ^= *whiteningValuesPtr64--;
;|*** 			*bufPtr++ ^= *whiteningValuesPtr64--;
;|*** 		}
;|*** 
;|*** 		blockCount -= endBlock - startBlock;
;|*** 		startBlock = 0;
;|*** 		dataUnitNo++;
;|*** 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
;|*** 	}
;|*** 
;|*** 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));
;|*** 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));
;|*** }
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void EncryptBufferXTSNonParallel (unsigned __int8 *buffer, GST_LARGEST_COMPILER_UINT length, const UINT64_STRUCT *startDataUnitNo, unsigned int startCipherBlockNo, unsigned __int8 *ks, unsigned __int8 *ks2, int cipher)
;|***  *	\brief Optimized for encryption algorithms not supporting intra-data-unit parallelization.
;|***  *			Encrypt data and add a switching parameter when encrypting.
;|***  *			On a 64-byte data it switches a 16bytes data with another block of data Then encrypt it.
;|***  *	\param[in] unsigned __int8 * buffer
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT length
;|***  *	\param[in] const UINT64_STRUCT * startDataUnitNo
;|***  *	\param[in] unsigned int startCipherBlockNo
;|***  *	\param[in] unsigned __int8 * ks
;|***  *	\param[in] unsigned __int8 * ks2
;|***  *	\param[in] int cipher
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void EncryptBufferXTSNonParallel (unsigned __int8 *buffer,
;|*** 					   GST_LARGEST_COMPILER_UINT length,
;|*** 					   const UINT64_STRUCT *startDataUnitNo,
;|*** 					   unsigned int startCipherBlockNo,
;|*** 					   unsigned __int8 *ks,
;|*** 					   unsigned __int8 *ks2,
;|*** 					   int cipher)
;|*** {
;|*** 	unsigned __int8 finalCarry;
;|*** 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
;|*** 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
;|*** 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
;|*** 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
;|*** 
;|*** 	/* The encrypted data unit number (i.e. the resultant ciphertext block) is to be multiplied in the
;|*** 	finite field GF(2^128) by j-th power of n, where j is the sequential plaintext/ciphertext block
;|*** 	number and n is 2, a primitive element of GF(2^128). This can be (and is) simplified and implemented
;|*** 	as a left shift of the preceding whitening value by one bit (with carry propagating). In addition, if
;|*** 	the shift of the highest byte results in a carry, 135 is XORed into the lowest byte. The value 135 is
;|*** 	derived from the modulus of the Galois Field (x^128+x^7+x^2+x+1). */
;|*** 
;|*** 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
;|*** 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
;|*** 	dataUnitNo = startDataUnitNo->Value;
;|*** 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
;|*** 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
;|*** 
;|*** 	if (length % BYTES_PER_XTS_BLOCK)
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 
;|*** 	blockCount = length / BYTES_PER_XTS_BLOCK;
;|*** 
;|*** 	// Process all blocks in the buffer
;|*** 	while (blockCount > 0)
;|*** 	{
;|*** 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
;|*** 			endBlock = startBlock + (unsigned int) blockCount;
;|*** 		else
;|*** 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;
;|*** 
;|*** 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
;|*** 
;|*** 		// Encrypt the data unit number using the secondary key (in order to generate the first 
;|*** 		// whitening value for this data unit)
;|*** 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);
;|*** 		*(whiteningValuePtr64 + 1) = 0;
;|*** 		EncipherBlock (cipher, whiteningValue, ks2);
;|*** 
;|*** 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
;|*** 		// encrypt all relevant blocks in this data unit
;|*** 		for (block = 0; block < endBlock; block++)
;|*** 		{
;|*** 			if (block >= startBlock)
;|*** 			{
;|*** 				// Pre-whitening
;|*** 				*bufPtr++ ^= *whiteningValuePtr64++;
;|*** 				*bufPtr-- ^= *whiteningValuePtr64--;
;|*** 
;|*** 				// Actual encryption
;|*** 				EncipherBlock (cipher, bufPtr, ks);
;|*** 
;|*** 				// Post-whitening
;|*** 				*bufPtr++ ^= *whiteningValuePtr64++;
;|*** 				*bufPtr++ ^= *whiteningValuePtr64;
;|*** 			}
;|*** 			else
;|*** 				whiteningValuePtr64++;
;|*** 
;|*** 			// Derive the next whitening value
;|*** 
;|*** #if BYTE_ORDER == LITTLE_ENDIAN
;|*** 
;|*** 			// Little-endian platforms
;|*** 
;|*** 			finalCarry = 
;|*** 				(*whiteningValuePtr64 & 0x8000000000000000) ?
;|*** 				135 : 0;
;|*** 
;|*** 			*whiteningValuePtr64-- <<= 1;
;|*** 
;|*** 			if (*whiteningValuePtr64 & 0x8000000000000000)
;|*** 				*(whiteningValuePtr64 + 1) |= 1;	
;|*** 
;|*** 			*whiteningValuePtr64 <<= 1;
;|*** #else
;|*** 
;|*** 			// Big-endian platforms
;|*** 
;|*** 			finalCarry = 
;|*** 				(*whiteningValuePtr64 & 0x80) ?
;|*** 				135 : 0;
;|*** 
;|*** 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
;|*** 
;|*** 			whiteningValuePtr64--;
;|*** 
;|*** 			if (*whiteningValuePtr64 & 0x80)
;|*** 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
;|*** 
;|*** 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
;|*** #endif
;|*** 
;|*** 			whiteningValue[0] ^= finalCarry;
;|*** 		}
;|*** 
;|*** 		blockCount -= endBlock - startBlock;
;|*** 		startBlock = 0;
;|*** 		dataUnitNo++;
;|*** 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
;|*** 	}
;|*** 
;|*** 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));
;|*** }
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void DecryptBufferXTS (unsigned __int8 *buffer, GST_LARGEST_COMPILER_UINT length, const UINT64_STRUCT *startDataUnitNo, unsigned int startCipherBlockNo, unsigned __int8 *ks, unsigned __int8 *ks2, int cipher)
;|***  *	\brief For descriptions of the input parameters, see EncryptBufferXTS(). Decrypt before switching back the data
;|***  *	\param[in] unsigned __int8 * buffer
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT length
;|***  *	\param[in] const UINT64_STRUCT * startDataUnitNo
;|***  *	\param[in] unsigned int startCipherBlockNo
;|***  *	\param[in] unsigned __int8 * ks
;|***  *	\param[in] unsigned __int8 * ks2
;|***  *	\param[in] int cipher
;|***  *	\return void
;|***  *
;|***  */
;|*** void DecryptBufferXTS (unsigned __int8 *buffer,
;|*** 					   GST_LARGEST_COMPILER_UINT length,
;|*** 					   const UINT64_STRUCT *startDataUnitNo,
;|*** 					   unsigned int startCipherBlockNo,
;|*** 					   unsigned __int8 *ks,
;|*** 					   unsigned __int8 *ks2,
;|*** 					   int cipher)
;|*** {
;|*** 	if (CipherSupportsIntraDataUnitParallelization (cipher))
;|*** 		DecryptBufferXTSParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);
;|*** 	else
;|*** 		DecryptBufferXTSNonParallel (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher);
;|*** }
;|*** 
;|*** void DecryptBufferXTS8Byte (unsigned __int8 *buffer,
;|*** 					GST_LARGEST_COMPILER_UINT length,
;|*** 					const UINT64_STRUCT *startDataUnitNo,
;|*** 					unsigned int startCipherBlockNo,
;|*** 					unsigned __int8 *ks,
;|*** 					unsigned __int8 *ks2,
;|*** 					int cipher)
;|*** {
;|*** 	unsigned __int8 finalCarry;
;|*** 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK_SMALL];
;|*** 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK_SMALL];
;|*** 	unsigned __int32 *whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
;|*** 	unsigned __int32 *bufPtr = (unsigned __int32 *) buffer;
;|*** 	unsigned __int32 startBlock = startCipherBlockNo, endBlock, block;
;|*** 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
;|*** 	unsigned __int8 xor_ks[MAX_EXPANDED_KEY];
;|*** 
;|*** 	dataUnitNo = startDataUnitNo->Value;
;|*** 	*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);
;|*** 
;|*** 	if (length % BYTES_PER_XTS_BLOCK_SMALL)
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 
;|*** 	blockCount = length / BYTES_PER_XTS_BLOCK_SMALL;
;|*** 
;|*** 	memcpy(xor_ks, ks, CipherGetKeyScheduleSize(cipher));
;|*** 
;|*** 	while (blockCount > 0)
;|*** 	{
;|*** 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT_SMALL)
;|*** 			endBlock = startBlock + (unsigned __int32) blockCount;
;|*** 		else
;|*** 			endBlock = BLOCKS_PER_XTS_DATA_UNIT_SMALL;
;|*** 
;|*** 		whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
;|*** 
;|*** 		//Encrypt data unit using the second key to generate the first whitening value
;|*** 		*whiteningValuePtr32 = *((unsigned __int32 *) byteBufUnitNo);
;|*** 		*(whiteningValuePtr32+1) = *((unsigned __int32 *) byteBufUnitNo+1);
;|*** 		EncipherBlock (cipher, whiteningValue, ks2);
;|*** 
;|*** 		//XOR ks with the current DataUnitNo
;|*** 		XorKeySchedule(cipher, ks, xor_ks, byteBufUnitNo, 8);
;|*** 
;|*** 		for (block = 0; block < endBlock; block++)
;|*** 		{
;|*** 			if (block >= startBlock)
;|*** 			{
;|*** 				//Post-whitening
;|*** 				*bufPtr++ ^= *whiteningValuePtr32++;
;|*** 				*bufPtr-- ^= *whiteningValuePtr32--;
;|*** 
;|*** 				//Actual decryption
;|*** 				DecipherBlock (cipher, bufPtr, xor_ks);
;|*** 
;|*** 				//Pre-whitening
;|*** 				*bufPtr++ ^= *whiteningValuePtr32++;
;|*** 				*bufPtr++ ^= *whiteningValuePtr32;
;|*** 			}
;|*** 			else
;|*** 				whiteningValuePtr32++;
;|*** 
;|*** 			//Derive the next whitening value
;|*** 
;|*** #if BYTE_ORDER == LITTLE_ENDIAN
;|*** 
;|*** 			//Little-endian platforms
;|*** 
;|*** 			finalCarry = (*whiteningValuePtr32 & 0x80000000) ? 27 : 0;
;|*** 
;|*** 			*whiteningValuePtr32-- <<= 1;
;|*** 
;|*** 			if (*whiteningValuePtr32 & 0x80000000)
;|*** 				*(whiteningValuePtr32 + 1) |= 1;
;|*** 
;|*** 			*whiteningValuePtr32 <<= 1;
;|*** #else
;|*** 			//Big-endian platforms
;|*** 			finalCarry = (*whiteningValuePtr32 & 0x80) ? 27 : 0;
;|*** 
;|*** 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
;|*** 
;|*** 			whiteningValuePtr32--;
;|*** 
;|*** 			if (*whiteningValuePtr32 & 0x80)
;|*** 				*(whiteningValuePtr32 + 1) |= 0x1000000;
;|*** 
;|*** 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
;|*** #endif
;|*** 
;|*** 			whiteningValue[0] ^= finalCarry;
;|*** 		}
;|*** 
;|*** 		blockCount -= endBlock - startBlock;
;|*** 		startBlock = 0;
;|*** 		dataUnitNo++;
;|*** 		*((unsigned __int64 *) byteBufUnitNo) = (unsigned __int64) LE64 (dataUnitNo);
;|*** 	}
;|*** 
;|*** 	FAST_ERASE32 (whiteningValue, sizeof (whiteningValue));
;|*** }
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void DecryptBufferXTSParallel (unsigned __int8 *buffer, GST_LARGEST_COMPILER_UINT length, const UINT64_STRUCT *startDataUnitNo, unsigned int startCipherBlockNo, unsigned __int8 *ks, unsigned __int8 *ks2, int cipher)
;|***  *	\brief Optimized for encryption algorithms supporting intra-data-unit parallelization. For descriptions of the input parameters, see EncryptBufferXTS(). Decrypt before switching back the data
;|***  *	\param[in] unsigned __int8 * buffer
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT length
;|***  *	\param[in] const UINT64_STRUCT * startDataUnitNo
;|***  *	\param[in] unsigned int startCipherBlockNo
;|***  *	\param[in] unsigned __int8 * ks
;|***  *	\param[in] unsigned __int8 * ks2
;|***  *	\param[in] int cipher
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void DecryptBufferXTSParallel (unsigned __int8 *buffer,
;|*** 					   GST_LARGEST_COMPILER_UINT length,
;|*** 					   const UINT64_STRUCT *startDataUnitNo,
;|*** 					   unsigned int startCipherBlockNo,
;|*** 					   unsigned __int8 *ks,
;|*** 					   unsigned __int8 *ks2,
;|*** 					   int cipher)
;|*** {
;|*** 	unsigned __int8 finalCarry;
;|*** 	unsigned __int8 whiteningValues [ENCRYPTION_DATA_UNIT_SIZE];
;|*** 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int64 *whiteningValuesPtr64 = (unsigned __int64 *) whiteningValues;
;|*** 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
;|*** 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
;|*** 	unsigned __int64 *dataUnitBufPtr;
;|*** 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
;|*** 	unsigned __int64 *const finalInt64WhiteningValuesPtr = whiteningValuesPtr64 + sizeof (whiteningValues) / sizeof (*whiteningValuesPtr64) - 1;
;|*** 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
;|*** 
;|*** 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
;|*** 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
;|*** 	dataUnitNo = startDataUnitNo->Value;
;|*** 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
;|*** 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
;|*** 
;|*** 	if (length % BYTES_PER_XTS_BLOCK)
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 
;|*** 	blockCount = length / BYTES_PER_XTS_BLOCK;
;|*** 
;|*** 	// Process all blocks in the buffer
;|*** 	while (blockCount > 0)
;|*** 	{
;|*** 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
;|*** 			endBlock = startBlock + (unsigned int) blockCount;
;|*** 		else
;|*** 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;
;|*** 
;|*** 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
;|*** 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
;|*** 
;|*** 		// Encrypt the data unit number using the secondary key (in order to generate the first 
;|*** 		// whitening value for this data unit)
;|*** 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);
;|*** 		*(whiteningValuePtr64 + 1) = 0;
;|*** 		EncipherBlock (cipher, whiteningValue, ks2);
;|*** 
;|*** 		// Generate subsequent whitening values for blocks in this data unit. Note that all generated 128-bit
;|*** 		// whitening values are stored in memory as a sequence of 64-bit integers in reverse order.
;|*** 		for (block = 0; block < endBlock; block++)
;|*** 		{
;|*** 			if (block >= startBlock)
;|*** 			{
;|*** 				*whiteningValuesPtr64-- = *whiteningValuePtr64++;
;|*** 				*whiteningValuesPtr64-- = *whiteningValuePtr64;
;|*** 			}
;|*** 			else
;|*** 				whiteningValuePtr64++;
;|*** 
;|*** 			// Derive the next whitening value
;|*** 
;|*** #if BYTE_ORDER == LITTLE_ENDIAN
;|*** 
;|*** 			// Little-endian platforms
;|*** 
;|*** 			finalCarry = 
;|*** 				(*whiteningValuePtr64 & 0x8000000000000000) ?
;|*** 				135 : 0;
;|*** 
;|*** 			*whiteningValuePtr64-- <<= 1;
;|*** 
;|*** 			if (*whiteningValuePtr64 & 0x8000000000000000)
;|*** 				*(whiteningValuePtr64 + 1) |= 1;	
;|*** 
;|*** 			*whiteningValuePtr64 <<= 1;
;|*** 
;|*** #else
;|*** 			// Big-endian platforms
;|*** 
;|*** 			finalCarry = 
;|*** 				(*whiteningValuePtr64 & 0x80) ?
;|*** 				135 : 0;
;|*** 
;|*** 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
;|*** 
;|*** 			whiteningValuePtr64--;
;|*** 
;|*** 			if (*whiteningValuePtr64 & 0x80)
;|*** 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
;|*** 
;|*** 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
;|*** #endif
;|*** 
;|*** 			whiteningValue[0] ^= finalCarry;
;|*** 		}
;|*** 
;|*** 		dataUnitBufPtr = bufPtr;
;|*** 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
;|*** 
;|*** 		// Decrypt blocks in this data unit
;|*** 
;|*** 		for (block = startBlock; block < endBlock; block++)
;|*** 		{
;|*** 			*bufPtr++ ^= *whiteningValuesPtr64--;
;|*** 			*bufPtr++ ^= *whiteningValuesPtr64--;
;|*** 		}
;|*** 
;|*** 		DecipherBlocks (cipher, dataUnitBufPtr, ks, endBlock - startBlock);
;|*** 
;|*** 		bufPtr = dataUnitBufPtr;
;|*** 		whiteningValuesPtr64 = finalInt64WhiteningValuesPtr;
;|*** 
;|*** 		for (block = startBlock; block < endBlock; block++)
;|*** 		{
;|*** 			*bufPtr++ ^= *whiteningValuesPtr64--;
;|*** 			*bufPtr++ ^= *whiteningValuesPtr64--;
;|*** 		}
;|*** 
;|*** 		blockCount -= endBlock - startBlock;
;|*** 		startBlock = 0;
;|*** 		dataUnitNo++;
;|*** 
;|*** 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
;|*** 	}
;|*** 
;|*** 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));
;|*** 	FAST_ERASE64 (whiteningValues, sizeof (whiteningValues));
;|*** }
;|*** 
;|*** 
;|*** // Optimized for encryption algorithms not supporting intra-data-unit parallelization
;|*** /**
;|***  *
;|***  *	\fn void DecryptBufferXTSNonParallel (unsigned __int8 *buffer, GST_LARGEST_COMPILER_UINT length, const UINT64_STRUCT *startDataUnitNo, unsigned int startCipherBlockNo, unsigned __int8 *ks, unsigned __int8 *ks2, int cipher)
;|***  *	\brief Optimized for encryption algorithms not supporting intra-data-unit parallelization. For descriptions of the input parameters, see EncryptBufferXTS(). Decrypt before switching back the data
;|***  *	\param[in] unsigned __int8 * buffer
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT length
;|***  *	\param[in] const UINT64_STRUCT * startDataUnitNo
;|***  *	\param[in] unsigned int startCipherBlockNo
;|***  *	\param[in] unsigned __int8 * ks
;|***  *	\param[in] unsigned __int8 * ks2
;|***  *	\param[in] int cipher
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void DecryptBufferXTSNonParallel (unsigned __int8 *buffer,
;|*** 					   GST_LARGEST_COMPILER_UINT length,
;|*** 					   const UINT64_STRUCT *startDataUnitNo,
;|*** 					   unsigned int startCipherBlockNo,
;|*** 					   unsigned __int8 *ks,
;|*** 					   unsigned __int8 *ks2,
;|*** 					   int cipher)
;|*** {
;|*** 	unsigned __int8 finalCarry;
;|*** 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int64 *whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
;|*** 	unsigned __int64 *bufPtr = (unsigned __int64 *) buffer;
;|*** 	unsigned int startBlock = startCipherBlockNo, endBlock, block;
;|*** 	GST_LARGEST_COMPILER_UINT blockCount, dataUnitNo;
;|*** 
;|*** 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
;|*** 	// Note that as we are converting a 64-bit number into a 16-byte array we can always zero the last 8 bytes.
;|*** 	dataUnitNo = startDataUnitNo->Value;
;|*** 	*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
;|*** 	*((unsigned __int64 *) byteBufUnitNo + 1) = 0;
;|*** 
;|*** 	if (length % BYTES_PER_XTS_BLOCK)
;|*** 		GST_THROW_FATAL_EXCEPTION;
;|*** 
;|*** 	blockCount = length / BYTES_PER_XTS_BLOCK;
;|*** 
;|*** 	// Process all blocks in the buffer
;|*** 	while (blockCount > 0)
;|*** 	{
;|*** 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
;|*** 			endBlock = startBlock + (unsigned int) blockCount;
;|*** 		else
;|*** 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;
;|*** 
;|*** 		whiteningValuePtr64 = (unsigned __int64 *) whiteningValue;
;|*** 
;|*** 		// Encrypt the data unit number using the secondary key (in order to generate the first 
;|*** 		// whitening value for this data unit)
;|*** 		*whiteningValuePtr64 = *((unsigned __int64 *) byteBufUnitNo);
;|*** 		*(whiteningValuePtr64 + 1) = 0;
;|*** 		EncipherBlock (cipher, whiteningValue, ks2);
;|*** 
;|*** 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
;|*** 		// decrypt all relevant blocks in this data unit
;|*** 		for (block = 0; block < endBlock; block++)
;|*** 		{
;|*** 			if (block >= startBlock)
;|*** 			{
;|*** 				// Post-whitening
;|*** 				*bufPtr++ ^= *whiteningValuePtr64++;
;|*** 				*bufPtr-- ^= *whiteningValuePtr64--;
;|*** 
;|*** 				// Actual decryption
;|*** 				DecipherBlock (cipher, bufPtr, ks);
;|*** 
;|*** 				// Pre-whitening
;|*** 				*bufPtr++ ^= *whiteningValuePtr64++;
;|*** 				*bufPtr++ ^= *whiteningValuePtr64;
;|*** 			}
;|*** 			else
;|*** 				whiteningValuePtr64++;
;|*** 
;|*** 			// Derive the next whitening value
;|*** 
;|*** #if BYTE_ORDER == LITTLE_ENDIAN
;|*** 
;|*** 			// Little-endian platforms
;|*** 
;|*** 			finalCarry = 
;|*** 				(*whiteningValuePtr64 & 0x8000000000000000) ?
;|*** 				135 : 0;
;|*** 
;|*** 			*whiteningValuePtr64-- <<= 1;
;|*** 
;|*** 			if (*whiteningValuePtr64 & 0x8000000000000000)
;|*** 				*(whiteningValuePtr64 + 1) |= 1;	
;|*** 
;|*** 			*whiteningValuePtr64 <<= 1;
;|*** 
;|*** #else
;|*** 			// Big-endian platforms
;|*** 
;|*** 			finalCarry = 
;|*** 				(*whiteningValuePtr64 & 0x80) ?
;|*** 				135 : 0;
;|*** 
;|*** 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
;|*** 
;|*** 			whiteningValuePtr64--;
;|*** 
;|*** 			if (*whiteningValuePtr64 & 0x80)
;|*** 				*(whiteningValuePtr64 + 1) |= 0x0100000000000000;	
;|*** 
;|*** 			*whiteningValuePtr64 = LE64 (LE64 (*whiteningValuePtr64) << 1);
;|*** #endif
;|*** 
;|*** 			whiteningValue[0] ^= finalCarry;
;|*** 		}
;|*** 
;|*** 		blockCount -= endBlock - startBlock;
;|*** 		startBlock = 0;
;|*** 		dataUnitNo++;
;|*** 		*((unsigned __int64 *) byteBufUnitNo) = LE64 (dataUnitNo);
;|*** 	}
;|*** 
;|*** 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));
;|*** }
;|*** 
;|*** 
;|*** #else	// GST_NO_COMPILER_INT64
;|*** 
;|*** /* ---- The following code is to be used only when native 64-bit data types are not available. ---- */
;|*** 
;|*** #if BYTE_ORDER == BIG_ENDIAN
;|*** #error The GST_NO_COMPILER_INT64 version of the XTS code is not compatible with big-endian platforms
;|*** #endif 
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void Uint64ToLE16ByteArray (unsigned __int8 *byteBuf, unsigned __int32 highInt32, unsigned __int32 lowInt32)
;|***  *	\brief When there is no 64 bytes types are not available. Build it with two 32 bytes data.
;|***  *			Converts a 64-bit unsigned integer (passed as two 32-bit integers for compatibility with non-64-bit environments/platforms) into a little-endian 16-byte array.
;|***  *	\param[in] unsigned __int32 lowInt32
;|***  *	\param[in] unsigned __int32 * highInt32
;|***  *	\param[in] unsigned __int8 * byteBuf
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void Uint64ToLE16ByteArray (unsigned __int8 *byteBuf, unsigned __int32 highInt32, unsigned __int32 lowInt32)
;|*** {
; Line 904
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	byteBuf = 4
;	highInt32 = 6
;	lowInt32 = 10
;	bufPtr32 = -2
	*** 000003	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;byteBuf
;|*** 	unsigned __int32 *bufPtr32 = (unsigned __int32 *) byteBuf;
;|*** 
;|*** 	*bufPtr32++ = lowInt32;
; Line 907
	*** 000006	66 8b 46 0a 		mov	eax,DWORD PTR [bp+10]	;lowInt32
	*** 00000a	66 89 07 		mov	DWORD PTR [bx],eax
;|*** 	*bufPtr32++ = highInt32;
; Line 908
	*** 00000d	66 8b 46 06 		mov	eax,DWORD PTR [bp+6]	;highInt32
	*** 000011	66 89 47 04 		mov	DWORD PTR [bx+4],eax
;|*** 
;|*** 	// We're converting a 64-bit number into a little-endian 16-byte array so we can zero the last 8 bytes
;|*** 	*bufPtr32++ = 0;
; Line 911
	*** 000015	83 c3 04 		add	bx,4
	*** 000018	66 2b c0 		sub	eax,eax
	*** 00001b	66 89 47 04 		mov	DWORD PTR [bx+4],eax
;|*** 	*bufPtr32 = 0;
; Line 912
	*** 00001f	83 c3 04 		add	bx,4
	*** 000022	89 47 06 		mov	WORD PTR [bx+6],ax
	*** 000025	89 47 04 		mov	WORD PTR [bx+4],ax
;|*** }
; Line 913
	*** 000028	c9 			leave	
	*** 000029	c3 			ret	

Uint64ToLE16ByteArray	ENDP

EncryptDecryptBufferXTS32	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void EncryptDecryptBufferXTS32 (const unsigned __int8 *buffer, GST_LARGEST_COMPILER_UINT length, const UINT64_STRUCT *startDataUnitNo, unsigned int startBlock, unsigned __int8 *ks, unsigned __int8 *ks2, int cipher, BOOL decryption)
;|***  *	\brief Encrypts or decrypts all blocks in the buffer in XTS mode. For descriptions of the input parameters,
;|***  *		   see the 64-bit version of EncryptBufferXTS().
;|***  *	\param[in] const unsigned __int8 * buffer
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT length
;|***  *	\param[in] const UINT64_STRUCT * startDataUnitNo
;|***  *	\param[in] unsigned int startBlock
;|***  *	\param[in] unsigned __int8 * ks
;|***  *	\param[in] unsigned __int8 * ks2
;|***  *	\param[in] int cipher
;|***  *	\param[in] BOOL decryption
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void EncryptDecryptBufferXTS32 (const unsigned __int8 *buffer,
;|*** 							GST_LARGEST_COMPILER_UINT length,
;|*** 							const UINT64_STRUCT *startDataUnitNo,
;|*** 							unsigned int startBlock,
;|*** 							unsigned __int8 *ks,
;|*** 							unsigned __int8 *ks2,
;|*** 							int cipher,
;|*** 							BOOL decryption)
;|*** {
; Line 941
	*** 000000	c8 36 00 00 		enter	54,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	startBlock = 12
;	ks = 14
;	ks2 = 16
;	cipher = 18
;	decryption = 20
;	blockCount = -8
;	dataUnitNo = -22
;	block = -10
;	endBlock = -12
;	byteBufUnitNo = -54
;	whiteningValue = -38
;	bufPtr32 = -14
;	whiteningValuePtr32 = -2
;	finalCarry = -3
;	finalDwordWhiteningValuePtr = -2
;	burnm = -2
;	register bx = burnc
;	buffer = 4
;	length = 6
;	startDataUnitNo = 10
;|*** 	GST_LARGEST_COMPILER_UINT blockCount;
;|*** 	UINT64_STRUCT dataUnitNo;
;|*** 	unsigned int block;
;|*** 	unsigned int endBlock;
;|*** 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK];
;|*** 	unsigned __int32 *bufPtr32 = (unsigned __int32 *) buffer;
; Line 948
	*** 000006	8b 46 04 		mov	ax,WORD PTR [bp+4]	;buffer
	*** 000009	89 46 f2 		mov	WORD PTR [bp-14],ax	;bufPtr32
;|*** 	unsigned __int32 *whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
;|*** 	unsigned __int8 finalCarry;
;|*** 	unsigned __int32 *const finalDwordWhiteningValuePtr = whiteningValuePtr32 + sizeof (whiteningValue) / sizeof (*whiteningValuePtr32) - 1;
; Line 951
	*** 00000c	8d 46 e6 		lea	ax,WORD PTR [bp-26]
	*** 00000f	89 46 fe 		mov	WORD PTR [bp-2],ax	;whiteningValuePtr32
;|*** 
;|*** 	// Store the 64-bit data unit number in a way compatible with non-64-bit environments/platforms
;|*** 	dataUnitNo.HighPart = startDataUnitNo->HighPart;
; Line 954
	*** 000012	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;startDataUnitNo
	*** 000015	66 8b 47 04 		mov	eax,DWORD PTR [bx+4]
	*** 000019	66 89 46 ee 		mov	DWORD PTR [bp-18],eax
;|*** 	dataUnitNo.LowPart = startDataUnitNo->LowPart;
; Line 955
	*** 00001d	66 8b 07 		mov	eax,DWORD PTR [bx]
	*** 000020	66 89 46 ea 		mov	DWORD PTR [bp-22],eax	;dataUnitNo
;|*** 
;|*** 	blockCount = length / BYTES_PER_XTS_BLOCK;
; Line 957
	*** 000024	66 8b 46 06 		mov	eax,DWORD PTR [bp+6]	;length
	*** 000028	66 c1 e8 04 		shr	eax,4
	*** 00002c	66 89 46 f8 		mov	DWORD PTR [bp-8],eax	;blockCount
;|*** 
;|*** 	// Convert the 64-bit data unit number into a little-endian 16-byte array. 
;|*** 	// (Passed as two 32-bit integers for compatibility with non-64-bit environments/platforms.)
;|*** 	Uint64ToLE16ByteArray (byteBufUnitNo, dataUnitNo.HighPart, dataUnitNo.LowPart);
; Line 961
	*** 000030	66 ff 76 ea 		push	DWORD PTR [bp-22]	;dataUnitNo
	*** 000034	66 ff 76 ee 		push	DWORD PTR [bp-18]
	*** 000038	8d 4e ca 		lea	cx,WORD PTR [bp-54]	;byteBufUnitNo
	*** 00003b	51 			push	cx
	*** 00003c	e8 00 00 		call	Uint64ToLE16ByteArray
	*** 00003f	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|*** 	// Generate whitening values for all blocks in the buffer
;|*** 	while (blockCount > 0)
; Line 964
	*** 000042	66 83 7e f8 00 		cmp	DWORD PTR [bp-8],0	;blockCount
	*** 000047	0f 84 6f 01 		je	$D743
					$L889:
	*** 00004b	8b 7e 0c 		mov	di,WORD PTR [bp+12]	;startBlock
					$FC726:
;|*** 	{
;|*** 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT)
;|*** 			endBlock = startBlock + (unsigned int) blockCount;
;|*** 		else
;|*** 			endBlock = BLOCKS_PER_XTS_DATA_UNIT;
;|*** 
;|*** 		// Encrypt the data unit number using the secondary key (in order to generate the first 
;|*** 		// whitening value for this data unit)
;|*** 		memcpy (whiteningValue, byteBufUnitNo, BYTES_PER_XTS_BLOCK);
; Line 973
	*** 00004e	6a 10 			push	16	;0010H
	*** 000050	8d 46 ca 		lea	ax,WORD PTR [bp-54]	;byteBufUnitNo
	*** 000053	50 			push	ax
	*** 000054	8d 46 da 		lea	ax,WORD PTR [bp-38]	;whiteningValue
	*** 000057	50 			push	ax
	*** 000058	e8 00 00 		call	_memcpy
	*** 00005b	83 c4 06 		add	sp,6
;|*** 		EncipherBlock (cipher, whiteningValue, ks2);
; Line 974
	*** 00005e	ff 76 10 		push	WORD PTR [bp+16]	;ks2
	*** 000061	8d 46 da 		lea	ax,WORD PTR [bp-38]	;whiteningValue
	*** 000064	50 			push	ax
	*** 000065	ff 76 12 		push	WORD PTR [bp+18]	;cipher
	*** 000068	e8 00 00 		call	_EncipherBlock
	*** 00006b	83 c4 06 		add	sp,6
;|*** 
;|*** 		// Generate (and apply) subsequent whitening values for blocks in this data unit and
;|*** 		// encrypt/decrypt all relevant blocks in this data unit
;|*** 		for (block = 0; block < endBlock; block++)
; Line 978
	*** 00006e	c7 46 f6 00 00 		mov	WORD PTR [bp-10],0	;block
	*** 000073	66 83 7e f8 20 		cmp	DWORD PTR [bp-8],32	;00000020H	;blockCount
	*** 000078	73 08 			jae	SHORT $I728
	*** 00007a	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;blockCount
	*** 00007d	03 c7 			add	ax,di
	*** 00007f	eb 04 			jmp	SHORT $I729
	*** 000081	90 			nop	
					$I728:
	*** 000082	b8 20 00 		mov	ax,32	;0020H
					$I729:
	*** 000085	89 46 f4 		mov	WORD PTR [bp-12],ax	;endBlock
	*** 000088	0b c0 			or	ax,ax
	*** 00008a	0f 84 eb 00 		je	$FB732
	*** 00008e	89 7e 0c 		mov	WORD PTR [bp+12],di	;startBlock
					$F730:
;|*** 		{
;|*** 			if (block >= startBlock)
; Line 980
	*** 000091	8b 46 0c 		mov	ax,WORD PTR [bp+12]	;startBlock
	*** 000094	39 46 f6 		cmp	WORD PTR [bp-10],ax	;block
	*** 000097	0f 82 90 00 		jb	$I733
	*** 00009b	8b 7e f2 		mov	di,WORD PTR [bp-14]	;bufPtr32
;|*** 			{
;|*** 				whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
;|*** 
;|*** 				// Whitening
;|*** 				*bufPtr32++ ^= *whiteningValuePtr32++;
; Line 985
	*** 00009e	66 8b 46 da 		mov	eax,DWORD PTR [bp-38]	;whiteningValue
	*** 0000a2	66 31 05 		xor	DWORD PTR [di],eax
;|*** 				*bufPtr32++ ^= *whiteningValuePtr32++;
; Line 986
	*** 0000a5	8b 46 de 		mov	ax,WORD PTR [bp-34]
	*** 0000a8	83 c7 04 		add	di,4
	*** 0000ab	8b 56 e0 		mov	dx,WORD PTR [bp-32]
	*** 0000ae	31 05 			xor	WORD PTR [di],ax
	*** 0000b0	31 55 02 		xor	WORD PTR [di+2],dx
;|*** 				*bufPtr32++ ^= *whiteningValuePtr32++;
; Line 987
	*** 0000b3	8b 46 e2 		mov	ax,WORD PTR [bp-30]
	*** 0000b6	83 c7 04 		add	di,4
	*** 0000b9	8b 56 e4 		mov	dx,WORD PTR [bp-28]
	*** 0000bc	31 05 			xor	WORD PTR [di],ax
	*** 0000be	31 55 02 		xor	WORD PTR [di+2],dx
;|*** 				*bufPtr32 ^= *whiteningValuePtr32;
; Line 988
	*** 0000c1	8b 46 e6 		mov	ax,WORD PTR [bp-26]
	*** 0000c4	83 c7 04 		add	di,4
	*** 0000c7	8b 56 e8 		mov	dx,WORD PTR [bp-24]
	*** 0000ca	31 05 			xor	WORD PTR [di],ax
	*** 0000cc	31 55 02 		xor	WORD PTR [di+2],dx
;|*** 
;|*** 				bufPtr32 -= BYTES_PER_XTS_BLOCK / sizeof (*bufPtr32) - 1;
; Line 990
	*** 0000cf	83 c7 f4 		add	di,-12	;fff4H
;|*** 
;|*** 				// Actual encryption/decryption
;|*** 				if (decryption)
; Line 993
	*** 0000d2	80 7e 14 00 		cmp	BYTE PTR [bp+20],0	;decryption
	*** 0000d6	74 0e 			je	SHORT $I734
	*** 0000d8	8b 76 0e 		mov	si,WORD PTR [bp+14]	;ks
;|*** 					DecipherBlock (cipher, bufPtr32, ks);
; Line 994
	*** 0000db	56 			push	si
	*** 0000dc	57 			push	di
	*** 0000dd	ff 76 12 		push	WORD PTR [bp+18]	;cipher
	*** 0000e0	e8 00 00 		call	_DecipherBlock
	*** 0000e3	eb 0c 			jmp	SHORT $L922
	*** 0000e5	90 			nop	
					$I734:
	*** 0000e6	8b 76 0e 		mov	si,WORD PTR [bp+14]	;ks
;|*** 				else
;|*** 					EncipherBlock (cipher, bufPtr32, ks);
; Line 996
	*** 0000e9	56 			push	si
	*** 0000ea	57 			push	di
	*** 0000eb	ff 76 12 		push	WORD PTR [bp+18]	;cipher
	*** 0000ee	e8 00 00 		call	_EncipherBlock
					$L922:
	*** 0000f1	83 c4 06 		add	sp,6
;|*** 
;|*** 				whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
;|*** 
;|*** 				// Whitening
;|*** 				*bufPtr32++ ^= *whiteningValuePtr32++;
; Line 1001
	*** 0000f4	66 8b 46 da 		mov	eax,DWORD PTR [bp-38]	;whiteningValue
	*** 0000f8	66 31 05 		xor	DWORD PTR [di],eax
;|*** 				*bufPtr32++ ^= *whiteningValuePtr32++;
; Line 1002
	*** 0000fb	8b 46 de 		mov	ax,WORD PTR [bp-34]
	*** 0000fe	83 c7 04 		add	di,4
	*** 000101	8b 56 e0 		mov	dx,WORD PTR [bp-32]
	*** 000104	31 05 			xor	WORD PTR [di],ax
	*** 000106	31 55 02 		xor	WORD PTR [di+2],dx
;|*** 				*bufPtr32++ ^= *whiteningValuePtr32++;
; Line 1003
	*** 000109	8b 46 e2 		mov	ax,WORD PTR [bp-30]
	*** 00010c	83 c7 04 		add	di,4
	*** 00010f	8b 56 e4 		mov	dx,WORD PTR [bp-28]
	*** 000112	31 05 			xor	WORD PTR [di],ax
	*** 000114	31 55 02 		xor	WORD PTR [di+2],dx
;|*** 				*bufPtr32++ ^= *whiteningValuePtr32;
; Line 1004
	*** 000117	8b 46 e6 		mov	ax,WORD PTR [bp-26]
	*** 00011a	83 c7 04 		add	di,4
	*** 00011d	8b 56 e8 		mov	dx,WORD PTR [bp-24]
	*** 000120	31 05 			xor	WORD PTR [di],ax
	*** 000122	31 55 02 		xor	WORD PTR [di+2],dx
	*** 000125	83 c7 04 		add	di,4
	*** 000128	89 7e f2 		mov	WORD PTR [bp-14],di	;bufPtr32
;|*** 			}
;|*** 
;|*** 			// Derive the next whitening value
;|*** 
;|*** 			finalCarry = 0;
; Line 1009
					$I733:
	*** 00012b	c6 46 fd 00 		mov	BYTE PTR [bp-3],0	;finalCarry
;|*** 
;|*** 			for (whiteningValuePtr32 = finalDwordWhiteningValuePtr;
;|*** 				whiteningValuePtr32 >= (unsigned __int32 *) whiteningValue;
;|*** 				whiteningValuePtr32--)
; Line 1013
	*** 00012f	8d 56 e6 		lea	dx,WORD PTR [bp-26]
	*** 000132	89 56 fe 		mov	WORD PTR [bp-2],dx	;whiteningValuePtr32
	*** 000135	8b f2 			mov	si,dx
					$F736:
;|*** 			{
;|*** 				if (*whiteningValuePtr32 & 0x80000000)	// If the following shift results in a carry
; Line 1015
	*** 000137	f7 44 02 00 80 		test	WORD PTR [si+2],-32768	;8000H
	*** 00013c	74 12 			je	SHORT $I739
;|*** 				{
;|*** 					if (whiteningValuePtr32 != finalDwordWhiteningValuePtr)	// If not processing the highest double word
; Line 1017
	*** 00013e	8d 46 e6 		lea	ax,WORD PTR [bp-26]
	*** 000141	3b f0 			cmp	si,ax
	*** 000143	74 07 			je	SHORT $I740
;|*** 					{
;|*** 						// A regular carry
;|*** 						*(whiteningValuePtr32 + 1) |= 1;
; Line 1020
	*** 000145	80 4c 04 01 		or	BYTE PTR [si+4],1
;|*** 					}
;|*** 					else 
; Line 1022
	*** 000149	eb 05 			jmp	SHORT $I739
	*** 00014b	90 			nop	
					$I740:
;|*** 					{
;|*** 						// The highest byte shift will result in a carry
;|*** 						finalCarry = 135;
; Line 1025
	*** 00014c	c6 46 fd 87 		mov	BYTE PTR [bp-3],135	;0087H	;finalCarry
;|*** 					}
;|*** 				}
;|*** 
;|*** 				*whiteningValuePtr32 <<= 1;
; Line 1029
					$I739:
	*** 000150	66 8b 04 		mov	eax,DWORD PTR [si]
	*** 000153	66 03 c0 		add	eax,eax
	*** 000156	66 89 04 		mov	DWORD PTR [si],eax
	*** 000159	83 ee 04 		sub	si,4
	*** 00015c	8d 46 da 		lea	ax,WORD PTR [bp-38]	;whiteningValue
	*** 00015f	3b f0 			cmp	si,ax
	*** 000161	73 d4 			jae	SHORT $F736
;|*** 			}
;|*** 
;|*** 			whiteningValue[0] ^= finalCarry;
; Line 1032
	*** 000163	8a 46 fd 		mov	al,BYTE PTR [bp-3]	;finalCarry
	*** 000166	30 46 da 		xor	BYTE PTR [bp-38],al	;whiteningValue
	*** 000169	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;endBlock
	*** 00016c	ff 46 f6 		inc	WORD PTR [bp-10]	;block
	*** 00016f	39 46 f6 		cmp	WORD PTR [bp-10],ax	;block
	*** 000172	0f 82 1b ff 		jb	$F730
	*** 000176	8b 7e 0c 		mov	di,WORD PTR [bp+12]	;startBlock
;|*** 		}
; Line 1033
					$FB732:
;|*** 
;|*** 		blockCount -= endBlock - startBlock;
; Line 1035
	*** 000179	2b c7 			sub	ax,di
	*** 00017b	2b d2 			sub	dx,dx
	*** 00017d	29 46 f8 		sub	WORD PTR [bp-8],ax	;blockCount
	*** 000180	19 56 fa 		sbb	WORD PTR [bp-6],dx
;|*** 		startBlock = 0;
; Line 1036
	*** 000183	33 ff 			xor	di,di
;|*** 
;|*** 		// Increase the data unit number by one
;|*** 		if (!++dataUnitNo.LowPart)
; Line 1039
	*** 000185	83 46 ea 01 		add	WORD PTR [bp-22],1	;dataUnitNo
	*** 000189	11 56 ec 		adc	WORD PTR [bp-20],dx
	*** 00018c	66 83 7e ea 00 		cmp	DWORD PTR [bp-22],0	;dataUnitNo
	*** 000191	75 07 			jne	SHORT $I742
;|*** 		{
;|*** 			dataUnitNo.HighPart++;
; Line 1041
	*** 000193	83 46 ee 01 		add	WORD PTR [bp-18],1
	*** 000197	11 56 f0 		adc	WORD PTR [bp-16],dx
;|*** 		}
;|*** 
;|*** 		// Convert the 64-bit data unit number into a little-endian 16-byte array. 
;|*** 		Uint64ToLE16ByteArray (byteBufUnitNo, dataUnitNo.HighPart, dataUnitNo.LowPart);
; Line 1045
					$I742:
	*** 00019a	66 ff 76 ea 		push	DWORD PTR [bp-22]	;dataUnitNo
	*** 00019e	66 ff 76 ee 		push	DWORD PTR [bp-18]
	*** 0001a2	8d 46 ca 		lea	ax,WORD PTR [bp-54]	;byteBufUnitNo
	*** 0001a5	50 			push	ax
	*** 0001a6	e8 00 00 		call	Uint64ToLE16ByteArray
	*** 0001a9	83 c4 0a 		add	sp,10	;000aH
;|*** 	}
; Line 1046
	*** 0001ac	39 7e fa 		cmp	WORD PTR [bp-6],di
	*** 0001af	0f 85 9b fe 		jne	$FC726
	*** 0001b3	39 7e f8 		cmp	WORD PTR [bp-8],di	;blockCount
	*** 0001b6	0f 85 94 fe 		jne	$FC726
;|*** 
;|*** 	FAST_ERASE64 (whiteningValue, sizeof (whiteningValue));
; Line 1048
					$D743:
	*** 0001ba	8d 46 da 		lea	ax,WORD PTR [bp-38]	;whiteningValue
	*** 0001bd	89 46 fe 		mov	WORD PTR [bp-2],ax	;whiteningValuePtr32
	*** 0001c0	bb 04 00 		mov	bx,4
	*** 0001c3	eb 0f 			jmp	SHORT $L923
	*** 0001c5	90 			nop	
					$FC749:
	*** 0001c6	8b 76 fe 		mov	si,WORD PTR [bp-2]	;whiteningValuePtr32
	*** 0001c9	66 c7 04 00 00 00 00 	mov	DWORD PTR [si],0
	*** 0001d0	83 46 fe 04 		add	WORD PTR [bp-2],4	;whiteningValuePtr32
					$L923:
	*** 0001d4	8b c3 			mov	ax,bx
	*** 0001d6	4b 			dec	bx
	*** 0001d7	0b c0 			or	ax,ax
	*** 0001d9	75 eb 			jne	SHORT $FC749
;|*** }
; Line 1049
	*** 0001db	5e 			pop	si
	*** 0001dc	5f 			pop	di
	*** 0001dd	c9 			leave	
	*** 0001de	c3 			ret	

EncryptDecryptBufferXTS32	ENDP
	PUBLIC	_DecryptBufferXTS8Byte
_DecryptBufferXTS8Byte	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void DecryptBufferXTS8Byte (const unsigned __int8 *buffer, GST_LARGEST_COMPILER_UINT length, const UINT64_STRUCT *startDataUnitNo, unsigned int startCipherBlockNo, unsigned __int8 *ks, unsigned __int8 *ks2, int cipher)
;|***  *	\brief Decrypts in the buffer in XTS mode.
;|***  *	\param[in] const unsigned __int8 * buffer
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT length
;|***  *	\param[in] const UINT64_STRUCT * startDataUnitNo
;|***  *	\param[in] unsigned int startCipherBlockNo
;|***  *	\param[in] unsigned __int8 * ks
;|***  *	\param[in] unsigned __int8 * ks2
;|***  *	\param[in] int cipher
;|***  *	\return void
;|***  *
;|***  */
;|*** void DecryptBufferXTS8Byte (unsigned __int8 *buffer,
;|*** 					GST_LARGEST_COMPILER_UINT length,
;|*** 					const UINT64_STRUCT *startDataUnitNo,
;|*** 					unsigned int startCipherBlockNo,
;|*** 					unsigned __int8 *ks,
;|*** 					unsigned __int8 *ks2,
;|*** 					int cipher)
;|*** {
; Line 1074
	*** 000000	c8 4c 02 00 		enter	588,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	byteBufUnitNo = -36
;	register si = whiteningValuePtr32
;	bufPtr = -20
;	startBlock = -14
;	endBlock = -18
;	block = -4
;	blockCount = -10
;	dataUnitNo = -28
;	xor_ks = -588
;	burnm = -2
;	register bx = burnc
;	buffer = 4
;	length = 6
;	startDataUnitNo = 10
;	startCipherBlockNo = 12
;	ks = 14
;	ks2 = 16
;	cipher = 18
;	finalCarry = -5
;	whiteningValue = -44
	*** 000006	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;startDataUnitNo
;|*** 	unsigned __int8 finalCarry;
;|*** 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK_SMALL];
;|*** 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK_SMALL];
;|*** 	unsigned __int32 *whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
;|*** 	unsigned __int32 *bufPtr = (unsigned __int32 *) buffer;
; Line 1079
	*** 000009	8b 46 04 		mov	ax,WORD PTR [bp+4]	;buffer
	*** 00000c	89 46 ec 		mov	WORD PTR [bp-20],ax	;bufPtr
;|*** 	unsigned __int32 startBlock = startCipherBlockNo, endBlock, block;
; Line 1080
	*** 00000f	8b 46 0c 		mov	ax,WORD PTR [bp+12]	;startCipherBlockNo
	*** 000012	89 46 f2 		mov	WORD PTR [bp-14],ax	;startBlock
	*** 000015	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0
;|*** 	GST_LARGEST_COMPILER_UINT blockCount;
;|*** 	UINT64_STRUCT dataUnitNo;
;|*** 	unsigned __int8 xor_ks[MAX_EXPANDED_KEY];
;|*** 
;|*** 	dataUnitNo.LowPart = startDataUnitNo->LowPart;
; Line 1085
	*** 00001a	66 8b 07 		mov	eax,DWORD PTR [bx]
	*** 00001d	66 89 46 e4 		mov	DWORD PTR [bp-28],eax	;dataUnitNo
;|*** 	dataUnitNo.HighPart = startDataUnitNo->HighPart;
; Line 1086
	*** 000021	66 8b 47 04 		mov	eax,DWORD PTR [bx+4]
	*** 000025	66 89 46 e8 		mov	DWORD PTR [bp-24],eax
;|*** 
;|*** 	*((unsigned __int32 *) byteBufUnitNo) = (unsigned __int32) LE32 (dataUnitNo.LowPart);
; Line 1088
	*** 000029	66 8b 46 e4 		mov	eax,DWORD PTR [bp-28]	;dataUnitNo
	*** 00002d	66 89 46 dc 		mov	DWORD PTR [bp-36],eax	;byteBufUnitNo
;|*** 	*((unsigned __int32 *) byteBufUnitNo + 1) = (unsigned __int32) LE32 (dataUnitNo.HighPart);
; Line 1089
	*** 000031	66 8b 46 e8 		mov	eax,DWORD PTR [bp-24]
	*** 000035	66 89 46 e0 		mov	DWORD PTR [bp-32],eax
;|*** 
;|*** 	if (length % BYTES_PER_XTS_BLOCK_SMALL)
; Line 1091
	*** 000039	f6 46 06 07 		test	BYTE PTR [bp+6],7	;length
	*** 00003d	74 09 			je	SHORT $I777
;|*** 		GST_THROW_FATAL_EXCEPTION;
; Line 1092
	*** 00003f	68 44 04 		push	1092	;0444H
	*** 000042	e8 00 00 		call	_ThrowFatalException
	*** 000045	83 c4 02 		add	sp,2
;|*** 
;|*** 	blockCount = length / BYTES_PER_XTS_BLOCK_SMALL;
; Line 1094
					$I777:
	*** 000048	66 8b 46 06 		mov	eax,DWORD PTR [bp+6]	;length
	*** 00004c	66 c1 e8 03 		shr	eax,3
	*** 000050	66 89 46 f6 		mov	DWORD PTR [bp-10],eax	;blockCount
;|*** 
;|*** 	memcpy(xor_ks, ks, CipherGetKeyScheduleSize(cipher));
; Line 1096
	*** 000054	ff 76 12 		push	WORD PTR [bp+18]	;cipher
	*** 000057	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 00005a	83 c4 02 		add	sp,2
	*** 00005d	50 			push	ax
	*** 00005e	ff 76 0e 		push	WORD PTR [bp+14]	;ks
	*** 000061	8d 86 b4 fd 		lea	ax,WORD PTR [bp-588]	;xor_ks
	*** 000065	50 			push	ax
	*** 000066	e8 00 00 		call	_memcpy
	*** 000069	83 c4 06 		add	sp,6
;|*** 	
;|*** 	while (blockCount > 0)
; Line 1098
	*** 00006c	66 83 7e f6 00 		cmp	DWORD PTR [bp-10],0	;blockCount
	*** 000071	0f 84 4f 01 		je	$D790
					$L901:
;|*** 	{
;|*** 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT_SMALL)
;|*** 			endBlock = startBlock + (unsigned __int32) blockCount;
;|*** 		else
;|*** 			endBlock = BLOCKS_PER_XTS_DATA_UNIT_SMALL;
;|*** 
;|*** 		whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
;|*** 
;|*** 		//Encrypt data unit using the second key to generate the first whitening value
;|*** 		*whiteningValuePtr32 = *((unsigned __int32 *) byteBufUnitNo);
; Line 1108
	*** 000075	66 8b 46 dc 		mov	eax,DWORD PTR [bp-36]	;byteBufUnitNo
	*** 000079	8d 76 d4 		lea	si,WORD PTR [bp-44]	;whiteningValue
	*** 00007c	66 89 04 		mov	DWORD PTR [si],eax
;|*** 		*(whiteningValuePtr32+1) = *((unsigned __int32 *) byteBufUnitNo+1);
; Line 1109
	*** 00007f	66 8b 46 e0 		mov	eax,DWORD PTR [bp-32]
	*** 000083	66 89 46 d8 		mov	DWORD PTR [bp-40],eax
;|*** 		EncipherBlock (cipher, whiteningValue, ks2);
; Line 1110
	*** 000087	ff 76 10 		push	WORD PTR [bp+16]	;ks2
	*** 00008a	8d 46 d4 		lea	ax,WORD PTR [bp-44]	;whiteningValue
	*** 00008d	50 			push	ax
	*** 00008e	ff 76 12 		push	WORD PTR [bp+18]	;cipher
	*** 000091	e8 00 00 		call	_EncipherBlock
	*** 000094	83 c4 06 		add	sp,6
;|*** 
;|*** 		//XOR ks with the current DataUnitNo
;|*** 		XorKeySchedule(cipher, ks, xor_ks, byteBufUnitNo, 8);
; Line 1113
	*** 000097	6a 08 			push	8
	*** 000099	8d 46 dc 		lea	ax,WORD PTR [bp-36]	;byteBufUnitNo
	*** 00009c	50 			push	ax
	*** 00009d	8d 86 b4 fd 		lea	ax,WORD PTR [bp-588]	;xor_ks
	*** 0000a1	50 			push	ax
	*** 0000a2	ff 76 0e 		push	WORD PTR [bp+14]	;ks
	*** 0000a5	ff 76 12 		push	WORD PTR [bp+18]	;cipher
	*** 0000a8	e8 00 00 		call	_XorKeySchedule
	*** 0000ab	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|*** 		for (block = 0; block < endBlock; block++)
; Line 1115
	*** 0000ae	66 2b c0 		sub	eax,eax
	*** 0000b1	66 89 46 fc 		mov	DWORD PTR [bp-4],eax	;block
	*** 0000b5	39 46 f8 		cmp	WORD PTR [bp-8],ax
	*** 0000b8	75 14 			jne	SHORT $I781
	*** 0000ba	83 7e f6 40 		cmp	WORD PTR [bp-10],64	;0040H	;blockCount
	*** 0000be	73 0e 			jae	SHORT $I781
	*** 0000c0	8b 46 f6 		mov	ax,WORD PTR [bp-10]	;blockCount
	*** 0000c3	8b 56 f8 		mov	dx,WORD PTR [bp-8]
	*** 0000c6	03 46 f2 		add	ax,WORD PTR [bp-14]	;startBlock
	*** 0000c9	13 56 f4 		adc	dx,WORD PTR [bp-12]
	*** 0000cc	eb 04 			jmp	SHORT $I782
					$I781:
	*** 0000ce	b8 40 00 		mov	ax,64	;0040H
	*** 0000d1	99 			cwd	
					$I782:
	*** 0000d2	89 46 ee 		mov	WORD PTR [bp-18],ax	;endBlock
	*** 0000d5	89 56 f0 		mov	WORD PTR [bp-16],dx
	*** 0000d8	0b d2 			or	dx,dx
	*** 0000da	75 06 			jne	SHORT $L903
	*** 0000dc	0b c0 			or	ax,ax
	*** 0000de	0f 84 a4 00 		je	$FB785
					$L903:
	*** 0000e2	8b 7e ec 		mov	di,WORD PTR [bp-20]	;bufPtr
					$F783:
;|*** 		{
;|*** 			if (block >= startBlock)
; Line 1117
	*** 0000e5	66 8b 46 f2 		mov	eax,DWORD PTR [bp-14]	;startBlock
	*** 0000e9	66 39 46 fc 		cmp	DWORD PTR [bp-4],eax	;block
	*** 0000ed	72 4b 			jb	SHORT $I786
					$L904:
;|*** 			{
;|*** 				//Post-whitening
;|*** 				*bufPtr++ ^= *whiteningValuePtr32++;
; Line 1120
	*** 0000ef	66 8b 04 		mov	eax,DWORD PTR [si]
	*** 0000f2	83 c6 04 		add	si,4
	*** 0000f5	66 31 05 		xor	DWORD PTR [di],eax
;|*** 				*bufPtr-- ^= *whiteningValuePtr32--;
; Line 1121
	*** 0000f8	66 8b 04 		mov	eax,DWORD PTR [si]
	*** 0000fb	83 ee 04 		sub	si,4
	*** 0000fe	83 c7 04 		add	di,4
	*** 000101	66 31 05 		xor	DWORD PTR [di],eax
;|*** 
;|*** 				//Actual decryption
;|*** 				DecipherBlock (cipher, bufPtr, xor_ks);
; Line 1124
	*** 000104	8d 86 b4 fd 		lea	ax,WORD PTR [bp-588]	;xor_ks
	*** 000108	50 			push	ax
	*** 000109	83 c7 fc 		add	di,-4	;fffcH
	*** 00010c	57 			push	di
	*** 00010d	ff 76 12 		push	WORD PTR [bp+18]	;cipher
	*** 000110	e8 00 00 		call	_DecipherBlock
	*** 000113	83 c4 06 		add	sp,6
;|*** 
;|*** 				//Pre-whitening
;|*** 				*bufPtr++ ^= *whiteningValuePtr32++;
; Line 1127
	*** 000116	8b 05 			mov	ax,WORD PTR [di]
	*** 000118	8b 55 02 		mov	dx,WORD PTR [di+2]
	*** 00011b	33 04 			xor	ax,WORD PTR [si]
	*** 00011d	33 54 02 		xor	dx,WORD PTR [si+2]
	*** 000120	89 05 			mov	WORD PTR [di],ax
	*** 000122	83 c6 04 		add	si,4
	*** 000125	89 55 02 		mov	WORD PTR [di+2],dx
;|*** 				*bufPtr++ ^= *whiteningValuePtr32;
; Line 1128
	*** 000128	8b 04 			mov	ax,WORD PTR [si]
	*** 00012a	83 c7 04 		add	di,4
	*** 00012d	8b 54 02 		mov	dx,WORD PTR [si+2]
	*** 000130	31 05 			xor	WORD PTR [di],ax
	*** 000132	31 55 02 		xor	WORD PTR [di+2],dx
	*** 000135	83 c7 04 		add	di,4
;|*** 			}
;|*** 			else
; Line 1130
	*** 000138	eb 03 			jmp	SHORT $I787
					$I786:
;|*** 				whiteningValuePtr32++;
; Line 1131
	*** 00013a	83 c6 04 		add	si,4
					$I787:
;|*** 
;|*** 			//Derive the next whitening value
;|*** 
;|*** #if BYTE_ORDER == LITTLE_ENDIAN
;|*** 
;|*** 			//Little-endian platforms
;|*** 
;|*** 			finalCarry = (*whiteningValuePtr32 & 0x80000000) ? 27 : 0;
; Line 1139
	*** 00013d	f7 44 02 00 80 		test	WORD PTR [si+2],-32768	;8000H
	*** 000142	74 04 			je	SHORT $L899
	*** 000144	b0 1b 			mov	al,27	;001bH
	*** 000146	eb 02 			jmp	SHORT $L900
					$L899:
	*** 000148	32 c0 			xor	al,al
					$L900:
	*** 00014a	88 46 fb 		mov	BYTE PTR [bp-5],al	;finalCarry
;|*** 
;|*** 			*whiteningValuePtr32-- <<= 1;
; Line 1141
	*** 00014d	66 8b 04 		mov	eax,DWORD PTR [si]
	*** 000150	66 03 c0 		add	eax,eax
	*** 000153	66 89 04 		mov	DWORD PTR [si],eax
;|*** 
;|*** 			if (*whiteningValuePtr32 & 0x80000000)
; Line 1143
	*** 000156	83 ee 04 		sub	si,4
	*** 000159	f7 44 02 00 80 		test	WORD PTR [si+2],-32768	;8000H
	*** 00015e	74 04 			je	SHORT $I788
;|*** 				*(whiteningValuePtr32 + 1) |= 1;
; Line 1144
	*** 000160	80 4c 04 01 		or	BYTE PTR [si+4],1
;|*** 
;|*** 			*whiteningValuePtr32 <<= 1;
; Line 1146
					$I788:
	*** 000164	66 8b 04 		mov	eax,DWORD PTR [si]
	*** 000167	66 03 c0 		add	eax,eax
	*** 00016a	66 89 04 		mov	DWORD PTR [si],eax
;|*** #else
;|*** 			//Big-endian platforms
;|*** 			finalCarry = (*whiteningValuePtr32 & 0x80) ? 27 : 0);
;|*** 
;|*** 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
;|*** 
;|*** 			whiteningValuePtr32--;
;|*** 
;|*** 			if (*whiteningValuePtr32 & 0x80)
;|*** 				*(whiteningValuePtr32 + 1) |= 0x1000000;
;|*** 
;|*** 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
;|*** #endif
;|*** 
;|*** 			whiteningValue[0] ^= finalCarry;
; Line 1161
	*** 00016d	8a 46 fb 		mov	al,BYTE PTR [bp-5]	;finalCarry
	*** 000170	30 46 d4 		xor	BYTE PTR [bp-44],al	;whiteningValue
	*** 000173	66 8b 46 ee 		mov	eax,DWORD PTR [bp-18]	;endBlock
	*** 000177	66 ff 46 fc 		inc	DWORD PTR [bp-4]	;block
	*** 00017b	66 39 46 fc 		cmp	DWORD PTR [bp-4],eax	;block
	*** 00017f	0f 82 62 ff 		jb	$F783
					$L898:
	*** 000183	89 7e ec 		mov	WORD PTR [bp-20],di	;bufPtr
;|*** 		}
; Line 1162
					$FB785:
;|*** 
;|*** 		blockCount -= endBlock - startBlock;
; Line 1164
	*** 000186	66 8b 46 f2 		mov	eax,DWORD PTR [bp-14]	;startBlock
	*** 00018a	66 2b 46 ee 		sub	eax,DWORD PTR [bp-18]	;endBlock
	*** 00018e	66 01 46 f6 		add	DWORD PTR [bp-10],eax	;blockCount
;|*** 		startBlock = 0;
; Line 1165
	*** 000192	66 2b c0 		sub	eax,eax
	*** 000195	66 89 46 f2 		mov	DWORD PTR [bp-14],eax	;startBlock
;|*** 		if (!++dataUnitNo.LowPart)
; Line 1166
	*** 000199	83 46 e4 01 		add	WORD PTR [bp-28],1	;dataUnitNo
	*** 00019d	11 46 e6 		adc	WORD PTR [bp-26],ax
	*** 0001a0	66 83 7e e4 00 		cmp	DWORD PTR [bp-28],0	;dataUnitNo
	*** 0001a5	75 04 			jne	SHORT $I789
;|*** 			dataUnitNo.HighPart++;
; Line 1167
	*** 0001a7	66 ff 46 e8 		inc	DWORD PTR [bp-24]
;|*** 		*((unsigned __int32 *) byteBufUnitNo) = (unsigned __int32) LE32 (dataUnitNo.LowPart);
; Line 1168
					$I789:
	*** 0001ab	66 8b 46 e4 		mov	eax,DWORD PTR [bp-28]	;dataUnitNo
	*** 0001af	66 89 46 dc 		mov	DWORD PTR [bp-36],eax	;byteBufUnitNo
;|*** 		*((unsigned __int32 *) byteBufUnitNo+1) = (unsigned __int32) LE32 (dataUnitNo.HighPart);
; Line 1169
	*** 0001b3	66 8b 46 e8 		mov	eax,DWORD PTR [bp-24]
	*** 0001b7	66 89 46 e0 		mov	DWORD PTR [bp-32],eax
;|*** 	}
; Line 1170
	*** 0001bb	66 83 7e f6 00 		cmp	DWORD PTR [bp-10],0	;blockCount
	*** 0001c0	0f 85 b1 fe 		jne	$L901
;|*** 
;|*** 	FAST_ERASE32 (whiteningValue, sizeof (whiteningValue));
; Line 1172
					$D790:
	*** 0001c4	8d 46 d4 		lea	ax,WORD PTR [bp-44]	;whiteningValue
	*** 0001c7	89 46 fe 		mov	WORD PTR [bp-2],ax	;burnm
	*** 0001ca	bb 01 00 		mov	bx,1
	*** 0001cd	eb 0f 			jmp	SHORT $L924
	*** 0001cf	90 			nop	
					$FC796:
	*** 0001d0	8b 76 fe 		mov	si,WORD PTR [bp-2]	;burnm
	*** 0001d3	66 c7 04 00 00 00 00 	mov	DWORD PTR [si],0
	*** 0001da	83 46 fe 04 		add	WORD PTR [bp-2],4	;burnm
					$L924:
	*** 0001de	8b c3 			mov	ax,bx
	*** 0001e0	4b 			dec	bx
	*** 0001e1	0b c0 			or	ax,ax
	*** 0001e3	75 eb 			jne	SHORT $FC796
;|*** }
; Line 1173
	*** 0001e5	5e 			pop	si
	*** 0001e6	5f 			pop	di
	*** 0001e7	c9 			leave	
	*** 0001e8	c3 			ret	

_DecryptBufferXTS8Byte	ENDP
	PUBLIC	_EncryptBufferXTS8Byte
_EncryptBufferXTS8Byte	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void EncryptBufferXTS8Byte (const unsigned __int8 *buffer, GST_LARGEST_COMPILER_UINT length, const UINT64_STRUCT *startDataUnitNo, unsigned int startCipherBlockNo, unsigned __int8 *ks, unsigned __int8 *ks2, int cipher)
;|***  *	\brief Encrypts in the buffer in XTS mode.
;|***  *	\param[in] const unsigned __int8 * buffer
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT length
;|***  *	\param[in] const UINT64_STRUCT * startDataUnitNo
;|***  *	\param[in] unsigned int startCipherBlockNo
;|***  *	\param[in] unsigned __int8 * ks
;|***  *	\param[in] unsigned __int8 * ks2
;|***  *	\param[in] int cipher
;|***  *	\return void
;|***  *
;|***  */
;|*** void EncryptBufferXTS8Byte(unsigned __int8 *buffer,
;|*** 						GST_LARGEST_COMPILER_UINT length,
;|*** 						const UINT64_STRUCT *startDataUnitNo,
;|*** 						unsigned int startCipherBlockNo,
;|*** 						unsigned __int8 *ks,
;|*** 						unsigned __int8 *ks2,
;|*** 						int cipher)
;|*** {
; Line 1197
	*** 000000	c8 4c 02 00 		enter	588,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	burnm = -2
;	register bx = burnc
;	buffer = 4
;	length = 6
;	startDataUnitNo = 10
;	startCipherBlockNo = 12
;	ks = 14
;	ks2 = 16
;	cipher = 18
;	finalCarry = -5
;	whiteningValue = -44
;	byteBufUnitNo = -36
;	register si = whiteningValuePtr32
;	bufPtr = -20
;	startBlock = -14
;	endBlock = -18
;	block = -4
;	blockCount = -10
;	dataUnitNo = -28
;	xor_ks = -588
	*** 000006	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;startDataUnitNo
;|*** 	unsigned __int8 finalCarry;
;|*** 	unsigned __int8 whiteningValue [BYTES_PER_XTS_BLOCK_SMALL];
;|*** 	unsigned __int8 byteBufUnitNo [BYTES_PER_XTS_BLOCK_SMALL];
;|*** 	unsigned __int32 *whiteningValuePtr32 = (unsigned __int32 *)whiteningValue;
;|*** 	unsigned __int32 *bufPtr = (unsigned __int32 *)buffer;
; Line 1202
	*** 000009	8b 46 04 		mov	ax,WORD PTR [bp+4]	;buffer
	*** 00000c	89 46 ec 		mov	WORD PTR [bp-20],ax	;bufPtr
;|*** 	unsigned __int32 startBlock = startCipherBlockNo, endBlock, block;
; Line 1203
	*** 00000f	8b 46 0c 		mov	ax,WORD PTR [bp+12]	;startCipherBlockNo
	*** 000012	89 46 f2 		mov	WORD PTR [bp-14],ax	;startBlock
	*** 000015	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0
;|*** 	GST_LARGEST_COMPILER_UINT blockCount;
;|*** 	UINT64_STRUCT dataUnitNo;
;|*** 	unsigned __int8 xor_ks[MAX_EXPANDED_KEY];
;|*** 
;|*** 	dataUnitNo.LowPart = startDataUnitNo->LowPart;
; Line 1208
	*** 00001a	66 8b 07 		mov	eax,DWORD PTR [bx]
	*** 00001d	66 89 46 e4 		mov	DWORD PTR [bp-28],eax	;dataUnitNo
;|*** 	dataUnitNo.HighPart = startDataUnitNo->HighPart;
; Line 1209
	*** 000021	66 8b 47 04 		mov	eax,DWORD PTR [bx+4]
	*** 000025	66 89 46 e8 		mov	DWORD PTR [bp-24],eax
;|*** 
;|*** 	*((unsigned __int32 *) byteBufUnitNo) = (unsigned __int32) LE32 (dataUnitNo.LowPart);
; Line 1211
	*** 000029	66 8b 46 e4 		mov	eax,DWORD PTR [bp-28]	;dataUnitNo
	*** 00002d	66 89 46 dc 		mov	DWORD PTR [bp-36],eax	;byteBufUnitNo
;|*** 	*((unsigned __int32 *) byteBufUnitNo + 1) = (unsigned __int32) LE32 (dataUnitNo.HighPart);
; Line 1212
	*** 000031	66 8b 46 e8 		mov	eax,DWORD PTR [bp-24]
	*** 000035	66 89 46 e0 		mov	DWORD PTR [bp-32],eax
;|*** 
;|*** 	if (length % BYTES_PER_XTS_BLOCK_SMALL)
; Line 1214
	*** 000039	f6 46 06 07 		test	BYTE PTR [bp+6],7	;length
	*** 00003d	74 09 			je	SHORT $I824
;|*** 		GST_THROW_FATAL_EXCEPTION;
; Line 1215
	*** 00003f	68 bf 04 		push	1215	;04bfH
	*** 000042	e8 00 00 		call	_ThrowFatalException
	*** 000045	83 c4 02 		add	sp,2
;|*** 
;|*** 	blockCount = length / BYTES_PER_XTS_BLOCK_SMALL;
; Line 1217
					$I824:
	*** 000048	66 8b 46 06 		mov	eax,DWORD PTR [bp+6]	;length
	*** 00004c	66 c1 e8 03 		shr	eax,3
	*** 000050	66 89 46 f6 		mov	DWORD PTR [bp-10],eax	;blockCount
;|*** 	
;|*** 	memcpy(xor_ks, ks, CipherGetKeyScheduleSize(cipher));
; Line 1219
	*** 000054	ff 76 12 		push	WORD PTR [bp+18]	;cipher
	*** 000057	e8 00 00 		call	_CipherGetKeyScheduleSize
	*** 00005a	83 c4 02 		add	sp,2
	*** 00005d	50 			push	ax
	*** 00005e	ff 76 0e 		push	WORD PTR [bp+14]	;ks
	*** 000061	8d 86 b4 fd 		lea	ax,WORD PTR [bp-588]	;xor_ks
	*** 000065	50 			push	ax
	*** 000066	e8 00 00 		call	_memcpy
	*** 000069	83 c4 06 		add	sp,6
;|*** 
;|*** 	while (blockCount > 0)
; Line 1221
	*** 00006c	66 83 7e f6 00 		cmp	DWORD PTR [bp-10],0	;blockCount
	*** 000071	0f 84 4f 01 		je	$D837
					$L916:
;|*** 	{
;|*** 		if (blockCount < BLOCKS_PER_XTS_DATA_UNIT_SMALL)
;|*** 			endBlock = startBlock + (unsigned __int32) blockCount;
;|*** 		else
;|*** 			endBlock = BLOCKS_PER_XTS_DATA_UNIT_SMALL;
;|*** 
;|*** 		whiteningValuePtr32 = (unsigned __int32 *) whiteningValue;
;|*** 
;|*** 		//Generate first whitening value
;|*** 		*whiteningValuePtr32 = *((unsigned __int32 *) byteBufUnitNo);
; Line 1231
	*** 000075	66 8b 46 dc 		mov	eax,DWORD PTR [bp-36]	;byteBufUnitNo
	*** 000079	8d 76 d4 		lea	si,WORD PTR [bp-44]	;whiteningValue
	*** 00007c	66 89 04 		mov	DWORD PTR [si],eax
;|*** 		*(whiteningValuePtr32+1) = *((unsigned __int32 *) byteBufUnitNo+1);
; Line 1232
	*** 00007f	66 8b 46 e0 		mov	eax,DWORD PTR [bp-32]
	*** 000083	66 89 46 d8 		mov	DWORD PTR [bp-40],eax
;|*** 		EncipherBlock (cipher, whiteningValue, ks2);
; Line 1233
	*** 000087	ff 76 10 		push	WORD PTR [bp+16]	;ks2
	*** 00008a	8d 46 d4 		lea	ax,WORD PTR [bp-44]	;whiteningValue
	*** 00008d	50 			push	ax
	*** 00008e	ff 76 12 		push	WORD PTR [bp+18]	;cipher
	*** 000091	e8 00 00 		call	_EncipherBlock
	*** 000094	83 c4 06 		add	sp,6
;|*** 
;|*** 		//XOR ks with the current DataUnitNo
;|*** 		XorKeySchedule(cipher, ks, xor_ks, byteBufUnitNo, 8);
; Line 1236
	*** 000097	6a 08 			push	8
	*** 000099	8d 46 dc 		lea	ax,WORD PTR [bp-36]	;byteBufUnitNo
	*** 00009c	50 			push	ax
	*** 00009d	8d 86 b4 fd 		lea	ax,WORD PTR [bp-588]	;xor_ks
	*** 0000a1	50 			push	ax
	*** 0000a2	ff 76 0e 		push	WORD PTR [bp+14]	;ks
	*** 0000a5	ff 76 12 		push	WORD PTR [bp+18]	;cipher
	*** 0000a8	e8 00 00 		call	_XorKeySchedule
	*** 0000ab	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|*** 		//Generate subsequent whitening values for blocks
;|*** 		for (block = 0; block < endBlock; block++)
; Line 1239
	*** 0000ae	66 2b c0 		sub	eax,eax
	*** 0000b1	66 89 46 fc 		mov	DWORD PTR [bp-4],eax	;block
	*** 0000b5	39 46 f8 		cmp	WORD PTR [bp-8],ax
	*** 0000b8	75 14 			jne	SHORT $I828
	*** 0000ba	83 7e f6 40 		cmp	WORD PTR [bp-10],64	;0040H	;blockCount
	*** 0000be	73 0e 			jae	SHORT $I828
	*** 0000c0	8b 46 f6 		mov	ax,WORD PTR [bp-10]	;blockCount
	*** 0000c3	8b 56 f8 		mov	dx,WORD PTR [bp-8]
	*** 0000c6	03 46 f2 		add	ax,WORD PTR [bp-14]	;startBlock
	*** 0000c9	13 56 f4 		adc	dx,WORD PTR [bp-12]
	*** 0000cc	eb 04 			jmp	SHORT $I829
					$I828:
	*** 0000ce	b8 40 00 		mov	ax,64	;0040H
	*** 0000d1	99 			cwd	
					$I829:
	*** 0000d2	89 46 ee 		mov	WORD PTR [bp-18],ax	;endBlock
	*** 0000d5	89 56 f0 		mov	WORD PTR [bp-16],dx
	*** 0000d8	0b d2 			or	dx,dx
	*** 0000da	75 06 			jne	SHORT $L918
	*** 0000dc	0b c0 			or	ax,ax
	*** 0000de	0f 84 a4 00 		je	$FB832
					$L918:
	*** 0000e2	8b 7e ec 		mov	di,WORD PTR [bp-20]	;bufPtr
					$F830:
;|*** 		{
;|*** 			if (block >= startBlock)
; Line 1241
	*** 0000e5	66 8b 46 f2 		mov	eax,DWORD PTR [bp-14]	;startBlock
	*** 0000e9	66 39 46 fc 		cmp	DWORD PTR [bp-4],eax	;block
	*** 0000ed	72 4b 			jb	SHORT $I833
					$L919:
;|*** 			{
;|*** 				//Pre-whitening
;|*** 				*bufPtr++ ^= *whiteningValuePtr32++;
; Line 1244
	*** 0000ef	66 8b 04 		mov	eax,DWORD PTR [si]
	*** 0000f2	83 c6 04 		add	si,4
	*** 0000f5	66 31 05 		xor	DWORD PTR [di],eax
;|*** 				*bufPtr-- ^= *whiteningValuePtr32--;
; Line 1245
	*** 0000f8	66 8b 04 		mov	eax,DWORD PTR [si]
	*** 0000fb	83 ee 04 		sub	si,4
	*** 0000fe	83 c7 04 		add	di,4
	*** 000101	66 31 05 		xor	DWORD PTR [di],eax
;|*** 
;|*** 				//Actual encryption
;|*** 				EncipherBlock(cipher, bufPtr, xor_ks);
; Line 1248
	*** 000104	8d 86 b4 fd 		lea	ax,WORD PTR [bp-588]	;xor_ks
	*** 000108	50 			push	ax
	*** 000109	83 c7 fc 		add	di,-4	;fffcH
	*** 00010c	57 			push	di
	*** 00010d	ff 76 12 		push	WORD PTR [bp+18]	;cipher
	*** 000110	e8 00 00 		call	_EncipherBlock
	*** 000113	83 c4 06 		add	sp,6
;|*** 
;|*** 				//Post-whitening
;|*** 				*bufPtr++ ^= *whiteningValuePtr32++;
; Line 1251
	*** 000116	8b 05 			mov	ax,WORD PTR [di]
	*** 000118	8b 55 02 		mov	dx,WORD PTR [di+2]
	*** 00011b	33 04 			xor	ax,WORD PTR [si]
	*** 00011d	33 54 02 		xor	dx,WORD PTR [si+2]
	*** 000120	89 05 			mov	WORD PTR [di],ax
	*** 000122	83 c6 04 		add	si,4
	*** 000125	89 55 02 		mov	WORD PTR [di+2],dx
;|*** 				*bufPtr++ ^= *whiteningValuePtr32;
; Line 1252
	*** 000128	8b 04 			mov	ax,WORD PTR [si]
	*** 00012a	83 c7 04 		add	di,4
	*** 00012d	8b 54 02 		mov	dx,WORD PTR [si+2]
	*** 000130	31 05 			xor	WORD PTR [di],ax
	*** 000132	31 55 02 		xor	WORD PTR [di+2],dx
	*** 000135	83 c7 04 		add	di,4
;|*** 			}
;|*** 			else
; Line 1254
	*** 000138	eb 03 			jmp	SHORT $I834
					$I833:
;|*** 				whiteningValuePtr32++;
; Line 1255
	*** 00013a	83 c6 04 		add	si,4
					$I834:
;|*** 
;|*** 			//Derive the next whitening value
;|*** #if BYTE_ORDER == LITTLE_ENDIAN
;|*** 
;|*** 			//Little-endian platforms
;|*** 			finalCarry = (*whiteningValuePtr32 & 0x80000000) ? 27 : 0;
; Line 1261
	*** 00013d	f7 44 02 00 80 		test	WORD PTR [si+2],-32768	;8000H
	*** 000142	74 04 			je	SHORT $L914
	*** 000144	b0 1b 			mov	al,27	;001bH
	*** 000146	eb 02 			jmp	SHORT $L915
					$L914:
	*** 000148	32 c0 			xor	al,al
					$L915:
	*** 00014a	88 46 fb 		mov	BYTE PTR [bp-5],al	;finalCarry
;|*** 
;|*** 			*whiteningValuePtr32-- <<= 1;
; Line 1263
	*** 00014d	66 8b 04 		mov	eax,DWORD PTR [si]
	*** 000150	66 03 c0 		add	eax,eax
	*** 000153	66 89 04 		mov	DWORD PTR [si],eax
;|*** 
;|*** 			if (*whiteningValuePtr32 & 0x80000000)
; Line 1265
	*** 000156	83 ee 04 		sub	si,4
	*** 000159	f7 44 02 00 80 		test	WORD PTR [si+2],-32768	;8000H
	*** 00015e	74 04 			je	SHORT $I835
;|*** 				*(whiteningValuePtr32 + 1) |= 1;
; Line 1266
	*** 000160	80 4c 04 01 		or	BYTE PTR [si+4],1
;|*** 
;|*** 			*whiteningValuePtr32 <<= 1;
; Line 1268
					$I835:
	*** 000164	66 8b 04 		mov	eax,DWORD PTR [si]
	*** 000167	66 03 c0 		add	eax,eax
	*** 00016a	66 89 04 		mov	DWORD PTR [si],eax
;|*** #else
;|*** 			//Big-endian platforms
;|*** 			finalCarry = (*whiteningValuePtr32 & 0x80) ? 27 : 0;
;|*** 
;|*** 			*whiteningValuePtr32 = LE32 (L32 (*whiteningValuePtr32) << 1);
;|*** 
;|*** 			whiteningValuePtr32--;
;|*** 
;|*** 			if (*whiteningValuePtr32 & 0x80)
;|*** 				*(whiteningValuePtr32 + 1) |= 0x01000000;
;|*** 
;|*** 			*whiteningValuePtr32 = LE32 (LE32 (*whiteningValuePtr32) << 1);
;|*** #endif
;|*** 			whiteningValue[0] ^= finalCarry;
; Line 1282
	*** 00016d	8a 46 fb 		mov	al,BYTE PTR [bp-5]	;finalCarry
	*** 000170	30 46 d4 		xor	BYTE PTR [bp-44],al	;whiteningValue
	*** 000173	66 8b 46 ee 		mov	eax,DWORD PTR [bp-18]	;endBlock
	*** 000177	66 ff 46 fc 		inc	DWORD PTR [bp-4]	;block
	*** 00017b	66 39 46 fc 		cmp	DWORD PTR [bp-4],eax	;block
	*** 00017f	0f 82 62 ff 		jb	$F830
					$L913:
	*** 000183	89 7e ec 		mov	WORD PTR [bp-20],di	;bufPtr
;|*** 		}
; Line 1283
					$FB832:
;|*** 		blockCount -= endBlock - startBlock;
; Line 1284
	*** 000186	66 8b 46 f2 		mov	eax,DWORD PTR [bp-14]	;startBlock
	*** 00018a	66 2b 46 ee 		sub	eax,DWORD PTR [bp-18]	;endBlock
	*** 00018e	66 01 46 f6 		add	DWORD PTR [bp-10],eax	;blockCount
;|*** 		startBlock = 0;
; Line 1285
	*** 000192	66 2b c0 		sub	eax,eax
	*** 000195	66 89 46 f2 		mov	DWORD PTR [bp-14],eax	;startBlock
;|*** 		if (!++dataUnitNo.LowPart)
; Line 1286
	*** 000199	83 46 e4 01 		add	WORD PTR [bp-28],1	;dataUnitNo
	*** 00019d	11 46 e6 		adc	WORD PTR [bp-26],ax
	*** 0001a0	66 83 7e e4 00 		cmp	DWORD PTR [bp-28],0	;dataUnitNo
	*** 0001a5	75 04 			jne	SHORT $I836
;|*** 			dataUnitNo.HighPart++;
; Line 1287
	*** 0001a7	66 ff 46 e8 		inc	DWORD PTR [bp-24]
;|*** 		*((unsigned __int32 *) byteBufUnitNo) = (unsigned __int32) LE32 (dataUnitNo.LowPart);
; Line 1288
					$I836:
	*** 0001ab	66 8b 46 e4 		mov	eax,DWORD PTR [bp-28]	;dataUnitNo
	*** 0001af	66 89 46 dc 		mov	DWORD PTR [bp-36],eax	;byteBufUnitNo
;|*** 		*((unsigned __int32 *) byteBufUnitNo+1) = (unsigned __int32) LE32 (dataUnitNo.HighPart);
; Line 1289
	*** 0001b3	66 8b 46 e8 		mov	eax,DWORD PTR [bp-24]
	*** 0001b7	66 89 46 e0 		mov	DWORD PTR [bp-32],eax
;|*** 	}
; Line 1290
	*** 0001bb	66 83 7e f6 00 		cmp	DWORD PTR [bp-10],0	;blockCount
	*** 0001c0	0f 85 b1 fe 		jne	$L916
;|*** 	FAST_ERASE32(whiteningValue, sizeof(whiteningValue));
; Line 1291
					$D837:
	*** 0001c4	8d 46 d4 		lea	ax,WORD PTR [bp-44]	;whiteningValue
	*** 0001c7	89 46 fe 		mov	WORD PTR [bp-2],ax	;burnm
	*** 0001ca	bb 01 00 		mov	bx,1
	*** 0001cd	eb 0f 			jmp	SHORT $L925
	*** 0001cf	90 			nop	
					$FC843:
	*** 0001d0	8b 76 fe 		mov	si,WORD PTR [bp-2]	;burnm
	*** 0001d3	66 c7 04 00 00 00 00 	mov	DWORD PTR [si],0
	*** 0001da	83 46 fe 04 		add	WORD PTR [bp-2],4	;burnm
					$L925:
	*** 0001de	8b c3 			mov	ax,bx
	*** 0001e0	4b 			dec	bx
	*** 0001e1	0b c0 			or	ax,ax
	*** 0001e3	75 eb 			jne	SHORT $FC843
;|*** }
; Line 1292
	*** 0001e5	5e 			pop	si
	*** 0001e6	5f 			pop	di
	*** 0001e7	c9 			leave	
	*** 0001e8	c3 			ret	

_EncryptBufferXTS8Byte	ENDP
	PUBLIC	_EncryptBufferXTS
_EncryptBufferXTS	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void EncryptBufferXTS (unsigned __int8 *buffer, GST_LARGEST_COMPILER_UINT length, const UINT64_STRUCT *startDataUnitNo, unsigned int startCipherBlockNo, unsigned __int8 *ks, unsigned __int8 *ks2, int cipher)
;|***  *	\brief For descriptions of the input parameters, see the 64-bit version of EncryptBufferXTS() above.
;|***  *	\param[in] unsigned __int8 * buffer
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT length
;|***  *	\param[in] const UINT64_STRUCT * startDataUnitNo
;|***  *	\param[in] unsigned int startCipherBlockNo
;|***  *	\param[in] unsigned __int8 * ks
;|***  *	\param[in] unsigned __int8 * ks2
;|***  *	\param[in] int cipher
;|***  *	\return void
;|***  *
;|***  */
;|*** void EncryptBufferXTS (unsigned __int8 *buffer,
;|*** 					   GST_LARGEST_COMPILER_UINT length,
;|*** 					   const UINT64_STRUCT *startDataUnitNo,
;|*** 					   unsigned int startCipherBlockNo,
;|*** 					   unsigned __int8 *ks,
;|*** 					   unsigned __int8 *ks2,
;|*** 					   int cipher)
;|*** {
; Line 1316
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	buffer = 4
;	length = 6
;	startDataUnitNo = 10
;	startCipherBlockNo = 12
;	ks = 14
;	ks2 = 16
;	cipher = 18
;|*** 	// Encrypt all plaintext blocks in the buffer
;|*** 	EncryptDecryptBufferXTS32 (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher, FALSE);
; Line 1318
	*** 000003	6a 00 			push	0
	*** 000005	66 ff 76 10 		push	DWORD PTR [bp+16]	;ks2
	*** 000009	66 ff 76 0c 		push	DWORD PTR [bp+12]	;startCipherBlockNo
	*** 00000d	66 ff 76 08 		push	DWORD PTR [bp+8]
	*** 000011	66 ff 76 04 		push	DWORD PTR [bp+4]	;buffer
	*** 000015	e8 00 00 		call	EncryptDecryptBufferXTS32
;|*** }
; Line 1319
	*** 000018	c9 			leave	
	*** 000019	c3 			ret	

_EncryptBufferXTS	ENDP
	PUBLIC	_DecryptBufferXTS
_DecryptBufferXTS	PROC NEAR	;  COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void DecryptBufferXTS (unsigned __int8 *buffer, GST_LARGEST_COMPILER_UINT length, const UINT64_STRUCT *startDataUnitNo, unsigned int startCipherBlockNo, unsigned __int8 *ks, unsigned __int8 *ks2, int cipher)
;|***  *	\brief For descriptions of the input parameters, see the 64-bit version of EncryptBufferXTS().
;|***  *	\param[in] unsigned __int8 * buffer
;|***  *	\param[in] GST_LARGEST_COMPILER_UINT length
;|***  *	\param[in] const UINT64_STRUCT * startDataUnitNo
;|***  *	\param[in] unsigned int startCipherBlockNo
;|***  *	\param[in] unsigned __int8 * ks
;|***  *	\param[in] unsigned __int8 * ks2
;|***  *	\param[in] int cipher
;|***  *	\return void
;|***  *
;|***  */
;|*** void DecryptBufferXTS (unsigned __int8 *buffer,
;|*** 					   GST_LARGEST_COMPILER_UINT length,
;|*** 					   const UINT64_STRUCT *startDataUnitNo,
;|*** 					   unsigned int startCipherBlockNo,
;|*** 					   unsigned __int8 *ks,
;|*** 					   unsigned __int8 *ks2,
;|*** 					   int cipher)
;|*** {
; Line 1343
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	buffer = 4
;	length = 6
;	startDataUnitNo = 10
;	startCipherBlockNo = 12
;	ks = 14
;	ks2 = 16
;	cipher = 18
;|*** 	// Decrypt all ciphertext blocks in the buffer
;|*** 	EncryptDecryptBufferXTS32 (buffer, length, startDataUnitNo, startCipherBlockNo, ks, ks2, cipher, TRUE);
; Line 1345
	*** 000003	6a 01 			push	1
	*** 000005	66 ff 76 10 		push	DWORD PTR [bp+16]	;ks2
	*** 000009	66 ff 76 0c 		push	DWORD PTR [bp+12]	;startCipherBlockNo
	*** 00000d	66 ff 76 08 		push	DWORD PTR [bp+8]
	*** 000011	66 ff 76 04 		push	DWORD PTR [bp+4]	;buffer
	*** 000015	e8 00 00 		call	EncryptDecryptBufferXTS32
;|*** }
; Line 1346
	*** 000018	c9 			leave	
	*** 000019	c3 			ret	

_DecryptBufferXTS	ENDP
_TEXT	ENDS
END
;|*** 
;|*** #endif	// GST_NO_COMPILER_INT64
