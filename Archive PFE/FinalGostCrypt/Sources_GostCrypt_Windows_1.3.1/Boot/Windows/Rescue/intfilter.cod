;	Static Name Aliases
;
;	$S1474_?OrigStackPointer@?1??IntFilterEntry@@YAXXZ@4IA	EQU	?OrigStackPointer@?1??IntFilterEntry@@YAXXZ@4IA
;	$S1476_?OrigStackSegment@?1??IntFilterEntry@@YAXXZ@4IA	EQU	?OrigStackSegment@?1??IntFilterEntry@@YAXXZ@4IA
;	$S1415_BiosMemoryMapSize	EQU	BiosMemoryMapSize
;	$S1365_OriginalInt13Handler	EQU	OriginalInt13Handler
;	$S1366_OriginalInt15Handler	EQU	OriginalInt15Handler
;	$S1367_IntRegisters	EQU	IntRegisters
;	$S1373_?ReEntryCount@?1??Int13Filter@@YADXZ@4HA	EQU	?ReEntryCount@?1??Int13Filter@@YADXZ@4HA
;	$S1468_?CompleteMapIssueCount@?5??Int15Filter@@YADXZ@4HA	EQU	?CompleteMapIssueCount@?5??Int15Filter@@YADXZ@4HA
	TITLE   ..\intfilter.cpp
	.MODEL  SMALL
	.386p
	.387
_TEXT	SEGMENT  WORD USE16 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT  WORD USE16 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD USE16 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD USE16 PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
PUBLIC  ??_C@_04PLFG@MMP?3?$AA@
EXTRN	?GetLinearAddress@@YAKII@Z:NEAR
EXTRN	?RegionsIntersect@@YADABTUINT64_STRUCT@@K00@Z:NEAR
EXTRN	?ReadEncryptedSectors@@YAEIIETUINT64_STRUCT@@I@Z:NEAR
EXTRN	??H@YA?ATUINT64_STRUCT@@ABT0@0@Z:NEAR
EXTRN	?WriteEncryptedSectors@@YAEIIETUINT64_STRUCT@@I@Z:NEAR
EXTRN	??G@YA?ATUINT64_STRUCT@@ABT0@0@Z:NEAR
EXTRN	??G@YA?ATUINT64_STRUCT@@ABT0@K@Z:NEAR
EXTRN	?GetFirstBiosMemoryMapEntry@@YADAAUBiosMemoryMapEntry@@@Z:NEAR
EXTRN	?Print@@YAXK@Z:NEAR
EXTRN	_memcpy:NEAR
EXTRN	?GetNextBiosMemoryMapEntry@@YADAAUBiosMemoryMapEntry@@@Z:NEAR
EXTRN	?ChsToLba@@YAXABUDriveGeometry@@ABUChsAddress@@AATUINT64_STRUCT@@@Z:NEAR
EXTRN	_ThrowFatalException:NEAR
EXTRN	?PrintEndl@@YAXXZ:NEAR
EXTRN	??O@YADABTUINT64_STRUCT@@0@Z:NEAR
EXTRN	??M@YADABTUINT64_STRUCT@@0@Z:NEAR
EXTRN	?PrintErrorNoEndl@@YAXPBD@Z:NEAR
EXTRN	?CopyMemory@@YAXPAXIII@Z:NEAR
EXTRN	?CopyMemory@@YAXIIPAXI@Z:NEAR
EXTRN	?BootSectorFlags@@3EA:BYTE
EXTRN	?BootDrive@@3EA:BYTE
EXTRN	?BootDriveGeometryValid@@3DA:BYTE
EXTRN	?BootDriveGeometry@@3UDriveGeometry@@A:DWORD
EXTRN	?EncryptedVirtualPartition@@3UPartition@@A:BYTE
_DATA      SEGMENT
$S1373_?ReEntryCount@?1??Int13Filter@@YADXZ@4HA	DW	0ffffH
	ORG	$-2
??_C@_04PLFG@MMP?3?$AA@	DB	'MMP:',  00H
	ORG	$-3
$S1468_?CompleteMapIssueCount@?5??Int15Filter@@YADXZ@4HA	DW	00H
_DATA      ENDS
_BSS      SEGMENT
	ORG	$+1638
$S1474_?OrigStackPointer@?1??IntFilterEntry@@YAXXZ@4IA	DW 01H DUP (?)
$S1476_?OrigStackSegment@?1??IntFilterEntry@@YAXXZ@4IA	DW 01H DUP (?)
	ORG	$-1606
PUBLIC  ?BiosMemoryMap@@3QAUBiosMemoryMapEntry@@A
?BiosMemoryMap@@3QAUBiosMemoryMapEntry@@A	DW 0320H DUP (?)
$S1415_BiosMemoryMapSize	DW 01H DUP (?)
	ORG	$-1638
$S1365_OriginalInt13Handler	DW 02H DUP (?)
$S1366_OriginalInt15Handler	DW 02H DUP (?)
$S1367_IntRegisters	DW 0eH DUP (?)
_BSS      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	PUBLIC	?Int13Filter@@YADXZ	; Int13Filter
?Int13Filter@@YADXZ	PROC NEAR	; Int13Filter COMDAT
;|*** /**
;|***  *
;|***  *	\file IntFilter.cpp
;|***  *	\brief Manage filters
;|***  *	\version 1.3.1
;|***  *	\date 13/12/2016
;|***  *
;|***  */
;|*** 
;|*** /**
;|***  *	
;|***  *	Copyright (c) 2008 TrueCrypt Developers Association. All rights reserved.
;|***  *	
;|***  *	Governed by the TrueCrypt License 3.0 the full text of which is contained in
;|***  *	the file License.txt included in TrueCrypt binary and source code distribution
;|***  *	packages.
;|***  *	
;|***  */
;|*** 
;|*** #include "Platform.h"
;|*** #include "BootMemory.h"
;|*** #include "BootConfig.h"
;|*** #include "BootConsoleIo.h"
;|*** #include "BootDebug.h"
;|*** #include "BootDefs.h"
;|*** #include "BootDiskIo.h"
;|*** #include "BootEncryptedIo.h"
;|*** #include "BootStrings.h"
;|*** #include "IntFilter.h"
;|*** 
;|*** static uint32 OriginalInt13Handler;
;|*** static uint32 OriginalInt15Handler;
;|*** 
;|*** static Registers IntRegisters;
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn bool Int13Filter ()
;|***  *	\brief Filter int 13
;|***  *	\return bool passOriginalRequest
;|***  *
;|***  */
;|*** bool Int13Filter ()
;|*** {
; Line 45
	*** 000000	c8 42 00 00 		enter	66,0
;	regs = -28
;	function = -30
;	passOriginalRequest = -32
;|*** 	CheckStack();
;|*** 
;|*** 	Registers regs;
;|*** 	memcpy (&regs, &IntRegisters, sizeof (regs));
; Line 49
	*** 000004	6a 1c 			push	28	;001cH
	*** 000006	68 00 00 		push	OFFSET DGROUP:$S1367_IntRegisters
	*** 000009	8d 46 e4 		lea	ax,WORD PTR [bp-28]	;regs
	*** 00000c	50 			push	ax
	*** 00000d	e8 00 00 		call	_memcpy
	*** 000010	83 c4 06 		add	sp,6
;|*** 	__asm sti
; Line 50
	*** 000013	fb 			sti	
;|*** 
;|*** 	static int ReEntryCount = -1;
;|*** 	++ReEntryCount;
; Line 53
	*** 000014	ff 06 00 00 		inc	WORD PTR $S1373_?ReEntryCount@?1??Int13Filter@@YADXZ@4HA
;|*** 
;|*** 	byte function = (byte) (regs.AX >> 8);
;|*** 
;|*** #ifdef GST_TRACE_INT13
;|*** 	DisableScreenOutput();
;|*** 
;|*** 	PrintHex (function);
;|*** 
;|*** 	Print (" EN:"); Print (ReEntryCount);
;|*** 	Print (" SS:"); PrintHex (regs.SS);
;|*** 
;|*** 	uint16 spdbg;
;|*** 	__asm mov spdbg, sp
;|*** 	PrintChar (' ');
;|*** 	PrintHex (spdbg);
;|*** 	PrintChar ('<'); PrintHex (GST_BOOT_LOADER_STACK_TOP);
;|*** 
;|*** #endif
;|*** 
;|*** 	bool passOriginalRequest = true;
; Line 73
	*** 000018	c6 46 e0 01 		mov	BYTE PTR [bp-32],1	;passOriginalRequest
;|*** 
;|*** 	switch (function)
; Line 75
	*** 00001c	8a 46 e7 		mov	al,BYTE PTR [bp-25]
	*** 00001f	88 46 e2 		mov	BYTE PTR [bp-30],al	;function
	*** 000022	2a e4 			sub	ah,ah
	*** 000024	48 			dec	ax
	*** 000025	48 			dec	ax
	*** 000026	7c 02 			jl	SHORT $L1503
	*** 000028	71 03 			jno	SHORT $L1502
					$L1503:
	*** 00002a	e9 7f 01 		jmp	$SD1413
					$L1502:
	*** 00002d	48 			dec	ax
	*** 00002e	7e 0f 			jle	SHORT $SC1381
	*** 000030	2d 3f 00 		sub	ax,63	;003fH
	*** 000033	0f 8c 75 01 		jl	$SD1413
	*** 000037	48 			dec	ax
	*** 000038	0f 8e db 00 		jle	$SC1397
	*** 00003c	e9 6d 01 		jmp	$SD1413
;|*** 	{
;|*** 	case 0x2: // Read sectors
; Line 77
					$SC1381:
;|*** 	case 0x3: // Write sectors
;|*** 		{
; Line 79
;	drive = -34
;	chs = -38
;	sectorCount = -40
;	sector = -48
;|*** 			byte drive = (byte) regs.DX;
; Line 80
	*** 00003f	8a 46 f2 		mov	al,BYTE PTR [bp-14]
	*** 000042	88 46 de 		mov	BYTE PTR [bp-34],al	;drive
;|*** 
;|*** 			ChsAddress chs;
;|*** 			chs.Cylinder = ((regs.CX << 2) & 0x300) | (regs.CX >> 8);
; Line 83
	*** 000045	8a 4e ee 		mov	cl,BYTE PTR [bp-18]
	*** 000048	81 e1 c0 00 		and	cx,192	;00c0H
	*** 00004c	c1 e1 02 		shl	cx,2
	*** 00004f	8a 56 ef 		mov	dl,BYTE PTR [bp-17]
	*** 000052	2a f6 			sub	dh,dh
	*** 000054	0b ca 			or	cx,dx
	*** 000056	89 4e da 		mov	WORD PTR [bp-38],cx	;chs
;|*** 			chs.Head = regs.DX >> 8;
; Line 84
	*** 000059	8a 4e f3 		mov	cl,BYTE PTR [bp-13]
	*** 00005c	88 4e dc 		mov	BYTE PTR [bp-36],cl
;|*** 			chs.Sector = regs.CX & 0x3f;
; Line 85
	*** 00005f	8a 4e ee 		mov	cl,BYTE PTR [bp-18]
	*** 000062	80 e1 3f 		and	cl,63	;003fH
	*** 000065	88 4e dd 		mov	BYTE PTR [bp-35],cl
;|*** 
;|*** 			byte sectorCount = (byte) regs.AX;
; Line 87
	*** 000068	8a 4e e6 		mov	cl,BYTE PTR [bp-26]
	*** 00006b	88 4e d8 		mov	BYTE PTR [bp-40],cl	;sectorCount
;|*** 
;|*** #ifdef GST_TRACE_INT13
;|*** 			PrintVal (": Drive", drive - GST_FIRST_BIOS_DRIVE, false);
;|*** 			Print (" Chs: "); Print (chs);
;|*** #endif
;|*** 
;|*** 			uint64 sector;
;|*** 			if (drive == BootDrive)
; Line 95
	*** 00006e	3a 06 00 00 		cmp	al,BYTE PTR ?BootDrive@@3EA	;BootDrive
	*** 000072	75 1d 			jne	SHORT $I1388
;|*** 			{
;|*** 				if (!BootDriveGeometryValid)
; Line 97
	*** 000074	38 36 00 00 		cmp	BYTE PTR ?BootDriveGeometryValid@@3DA,dh	;BootDriveGeometryValid
	*** 000078	75 06 			jne	SHORT $I1389
;|*** 					GST_THROW_FATAL_EXCEPTION;
; Line 98
	*** 00007a	6a 62 			push	98	;0062H
	*** 00007c	e8 00 00 		call	_ThrowFatalException
	*** 00007f	5b 			pop	bx
;|*** 
;|*** 				ChsToLba (BootDriveGeometry, chs, sector);
; Line 100
					$I1389:
	*** 000080	8d 46 d0 		lea	ax,WORD PTR [bp-48]	;sector
	*** 000083	50 			push	ax
	*** 000084	8d 46 da 		lea	ax,WORD PTR [bp-38]	;chs
	*** 000087	50 			push	ax
	*** 000088	68 00 00 		push	OFFSET ?BootDriveGeometry@@3UDriveGeometry@@A	;BootDriveGeometry
	*** 00008b	e8 00 00 		call	?ChsToLba@@YAXABUDriveGeometry@@ABUChsAddress@@AATUINT64_STRUCT@@@Z	; ChsToLba
	*** 00008e	83 c4 06 		add	sp,6
;|*** #ifdef GST_TRACE_INT13
;|*** 				PrintVal (" Sec", sector.LowPart, false);
;|*** #endif
;|*** 			}
;|*** 
;|*** #ifdef GST_TRACE_INT13
;|*** 			PrintVal (" Count", sectorCount, false);
;|*** 			Print (" Buf: "); PrintHex (regs.ES); PrintChar (':'); PrintHex (regs.BX);
;|*** 			PrintEndl();
;|*** #endif
;|*** 
;|*** 			if (ReEntryCount == 0 && drive == EncryptedVirtualPartition.Drive)
; Line 112
					$I1388:
	*** 000091	83 3e 00 00 00 		cmp	WORD PTR $S1373_?ReEntryCount@?1??Int13Filter@@YADXZ@4HA,0
	*** 000096	75 08 			jne	SHORT $L1505
	*** 000098	a0 01 00 		mov	al,BYTE PTR ?EncryptedVirtualPartition@@3UPartition@@A+1	;EncryptedVirtualPartition
	*** 00009b	38 46 de 		cmp	BYTE PTR [bp-34],al	;drive
	*** 00009e	74 03 			je	SHORT $L1504
;|*** 			{
; Line 113
;	result = -50
;|*** 				BiosResult result;
;|*** 				
;|*** 				if (function == 0x3)
; Line 116
					$L1505:
	*** 0000a0	e9 09 01 		jmp	$SD1413
					$L1504:
	*** 0000a3	80 7e e2 03 		cmp	BYTE PTR [bp-30],3	;function
	*** 0000a7	75 1d 			jne	SHORT $I1392
;|*** 					result = WriteEncryptedSectors (regs.ES, regs.BX, drive, sector, sectorCount);
; Line 117
	*** 0000a9	8a 46 d8 		mov	al,BYTE PTR [bp-40]	;sectorCount
	*** 0000ac	2a e4 			sub	ah,ah
	*** 0000ae	50 			push	ax
	*** 0000af	66 ff 76 d4 		push	DWORD PTR [bp-44]
	*** 0000b3	66 ff 76 d0 		push	DWORD PTR [bp-48]	;sector
	*** 0000b7	8a 46 de 		mov	al,BYTE PTR [bp-34]	;drive
	*** 0000ba	50 			push	ax
	*** 0000bb	ff 76 ea 		push	WORD PTR [bp-22]
	*** 0000be	ff 76 fc 		push	WORD PTR [bp-4]
	*** 0000c1	e8 00 00 		call	?WriteEncryptedSectors@@YAEIIETUINT64_STRUCT@@I@Z	; WriteEncryptedSectors
	*** 0000c4	eb 1b 			jmp	SHORT $L1497
					$I1392:
;|*** 				else
;|*** 					result = ReadEncryptedSectors (regs.ES, regs.BX, drive, sector, sectorCount);
; Line 119
	*** 0000c6	8a 46 d8 		mov	al,BYTE PTR [bp-40]	;sectorCount
	*** 0000c9	2a e4 			sub	ah,ah
	*** 0000cb	50 			push	ax
	*** 0000cc	66 ff 76 d4 		push	DWORD PTR [bp-44]
	*** 0000d0	66 ff 76 d0 		push	DWORD PTR [bp-48]	;sector
	*** 0000d4	8a 46 de 		mov	al,BYTE PTR [bp-34]	;drive
	*** 0000d7	50 			push	ax
	*** 0000d8	ff 76 ea 		push	WORD PTR [bp-22]
	*** 0000db	ff 76 fc 		push	WORD PTR [bp-4]
	*** 0000de	e8 00 00 		call	?ReadEncryptedSectors@@YAEIIETUINT64_STRUCT@@I@Z	; ReadEncryptedSectors
					$L1497:
	*** 0000e1	83 c4 10 		add	sp,16	;0010H
	*** 0000e4	88 46 ce 		mov	BYTE PTR [bp-50],al	;result
;|*** 
;|*** 				__asm cli
; Line 121
	*** 0000e7	fa 			cli	
;|*** 
;|*** 				memcpy (&IntRegisters, &regs, sizeof (regs));
; Line 123
	*** 0000e8	6a 1c 			push	28	;001cH
	*** 0000ea	8d 46 e4 		lea	ax,WORD PTR [bp-28]	;regs
	*** 0000ed	50 			push	ax
	*** 0000ee	68 00 00 		push	OFFSET DGROUP:$S1367_IntRegisters
	*** 0000f1	e8 00 00 		call	_memcpy
	*** 0000f4	83 c4 06 		add	sp,6
;|*** 				IntRegisters.AX = (uint16) result << 8;
; Line 124
	*** 0000f7	8a 66 ce 		mov	ah,BYTE PTR [bp-50]	;result
	*** 0000fa	2a c0 			sub	al,al
	*** 0000fc	a3 02 00 		mov	WORD PTR $S1367_IntRegisters+2,ax
;|*** 
;|*** 				if (result == BiosResultSuccess)
; Line 126
	*** 0000ff	0a e4 			or	ah,ah
	*** 000101	0f 85 9e 00 		jne	$I1395
;|*** 				{
;|*** 					IntRegisters.AX |= sectorCount;
; Line 128
	*** 000105	8a 4e d8 		mov	cl,BYTE PTR [bp-40]	;sectorCount
	*** 000108	2a ed 			sub	ch,ch
	*** 00010a	0b c1 			or	ax,cx
	*** 00010c	a3 02 00 		mov	WORD PTR $S1367_IntRegisters+2,ax
;|*** 					IntRegisters.Flags &= ~GST_X86_CARRY_FLAG;
; Line 129
					$L1500:
	*** 00010f	80 26 00 00 fe 		and	BYTE PTR $S1367_IntRegisters,254	;00feH
;|*** 				}
;|*** 				else
; Line 131
	*** 000114	e9 91 00 		jmp	$I1396
;|*** 					IntRegisters.Flags |= GST_X86_CARRY_FLAG;
;|*** 
;|*** 				passOriginalRequest = false;
;|*** 			}
;|*** 		}
;|*** 		break;
;|*** 
;|*** 	case 0x42: // Read sectors LBA
; Line 139
					$SC1397:
;|*** 	case 0x43: // Write sectors LBA
;|*** 		{
; Line 141
;	drive = -50
;	lba = -66
;|*** 			byte drive = (byte) regs.DX;
; Line 142
	*** 000117	8a 46 f2 		mov	al,BYTE PTR [bp-14]
	*** 00011a	88 46 ce 		mov	BYTE PTR [bp-50],al	;result
;|*** 			
;|*** 			BiosLbaPacket lba;
;|*** 			CopyMemory (regs.DS, regs.SI, (byte *) &lba, sizeof (lba));
; Line 145
	*** 00011d	6a 10 			push	16	;0010H
	*** 00011f	8d 46 be 		lea	ax,WORD PTR [bp-66]	;lba
	*** 000122	50 			push	ax
	*** 000123	ff 76 f8 		push	WORD PTR [bp-8]
	*** 000126	ff 76 fa 		push	WORD PTR [bp-6]
	*** 000129	e8 00 00 		call	?CopyMemory@@YAXIIPAXI@Z	; CopyMemory
	*** 00012c	83 c4 08 		add	sp,8
;|*** 
;|*** #ifdef GST_TRACE_INT13
;|*** 			PrintVal (": Drive", drive - GST_FIRST_BIOS_DRIVE, false);
;|*** 			PrintVal (" Sec", lba.Sector.LowPart, false);
;|*** 			PrintVal (" Count", lba.SectorCount, false);
;|*** 			PrintVal (" Buf", lba.Buffer, false, true);
;|*** 			PrintEndl();
;|*** #endif
;|*** 
;|*** 			if (ReEntryCount == 0 && drive == EncryptedVirtualPartition.Drive)
; Line 155
	*** 00012f	83 3e 00 00 00 		cmp	WORD PTR $S1373_?ReEntryCount@?1??Int13Filter@@YADXZ@4HA,0
	*** 000134	75 76 			jne	SHORT $SD1413
	*** 000136	a0 01 00 		mov	al,BYTE PTR ?EncryptedVirtualPartition@@3UPartition@@A+1	;EncryptedVirtualPartition
	*** 000139	38 46 ce 		cmp	BYTE PTR [bp-50],al	;result
	*** 00013c	75 6e 			jne	SHORT $SD1413
;|*** 			{
; Line 156
;	result = -48
;	segment = -40
;	offset = -38
;|*** 				BiosResult result;
;|*** 				
;|*** 				uint16 segment = (uint16) (lba.Buffer >> 16);
; Line 159
	*** 00013e	8b 46 c4 		mov	ax,WORD PTR [bp-60]
	*** 000141	89 46 d8 		mov	WORD PTR [bp-40],ax	;sectorCount
;|*** 				uint16 offset = (uint16) lba.Buffer;
; Line 160
	*** 000144	8b 46 c2 		mov	ax,WORD PTR [bp-62]
	*** 000147	89 46 da 		mov	WORD PTR [bp-38],ax	;chs
;|*** 
;|*** 				if (function == 0x43)
; Line 162
	*** 00014a	80 7e e2 43 		cmp	BYTE PTR [bp-30],67	;0043H	;function
	*** 00014e	75 18 			jne	SHORT $I1408
;|*** 					result = WriteEncryptedSectors (segment, offset, drive, lba.Sector, lba.SectorCount);
; Line 163
	*** 000150	ff 76 c0 		push	WORD PTR [bp-64]
	*** 000153	66 ff 76 ca 		push	DWORD PTR [bp-54]
	*** 000157	66 ff 76 c6 		push	DWORD PTR [bp-58]
	*** 00015b	8a 46 ce 		mov	al,BYTE PTR [bp-50]	;result
	*** 00015e	50 			push	ax
	*** 00015f	66 ff 76 d8 		push	DWORD PTR [bp-40]	;sectorCount
	*** 000163	e8 00 00 		call	?WriteEncryptedSectors@@YAEIIETUINT64_STRUCT@@I@Z	; WriteEncryptedSectors
	*** 000166	eb 16 			jmp	SHORT $L1498
					$I1408:
;|*** 				else
;|*** 					result = ReadEncryptedSectors (segment, offset, drive, lba.Sector, lba.SectorCount);
; Line 165
	*** 000168	ff 76 c0 		push	WORD PTR [bp-64]
	*** 00016b	66 ff 76 ca 		push	DWORD PTR [bp-54]
	*** 00016f	66 ff 76 c6 		push	DWORD PTR [bp-58]
	*** 000173	8a 46 ce 		mov	al,BYTE PTR [bp-50]	;result
	*** 000176	50 			push	ax
	*** 000177	66 ff 76 d8 		push	DWORD PTR [bp-40]	;sectorCount
	*** 00017b	e8 00 00 		call	?ReadEncryptedSectors@@YAEIIETUINT64_STRUCT@@I@Z	; ReadEncryptedSectors
					$L1498:
	*** 00017e	83 c4 10 		add	sp,16	;0010H
	*** 000181	88 46 d0 		mov	BYTE PTR [bp-48],al	;sector
;|*** 
;|*** 				__asm cli
; Line 167
	*** 000184	fa 			cli	
;|*** 
;|*** 				memcpy (&IntRegisters, &regs, sizeof (regs));
; Line 169
	*** 000185	6a 1c 			push	28	;001cH
	*** 000187	8d 46 e4 		lea	ax,WORD PTR [bp-28]	;regs
	*** 00018a	50 			push	ax
	*** 00018b	68 00 00 		push	OFFSET DGROUP:$S1367_IntRegisters
	*** 00018e	e8 00 00 		call	_memcpy
	*** 000191	83 c4 06 		add	sp,6
;|*** 				IntRegisters.AX = (IntRegisters.AX & 0xff) | ((uint16) result << 8);
; Line 170
	*** 000194	a0 02 00 		mov	al,BYTE PTR $S1367_IntRegisters+2
	*** 000197	8a 66 d0 		mov	ah,BYTE PTR [bp-48]	;sector
	*** 00019a	a3 02 00 		mov	WORD PTR $S1367_IntRegisters+2,ax
;|*** 
;|*** 				if (result == BiosResultSuccess)
; Line 172
	*** 00019d	0a e4 			or	ah,ah
	*** 00019f	0f 84 6c ff 		je	$L1500
					$I1395:
;|*** 					IntRegisters.Flags |= GST_X86_CARRY_FLAG;
; Line 132
	*** 0001a3	80 0e 00 00 01 		or	BYTE PTR $S1367_IntRegisters,1
					$I1396:
;|*** 
;|*** 				passOriginalRequest = false;
; Line 134
	*** 0001a8	c6 46 e0 00 		mov	BYTE PTR [bp-32],0	;passOriginalRequest
;|*** 			}
;|*** 		}
;|*** 		break;
;|*** 
;|*** 	case 0x42: // Read sectors LBA
;|*** 	case 0x43: // Write sectors LBA
;|*** 		{
;|*** 			byte drive = (byte) regs.DX;
;|*** 			
;|*** 			BiosLbaPacket lba;
;|*** 			CopyMemory (regs.DS, regs.SI, (byte *) &lba, sizeof (lba));
;|*** 
;|*** #ifdef GST_TRACE_INT13
;|*** 			PrintVal (": Drive", drive - GST_FIRST_BIOS_DRIVE, false);
;|*** 			PrintVal (" Sec", lba.Sector.LowPart, false);
;|*** 			PrintVal (" Count", lba.SectorCount, false);
;|*** 			PrintVal (" Buf", lba.Buffer, false, true);
;|*** 			PrintEndl();
;|*** #endif
;|*** 
;|*** 			if (ReEntryCount == 0 && drive == EncryptedVirtualPartition.Drive)
;|*** 			{
;|*** 				BiosResult result;
;|*** 				
;|*** 				uint16 segment = (uint16) (lba.Buffer >> 16);
;|*** 				uint16 offset = (uint16) lba.Buffer;
;|*** 
;|*** 				if (function == 0x43)
;|*** 					result = WriteEncryptedSectors (segment, offset, drive, lba.Sector, lba.SectorCount);
;|*** 				else
;|*** 					result = ReadEncryptedSectors (segment, offset, drive, lba.Sector, lba.SectorCount);
;|*** 
;|*** 				__asm cli
;|*** 
;|*** 				memcpy (&IntRegisters, &regs, sizeof (regs));
;|*** 				IntRegisters.AX = (IntRegisters.AX & 0xff) | ((uint16) result << 8);
;|*** 
;|*** 				if (result == BiosResultSuccess)
;|*** 					IntRegisters.Flags &= ~GST_X86_CARRY_FLAG;
;|*** 				else
;|*** 					IntRegisters.Flags |= GST_X86_CARRY_FLAG;
;|*** 
;|*** 				passOriginalRequest = false;
;|*** 			}
;|*** 		}
;|*** 		break;
;|*** 
;|*** 	default:
; Line 182
					$SD1413:
;|*** #ifdef GST_TRACE_INT13
;|*** 		PrintEndl();
;|*** #endif
;|*** 		break;
;|*** 	}
;|*** 
;|*** #ifdef GST_TRACE_INT13
;|*** 	EnableScreenOutput();
;|*** #endif
;|*** 	--ReEntryCount;
; Line 192
	*** 0001ac	ff 0e 00 00 		dec	WORD PTR $S1373_?ReEntryCount@?1??Int13Filter@@YADXZ@4HA
;|*** 
;|*** 	return passOriginalRequest;
; Line 194
	*** 0001b0	8a 46 e0 		mov	al,BYTE PTR [bp-32]	;passOriginalRequest
;|*** }
; Line 195
	*** 0001b3	c9 			leave	
	*** 0001b4	c3 			ret	

?Int13Filter@@YADXZ	ENDP

?CreateBootLoaderMemoryMapEntry@@YAXPAUBiosMemoryMapEntry@@K@Z	PROC NEAR	; CreateBootLoaderMemoryMapEntry COMDAT
;|*** 
;|*** 
;|*** #define GST_MAX_MEMORY_MAP_SIZE 80
;|*** 
;|*** BiosMemoryMapEntry BiosMemoryMap[GST_MAX_MEMORY_MAP_SIZE];
;|*** static size_t BiosMemoryMapSize;
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void CreateBootLoaderMemoryMapEntry (BiosMemoryMapEntry *newMapEntry, uint32 bootLoaderStart)
;|***  *	\brief Initialize the BiosMemoryMapEntry
;|***  *	\param[in] uint32 bootLoaderStart
;|***  *	\param[in] BiosMemoryMapEntry * newMapEntry
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void CreateBootLoaderMemoryMapEntry (BiosMemoryMapEntry *newMapEntry, uint32 bootLoaderStart)
;|*** {
; Line 214
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	newMapEntry = 4
;	bootLoaderStart = 6
	*** 000003	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;newMapEntry
;|*** 	newMapEntry->Type = 0x2;
; Line 215
	*** 000006	66 c7 47 10 02 00 00 00 mov	DWORD PTR [bx+16],2
;|*** 	newMapEntry->BaseAddress.HighPart = 0;
; Line 216
	*** 00000e	66 c7 47 04 00 00 00 00 mov	DWORD PTR [bx+4],0
;|*** 	newMapEntry->BaseAddress.LowPart = bootLoaderStart;
; Line 217
	*** 000016	66 8b 46 06 		mov	eax,DWORD PTR [bp+6]	;bootLoaderStart
	*** 00001a	66 89 07 		mov	DWORD PTR [bx],eax
;|*** 	newMapEntry->Length.HighPart = 0;
; Line 218
	*** 00001d	66 2b c0 		sub	eax,eax
	*** 000020	66 89 47 0c 		mov	DWORD PTR [bx+12],eax
;|*** 	newMapEntry->Length.LowPart = GST_BOOT_MEMORY_REQUIRED * 1024UL;
; Line 219
	*** 000024	c7 47 08 00 a0 		mov	WORD PTR [bx+8],-24576	;a000H
	*** 000029	89 47 0a 		mov	WORD PTR [bx+10],ax
;|*** }
; Line 220
	*** 00002c	c9 			leave	
	*** 00002d	c3 			ret	

?CreateBootLoaderMemoryMapEntry@@YAXPAUBiosMemoryMapEntry@@K@Z	ENDP

?CreateNewBiosMemoryMap@@YADXZ	PROC NEAR	; CreateNewBiosMemoryMap COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static bool CreateNewBiosMemoryMap ()
;|***  *	\brief Create a new BIOS memory map presenting the memory area of the loader as reserved
;|***  *	\return static bool false if Map overflow
;|***  *			true else
;|***  *
;|***  */
;|*** static bool CreateNewBiosMemoryMap ()
;|*** {
; Line 232
	*** 000000	c8 40 00 00 		enter	64,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	entry = -20
;	newMapEntry = -22
;	mapEnd = -24
;	bootLoaderStart = -32
;	codeSeg = -34
;	bootLoaderEnd = -42
;	loaderEntryInserted = -44
;	overSize = -46
;|*** 	// Create a new BIOS memory map presenting the memory area of the loader as reserved
;|*** 
;|*** 	BiosMemoryMapSize = 0;
; Line 235
	*** 000006	c7 06 00 00 00 00 	mov	WORD PTR $S1415_BiosMemoryMapSize,0
;|*** 	BiosMemoryMapEntry entry;
;|*** 	BiosMemoryMapEntry *newMapEntry = BiosMemoryMap;
; Line 237
	*** 00000c	c7 46 ea 00 00 		mov	WORD PTR [bp-22],OFFSET DGROUP:?BiosMemoryMap@@3QAUBiosMemoryMapEntry@@A	;newMapEntry	;BiosMemoryMap
;|*** 
;|*** 	const BiosMemoryMapEntry *mapEnd = BiosMemoryMap + GST_MAX_MEMORY_MAP_SIZE;
; Line 239
	*** 000011	c7 46 e8 40 06 		mov	WORD PTR [bp-24],OFFSET DGROUP:?BiosMemoryMap@@3QAUBiosMemoryMapEntry@@A+1600	;mapEnd	;BiosMemoryMap
;|*** 
;|*** 	uint64 bootLoaderStart;
;|*** 	bootLoaderStart.HighPart = 0;
; Line 242
	*** 000016	66 2b c0 		sub	eax,eax
	*** 000019	66 89 46 e4 		mov	DWORD PTR [bp-28],eax
;|*** 
;|*** 	uint16 codeSeg;
;|*** 	__asm mov codeSeg, cs
; Line 245
	*** 00001d	8c 4e de 		mov	WORD PTR [bp-34],cs	;codeSeg
;|*** 	bootLoaderStart.LowPart = GetLinearAddress (codeSeg, 0);
; Line 246
	*** 000020	6a 00 			push	0
	*** 000022	ff 76 de 		push	WORD PTR [bp-34]	;codeSeg
	*** 000025	e8 00 00 		call	?GetLinearAddress@@YAKII@Z	; GetLinearAddress
	*** 000028	83 c4 04 		add	sp,4
	*** 00002b	89 46 e0 		mov	WORD PTR [bp-32],ax	;bootLoaderStart
	*** 00002e	89 56 e2 		mov	WORD PTR [bp-30],dx
;|*** 
;|*** 	uint64 bootLoaderEnd;
;|*** 	bootLoaderEnd.HighPart = 0;
; Line 249
	*** 000031	66 c7 46 da 00 00 00 00 mov	DWORD PTR [bp-38],0
;|*** 	bootLoaderEnd.LowPart = bootLoaderStart.LowPart + GST_BOOT_MEMORY_REQUIRED * 1024UL;
; Line 250
	*** 000039	8b 46 e0 		mov	ax,WORD PTR [bp-32]	;bootLoaderStart
	*** 00003c	80 c4 a0 		add	ah,160	;00a0H
	*** 00003f	83 d2 00 		adc	dx,0
	*** 000042	89 46 d6 		mov	WORD PTR [bp-42],ax	;bootLoaderEnd
	*** 000045	89 56 d8 		mov	WORD PTR [bp-40],dx
;|*** 
;|*** 	bool loaderEntryInserted = false;
; Line 252
	*** 000048	c6 46 d4 00 		mov	BYTE PTR [bp-44],0	;loaderEntryInserted
;|*** 
;|*** 	if (GetFirstBiosMemoryMapEntry (entry))
; Line 254
	*** 00004c	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;entry
	*** 00004f	50 			push	ax
	*** 000050	e8 00 00 		call	?GetFirstBiosMemoryMapEntry@@YADAAUBiosMemoryMapEntry@@@Z	; GetFirstBiosMemoryMapEntry
	*** 000053	5b 			pop	bx
	*** 000054	0a c0 			or	al,al
	*** 000056	0f 84 7a 01 		je	$I1430
;|*** 	{
;|*** 		do
; Line 256
					$D1431:
;|*** 		{
; Line 257
;	entryEnd = -54
;|*** 			uint64 entryEnd = entry.BaseAddress + entry.Length;
; Line 258
	*** 00005a	8d 46 f4 		lea	ax,WORD PTR [bp-12]
	*** 00005d	50 			push	ax
	*** 00005e	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;entry
	*** 000061	50 			push	ax
	*** 000062	8d 4e c2 		lea	cx,WORD PTR [bp-62]
	*** 000065	51 			push	cx
	*** 000066	e8 00 00 		call	??H@YA?ATUINT64_STRUCT@@ABT0@0@Z	; operator+
	*** 000069	83 c4 06 		add	sp,6
	*** 00006c	8d 7e ca 		lea	di,WORD PTR [bp-54]	;entryEnd
	*** 00006f	8b f0 			mov	si,ax
	*** 000071	16 			push	ss
	*** 000072	07 			pop	es
	*** 000073	66 a5 			movsd
	*** 000075	66 a5 			movsd
;|*** 
;|*** 			if (entry.Type == 0x1 && RegionsIntersect (bootLoaderStart, GST_BOOT_MEMORY_REQUIRED * 1024UL, entry.BaseAddress, entryEnd - 1))
; Line 260
	*** 000077	66 83 7e fc 01 		cmp	DWORD PTR [bp-4],1
	*** 00007c	0f 85 f7 00 		jne	$I1437
	*** 000080	6a 00 			push	0
	*** 000082	6a 01 			push	1
	*** 000084	8d 46 ca 		lea	ax,WORD PTR [bp-54]	;entryEnd
	*** 000087	50 			push	ax
	*** 000088	8d 46 c2 		lea	ax,WORD PTR [bp-62]
	*** 00008b	50 			push	ax
	*** 00008c	e8 00 00 		call	??G@YA?ATUINT64_STRUCT@@ABT0@K@Z	; operator-
	*** 00008f	83 c4 08 		add	sp,8
	*** 000092	50 			push	ax
	*** 000093	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;entry
	*** 000096	50 			push	ax
	*** 000097	6a 00 			push	0
	*** 000099	68 00 a0 		push	-24576	;a000H
	*** 00009c	8d 4e e0 		lea	cx,WORD PTR [bp-32]	;bootLoaderStart
	*** 00009f	51 			push	cx
	*** 0000a0	e8 00 00 		call	?RegionsIntersect@@YADABTUINT64_STRUCT@@K00@Z	; RegionsIntersect
	*** 0000a3	83 c4 0a 		add	sp,10	;000aH
	*** 0000a6	0a c0 			or	al,al
	*** 0000a8	0f 84 cb 00 		je	$I1437
;|*** 			{
;|*** 				// Free map entry covers the boot loader area
;|*** 
;|*** 				if (entry.BaseAddress < bootLoaderStart)
; Line 264
	*** 0000ac	8d 46 e0 		lea	ax,WORD PTR [bp-32]	;bootLoaderStart
	*** 0000af	50 			push	ax
	*** 0000b0	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;entry
	*** 0000b3	50 			push	ax
	*** 0000b4	e8 00 00 		call	??M@YADABTUINT64_STRUCT@@0@Z	; operator<
	*** 0000b7	83 c4 04 		add	sp,4
	*** 0000ba	0a c0 			or	al,al
	*** 0000bc	74 41 			je	SHORT $I1438
;|*** 				{
;|*** 					// Create free entry below the boot loader area
;|*** 					if (newMapEntry >= mapEnd)
; Line 267
	*** 0000be	8b 46 ea 		mov	ax,WORD PTR [bp-22]	;newMapEntry
	*** 0000c1	39 46 e8 		cmp	WORD PTR [bp-24],ax	;mapEnd
	*** 0000c4	77 08 			ja	SHORT $I1439
;|*** 						goto mapOverflow;
; Line 268
					$mapOverflow1440:
;|*** 
;|*** 					*newMapEntry = entry;
;|*** 					newMapEntry->Length = bootLoaderStart - entry.BaseAddress;
;|*** 					++newMapEntry;
;|*** 				}
;|*** 
;|*** 				if (!loaderEntryInserted)
;|*** 				{
;|*** 					// Create reserved entry for the boot loader if it has not been done yet
;|*** 					if (newMapEntry >= mapEnd)
;|*** 						goto mapOverflow;
;|*** 
;|*** 					CreateBootLoaderMemoryMapEntry (newMapEntry, bootLoaderStart.LowPart);
;|*** 					++newMapEntry;
;|*** 					loaderEntryInserted = true;
;|*** 				}
;|*** 
;|*** 				if (bootLoaderEnd < entryEnd)
;|*** 				{
;|*** 					// Create free entry above the boot loader area
;|*** 					if (newMapEntry >= mapEnd)
;|*** 						goto mapOverflow;
;|*** 
;|*** 					newMapEntry->Type = 0x1;
;|*** 					newMapEntry->BaseAddress = bootLoaderEnd;
;|*** 					newMapEntry->Length = entryEnd - bootLoaderEnd;
;|*** 					++newMapEntry;
;|*** 				}
;|*** 			}
;|*** 			else
;|*** 			{
;|*** 				if (newMapEntry >= mapEnd)
;|*** 					goto mapOverflow;
;|*** 
;|*** 				if (!loaderEntryInserted && entry.BaseAddress > bootLoaderStart)
;|*** 				{
;|*** 					// Create reserved entry for the boot loader if it has not been done yet
;|*** 					CreateBootLoaderMemoryMapEntry (newMapEntry, bootLoaderStart.LowPart);
;|*** 					++newMapEntry;
;|*** 					loaderEntryInserted = true;
;|*** 				}
;|*** 
;|*** 				// Copy map entry
;|*** 				*newMapEntry++ = entry;
;|*** 			}
;|*** 
;|*** 		} while (GetNextBiosMemoryMapEntry (entry));
;|*** 	}
;|*** 
;|*** 	BiosMemoryMapSize = newMapEntry - BiosMemoryMap;
;|*** 	return true;
;|*** 
;|*** mapOverflow:
;|*** 	size_t overSize = 0;
; Line 322
	*** 0000c6	c7 46 d2 00 00 		mov	WORD PTR [bp-46],0	;overSize
;|*** 	while (GetNextBiosMemoryMapEntry (entry))
; Line 323
	*** 0000cb	e9 1c 01 		jmp	$L1506
					$I1439:
	*** 0000ce	8d 76 ec 		lea	si,WORD PTR [bp-20]	;entry
	*** 0000d1	1e 			push	ds
	*** 0000d2	07 			pop	es
	*** 0000d3	8b 7e ea 		mov	di,WORD PTR [bp-22]	;newMapEntry
	*** 0000d6	b9 0a 00 		mov	cx,10	;000aH
	*** 0000d9	f3 			rep
	*** 0000da	a5 			movsw
;|*** 					newMapEntry->Length = bootLoaderStart - entry.BaseAddress;
; Line 271
	*** 0000db	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;entry
	*** 0000de	50 			push	ax
	*** 0000df	8d 46 e0 		lea	ax,WORD PTR [bp-32]	;bootLoaderStart
	*** 0000e2	50 			push	ax
	*** 0000e3	8d 46 c2 		lea	ax,WORD PTR [bp-62]
	*** 0000e6	50 			push	ax
	*** 0000e7	e8 00 00 		call	??G@YA?ATUINT64_STRUCT@@ABT0@0@Z	; operator-
	*** 0000ea	83 c4 06 		add	sp,6
	*** 0000ed	8b 5e ea 		mov	bx,WORD PTR [bp-22]	;newMapEntry
	*** 0000f0	8d 7f 08 		lea	di,WORD PTR [bx+8]
	*** 0000f3	8b f0 			mov	si,ax
	*** 0000f5	1e 			push	ds
	*** 0000f6	07 			pop	es
	*** 0000f7	66 a5 			movsd
	*** 0000f9	66 a5 			movsd
;|*** 					++newMapEntry;
; Line 272
	*** 0000fb	83 46 ea 14 		add	WORD PTR [bp-22],20	;0014H	;newMapEntry
;|*** 				}
;|*** 
;|*** 				if (!loaderEntryInserted)
; Line 275
					$I1438:
	*** 0000ff	80 7e d4 00 		cmp	BYTE PTR [bp-44],0	;loaderEntryInserted
	*** 000103	75 1b 			jne	SHORT $I1443
;|*** 				{
;|*** 					// Create reserved entry for the boot loader if it has not been done yet
;|*** 					if (newMapEntry >= mapEnd)
; Line 278
	*** 000105	8b 46 ea 		mov	ax,WORD PTR [bp-22]	;newMapEntry
	*** 000108	39 46 e8 		cmp	WORD PTR [bp-24],ax	;mapEnd
	*** 00010b	76 b9 			jbe	SHORT $mapOverflow1440
;|*** 						goto mapOverflow;
; Line 279
	*** 00010d	66 ff 76 e0 		push	DWORD PTR [bp-32]	;bootLoaderStart
	*** 000111	50 			push	ax
	*** 000112	e8 00 00 		call	?CreateBootLoaderMemoryMapEntry@@YAXPAUBiosMemoryMapEntry@@K@Z	; CreateBootLoaderMemoryMapEntry
	*** 000115	83 c4 06 		add	sp,6
;|*** 
;|*** 					CreateBootLoaderMemoryMapEntry (newMapEntry, bootLoaderStart.LowPart);
;|*** 					++newMapEntry;
; Line 282
	*** 000118	83 46 ea 14 		add	WORD PTR [bp-22],20	;0014H	;newMapEntry
;|*** 					loaderEntryInserted = true;
; Line 283
	*** 00011c	c6 46 d4 01 		mov	BYTE PTR [bp-44],1	;loaderEntryInserted
;|*** 				}
;|*** 
;|*** 				if (bootLoaderEnd < entryEnd)
; Line 286
					$I1443:
	*** 000120	8d 46 ca 		lea	ax,WORD PTR [bp-54]	;entryEnd
	*** 000123	50 			push	ax
	*** 000124	8d 46 d6 		lea	ax,WORD PTR [bp-42]	;bootLoaderEnd
	*** 000127	50 			push	ax
	*** 000128	e8 00 00 		call	??M@YADABTUINT64_STRUCT@@0@Z	; operator<
	*** 00012b	83 c4 04 		add	sp,4
	*** 00012e	0a c0 			or	al,al
	*** 000130	0f 84 92 00 		je	$I1450
;|*** 				{
;|*** 					// Create free entry above the boot loader area
;|*** 					if (newMapEntry >= mapEnd)
; Line 289
	*** 000134	8b 46 ea 		mov	ax,WORD PTR [bp-22]	;newMapEntry
	*** 000137	39 46 e8 		cmp	WORD PTR [bp-24],ax	;mapEnd
	*** 00013a	76 43 			jbe	SHORT $L1508
;|*** 						goto mapOverflow;
; Line 290
	*** 00013c	8b d8 			mov	bx,ax
	*** 00013e	66 c7 47 10 01 00 00 00 mov	DWORD PTR [bx+16],1
;|*** 
;|*** 					newMapEntry->Type = 0x1;
;|*** 					newMapEntry->BaseAddress = bootLoaderEnd;
; Line 293
	*** 000146	8b f8 			mov	di,ax
	*** 000148	8d 76 d6 		lea	si,WORD PTR [bp-42]	;bootLoaderEnd
	*** 00014b	1e 			push	ds
	*** 00014c	07 			pop	es
	*** 00014d	66 a5 			movsd
	*** 00014f	66 a5 			movsd
;|*** 					newMapEntry->Length = entryEnd - bootLoaderEnd;
; Line 294
	*** 000151	8d 46 d6 		lea	ax,WORD PTR [bp-42]	;bootLoaderEnd
	*** 000154	50 			push	ax
	*** 000155	8d 46 ca 		lea	ax,WORD PTR [bp-54]	;entryEnd
	*** 000158	50 			push	ax
	*** 000159	8d 46 c2 		lea	ax,WORD PTR [bp-62]
	*** 00015c	50 			push	ax
	*** 00015d	e8 00 00 		call	??G@YA?ATUINT64_STRUCT@@ABT0@0@Z	; operator-
	*** 000160	83 c4 06 		add	sp,6
	*** 000163	8b 5e ea 		mov	bx,WORD PTR [bp-22]	;newMapEntry
	*** 000166	8d 7f 08 		lea	di,WORD PTR [bx+8]
	*** 000169	8b f0 			mov	si,ax
	*** 00016b	1e 			push	ds
	*** 00016c	07 			pop	es
	*** 00016d	66 a5 			movsd
	*** 00016f	66 a5 			movsd
;|*** 					++newMapEntry;
; Line 295
	*** 000171	83 46 ea 14 		add	WORD PTR [bp-22],20	;0014H	;newMapEntry
;|*** 				}
;|*** 			}
;|*** 			else
; Line 298
	*** 000175	eb 4f 			jmp	SHORT $I1450
					$I1437:
;|*** 			{
;|*** 				if (newMapEntry >= mapEnd)
; Line 300
	*** 000177	8b 46 ea 		mov	ax,WORD PTR [bp-22]	;newMapEntry
	*** 00017a	39 46 e8 		cmp	WORD PTR [bp-24],ax	;mapEnd
	*** 00017d	77 03 			ja	SHORT $L1507
;|*** 					goto mapOverflow;
; Line 301
					$L1508:
	*** 00017f	e9 44 ff 		jmp	$mapOverflow1440
					$L1507:
	*** 000182	80 7e d4 00 		cmp	BYTE PTR [bp-44],0	;loaderEntryInserted
	*** 000186	75 27 			jne	SHORT $I1453
	*** 000188	8d 46 e0 		lea	ax,WORD PTR [bp-32]	;bootLoaderStart
	*** 00018b	50 			push	ax
	*** 00018c	8d 4e ec 		lea	cx,WORD PTR [bp-20]	;entry
	*** 00018f	51 			push	cx
	*** 000190	e8 00 00 		call	??O@YADABTUINT64_STRUCT@@0@Z	; operator>
	*** 000193	83 c4 04 		add	sp,4
	*** 000196	0a c0 			or	al,al
	*** 000198	74 15 			je	SHORT $I1453
;|*** 
;|*** 				if (!loaderEntryInserted && entry.BaseAddress > bootLoaderStart)
;|*** 				{
;|*** 					// Create reserved entry for the boot loader if it has not been done yet
;|*** 					CreateBootLoaderMemoryMapEntry (newMapEntry, bootLoaderStart.LowPart);
; Line 306
	*** 00019a	66 ff 76 e0 		push	DWORD PTR [bp-32]	;bootLoaderStart
	*** 00019e	ff 76 ea 		push	WORD PTR [bp-22]	;newMapEntry
	*** 0001a1	e8 00 00 		call	?CreateBootLoaderMemoryMapEntry@@YAXPAUBiosMemoryMapEntry@@K@Z	; CreateBootLoaderMemoryMapEntry
	*** 0001a4	83 c4 06 		add	sp,6
;|*** 					++newMapEntry;
; Line 307
	*** 0001a7	83 46 ea 14 		add	WORD PTR [bp-22],20	;0014H	;newMapEntry
;|*** 					loaderEntryInserted = true;
; Line 308
	*** 0001ab	c6 46 d4 01 		mov	BYTE PTR [bp-44],1	;loaderEntryInserted
;|*** 				}
;|*** 
;|*** 				// Copy map entry
;|*** 				*newMapEntry++ = entry;
; Line 312
					$I1453:
	*** 0001af	8b 46 ea 		mov	ax,WORD PTR [bp-22]	;newMapEntry
	*** 0001b2	83 46 ea 14 		add	WORD PTR [bp-22],20	;0014H	;newMapEntry
	*** 0001b6	89 46 c0 		mov	WORD PTR [bp-64],ax
	*** 0001b9	8d 76 ec 		lea	si,WORD PTR [bp-20]	;entry
	*** 0001bc	1e 			push	ds
	*** 0001bd	07 			pop	es
	*** 0001be	8b 7e c0 		mov	di,WORD PTR [bp-64]
	*** 0001c1	b9 0a 00 		mov	cx,10	;000aH
	*** 0001c4	f3 			rep
	*** 0001c5	a5 			movsw
;|*** 			}
; Line 313
					$I1450:
;|*** 
;|*** 		} while (GetNextBiosMemoryMapEntry (entry));
; Line 315
	*** 0001c6	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;entry
	*** 0001c9	50 			push	ax
	*** 0001ca	e8 00 00 		call	?GetNextBiosMemoryMapEntry@@YADAAUBiosMemoryMapEntry@@@Z	; GetNextBiosMemoryMapEntry
	*** 0001cd	5b 			pop	bx
	*** 0001ce	0a c0 			or	al,al
	*** 0001d0	0f 85 86 fe 		jne	$D1431
;|*** 	}
;|*** 
;|*** 	BiosMemoryMapSize = newMapEntry - BiosMemoryMap;
; Line 318
					$I1430:
	*** 0001d4	8b 46 ea 		mov	ax,WORD PTR [bp-22]	;newMapEntry
	*** 0001d7	2d 00 00 		sub	ax,OFFSET DGROUP:?BiosMemoryMap@@3QAUBiosMemoryMapEntry@@A	;BiosMemoryMap
	*** 0001da	b9 14 00 		mov	cx,20	;0014H
	*** 0001dd	99 			cwd	
	*** 0001de	f7 f9 			idiv	cx
	*** 0001e0	a3 00 00 		mov	WORD PTR $S1415_BiosMemoryMapSize,ax
;|*** 	return true;
; Line 319
	*** 0001e3	b0 01 			mov	al,1
	*** 0001e5	eb 26 			jmp	SHORT $EX1422
;|*** 
;|*** mapOverflow:
; Line 321
					$FC1456:
;|*** 	size_t overSize = 0;
;|*** 	while (GetNextBiosMemoryMapEntry (entry))
;|*** 	{
;|*** 		++overSize;
; Line 325
	*** 0001e7	ff 46 d2 		inc	WORD PTR [bp-46]	;overSize
;|*** 	}
; Line 326
					$L1506:
	*** 0001ea	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;entry
	*** 0001ed	50 			push	ax
	*** 0001ee	e8 00 00 		call	?GetNextBiosMemoryMapEntry@@YADAAUBiosMemoryMapEntry@@@Z	; GetNextBiosMemoryMapEntry
	*** 0001f1	5b 			pop	bx
	*** 0001f2	0a c0 			or	al,al
	*** 0001f4	75 f1 			jne	SHORT $FC1456
;|*** 
;|*** 	PrintErrorNoEndl ("MMP:");
; Line 328
	*** 0001f6	68 00 00 		push	OFFSET DGROUP:??_C@_04PLFG@MMP?3?$AA@
	*** 0001f9	e8 00 00 		call	?PrintErrorNoEndl@@YAXPBD@Z	; PrintErrorNoEndl
	*** 0001fc	5b 			pop	bx
;|*** 	Print (overSize);
; Line 329
	*** 0001fd	6a 00 			push	0
	*** 0001ff	ff 76 d2 		push	WORD PTR [bp-46]	;overSize
	*** 000202	e8 00 00 		call	?Print@@YAXK@Z	; Print
	*** 000205	83 c4 04 		add	sp,4
;|*** 	PrintEndl();
; Line 330
	*** 000208	e8 00 00 		call	?PrintEndl@@YAXXZ	; PrintEndl
;|*** 
;|*** 	return false;
; Line 332
	*** 00020b	32 c0 			xor	al,al
;|*** }
; Line 333
					$EX1422:
	*** 00020d	5e 			pop	si
	*** 00020e	5f 			pop	di
	*** 00020f	c9 			leave	
	*** 000210	c3 			ret	

?CreateNewBiosMemoryMap@@YADXZ	ENDP
	PUBLIC	?Int15Filter@@YADXZ	; Int15Filter
?Int15Filter@@YADXZ	PROC NEAR	; Int15Filter COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn bool Int15Filter ()
;|***  *	\brief Filter int 15
;|***  *	\return bool false
;|***  *
;|***  */
;|*** bool Int15Filter ()
;|*** {
; Line 344
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;|*** 	CheckStack();
;|*** 
;|*** #ifdef GST_TRACE_INT15
;|*** 	DisableScreenOutput();
;|*** 
;|*** 	Print ("15-");
;|*** 	PrintHex (IntRegisters.AX);
;|*** 
;|*** 	Print (" SS:"); PrintHex (IntRegisters.SS);
;|*** 
;|*** 	uint16 spdbg;
;|*** 	__asm mov spdbg, sp
;|*** 	PrintChar (' ');
;|*** 	PrintHex (spdbg);
;|*** 	PrintChar ('<'); PrintHex (GST_BOOT_LOADER_STACK_TOP);
;|*** 
;|*** 	Print (" EAX:"); PrintHex (IntRegisters.EAX);
;|*** 	Print (" EBX:"); PrintHex (IntRegisters.EBX);
;|*** 	Print (" ECX:"); PrintHex (IntRegisters.ECX);
;|*** 	Print (" EDX:"); PrintHex (IntRegisters.EDX);
;|*** 	Print (" DI:"); PrintHex (IntRegisters.DI);
;|*** 	PrintEndl();
;|*** 
;|*** #endif
;|*** 
;|*** 	if (IntRegisters.EBX >= BiosMemoryMapSize)
; Line 370
	*** 000005	a1 00 00 		mov	ax,WORD PTR $S1415_BiosMemoryMapSize
	*** 000008	2b d2 			sub	dx,dx
	*** 00000a	3b 16 08 00 		cmp	dx,WORD PTR $S1367_IntRegisters+8
	*** 00000e	77 1c 			ja	SHORT $I1462
	*** 000010	72 06 			jb	SHORT $L1495
	*** 000012	3b 06 06 00 		cmp	ax,WORD PTR $S1367_IntRegisters+6
	*** 000016	77 14 			ja	SHORT $I1462
					$L1495:
;|*** 	{
;|*** 		IntRegisters.Flags |= GST_X86_CARRY_FLAG;
; Line 372
	*** 000018	80 0e 00 00 01 		or	BYTE PTR $S1367_IntRegisters,1
;|*** 		IntRegisters.EBX = 0;
; Line 373
	*** 00001d	66 2b c0 		sub	eax,eax
	*** 000020	66 a3 06 00 		mov	DWORD PTR $S1367_IntRegisters+6,eax
;|*** 		IntRegisters.AX = -1;
; Line 374
	*** 000024	c7 06 02 00 ff ff 	mov	WORD PTR $S1367_IntRegisters+2,-1	;ffffH
;|*** 	}
;|*** 	else
; Line 376
	*** 00002a	eb 52 			jmp	SHORT $I1463
					$I1462:
;|*** 	{
;|*** 		CopyMemory ((byte *) &BiosMemoryMap[IntRegisters.EBX], IntRegisters.ES, IntRegisters.DI, sizeof (BiosMemoryMap[0]));
; Line 378
	*** 00002c	6a 14 			push	20	;0014H
	*** 00002e	ff 36 12 00 		push	WORD PTR $S1367_IntRegisters+18
	*** 000032	ff 36 18 00 		push	WORD PTR $S1367_IntRegisters+24
	*** 000036	6b 06 06 00 14 		imul	ax,WORD PTR $S1367_IntRegisters+6,20	;0014H
	*** 00003b	05 00 00 		add	ax,OFFSET DGROUP:?BiosMemoryMap@@3QAUBiosMemoryMapEntry@@A	;BiosMemoryMap
	*** 00003e	50 			push	ax
	*** 00003f	e8 00 00 		call	?CopyMemory@@YAXPAXIII@Z	; CopyMemory
	*** 000042	83 c4 08 		add	sp,8
;|*** 
;|*** 		IntRegisters.Flags &= ~GST_X86_CARRY_FLAG;
; Line 380
	*** 000045	80 26 00 00 fe 		and	BYTE PTR $S1367_IntRegisters,254	;00feH
;|*** 		IntRegisters.EAX = 0x534D4150UL;
; Line 381
	*** 00004a	66 c7 06 02 00 50 41 4d 53 mov	DWORD PTR $S1367_IntRegisters+2,1397571920	;534d4150H
;|*** 
;|*** 		++IntRegisters.EBX;
;|*** 		if (IntRegisters.EBX >= BiosMemoryMapSize)
; Line 384
	*** 000053	66 ff 06 06 00 		inc	DWORD PTR $S1367_IntRegisters+6
	*** 000058	a1 00 00 		mov	ax,WORD PTR $S1415_BiosMemoryMapSize
	*** 00005b	2b d2 			sub	dx,dx
	*** 00005d	3b 16 08 00 		cmp	dx,WORD PTR $S1367_IntRegisters+8
	*** 000061	77 11 			ja	SHORT $I1465
	*** 000063	72 06 			jb	SHORT $L1496
	*** 000065	3b 06 06 00 		cmp	ax,WORD PTR $S1367_IntRegisters+6
	*** 000069	77 09 			ja	SHORT $I1465
					$L1496:
;|*** 			IntRegisters.EBX = 0;
; Line 385
	*** 00006b	66 c7 06 06 00 00 00 00 00 mov	DWORD PTR $S1367_IntRegisters+6,0
;|*** 
;|*** 		IntRegisters.ECX = sizeof (BiosMemoryMap[0]);
; Line 387
					$I1465:
	*** 000074	c7 06 0a 00 14 00 	mov	WORD PTR $S1367_IntRegisters+10,20	;0014H
	*** 00007a	89 16 0c 00 		mov	WORD PTR $S1367_IntRegisters+12,dx
;|*** 	}
; Line 388
					$I1463:
;|*** 
;|*** 	if (IntRegisters.EBX == 0 && !(BootSectorFlags & GST_BOOT_CFG_FLAG_WINDOWS_VISTA_OR_LATER))
; Line 390
	*** 00007e	a1 08 00 		mov	ax,WORD PTR $S1367_IntRegisters+8
	*** 000081	0b 06 06 00 		or	ax,WORD PTR $S1367_IntRegisters+6
	*** 000085	75 2d 			jne	SHORT $I1469
	*** 000087	f6 06 00 00 04 		test	BYTE PTR ?BootSectorFlags@@3EA,4	;BootSectorFlags
	*** 00008c	75 26 			jne	SHORT $I1469
;|*** 	{
;|*** 		// Uninstall filter when the modified map has been issued three times to prevent
;|*** 		// problems with hardware drivers on some notebooks running Windows XP.
;|*** 
;|*** 		static int CompleteMapIssueCount = 0;
;|*** 		if (++CompleteMapIssueCount >= 3)
; Line 396
	*** 00008e	ff 06 00 00 		inc	WORD PTR $S1468_?CompleteMapIssueCount@?5??Int15Filter@@YADXZ@4HA
	*** 000092	83 3e 00 00 03 		cmp	WORD PTR $S1468_?CompleteMapIssueCount@?5??Int15Filter@@YADXZ@4HA,3
	*** 000097	7c 1b 			jl	SHORT $I1469
;|*** 		{
;|*** 			__asm
;|*** 			{
;|*** 				cli
; Line 400
	*** 000099	fa 			cli	
;|*** 				push es
; Line 401
	*** 00009a	06 			push	es
;|*** 
;|*** 				lea si, OriginalInt15Handler
; Line 403
	*** 00009b	8d 36 00 00 		lea	si,WORD PTR $S1366_OriginalInt15Handler
;|*** 				xor ax, ax
; Line 404
	*** 00009f	33 c0 			xor	ax,ax
;|*** 				mov es, ax
; Line 405
	*** 0000a1	8e c0 			mov	es,ax
;|*** 				mov di, 0x15 * 4
; Line 406
	*** 0000a3	bf 54 00 		mov	di,84	;0054H
;|*** 
;|*** 				mov ax, [si]
; Line 408
	*** 0000a6	8b 04 			mov	ax,WORD PTR [si]
;|*** 				mov es:[di], ax
; Line 409
	*** 0000a8	26 89 05 		mov	WORD PTR es:[di],ax
;|*** 				mov ax, [si + 2]
; Line 410
	*** 0000ab	8b 44 02 		mov	ax,WORD PTR [si+2]
;|*** 				mov es:[di + 2], ax
; Line 411
	*** 0000ae	26 89 45 02 		mov	WORD PTR es:[di+2],ax
;|*** 
;|*** 				pop es
; Line 413
	*** 0000b2	07 			pop	es
;|*** 				sti
; Line 414
	*** 0000b3	fb 			sti	
;|*** 			}
; Line 415
;|*** 		}
;|*** 	}
; Line 417
					$I1469:
;|*** 
;|*** #ifdef GST_TRACE_INT15
;|*** 	BiosMemoryMapEntry entry;
;|*** 	CopyMemory (IntRegisters.ES, IntRegisters.DI, (byte *) &entry, sizeof (entry));
;|*** 	PrintHex (entry.Type); PrintChar (' ');
;|*** 	PrintHex (entry.BaseAddress); PrintChar (' ');
;|*** 	PrintHex (entry.Length); PrintChar (' ');
;|*** 	PrintHex (entry.BaseAddress + entry.Length); PrintEndl();
;|*** 
;|*** 	Print ("EAX:"); PrintHex (IntRegisters.EAX);
;|*** 	Print (" EBX:"); PrintHex (IntRegisters.EBX);
;|*** 	Print (" ECX:"); PrintHex (IntRegisters.ECX);
;|*** 	Print (" EDX:"); PrintHex (IntRegisters.EDX);
;|*** 	Print (" DI:"); PrintHex (IntRegisters.DI);
;|*** 	Print (" FL:"); PrintHex (IntRegisters.Flags);
;|*** 	PrintEndl (2);
;|*** #endif
;|*** 
;|*** #ifdef GST_TRACE_INT15
;|*** 	EnableScreenOutput();
;|*** #endif
;|*** 	return false;
; Line 439
	*** 0000b4	32 c0 			xor	al,al
;|*** }
; Line 440
	*** 0000b6	5e 			pop	si
	*** 0000b7	5f 			pop	di
	*** 0000b8	c9 			leave	
	*** 0000b9	c3 			ret	

?Int15Filter@@YADXZ	ENDP
	PUBLIC	?IntFilterEntry@@YAXXZ	; IntFilterEntry
?IntFilterEntry@@YAXXZ	PROC NEAR	; IntFilterEntry COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void IntFilterEntry ()
;|***  *	\brief Filter an int request
;|***  *	\return void
;|***  *
;|***  */
;|*** void IntFilterEntry ()
;|*** {
; Line 451
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;|*** 	// No automatic variables should be used in this scope as SS may change
;|*** 	static uint16 OrigStackPointer;
;|*** 	static uint16 OrigStackSegment;
;|*** 
;|*** 	__asm
;|*** 	{
;|*** 		pushf
; Line 458
	*** 000005	9c 			pushf	
;|*** 		pushad
; Line 459
	*** 000006	66 60 			pushad
;|*** 
;|*** 		cli
; Line 461
	*** 000008	fa 			cli	
;|*** 		mov cs:IntRegisters.DI, di
; Line 462
	*** 000009	2e 89 3e 12 00 		mov	WORD PTR cs:$S1367_IntRegisters+18,di
;|*** 
;|*** 		lea di, cs:IntRegisters.EAX
; Line 464
	*** 00000e	2e 8d 3e 02 00 		lea	di,WORD PTR cs:$S1367_IntRegisters+2
;|*** 		GST_ASM_EMIT4 (66,2E,89,05) // mov [cs:di], eax
; Line 465
	*** 000013	66 			DB	102	;0066H
	*** 000014	2e 			DB	46	;002eH
	*** 000015	89 			DB	137	;0089H
	*** 000016	05 			DB	5
;|*** 		lea di, cs:IntRegisters.EBX
; Line 466
	*** 000017	2e 8d 3e 06 00 		lea	di,WORD PTR cs:$S1367_IntRegisters+6
;|*** 		GST_ASM_EMIT4 (66,2E,89,1D) // mov [cs:di], ebx
; Line 467
	*** 00001c	66 			DB	102	;0066H
	*** 00001d	2e 			DB	46	;002eH
	*** 00001e	89 			DB	137	;0089H
	*** 00001f	1d 			DB	29	;001dH
;|*** 		lea di, cs:IntRegisters.ECX
; Line 468
	*** 000020	2e 8d 3e 0a 00 		lea	di,WORD PTR cs:$S1367_IntRegisters+10
;|*** 		GST_ASM_EMIT4 (66,2E,89,0D) // mov [cs:di], ecx
; Line 469
	*** 000025	66 			DB	102	;0066H
	*** 000026	2e 			DB	46	;002eH
	*** 000027	89 			DB	137	;0089H
	*** 000028	0d 			DB	13	;000dH
;|*** 		lea di, cs:IntRegisters.EDX
; Line 470
	*** 000029	2e 8d 3e 0e 00 		lea	di,WORD PTR cs:$S1367_IntRegisters+14
;|*** 		GST_ASM_EMIT4 (66,2E,89,15) // mov [cs:di], edx
; Line 471
	*** 00002e	66 			DB	102	;0066H
	*** 00002f	2e 			DB	46	;002eH
	*** 000030	89 			DB	137	;0089H
	*** 000031	15 			DB	21	;0015H
;|*** 
;|*** 		mov ax, [bp + 8]
; Line 473
	*** 000032	8b 46 08 		mov	ax,WORD PTR [bp+8]
;|*** 		mov cs:IntRegisters.Flags, ax
; Line 474
	*** 000035	2e a3 00 00 		mov	WORD PTR cs:$S1367_IntRegisters,ax
;|*** 
;|*** 		mov cs:IntRegisters.SI, si
; Line 476
	*** 000039	2e 89 36 14 00 		mov	WORD PTR cs:$S1367_IntRegisters+20,si
;|*** 		mov si, [bp + 2] // Int number
; Line 477
	*** 00003e	8b 76 02 		mov	si,WORD PTR [bp+2]
;|*** 
;|*** 		mov cs:IntRegisters.DS, ds
; Line 479
	*** 000041	2e 8c 1e 16 00 		mov	WORD PTR cs:$S1367_IntRegisters+22,ds
;|*** 		mov cs:IntRegisters.ES, es
; Line 480
	*** 000046	2e 8c 06 18 00 		mov	WORD PTR cs:$S1367_IntRegisters+24,es
;|*** 		mov cs:IntRegisters.SS, ss
; Line 481
	*** 00004b	2e 8c 16 1a 00 		mov	WORD PTR cs:$S1367_IntRegisters+26,ss
;|*** 
;|*** 		// Compiler assumes SS == DS - use our stack if this condition is not met
;|*** 		mov ax, ss
; Line 484
	*** 000050	8c d0 			mov	ax,ss
;|*** 		mov bx, cs
; Line 485
	*** 000052	8c cb 			mov	bx,cs
;|*** 		cmp ax, bx
; Line 486
	*** 000054	3b c3 			cmp	ax,bx
;|*** 		jz stack_ok
; Line 487
	*** 000056	74 11 			je	SHORT $stack_ok1477
;|*** 
;|*** 		mov cs:OrigStackPointer, sp
; Line 489
	*** 000058	2e 89 26 00 00 		mov	WORD PTR cs:$S1474_?OrigStackPointer@?1??IntFilterEntry@@YAXXZ@4IA,sp
;|*** 		mov cs:OrigStackSegment, ss
; Line 490
	*** 00005d	2e 8c 16 00 00 		mov	WORD PTR cs:$S1476_?OrigStackSegment@?1??IntFilterEntry@@YAXXZ@4IA,ss
;|*** 		mov ax, cs
; Line 491
	*** 000062	8c c8 			mov	ax,cs
;|*** 		mov ss, ax
; Line 492
	*** 000064	8e d0 			mov	ss,ax
;|*** 		mov sp, GST_BOOT_LOADER_STACK_TOP
; Line 493
	*** 000066	bc fc 9f 		mov	sp,-24580	;9ffcH
;|*** 
;|*** 	stack_ok:
; Line 495
					$stack_ok1477:
;|*** 		// DS = CS
;|*** 		push ds
; Line 497
	*** 000069	1e 			push	ds
;|*** 		push es
; Line 498
	*** 00006a	06 			push	es
;|*** 		mov ax, cs
; Line 499
	*** 00006b	8c c8 			mov	ax,cs
;|*** 		mov ds, ax
; Line 500
	*** 00006d	8e d8 			mov	ds,ax
;|*** 		mov es, ax
; Line 501
	*** 00006f	8e c0 			mov	es,ax
;|*** 
;|*** 		push si // Int number
; Line 503
	*** 000071	56 			push	si
;|*** 
;|*** 		// Filter request
;|*** 		cmp si, 0x15
; Line 506
	*** 000072	83 fe 15 		cmp	si,21	;0015H
;|*** 		je filter15
; Line 507
	*** 000075	74 0b 			je	SHORT $filter151478
;|*** 		cmp si, 0x13
; Line 508
	*** 000077	83 fe 13 		cmp	si,19	;0013H
;|*** 		jne $
; Line 509
	*** 00007a	75 fe 			jne	SHORT $+0
;|*** 
;|*** 		call Int13Filter
; Line 511
	*** 00007c	e8 00 00 		call	?Int13Filter@@YADXZ	;Int13Filter
;|*** 		jmp s0
; Line 512
	*** 00007f	e9 03 00 		jmp	$s01479
;|*** 
;|*** 	filter15:
; Line 514
					$filter151478:
;|*** 		call Int15Filter
; Line 515
	*** 000082	e8 00 00 		call	?Int15Filter@@YADXZ	;Int15Filter
;|*** 
;|*** 	s0:
; Line 517
					$s01479:
;|*** 		pop si // Int number
; Line 518
	*** 000085	5e 			pop	si
;|*** 		pop es
; Line 519
	*** 000086	07 			pop	es
;|*** 		pop ds
; Line 520
	*** 000087	1f 			pop	ds
;|*** 
;|*** 		// Restore original SS:SP if our stack is empty
;|*** 		cli
; Line 523
	*** 000088	fa 			cli	
;|*** 		mov bx, GST_BOOT_LOADER_STACK_TOP
; Line 524
	*** 000089	bb fc 9f 		mov	bx,-24580	;9ffcH
;|*** 		cmp bx, sp
; Line 525
	*** 00008c	3b dc 			cmp	bx,sp
;|*** 		jnz stack_in_use
; Line 526
	*** 00008e	75 0a 			jne	SHORT $stack_in_use1480
;|*** 
;|*** 		mov ss, cs:OrigStackSegment
; Line 528
	*** 000090	2e 8e 16 00 00 		mov	ss,WORD PTR cs:$S1476_?OrigStackSegment@?1??IntFilterEntry@@YAXXZ@4IA
;|*** 		mov sp, cs:OrigStackPointer
; Line 529
	*** 000095	2e 8b 26 00 00 		mov	sp,WORD PTR cs:$S1474_?OrigStackPointer@?1??IntFilterEntry@@YAXXZ@4IA
;|*** 	stack_in_use:
; Line 530
					$stack_in_use1480:
;|*** 
;|*** 		test ax, ax // passOriginalRequest
; Line 532
	*** 00009a	85 c0 			test	ax,ax
;|*** 		jnz pass_request
; Line 533
	*** 00009c	75 48 			jne	SHORT $pass_request1481
;|*** 
;|*** 		// Return results of filtered request
;|*** 		popad
; Line 536
	*** 00009e	66 61 			popad
;|*** 		popf
; Line 537
	*** 0000a0	9d 			popf	
;|*** 		mov ax, cs:IntRegisters.Flags
; Line 538
	*** 0000a1	2e a1 00 00 		mov	ax,WORD PTR cs:$S1367_IntRegisters
;|*** 		mov [bp + 8], ax
; Line 539
	*** 0000a5	89 46 08 		mov	WORD PTR [bp+8],ax
;|*** 		leave
; Line 540
	*** 0000a8	c9 			leave	
;|*** 
;|*** 		lea di, cs:IntRegisters.EAX
; Line 542
	*** 0000a9	2e 8d 3e 02 00 		lea	di,WORD PTR cs:$S1367_IntRegisters+2
;|*** 		GST_ASM_EMIT4 (66,2E,8B,05) // mov eax, [cs:di]
; Line 543
	*** 0000ae	66 			DB	102	;0066H
	*** 0000af	2e 			DB	46	;002eH
	*** 0000b0	8b 			DB	139	;008bH
	*** 0000b1	05 			DB	5
;|*** 		lea di, cs:IntRegisters.EBX
; Line 544
	*** 0000b2	2e 8d 3e 06 00 		lea	di,WORD PTR cs:$S1367_IntRegisters+6
;|*** 		GST_ASM_EMIT4 (66,2E,8B,1D) // mov ebx, [cs:di]
; Line 545
	*** 0000b7	66 			DB	102	;0066H
	*** 0000b8	2e 			DB	46	;002eH
	*** 0000b9	8b 			DB	139	;008bH
	*** 0000ba	1d 			DB	29	;001dH
;|*** 		lea di, cs:IntRegisters.ECX
; Line 546
	*** 0000bb	2e 8d 3e 0a 00 		lea	di,WORD PTR cs:$S1367_IntRegisters+10
;|*** 		GST_ASM_EMIT4 (66,2E,8B,0D) // mov ecx, [cs:di]
; Line 547
	*** 0000c0	66 			DB	102	;0066H
	*** 0000c1	2e 			DB	46	;002eH
	*** 0000c2	8b 			DB	139	;008bH
	*** 0000c3	0d 			DB	13	;000dH
;|*** 		lea di, cs:IntRegisters.EDX
; Line 548
	*** 0000c4	2e 8d 3e 0e 00 		lea	di,WORD PTR cs:$S1367_IntRegisters+14
;|*** 		GST_ASM_EMIT4 (66,2E,8B,15) // mov edx, [cs:di]
; Line 549
	*** 0000c9	66 			DB	102	;0066H
	*** 0000ca	2e 			DB	46	;002eH
	*** 0000cb	8b 			DB	139	;008bH
	*** 0000cc	15 			DB	21	;0015H
;|*** 
;|*** 		mov di, cs:IntRegisters.DI
; Line 551
	*** 0000cd	2e 8b 3e 12 00 		mov	di,WORD PTR cs:$S1367_IntRegisters+18
;|*** 		mov si, cs:IntRegisters.SI
; Line 552
	*** 0000d2	2e 8b 36 14 00 		mov	si,WORD PTR cs:$S1367_IntRegisters+20
;|*** 		mov es, cs:IntRegisters.ES
; Line 553
	*** 0000d7	2e 8e 06 18 00 		mov	es,WORD PTR cs:$S1367_IntRegisters+24
;|*** 		mov ds, cs:IntRegisters.DS
; Line 554
	*** 0000dc	2e 8e 1e 16 00 		mov	ds,WORD PTR cs:$S1367_IntRegisters+22
;|*** 
;|*** 		sti
; Line 556
	*** 0000e1	fb 			sti	
;|*** 		add sp, 2
; Line 557
	*** 0000e2	83 c4 02 		add	sp,2
;|*** 		iret
; Line 558
	*** 0000e5	cf 			iret	
;|*** 
;|*** 		// Pass original request
;|*** 	pass_request:
; Line 561
					$pass_request1481:
;|*** 		sti
; Line 562
	*** 0000e6	fb 			sti	
;|*** 		cmp si, 0x15
; Line 563
	*** 0000e7	83 fe 15 		cmp	si,21	;0015H
;|*** 		je pass15
; Line 564
	*** 0000ea	74 11 			je	SHORT $pass151482
;|*** 		cmp si, 0x13
; Line 565
	*** 0000ec	83 fe 13 		cmp	si,19	;0013H
;|*** 		jne $
; Line 566
	*** 0000ef	75 fe 			jne	SHORT $+0
;|*** 
;|*** 		popad
; Line 568
	*** 0000f1	66 61 			popad
;|*** 		popf
; Line 569
	*** 0000f3	9d 			popf	
;|*** 		leave
; Line 570
	*** 0000f4	c9 			leave	
;|*** 		add sp, 2
; Line 571
	*** 0000f5	83 c4 02 		add	sp,2
;|*** 		jmp cs:OriginalInt13Handler	
; Line 572
	*** 0000f8	2e ff 2e 00 00 		jmp	WORD PTR cs:$S1365_OriginalInt13Handler
;|*** 
;|*** 	pass15:
; Line 574
					$pass151482:
;|*** 		popad
; Line 575
	*** 0000fd	66 61 			popad
;|*** 		popf
; Line 576
	*** 0000ff	9d 			popf	
;|*** 		leave
; Line 577
	*** 000100	c9 			leave	
;|*** 		add sp, 2
; Line 578
	*** 000101	83 c4 02 		add	sp,2
;|*** 		jmp cs:OriginalInt15Handler
; Line 579
	*** 000104	2e ff 2e 00 00 		jmp	WORD PTR cs:$S1366_OriginalInt15Handler
;|*** 	}
; Line 580
;|*** }
; Line 581
	*** 000109	eb 00 			jmp	SHORT $EX1472
					$EX1472:
	*** 00010b	5e 			pop	si
	*** 00010c	5f 			pop	di
	*** 00010d	c9 			leave	
	*** 00010e	c3 			ret	

?IntFilterEntry@@YAXXZ	ENDP
	PUBLIC	?Int13FilterEntry@@YAXXZ	; Int13FilterEntry
?Int13FilterEntry@@YAXXZ	PROC NEAR	; Int13FilterEntry COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn void Int13FilterEntry ()
;|***  *	\brief Intall filter an int13 request
;|***  *	\return void
;|***  *
;|***  */
;|*** void Int13FilterEntry ()
;|*** {
; Line 592
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;|*** 	__asm
;|*** 	{
;|*** 		leave
; Line 595
	*** 000003	c9 			leave	
;|*** 		push 0x13
; Line 596
	*** 000004	6a 13 			push	19	;0013H
;|*** 		jmp IntFilterEntry
; Line 597
	*** 000006	e9 00 00 		jmp	?IntFilterEntry@@YAXXZ	;IntFilterEntry
;|*** 	}
; Line 598
;|*** }
; Line 599
	*** 000009	c9 			leave	
	*** 00000a	c3 			ret	

?Int13FilterEntry@@YAXXZ	ENDP

?Int15FilterEntry@@YAXXZ	PROC NEAR	; Int15FilterEntry COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn static void Int15FilterEntry ()
;|***  *	\brief Install filter a int15 request
;|***  *	\return static void
;|***  *
;|***  */
;|*** static void Int15FilterEntry ()
;|*** {
; Line 610
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;|*** 	__asm
;|*** 	{
;|*** 		pushf
; Line 613
	*** 000003	9c 			pushf	
;|*** 		cmp ax, 0xe820 // Get system memory map
; Line 614
	*** 000004	3d 20 e8 		cmp	ax,-6112	;e820H
;|*** 		je filter
; Line 615
	*** 000007	74 07 			je	SHORT $filter1489
;|*** 		
;|*** 		popf
; Line 617
	*** 000009	9d 			popf	
;|*** 		leave
; Line 618
	*** 00000a	c9 			leave	
;|*** 		jmp cs:OriginalInt15Handler
; Line 619
	*** 00000b	2e ff 2e 00 00 		jmp	WORD PTR cs:$S1366_OriginalInt15Handler
;|*** 
;|*** 	filter:
; Line 621
					$filter1489:
;|*** 		leave
; Line 622
	*** 000010	c9 			leave	
;|*** 		push 0x15
; Line 623
	*** 000011	6a 15 			push	21	;0015H
;|*** 		jmp IntFilterEntry
; Line 624
	*** 000013	e9 00 00 		jmp	?IntFilterEntry@@YAXXZ	;IntFilterEntry
;|*** 	}
; Line 625
;|*** }
; Line 626
	*** 000016	c9 			leave	
	*** 000017	c3 			ret	

?Int15FilterEntry@@YAXXZ	ENDP
	PUBLIC	?InstallInterruptFilters@@YADXZ	; InstallInterruptFilters
?InstallInterruptFilters@@YADXZ	PROC NEAR	; InstallInterruptFilters COMDAT
;|*** 
;|*** 
;|*** /**
;|***  *
;|***  *	\fn bool InstallInterruptFilters ()
;|***  *	\brief Install or interrupt filters
;|***  *	\return bool false if cant create new bios memory map
;|***  *			true if currentInt13Handler == (uint32) Int13FilterEntry
;|***  *			true else
;|***  *
;|***  */
;|*** bool InstallInterruptFilters ()
;|*** {
; Line 639
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
	*** 000004	56 			push	si
;|*** 
;|*** #ifndef GST_WINDOWS_BOOT_RESCUE_DISK_MODE
;|*** 
;|*** 	// If the filters have already been installed, it usually indicates stack corruption
;|*** 	// and a consequent reentry of this routine without a system reset.
;|*** 
;|*** 	uint32 currentInt13Handler;
;|*** 	CopyMemory (0, 0x13 * 4, &currentInt13Handler, sizeof (currentInt13Handler));
;|*** 
;|*** 	if (currentInt13Handler == (uint32) Int13FilterEntry)
;|*** 	{
;|*** 		PrintError ("Memory corrupted");
;|*** 		Print (GST_BOOT_STR_UPGRADE_BIOS);
;|*** 
;|*** 		GetKeyboardChar();
;|*** 		return true;
;|*** 	}
;|*** 
;|*** #endif
;|*** 
;|*** 	if (!CreateNewBiosMemoryMap())
; Line 660
	*** 000005	e8 00 00 		call	?CreateNewBiosMemoryMap@@YADXZ	; CreateNewBiosMemoryMap
	*** 000008	0a c0 			or	al,al
	*** 00000a	74 57 			je	SHORT $EX1491
;|*** 		return false;
;|*** 
;|*** 	__asm
;|*** 	{
;|*** 		cli
; Line 665
	*** 00000c	fa 			cli	
;|*** 		push es
; Line 666
	*** 00000d	06 			push	es
;|*** 
;|*** 		// Save original INT 13 handler
;|*** 		xor ax, ax
; Line 669
	*** 00000e	33 c0 			xor	ax,ax
;|*** 		mov es, ax
; Line 670
	*** 000010	8e c0 			mov	es,ax
;|*** 		
;|*** 		mov si, 0x13 * 4
; Line 672
	*** 000012	be 4c 00 		mov	si,76	;004cH
;|*** 		lea di, OriginalInt13Handler
; Line 673
	*** 000015	8d 3e 00 00 		lea	di,WORD PTR $S1365_OriginalInt13Handler
;|*** 
;|*** 		mov ax, es:[si]
; Line 675
	*** 000019	26 8b 04 		mov	ax,WORD PTR es:[si]
;|*** 		mov [di], ax
; Line 676
	*** 00001c	89 05 			mov	WORD PTR [di],ax
;|*** 		mov ax, es:[si + 2]
; Line 677
	*** 00001e	26 8b 44 02 		mov	ax,WORD PTR es:[si+2]
;|*** 		mov [di + 2], ax
; Line 678
	*** 000022	89 45 02 		mov	WORD PTR [di+2],ax
;|*** 		
;|*** 		// Install INT 13 filter
;|*** 		lea ax, Int13FilterEntry
; Line 681
	*** 000025	8d 06 00 00 		lea	ax,WORD PTR ?Int13FilterEntry@@YAXXZ	;Int13FilterEntry
;|*** 		mov es:[si], ax
; Line 682
	*** 000029	26 89 04 		mov	WORD PTR es:[si],ax
;|*** 		mov es:[si + 2], cs
; Line 683
	*** 00002c	26 8c 4c 02 		mov	WORD PTR es:[si+2],cs
;|*** 
;|*** 		// Save original INT 15 handler
;|*** 		mov si, 0x15 * 4	
; Line 686
	*** 000030	be 54 00 		mov	si,84	;0054H
;|*** 		lea di, OriginalInt15Handler
; Line 687
	*** 000033	8d 3e 00 00 		lea	di,WORD PTR $S1366_OriginalInt15Handler
;|*** 
;|*** 		mov ax, es:[si]
; Line 689
	*** 000037	26 8b 04 		mov	ax,WORD PTR es:[si]
;|*** 		mov [di], ax
; Line 690
	*** 00003a	89 05 			mov	WORD PTR [di],ax
;|*** 		mov ax, es:[si + 2]
; Line 691
	*** 00003c	26 8b 44 02 		mov	ax,WORD PTR es:[si+2]
;|*** 		mov [di + 2], ax
; Line 692
	*** 000040	89 45 02 		mov	WORD PTR [di+2],ax
;|*** 
;|*** 		// Install INT 15 filter
;|*** 		lea ax, Int15FilterEntry
; Line 695
	*** 000043	8d 06 00 00 		lea	ax,WORD PTR ?Int15FilterEntry@@YAXXZ	;Int15FilterEntry
;|*** 		mov es:[si], ax
; Line 696
	*** 000047	26 89 04 		mov	WORD PTR es:[si],ax
;|*** 		mov es:[si + 2], cs
; Line 697
	*** 00004a	26 8c 4c 02 		mov	WORD PTR es:[si+2],cs
;|*** 
;|*** 		// If the BIOS does not support system memory map (INT15 0xe820),
;|*** 		// set amount of available memory to CS:0000 - 0:0000
;|*** 		cmp BiosMemoryMapSize, 1
; Line 701
	*** 00004e	83 3e 00 00 01 		cmp	WORD PTR $S1415_BiosMemoryMapSize,1
;|*** 		jg mem_map_ok
; Line 702
	*** 000053	7f 0a 			jg	SHORT $mem_map_ok1493
;|*** 		mov ax, cs
; Line 703
	*** 000055	8c c8 			mov	ax,cs
;|*** 		shr ax, 10 - 4		// CS * 16 / 1024
; Line 704
	*** 000057	c1 e8 06 		shr	ax,6
;|*** 		mov es:[0x413], ax	// = KBytes available
; Line 705
	*** 00005a	26 89 06 13 04 		mov	WORD PTR es:1043,ax
;|*** 	mem_map_ok:
; Line 706
					$mem_map_ok1493:
;|*** 
;|*** 		pop es
; Line 708
	*** 00005f	07 			pop	es
;|*** 		sti
; Line 709
	*** 000060	fb 			sti	
;|*** 	}
; Line 710
;|*** 
;|*** 	return true;
; Line 712
	*** 000061	b0 01 			mov	al,1
;|*** }
; Line 713
					$EX1491:
	*** 000063	5e 			pop	si
	*** 000064	5f 			pop	di
	*** 000065	c9 			leave	
	*** 000066	c3 			ret	

?InstallInterruptFilters@@YADXZ	ENDP
_TEXT	ENDS
END
