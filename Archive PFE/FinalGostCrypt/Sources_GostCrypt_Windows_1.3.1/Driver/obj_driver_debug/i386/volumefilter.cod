; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\volumefilter.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_HiddenSysLeakProtectionCount
_BSS	SEGMENT
_HiddenSysLeakProtectionCount DD 01H DUP (?)
_BSS	ENDS
PUBLIC	??_C@_0BO@INEJHKOL@VolumeFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_VolumeFilterAddDevice@8
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoDetachDevice@4:PROC
EXTRN	__imp__IoInitializeRemoveLockEx@20:PROC
EXTRN	__imp__IoAttachDeviceToDeviceStack@8:PROC
EXTRN	__imp_@ObfDereferenceObject@4:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
EXTRN	__imp__IoGetAttachedDeviceReference@4:PROC
EXTRN	_DbgPrint:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0BO@INEJHKOL@VolumeFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\volumefilter.c
text$s	SEGMENT
??_C@_0BO@INEJHKOL@VolumeFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@ DB 'V'
	DB	'olumeFilterAddDevice pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _VolumeFilterAddDevice@8
_TEXT	SEGMENT
_filterDeviceObject$ = -16				; size = 4
_status$ = -12						; size = 4
_attachedDeviceObject$ = -8				; size = 4
_Extension$ = -4					; size = 4
_driverObject$ = 8					; size = 4
_pdo$ = 12						; size = 4
_VolumeFilterAddDevice@8 PROC				; COMDAT

; 41   : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 10	 sub	 esp, 16			; 00000010H

; 42   : 	VolumeFilterExtension *Extension;
; 43   : 	NTSTATUS status;
; 44   : 	PDEVICE_OBJECT filterDeviceObject = NULL;

  00008	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _filterDeviceObject$[ebp], 0

; 45   : 	PDEVICE_OBJECT attachedDeviceObject;
; 46   : 
; 47   : 	Dump ("VolumeFilterAddDevice pdo=%p\n", pdo);

  0000f	8b 45 0c	 mov	 eax, DWORD PTR _pdo$[ebp]
  00012	50		 push	 eax
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@INEJHKOL@VolumeFilterAddDevice?5pdo?$DN?$CFp?6?$AA@FNODOBFM@
  00018	e8 00 00 00 00	 call	 _DbgPrint
  0001d	83 c4 08	 add	 esp, 8

; 48   : 
; 49   : 	attachedDeviceObject = IoGetAttachedDeviceReference (pdo);

  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _pdo$[ebp]
  00023	51		 push	 ecx
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetAttachedDeviceReference@4
  0002a	89 45 f8	 mov	 DWORD PTR _attachedDeviceObject$[ebp], eax

; 50   : 	status = IoCreateDevice (driverObject, sizeof (VolumeFilterExtension), NULL, attachedDeviceObject->DeviceType, 0, FALSE, &filterDeviceObject);

  0002d	8d 55 f0	 lea	 edx, DWORD PTR _filterDeviceObject$[ebp]
  00030	52		 push	 edx
  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	8b 45 f8	 mov	 eax, DWORD PTR _attachedDeviceObject$[ebp]
  00038	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0003b	51		 push	 ecx
  0003c	6a 00		 push	 0
  0003e	68 50 02 00 00	 push	 592			; 00000250H
  00043	8b 55 08	 mov	 edx, DWORD PTR _driverObject$[ebp]
  00046	52		 push	 edx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28
  0004d	89 45 f4	 mov	 DWORD PTR _status$[ebp], eax

; 51   : 
; 52   : 	ObDereferenceObject (attachedDeviceObject);

  00050	8b 4d f8	 mov	 ecx, DWORD PTR _attachedDeviceObject$[ebp]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 53   : 
; 54   : 	if (!NT_SUCCESS (status))

  00059	83 7d f4 00	 cmp	 DWORD PTR _status$[ebp], 0
  0005d	7d 0c		 jge	 SHORT $LN4@VolumeFilt

; 55   : 	{
; 56   : 		filterDeviceObject = NULL;

  0005f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _filterDeviceObject$[ebp], 0

; 57   : 		goto err;

  00066	e9 a9 00 00 00	 jmp	 $err$26334
$LN4@VolumeFilt:

; 58   : 	}
; 59   : 
; 60   : 	Extension = (VolumeFilterExtension *) filterDeviceObject->DeviceExtension;

  0006b	8b 45 f0	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  0006e	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00071	89 4d fc	 mov	 DWORD PTR _Extension$[ebp], ecx

; 61   : 	memset (Extension, 0, sizeof (VolumeFilterExtension));

  00074	68 50 02 00 00	 push	 592			; 00000250H
  00079	6a 00		 push	 0
  0007b	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 _memset
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH

; 62   : 
; 63   : 	Extension->LowerDeviceObject = IoAttachDeviceToDeviceStack (filterDeviceObject, pdo);  // IoAttachDeviceToDeviceStackSafe() is not required in AddDevice routine and is also unavailable on Windows 2000 SP4

  00087	8b 45 0c	 mov	 eax, DWORD PTR _pdo$[ebp]
  0008a	50		 push	 eax
  0008b	8b 4d f0	 mov	 ecx, DWORD PTR _filterDeviceObject$[ebp]
  0008e	51		 push	 ecx
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAttachDeviceToDeviceStack@8
  00095	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  00098	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 64   : 	if (!Extension->LowerDeviceObject)

  0009b	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  0009e	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  000a2	75 09		 jne	 SHORT $LN3@VolumeFilt

; 65   : 	{
; 66   : 		status = STATUS_DEVICE_REMOVED;

  000a4	c7 45 f4 b6 02
	00 c0		 mov	 DWORD PTR _status$[ebp], -1073741130 ; c00002b6H

; 67   : 		goto err;

  000ab	eb 67		 jmp	 SHORT $err$26334
$LN3@VolumeFilt:

; 68   : 	}
; 69   : 	
; 70   : 	Extension->IsVolumeFilterDevice = TRUE;

  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000b0	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [ecx+12], 1

; 71   : 	Extension->DeviceObject = filterDeviceObject;

  000b7	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  000ba	8b 45 f0	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  000bd	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 72   : 	Extension->Pdo = pdo;

  000c0	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000c3	8b 55 0c	 mov	 edx, DWORD PTR _pdo$[ebp]
  000c6	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 73   : 
; 74   : 	IoInitializeRemoveLock (&Extension->Queue.RemoveLock, 'LRCT', 0, 0);

  000c9	6a 58		 push	 88			; 00000058H
  000cb	6a 00		 push	 0
  000cd	6a 00		 push	 0
  000cf	68 54 43 52 4c	 push	 1280459604		; 4c524354H
  000d4	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  000d7	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  000dc	50		 push	 eax
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoInitializeRemoveLockEx@20

; 75   : 
; 76   : 	filterDeviceObject->Flags |= Extension->LowerDeviceObject->Flags & (DO_DIRECT_IO | DO_BUFFERED_IO | DO_POWER_PAGABLE);

  000e3	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000e6	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000e9	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000ec	25 14 20 00 00	 and	 eax, 8212		; 00002014H
  000f1	8b 4d f0	 mov	 ecx, DWORD PTR _filterDeviceObject$[ebp]
  000f4	0b 41 1c	 or	 eax, DWORD PTR [ecx+28]
  000f7	8b 55 f0	 mov	 edx, DWORD PTR _filterDeviceObject$[ebp]
  000fa	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 77   : 	filterDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  000fd	8b 45 f0	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  00100	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00103	81 e1 7f ff ff
	ff		 and	 ecx, -129		; ffffff7fH
  00109	8b 55 f0	 mov	 edx, DWORD PTR _filterDeviceObject$[ebp]
  0010c	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 78   : 
; 79   : 	return status;

  0010f	8b 45 f4	 mov	 eax, DWORD PTR _status$[ebp]
  00112	eb 29		 jmp	 SHORT $LN5@VolumeFilt
$err$26334:

; 80   : 
; 81   : err:
; 82   : 	if (filterDeviceObject)

  00114	83 7d f0 00	 cmp	 DWORD PTR _filterDeviceObject$[ebp], 0
  00118	74 20		 je	 SHORT $LN2@VolumeFilt

; 83   : 	{
; 84   : 		if (Extension->LowerDeviceObject)

  0011a	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  0011d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00121	74 0d		 je	 SHORT $LN1@VolumeFilt

; 85   : 			IoDetachDevice (Extension->LowerDeviceObject);

  00123	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00126	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00129	52		 push	 edx
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDetachDevice@4
$LN1@VolumeFilt:

; 86   : 
; 87   : 		IoDeleteDevice (filterDeviceObject);

  00130	8b 45 f0	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  00133	50		 push	 eax
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4
$LN2@VolumeFilt:

; 88   : 	}
; 89   : 
; 90   : 	return status;

  0013a	8b 45 f4	 mov	 eax, DWORD PTR _status$[ebp]
$LN5@VolumeFilt:

; 91   : }

  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c2 08 00	 ret	 8
_VolumeFilterAddDevice@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DL@GNELLIFI@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0JJ@FGAHJPEG@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_IoGetCurrentIrpStackLocation@4
PUBLIC	_VolumeFilterDispatchIrp@8
EXTRN	__imp__IoReleaseRemoveLockEx@12:PROC
EXTRN	_GSTCompleteIrp@12:PROC
EXTRN	__imp__IoAcquireRemoveLockEx@20:PROC
EXTRN	__imp__RtlAssert@16:PROC
;	COMDAT ??_C@_0DL@GNELLIFI@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@
text$s	SEGMENT
??_C@_0DL@GNELLIFI@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@ DB '!'
	DB	'Extension->bRootDevice && Extension->IsVolumeFilterDevice', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0JJ@FGAHJPEG@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
text$s	SEGMENT
??_C@_0JJ@FGAHJPEG@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@ DB 'c:'
	DB	'\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_comment'
	DB	'ed\sources_gostcrypt_windows_1.3.1', 0e9H, '\sources_gostcryp'
	DB	't_windows_1.3.1\driver\volumefilter.c', 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _VolumeFilterDispatchIrp@8
_TEXT	SEGMENT
tv76 = -20						; size = 4
tv74 = -16						; size = 4
_irpSp$ = -12						; size = 4
_status$ = -8						; size = 4
_Extension$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_VolumeFilterDispatchIrp@8 PROC				; COMDAT

; 362  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 14	 sub	 esp, 20			; 00000014H

; 363  : 	VolumeFilterExtension *Extension = (VolumeFilterExtension *) DeviceObject->DeviceExtension;

  00008	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  0000b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0000e	89 4d fc	 mov	 DWORD PTR _Extension$[ebp], ecx

; 364  : 	PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

  00011	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  0001a	89 45 f4	 mov	 DWORD PTR _irpSp$[ebp], eax

; 365  : 	NTSTATUS status;
; 366  : 
; 367  : 	ASSERT (!Extension->bRootDevice && Extension->IsVolumeFilterDevice);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  00020	83 38 00	 cmp	 DWORD PTR [eax], 0
  00023	75 12		 jne	 SHORT $LN10@VolumeFilt@2
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00028	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0002c	74 09		 je	 SHORT $LN10@VolumeFilt@2
  0002e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00035	eb 1e		 jmp	 SHORT $LN11@VolumeFilt@2
$LN10@VolumeFilt@2:
  00037	6a 00		 push	 0
  00039	68 6f 01 00 00	 push	 367			; 0000016fH
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0JJ@FGAHJPEG@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GNELLIFI@?$CBExtension?9?$DObRootDevice?5?$CG?$CG?5Exten@FNODOBFM@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  0004e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN11@VolumeFilt@2:

; 368  : 
; 369  : 	switch (irpSp->MajorFunction)

  00055	8b 55 f4	 mov	 edx, DWORD PTR _irpSp$[ebp]
  00058	8a 02		 mov	 al, BYTE PTR [edx]
  0005a	88 45 ec	 mov	 BYTE PTR tv76[ebp], al
  0005d	80 7d ec 0e	 cmp	 BYTE PTR tv76[ebp], 14	; 0000000eH
  00061	74 0e		 je	 SHORT $LN5@VolumeFilt@2
  00063	80 7d ec 16	 cmp	 BYTE PTR tv76[ebp], 22	; 00000016H
  00067	74 39		 je	 SHORT $LN3@VolumeFilt@2
  00069	80 7d ec 1b	 cmp	 BYTE PTR tv76[ebp], 27	; 0000001bH
  0006d	74 1c		 je	 SHORT $LN4@VolumeFilt@2
  0006f	eb 48		 jmp	 SHORT $LN2@VolumeFilt@2
$LN5@VolumeFilt@2:

; 370  : 	{
; 371  : 	case IRP_MJ_DEVICE_CONTROL:
; 372  : 		return DispatchControl (DeviceObject, Irp, Extension, irpSp);

  00071	8b 4d f4	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00074	51		 push	 ecx
  00075	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  00078	52		 push	 edx
  00079	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 _DispatchControl@16
  00086	e9 93 00 00 00	 jmp	 $LN8@VolumeFilt@2
$LN4@VolumeFilt@2:

; 373  : 
; 374  : 	case IRP_MJ_PNP:
; 375  : 		return DispatchPnp (DeviceObject, Irp, Extension, irpSp);

  0008b	8b 55 f4	 mov	 edx, DWORD PTR _irpSp$[ebp]
  0008e	52		 push	 edx
  0008f	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  00092	50		 push	 eax
  00093	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00096	51		 push	 ecx
  00097	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  0009a	52		 push	 edx
  0009b	e8 00 00 00 00	 call	 _DispatchPnp@16
  000a0	eb 7c		 jmp	 SHORT $LN8@VolumeFilt@2
$LN3@VolumeFilt@2:

; 376  : 
; 377  : 	case IRP_MJ_POWER:
; 378  : 		return DispatchPower (DeviceObject, Irp, Extension, irpSp);

  000a2	8b 45 f4	 mov	 eax, DWORD PTR _irpSp$[ebp]
  000a5	50		 push	 eax
  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000a9	51		 push	 ecx
  000aa	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  000ad	52		 push	 edx
  000ae	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 _DispatchPower@16
  000b7	eb 65		 jmp	 SHORT $LN8@VolumeFilt@2
$LN2@VolumeFilt@2:

; 379  : 
; 380  : 	default:
; 381  : 		status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  000b9	6a 58		 push	 88			; 00000058H
  000bb	68 7d 01 00 00	 push	 381			; 0000017dH
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0JJ@FGAHJPEG@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
  000c5	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  000c8	51		 push	 ecx
  000c9	8b 55 fc	 mov	 edx, DWORD PTR _Extension$[ebp]
  000cc	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  000d2	52		 push	 edx
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20
  000d9	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 382  : 		if (!NT_SUCCESS (status))

  000dc	83 7d f8 00	 cmp	 DWORD PTR _status$[ebp], 0
  000e0	7d 11		 jge	 SHORT $LN1@VolumeFilt@2

; 383  : 			return GSTCompleteIrp (Irp, status, 0);

  000e2	6a 00		 push	 0
  000e4	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]
  000e7	50		 push	 eax
  000e8	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  000eb	51		 push	 ecx
  000ec	e8 00 00 00 00	 call	 _GSTCompleteIrp@12
  000f1	eb 2b		 jmp	 SHORT $LN8@VolumeFilt@2
$LN1@VolumeFilt@2:

; 384  : 
; 385  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  000f3	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  000f6	52		 push	 edx
  000f7	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  000fa	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000fd	51		 push	 ecx
  000fe	e8 00 00 00 00	 call	 _PassIrp@8
  00103	89 45 f8	 mov	 DWORD PTR _status$[ebp], eax

; 386  : 
; 387  : 		IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00106	6a 58		 push	 88			; 00000058H
  00108	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  0010b	52		 push	 edx
  0010c	8b 45 fc	 mov	 eax, DWORD PTR _Extension$[ebp]
  0010f	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  00114	50		 push	 eax
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 388  : 		return status;

  0011b	8b 45 f8	 mov	 eax, DWORD PTR _status$[ebp]
$LN8@VolumeFilt@2:

; 389  : 	}
; 390  : }

  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 08 00	 ret	 8
_VolumeFilterDispatchIrp@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount + 1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@ DB 'c'
	DB	':\winddk\7600.16385.1\inc\ddk\wdm.h', 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv74 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	0f be 48 23	 movsx	 ecx, BYTE PTR [eax+35]
  0000d	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  00010	0f be 42 22	 movsx	 eax, BYTE PTR [edx+34]
  00014	83 c0 01	 add	 eax, 1
  00017	3b c8		 cmp	 ecx, eax
  00019	7e 20		 jle	 SHORT $LN3@IoGetCurre
  0001b	6a 00		 push	 0
  0001d	68 15 5b 00 00	 push	 23317			; 00005b15H
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  00039	eb 07		 jmp	 SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
  0003b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
$LN4@IoGetCurre:

; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

  00042	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00045	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]

; 23319: }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_IoSkipCurrentIrpStackLocation@4
EXTRN	__imp_@IofCallDriver@8:PROC
; Function compile flags: /Odtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\volumefilter.c
;	COMDAT _PassIrp@8
_TEXT	SEGMENT
_deviceObject$ = 8					; size = 4
_irp$ = 12						; size = 4
_PassIrp@8 PROC						; COMDAT

; 104  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 105  : 	IoSkipCurrentIrpStackLocation (irp);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _irp$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IoSkipCurrentIrpStackLocation@4

; 106  : 	return IoCallDriver (deviceObject, irp);

  0000e	8b 55 0c	 mov	 edx, DWORD PTR _irp$[ebp]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 107  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
_PassIrp@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoSkipCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv73 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoSkipCurrentIrpStackLocation@4 PROC			; COMDAT

; 23945: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23946:     ASSERT(Irp->CurrentLocation <= Irp->StackCount);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	0f be 48 23	 movsx	 ecx, BYTE PTR [eax+35]
  0000d	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  00010	0f be 42 22	 movsx	 eax, BYTE PTR [edx+34]
  00014	3b c8		 cmp	 ecx, eax
  00016	7e 20		 jle	 SHORT $LN3@IoSkipCurr
  00018	6a 00		 push	 0
  0001a	68 8a 5d 00 00	 push	 23946			; 00005d8aH
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00036	eb 07		 jmp	 SHORT $LN4@IoSkipCurr
$LN3@IoSkipCurr:
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
$LN4@IoSkipCurr:

; 23947:     Irp->CurrentLocation++;

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00042	8a 51 23	 mov	 dl, BYTE PTR [ecx+35]
  00045	80 c2 01	 add	 dl, 1
  00048	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  0004b	88 50 23	 mov	 BYTE PTR [eax+35], dl

; 23948:     Irp->Tail.Overlay.CurrentStackLocation++;

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00051	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00054	83 c2 24	 add	 edx, 36			; 00000024H
  00057	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  0005a	89 50 60	 mov	 DWORD PTR [eax+96], edx

; 23949: }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
_IoSkipCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@FGGJENKJ@GST_IOCTL_DISK_IS_WRITABLE?5pdo?$DN?$CF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	_ProbingHostDeviceForWrite:DWORD
EXTRN	_GSTCompleteDiskIrp@12:PROC
EXTRN	_SendDeviceIoControlRequest@24:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	_GetBootDriveFilterExtension@0:PROC
EXTRN	_IsHiddenSystemRunning@0:PROC
;	COMDAT ??_C@_0CD@FGGJENKJ@GST_IOCTL_DISK_IS_WRITABLE?5pdo?$DN?$CF@FNODOBFM@
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\volumefilter.c
text$s	SEGMENT
??_C@_0CD@FGGJENKJ@GST_IOCTL_DISK_IS_WRITABLE?5pdo?$DN?$CF@FNODOBFM@ DB 'G'
	DB	'ST_IOCTL_DISK_IS_WRITABLE pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DispatchControl@16
_TEXT	SEGMENT
tv240 = -176						; size = 4
tv79 = -172						; size = 4
_partition$26413 = -168					; size = 144
_storageDeviceNumber$26405 = -20			; size = 12
_bootDriveExtension$26404 = -8				; size = 4
_status$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_Extension$ = 16					; size = 4
_irpSp$ = 20						; size = 4
_DispatchControl@16 PROC				; COMDAT

; 190  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H

; 191  : 	NTSTATUS status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0000b	6a 58		 push	 88			; 00000058H
  0000d	68 bf 00 00 00	 push	 191			; 000000bfH
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0JJ@FGAHJPEG@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
  00017	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0001e	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00024	51		 push	 ecx
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20
  0002b	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 192  : 	if (!NT_SUCCESS (status))

  0002e	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  00032	7d 14		 jge	 SHORT $LN13@DispatchCo

; 193  : 		return GSTCompleteIrp (Irp, status, 0);

  00034	6a 00		 push	 0
  00036	8b 55 fc	 mov	 edx, DWORD PTR _status$[ebp]
  00039	52		 push	 edx
  0003a	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _GSTCompleteIrp@12
  00043	e9 65 02 00 00	 jmp	 $LN15@DispatchCo
$LN13@DispatchCo:

; 194  : 
; 195  : 	if (IsHiddenSystemRunning())

  00048	e8 00 00 00 00	 call	 _IsHiddenSystemRunning@0
  0004d	85 c0		 test	 eax, eax
  0004f	0f 84 2d 02 00
	00		 je	 $LN12@DispatchCo

; 196  : 	{
; 197  : 		switch (irpSp->Parameters.DeviceIoControl.IoControlCode)

  00055	8b 4d 14	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00058	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0005b	89 95 54 ff ff
	ff		 mov	 DWORD PTR tv79[ebp], edx
  00061	81 bd 54 ff ff
	ff 24 00 07 00	 cmp	 DWORD PTR tv79[ebp], 458788 ; 00070024H
  0006b	74 25		 je	 SHORT $LN9@DispatchCo
  0006d	81 bd 54 ff ff
	ff 74 20 22 00	 cmp	 DWORD PTR tv79[ebp], 2236532 ; 00222074H
  00077	0f 84 27 01 00
	00		 je	 $LN5@DispatchCo
  0007d	81 bd 54 ff ff
	ff 04 94 2d 00	 cmp	 DWORD PTR tv79[ebp], 2987012 ; 002d9404H
  00087	0f 84 d1 01 00
	00		 je	 $LN1@DispatchCo
  0008d	e9 f0 01 00 00	 jmp	 $LN12@DispatchCo
$LN9@DispatchCo:

; 198  : 		{
; 199  : 		case IOCTL_DISK_IS_WRITABLE:
; 200  : 			{
; 201  : 				// All volumes except the system volume must be read-only
; 202  : 
; 203  : 				DriveFilterExtension *bootDriveExtension = GetBootDriveFilterExtension();

  00092	e8 00 00 00 00	 call	 _GetBootDriveFilterExtension@0
  00097	89 45 f8	 mov	 DWORD PTR _bootDriveExtension$26404[ebp], eax

; 204  : 				STORAGE_DEVICE_NUMBER storageDeviceNumber;
; 205  : 
; 206  : 				if (!bootDriveExtension->SystemStorageDeviceNumberValid)

  0009a	8b 45 f8	 mov	 eax, DWORD PTR _bootDriveExtension$26404[ebp]
  0009d	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  000a1	75 19		 jne	 SHORT $LN8@DispatchCo

; 207  : 					GST_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000a3	68 54 53 47 00	 push	 4674388			; 00475354H
  000a8	6a 00		 push	 0
  000aa	68 0d 00 00 c0	 push	 -1073741811		; c000000dH
  000af	68 cf 00 00 00	 push	 207			; 000000cfH
  000b4	6a 29		 push	 41			; 00000029H
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeBugCheckEx@20
$LN8@DispatchCo:

; 208  : 
; 209  : 				status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &storageDeviceNumber, sizeof (storageDeviceNumber));

  000bc	6a 0c		 push	 12			; 0000000cH
  000be	8d 4d ec	 lea	 ecx, DWORD PTR _storageDeviceNumber$26405[ebp]
  000c1	51		 push	 ecx
  000c2	6a 00		 push	 0
  000c4	6a 00		 push	 0
  000c6	68 80 10 2d 00	 push	 2953344			; 002d1080H
  000cb	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  000ce	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  000d7	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 210  : 
; 211  : 				if (NT_SUCCESS (status) && bootDriveExtension->SystemStorageDeviceNumber == storageDeviceNumber.DeviceNumber)

  000da	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  000de	0f 8c 87 00 00
	00		 jl	 $LN7@DispatchCo
  000e4	8b 4d f8	 mov	 ecx, DWORD PTR _bootDriveExtension$26404[ebp]
  000e7	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000ea	3b 55 f0	 cmp	 edx, DWORD PTR _storageDeviceNumber$26405[ebp+4]
  000ed	75 7c		 jne	 SHORT $LN7@DispatchCo

; 212  : 				{
; 213  : 					PARTITION_INFORMATION_EX partition;
; 214  : 					status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &partition, sizeof (partition));

  000ef	68 90 00 00 00	 push	 144			; 00000090H
  000f4	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _partition$26413[ebp]
  000fa	50		 push	 eax
  000fb	6a 00		 push	 0
  000fd	6a 00		 push	 0
  000ff	68 48 00 07 00	 push	 458824			; 00070048H
  00104	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00107	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0010a	52		 push	 edx
  0010b	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  00110	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 215  : 
; 216  : 					if (NT_SUCCESS (status) && partition.StartingOffset.QuadPart == bootDriveExtension->ConfiguredEncryptedAreaStart)

  00113	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  00117	7c 52		 jl	 SHORT $LN7@DispatchCo
  00119	8b 45 f8	 mov	 eax, DWORD PTR _bootDriveExtension$26404[ebp]
  0011c	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv240[ebp], eax
  00122	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR tv240[ebp]
  00128	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _partition$26413[ebp+8]
  0012e	3b 51 30	 cmp	 edx, DWORD PTR [ecx+48]
  00131	75 38		 jne	 SHORT $LN7@DispatchCo
  00133	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv240[ebp]
  00139	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _partition$26413[ebp+12]
  0013f	3b 48 34	 cmp	 ecx, DWORD PTR [eax+52]
  00142	75 27		 jne	 SHORT $LN7@DispatchCo

; 217  : 					{
; 218  : 						IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00144	6a 58		 push	 88			; 00000058H
  00146	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00149	52		 push	 edx
  0014a	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  0014d	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  00152	50		 push	 eax
  00153	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 219  : 						return GSTCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);

  00159	6a 00		 push	 0
  0015b	6a 00		 push	 0
  0015d	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00160	51		 push	 ecx
  00161	e8 00 00 00 00	 call	 _GSTCompleteDiskIrp@12
  00166	e9 42 01 00 00	 jmp	 $LN15@DispatchCo
$LN7@DispatchCo:

; 220  : 					}
; 221  : 				}
; 222  : 
; 223  : 				IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0016b	6a 58		 push	 88			; 00000058H
  0016d	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00170	52		 push	 edx
  00171	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  00174	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  00179	50		 push	 eax
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 224  : 
; 225  : 				++HiddenSysLeakProtectionCount;

  00180	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _HiddenSysLeakProtectionCount
  00186	83 c1 01	 add	 ecx, 1
  00189	89 0d 00 00 00
	00		 mov	 DWORD PTR _HiddenSysLeakProtectionCount, ecx

; 226  : 				return GSTCompleteDiskIrp (Irp, STATUS_MEDIA_WRITE_PROTECTED, 0);

  0018f	6a 00		 push	 0
  00191	68 a2 00 00 c0	 push	 -1073741662		; c00000a2H
  00196	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00199	52		 push	 edx
  0019a	e8 00 00 00 00	 call	 _GSTCompleteDiskIrp@12
  0019f	e9 09 01 00 00	 jmp	 $LN15@DispatchCo
$LN5@DispatchCo:

; 227  : 			}
; 228  : 
; 229  : 		case GST_IOCTL_DISK_IS_WRITABLE:
; 230  : 			Dump ("GST_IOCTL_DISK_IS_WRITABLE pdo=%p\n", Extension->Pdo);

  001a4	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  001a7	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001aa	51		 push	 ecx
  001ab	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FGGJENKJ@GST_IOCTL_DISK_IS_WRITABLE?5pdo?$DN?$CF@FNODOBFM@
  001b0	e8 00 00 00 00	 call	 _DbgPrint
  001b5	83 c4 08	 add	 esp, 8

; 231  : 
; 232  : 			if (!ProbingHostDeviceForWrite)

  001b8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ProbingHostDeviceForWrite, 0
  001bf	75 05		 jne	 SHORT $LN4@DispatchCo

; 233  : 				break;

  001c1	e9 bc 00 00 00	 jmp	 $LN12@DispatchCo
$LN4@DispatchCo:

; 234  : 
; 235  : 			// Probe the real state of the device as the user is mounting a GostCrypt volume.
; 236  : 
; 237  : 			// Volume filter may be attached to a merged drive+volume PDO. First test if GST_IOCTL_DISK_IS_WRITABLE works for the underlying device.
; 238  : 			status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, GST_IOCTL_DISK_IS_WRITABLE, NULL, 0, NULL, 0);

  001c6	6a 00		 push	 0
  001c8	6a 00		 push	 0
  001ca	6a 00		 push	 0
  001cc	6a 00		 push	 0
  001ce	68 74 20 22 00	 push	 2236532			; 00222074H
  001d3	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  001d6	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  001d9	50		 push	 eax
  001da	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  001df	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 239  : 
; 240  : 			if (NT_SUCCESS (status) || status == STATUS_MEDIA_WRITE_PROTECTED)

  001e2	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  001e6	7d 09		 jge	 SHORT $LN2@DispatchCo
  001e8	81 7d fc a2 00
	00 c0		 cmp	 DWORD PTR _status$[ebp], -1073741662 ; c00000a2H
  001ef	75 2a		 jne	 SHORT $LN3@DispatchCo
$LN2@DispatchCo:

; 241  : 			{
; 242  : 				IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  001f1	6a 58		 push	 88			; 00000058H
  001f3	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  001f6	51		 push	 ecx
  001f7	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  001fa	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  00200	52		 push	 edx
  00201	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 243  : 				return GSTCompleteDiskIrp (Irp, status, 0);

  00207	6a 00		 push	 0
  00209	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
  0020c	50		 push	 eax
  0020d	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00210	51		 push	 ecx
  00211	e8 00 00 00 00	 call	 _GSTCompleteDiskIrp@12
  00216	e9 92 00 00 00	 jmp	 $LN15@DispatchCo
$LN3@DispatchCo:

; 244  : 			}
; 245  : 
; 246  : 			status = SendDeviceIoControlRequest (Extension->LowerDeviceObject, IOCTL_DISK_IS_WRITABLE, NULL, 0, NULL, 0);

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	6a 00		 push	 0
  00221	6a 00		 push	 0
  00223	68 24 00 07 00	 push	 458788			; 00070024H
  00228	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  0022b	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0022e	50		 push	 eax
  0022f	e8 00 00 00 00	 call	 _SendDeviceIoControlRequest@24
  00234	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 247  : 
; 248  : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00237	6a 58		 push	 88			; 00000058H
  00239	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0023c	51		 push	 ecx
  0023d	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  00240	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  00246	52		 push	 edx
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 249  : 			return GSTCompleteDiskIrp (Irp, status, 0);

  0024d	6a 00		 push	 0
  0024f	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
  00252	50		 push	 eax
  00253	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00256	51		 push	 ecx
  00257	e8 00 00 00 00	 call	 _GSTCompleteDiskIrp@12
  0025c	eb 4f		 jmp	 SHORT $LN15@DispatchCo
$LN1@DispatchCo:

; 250  : 
; 251  : 		case IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES:
; 252  : 
; 253  : 			// Filter IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES to enable potential future use of hidden systems on drives that use the trim operation but not wear-leveling (if any appear in future). The documentation forbids users to create hidden volumes/systems on drives that use wear-leveling and consequently also on drives that use trim (as trim is used only by drives that use wear-leveling, as of 2010).
; 254  : 
; 255  : 			IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0025e	6a 58		 push	 88			; 00000058H
  00260	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00263	52		 push	 edx
  00264	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  00267	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  0026c	50		 push	 eax
  0026d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 256  : 			return GSTCompleteDiskIrp (Irp, STATUS_SUCCESS, 0);

  00273	6a 00		 push	 0
  00275	6a 00		 push	 0
  00277	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0027a	51		 push	 ecx
  0027b	e8 00 00 00 00	 call	 _GSTCompleteDiskIrp@12
  00280	eb 2b		 jmp	 SHORT $LN15@DispatchCo
$LN12@DispatchCo:

; 257  : 		}
; 258  : 	}
; 259  : 
; 260  : 	status = PassIrp (Extension->LowerDeviceObject, Irp);

  00282	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00285	52		 push	 edx
  00286	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  00289	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0028c	51		 push	 ecx
  0028d	e8 00 00 00 00	 call	 _PassIrp@8
  00292	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 261  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00295	6a 58		 push	 88			; 00000058H
  00297	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  0029a	52		 push	 edx
  0029b	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  0029e	05 b8 00 00 00	 add	 eax, 184		; 000000b8H
  002a3	50		 push	 eax
  002a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 262  : 	return status;

  002aa	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
$LN15@DispatchCo:

; 263  : }

  002ad	8b e5		 mov	 esp, ebp
  002af	5d		 pop	 ebp
  002b0	c2 10 00	 ret	 16			; 00000010H
_DispatchControl@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@GJODMOBD@IRP_MN_REMOVE_DEVICE?5volume?5pdo?$DN@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CD@BENKCDLN@IRP_MN_START_DEVICE?5volume?5pdo?$DN?$CF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__IoReleaseRemoveLockAndWaitEx@12:PROC
;	COMDAT ??_C@_0CE@GJODMOBD@IRP_MN_REMOVE_DEVICE?5volume?5pdo?$DN@FNODOBFM@
text$s	SEGMENT
??_C@_0CE@GJODMOBD@IRP_MN_REMOVE_DEVICE?5volume?5pdo?$DN@FNODOBFM@ DB 'IR'
	DB	'P_MN_REMOVE_DEVICE volume pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CD@BENKCDLN@IRP_MN_START_DEVICE?5volume?5pdo?$DN?$CF@FNODOBFM@
text$s	SEGMENT
??_C@_0CD@BENKCDLN@IRP_MN_START_DEVICE?5volume?5pdo?$DN?$CF@FNODOBFM@ DB 'I'
	DB	'RP_MN_START_DEVICE volume pdo=%p', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DispatchPnp@16
_TEXT	SEGMENT
tv78 = -12						; size = 4
_attachedDevice$26459 = -8				; size = 4
_status$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_Extension$ = 16					; size = 4
_irpSp$ = 20						; size = 4
_DispatchPnp@16 PROC					; COMDAT

; 278  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 279  : 	NTSTATUS status;
; 280  : 
; 281  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00008	6a 58		 push	 88			; 00000058H
  0000a	68 19 01 00 00	 push	 281			; 00000119H
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0JJ@FGAHJPEG@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
  00014	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00017	50		 push	 eax
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0001b	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00021	51		 push	 ecx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20
  00028	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 282  : 	if (!NT_SUCCESS (status))

  0002b	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  0002f	7d 14		 jge	 SHORT $LN9@DispatchPn

; 283  : 		return GSTCompleteIrp (Irp, status, 0);

  00031	6a 00		 push	 0
  00033	8b 55 fc	 mov	 edx, DWORD PTR _status$[ebp]
  00036	52		 push	 edx
  00037	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _GSTCompleteIrp@12
  00040	e9 36 01 00 00	 jmp	 $LN10@DispatchPn
$LN9@DispatchPn:

; 284  : 
; 285  : 	switch (irpSp->MinorFunction)

  00045	8b 4d 14	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  00048	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0004b	88 55 f4	 mov	 BYTE PTR tv78[ebp], dl
  0004e	80 7d f4 00	 cmp	 BYTE PTR tv78[ebp], 0
  00052	74 15		 je	 SHORT $LN6@DispatchPn
  00054	80 7d f4 02	 cmp	 BYTE PTR tv78[ebp], 2
  00058	0f 84 98 00 00
	00		 je	 $LN2@DispatchPn
  0005e	80 7d f4 16	 cmp	 BYTE PTR tv78[ebp], 22	; 00000016H
  00062	74 37		 je	 SHORT $LN5@DispatchPn
  00064	e9 e6 00 00 00	 jmp	 $LN1@DispatchPn
$LN6@DispatchPn:

; 286  : 	{
; 287  : 	case IRP_MN_START_DEVICE:
; 288  : 		Dump ("IRP_MN_START_DEVICE volume pdo=%p\n", Extension->Pdo);

  00069	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  0006c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0006f	51		 push	 ecx
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@BENKCDLN@IRP_MN_START_DEVICE?5volume?5pdo?$DN?$CF@FNODOBFM@
  00075	e8 00 00 00 00	 call	 _DbgPrint
  0007a	83 c4 08	 add	 esp, 8

; 289  : 		return PassFilteredIrp (Extension->LowerDeviceObject, Irp, OnStartDeviceCompleted, Extension);

  0007d	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  00080	52		 push	 edx
  00081	68 00 00 00 00	 push	 OFFSET _OnStartDeviceCompleted@12
  00086	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0008d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 _PassFilteredIrp@16
  00096	e9 e0 00 00 00	 jmp	 $LN10@DispatchPn
$LN5@DispatchPn:

; 290  : 
; 291  : 	case IRP_MN_DEVICE_USAGE_NOTIFICATION:
; 292  : 		{
; 293  : 			PDEVICE_OBJECT attachedDevice = IoGetAttachedDeviceReference (DeviceObject);

  0009b	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetAttachedDeviceReference@4
  000a5	89 45 f8	 mov	 DWORD PTR _attachedDevice$26459[ebp], eax

; 294  : 
; 295  : 			if (attachedDevice == DeviceObject || (attachedDevice->Flags & DO_POWER_PAGABLE))

  000a8	8b 4d f8	 mov	 ecx, DWORD PTR _attachedDevice$26459[ebp]
  000ab	3b 4d 08	 cmp	 ecx, DWORD PTR _DeviceObject$[ebp]
  000ae	74 0d		 je	 SHORT $LN3@DispatchPn
  000b0	8b 55 f8	 mov	 edx, DWORD PTR _attachedDevice$26459[ebp]
  000b3	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000b6	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  000bb	74 12		 je	 SHORT $LN4@DispatchPn
$LN3@DispatchPn:

; 296  : 				DeviceObject->Flags |= DO_POWER_PAGABLE;

  000bd	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  000c0	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000c3	81 ca 00 20 00
	00		 or	 edx, 8192		; 00002000H
  000c9	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  000cc	89 50 1c	 mov	 DWORD PTR [eax+28], edx
$LN4@DispatchPn:

; 297  : 
; 298  : 			ObDereferenceObject (attachedDevice);

  000cf	8b 4d f8	 mov	 ecx, DWORD PTR _attachedDevice$26459[ebp]
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 299  : 		}
; 300  : 
; 301  : 		return PassFilteredIrp (Extension->LowerDeviceObject, Irp, OnDeviceUsageNotificationCompleted, Extension);

  000d8	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  000db	51		 push	 ecx
  000dc	68 00 00 00 00	 push	 OFFSET _OnDeviceUsageNotificationCompleted@12
  000e1	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  000e4	52		 push	 edx
  000e5	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  000e8	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000eb	51		 push	 ecx
  000ec	e8 00 00 00 00	 call	 _PassFilteredIrp@16
  000f1	e9 85 00 00 00	 jmp	 $LN10@DispatchPn
$LN2@DispatchPn:

; 302  : 
; 303  : 
; 304  : 	case IRP_MN_REMOVE_DEVICE:
; 305  : 		Dump ("IRP_MN_REMOVE_DEVICE volume pdo=%p\n", Extension->Pdo);

  000f6	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  000f9	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  000fc	50		 push	 eax
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@GJODMOBD@IRP_MN_REMOVE_DEVICE?5volume?5pdo?$DN@FNODOBFM@
  00102	e8 00 00 00 00	 call	 _DbgPrint
  00107	83 c4 08	 add	 esp, 8

; 306  : 
; 307  : 		IoReleaseRemoveLockAndWait (&Extension->Queue.RemoveLock, Irp);

  0010a	6a 58		 push	 88			; 00000058H
  0010c	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0010f	51		 push	 ecx
  00110	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  00113	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  00119	52		 push	 edx
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockAndWaitEx@12

; 308  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  00120	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00123	50		 push	 eax
  00124	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00127	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 _PassIrp@8
  00130	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 309  : 
; 310  : 		IoDetachDevice (Extension->LowerDeviceObject);

  00133	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  00136	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00139	51		 push	 ecx
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDetachDevice@4

; 311  : 
; 312  : 		IoDeleteDevice (DeviceObject);

  00140	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  00143	52		 push	 edx
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 313  : 		return status;

  0014a	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
  0014d	eb 2c		 jmp	 SHORT $LN10@DispatchPn
$LN1@DispatchPn:

; 314  : 
; 315  : 	default:
; 316  : 		status = PassIrp (Extension->LowerDeviceObject, Irp);

  0014f	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00152	50		 push	 eax
  00153	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00156	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00159	52		 push	 edx
  0015a	e8 00 00 00 00	 call	 _PassIrp@8
  0015f	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 317  : 		IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00162	6a 58		 push	 88			; 00000058H
  00164	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00167	50		 push	 eax
  00168	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0016b	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00171	51		 push	 ecx
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 318  : 	}
; 319  : 
; 320  : 	return status;

  00178	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
$LN10@DispatchPn:

; 321  : }

  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c2 10 00	 ret	 16			; 00000010H
_DispatchPnp@16 ENDP
_TEXT	ENDS
PUBLIC	_IoSetCompletionRoutine@24
PUBLIC	_IoCopyCurrentIrpStackLocationToNext@4
; Function compile flags: /Odtp
;	COMDAT _PassFilteredIrp@16
_TEXT	SEGMENT
_deviceObject$ = 8					; size = 4
_irp$ = 12						; size = 4
_completionRoutine$ = 16				; size = 4
_completionRoutineArg$ = 20				; size = 4
_PassFilteredIrp@16 PROC				; COMDAT

; 122  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 123  : 	IoCopyCurrentIrpStackLocationToNext (irp);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _irp$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _IoCopyCurrentIrpStackLocationToNext@4

; 124  : 
; 125  : 	if (completionRoutine)

  0000e	83 7d 10 00	 cmp	 DWORD PTR _completionRoutine$[ebp], 0
  00012	74 17		 je	 SHORT $LN1@PassFilter

; 126  : 		IoSetCompletionRoutine (irp, completionRoutine, completionRoutineArg, TRUE, TRUE, TRUE);

  00014	6a 01		 push	 1
  00016	6a 01		 push	 1
  00018	6a 01		 push	 1
  0001a	8b 4d 14	 mov	 ecx, DWORD PTR _completionRoutineArg$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 55 10	 mov	 edx, DWORD PTR _completionRoutine$[ebp]
  00021	52		 push	 edx
  00022	8b 45 0c	 mov	 eax, DWORD PTR _irp$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _IoSetCompletionRoutine@24
$LN1@PassFilter:

; 127  : 
; 128  : 	return IoCallDriver (deviceObject, irp);

  0002b	8b 55 0c	 mov	 edx, DWORD PTR _irp$[ebp]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _deviceObject$[ebp]
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 129  : }

  00037	5d		 pop	 ebp
  00038	c2 10 00	 ret	 16			; 00000010H
_PassFilteredIrp@16 ENDP
_TEXT	ENDS
PUBLIC	_IoGetNextIrpStackLocation@4
PUBLIC	??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@ DB '('
	DB	'InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (Comple'
	DB	'tionRoutine != NULL) : TRUE', 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoSetCompletionRoutine@24
_TEXT	SEGMENT
tv78 = -12						; size = 4
tv72 = -8						; size = 4
_irpSp$ = -4						; size = 4
_Irp$ = 8						; size = 4
_CompletionRoutine$ = 12				; size = 4
_Context$ = 16						; size = 4
_InvokeOnSuccess$ = 20					; size = 1
_InvokeOnError$ = 24					; size = 1
_InvokeOnCancel$ = 28					; size = 1
_IoSetCompletionRoutine@24 PROC				; COMDAT

; 23820: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 23821:     PIO_STACK_LOCATION irpSp;
; 23822:     ASSERT( (InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (CompletionRoutine != NULL) : TRUE );

  00008	0f b6 45 14	 movzx	 eax, BYTE PTR _InvokeOnSuccess$[ebp]
  0000c	85 c0		 test	 eax, eax
  0000e	75 19		 jne	 SHORT $LN6@IoSetCompl
  00010	0f b6 4d 18	 movzx	 ecx, BYTE PTR _InvokeOnError$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	75 11		 jne	 SHORT $LN6@IoSetCompl
  00018	0f b6 55 1c	 movzx	 edx, BYTE PTR _InvokeOnCancel$[ebp]
  0001c	85 d2		 test	 edx, edx
  0001e	75 09		 jne	 SHORT $LN6@IoSetCompl
  00020	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  00027	eb 0c		 jmp	 SHORT $LN7@IoSetCompl
$LN6@IoSetCompl:
  00029	33 c0		 xor	 eax, eax
  0002b	83 7d 0c 00	 cmp	 DWORD PTR _CompletionRoutine$[ebp], 0
  0002f	0f 95 c0	 setne	 al
  00032	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
$LN7@IoSetCompl:
  00035	83 7d f8 00	 cmp	 DWORD PTR tv72[ebp], 0
  00039	75 20		 jne	 SHORT $LN8@IoSetCompl
  0003b	6a 00		 push	 0
  0003d	68 0e 5d 00 00	 push	 23822			; 00005d0eH
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00052	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00059	eb 07		 jmp	 SHORT $LN9@IoSetCompl
$LN8@IoSetCompl:
  0005b	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
$LN9@IoSetCompl:

; 23823:     irpSp = IoGetNextIrpStackLocation(Irp);

  00062	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 _IoGetNextIrpStackLocation@4
  0006b	89 45 fc	 mov	 DWORD PTR _irpSp$[ebp], eax

; 23824:     irpSp->CompletionRoutine = CompletionRoutine;

  0006e	8b 55 fc	 mov	 edx, DWORD PTR _irpSp$[ebp]
  00071	8b 45 0c	 mov	 eax, DWORD PTR _CompletionRoutine$[ebp]
  00074	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 23825:     irpSp->Context = Context;

  00077	8b 4d fc	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  0007a	8b 55 10	 mov	 edx, DWORD PTR _Context$[ebp]
  0007d	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 23826:     irpSp->Control = 0;

  00080	8b 45 fc	 mov	 eax, DWORD PTR _irpSp$[ebp]
  00083	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 23827: 
; 23828:     if (InvokeOnSuccess) {

  00087	0f b6 4d 14	 movzx	 ecx, BYTE PTR _InvokeOnSuccess$[ebp]
  0008b	85 c9		 test	 ecx, ecx
  0008d	74 07		 je	 SHORT $LN3@IoSetCompl

; 23829:         irpSp->Control = SL_INVOKE_ON_SUCCESS;

  0008f	8b 55 fc	 mov	 edx, DWORD PTR _irpSp$[ebp]
  00092	c6 42 03 40	 mov	 BYTE PTR [edx+3], 64	; 00000040H
$LN3@IoSetCompl:

; 23830:     }
; 23831: 
; 23832:     if (InvokeOnError) {

  00096	0f b6 45 18	 movzx	 eax, BYTE PTR _InvokeOnError$[ebp]
  0009a	85 c0		 test	 eax, eax
  0009c	74 13		 je	 SHORT $LN2@IoSetCompl

; 23833:         irpSp->Control |= SL_INVOKE_ON_ERROR;

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  000a1	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  000a5	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  000ab	8b 45 fc	 mov	 eax, DWORD PTR _irpSp$[ebp]
  000ae	88 50 03	 mov	 BYTE PTR [eax+3], dl
$LN2@IoSetCompl:

; 23834:     }
; 23835: 
; 23836:     if (InvokeOnCancel) {

  000b1	0f b6 4d 1c	 movzx	 ecx, BYTE PTR _InvokeOnCancel$[ebp]
  000b5	85 c9		 test	 ecx, ecx
  000b7	74 10		 je	 SHORT $LN4@IoSetCompl

; 23837:         irpSp->Control |= SL_INVOKE_ON_CANCEL;

  000b9	8b 55 fc	 mov	 edx, DWORD PTR _irpSp$[ebp]
  000bc	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  000c0	83 c8 20	 or	 eax, 32			; 00000020H
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _irpSp$[ebp]
  000c6	88 41 03	 mov	 BYTE PTR [ecx+3], al
$LN4@IoSetCompl:

; 23838:     }
; 23839: }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 18 00	 ret	 24			; 00000018H
_IoSetCompletionRoutine@24 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@ DB 'Irp'
	DB	'->CurrentLocation > 0', 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetNextIrpStackLocation@4
_TEXT	SEGMENT
tv71 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetNextIrpStackLocation@4 PROC			; COMDAT

; 23479: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23480:     ASSERT(Irp->CurrentLocation > 0);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	0f be 48 23	 movsx	 ecx, BYTE PTR [eax+35]
  0000d	85 c9		 test	 ecx, ecx
  0000f	7f 20		 jg	 SHORT $LN3@IoGetNextI
  00011	6a 00		 push	 0
  00013	68 b8 5b 00 00	 push	 23480			; 00005bb8H
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LIHGPBLF@c?3?2winddk?27600?416385?41?2inc?2ddk?2w@FNODOBFM@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlAssert@16
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  0002f	eb 07		 jmp	 SHORT $LN4@IoGetNextI
$LN3@IoGetNextI:
  00031	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN4@IoGetNextI:

; 23481: 
; 23482:     return ((Irp)->Tail.Overlay.CurrentStackLocation - 1 );

  00038	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  0003b	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0003e	83 e8 24	 sub	 eax, 36			; 00000024H

; 23483: }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
_IoGetNextIrpStackLocation@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _IoCopyCurrentIrpStackLocationToNext@4
_TEXT	SEGMENT
_irpSp$ = -8						; size = 4
_nextIrpSp$ = -4					; size = 4
_Irp$ = 8						; size = 4
_IoCopyCurrentIrpStackLocationToNext@4 PROC		; COMDAT

; 23912: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	83 ec 08	 sub	 esp, 8
  00008	56		 push	 esi
  00009	57		 push	 edi

; 23913:     PIO_STACK_LOCATION irpSp;
; 23914:     PIO_STACK_LOCATION nextIrpSp;
; 23915:     irpSp = IoGetCurrentIrpStackLocation(Irp);

  0000a	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  00013	89 45 f8	 mov	 DWORD PTR _irpSp$[ebp], eax

; 23916:     nextIrpSp = IoGetNextIrpStackLocation(Irp);

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 _IoGetNextIrpStackLocation@4
  0001f	89 45 fc	 mov	 DWORD PTR _nextIrpSp$[ebp], eax

; 23917:     RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine));

  00022	b9 07 00 00 00	 mov	 ecx, 7
  00027	8b 75 f8	 mov	 esi, DWORD PTR _irpSp$[ebp]
  0002a	8b 7d fc	 mov	 edi, DWORD PTR _nextIrpSp$[ebp]
  0002d	f3 a5		 rep movsd

; 23918:     nextIrpSp->Control = 0;

  0002f	8b 55 fc	 mov	 edx, DWORD PTR _nextIrpSp$[ebp]
  00032	c6 42 03 00	 mov	 BYTE PTR [edx+3], 0

; 23919: }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
_IoCopyCurrentIrpStackLocationToNext@4 ENDP
_TEXT	ENDS
PUBLIC	_IoMarkIrpPending@4
; Function compile flags: /Odtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\volumefilter.c
;	COMDAT _OnDeviceUsageNotificationCompleted@12
_TEXT	SEGMENT
_filterDeviceObject$ = 8				; size = 4
_Irp$ = 12						; size = 4
_Extension$ = 16					; size = 4
_OnDeviceUsageNotificationCompleted@12 PROC		; COMDAT

; 143  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 144  : 	if (Irp->PendingReturned)

  00005	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	0f b6 48 21	 movzx	 ecx, BYTE PTR [eax+33]
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 09		 je	 SHORT $LN2@OnDeviceUs

; 145  : 		IoMarkIrpPending (Irp);

  00010	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _IoMarkIrpPending@4
$LN2@OnDeviceUs:

; 146  : 
; 147  : 	if (!(Extension->LowerDeviceObject->Flags & DO_POWER_PAGABLE))

  00019	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  0001c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0001f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00022	81 e2 00 20 00
	00		 and	 edx, 8192		; 00002000H
  00028	75 12		 jne	 SHORT $LN1@OnDeviceUs

; 148  : 		filterDeviceObject->Flags &= ~DO_POWER_PAGABLE;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  0002d	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00030	81 e1 ff df ff
	ff		 and	 ecx, -8193		; ffffdfffH
  00036	8b 55 08	 mov	 edx, DWORD PTR _filterDeviceObject$[ebp]
  00039	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx
$LN1@OnDeviceUs:

; 149  : 
; 150  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  0003c	6a 58		 push	 88			; 00000058H
  0003e	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00041	50		 push	 eax
  00042	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00045	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  0004b	51		 push	 ecx
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 151  : 	return STATUS_CONTINUE_COMPLETION;

  00052	33 c0		 xor	 eax, eax

; 152  : }

  00054	5d		 pop	 ebp
  00055	c2 0c 00	 ret	 12			; 0000000cH
_OnDeviceUsageNotificationCompleted@12 ENDP
; Function compile flags: /Odtp
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _IoMarkIrpPending@4
_TEXT	SEGMENT
tv67 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoMarkIrpPending@4 PROC				; COMDAT

; 23667: {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 23668:     IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED;

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _IoGetCurrentIrpStackLocation@4
  0000f	83 c0 03	 add	 eax, 3
  00012	89 45 fc	 mov	 DWORD PTR tv67[ebp], eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR tv67[ebp]
  00018	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0001b	83 ca 01	 or	 edx, 1
  0001e	8b 45 fc	 mov	 eax, DWORD PTR tv67[ebp]
  00021	88 10		 mov	 BYTE PTR [eax], dl

; 23669: }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
_IoMarkIrpPending@4 ENDP
; Function compile flags: /Odtp
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\volumefilter.c
_TEXT	ENDS
;	COMDAT _OnStartDeviceCompleted@12
_TEXT	SEGMENT
_filterDeviceObject$ = 8				; size = 4
_Irp$ = 12						; size = 4
_Extension$ = 16					; size = 4
_OnStartDeviceCompleted@12 PROC				; COMDAT

; 166  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp

; 167  : 	if (Irp->PendingReturned)

  00005	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	0f b6 48 21	 movzx	 ecx, BYTE PTR [eax+33]
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 09		 je	 SHORT $LN2@OnStartDev

; 168  : 		IoMarkIrpPending (Irp);

  00010	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _IoMarkIrpPending@4
$LN2@OnStartDev:

; 169  : 
; 170  : 	if (Extension->LowerDeviceObject->Characteristics & FILE_REMOVABLE_MEDIA)

  00019	8b 45 10	 mov	 eax, DWORD PTR _Extension$[ebp]
  0001c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0001f	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00022	83 e2 01	 and	 edx, 1
  00025	74 0f		 je	 SHORT $LN1@OnStartDev

; 171  : 		filterDeviceObject->Characteristics |= FILE_REMOVABLE_MEDIA;

  00027	8b 45 08	 mov	 eax, DWORD PTR _filterDeviceObject$[ebp]
  0002a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0002d	83 c9 01	 or	 ecx, 1
  00030	8b 55 08	 mov	 edx, DWORD PTR _filterDeviceObject$[ebp]
  00033	89 4a 20	 mov	 DWORD PTR [edx+32], ecx
$LN1@OnStartDev:

; 172  : 
; 173  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00036	6a 58		 push	 88			; 00000058H
  00038	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0003f	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00045	51		 push	 ecx
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 174  : 	return STATUS_CONTINUE_COMPLETION;

  0004c	33 c0		 xor	 eax, eax

; 175  : }

  0004e	5d		 pop	 ebp
  0004f	c2 0c 00	 ret	 12			; 0000000cH
_OnStartDeviceCompleted@12 ENDP
_TEXT	ENDS
EXTRN	__imp__PoCallDriver@8:PROC
EXTRN	__imp__PoStartNextPowerIrp@4:PROC
; Function compile flags: /Odtp
;	COMDAT _DispatchPower@16
_TEXT	SEGMENT
_status$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_Extension$ = 16					; size = 4
_irpSp$ = 20						; size = 4
_DispatchPower@16 PROC					; COMDAT

; 336  : {

  00000	8b ff		 npad	 2
  00002	55		 push	 ebp
  00003	8b ec		 mov	 ebp, esp
  00005	51		 push	 ecx

; 337  : 	NTSTATUS status;
; 338  : 	PoStartNextPowerIrp (Irp);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 339  : 
; 340  : 	status = IoAcquireRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00010	6a 58		 push	 88			; 00000058H
  00012	68 54 01 00 00	 push	 340			; 00000154H
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0JJ@FGAHJPEG@c?3?2users?2alexis?2desktop?2sources_@FNODOBFM@
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 10	 mov	 edx, DWORD PTR _Extension$[ebp]
  00023	81 c2 b8 00 00
	00		 add	 edx, 184		; 000000b8H
  00029	52		 push	 edx
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAcquireRemoveLockEx@20
  00030	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 341  : 	if (!NT_SUCCESS (status))

  00033	83 7d fc 00	 cmp	 DWORD PTR _status$[ebp], 0
  00037	7d 11		 jge	 SHORT $LN1@DispatchPo

; 342  : 		return GSTCompleteIrp (Irp, status, 0);

  00039	6a 00		 push	 0
  0003b	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 _GSTCompleteIrp@12
  00048	eb 36		 jmp	 SHORT $LN2@DispatchPo
$LN1@DispatchPo:

; 343  : 
; 344  : 	IoSkipCurrentIrpStackLocation (Irp);

  0004a	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 _IoSkipCurrentIrpStackLocation@4

; 345  : 	status = PoCallDriver (Extension->LowerDeviceObject, Irp);

  00053	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00056	50		 push	 eax
  00057	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  0005a	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0005d	52		 push	 edx
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoCallDriver@8
  00064	89 45 fc	 mov	 DWORD PTR _status$[ebp], eax

; 346  : 
; 347  : 	IoReleaseRemoveLock (&Extension->Queue.RemoveLock, Irp);

  00067	6a 58		 push	 88			; 00000058H
  00069	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d 10	 mov	 ecx, DWORD PTR _Extension$[ebp]
  00070	81 c1 b8 00 00
	00		 add	 ecx, 184		; 000000b8H
  00076	51		 push	 ecx
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseRemoveLockEx@12

; 348  : 	return status;

  0007d	8b 45 fc	 mov	 eax, DWORD PTR _status$[ebp]
$LN2@DispatchPo:

; 349  : }

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 10 00	 ret	 16			; 00000010H
_DispatchPower@16 ENDP
_TEXT	ENDS
END
