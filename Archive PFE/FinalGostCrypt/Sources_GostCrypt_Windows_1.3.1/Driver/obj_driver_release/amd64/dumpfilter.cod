; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_MmMapLockedPagesSpecifyCache:PROC
	ALIGN	8

BootDriveFilterExtension DQ 01H DUP (?)
WriteFilterBuffer DQ 01H DUP (?)
;	COMDAT ??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'G', 00H, 'o', 00H, 's', 00H, 't', 00H, 'C', 00H, 'r'
	DB	00H, 'y', 00H, 'p', 00H, 't', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
WriteFilterBufferSize DQ 01H DUP (?)
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\dumpfilter.c
pdata	SEGMENT
$pdata$DumpFilterUnload DD imagerel DumpFilterUnload
	DD	imagerel DumpFilterUnload+63
	DD	imagerel $unwind$DumpFilterUnload
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DumpFilterUnload DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DumpFilterUnload
_TEXT	SEGMENT
filterExtension$ = 48
DumpFilterUnload PROC					; COMDAT

; 285  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 286  : 	Dump ("DumpFilterUnload type=%d\n", filterExtension->DumpType);
; 287  : 
; 288  : 	if (WriteFilterBuffer)

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR WriteFilterBuffer, 0
  0000c	74 2a		 je	 SHORT $LN1@DumpFilter

; 289  : 	{
; 290  : 		memset (WriteFilterBuffer, 0, WriteFilterBufferSize);

  0000e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR WriteFilterBufferSize
  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR WriteFilterBuffer
  0001c	33 d2		 xor	 edx, edx
  0001e	e8 00 00 00 00	 call	 memset

; 291  : 		MmFreeContiguousMemory (WriteFilterBuffer);

  00023	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR WriteFilterBuffer
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmFreeContiguousMemory

; 292  : 		WriteFilterBuffer = NULL;

  00030	48 83 25 00 00
	00 00 00	 and	 QWORD PTR WriteFilterBuffer, 0
$LN1@DumpFilter:

; 293  : 	}
; 294  : 
; 295  : 	return STATUS_SUCCESS;

  00038	33 c0		 xor	 eax, eax

; 296  : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
DumpFilterUnload ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT DumpFilterFinish
_TEXT	SEGMENT
filterExtension$ = 8
DumpFilterFinish PROC					; COMDAT

; 270  : 	Dump ("DumpFilterFinish type=%d\n", filterExtension->DumpType);
; 271  : 
; 272  : 	return STATUS_SUCCESS;

  00000	33 c0		 xor	 eax, eax

; 273  : }

  00002	c3		 ret	 0
DumpFilterFinish ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DumpFilterStart DD imagerel DumpFilterStart
	DD	imagerel DumpFilterStart+84
	DD	imagerel $unwind$DumpFilterStart
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DumpFilterStart DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DumpFilterStart
_TEXT	SEGMENT
filterExtension$ = 64
DumpFilterStart PROC					; COMDAT

; 167  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 168  : 	Dump ("DumpFilterStart type=%d\n", filterExtension->DumpType);
; 169  : 
; 170  : 	if (BootDriveFilterExtension->MagicNumber != GST_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0000b	48 b9 54 58 45
	42 45 55 52 54	 mov	 rcx, 6076012603229165652 ; 5452554542455854H
  00015	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00019	74 23		 je	 SHORT $LN1@DumpFilter@2

; 171  : 		GST_BUG_CHECK (STATUS_CRC_ERROR);

  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	ba ab 00 00 00	 mov	 edx, 171		; 000000abH
  00023	49 c7 c0 3f 00
	00 c0		 mov	 r8, -1073741761		; ffffffffc000003fH
  0002a	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  0002e	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0003d	cc		 int	 3
$LN1@DumpFilter@2:

; 172  : 
; 173  : 	return BootDriveFilterExtension->DriveMounted ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

  0003e	8b 80 b8 02 00
	00		 mov	 eax, DWORD PTR [rax+696]
  00044	f7 d8		 neg	 eax
  00046	1b c0		 sbb	 eax, eax
  00048	f7 d0		 not	 eax
  0004a	25 01 00 00 c0	 and	 eax, -1073741823	; ffffffffc0000001H

; 174  : }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
$LN4@DumpFilter@2:
DumpFilterStart ENDP
	ALIGN	8

DumpPartitionOffset DQ 01H DUP (?)
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntdriver.c
pdata	SEGMENT
$pdata$DumpFilterWrite DD imagerel DumpFilterWrite
	DD	imagerel DumpFilterWrite+695
	DD	imagerel $unwind$DumpFilterWrite
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DumpFilterWrite DD 0a1801H
	DD	0d6418H
	DD	0c5418H
	DD	0a3418H
	DD	0d0145218H
	DD	07010c012H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\dumpfilter.c
xdata	ENDS
;	COMDAT DumpFilterWrite
_TEXT	SEGMENT
filterExtension$ = 80
dataUnit$28086 = 88
diskWriteOffset$ = 88
writeMdl$ = 96
DumpFilterWrite PROC					; COMDAT

; 188  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	49 89 6b 18	 mov	 QWORD PTR [r11+24], rbp
  0000b	49 89 73 20	 mov	 QWORD PTR [r11+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 189  : 	ULONG dataLength = MmGetMdlByteCount (writeMdl);
; 190  : 	uint64 offset = DumpPartitionOffset.QuadPart + diskWriteOffset->QuadPart;

  00018	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR DumpPartitionOffset

; 191  : 	uint64 intersectStart;
; 192  : 	uint32 intersectLength;
; 193  : 	PVOID writeBuffer;
; 194  : 	CSHORT origMdlFlags;
; 195  : 
; 196  : 	if (BootDriveFilterExtension->MagicNumber != GST_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  00026	41 8b 70 28	 mov	 esi, DWORD PTR [r8+40]
  0002a	48 03 1a	 add	 rbx, QWORD PTR [rdx]
  0002d	48 b9 54 58 45
	42 45 55 52 54	 mov	 rcx, 6076012603229165652 ; 5452554542455854H
  00037	49 8b f8	 mov	 rdi, r8
  0003a	48 8b ea	 mov	 rbp, rdx
  0003d	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00041	74 22		 je	 SHORT $LN10@DumpFilter@3

; 197  : 		GST_BUG_CHECK (STATUS_CRC_ERROR);

  00043	45 33 c9	 xor	 r9d, r9d
  00046	ba c5 00 00 00	 mov	 edx, 197		; 000000c5H
  0004b	49 c7 c0 3f 00
	00 c0		 mov	 r8, -1073741761		; ffffffffc000003fH
  00052	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00056	49 c7 43 d8 54
	53 47 00	 mov	 QWORD PTR [r11-40], 4674388 ; 00475354H
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00064	cc		 int	 3
$LN10@DumpFilter@3:

; 198  : 
; 199  : 	if (BootDriveFilterExtension->Queue.EncryptedAreaEndUpdatePending)	// Hibernation should always abort the setup thread

  00065	8b 80 d8 00 00
	00		 mov	 eax, DWORD PTR [rax+216]
  0006b	45 33 ed	 xor	 r13d, r13d
  0006e	41 3b c5	 cmp	 eax, r13d
  00071	74 23		 je	 SHORT $LN9@DumpFilter@3

; 200  : 		GST_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00073	41 8d 4d 29	 lea	 ecx, QWORD PTR [r13+41]
  00077	45 33 c9	 xor	 r9d, r9d
  0007a	ba c8 00 00 00	 mov	 edx, 200		; 000000c8H
  0007f	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  00086	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00095	cc		 int	 3
$LN9@DumpFilter@3:

; 201  : 
; 202  : 	if (BootDriveFilterExtension->Queue.EncryptedAreaStart == -1 || BootDriveFilterExtension->Queue.EncryptedAreaEnd == -1)

  00096	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0009d	48 83 b8 c8 00
	00 00 ff	 cmp	 QWORD PTR [rax+200], -1
  000a5	0f 84 f1 01 00
	00		 je	 $LN7@DumpFilter@3
  000ab	48 8b 80 d0 00
	00 00		 mov	 rax, QWORD PTR [rax+208]
  000b2	48 83 f8 ff	 cmp	 rax, -1
  000b6	0f 84 e0 01 00
	00		 je	 $LN7@DumpFilter@3

; 203  : 		return STATUS_SUCCESS;
; 204  : 
; 205  : 	if (dataLength > WriteFilterBufferSize)

  000bc	48 3b 35 00 00
	00 00		 cmp	 rsi, QWORD PTR WriteFilterBufferSize
  000c3	76 23		 jbe	 SHORT $LN6@DumpFilter@3

; 206  : 		GST_BUG_CHECK (STATUS_BUFFER_OVERFLOW);	// Bug check is required as returning an error does not prevent data from being written to disk

  000c5	45 33 c9	 xor	 r9d, r9d
  000c8	ba ce 00 00 00	 mov	 edx, 206		; 000000ceH
  000cd	49 c7 c0 05 00
	00 80		 mov	 r8, -2147483643		; ffffffff80000005H
  000d4	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  000d8	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  000e7	cc		 int	 3
$LN6@DumpFilter@3:

; 207  : 
; 208  : 	if ((dataLength & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  000e8	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  000ed	85 f0		 test	 esi, eax
  000ef	74 23		 je	 SHORT $LN5@DumpFilter@3

; 209  : 		GST_BUG_CHECK (STATUS_INVALID_PARAMETER);

  000f1	45 33 c9	 xor	 r9d, r9d
  000f4	ba d1 00 00 00	 mov	 edx, 209		; 000000d1H
  000f9	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  00100	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00104	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  00113	cc		 int	 3
$LN5@DumpFilter@3:

; 210  : 
; 211  : 	if ((offset & (ENCRYPTION_DATA_UNIT_SIZE - 1)) != 0)

  00114	48 85 d8	 test	 rbx, rax
  00117	74 23		 je	 SHORT $LN4@DumpFilter@3

; 212  : 		GST_BUG_CHECK (STATUS_INVALID_PARAMETER);

  00119	45 33 c9	 xor	 r9d, r9d
  0011c	ba d4 00 00 00	 mov	 edx, 212		; 000000d4H
  00121	49 c7 c0 0d 00
	00 c0		 mov	 r8, -1073741811		; ffffffffc000000dH
  00128	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  0012c	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0013b	cc		 int	 3
$LN4@DumpFilter@3:

; 213  : 
; 214  : 	writeBuffer = MmGetSystemAddressForMdlSafe (writeMdl, HighPagePriority);

  0013c	41 f6 40 0a 05	 test	 BYTE PTR [r8+10], 5
  00141	74 06		 je	 SHORT $LN13@DumpFilter@3
  00143	49 8b 40 18	 mov	 rax, QWORD PTR [r8+24]
  00147	eb 1f		 jmp	 SHORT $LN14@DumpFilter@3
$LN13@DumpFilter@3:
  00149	45 33 c9	 xor	 r9d, r9d
  0014c	33 d2		 xor	 edx, edx
  0014e	48 8b cf	 mov	 rcx, rdi
  00151	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  00155	c7 44 24 28 20
	00 00 00	 mov	 DWORD PTR [rsp+40], 32	; 00000020H
  0015d	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapLockedPagesSpecifyCache
$LN14@DumpFilter@3:

; 215  : 	if (!writeBuffer)

  00168	49 3b c5	 cmp	 rax, r13
  0016b	75 23		 jne	 SHORT $LN3@DumpFilter@3

; 216  : 		GST_BUG_CHECK (STATUS_INSUFFICIENT_RESOURCES);

  0016d	45 33 c9	 xor	 r9d, r9d
  00170	ba d8 00 00 00	 mov	 edx, 216		; 000000d8H
  00175	49 c7 c0 9a 00
	00 c0		 mov	 r8, -1073741670		; ffffffffc000009aH
  0017c	41 8d 49 29	 lea	 ecx, QWORD PTR [r9+41]
  00180	48 c7 44 24 20
	54 53 47 00	 mov	 QWORD PTR [rsp+32], 4674388 ; 00475354H
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeBugCheckEx
  0018f	cc		 int	 3
$LN3@DumpFilter@3:

; 217  : 
; 218  : 	memcpy (WriteFilterBuffer, writeBuffer, dataLength);

  00190	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR WriteFilterBuffer
  00197	4c 8b c6	 mov	 r8, rsi
  0019a	48 8b d0	 mov	 rdx, rax
  0019d	e8 00 00 00 00	 call	 memcpy

; 219  : 
; 220  : 	GetIntersection (offset,
; 221  : 		dataLength,
; 222  : 		BootDriveFilterExtension->Queue.EncryptedAreaStart,
; 223  : 		BootDriveFilterExtension->Queue.EncryptedAreaEnd,
; 224  : 		&intersectStart,
; 225  : 		&intersectLength);

  001a2	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR BootDriveFilterExtension
  001a9	48 8d 44 1e ff	 lea	 rax, QWORD PTR [rsi+rbx-1]
  001ae	49 8b 93 d0 00
	00 00		 mov	 rdx, QWORD PTR [r11+208]
  001b5	4c 8b 15 00 00
	00 00		 mov	 r10, QWORD PTR BootDriveFilterExtension
  001bc	4d 8b 8a c8 00
	00 00		 mov	 r9, QWORD PTR [r10+200]
  001c3	48 3b c2	 cmp	 rax, rdx
  001c6	48 0f 46 d0	 cmovbe	 rdx, rax
  001ca	49 3b d9	 cmp	 rbx, r9
  001cd	4c 0f 43 cb	 cmovae	 r9, rbx
  001d1	4c 3b ca	 cmp	 r9, rdx
  001d4	76 05		 jbe	 SHORT $LN18@DumpFilter@3
  001d6	41 8b d5	 mov	 edx, r13d
  001d9	eb 08		 jmp	 SHORT $LN20@DumpFilter@3
$LN18@DumpFilter@3:
  001db	41 2b d1	 sub	 edx, r9d
  001de	83 c2 01	 add	 edx, 1
  001e1	75 03		 jne	 SHORT $LN15@DumpFilter@3
$LN20@DumpFilter@3:
  001e3	4c 8b cb	 mov	 r9, rbx
$LN15@DumpFilter@3:

; 226  : 
; 227  : 	if (intersectLength > 0)

  001e6	41 3b d5	 cmp	 edx, r13d
  001e9	76 51		 jbe	 SHORT $LN2@DumpFilter@3

; 228  : 	{
; 229  : 		UINT64_STRUCT dataUnit;
; 230  : 		dataUnit.Value = intersectStart / ENCRYPTION_DATA_UNIT_SIZE;

  001eb	49 8b c1	 mov	 rax, r9
  001ee	48 c1 e8 09	 shr	 rax, 9
  001f2	48 89 44 24 58	 mov	 QWORD PTR dataUnit$28086[rsp], rax

; 231  : 
; 232  : 		if (BootDriveFilterExtension->Queue.RemapEncryptedArea)

  001f7	45 39 aa dc 00
	00 00		 cmp	 DWORD PTR [r10+220], r13d
  001fe	74 17		 je	 SHORT $LN1@DumpFilter@3

; 233  : 		{
; 234  : 			diskWriteOffset->QuadPart += BootDriveFilterExtension->Queue.RemappedAreaOffset;

  00200	49 8b 8a e0 00
	00 00		 mov	 rcx, QWORD PTR [r10+224]
  00207	48 01 4d 00	 add	 QWORD PTR [rbp], rcx

; 235  : 			dataUnit.Value += BootDriveFilterExtension->Queue.RemappedAreaDataUnitOffset;

  0020b	49 03 82 e8 00
	00 00		 add	 rax, QWORD PTR [r10+232]
  00212	48 89 44 24 58	 mov	 QWORD PTR dataUnit$28086[rsp], rax
$LN1@DumpFilter@3:

; 236  : 		}
; 237  : 
; 238  : 		EncryptDataUnitsCurrentThread (WriteFilterBuffer + (intersectStart - offset),
; 239  : 			&dataUnit,
; 240  : 			intersectLength / ENCRYPTION_DATA_UNIT_SIZE,
; 241  : 			BootDriveFilterExtension->Queue.CryptoInfo);

  00217	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR WriteFilterBuffer
  0021e	44 8b c2	 mov	 r8d, edx
  00221	48 8d 54 24 58	 lea	 rdx, QWORD PTR dataUnit$28086[rsp]
  00226	48 2b cb	 sub	 rcx, rbx
  00229	49 c1 e8 09	 shr	 r8, 9
  0022d	49 03 c9	 add	 rcx, r9
  00230	4d 8b 8a 98 00
	00 00		 mov	 r9, QWORD PTR [r10+152]
  00237	e8 00 00 00 00	 call	 EncryptDataUnitsCurrentThread
$LN2@DumpFilter@3:

; 242  : 	}
; 243  : 
; 244  : 	origMdlFlags = writeMdl->MdlFlags;
; 245  : 
; 246  : 	MmInitializeMdl (writeMdl, WriteFilterBuffer, dataLength);

  0023c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR WriteFilterBuffer
  00243	0f b7 5f 0a	 movzx	 ebx, WORD PTR [rdi+10]
  00247	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  0024c	44 8b c2	 mov	 r8d, edx
  0024f	8b c6		 mov	 eax, esi
  00251	48 81 e2 00 f0
	ff ff		 and	 rdx, -4096		; fffffffffffff000H
  00258	23 c1		 and	 eax, ecx
  0025a	44 23 c1	 and	 r8d, ecx
  0025d	4c 89 2f	 mov	 QWORD PTR [rdi], r13
  00260	42 8d 8c 00 ff
	0f 00 00	 lea	 ecx, DWORD PTR [rax+r8+4095]
  00268	8b c6		 mov	 eax, esi
  0026a	66 44 89 6f 0a	 mov	 WORD PTR [rdi+10], r13w
  0026f	c1 e9 0c	 shr	 ecx, 12
  00272	c1 e8 0c	 shr	 eax, 12
  00275	48 89 57 20	 mov	 QWORD PTR [rdi+32], rdx
  00279	66 03 c8	 add	 cx, ax
  0027c	44 89 47 2c	 mov	 DWORD PTR [rdi+44], r8d
  00280	89 77 28	 mov	 DWORD PTR [rdi+40], esi
  00283	66 83 c1 06	 add	 cx, 6
  00287	66 c1 e1 03	 shl	 cx, 3
  0028b	66 89 4f 08	 mov	 WORD PTR [rdi+8], cx

; 247  : 	MmBuildMdlForNonPagedPool (writeMdl);

  0028f	48 8b cf	 mov	 rcx, rdi
  00292	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmBuildMdlForNonPagedPool

; 248  : 
; 249  : 	// Instead of using MmGetSystemAddressForMdlSafe(), some buggy custom storage drivers may directly test MDL_MAPPED_TO_SYSTEM_VA flag,
; 250  : 	// disregarding the fact that other MDL flags may be set by the system or a dump filter (e.g. MDL_SOURCE_IS_NONPAGED_POOL flag only).
; 251  : 	// Therefore, to work around this issue, the original flags will be restored even if they do not match the new MDL.
; 252  : 	// MS BitLocker also uses this hack/workaround (it should be safe to use until the MDL structure is changed).
; 253  : 
; 254  : 	writeMdl->MdlFlags = origMdlFlags;

  00298	66 89 5f 0a	 mov	 WORD PTR [rdi+10], bx
$LN7@DumpFilter@3:

; 255  : 
; 256  : 	return STATUS_SUCCESS;
; 257  : }

  0029c	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  002a1	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  002a6	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  002ab	33 c0		 xor	 eax, eax
  002ad	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002b1	41 5d		 pop	 r13
  002b3	41 5c		 pop	 r12
  002b5	5f		 pop	 rdi
  002b6	c3		 ret	 0
$LN21@DumpFilter@3:
DumpFilterWrite ENDP
PUBLIC	DumpFilterEntry
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\common\crypto.c
pdata	SEGMENT
$pdata$DumpFilterEntry DD imagerel $LN31
	DD	imagerel $LN31+500
	DD	imagerel $unwind$DumpFilterEntry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DumpFilterEntry DD 061001H
	DD	0126410H
	DD	0103410H
	DD	0700cd210H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\dumpfilter.c
xdata	ENDS
;	COMDAT DumpFilterEntry
_TEXT	SEGMENT
dumpConfig$ = 48
storageDeviceNumber$ = 64
partitionInfo$ = 80
filterExtension$ = 128
version$ = 136
filterInitData$ = 136
DumpFilterEntry PROC					; COMDAT

; 39   : {

$LN31:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 40   : 	GetSystemDriveDumpConfigRequest dumpConfig;
; 41   : 	PHYSICAL_ADDRESS highestAcceptableWriteBufferAddr;
; 42   : 	STORAGE_DEVICE_NUMBER storageDeviceNumber;
; 43   : 	PARTITION_INFORMATION partitionInfo;
; 44   : 	LONG version;
; 45   : 	NTSTATUS status;
; 46   : 
; 47   : 	Dump ("DumpFilterEntry type=%d\n", filterExtension->DumpType);
; 48   : 
; 49   : 	filterInitData->MajorVersion = DUMP_FILTER_MAJOR_VERSION;
; 50   : 	filterInitData->MinorVersion = DUMP_FILTER_MINOR_VERSION;

  00010	83 62 04 00	 and	 DWORD PTR [rdx+4], 0

; 51   : 	filterInitData->Flags |= DUMP_FILTER_CRITICAL;

  00014	83 4a 34 01	 or	 DWORD PTR [rdx+52], 1

; 52   : 
; 53   : 	// Check driver version of the main device
; 54   : 	status = GSTDeviceIoControl (NT_ROOT_PREFIX, GST_IOCTL_GET_DRIVER_VERSION, NULL, 0, &version, sizeof (version));

  00018	c7 40 b0 04 00
	00 00		 mov	 DWORD PTR [rax-80], 4
  0001f	48 8d 40 10	 lea	 rax, QWORD PTR [rax+16]
  00023	48 8b f1	 mov	 rsi, rcx
  00026	48 8b fa	 mov	 rdi, rdx
  00029	c7 02 01 00 00
	00		 mov	 DWORD PTR [rdx], 1
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  00036	45 33 c9	 xor	 r9d, r9d
  00039	45 33 c0	 xor	 r8d, r8d
  0003c	ba 04 20 22 00	 mov	 edx, 2236420		; 00222004H
  00041	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00046	e8 00 00 00 00	 call	 GSTDeviceIoControl

; 55   : 	if (!NT_SUCCESS (status))

  0004b	85 c0		 test	 eax, eax
  0004d	0f 88 8f 01 00
	00		 js	 $err$28006

; 56   : 		goto err;
; 57   : 
; 58   : 	if (version != VERSION_NUM)

  00053	81 bc 24 88 00
	00 00 00 13 00
	00		 cmp	 DWORD PTR version$[rsp], 4864 ; 00001300H
  0005e	74 0a		 je	 SHORT $LN12@DumpFilter@4
$LN30@DumpFilter@4:

; 59   : 	{
; 60   : 		status = STATUS_INVALID_PARAMETER;

  00060	b8 0d 00 00 c0	 mov	 eax, -1073741811	; ffffffffc000000dH

; 61   : 		goto err;

  00065	e9 78 01 00 00	 jmp	 $err$28006
$LN12@DumpFilter@4:

; 62   : 	}
; 63   : 
; 64   : 	// Get dump configuration from the main device
; 65   : 	status = GSTDeviceIoControl (NT_ROOT_PREFIX, GST_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG, NULL, 0, &dumpConfig, sizeof (dumpConfig));

  0006a	48 8d 44 24 30	 lea	 rax, QWORD PTR dumpConfig$[rsp]
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@LFEKNJLC@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAG?$AAo?$AAs?$AAt?$AAC?$AAr?$AAy?$AAp?$AAt?$AA?$AA@FNODOBFM@
  00076	45 33 c9	 xor	 r9d, r9d
  00079	45 33 c0	 xor	 r8d, r8d
  0007c	ba 98 20 22 00	 mov	 edx, 2236568		; 00222098H
  00081	c7 44 24 28 0c
	00 00 00	 mov	 DWORD PTR [rsp+40], 12
  00089	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008e	e8 00 00 00 00	 call	 GSTDeviceIoControl

; 66   : 	if (!NT_SUCCESS (status))

  00093	85 c0		 test	 eax, eax
  00095	0f 88 47 01 00
	00		 js	 $err$28006

; 67   : 		goto err;
; 68   : 
; 69   : 	BootDriveFilterExtension = dumpConfig.BootDriveFilterExtension;

  0009b	48 8b 44 24 30	 mov	 rax, QWORD PTR dumpConfig$[rsp]

; 70   : 
; 71   : 	if (BootDriveFilterExtension->MagicNumber != GST_BOOT_DRIVE_FILTER_EXTENSION_MAGIC_NUMBER)

  000a0	48 b9 54 58 45
	42 45 55 52 54	 mov	 rcx, 6076012603229165652 ; 5452554542455854H
  000aa	48 89 05 00 00
	00 00		 mov	 QWORD PTR BootDriveFilterExtension, rax
  000b1	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  000b5	74 0a		 je	 SHORT $LN10@DumpFilter@4

; 72   : 	{
; 73   : 		status = STATUS_CRC_ERROR;

  000b7	b8 3f 00 00 c0	 mov	 eax, -1073741761	; ffffffffc000003fH

; 74   : 		goto err;

  000bc	e9 21 01 00 00	 jmp	 $err$28006
$LN10@DumpFilter@4:

; 75   : 	}
; 76   : 
; 77   : 	// KeSaveFloatingPointState() may generate a bug check during crash dump
; 78   : #if !defined (_WIN64)
; 79   : 	if (filterExtension->DumpType == DumpTypeCrashdump)
; 80   : 		dumpConfig.HwEncryptionEnabled = FALSE;
; 81   : #endif
; 82   : 
; 83   : 	EnableHwEncryption (dumpConfig.HwEncryptionEnabled);
; 84   : 
; 85   : 	if (!AutoTestAlgorithms())

  000c1	e8 00 00 00 00	 call	 DoAutoTestAlgorithms
  000c6	f7 d8		 neg	 eax
  000c8	1b db		 sbb	 ebx, ebx
  000ca	83 e3 01	 and	 ebx, 1
  000cd	e8 00 00 00 00	 call	 DoAutoTestAlgorithms
  000d2	f7 d8		 neg	 eax
  000d4	1b c9		 sbb	 ecx, ecx
  000d6	23 cb		 and	 ecx, ebx

; 86   : 	{
; 87   : 		status = STATUS_INVALID_PARAMETER;
; 88   : 		goto err;

  000d8	74 86		 je	 SHORT $LN30@DumpFilter@4

; 89   : 	}
; 90   : 
; 91   : 	// Check dump volume is located on the system drive
; 92   : 	status = SendDeviceIoControlRequest (filterExtension->DeviceObject, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0, &storageDeviceNumber, sizeof (storageDeviceNumber));

  000da	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  000de	48 8d 44 24 40	 lea	 rax, QWORD PTR storageDeviceNumber$[rsp]
  000e3	45 33 c9	 xor	 r9d, r9d
  000e6	45 33 c0	 xor	 r8d, r8d
  000e9	ba 80 10 2d 00	 mov	 edx, 2953344		; 002d1080H
  000ee	c7 44 24 28 0c
	00 00 00	 mov	 DWORD PTR [rsp+40], 12
  000f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fb	e8 00 00 00 00	 call	 SendDeviceIoControlRequest

; 93   : 	if (!NT_SUCCESS (status))

  00100	85 c0		 test	 eax, eax
  00102	0f 88 da 00 00
	00		 js	 $err$28006

; 94   : 		goto err;
; 95   : 
; 96   : 	if (!BootDriveFilterExtension->SystemStorageDeviceNumberValid)

  00108	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0010f	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0

; 97   : 	{
; 98   : 		status = STATUS_INVALID_PARAMETER;
; 99   : 		goto err;

  00113	0f 84 47 ff ff
	ff		 je	 $LN30@DumpFilter@4

; 100  : 	}
; 101  : 
; 102  : 	if (storageDeviceNumber.DeviceNumber != BootDriveFilterExtension->SystemStorageDeviceNumber)

  00119	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0011c	39 44 24 44	 cmp	 DWORD PTR storageDeviceNumber$[rsp+4], eax

; 103  : 	{
; 104  : 		status = STATUS_ACCESS_DENIED;
; 105  : 		goto err;

  00120	0f 85 b7 00 00
	00		 jne	 $LN3@DumpFilter@4

; 106  : 	}
; 107  : 
; 108  : 	// Check dump volume is located within the scope of system encryption
; 109  : 	status = SendDeviceIoControlRequest (filterExtension->DeviceObject, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &partitionInfo, sizeof (partitionInfo));

  00126	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  0012a	48 8d 44 24 50	 lea	 rax, QWORD PTR partitionInfo$[rsp]
  0012f	45 33 c9	 xor	 r9d, r9d
  00132	45 33 c0	 xor	 r8d, r8d
  00135	ba 04 40 07 00	 mov	 edx, 475140		; 00074004H
  0013a	c7 44 24 28 20
	00 00 00	 mov	 DWORD PTR [rsp+40], 32	; 00000020H
  00142	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00147	e8 00 00 00 00	 call	 SendDeviceIoControlRequest

; 110  : 	if (!NT_SUCCESS (status))

  0014c	85 c0		 test	 eax, eax
  0014e	0f 88 8e 00 00
	00		 js	 $err$28006

; 111  : 		goto err;
; 112  : 
; 113  : 	DumpPartitionOffset = partitionInfo.StartingOffset;

  00154	48 8b 44 24 50	 mov	 rax, QWORD PTR partitionInfo$[rsp]

; 114  : 
; 115  : 	if (DumpPartitionOffset.QuadPart < BootDriveFilterExtension->ConfiguredEncryptedAreaStart
; 116  : 		|| DumpPartitionOffset.QuadPart > BootDriveFilterExtension->ConfiguredEncryptedAreaEnd)

  00159	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR BootDriveFilterExtension
  00160	48 3b 41 38	 cmp	 rax, QWORD PTR [rcx+56]
  00164	48 89 05 00 00
	00 00		 mov	 QWORD PTR DumpPartitionOffset, rax
  0016b	7c 70		 jl	 SHORT $LN3@DumpFilter@4
  0016d	48 3b 41 40	 cmp	 rax, QWORD PTR [rcx+64]
  00171	7f 6a		 jg	 SHORT $LN3@DumpFilter@4

; 119  : 		goto err;
; 120  : 	}
; 121  : 
; 122  : 	// Allocate buffer for encryption
; 123  : 	if (filterInitData->MaxPagesPerWrite == 0)

  00173	8b 47 30	 mov	 eax, DWORD PTR [rdi+48]
  00176	85 c0		 test	 eax, eax

; 124  : 	{
; 125  : 		status = STATUS_INVALID_PARAMETER;
; 126  : 		goto err;

  00178	0f 84 e2 fe ff
	ff		 je	 $LN30@DumpFilter@4

; 127  : 	}
; 128  : 
; 129  : 	WriteFilterBufferSize = filterInitData->MaxPagesPerWrite * PAGE_SIZE;

  0017e	c1 e0 0c	 shl	 eax, 12

; 130  : 
; 131  : #ifdef _WIN64
; 132  : 	highestAcceptableWriteBufferAddr.QuadPart = 0x7FFffffFFFFLL;

  00181	48 ba ff ff ff
	ff ff 07 00 00	 mov	 rdx, 8796093022207	; 000007ffffffffffH
  0018b	8b c8		 mov	 ecx, eax
  0018d	48 89 0d 00 00
	00 00		 mov	 QWORD PTR WriteFilterBufferSize, rcx

; 133  : #else
; 134  : 	highestAcceptableWriteBufferAddr.QuadPart = 0xffffFFFFLL;
; 135  : #endif
; 136  : 
; 137  : 	WriteFilterBuffer = MmAllocateContiguousMemory (WriteFilterBufferSize, highestAcceptableWriteBufferAddr);

  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmAllocateContiguousMemory
  0019a	48 89 05 00 00
	00 00		 mov	 QWORD PTR WriteFilterBuffer, rax

; 138  : 	if (!WriteFilterBuffer)

  001a1	48 85 c0	 test	 rax, rax
  001a4	75 07		 jne	 SHORT $LN1@DumpFilter@4

; 139  : 	{
; 140  : 		status = STATUS_INSUFFICIENT_RESOURCES;

  001a6	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH

; 141  : 		goto err;

  001ab	eb 35		 jmp	 SHORT $err$28006
$LN1@DumpFilter@4:

; 142  : 	}
; 143  : 
; 144  : 	filterInitData->DumpStart = DumpFilterStart;

  001ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DumpFilterStart
  001b4	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax

; 145  : 	filterInitData->DumpWrite = DumpFilterWrite;

  001b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DumpFilterWrite
  001bf	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 146  : 	filterInitData->DumpFinish = DumpFilterFinish;

  001c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DumpFilterFinish
  001ca	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax

; 147  : 	filterInitData->DumpUnload = DumpFilterUnload;

  001ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DumpFilterUnload
  001d5	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 148  : 
; 149  : 	Dump ("Dump filter loaded type=%d\n", filterExtension->DumpType);
; 150  : 	return STATUS_SUCCESS;

  001d9	33 c0		 xor	 eax, eax
  001db	eb 05		 jmp	 SHORT $err$28006
$LN3@DumpFilter@4:

; 117  : 	{
; 118  : 		status = STATUS_ACCESS_DENIED;

  001dd	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
$err$28006:

; 151  : 
; 152  : err:
; 153  : 	Dump ("DumpFilterEntry error %x\n", status);
; 154  : 	return status;
; 155  : }

  001e2	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  001e7	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  001eb	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  001ef	49 8b e3	 mov	 rsp, r11
  001f2	5f		 pop	 rdi
  001f3	c3		 ret	 0
DumpFilterEntry ENDP
END
