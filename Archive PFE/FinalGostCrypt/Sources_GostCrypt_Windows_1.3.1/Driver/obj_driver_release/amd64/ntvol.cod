; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	ProbingHostDeviceForWrite
PUBLIC	??_C@_1DM@FMJIKGBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAH?$AAa?$AAr?$AAd?$AAd?$AAi?$AAs?$AAk?$AA?$CF?$AAd?$AA?2?$AAP?$AAa?$AAr?$AAt?$AAi?$AAt?$AAi?$AAo?$AAn?$AA0?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BC@MAMPPFNN@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAU?$AAN?$AAC?$AA?2?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BA@GIIKONIJ@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_wcsncpy:PROC
EXTRN	__imp_wcsstr:PROC
EXTRN	IoFileObjectType:QWORD
EXTRN	__imp__snwprintf:PROC
EXTRN	__imp_ZwQueryInformationFile:PROC
EXTRN	__imp_ZwSetInformationFile:PROC
ProbingHostDeviceForWrite DD 01H DUP (?)
;	COMDAT ??_C@_1BA@GIIKONIJ@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BA@GIIKONIJ@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, '?', 00H, '?', 00H, '\', 00H, '\', 00H, '%', 00H, 's', 00H
	DB	00H, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BC@MAMPPFNN@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAU?$AAN?$AAC?$AA?2?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BC@MAMPPFNN@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAU?$AAN?$AAC?$AA?2?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, '?', 00H, '?', 00H, '\', 00H, 'U', 00H, 'N', 00H, 'C', 00H
	DB	'\', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1DM@FMJIKGBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAH?$AAa?$AAr?$AAd?$AAd?$AAi?$AAs?$AAk?$AA?$CF?$AAd?$AA?2?$AAP?$AAa?$AAr?$AAt?$AAi?$AAt?$AAi?$AAo?$AAn?$AA0?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DM@FMJIKGBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAH?$AAa?$AAr?$AAd?$AAd?$AAi?$AAs?$AAk?$AA?$CF?$AAd?$AA?2?$AAP?$AAa?$AAr?$AAt?$AAi?$AAt?$AAi?$AAo?$AAn?$AA0?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'H', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'd', 00H, 'i'
	DB	00H, 's', 00H, 'k', 00H, '%', 00H, 'd', 00H, '\', 00H, 'P', 00H
	DB	'a', 00H, 'r', 00H, 't', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o'
	DB	00H, 'n', 00H, '0', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntvol.c
pdata	SEGMENT
$pdata$RestoreTimeStamp DD imagerel RestoreTimeStamp
	DD	imagerel RestoreTimeStamp+175
	DD	imagerel $unwind$RestoreTimeStamp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RestoreTimeStamp DD 020601H
	DD	03002d206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT RestoreTimeStamp
_TEXT	SEGMENT
IoStatusBlock$ = 48
FileBasicInfo$ = 64
Extension$ = 128
RestoreTimeStamp PROC					; COMDAT

; 864  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00006	48 8b d9	 mov	 rbx, rcx

; 865  : 	NTSTATUS ntStatus;
; 866  : 	FILE_BASIC_INFORMATION FileBasicInfo;
; 867  : 	IO_STATUS_BLOCK IoStatusBlock;
; 868  : 
; 869  : 	if (Extension->hDeviceFile != NULL 
; 870  : 		&& Extension->bRawDevice == FALSE 
; 871  : 		&& Extension->bReadOnly == FALSE
; 872  : 		&& Extension->bTimeStampValid)

  00009	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	0f 84 93 00 00
	00		 je	 $LN1@RestoreTim
  00016	83 bb 4c 03 00
	00 00		 cmp	 DWORD PTR [rbx+844], 0
  0001d	0f 85 86 00 00
	00		 jne	 $LN1@RestoreTim
  00023	83 bb 40 03 00
	00 00		 cmp	 DWORD PTR [rbx+832], 0
  0002a	75 7d		 jne	 SHORT $LN1@RestoreTim
  0002c	83 bb 80 05 00
	00 00		 cmp	 DWORD PTR [rbx+1408], 0
  00033	74 74		 je	 SHORT $LN1@RestoreTim

; 873  : 	{
; 874  : 		ntStatus = ZwQueryInformationFile (Extension->hDeviceFile,
; 875  : 			&IoStatusBlock,
; 876  : 			&FileBasicInfo,
; 877  : 			sizeof (FileBasicInfo),
; 878  : 			FileBasicInformation); 

  00035	4c 8d 44 24 40	 lea	 r8, QWORD PTR FileBasicInfo$[rsp]
  0003a	48 8d 54 24 30	 lea	 rdx, QWORD PTR IoStatusBlock$[rsp]
  0003f	41 b9 28 00 00
	00		 mov	 r9d, 40			; 00000028H
  00045	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQueryInformationFile

; 879  : 
; 880  : 		if (!NT_SUCCESS (ntStatus))

  00053	85 c0		 test	 eax, eax
  00055	78 52		 js	 SHORT $LN1@RestoreTim

; 881  : 		{
; 882  : 			Dump ("ZwQueryInformationFile failed in RestoreTimeStamp: NTSTATUS 0x%08x\n",
; 883  : 				ntStatus);
; 884  : 		}
; 885  : 		else
; 886  : 		{
; 887  : 			FileBasicInfo.CreationTime = Extension->fileCreationTime;

  00057	48 8b 83 60 05
	00 00		 mov	 rax, QWORD PTR [rbx+1376]

; 888  : 			FileBasicInfo.LastAccessTime = Extension->fileLastAccessTime;
; 889  : 			FileBasicInfo.LastWriteTime = Extension->fileLastWriteTime;
; 890  : 			FileBasicInfo.ChangeTime = Extension->fileLastChangeTime;
; 891  : 
; 892  : 			ntStatus = ZwSetInformationFile(
; 893  : 				Extension->hDeviceFile,
; 894  : 				&IoStatusBlock,
; 895  : 				&FileBasicInfo,
; 896  : 				sizeof (FileBasicInfo),
; 897  : 				FileBasicInformation); 

  0005e	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  00062	4c 8d 44 24 40	 lea	 r8, QWORD PTR FileBasicInfo$[rsp]
  00067	48 89 44 24 40	 mov	 QWORD PTR FileBasicInfo$[rsp], rax
  0006c	48 8b 83 68 05
	00 00		 mov	 rax, QWORD PTR [rbx+1384]
  00073	48 8d 54 24 30	 lea	 rdx, QWORD PTR IoStatusBlock$[rsp]
  00078	48 89 44 24 48	 mov	 QWORD PTR FileBasicInfo$[rsp+8], rax
  0007d	48 8b 83 70 05
	00 00		 mov	 rax, QWORD PTR [rbx+1392]
  00084	41 b9 28 00 00
	00		 mov	 r9d, 40			; 00000028H
  0008a	48 89 44 24 50	 mov	 QWORD PTR FileBasicInfo$[rsp+16], rax
  0008f	48 8b 83 78 05
	00 00		 mov	 rax, QWORD PTR [rbx+1400]
  00096	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0009e	48 89 44 24 58	 mov	 QWORD PTR FileBasicInfo$[rsp+24], rax
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwSetInformationFile
$LN1@RestoreTim:

; 898  : 
; 899  : 			if (!NT_SUCCESS (ntStatus))
; 900  : 				Dump ("ZwSetInformationFile failed in RestoreTimeStamp: NTSTATUS 0x%08x\n",ntStatus);
; 901  : 		}
; 902  : 	}
; 903  : }

  000a9	48 83 c4 70	 add	 rsp, 112		; 00000070H
  000ad	5b		 pop	 rbx
  000ae	c3		 ret	 0
RestoreTimeStamp ENDP
_TEXT	ENDS
PUBLIC	COMPLETE_IRP
;	COMDAT pdata
pdata	SEGMENT
$pdata$COMPLETE_IRP DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$COMPLETE_IRP
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$COMPLETE_IRP DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT COMPLETE_IRP
_TEXT	SEGMENT
DeviceObject$ = 48
Irp$ = 56
IrpStatus$ = 64
IrpInformation$ = 72
COMPLETE_IRP PROC					; COMDAT

; 830  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 831  : 	Irp->IoStatus.Status = IrpStatus;

  00004	83 62 30 00	 and	 DWORD PTR [rdx+48], 0

; 832  : 	Irp->IoStatus.Information = IrpInformation;

  00008	48 83 62 38 00	 and	 QWORD PTR [rdx+56], 0

; 833  : 
; 834  : 	if (DeviceObject);	/* Remove compiler warning */
; 835  : 
; 836  : #if EXTRA_INFO
; 837  : 	if (!NT_SUCCESS (IrpStatus))
; 838  : 	{
; 839  : 		PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);
; 840  : 		Dump ("COMPLETE_IRP FAILING IRP %ls Flags 0x%08x vpb 0x%08x NTSTATUS 0x%08x\n", GSTTranslateCode (irpSp->MajorFunction),
; 841  : 		      (ULONG) DeviceObject->Flags, (ULONG) DeviceObject->Vpb->Flags, IrpStatus);
; 842  : 	}
; 843  : 	else
; 844  : 	{
; 845  : 		PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);
; 846  : 		Dump ("COMPLETE_IRP SUCCESS IRP %ls Flags 0x%08x vpb 0x%08x NTSTATUS 0x%08x\n", GSTTranslateCode (irpSp->MajorFunction),
; 847  : 		      (ULONG) DeviceObject->Flags, (ULONG) DeviceObject->Vpb->Flags, IrpStatus);
; 848  : 	}
; 849  : #endif
; 850  : 	IoCompleteRequest (Irp, IO_NO_INCREMENT);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	33 d2		 xor	 edx, edx
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 851  : 	return IrpStatus;

  00018	33 c0		 xor	 eax, eax

; 852  : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
COMPLETE_IRP ENDP
;	COMDAT pdata
; File c:\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$GSTSendHostDeviceIoControlRequest DD imagerel GSTSendHostDeviceIoControlRequest
	DD	imagerel GSTSendHostDeviceIoControlRequest+207
	DD	imagerel $unwind$GSTSendHostDeviceIoControlRequest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTSendHostDeviceIoControlRequest DD 081401H
	DD	0106414H
	DD	0f5414H
	DD	0e3414H
	DD	07010b214H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntvol.c
xdata	ENDS
;	COMDAT GSTSendHostDeviceIoControlRequest
_TEXT	SEGMENT
IoStatusBlock$ = 80
DeviceObject$ = 112
Extension$ = 120
IoControlCode$ = 128
OutputBuffer$ = 136
OutputBufferSize$ = 144
GSTSendHostDeviceIoControlRequest PROC			; COMDAT

; 790  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 791  : 	IO_STATUS_BLOCK IoStatusBlock;
; 792  : 	NTSTATUS ntStatus;
; 793  : 	PIRP Irp;
; 794  : 
; 795  : 	if (DeviceObject);	/* Remove compiler warning */
; 796  : 
; 797  : 	KeClearEvent (&Extension->keVolumeEvent);

  00014	48 8d aa c8 00
	00 00		 lea	 rbp, QWORD PTR [rdx+200]
  0001b	49 8b d9	 mov	 rbx, r9
  0001e	41 8b f8	 mov	 edi, r8d
  00021	48 8b cd	 mov	 rcx, rbp
  00024	48 8b f2	 mov	 rsi, rdx
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeClearEvent

; 798  : 
; 799  : 	Irp = IoBuildDeviceIoControlRequest (IoControlCode,
; 800  : 					     Extension->pFsdDevice,
; 801  : 					     NULL, 0,
; 802  : 					     OutputBuffer, OutputBufferSize,
; 803  : 					     FALSE,
; 804  : 					     &Extension->keVolumeEvent,
; 805  : 					     &IoStatusBlock);

  0002d	48 8b 96 88 00
	00 00		 mov	 rdx, QWORD PTR [rsi+136]
  00034	48 8d 44 24 50	 lea	 rax, QWORD PTR IoStatusBlock$[rsp]
  00039	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0003e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR OutputBufferSize$[rsp]
  00045	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  0004a	c6 44 24 30 00	 mov	 BYTE PTR [rsp+48], 0
  0004f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00053	45 33 c9	 xor	 r9d, r9d
  00056	45 33 c0	 xor	 r8d, r8d
  00059	8b cf		 mov	 ecx, edi
  0005b	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoBuildDeviceIoControlRequest
  00066	4c 8b d8	 mov	 r11, rax

; 806  : 
; 807  : 	if (Irp == NULL)

  00069	48 85 c0	 test	 rax, rax
  0006c	75 07		 jne	 SHORT $LN2@GSTSendHos

; 808  : 	{
; 809  : 		Dump ("IRP allocation failed\n");
; 810  : 		return STATUS_INSUFFICIENT_RESOURCES;

  0006e	b8 9a 00 00 c0	 mov	 eax, -1073741670	; ffffffffc000009aH
  00073	eb 44		 jmp	 SHORT $LN1@GSTSendHos
$LN2@GSTSendHos:

; 811  : 	}
; 812  : 
; 813  : 	// Disk device may be used by filesystem driver which needs file object
; 814  : 	IoGetNextIrpStackLocation (Irp) -> FileObject = Extension->pfoDeviceFile;

  00075	48 8b 90 b8 00
	00 00		 mov	 rdx, QWORD PTR [rax+184]
  0007c	48 8b 86 80 00
	00 00		 mov	 rax, QWORD PTR [rsi+128]
  00083	48 89 42 e8	 mov	 QWORD PTR [rdx-24], rax

; 815  : 
; 816  : 	ntStatus = IoCallDriver (Extension->pFsdDevice, Irp);

  00087	48 8b 8e 88 00
	00 00		 mov	 rcx, QWORD PTR [rsi+136]
  0008e	49 8b d3	 mov	 rdx, r11
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCallDriver

; 817  : 	if (ntStatus == STATUS_PENDING)

  00097	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  0009c	75 1b		 jne	 SHORT $LN1@GSTSendHos

; 818  : 	{
; 819  : 		KeWaitForSingleObject (&Extension->keVolumeEvent, Executive, KernelMode, FALSE, NULL);

  0009e	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000a4	45 33 c9	 xor	 r9d, r9d
  000a7	45 33 c0	 xor	 r8d, r8d
  000aa	33 d2		 xor	 edx, edx
  000ac	48 8b cd	 mov	 rcx, rbp
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeWaitForSingleObject

; 820  : 		ntStatus = IoStatusBlock.Status;

  000b5	8b 44 24 50	 mov	 eax, DWORD PTR IoStatusBlock$[rsp]
$LN1@GSTSendHos:

; 821  : 	}
; 822  : 
; 823  : 	return ntStatus;
; 824  : }

  000b9	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  000be	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000c2	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  000c6	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  000ca	49 8b e3	 mov	 rsp, r11
  000cd	5f		 pop	 rdi
  000ce	c3		 ret	 0
GSTSendHostDeviceIoControlRequest ENDP
_TEXT	ENDS
PUBLIC	GSTCloseVolume
;	COMDAT pdata
pdata	SEGMENT
$pdata$GSTCloseVolume DD imagerel $LN6
	DD	imagerel $LN6+81
	DD	imagerel $unwind$GSTCloseVolume
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTCloseVolume DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT GSTCloseVolume
_TEXT	SEGMENT
DeviceObject$ = 48
Extension$ = 56
GSTCloseVolume PROC					; COMDAT

; 768  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 769  : 	if (DeviceObject);	/* Remove compiler warning */
; 770  : 
; 771  : 	if (Extension->hDeviceFile != NULL)

  00006	33 c0		 xor	 eax, eax
  00008	48 8b da	 mov	 rbx, rdx
  0000b	48 39 42 78	 cmp	 QWORD PTR [rdx+120], rax
  0000f	74 22		 je	 SHORT $LN2@GSTCloseVo

; 772  : 	{
; 773  : 		if (Extension->bRawDevice == FALSE
; 774  : 			&& Extension->bTimeStampValid)

  00011	39 82 4c 03 00
	00		 cmp	 DWORD PTR [rdx+844], eax
  00017	75 10		 jne	 SHORT $LN1@GSTCloseVo
  00019	39 82 80 05 00
	00		 cmp	 DWORD PTR [rdx+1408], eax
  0001f	74 08		 je	 SHORT $LN1@GSTCloseVo

; 775  : 		{
; 776  : 			RestoreTimeStamp (Extension);

  00021	48 8b ca	 mov	 rcx, rdx
  00024	e8 00 00 00 00	 call	 RestoreTimeStamp
$LN1@GSTCloseVo:

; 777  : 		}
; 778  : 		ZwClose (Extension->hDeviceFile);

  00029	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN2@GSTCloseVo:

; 779  : 	}
; 780  : 	ObDereferenceObject (Extension->pfoDeviceFile);

  00033	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject

; 781  : 	crypto_close (Extension->cryptoInfo);

  00040	48 8b 8b 90 00
	00 00		 mov	 rcx, QWORD PTR [rbx+144]

; 782  : }

  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5b		 pop	 rbx
  0004c	e9 00 00 00 00	 jmp	 crypto_close
GSTCloseVolume ENDP
PUBLIC	__$ArrayPad$
PUBLIC	GSTOpenVolume
;	COMDAT pdata
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\drivefilter.c
pdata	SEGMENT
$pdata$GSTOpenVolume DD imagerel $LN169
	DD	imagerel $LN169+3725
	DD	imagerel $unwind$GSTOpenVolume
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GSTOpenVolume DD 0a2619H
	DD	0570114H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	02a0H
; Function compile flags: /Ogspy
; File c:\users\alexis\desktop\sources_gostcrypt_windows_1.3.1_commented\sources_gostcrypt_windows_1.3.1é\sources_gostcrypt_windows_1.3.1\driver\ntvol.c
xdata	ENDS
;	COMDAT GSTOpenVolume
_TEXT	SEGMENT
partitionStartingOffset$1$ = 96
hParentDeviceFile$29835 = 104
IoStatusBlock$ = 112
headerOffset$29817 = 128
pfoTmpDeviceFile$29796 = 136
parentKeyDataOffset$29839 = 144
lDiskLength$ = 144
tmpCryptoInfo$ = 152
readBuffer$1$ = 160
pwszMountVolume$GSCopy$1$ = 168
diskLengthInfo$29744 = 176
dg$29745 = 184
FullFileName$ = 208
oaFileAttributes$ = 224
FileBasicInfo$ = 272
oaParentFileAttributes$29838 = 312
FullParentPath$29837 = 360
pi$29742 = 376
FileStandardInfo$ = 408
pix$29743 = 432
parentDrivePath$29834 = 576
__$ArrayPad$ = 672
DeviceObject$ = 768
Extension$ = 776
mount$ = 784
pwszMountVolume$ = 792
bRawDevice$ = 800
GSTOpenVolume PROC					; COMDAT

; 50   : {

$LN169:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 81 ec b8 02
	00 00		 sub	 rsp, 696		; 000002b8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00026	4c 8b e1	 mov	 r12, rcx

; 51   : 	FILE_STANDARD_INFORMATION FileStandardInfo;
; 52   : 	FILE_BASIC_INFORMATION FileBasicInfo;
; 53   : 	OBJECT_ATTRIBUTES oaFileAttributes;
; 54   : 	UNICODE_STRING FullFileName;
; 55   : 	IO_STATUS_BLOCK IoStatusBlock;
; 56   : 	PCRYPTO_INFO cryptoInfoPtr = NULL;
; 57   : 	PCRYPTO_INFO tmpCryptoInfo = NULL;

  00029	33 c9		 xor	 ecx, ecx
  0002b	4c 89 8c 24 a8
	00 00 00	 mov	 QWORD PTR pwszMountVolume$GSCopy$1$[rsp], r9
  00033	49 8b e8	 mov	 rbp, r8
  00036	48 8b f2	 mov	 rsi, rdx

; 58   : 	LARGE_INTEGER lDiskLength;
; 59   : 	__int64 partitionStartingOffset = 0;
; 60   : 	int volumeType;
; 61   : 	char *readBuffer = 0;
; 62   : 	NTSTATUS ntStatus = 0;
; 63   : 	BOOL forceAccessCheck = (!bRawDevice && !(OsMajorVersion == 5 &&OsMinorVersion == 0)); // Windows 2000 does not support OBJ_FORCE_ACCESS_CHECK attribute

  00039	8d 41 01	 lea	 eax, QWORD PTR [rcx+1]
  0003c	4c 8b f9	 mov	 r15, rcx
  0003f	48 89 8c 24 98
	00 00 00	 mov	 QWORD PTR tmpCryptoInfo$[rsp], rcx
  00047	48 89 4c 24 60	 mov	 QWORD PTR partitionStartingOffset$1$[rsp], rcx
  0004c	48 89 8c 24 a0
	00 00 00	 mov	 QWORD PTR readBuffer$1$[rsp], rcx
  00054	8b f9		 mov	 edi, ecx
  00056	39 8c 24 20 03
	00 00		 cmp	 DWORD PTR bRawDevice$[rsp], ecx
  0005d	75 15		 jne	 SHORT $LN111@GSTOpenVol
  0005f	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR OsMajorVersion, 5
  00066	75 08		 jne	 SHORT $LN110@GSTOpenVol
  00068	39 0d 00 00 00
	00		 cmp	 DWORD PTR OsMinorVersion, ecx
  0006e	74 04		 je	 SHORT $LN111@GSTOpenVol
$LN110@GSTOpenVol:
  00070	8b d8		 mov	 ebx, eax
  00072	eb 02		 jmp	 SHORT $LN112@GSTOpenVol
$LN111@GSTOpenVol:
  00074	8b d9		 mov	 ebx, ecx
$LN112@GSTOpenVol:

; 64   : 	BOOL disableBuffering = TRUE;
; 65   : 	BOOL exclusiveAccess = mount->bExclusiveAccess;

  00076	45 8b a8 74 02
	00 00		 mov	 r13d, DWORD PTR [r8+628]

; 66   : 
; 67   : 	Extension->pfoDeviceFile = NULL;

  0007d	48 89 8a 80 00
	00 00		 mov	 QWORD PTR [rdx+128], rcx

; 68   : 	Extension->hDeviceFile = NULL;

  00084	48 89 4a 78	 mov	 QWORD PTR [rdx+120], rcx

; 69   : 	Extension->bTimeStampValid = FALSE;

  00088	89 8a 80 05 00
	00		 mov	 DWORD PTR [rdx+1408], ecx

; 70   : 
; 71   : 	RtlInitUnicodeString (&FullFileName, pwszMountVolume);

  0008e	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR FullFileName$[rsp]
  00096	49 8b d1	 mov	 rdx, r9
  00099	44 8b f0	 mov	 r14d, eax
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 72   : 	InitializeObjectAttributes (&oaFileAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | (forceAccessCheck ? OBJ_FORCE_ACCESS_CHECK : 0) | OBJ_KERNEL_HANDLE, NULL, NULL);

  000a2	33 c9		 xor	 ecx, ecx
  000a4	48 89 8c 24 e8
	00 00 00	 mov	 QWORD PTR oaFileAttributes$[rsp+8], rcx
  000ac	48 89 8c 24 00
	01 00 00	 mov	 QWORD PTR oaFileAttributes$[rsp+32], rcx
  000b4	48 89 8c 24 08
	01 00 00	 mov	 QWORD PTR oaFileAttributes$[rsp+40], rcx
  000bc	f7 db		 neg	 ebx

; 73   : 	KeInitializeEvent (&Extension->keVolumeEvent, NotificationEvent, FALSE);

  000be	48 8d 8e c8 00
	00 00		 lea	 rcx, QWORD PTR [rsi+200]
  000c5	c7 84 24 e0 00
	00 00 30 00 00
	00		 mov	 DWORD PTR oaFileAttributes$[rsp], 48 ; 00000030H
  000d0	1b c0		 sbb	 eax, eax
  000d2	45 33 c0	 xor	 r8d, r8d
  000d5	33 d2		 xor	 edx, edx
  000d7	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  000dc	0d 40 02 00 00	 or	 eax, 576		; 00000240H
  000e1	89 84 24 f8 00
	00 00		 mov	 DWORD PTR oaFileAttributes$[rsp+24], eax
  000e8	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR FullFileName$[rsp]
  000f0	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR oaFileAttributes$[rsp+16], rax
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeInitializeEvent

; 74   : 
; 75   : 	if (Extension->SecurityClientContextValid)

  000fe	33 db		 xor	 ebx, ebx
  00100	39 9e 90 05 00
	00		 cmp	 DWORD PTR [rsi+1424], ebx
  00106	74 19		 je	 SHORT $LN106@GSTOpenVol

; 76   : 	{
; 77   : 		ntStatus = SeImpersonateClientEx (&Extension->SecurityClientContext, NULL);

  00108	48 8d 8e 98 05
	00 00		 lea	 rcx, QWORD PTR [rsi+1432]
  0010f	33 d2		 xor	 edx, edx
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SeImpersonateClientEx

; 78   : 		if (!NT_SUCCESS (ntStatus))

  00117	3b c3		 cmp	 eax, ebx
  00119	8b f8		 mov	 edi, eax
  0011b	0f 8c bf 0c 00
	00		 jl	 $error$29740
$LN106@GSTOpenVol:

; 79   : 			goto error;
; 80   : 	}
; 81   : 
; 82   : 	mount->VolumeMountedReadOnlyAfterDeviceWriteProtected = FALSE;

  00121	89 5d 0c	 mov	 DWORD PTR [rbp+12], ebx

; 83   : 
; 84   : 	// If we are opening a device, query its size first
; 85   : 	if (bRawDevice)

  00124	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00129	39 9c 24 20 03
	00 00		 cmp	 DWORD PTR bRawDevice$[rsp], ebx
  00130	0f 84 a3 01 00
	00		 je	 $LN105@GSTOpenVol

; 86   : 	{
; 87   : 		PARTITION_INFORMATION pi;
; 88   : 		PARTITION_INFORMATION_EX pix;
; 89   : 		LARGE_INTEGER diskLengthInfo;
; 90   : 		DISK_GEOMETRY dg;
; 91   : 
; 92   : 		ntStatus = IoGetDeviceObjectPointer (&FullFileName,
; 93   : 			FILE_READ_DATA | FILE_READ_ATTRIBUTES,
; 94   : 			&Extension->pfoDeviceFile,
; 95   : 			&Extension->pFsdDevice);

  00136	4c 8d 8e 88 00
	00 00		 lea	 r9, QWORD PTR [rsi+136]
  0013d	4c 8d 86 80 00
	00 00		 lea	 r8, QWORD PTR [rsi+128]
  00144	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR FullFileName$[rsp]
  0014c	ba 81 00 00 00	 mov	 edx, 129		; 00000081H
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetDeviceObjectPointer

; 96   : 
; 97   : 		if (!NT_SUCCESS (ntStatus))

  00157	3b c3		 cmp	 eax, ebx
  00159	8b f8		 mov	 edi, eax
  0015b	0f 8c 7f 0c 00
	00		 jl	 $error$29740

; 98   : 			goto error;
; 99   : 
; 100  : 		ntStatus = GSTSendHostDeviceIoControlRequest (DeviceObject, Extension, IOCTL_DISK_GET_DRIVE_GEOMETRY, (char *) &dg, sizeof (dg));

  00161	4c 8d 8c 24 b8
	00 00 00	 lea	 r9, QWORD PTR dg$29745[rsp]
  00169	41 b8 00 00 07
	00		 mov	 r8d, 458752		; 00070000H
  0016f	48 8b d6	 mov	 rdx, rsi
  00172	49 8b cc	 mov	 rcx, r12
  00175	c7 44 24 20 18
	00 00 00	 mov	 DWORD PTR [rsp+32], 24
  0017d	e8 00 00 00 00	 call	 GSTSendHostDeviceIoControlRequest

; 101  : 		if (!NT_SUCCESS (ntStatus))

  00182	3b c3		 cmp	 eax, ebx
  00184	8b f8		 mov	 edi, eax
  00186	0f 8c 54 0c 00
	00		 jl	 $error$29740

; 102  : 			goto error;
; 103  : 
; 104  : 		lDiskLength.QuadPart = dg.Cylinders.QuadPart * dg.SectorsPerTrack * dg.TracksPerCylinder * dg.BytesPerSector;

  0018c	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR dg$29745[rsp+20]
  00193	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR dg$29745[rsp+12]

; 105  : 		Extension->HostBytesPerSector = dg.BytesPerSector;
; 106  : 
; 107  : 		// Drive geometry is used only when IOCTL_DISK_GET_PARTITION_INFO fails
; 108  : 		if (NT_SUCCESS (GSTSendHostDeviceIoControlRequest (DeviceObject, Extension, IOCTL_DISK_GET_PARTITION_INFO_EX, (char *) &pix, sizeof (pix))))

  0019a	4c 8d 8c 24 b0
	01 00 00	 lea	 r9, QWORD PTR pix$29743[rsp]
  001a2	48 8b d9	 mov	 rbx, rcx
  001a5	89 8e c0 00 00
	00		 mov	 DWORD PTR [rsi+192], ecx
  001ab	41 b8 48 00 07
	00		 mov	 r8d, 458824		; 00070048H
  001b1	48 8b d6	 mov	 rdx, rsi
  001b4	49 8b cc	 mov	 rcx, r12
  001b7	c7 44 24 20 90
	00 00 00	 mov	 DWORD PTR [rsp+32], 144	; 00000090H
  001bf	48 0f af d8	 imul	 rbx, rax
  001c3	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR dg$29745[rsp+16]
  001ca	48 0f af d8	 imul	 rbx, rax
  001ce	48 0f af 9c 24
	b8 00 00 00	 imul	 rbx, QWORD PTR dg$29745[rsp]
  001d7	e8 00 00 00 00	 call	 GSTSendHostDeviceIoControlRequest
  001dc	33 c9		 xor	 ecx, ecx
  001de	3b c1		 cmp	 eax, ecx
  001e0	7c 12		 jl	 SHORT $LN102@GSTOpenVol

; 109  : 		{
; 110  : 			lDiskLength.QuadPart = pix.PartitionLength.QuadPart;

  001e2	48 8b 9c 24 c0
	01 00 00	 mov	 rbx, QWORD PTR pix$29743[rsp+16]

; 111  : 			partitionStartingOffset = pix.StartingOffset.QuadPart;

  001ea	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR pix$29743[rsp+8]
  001f2	eb 37		 jmp	 SHORT $LN164@GSTOpenVol
$LN102@GSTOpenVol:

; 112  : 		}
; 113  : 		// Windows 2000 does not support IOCTL_DISK_GET_PARTITION_INFO_EX
; 114  : 		else if (NT_SUCCESS (GSTSendHostDeviceIoControlRequest (DeviceObject, Extension, IOCTL_DISK_GET_PARTITION_INFO, (char *) &pi, sizeof (pi))))

  001f4	4c 8d 8c 24 78
	01 00 00	 lea	 r9, QWORD PTR pi$29742[rsp]
  001fc	41 b8 04 40 07
	00		 mov	 r8d, 475140		; 00074004H
  00202	48 8b d6	 mov	 rdx, rsi
  00205	49 8b cc	 mov	 rcx, r12
  00208	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR [rsp+32], 32	; 00000020H
  00210	e8 00 00 00 00	 call	 GSTSendHostDeviceIoControlRequest
  00215	33 c9		 xor	 ecx, ecx
  00217	3b c1		 cmp	 eax, ecx
  00219	7c 17		 jl	 SHORT $LN100@GSTOpenVol

; 115  : 		{
; 116  : 			lDiskLength.QuadPart = pi.PartitionLength.QuadPart;

  0021b	48 8b 9c 24 80
	01 00 00	 mov	 rbx, QWORD PTR pi$29742[rsp+8]

; 117  : 			partitionStartingOffset = pi.StartingOffset.QuadPart;

  00223	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR pi$29742[rsp]
$LN164@GSTOpenVol:
  0022b	48 89 44 24 60	 mov	 QWORD PTR partitionStartingOffset$1$[rsp], rax
  00230	eb 2e		 jmp	 SHORT $LN98@GSTOpenVol
$LN100@GSTOpenVol:

; 118  : 		}
; 119  : 		else if (NT_SUCCESS (GSTSendHostDeviceIoControlRequest (DeviceObject, Extension, IOCTL_DISK_GET_LENGTH_INFO, &diskLengthInfo, sizeof (diskLengthInfo))))

  00232	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR diskLengthInfo$29744[rsp]
  0023a	41 b8 5c 40 07
	00		 mov	 r8d, 475228		; 0007405cH
  00240	48 8b d6	 mov	 rdx, rsi
  00243	49 8b cc	 mov	 rcx, r12
  00246	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  0024e	e8 00 00 00 00	 call	 GSTSendHostDeviceIoControlRequest
  00253	33 c9		 xor	 ecx, ecx
  00255	3b c1		 cmp	 eax, ecx
  00257	48 0f 4d 9c 24
	b0 00 00 00	 cmovge	 rbx, QWORD PTR diskLengthInfo$29744[rsp]
$LN98@GSTOpenVol:

; 120  : 		{
; 121  : 			lDiskLength = diskLengthInfo;
; 122  : 		}
; 123  : 
; 124  : 		ProbingHostDeviceForWrite = TRUE;
; 125  : 
; 126  : 		if (!mount->bMountReadOnly
; 127  : 			&& GSTSendHostDeviceIoControlRequest (DeviceObject, Extension,
; 128  : 				IsHiddenSystemRunning() ? GST_IOCTL_DISK_IS_WRITABLE : IOCTL_DISK_IS_WRITABLE, NULL, 0) == STATUS_MEDIA_WRITE_PROTECTED)

  00260	33 c0		 xor	 eax, eax
  00262	45 8b ee	 mov	 r13d, r14d
  00265	44 89 35 00 00
	00 00		 mov	 DWORD PTR ProbingHostDeviceForWrite, r14d
  0026c	39 85 6c 02 00
	00		 cmp	 DWORD PTR [rbp+620], eax
  00272	75 5a		 jne	 SHORT $LN97@GSTOpenVol
  00274	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BootDriveFilterExtension
  0027b	33 c9		 xor	 ecx, ecx
  0027d	48 3b c1	 cmp	 rax, rcx
  00280	74 0b		 je	 SHORT $LN127@GSTOpenVol
  00282	39 88 e0 02 00
	00		 cmp	 DWORD PTR [rax+736], ecx
  00288	41 8b c6	 mov	 eax, r14d
  0028b	75 02		 jne	 SHORT $LN128@GSTOpenVol
$LN127@GSTOpenVol:
  0028d	8b c1		 mov	 eax, ecx
$LN128@GSTOpenVol:
  0028f	f7 d8		 neg	 eax
  00291	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00295	48 8b d6	 mov	 rdx, rsi
  00298	45 1b c0	 sbb	 r8d, r8d
  0029b	45 33 c9	 xor	 r9d, r9d
  0029e	49 8b cc	 mov	 rcx, r12
  002a1	41 81 e0 50 20
	1b 00		 and	 r8d, 1777744		; 001b2050H
  002a8	41 81 c0 24 00
	07 00		 add	 r8d, 458788		; 00070024H
  002af	e8 00 00 00 00	 call	 GSTSendHostDeviceIoControlRequest
  002b4	3d a2 00 00 c0	 cmp	 eax, -1073741662	; ffffffffc00000a2H
  002b9	75 11		 jne	 SHORT $LN159@GSTOpenVol

; 129  : 		{
; 130  : 			mount->bMountReadOnly = TRUE;

  002bb	44 89 ad 6c 02
	00 00		 mov	 DWORD PTR [rbp+620], r13d

; 131  : 			DeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;

  002c2	41 83 4c 24 34
	02		 or	 DWORD PTR [r12+52], 2

; 132  : 			mount->VolumeMountedReadOnlyAfterDeviceWriteProtected = TRUE;

  002c8	44 89 6d 0c	 mov	 DWORD PTR [rbp+12], r13d
$LN159@GSTOpenVol:

; 669  : 				if (wcsstr (pwszMountVolume, WIDE ("\\??\\UNC\\")) == pwszMountVolume)

  002cc	33 c0		 xor	 eax, eax
$LN97@GSTOpenVol:

; 133  : 		}
; 134  : 
; 135  : 		ProbingHostDeviceForWrite = FALSE;

  002ce	89 05 00 00 00
	00		 mov	 DWORD PTR ProbingHostDeviceForWrite, eax

; 136  : 
; 137  : 		// Some Windows tools (e.g. diskmgmt, diskpart, vssadmin) fail or experience timeouts when there is a raw device
; 138  : 		// open for exclusive access. Therefore, exclusive access is used only for file-hosted volumes.
; 139  : 		// Applications requiring a consistent device image need to acquire exclusive write access first. This is prevented
; 140  : 		// when a device-hosted volume is mounted.
; 141  : 
; 142  : 		exclusiveAccess = FALSE;

  002d4	44 8b e8	 mov	 r13d, eax

; 143  : 	}
; 144  : 	else

  002d7	eb 2e		 jmp	 SHORT $LN94@GSTOpenVol
$LN105@GSTOpenVol:

; 145  : 	{
; 146  : 		// Limit the maximum required buffer size
; 147  : 		if (mount->BytesPerSector > 128 * BYTES_PER_KB)

  002d9	8b 85 68 02 00
	00		 mov	 eax, DWORD PTR [rbp+616]
  002df	3d 00 00 02 00	 cmp	 eax, 131072		; 00020000H
  002e4	76 0a		 jbe	 SHORT $LN95@GSTOpenVol

; 148  : 		{
; 149  : 			ntStatus = STATUS_INVALID_PARAMETER;

  002e6	bf 0d 00 00 c0	 mov	 edi, -1073741811	; ffffffffc000000dH

; 150  : 			goto error;

  002eb	e9 f0 0a 00 00	 jmp	 $error$29740
$LN95@GSTOpenVol:

; 151  : 		}
; 152  : 
; 153  : 		Extension->HostBytesPerSector = mount->BytesPerSector;
; 154  : 
; 155  : 		if (Extension->HostBytesPerSector != GST_SECTOR_SIZE_FILE_HOSTED_VOLUME)

  002f0	3b c1		 cmp	 eax, ecx
  002f2	89 86 c0 00 00
	00		 mov	 DWORD PTR [rsi+192], eax
  002f8	48 8b c3	 mov	 rax, rbx
  002fb	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR lDiskLength$[rsp]
  00303	44 0f 45 f0	 cmovne	 r14d, eax
$LN94@GSTOpenVol:

; 156  : 			disableBuffering = FALSE;
; 157  : 	}
; 158  : 
; 159  : 	// Open the volume hosting file/device
; 160  : 	if (!mount->bMountReadOnly)

  00307	39 85 6c 02 00
	00		 cmp	 DWORD PTR [rbp+620], eax
  0030d	75 64		 jne	 SHORT $LN93@GSTOpenVol

; 161  : 	{
; 162  : 		ntStatus = ZwCreateFile (&Extension->hDeviceFile,
; 163  : 			GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
; 164  : 			&oaFileAttributes,
; 165  : 			&IoStatusBlock,
; 166  : 			NULL,
; 167  : 			FILE_ATTRIBUTE_NORMAL |
; 168  : 			FILE_ATTRIBUTE_SYSTEM,
; 169  : 			exclusiveAccess ? 0 : FILE_SHARE_READ | FILE_SHARE_WRITE,
; 170  : 			FILE_OPEN,
; 171  : 			FILE_RANDOM_ACCESS |
; 172  : 			FILE_WRITE_THROUGH |
; 173  : 			(disableBuffering ? FILE_NO_INTERMEDIATE_BUFFERING : 0) |
; 174  : 			FILE_SYNCHRONOUS_IO_NONALERT,
; 175  : 			NULL,
; 176  : 			0);

  0030f	41 8b c6	 mov	 eax, r14d
  00312	4c 8d 4c 24 70	 lea	 r9, QWORD PTR IoStatusBlock$[rsp]
  00317	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR oaFileAttributes$[rsp]
  0031f	f7 d8		 neg	 eax
  00321	41 8b c5	 mov	 eax, r13d
  00324	1b d2		 sbb	 edx, edx
  00326	83 e2 08	 and	 edx, 8
  00329	81 ca 22 08 00
	00		 or	 edx, 2082		; 00000822H
  0032f	f7 d8		 neg	 eax
  00331	1b c9		 sbb	 ecx, ecx
  00333	33 c0		 xor	 eax, eax
  00335	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00339	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0033e	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  00342	f7 d1		 not	 ecx
  00344	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  0034c	ba 00 00 10 c0	 mov	 edx, -1072693248	; c0100000H
  00351	83 e1 03	 and	 ecx, 3
  00354	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00358	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]
  0035c	c7 44 24 28 84
	00 00 00	 mov	 DWORD PTR [rsp+40], 132	; 00000084H
  00364	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00369	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile
  0036f	8b f8		 mov	 edi, eax
  00371	33 c0		 xor	 eax, eax
$LN93@GSTOpenVol:

; 177  : 	}
; 178  : 
; 179  : 	/* 26-4-99 NT for some partitions returns this code, it is really a	access denied */
; 180  : 	if (ntStatus == 0xc000001b)

  00373	81 ff 1b 00 00
	c0		 cmp	 edi, -1073741797	; c000001bH
  00379	b9 22 00 00 c0	 mov	 ecx, -1073741790	; ffffffffc0000022H

; 181  : 		ntStatus = STATUS_ACCESS_DENIED;
; 182  : 
; 183  : 	mount->VolumeMountedReadOnlyAfterAccessDenied = FALSE;

  0037e	89 45 08	 mov	 DWORD PTR [rbp+8], eax
  00381	0f 44 f9	 cmove	 edi, ecx

; 184  : 
; 185  : 	if (mount->bMountReadOnly || ntStatus == STATUS_ACCESS_DENIED)

  00384	39 85 6c 02 00
	00		 cmp	 DWORD PTR [rbp+620], eax
  0038a	75 19		 jne	 SHORT $LN90@GSTOpenVol
  0038c	3b f9		 cmp	 edi, ecx
  0038e	74 15		 je	 SHORT $LN90@GSTOpenVol

; 208  : 	}
; 209  : 	else
; 210  : 		Extension->bReadOnly = FALSE;

  00390	89 86 40 03 00
	00		 mov	 DWORD PTR [rsi+832], eax
  00396	4c 8d 6e 78	 lea	 r13, QWORD PTR [rsi+120]
  0039a	41 be 01 00 00
	00		 mov	 r14d, 1
  003a0	e9 82 00 00 00	 jmp	 $LN88@GSTOpenVol
$LN90@GSTOpenVol:

; 186  : 	{
; 187  : 		ntStatus = ZwCreateFile (&Extension->hDeviceFile,
; 188  : 			GENERIC_READ | SYNCHRONIZE,
; 189  : 			&oaFileAttributes,
; 190  : 			&IoStatusBlock,
; 191  : 			NULL,
; 192  : 			FILE_ATTRIBUTE_NORMAL |
; 193  : 			FILE_ATTRIBUTE_SYSTEM,
; 194  : 			exclusiveAccess ? FILE_SHARE_READ : FILE_SHARE_READ | FILE_SHARE_WRITE,
; 195  : 			FILE_OPEN,
; 196  : 			FILE_RANDOM_ACCESS |
; 197  : 			FILE_WRITE_THROUGH |
; 198  : 			(disableBuffering ? FILE_NO_INTERMEDIATE_BUFFERING : 0) |
; 199  : 			FILE_SYNCHRONOUS_IO_NONALERT,
; 200  : 			NULL,
; 201  : 			0);

  003a5	41 f7 de	 neg	 r14d
  003a8	4c 8d 4c 24 70	 lea	 r9, QWORD PTR IoStatusBlock$[rsp]
  003ad	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR oaFileAttributes$[rsp]
  003b5	1b c9		 sbb	 ecx, ecx
  003b7	83 e1 08	 and	 ecx, 8
  003ba	81 c9 22 08 00
	00		 or	 ecx, 2082		; 00000822H
  003c0	41 f7 dd	 neg	 r13d
  003c3	4c 8d 6e 78	 lea	 r13, QWORD PTR [rsi+120]
  003c7	1b c0		 sbb	 eax, eax
  003c9	33 d2		 xor	 edx, edx
  003cb	89 54 24 50	 mov	 DWORD PTR [rsp+80], edx
  003cf	48 89 54 24 48	 mov	 QWORD PTR [rsp+72], rdx
  003d4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003d8	44 8d 72 01	 lea	 r14d, QWORD PTR [rdx+1]
  003dc	83 e0 fe	 and	 eax, -2			; fffffffeH
  003df	49 8b cd	 mov	 rcx, r13
  003e2	44 89 74 24 38	 mov	 DWORD PTR [rsp+56], r14d
  003e7	83 c0 03	 add	 eax, 3
  003ea	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  003ee	c7 44 24 28 84
	00 00 00	 mov	 DWORD PTR [rsp+40], 132	; 00000084H
  003f6	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  003fb	ba 00 00 10 80	 mov	 edx, -2146435072	; 80100000H
  00400	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile
  00406	8b f8		 mov	 edi, eax

; 202  : 
; 203  : 		if (NT_SUCCESS (ntStatus) && !mount->bMountReadOnly)

  00408	33 c0		 xor	 eax, eax
  0040a	3b f8		 cmp	 edi, eax
  0040c	7c 0c		 jl	 SHORT $LN89@GSTOpenVol
  0040e	39 85 6c 02 00
	00		 cmp	 DWORD PTR [rbp+620], eax
  00414	75 04		 jne	 SHORT $LN89@GSTOpenVol

; 204  : 			mount->VolumeMountedReadOnlyAfterAccessDenied = TRUE;

  00416	44 89 75 08	 mov	 DWORD PTR [rbp+8], r14d
$LN89@GSTOpenVol:

; 205  : 
; 206  : 		Extension->bReadOnly = TRUE;

  0041a	44 89 b6 40 03
	00 00		 mov	 DWORD PTR [rsi+832], r14d

; 207  : 		DeviceObject->Characteristics |= FILE_READ_ONLY_DEVICE;

  00421	41 83 4c 24 34
	02		 or	 DWORD PTR [r12+52], 2
$LN88@GSTOpenVol:

; 211  : 
; 212  : 	/* 26-4-99 NT for some partitions returns this code, it is really a
; 213  : 	access denied */
; 214  : 	if (ntStatus == 0xc000001b)

  00427	b8 43 00 00 c0	 mov	 eax, -1073741757	; ffffffffc0000043H
  0042c	81 ff 1b 00 00
	c0		 cmp	 edi, -1073741797	; c000001bH
  00432	0f 44 f8	 cmove	 edi, eax

; 215  : 	{
; 216  : 		/* Partitions which return this code can still be opened with
; 217  : 		FILE_SHARE_READ but this causes NT problems elsewhere in
; 218  : 		particular if you do FILE_SHARE_READ NT will die later if
; 219  : 		anyone even tries to open the partition (or file for that
; 220  : 		matter...)  */
; 221  : 		ntStatus = STATUS_SHARING_VIOLATION;
; 222  : 	}
; 223  : 
; 224  : 	if (!NT_SUCCESS (ntStatus))

  00435	33 c0		 xor	 eax, eax
  00437	3b f8		 cmp	 edi, eax
  00439	0f 8c 9f 09 00
	00		 jl	 $LN158@GSTOpenVol

; 225  : 	{
; 226  : 		goto error;
; 227  : 	}
; 228  : 
; 229  : 	// If we have opened a file, query its size now
; 230  : 	if (bRawDevice == FALSE)

  0043f	44 8b a4 24 20
	03 00 00	 mov	 r12d, DWORD PTR bRawDevice$[rsp]

; 231  : 	{
; 232  : 		ntStatus = ZwQueryInformationFile (Extension->hDeviceFile,
; 233  : 			&IoStatusBlock,
; 234  : 			&FileBasicInfo,
; 235  : 			sizeof (FileBasicInfo),
; 236  : 			FileBasicInformation);

  00447	49 8b 4d 00	 mov	 rcx, QWORD PTR [r13]
  0044b	33 ff		 xor	 edi, edi
  0044d	44 3b e7	 cmp	 r12d, edi
  00450	0f 85 18 01 00
	00		 jne	 $LN85@GSTOpenVol
  00456	44 8d 48 28	 lea	 r9d, QWORD PTR [rax+40]
  0045a	4c 8d 84 24 10
	01 00 00	 lea	 r8, QWORD PTR FileBasicInfo$[rsp]
  00462	48 8d 54 24 70	 lea	 rdx, QWORD PTR IoStatusBlock$[rsp]
  00467	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0046f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQueryInformationFile

; 237  : 
; 238  : 		if (NT_SUCCESS (ntStatus))

  00475	33 db		 xor	 ebx, ebx
  00477	3b c3		 cmp	 eax, ebx
  00479	8b f8		 mov	 edi, eax
  0047b	0f 8c 5f 09 00
	00		 jl	 $error$29740

; 239  : 		{
; 240  : 			if (mount->bPreserveTimestamp)

  00481	33 ff		 xor	 edi, edi
  00483	39 bd 7c 02 00
	00		 cmp	 DWORD PTR [rbp+636], edi
  00489	74 43		 je	 SHORT $LN83@GSTOpenVol

; 241  : 			{
; 242  : 				Extension->fileCreationTime = FileBasicInfo.CreationTime;

  0048b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR FileBasicInfo$[rsp]

; 243  : 				Extension->fileLastAccessTime = FileBasicInfo.LastAccessTime;
; 244  : 				Extension->fileLastWriteTime = FileBasicInfo.LastWriteTime;
; 245  : 				Extension->fileLastChangeTime = FileBasicInfo.ChangeTime;
; 246  : 				Extension->bTimeStampValid = TRUE;

  00493	44 89 b6 80 05
	00 00		 mov	 DWORD PTR [rsi+1408], r14d
  0049a	48 89 86 60 05
	00 00		 mov	 QWORD PTR [rsi+1376], rax
  004a1	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR FileBasicInfo$[rsp+8]
  004a9	48 89 86 68 05
	00 00		 mov	 QWORD PTR [rsi+1384], rax
  004b0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR FileBasicInfo$[rsp+16]
  004b8	48 89 86 70 05
	00 00		 mov	 QWORD PTR [rsi+1392], rax
  004bf	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR FileBasicInfo$[rsp+24]
  004c7	48 89 86 78 05
	00 00		 mov	 QWORD PTR [rsi+1400], rax
$LN83@GSTOpenVol:

; 247  : 			}
; 248  : 
; 249  : 			ntStatus = ZwQueryInformationFile (Extension->hDeviceFile,
; 250  : 				&IoStatusBlock,
; 251  : 				&FileStandardInfo,
; 252  : 				sizeof (FileStandardInfo),
; 253  : 				FileStandardInformation);

  004ce	49 8b 4d 00	 mov	 rcx, QWORD PTR [r13]
  004d2	4c 8d 84 24 98
	01 00 00	 lea	 r8, QWORD PTR FileStandardInfo$[rsp]
  004da	48 8d 54 24 70	 lea	 rdx, QWORD PTR IoStatusBlock$[rsp]
  004df	41 b9 18 00 00
	00		 mov	 r9d, 24
  004e5	c7 44 24 20 05
	00 00 00	 mov	 DWORD PTR [rsp+32], 5
  004ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwQueryInformationFile

; 254  : 		}
; 255  : 
; 256  : 		if (!NT_SUCCESS (ntStatus))

  004f3	3b c3		 cmp	 eax, ebx
  004f5	8b f8		 mov	 edi, eax
  004f7	0f 8c e3 08 00
	00		 jl	 $error$29740

; 257  : 		{
; 258  : 			Dump ("ZwQueryInformationFile failed while opening file: NTSTATUS 0x%08x\n",
; 259  : 				ntStatus);
; 260  : 			goto error;
; 261  : 		}
; 262  : 
; 263  : 		lDiskLength.QuadPart = FileStandardInfo.EndOfFile.QuadPart;
; 264  : 
; 265  : 		if (FileBasicInfo.FileAttributes & FILE_ATTRIBUTE_COMPRESSED)

  004fd	0f ba a4 24 30
	01 00 00 0b	 bt	 DWORD PTR FileBasicInfo$[rsp+32], 11
  00506	48 8b 9c 24 a0
	01 00 00	 mov	 rbx, QWORD PTR FileStandardInfo$[rsp+8]
  0050e	73 0f		 jae	 SHORT $LN81@GSTOpenVol

; 266  : 		{
; 267  : 			Dump ("File \"%ls\" is marked as compressed - not supported!\n", pwszMountVolume);
; 268  : 			mount->nReturnCode = ERR_COMPRESSION_NOT_SUPPORTED;

  00510	c7 45 00 08 00
	00 00		 mov	 DWORD PTR [rbp], 8

; 269  : 			ntStatus = STATUS_SUCCESS;

  00517	41 8b ff	 mov	 edi, r15d

; 270  : 			goto error;

  0051a	e9 e3 08 00 00	 jmp	 $LN6@GSTOpenVol
$LN81@GSTOpenVol:

; 271  : 		}
; 272  : 
; 273  : 		ntStatus = ObReferenceObjectByHandle (Extension->hDeviceFile,
; 274  : 			FILE_ALL_ACCESS,
; 275  : 			*IoFileObjectType,
; 276  : 			KernelMode,
; 277  : 			&Extension->pfoDeviceFile,
; 278  : 			0);

  0051f	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR IoFileObjectType
  00526	49 8b 4d 00	 mov	 rcx, QWORD PTR [r13]
  0052a	4c 8d b6 80 00
	00 00		 lea	 r14, QWORD PTR [rsi+128]
  00531	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00534	33 ff		 xor	 edi, edi
  00536	45 33 c9	 xor	 r9d, r9d
  00539	ba ff 01 1f 00	 mov	 edx, 2032127		; 001f01ffH
  0053e	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  00543	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00548	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle
  0054e	8b f8		 mov	 edi, eax

; 279  : 
; 280  : 		if (!NT_SUCCESS (ntStatus))

  00550	33 c0		 xor	 eax, eax
  00552	3b f8		 cmp	 edi, eax
  00554	0f 8c 84 08 00
	00		 jl	 $LN158@GSTOpenVol

; 281  : 		{
; 282  : 			goto error;
; 283  : 		}
; 284  : 
; 285  : 		/* Get the FSD device for the file (probably either NTFS or	FAT) */
; 286  : 		Extension->pFsdDevice = IoGetRelatedDeviceObject (Extension->pfoDeviceFile);

  0055a	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  0055d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetRelatedDeviceObject

; 287  : 	}
; 288  : 	else

  00563	33 ff		 xor	 edi, edi
  00565	48 89 86 88 00
	00 00		 mov	 QWORD PTR [rsi+136], rax
  0056c	eb 6a		 jmp	 SHORT $LN78@GSTOpenVol
$LN85@GSTOpenVol:

; 289  : 	{
; 290  : 		// Try to gain "raw" access to the partition in case there is a live filesystem on it (otherwise, 
; 291  : 		// the NTFS driver guards hidden sectors and prevents mounting using a backup header e.g. after the user 
; 292  : 		// accidentally quick-formats a dismounted partition-hosted GostCrypt volume as NTFS).
; 293  : 
; 294  : 		PFILE_OBJECT pfoTmpDeviceFile = NULL;
; 295  : 
; 296  : 		if (NT_SUCCESS (ObReferenceObjectByHandle (Extension->hDeviceFile, FILE_ALL_ACCESS, *IoFileObjectType, KernelMode, &pfoTmpDeviceFile, NULL))
; 297  : 			&& pfoTmpDeviceFile != NULL)

  0056e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR IoFileObjectType
  00575	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR pfoTmpDeviceFile$29796[rsp]
  0057d	45 33 c9	 xor	 r9d, r9d
  00580	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00583	ba ff 01 1f 00	 mov	 edx, 2032127		; 001f01ffH
  00588	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  0058d	48 89 bc 24 88
	00 00 00	 mov	 QWORD PTR pfoTmpDeviceFile$29796[rsp], rdi
  00595	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0059a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByHandle
  005a0	3b c7		 cmp	 eax, edi
  005a2	7c 34		 jl	 SHORT $LN78@GSTOpenVol
  005a4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pfoTmpDeviceFile$29796[rsp]
  005ac	48 3b cf	 cmp	 rcx, rdi
  005af	74 27		 je	 SHORT $LN78@GSTOpenVol

; 298  : 		{
; 299  : 			GSTFsctlCall (pfoTmpDeviceFile, FSCTL_ALLOW_EXTENDED_DASD_IO, NULL, 0, NULL, 0);

  005b1	45 33 c9	 xor	 r9d, r9d
  005b4	45 33 c0	 xor	 r8d, r8d
  005b7	ba 83 00 09 00	 mov	 edx, 589955		; 00090083H
  005bc	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  005c0	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  005c5	e8 00 00 00 00	 call	 GSTFsctlCall

; 300  : 			ObDereferenceObject (pfoTmpDeviceFile);

  005ca	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pfoTmpDeviceFile$29796[rsp]
  005d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject
$LN78@GSTOpenVol:

; 301  : 		}
; 302  : 	}
; 303  : 
; 304  : 	// Check volume size
; 305  : 	if (lDiskLength.QuadPart < GST_MIN_VOLUME_SIZE_LEGACY || lDiskLength.QuadPart > GST_MAX_VOLUME_SIZE)

  005d8	48 8d 83 00 b6
	ff ff		 lea	 rax, QWORD PTR [rbx-18944]
  005df	48 b9 00 b6 ff
	ff ff ff 03 00	 mov	 rcx, 1125899906823680	; 0003ffffffffb600H
  005e9	48 3b c1	 cmp	 rax, rcx
  005ec	0f 87 e5 07 00
	00		 ja	 $LN76@GSTOpenVol

; 308  : 		ntStatus = STATUS_SUCCESS;
; 309  : 		goto error;
; 310  : 	}
; 311  : 
; 312  : 	Extension->DiskLength = lDiskLength.QuadPart;
; 313  : 	Extension->HostLength = lDiskLength.QuadPart;
; 314  : 
; 315  : 	readBuffer = GSTalloc (max (max (GST_VOLUME_HEADER_EFFECTIVE_SIZE, PAGE_SIZE), Extension->HostBytesPerSector));

  005f2	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [rsi+192]
  005f8	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  005fd	41 b8 54 43 4d
	4d		 mov	 r8d, 1296909140		; 4d4d4354H
  00603	3b c1		 cmp	 eax, ecx
  00605	48 89 9e a0 00
	00 00		 mov	 QWORD PTR [rsi+160], rbx
  0060c	48 89 9e 98 00
	00 00		 mov	 QWORD PTR [rsi+152], rbx
  00613	0f 42 c1	 cmovb	 eax, ecx
  00616	33 c9		 xor	 ecx, ecx
  00618	8b d0		 mov	 edx, eax
  0061a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePoolWithTag
  00620	4c 8b f0	 mov	 r14, rax
  00623	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR readBuffer$1$[rsp], rax

; 316  : 	if (readBuffer == NULL)

  0062b	48 3b c7	 cmp	 rax, rdi
  0062e	75 0a		 jne	 SHORT $LN75@GSTOpenVol

; 317  : 	{
; 318  : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  00630	bf 9a 00 00 c0	 mov	 edi, -1073741670	; ffffffffc000009aH

; 319  : 		goto error;

  00635	e9 a4 07 00 00	 jmp	 $LN158@GSTOpenVol
$LN75@GSTOpenVol:

; 320  : 	}
; 321  : 
; 322  : 	// Go through all volume types (e.g., normal, hidden)
; 323  : 	for (volumeType = GST_VOLUME_TYPE_NORMAL;
; 324  : 		volumeType < GST_VOLUME_TYPE_COUNT;
; 325  : 		volumeType++)	

  0063a	44 8b ef	 mov	 r13d, edi
$LL74@GSTOpenVol:

; 326  : 	{
; 327  : 		Dump ("Trying to open volume type %d\n", volumeType);
; 328  : 
; 329  : 		if (mount->bPartitionInInactiveSysEncScope
; 330  : 			&& volumeType == GST_VOLUME_TYPE_HIDDEN_LEGACY)

  0063d	39 bd 80 02 00
	00		 cmp	 DWORD PTR [rbp+640], edi
  00643	0f 84 6f 01 00
	00		 je	 $LN69@GSTOpenVol
  00649	41 83 fd 02	 cmp	 r13d, 2
  0064d	0f 84 38 07 00
	00		 je	 $LN73@GSTOpenVol

; 331  : 			continue;		
; 332  : 
; 333  : 		/* Read the volume header */
; 334  : 
; 335  : 		if (!mount->bPartitionInInactiveSysEncScope
; 336  : 			|| (mount->bPartitionInInactiveSysEncScope && volumeType == GST_VOLUME_TYPE_HIDDEN))

  00653	41 83 fd 01	 cmp	 r13d, 1
  00657	0f 84 5b 01 00
	00		 je	 $LN69@GSTOpenVol

; 381  : 		}
; 382  : 		else
; 383  : 		{
; 384  : 			// Header of a partition that is within the scope of system encryption
; 385  : 
; 386  : 			WCHAR parentDrivePath [47+1] = {0};

  0065d	33 d2		 xor	 edx, edx
  0065f	48 8d 8c 24 42
	02 00 00	 lea	 rcx, QWORD PTR parentDrivePath$29834[rsp+2]
  00667	66 89 bc 24 40
	02 00 00	 mov	 WORD PTR parentDrivePath$29834[rsp], di
  0066f	44 8d 42 5e	 lea	 r8d, QWORD PTR [rdx+94]
  00673	e8 00 00 00 00	 call	 memset

; 387  : 			HANDLE hParentDeviceFile = NULL;
; 388  : 			UNICODE_STRING FullParentPath;
; 389  : 			OBJECT_ATTRIBUTES oaParentFileAttributes;
; 390  : 			LARGE_INTEGER parentKeyDataOffset;
; 391  : 
; 392  : 			_snwprintf (parentDrivePath,
; 393  : 				sizeof (parentDrivePath) / sizeof (WCHAR) - 1,
; 394  : 				WIDE ("\\Device\\Harddisk%d\\Partition0"),
; 395  : 				mount->nPartitionInInactiveSysEncScopeDriveNo);

  00678	44 8b 8d 84 02
	00 00		 mov	 r9d, DWORD PTR [rbp+644]
  0067f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1DM@FMJIKGBL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAH?$AAa?$AAr?$AAd?$AAd?$AAi?$AAs?$AAk?$AA?$CF?$AAd?$AA?2?$AAP?$AAa?$AAr?$AAt?$AAi?$AAt?$AAi?$AAo?$AAn?$AA0?$AA?$AA@FNODOBFM@
  00686	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR parentDrivePath$29834[rsp]
  0068e	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  00693	48 89 7c 24 68	 mov	 QWORD PTR hParentDeviceFile$29835[rsp], rdi
  00698	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__snwprintf

; 396  : 
; 397  : 			Dump ("Mounting partition within scope of system encryption (reading key data from: %ls)\n", parentDrivePath);
; 398  : 
; 399  : 			RtlInitUnicodeString (&FullParentPath, parentDrivePath);

  0069e	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR parentDrivePath$29834[rsp]
  006a6	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR FullParentPath$29837[rsp]
  006ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 400  : 			InitializeObjectAttributes (&oaParentFileAttributes, &FullParentPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,	NULL, NULL);
; 401  : 
; 402  : 			ntStatus = ZwCreateFile (&hParentDeviceFile,
; 403  : 				GENERIC_READ | SYNCHRONIZE,
; 404  : 				&oaParentFileAttributes,
; 405  : 				&IoStatusBlock,
; 406  : 				NULL,
; 407  : 				FILE_ATTRIBUTE_NORMAL |
; 408  : 				FILE_ATTRIBUTE_SYSTEM,
; 409  : 				FILE_SHARE_READ | FILE_SHARE_WRITE,
; 410  : 				FILE_OPEN,
; 411  : 				FILE_RANDOM_ACCESS |
; 412  : 				FILE_WRITE_THROUGH |
; 413  : 				FILE_NO_INTERMEDIATE_BUFFERING |
; 414  : 				FILE_SYNCHRONOUS_IO_NONALERT,
; 415  : 				NULL,
; 416  : 				0);

  006b4	89 7c 24 50	 mov	 DWORD PTR [rsp+80], edi
  006b8	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  006bd	c7 44 24 40 2a
	08 00 00	 mov	 DWORD PTR [rsp+64], 2090 ; 0000082aH
  006c5	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  006cd	48 8d 84 24 68
	01 00 00	 lea	 rax, QWORD PTR FullParentPath$29837[rsp]
  006d5	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR [rsp+48], 3
  006dd	4c 8d 4c 24 70	 lea	 r9, QWORD PTR IoStatusBlock$[rsp]
  006e2	4c 8d 84 24 38
	01 00 00	 lea	 r8, QWORD PTR oaParentFileAttributes$29838[rsp]
  006ea	48 8d 4c 24 68	 lea	 rcx, QWORD PTR hParentDeviceFile$29835[rsp]
  006ef	ba 00 00 10 80	 mov	 edx, -2146435072	; 80100000H
  006f4	c7 44 24 28 84
	00 00 00	 mov	 DWORD PTR [rsp+40], 132	; 00000084H
  006fc	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00701	c7 84 24 38 01
	00 00 30 00 00
	00		 mov	 DWORD PTR oaParentFileAttributes$29838[rsp], 48 ; 00000030H
  0070c	48 89 bc 24 40
	01 00 00	 mov	 QWORD PTR oaParentFileAttributes$29838[rsp+8], rdi
  00714	c7 84 24 50 01
	00 00 40 02 00
	00		 mov	 DWORD PTR oaParentFileAttributes$29838[rsp+24], 576 ; 00000240H
  0071f	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR oaParentFileAttributes$29838[rsp+16], rax
  00727	48 89 bc 24 58
	01 00 00	 mov	 QWORD PTR oaParentFileAttributes$29838[rsp+32], rdi
  0072f	48 89 bc 24 60
	01 00 00	 mov	 QWORD PTR oaParentFileAttributes$29838[rsp+40], rdi
  00737	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwCreateFile

; 417  : 
; 418  : 			if (!NT_SUCCESS (ntStatus))

  0073d	33 c9		 xor	 ecx, ecx
  0073f	3b c1		 cmp	 eax, ecx
  00741	8b f8		 mov	 edi, eax
  00743	0f 8c 54 06 00
	00		 jl	 $LN140@GSTOpenVol

; 426  : 			}
; 427  : 
; 428  : 			parentKeyDataOffset.QuadPart = GST_BOOT_VOLUME_HEADER_SECTOR_OFFSET;
; 429  : 
; 430  : 			ntStatus = ZwReadFile (hParentDeviceFile,
; 431  : 				NULL,
; 432  : 				NULL,
; 433  : 				NULL,
; 434  : 				&IoStatusBlock,
; 435  : 				readBuffer,
; 436  : 				max (GST_VOLUME_HEADER_EFFECTIVE_SIZE, Extension->HostBytesPerSector),
; 437  : 				&parentKeyDataOffset,
; 438  : 				NULL);

  00749	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [rsi+192]
  0074f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00754	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00759	3b c2		 cmp	 eax, edx
  0075b	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR parentKeyDataOffset$29839[rsp]
  00763	48 c7 84 24 90
	00 00 00 00 7c
	00 00		 mov	 QWORD PTR parentKeyDataOffset$29839[rsp], 31744 ; 00007c00H
  0076f	0f 42 c2	 cmovb	 eax, edx
  00772	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00777	48 8b 4c 24 68	 mov	 rcx, QWORD PTR hParentDeviceFile$29835[rsp]
  0077c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00780	48 8d 44 24 70	 lea	 rax, QWORD PTR IoStatusBlock$[rsp]
  00785	45 33 c9	 xor	 r9d, r9d
  00788	45 33 c0	 xor	 r8d, r8d
  0078b	33 d2		 xor	 edx, edx
  0078d	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00792	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00797	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile

; 439  : 
; 440  : 			if (hParentDeviceFile != NULL)

  0079d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR hParentDeviceFile$29835[rsp]
  007a2	8b f8		 mov	 edi, eax
  007a4	48 85 c9	 test	 rcx, rcx
  007a7	0f 84 f0 00 00
	00		 je	 $LN56@GSTOpenVol

; 441  : 				ZwClose (hParentDeviceFile);

  007ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
  007b3	e9 e5 00 00 00	 jmp	 $LN56@GSTOpenVol
$LN69@GSTOpenVol:

; 337  : 		{
; 338  : 			// Header of a volume that is not within the scope of system encryption, or
; 339  : 			// header of a system hidden volume (containing a hidden OS)
; 340  : 
; 341  : 			LARGE_INTEGER headerOffset;
; 342  : 
; 343  : 			if (mount->UseBackupHeader && lDiskLength.QuadPart <= GST_TOTAL_VOLUME_HEADERS_SIZE)

  007b8	8b 95 d8 02 00
	00		 mov	 edx, DWORD PTR [rbp+728]
  007be	3b d7		 cmp	 edx, edi
  007c0	74 0d		 je	 SHORT $LN68@GSTOpenVol
  007c2	48 81 fb 00 00
	04 00		 cmp	 rbx, 262144		; 00040000H
  007c9	0f 8e bc 05 00
	00		 jle	 $LN73@GSTOpenVol
$LN68@GSTOpenVol:

; 344  : 				continue;
; 345  : 
; 346  : 			switch (volumeType)

  007cf	41 8b cd	 mov	 ecx, r13d
  007d2	44 3b ef	 cmp	 r13d, edi
  007d5	74 5a		 je	 SHORT $LN65@GSTOpenVol
  007d7	83 e9 01	 sub	 ecx, 1
  007da	74 2c		 je	 SHORT $LN64@GSTOpenVol
  007dc	83 f9 01	 cmp	 ecx, 1
  007df	75 67		 jne	 SHORT $LN66@GSTOpenVol

; 358  : 
; 359  : 			case GST_VOLUME_TYPE_HIDDEN_LEGACY:
; 360  : 				if (mount->UseBackupHeader)

  007e1	3b d7		 cmp	 edx, edi
  007e3	0f 85 a2 05 00
	00		 jne	 $LN73@GSTOpenVol

; 361  : 					continue;
; 362  : 
; 363  : 				if (bRawDevice && Extension->HostBytesPerSector != GST_SECTOR_SIZE_LEGACY)

  007e9	44 3b e7	 cmp	 r12d, edi
  007ec	74 11		 je	 SHORT $LN60@GSTOpenVol
  007ee	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  007f3	39 86 c0 00 00
	00		 cmp	 DWORD PTR [rsi+192], eax
  007f9	0f 85 8c 05 00
	00		 jne	 $LN73@GSTOpenVol
$LN60@GSTOpenVol:

; 364  : 					continue;
; 365  : 
; 366  : 				headerOffset.QuadPart = lDiskLength.QuadPart - GST_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  007ff	48 8d 83 00 fa
	ff ff		 lea	 rax, QWORD PTR [rbx-1536]

; 367  : 				break;

  00806	eb 38		 jmp	 SHORT $LN165@GSTOpenVol
$LN64@GSTOpenVol:

; 350  : 				break;
; 351  : 
; 352  : 			case GST_VOLUME_TYPE_HIDDEN:
; 353  : 				if (lDiskLength.QuadPart <= GST_VOLUME_HEADER_GROUP_SIZE)

  00808	48 81 fb 00 00
	02 00		 cmp	 rbx, 131072		; 00020000H
  0080f	0f 8e 76 05 00
	00		 jle	 $LN73@GSTOpenVol

; 354  : 					continue;
; 355  : 
; 356  : 				headerOffset.QuadPart = mount->UseBackupHeader ? lDiskLength.QuadPart - GST_HIDDEN_VOLUME_HEADER_OFFSET : GST_HIDDEN_VOLUME_HEADER_OFFSET;

  00815	48 8d 83 00 00
	ff ff		 lea	 rax, QWORD PTR [rbx-65536]
  0081c	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00821	3b d7		 cmp	 edx, edi
  00823	48 0f 45 c8	 cmovne	 rcx, rax
  00827	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR headerOffset$29817[rsp], rcx

; 357  : 				break;

  0082f	eb 17		 jmp	 SHORT $LN66@GSTOpenVol
$LN65@GSTOpenVol:

; 347  : 			{
; 348  : 			case GST_VOLUME_TYPE_NORMAL:
; 349  : 				headerOffset.QuadPart = mount->UseBackupHeader ? lDiskLength.QuadPart - GST_VOLUME_HEADER_GROUP_SIZE : GST_VOLUME_HEADER_OFFSET;

  00831	f7 da		 neg	 edx
  00833	48 8d 8b 00 00
	fe ff		 lea	 rcx, QWORD PTR [rbx-131072]
  0083a	48 1b c0	 sbb	 rax, rax
  0083d	48 23 c1	 and	 rax, rcx
$LN165@GSTOpenVol:
  00840	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR headerOffset$29817[rsp], rax
$LN66@GSTOpenVol:

; 368  : 			}
; 369  : 
; 370  : 			Dump ("Reading volume header at %I64d\n", headerOffset.QuadPart);
; 371  : 
; 372  : 			ntStatus = ZwReadFile (Extension->hDeviceFile,
; 373  : 			NULL,
; 374  : 			NULL,
; 375  : 			NULL,
; 376  : 			&IoStatusBlock,
; 377  : 			readBuffer,
; 378  : 			bRawDevice ? max (GST_VOLUME_HEADER_EFFECTIVE_SIZE, Extension->HostBytesPerSector) : GST_VOLUME_HEADER_EFFECTIVE_SIZE,
; 379  : 			&headerOffset,
; 380  : 			NULL);

  00848	44 3b e7	 cmp	 r12d, edi
  0084b	74 12		 je	 SHORT $LN117@GSTOpenVol
  0084d	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [rsi+192]
  00853	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00858	3b c1		 cmp	 eax, ecx
  0085a	0f 42 c1	 cmovb	 eax, ecx
  0085d	eb 05		 jmp	 SHORT $LN118@GSTOpenVol
$LN117@GSTOpenVol:
  0085f	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
$LN118@GSTOpenVol:
  00864	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00869	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR headerOffset$29817[rsp]
  00871	45 33 c9	 xor	 r9d, r9d
  00874	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00879	48 8b 4e 78	 mov	 rcx, QWORD PTR [rsi+120]
  0087d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00881	48 8d 44 24 70	 lea	 rax, QWORD PTR IoStatusBlock$[rsp]
  00886	45 33 c0	 xor	 r8d, r8d
  00889	33 d2		 xor	 edx, edx
  0088b	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00890	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00895	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwReadFile
  0089b	8b f8		 mov	 edi, eax
$LN56@GSTOpenVol:

; 442  : 		}
; 443  : 
; 444  : 		if (!NT_SUCCESS (ntStatus) && ntStatus != STATUS_END_OF_FILE)

  0089d	85 ff		 test	 edi, edi
  0089f	79 0c		 jns	 SHORT $LN55@GSTOpenVol
  008a1	81 ff 11 00 00
	c0		 cmp	 edi, -1073741807	; ffffffffc0000011H
  008a7	0f 85 31 05 00
	00		 jne	 $LN158@GSTOpenVol
$LN55@GSTOpenVol:

; 445  : 		{
; 446  : 			Dump ("Read failed: NTSTATUS 0x%08x\n", ntStatus);
; 447  : 			goto error;
; 448  : 		}
; 449  : 
; 450  : 		if (ntStatus == STATUS_END_OF_FILE || IoStatusBlock.Information < GST_VOLUME_HEADER_EFFECTIVE_SIZE)

  008ad	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  008b2	81 ff 11 00 00
	c0		 cmp	 edi, -1073741807	; ffffffffc0000011H
  008b8	74 07		 je	 SHORT $LN53@GSTOpenVol
  008ba	48 39 44 24 78	 cmp	 QWORD PTR IoStatusBlock$[rsp+8], rax
  008bf	73 0d		 jae	 SHORT $LN54@GSTOpenVol
$LN53@GSTOpenVol:

; 451  : 		{
; 452  : 			Dump ("Read didn't read enough data\n");
; 453  : 
; 454  : 			// If FSCTL_ALLOW_EXTENDED_DASD_IO failed and there is a live filesystem on the partition, then the
; 455  : 			// filesystem driver may report EOF when we are reading hidden sectors (when the filesystem is 
; 456  : 			// shorter than the partition). This can happen for example after the user quick-formats a dismounted
; 457  : 			// partition-hosted GostCrypt volume and then tries to mount the volume using the embedded backup header.
; 458  : 			memset (readBuffer, 0, GST_VOLUME_HEADER_EFFECTIVE_SIZE);

  008c1	4c 8b c0	 mov	 r8, rax
  008c4	33 d2		 xor	 edx, edx
  008c6	49 8b ce	 mov	 rcx, r14
  008c9	e8 00 00 00 00	 call	 memset
$LN54@GSTOpenVol:

; 459  : 		}
; 460  : 
; 461  : 		/* Attempt to recognize the volume (decrypt the header) */
; 462  : 
; 463  : 		ReadVolumeHeaderRecoveryMode = mount->RecoveryMode;

  008ce	8b 85 dc 02 00
	00		 mov	 eax, DWORD PTR [rbp+732]
  008d4	89 05 00 00 00
	00		 mov	 DWORD PTR ReadVolumeHeaderRecoveryMode, eax

; 464  : 
; 465  : 		if ((volumeType == GST_VOLUME_TYPE_HIDDEN || volumeType == GST_VOLUME_TYPE_HIDDEN_LEGACY) && mount->bProtectHiddenVolume)

  008da	41 83 fd 01	 cmp	 r13d, 1
  008de	74 06		 je	 SHORT $LN51@GSTOpenVol
  008e0	41 83 fd 02	 cmp	 r13d, 2
  008e4	75 38		 jne	 SHORT $LN162@GSTOpenVol
$LN51@GSTOpenVol:
  008e6	33 ff		 xor	 edi, edi
  008e8	39 bd 8c 02 00
	00		 cmp	 DWORD PTR [rbp+652], edi
  008ee	74 30		 je	 SHORT $LN52@GSTOpenVol

; 466  : 		{
; 467  : 			mount->nReturnCode = ReadVolumeHeaderWCache (
; 468  : 				FALSE,
; 469  : 				mount->bCache,
; 470  : 				readBuffer,
; 471  : 				&mount->ProtectedHidVolPassword,
; 472  : 				&tmpCryptoInfo);

  008f0	8b 95 60 02 00
	00		 mov	 edx, DWORD PTR [rbp+608]
  008f6	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR tmpCryptoInfo$[rsp]
  008fe	4c 8d 8d 90 02
	00 00		 lea	 r9, QWORD PTR [rbp+656]
  00905	4d 8b c6	 mov	 r8, r14
  00908	33 c9		 xor	 ecx, ecx
  0090a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0090f	e8 00 00 00 00	 call	 ReadVolumeHeaderWCache

; 473  : 		}
; 474  : 		else

  00914	4c 8b bc 24 98
	00 00 00	 mov	 r15, QWORD PTR tmpCryptoInfo$[rsp]
  0091c	eb 37		 jmp	 SHORT $LN166@GSTOpenVol
$LN162@GSTOpenVol:

; 586  : 					Extension->DiskLength = Extension->cryptoInfo->VolumeSize.Value;

  0091e	33 ff		 xor	 edi, edi
$LN52@GSTOpenVol:

; 475  : 		{
; 476  : 			mount->nReturnCode = ReadVolumeHeaderWCache (
; 477  : 				mount->bPartitionInInactiveSysEncScope && volumeType == GST_VOLUME_TYPE_NORMAL,
; 478  : 				mount->bCache,
; 479  : 				readBuffer,
; 480  : 				&mount->VolumePassword,
; 481  : 				&Extension->cryptoInfo);

  00920	39 bd 80 02 00
	00		 cmp	 DWORD PTR [rbp+640], edi
  00926	74 0a		 je	 SHORT $LN121@GSTOpenVol
  00928	b9 01 00 00 00	 mov	 ecx, 1
  0092d	44 3b ef	 cmp	 r13d, edi
  00930	74 02		 je	 SHORT $LN122@GSTOpenVol
$LN121@GSTOpenVol:
  00932	8b cf		 mov	 ecx, edi
$LN122@GSTOpenVol:
  00934	8b 95 60 02 00
	00		 mov	 edx, DWORD PTR [rbp+608]
  0093a	48 8d 86 90 00
	00 00		 lea	 rax, QWORD PTR [rsi+144]
  00941	4c 8d 8d 18 02
	00 00		 lea	 r9, QWORD PTR [rbp+536]
  00948	4d 8b c6	 mov	 r8, r14
  0094b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00950	e8 00 00 00 00	 call	 ReadVolumeHeaderWCache
$LN166@GSTOpenVol:
  00955	89 45 00	 mov	 DWORD PTR [rbp], eax

; 482  : 		}
; 483  : 
; 484  : 		ReadVolumeHeaderRecoveryMode = FALSE;

  00958	89 3d 00 00 00
	00		 mov	 DWORD PTR ReadVolumeHeaderRecoveryMode, edi

; 485  : 
; 486  : 		if (mount->nReturnCode == 0 || mount->nReturnCode == ERR_CIPHER_INIT_WEAK_KEY)

  0095e	3b c7		 cmp	 eax, edi
  00960	74 31		 je	 SHORT $LN48@GSTOpenVol
  00962	83 f8 12	 cmp	 eax, 18
  00965	74 2c		 je	 SHORT $LN48@GSTOpenVol

; 696  : 			}
; 697  : 		}
; 698  : 		else if ((mount->bProtectHiddenVolume && volumeType == GST_VOLUME_TYPE_NORMAL)
; 699  : 			  || mount->nReturnCode != ERR_PASSWORD_WRONG)

  00967	39 bd 8c 02 00
	00		 cmp	 DWORD PTR [rbp+652], edi
  0096d	74 05		 je	 SHORT $LN10@GSTOpenVol
  0096f	44 3b ef	 cmp	 r13d, edi
  00972	74 0a		 je	 SHORT $LN152@GSTOpenVol
$LN10@GSTOpenVol:
  00974	83 7d 00 03	 cmp	 DWORD PTR [rbp], 3
  00978	0f 84 0d 04 00
	00		 je	 $LN73@GSTOpenVol
$LN152@GSTOpenVol:

; 700  : 		{
; 701  : 			 /* If we are not supposed to protect a hidden volume, the only error that is
; 702  : 				tolerated is ERR_PASSWORD_WRONG (to allow mounting a possible hidden volume). 
; 703  : 
; 704  : 				If we _are_ supposed to protect a hidden volume, we do not tolerate any error
; 705  : 				(both volume headers must be successfully decrypted). */
; 706  : 
; 707  : 			break;
; 708  : 		}
; 709  : 	}
; 710  : 
; 711  : 	/* Failed due to some non-OS reason so we drop through and return NT
; 712  : 	   SUCCESS then nReturnCode is checked later in user-mode */
; 713  : 
; 714  : 	if (mount->nReturnCode == ERR_OUTOFMEMORY)

  0097e	83 7d 00 02	 cmp	 DWORD PTR [rbp], 2
  00982	8b c7		 mov	 eax, edi
  00984	bf 9a 00 00 c0	 mov	 edi, -1073741670	; ffffffffc000009aH
  00989	0f 44 c7	 cmove	 eax, edi
  0098c	8b f8		 mov	 edi, eax

; 715  : 		ntStatus = STATUS_INSUFFICIENT_RESOURCES;
; 716  : 	else
; 717  : 		ntStatus = STATUS_SUCCESS;

  0098e	e9 4b 04 00 00	 jmp	 $LN158@GSTOpenVol
$LN48@GSTOpenVol:

; 487  : 		{
; 488  : 			/* Volume header successfully decrypted */
; 489  : 
; 490  : 			Dump ("Volume header decrypted\n");
; 491  : 			Dump ("Required program version = %x\n", (int) Extension->cryptoInfo->RequiredProgramVersion);
; 492  : 			Dump ("Legacy volume = %d\n", (int) Extension->cryptoInfo->LegacyVolume);
; 493  : 
; 494  : 			if (IsHiddenSystemRunning() && !Extension->cryptoInfo->hiddenVolume)

  00993	4c 8b 25 00 00
	00 00		 mov	 r12, QWORD PTR BootDriveFilterExtension
  0099a	4c 3b e7	 cmp	 r12, rdi
  0099d	74 30		 je	 SHORT $LN47@GSTOpenVol
  0099f	41 39 bc 24 e0
	02 00 00	 cmp	 DWORD PTR [r12+736], edi
  009a7	74 26		 je	 SHORT $LN47@GSTOpenVol
  009a9	48 8b 86 90 00
	00 00		 mov	 rax, QWORD PTR [rsi+144]
  009b0	39 b8 48 04 00
	00		 cmp	 DWORD PTR [rax+1096], edi
  009b6	75 17		 jne	 SHORT $LN47@GSTOpenVol

; 495  : 			{
; 496  : 				Extension->bReadOnly = mount->bMountReadOnly = TRUE;

  009b8	b8 01 00 00 00	 mov	 eax, 1

; 497  : 				HiddenSysLeakProtectionCount++;

  009bd	01 05 00 00 00
	00		 add	 DWORD PTR HiddenSysLeakProtectionCount, eax
  009c3	89 85 6c 02 00
	00		 mov	 DWORD PTR [rbp+620], eax
  009c9	89 86 40 03 00
	00		 mov	 DWORD PTR [rsi+832], eax
$LN47@GSTOpenVol:

; 498  : 			}
; 499  : 
; 500  : 			Extension->cryptoInfo->bProtectHiddenVolume = FALSE;

  009cf	48 8b 86 90 00
	00 00		 mov	 rax, QWORD PTR [rsi+144]
  009d6	89 b8 a8 1e 00
	00		 mov	 DWORD PTR [rax+7848], edi

; 501  : 			Extension->cryptoInfo->bHiddenVolProtectionAction = FALSE;

  009dc	48 8b 86 90 00
	00 00		 mov	 rax, QWORD PTR [rsi+144]
  009e3	89 b8 ac 1e 00
	00		 mov	 DWORD PTR [rax+7852], edi

; 502  : 
; 503  : 			Extension->cryptoInfo->bPartitionInInactiveSysEncScope = mount->bPartitionInInactiveSysEncScope;

  009e9	48 8b 8e 90 00
	00 00		 mov	 rcx, QWORD PTR [rsi+144]
  009f0	8b 85 80 02 00
	00		 mov	 eax, DWORD PTR [rbp+640]
  009f6	89 81 d0 1e 00
	00		 mov	 DWORD PTR [rcx+7888], eax

; 504  : 
; 505  : 			if (volumeType == GST_VOLUME_TYPE_NORMAL)

  009fc	44 3b ef	 cmp	 r13d, edi
  009ff	75 69		 jne	 SHORT $LN39@GSTOpenVol

; 506  : 			{
; 507  : 				if (mount->bPartitionInInactiveSysEncScope)
; 508  : 				{
; 509  : 					if (Extension->cryptoInfo->EncryptedAreaStart.Value > (unsigned __int64) partitionStartingOffset
; 510  : 						|| Extension->cryptoInfo->EncryptedAreaStart.Value + Extension->cryptoInfo->VolumeSize.Value <= (unsigned __int64) partitionStartingOffset)

  00a01	48 8b 8e 90 00
	00 00		 mov	 rcx, QWORD PTR [rsi+144]
  00a08	39 bd 80 02 00
	00		 cmp	 DWORD PTR [rbp+640], edi
  00a0e	74 3d		 je	 SHORT $LN45@GSTOpenVol
  00a10	48 8b 81 f8 1e
	00 00		 mov	 rax, QWORD PTR [rcx+7928]
  00a17	4c 8b 44 24 60	 mov	 r8, QWORD PTR partitionStartingOffset$1$[rsp]
  00a1c	49 3b c0	 cmp	 rax, r8
  00a1f	0f 87 c0 03 00
	00		 ja	 $LN43@GSTOpenVol
  00a25	48 8b 91 f0 1e
	00 00		 mov	 rdx, QWORD PTR [rcx+7920]
  00a2c	48 03 c2	 add	 rax, rdx
  00a2f	49 3b c0	 cmp	 rax, r8
  00a32	0f 86 ad 03 00
	00		 jbe	 $LN43@GSTOpenVol

; 511  : 					{
; 512  : 						// The partition is not within the key scope of system encryption
; 513  : 						mount->nReturnCode = ERR_PASSWORD_WRONG;
; 514  : 						ntStatus = STATUS_SUCCESS;
; 515  : 						goto error;
; 516  : 					}
; 517  : 
; 518  : 					if (Extension->cryptoInfo->EncryptedAreaLength.Value != Extension->cryptoInfo->VolumeSize.Value)

  00a38	48 39 91 00 1f
	00 00		 cmp	 QWORD PTR [rcx+7936], rdx
  00a3f	74 29		 je	 SHORT $LN39@GSTOpenVol

; 519  : 					{
; 520  : 						// Partial encryption is not supported for volumes mounted as regular
; 521  : 						mount->nReturnCode = ERR_ENCRYPTION_NOT_COMPLETED;

  00a41	c7 45 00 1d 00
	00 00		 mov	 DWORD PTR [rbp], 29

; 522  : 						ntStatus = STATUS_SUCCESS;
; 523  : 						goto error;

  00a48	e9 9f 03 00 00	 jmp	 $LN7@GSTOpenVol
$LN45@GSTOpenVol:

; 524  : 					}
; 525  : 				}
; 526  : /**
; 527  :  *
; 528  :  *	\fn else if (Extension->cryptoInfo->HeaderFlags & GST_HEADER_FLAG_NONSYS_INPLACE_ENC)
; 529  :  *	\brief
; 530  :  *	\param[in] Extension->cryptoInfo->HeaderFlags &
; 531  :  *	\return
; 532  :  *
; 533  :  */
; 534  : 				else if (Extension->cryptoInfo->HeaderFlags & GST_HEADER_FLAG_NONSYS_INPLACE_ENC)

  00a4d	f6 81 08 1f 00
	00 02		 test	 BYTE PTR [rcx+7944], 2
  00a54	74 14		 je	 SHORT $LN39@GSTOpenVol

; 535  : 				{
; 536  : 					if (Extension->cryptoInfo->EncryptedAreaLength.Value != Extension->cryptoInfo->VolumeSize.Value)

  00a56	48 8b 81 f0 1e
	00 00		 mov	 rax, QWORD PTR [rcx+7920]
  00a5d	48 39 81 00 1f
	00 00		 cmp	 QWORD PTR [rcx+7936], rax
  00a64	0f 85 47 03 00
	00		 jne	 $LN144@GSTOpenVol
$LN39@GSTOpenVol:

; 542  : 					}
; 543  : 				}
; 544  : 			}
; 545  : 
; 546  : 			Extension->cryptoInfo->FirstDataUnitNo.Value = 0;

  00a6a	48 8b 86 90 00
	00 00		 mov	 rax, QWORD PTR [rsi+144]
  00a71	48 89 b8 d8 1e
	00 00		 mov	 QWORD PTR [rax+7896], rdi

; 547  : 
; 548  : 			if (Extension->cryptoInfo->hiddenVolume && IsHiddenSystemRunning())

  00a78	48 8b be 90 00
	00 00		 mov	 rdi, QWORD PTR [rsi+144]
  00a7f	33 c0		 xor	 eax, eax
  00a81	39 87 48 04 00
	00		 cmp	 DWORD PTR [rdi+1096], eax
  00a87	74 40		 je	 SHORT $LN37@GSTOpenVol
  00a89	4c 3b e0	 cmp	 r12, rax
  00a8c	74 3b		 je	 SHORT $LN37@GSTOpenVol
  00a8e	41 39 84 24 e0
	02 00 00	 cmp	 DWORD PTR [r12+736], eax
  00a96	74 31		 je	 SHORT $LN37@GSTOpenVol

; 549  : 			{
; 550  : 				// Prevent mount of a hidden system partition if the system hosted on it is currently running
; 551  : 				if (memcmp (Extension->cryptoInfo->master_keydata, GetSystemDriveCryptoInfo()->master_keydata, EAGetKeySize (Extension->cryptoInfo->ea)) == 0)

  00a98	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00a9a	e8 00 00 00 00	 call	 EAGetKeySize
  00a9f	49 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR [r12+152]
  00aa7	48 8d 8f 50 1c
	00 00		 lea	 rcx, QWORD PTR [rdi+7248]
  00aae	48 81 c2 50 1c
	00 00		 add	 rdx, 7248		; 00001c50H
  00ab5	4c 63 c0	 movsxd	 r8, eax
  00ab8	e8 00 00 00 00	 call	 memcmp
  00abd	33 c9		 xor	 ecx, ecx
  00abf	3b c1		 cmp	 eax, ecx
  00ac1	0f 84 f3 02 00
	00		 je	 $LN145@GSTOpenVol
  00ac7	33 c0		 xor	 eax, eax
$LN37@GSTOpenVol:

; 556  : 				}
; 557  : 			}
; 558  : 
; 559  : 			switch (volumeType)

  00ac9	44 3b e8	 cmp	 r13d, eax
  00acc	0f 84 e5 00 00
	00		 je	 $LN34@GSTOpenVol
  00ad2	0f 8e 78 01 00
	00		 jle	 $LN161@GSTOpenVol
  00ad8	41 83 fd 02	 cmp	 r13d, 2
  00adc	0f 8f 6e 01 00
	00		 jg	 $LN161@GSTOpenVol

; 587  : 				}
; 588  : 
; 589  : 				break;
; 590  : 
; 591  : 			case GST_VOLUME_TYPE_HIDDEN:
; 592  : 			case GST_VOLUME_TYPE_HIDDEN_LEGACY:
; 593  : 
; 594  : 				cryptoInfoPtr = mount->bProtectHiddenVolume ? tmpCryptoInfo : Extension->cryptoInfo;

  00ae2	39 85 8c 02 00
	00		 cmp	 DWORD PTR [rbp+652], eax
  00ae8	48 8b cf	 mov	 rcx, rdi
  00aeb	49 0f 45 cf	 cmovne	 rcx, r15

; 595  : 
; 596  : 				if (volumeType == GST_VOLUME_TYPE_HIDDEN_LEGACY)

  00aef	41 83 fd 02	 cmp	 r13d, 2
  00af3	75 12		 jne	 SHORT $LN28@GSTOpenVol

; 597  : 					Extension->cryptoInfo->hiddenVolumeOffset = lDiskLength.QuadPart - cryptoInfoPtr->hiddenVolumeSize - GST_HIDDEN_VOLUME_HEADER_OFFSET_LEGACY;

  00af5	48 8b c3	 mov	 rax, rbx
  00af8	48 2b 81 b8 1e
	00 00		 sub	 rax, QWORD PTR [rcx+7864]
  00aff	48 2d 00 06 00
	00		 sub	 rax, 1536		; 00000600H

; 598  : 				else

  00b05	eb 07		 jmp	 SHORT $LN167@GSTOpenVol
$LN28@GSTOpenVol:

; 599  : 					Extension->cryptoInfo->hiddenVolumeOffset = cryptoInfoPtr->EncryptedAreaStart.Value;

  00b07	48 8b 81 f8 1e
	00 00		 mov	 rax, QWORD PTR [rcx+7928]
$LN167@GSTOpenVol:
  00b0e	48 89 87 c0 1e
	00 00		 mov	 QWORD PTR [rdi+7872], rax

; 600  : 
; 601  : 				Dump ("Hidden volume offset = %I64d\n", Extension->cryptoInfo->hiddenVolumeOffset);
; 602  : 				Dump ("Hidden volume size = %I64d\n", cryptoInfoPtr->hiddenVolumeSize);
; 603  : 				Dump ("Hidden volume end = %I64d\n", Extension->cryptoInfo->hiddenVolumeOffset + cryptoInfoPtr->hiddenVolumeSize - 1);
; 604  : 
; 605  : 				// Validate the offset
; 606  : 				if (Extension->cryptoInfo->hiddenVolumeOffset % ENCRYPTION_DATA_UNIT_SIZE != 0)

  00b15	48 8b 96 90 00
	00 00		 mov	 rdx, QWORD PTR [rsi+144]

; 611  : 				}
; 612  : 
; 613  : 				// If we are supposed to actually mount the hidden volume (not just to protect it)
; 614  : 				if (!mount->bProtectHiddenVolume)	

  00b1c	33 ff		 xor	 edi, edi
  00b1e	8b 82 c0 1e 00
	00		 mov	 eax, DWORD PTR [rdx+7872]
  00b24	48 a9 ff 01 00
	00		 test	 rax, 511		; 000001ffH
  00b2a	0f 85 95 02 00
	00		 jne	 $LN146@GSTOpenVol
  00b30	39 bd 8c 02 00
	00		 cmp	 DWORD PTR [rbp+652], edi
  00b36	75 32		 jne	 SHORT $LN25@GSTOpenVol

; 615  : 				{
; 616  : 					Extension->DiskLength = cryptoInfoPtr->hiddenVolumeSize;

  00b38	48 8b 81 b8 1e
	00 00		 mov	 rax, QWORD PTR [rcx+7864]
  00b3f	48 89 86 a0 00
	00 00		 mov	 QWORD PTR [rsi+160], rax

; 617  : 					Extension->cryptoInfo->hiddenVolume = TRUE;

  00b46	c7 82 48 04 00
	00 01 00 00 00	 mov	 DWORD PTR [rdx+1096], 1

; 618  : 					Extension->cryptoInfo->volDataAreaOffset = Extension->cryptoInfo->hiddenVolumeOffset;

  00b50	48 8b 8e 90 00
	00 00		 mov	 rcx, QWORD PTR [rsi+144]
  00b57	48 8b 81 c0 1e
	00 00		 mov	 rax, QWORD PTR [rcx+7872]
  00b5e	48 89 81 b0 1e
	00 00		 mov	 QWORD PTR [rcx+7856], rax

; 619  : 				}
; 620  : 				else

  00b65	e9 e8 00 00 00	 jmp	 $LN30@GSTOpenVol
$LN25@GSTOpenVol:

; 621  : 				{
; 622  : 					// Hidden volume protection
; 623  : 					Extension->cryptoInfo->hiddenVolume = FALSE;

  00b6a	89 ba 48 04 00
	00		 mov	 DWORD PTR [rdx+1096], edi

; 624  : 					Extension->cryptoInfo->bProtectHiddenVolume = TRUE;

  00b70	48 8b 86 90 00
	00 00		 mov	 rax, QWORD PTR [rsi+144]
  00b77	c7 80 a8 1e 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7848], 1

; 625  : 					
; 626  : 					Extension->cryptoInfo->hiddenVolumeProtectedSize = tmpCryptoInfo->hiddenVolumeSize;

  00b81	48 8b 8e 90 00
	00 00		 mov	 rcx, QWORD PTR [rsi+144]
  00b88	49 8b 87 b8 1e
	00 00		 mov	 rax, QWORD PTR [r15+7864]
  00b8f	48 89 81 c8 1e
	00 00		 mov	 QWORD PTR [rcx+7880], rax

; 627  : 
; 628  : 					if (volumeType == GST_VOLUME_TYPE_HIDDEN_LEGACY)

  00b96	41 83 fd 02	 cmp	 r13d, 2
  00b9a	0f 85 b2 00 00
	00		 jne	 $LN30@GSTOpenVol

; 629  : 						Extension->cryptoInfo->hiddenVolumeProtectedSize += GST_VOLUME_HEADER_SIZE_LEGACY;

  00ba0	48 8b 86 90 00
	00 00		 mov	 rax, QWORD PTR [rsi+144]
  00ba7	48 81 80 c8 1e
	00 00 00 02 00
	00		 add	 QWORD PTR [rax+7880], 512 ; 00000200H

; 630  : 
; 631  : 					Dump ("Hidden volume protection active: %I64d-%I64d (%I64d)\n", Extension->cryptoInfo->hiddenVolumeOffset, Extension->cryptoInfo->hiddenVolumeProtectedSize + Extension->cryptoInfo->hiddenVolumeOffset - 1, Extension->cryptoInfo->hiddenVolumeProtectedSize);
; 632  : 				}
; 633  : 
; 634  : 				break;

  00bb2	e9 9b 00 00 00	 jmp	 $LN30@GSTOpenVol
$LN34@GSTOpenVol:

; 560  : 			{
; 561  : 			case GST_VOLUME_TYPE_NORMAL:
; 562  : 
; 563  : 				Extension->cryptoInfo->hiddenVolume = FALSE;

  00bb7	89 87 48 04 00
	00		 mov	 DWORD PTR [rdi+1096], eax

; 564  : 
; 565  : 				if (mount->bPartitionInInactiveSysEncScope)

  00bbd	33 ff		 xor	 edi, edi
  00bbf	39 bd 80 02 00
	00		 cmp	 DWORD PTR [rbp+640], edi
  00bc5	74 39		 je	 SHORT $LN33@GSTOpenVol

; 566  : 				{
; 567  : 					Extension->cryptoInfo->volDataAreaOffset = 0;

  00bc7	48 8b 86 90 00
	00 00		 mov	 rax, QWORD PTR [rsi+144]
  00bce	48 89 b8 b0 1e
	00 00		 mov	 QWORD PTR [rax+7856], rdi

; 568  : 					Extension->DiskLength = lDiskLength.QuadPart;
; 569  : 					Extension->cryptoInfo->FirstDataUnitNo.Value = partitionStartingOffset / ENCRYPTION_DATA_UNIT_SIZE;

  00bd5	48 8b 44 24 60	 mov	 rax, QWORD PTR partitionStartingOffset$1$[rsp]
  00bda	48 8b 8e 90 00
	00 00		 mov	 rcx, QWORD PTR [rsi+144]
  00be1	48 99		 cdq
  00be3	48 89 9e a0 00
	00 00		 mov	 QWORD PTR [rsi+160], rbx
  00bea	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  00bf0	48 03 c2	 add	 rax, rdx
  00bf3	48 c1 f8 09	 sar	 rax, 9
  00bf7	48 89 81 d8 1e
	00 00		 mov	 QWORD PTR [rcx+7896], rax
  00bfe	eb 52		 jmp	 SHORT $LN30@GSTOpenVol
$LN33@GSTOpenVol:

; 570  : 				}
; 571  : /**
; 572  :  *
; 573  :  *	\fn else if (Extension->cryptoInfo->LegacyVolume)
; 574  :  *	\brief
; 575  :  *	\return
; 576  :  *
; 577  :  */
; 578  : 				else if (Extension->cryptoInfo->LegacyVolume)

  00c00	48 8b 8e 90 00
	00 00		 mov	 rcx, QWORD PTR [rsi+144]
  00c07	39 b9 e4 1e 00
	00		 cmp	 DWORD PTR [rcx+7908], edi
  00c0d	74 1c		 je	 SHORT $LN31@GSTOpenVol

; 579  : 				{
; 580  : 					Extension->cryptoInfo->volDataAreaOffset = GST_VOLUME_HEADER_SIZE_LEGACY;

  00c0f	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00c14	48 89 81 b0 1e
	00 00		 mov	 QWORD PTR [rcx+7856], rax

; 581  : 					Extension->DiskLength = lDiskLength.QuadPart - GST_VOLUME_HEADER_SIZE_LEGACY;

  00c1b	48 8d 83 00 fe
	ff ff		 lea	 rax, QWORD PTR [rbx-512]
  00c22	48 89 86 a0 00
	00 00		 mov	 QWORD PTR [rsi+160], rax

; 582  : 				}
; 583  : 				else

  00c29	eb 27		 jmp	 SHORT $LN30@GSTOpenVol
$LN31@GSTOpenVol:

; 584  : 				{
; 585  : 					Extension->cryptoInfo->volDataAreaOffset = Extension->cryptoInfo->EncryptedAreaStart.Value;

  00c2b	48 8b 81 f8 1e
	00 00		 mov	 rax, QWORD PTR [rcx+7928]
  00c32	48 89 81 b0 1e
	00 00		 mov	 QWORD PTR [rcx+7856], rax

; 586  : 					Extension->DiskLength = Extension->cryptoInfo->VolumeSize.Value;

  00c39	48 8b 86 90 00
	00 00		 mov	 rax, QWORD PTR [rsi+144]
  00c40	48 8b 88 f0 1e
	00 00		 mov	 rcx, QWORD PTR [rax+7920]
  00c47	48 89 8e a0 00
	00 00		 mov	 QWORD PTR [rsi+160], rcx
  00c4e	eb 02		 jmp	 SHORT $LN30@GSTOpenVol
$LN161@GSTOpenVol:
  00c50	33 ff		 xor	 edi, edi
$LN30@GSTOpenVol:

; 635  : 			}
; 636  : 
; 637  : 			Dump ("Volume data offset = %I64d\n", Extension->cryptoInfo->volDataAreaOffset);
; 638  : 			Dump ("Volume data size = %I64d\n", Extension->DiskLength);
; 639  : 			Dump ("Volume data end = %I64d\n", Extension->cryptoInfo->volDataAreaOffset + Extension->DiskLength - 1);
; 640  : 
; 641  : 			if (Extension->DiskLength == 0)

  00c52	48 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [rsi+160]
  00c59	48 3b c7	 cmp	 rax, rdi
  00c5c	0f 84 21 01 00
	00		 je	 $LN154@GSTOpenVol

; 642  : 			{
; 643  : 				Dump ("Incorrect volume size\n");
; 644  : 				continue;
; 645  : 			}
; 646  : 
; 647  : 			// If this is a hidden volume, make sure we are supposed to actually
; 648  : 			// mount it (i.e. not just to protect it)
; 649  : 			if (volumeType == GST_VOLUME_TYPE_NORMAL || !mount->bProtectHiddenVolume)	

  00c62	44 3b ef	 cmp	 r13d, edi
  00c65	74 0c		 je	 SHORT $LN20@GSTOpenVol
  00c67	39 bd 8c 02 00
	00		 cmp	 DWORD PTR [rbp+652], edi
  00c6d	0f 85 d9 00 00
	00		 jne	 $LN155@GSTOpenVol
$LN20@GSTOpenVol:

; 650  : 			{
; 651  : 				// Validate sector size
; 652  : 				if (bRawDevice && Extension->cryptoInfo->SectorSize != Extension->HostBytesPerSector)

  00c73	44 8b a4 24 20
	03 00 00	 mov	 r12d, DWORD PTR bRawDevice$[rsp]
  00c7b	44 3b e7	 cmp	 r12d, edi
  00c7e	74 19		 je	 SHORT $LN19@GSTOpenVol
  00c80	48 8b 96 90 00
	00 00		 mov	 rdx, QWORD PTR [rsi+144]
  00c87	8b 8e c0 00 00
	00		 mov	 ecx, DWORD PTR [rsi+192]
  00c8d	39 8a e8 1e 00
	00		 cmp	 DWORD PTR [rdx+7912], ecx
  00c93	0f 85 35 01 00
	00		 jne	 $LN147@GSTOpenVol
$LN19@GSTOpenVol:

; 657  : 				}
; 658  : 
; 659  : 				// Calculate virtual volume geometry
; 660  : 				Extension->TracksPerCylinder = 1;
; 661  : 				Extension->SectorsPerTrack = 1;
; 662  : 				Extension->BytesPerSector = Extension->cryptoInfo->SectorSize;

  00c99	48 8b 8e 90 00
	00 00		 mov	 rcx, QWORD PTR [rsi+144]
  00ca0	c7 86 b0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rsi+176], 1
  00caa	c7 86 b4 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rsi+180], 1
  00cb4	8b 91 e8 1e 00
	00		 mov	 edx, DWORD PTR [rcx+7912]

; 663  : 				Extension->NumberOfCylinders = Extension->DiskLength / Extension->BytesPerSector;
; 664  : 				Extension->PartitionType = 0;
; 665  : 
; 666  : 				Extension->bRawDevice = bRawDevice;
; 667  : 				
; 668  : 				memset (Extension->wszVolume, 0, sizeof (Extension->wszVolume));

  00cba	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H
  00cc0	40 88 be bc 00
	00 00		 mov	 BYTE PTR [rsi+188], dil
  00cc7	48 8b ca	 mov	 rcx, rdx
  00cca	89 96 b8 00 00
	00		 mov	 DWORD PTR [rsi+184], edx
  00cd0	48 99		 cdq
  00cd2	44 89 a6 4c 03
	00 00		 mov	 DWORD PTR [rsi+844], r12d
  00cd9	48 f7 f9	 idiv	 rcx
  00cdc	48 8d 8e 58 03
	00 00		 lea	 rcx, QWORD PTR [rsi+856]
  00ce3	33 d2		 xor	 edx, edx
  00ce5	48 89 86 a8 00
	00 00		 mov	 QWORD PTR [rsi+168], rax
  00cec	e8 00 00 00 00	 call	 memset

; 669  : 				if (wcsstr (pwszMountVolume, WIDE ("\\??\\UNC\\")) == pwszMountVolume)

  00cf1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pwszMountVolume$GSCopy$1$[rsp]
  00cf9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BC@MAMPPFNN@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAU?$AAN?$AAC?$AA?2?$AA?$AA@FNODOBFM@
  00d00	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsstr
  00d06	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pwszMountVolume$GSCopy$1$[rsp]
  00d0e	48 3b c1	 cmp	 rax, rcx
  00d11	75 21		 jne	 SHORT $LN18@GSTOpenVol

; 670  : 				{
; 671  : 					/* UNC path */
; 672  : 					_snwprintf (Extension->wszVolume,
; 673  : 						sizeof (Extension->wszVolume) / sizeof (WCHAR) - 1,
; 674  : 						WIDE ("\\??\\\\%s"),
; 675  : 						pwszMountVolume + 7);

  00d13	4c 8d 49 0e	 lea	 r9, QWORD PTR [rcx+14]
  00d17	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1BA@GIIKONIJ@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@
  00d1e	48 8d 8e 58 03
	00 00		 lea	 rcx, QWORD PTR [rsi+856]
  00d25	ba 03 01 00 00	 mov	 edx, 259		; 00000103H
  00d2a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__snwprintf
$LN168@GSTOpenVol:

; 676  : 				}
; 677  : 				else

  00d30	33 ff		 xor	 edi, edi
  00d32	eb 20		 jmp	 SHORT $LN17@GSTOpenVol
$LN18@GSTOpenVol:

; 678  : 				{
; 679  : 					wcsncpy (Extension->wszVolume, pwszMountVolume, sizeof (Extension->wszVolume) / sizeof (WCHAR) - 1);

  00d34	48 8b d1	 mov	 rdx, rcx
  00d37	48 8d 8e 58 03
	00 00		 lea	 rcx, QWORD PTR [rsi+856]
  00d3e	41 b8 03 01 00
	00		 mov	 r8d, 259		; 00000103H
  00d44	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy
  00d4a	eb e4		 jmp	 SHORT $LN168@GSTOpenVol
$LN155@GSTOpenVol:

; 308  : 		ntStatus = STATUS_SUCCESS;
; 309  : 		goto error;
; 310  : 	}
; 311  : 
; 312  : 	Extension->DiskLength = lDiskLength.QuadPart;
; 313  : 	Extension->HostLength = lDiskLength.QuadPart;
; 314  : 
; 315  : 	readBuffer = GSTalloc (max (max (GST_VOLUME_HEADER_EFFECTIVE_SIZE, PAGE_SIZE), Extension->HostBytesPerSector));

  00d4c	44 8b a4 24 20
	03 00 00	 mov	 r12d, DWORD PTR bRawDevice$[rsp]
$LN17@GSTOpenVol:

; 680  : 				}
; 681  : 			}
; 682  : 
; 683  : 			// If we are to protect a hidden volume we cannot exit yet, for we must also
; 684  : 			// decrypt the hidden volume header.
; 685  : 			if (!(volumeType == GST_VOLUME_TYPE_NORMAL && mount->bProtectHiddenVolume))

  00d54	44 3b ef	 cmp	 r13d, edi
  00d57	75 08		 jne	 SHORT $LN148@GSTOpenVol
  00d59	39 bd 8c 02 00
	00		 cmp	 DWORD PTR [rbp+652], edi
  00d5f	75 2a		 jne	 SHORT $LN73@GSTOpenVol
$LN148@GSTOpenVol:

; 686  : 			{
; 687  : 				GSTfree (readBuffer);

  00d61	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00d66	49 8b ce	 mov	 rcx, r14
  00d69	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 688  : 
; 689  : 				if (tmpCryptoInfo != NULL)

  00d6f	4c 3b ff	 cmp	 r15, rdi
  00d72	74 08		 je	 SHORT $LN14@GSTOpenVol

; 690  : 				{
; 691  : 					crypto_close (tmpCryptoInfo);

  00d74	49 8b cf	 mov	 rcx, r15
  00d77	e8 00 00 00 00	 call	 crypto_close
$LN14@GSTOpenVol:

; 692  : 					tmpCryptoInfo = NULL;
; 693  : 				}
; 694  : 				
; 695  : 				return STATUS_SUCCESS;

  00d7c	33 c0		 xor	 eax, eax
  00d7e	e9 e6 00 00 00	 jmp	 $LN108@GSTOpenVol
$LN154@GSTOpenVol:

; 308  : 		ntStatus = STATUS_SUCCESS;
; 309  : 		goto error;
; 310  : 	}
; 311  : 
; 312  : 	Extension->DiskLength = lDiskLength.QuadPart;
; 313  : 	Extension->HostLength = lDiskLength.QuadPart;
; 314  : 
; 315  : 	readBuffer = GSTalloc (max (max (GST_VOLUME_HEADER_EFFECTIVE_SIZE, PAGE_SIZE), Extension->HostBytesPerSector));

  00d83	44 8b a4 24 20
	03 00 00	 mov	 r12d, DWORD PTR bRawDevice$[rsp]
$LN73@GSTOpenVol:

; 320  : 	}
; 321  : 
; 322  : 	// Go through all volume types (e.g., normal, hidden)
; 323  : 	for (volumeType = GST_VOLUME_TYPE_NORMAL;
; 324  : 		volumeType < GST_VOLUME_TYPE_COUNT;
; 325  : 		volumeType++)	

  00d8b	41 ff c5	 inc	 r13d
  00d8e	41 83 fd 03	 cmp	 r13d, 3
  00d92	0f 8d e6 fb ff
	ff		 jge	 $LN152@GSTOpenVol
  00d98	e9 a0 f8 ff ff	 jmp	 $LL74@GSTOpenVol
$LN140@GSTOpenVol:

; 419  : 			{
; 420  : 				if (hParentDeviceFile != NULL)

  00d9d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR hParentDeviceFile$29835[rsp]
  00da2	33 db		 xor	 ebx, ebx
  00da4	48 3b cb	 cmp	 rcx, rbx
  00da7	74 37		 je	 SHORT $error$29740

; 421  : 					ZwClose (hParentDeviceFile);

  00da9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 422  : 
; 423  : 				Dump ("Cannot open %ls\n", parentDrivePath);
; 424  : 
; 425  : 				goto error;

  00daf	eb 2f		 jmp	 SHORT $error$29740
$LN144@GSTOpenVol:

; 537  : 					{
; 538  : 						// Non-system in-place encryption process has not been completed on this volume
; 539  : 						mount->nReturnCode = ERR_NONSYS_INPLACE_ENC_INCOMPLETE;

  00db1	c7 45 00 20 00
	00 00		 mov	 DWORD PTR [rbp], 32	; 00000020H

; 540  : 						ntStatus = STATUS_SUCCESS;
; 541  : 						goto error;

  00db8	eb 32		 jmp	 SHORT $LN7@GSTOpenVol
$LN145@GSTOpenVol:

; 552  : 				{
; 553  : 					mount->nReturnCode = ERR_VOL_ALREADY_MOUNTED;

  00dba	c7 45 00 15 00
	00 00		 mov	 DWORD PTR [rbp], 21

; 554  : 					ntStatus = STATUS_SUCCESS;

  00dc1	33 ff		 xor	 edi, edi

; 555  : 					goto error;

  00dc3	eb 27		 jmp	 SHORT $LN7@GSTOpenVol
$LN146@GSTOpenVol:

; 607  : 				{
; 608  : 					mount->nReturnCode = ERR_VOL_SIZE_WRONG;

  00dc5	c7 45 00 07 00
	00 00		 mov	 DWORD PTR [rbp], 7

; 609  : 					ntStatus = STATUS_SUCCESS;
; 610  : 					goto error;

  00dcc	eb 1e		 jmp	 SHORT $LN7@GSTOpenVol
$LN147@GSTOpenVol:

; 653  : 				{
; 654  : 					mount->nReturnCode = ERR_PARAMETER_INCORRECT;

  00dce	c7 45 00 1e 00
	00 00		 mov	 DWORD PTR [rbp], 30

; 655  : 					ntStatus = STATUS_SUCCESS;
; 656  : 					goto error;

  00dd5	eb 15		 jmp	 SHORT $LN7@GSTOpenVol
$LN76@GSTOpenVol:

; 306  : 	{
; 307  : 		mount->nReturnCode = ERR_VOL_SIZE_WRONG;

  00dd7	c7 45 00 07 00
	00 00		 mov	 DWORD PTR [rbp], 7
$LN158@GSTOpenVol:

; 669  : 				if (wcsstr (pwszMountVolume, WIDE ("\\??\\UNC\\")) == pwszMountVolume)

  00dde	33 db		 xor	 ebx, ebx
$error$29740:

; 718  : 
; 719  : error:
; 720  : 	if (mount->nReturnCode == ERR_SUCCESS)

  00de0	39 5d 00	 cmp	 DWORD PTR [rbp], ebx
  00de3	75 07		 jne	 SHORT $LN7@GSTOpenVol
$LN43@GSTOpenVol:

; 721  : 		mount->nReturnCode = ERR_PASSWORD_WRONG;

  00de5	c7 45 00 03 00
	00 00		 mov	 DWORD PTR [rbp], 3
$LN7@GSTOpenVol:

; 722  : 
; 723  : 	if (tmpCryptoInfo != NULL)

  00dec	33 ed		 xor	 ebp, ebp
  00dee	4c 3b fd	 cmp	 r15, rbp
  00df1	74 08		 je	 SHORT $LN153@GSTOpenVol

; 724  : 	{
; 725  : 		crypto_close (tmpCryptoInfo);

  00df3	49 8b cf	 mov	 rcx, r15
  00df6	e8 00 00 00 00	 call	 crypto_close
$LN153@GSTOpenVol:
  00dfb	45 33 ff	 xor	 r15d, r15d
  00dfe	4c 8d 6e 78	 lea	 r13, QWORD PTR [rsi+120]
$LN6@GSTOpenVol:

; 726  : 		tmpCryptoInfo = NULL;
; 727  : 	}
; 728  : 
; 729  : 	if (Extension->cryptoInfo)

  00e02	48 8b 8e 90 00
	00 00		 mov	 rcx, QWORD PTR [rsi+144]
  00e09	49 3b cf	 cmp	 rcx, r15
  00e0c	74 0c		 je	 SHORT $LN5@GSTOpenVol

; 730  : 	{
; 731  : 		crypto_close (Extension->cryptoInfo);

  00e0e	e8 00 00 00 00	 call	 crypto_close

; 732  : 		Extension->cryptoInfo = NULL;

  00e13	4c 89 be 90 00
	00 00		 mov	 QWORD PTR [rsi+144], r15
$LN5@GSTOpenVol:

; 733  : 	}
; 734  : 
; 735  : 	if (Extension->bTimeStampValid)

  00e1a	44 39 be 80 05
	00 00		 cmp	 DWORD PTR [rsi+1408], r15d
  00e21	74 08		 je	 SHORT $LN4@GSTOpenVol

; 736  : 	{
; 737  : 		RestoreTimeStamp (Extension);

  00e23	48 8b ce	 mov	 rcx, rsi
  00e26	e8 00 00 00 00	 call	 RestoreTimeStamp
$LN4@GSTOpenVol:

; 738  : 	}
; 739  : 
; 740  : 	/* Close the hDeviceFile */
; 741  : 	if (Extension->hDeviceFile != NULL)

  00e2b	49 8b 4d 00	 mov	 rcx, QWORD PTR [r13]
  00e2f	49 3b cf	 cmp	 rcx, r15
  00e32	74 06		 je	 SHORT $LN3@GSTOpenVol

; 742  : 		ZwClose (Extension->hDeviceFile);

  00e34	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose
$LN3@GSTOpenVol:

; 743  : 
; 744  : 	/* The cryptoInfo pointer is deallocated if the readheader routines
; 745  : 	   fail so there is no need to deallocate here  */
; 746  : 
; 747  : 	/* Dereference the user-mode file object */
; 748  : 	if (Extension->pfoDeviceFile != NULL)

  00e3a	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  00e41	49 3b cf	 cmp	 rcx, r15
  00e44	74 06		 je	 SHORT $LN2@GSTOpenVol

; 749  : 		ObDereferenceObject (Extension->pfoDeviceFile);

  00e46	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObfDereferenceObject
$LN2@GSTOpenVol:

; 750  : 
; 751  : 	/* Free the tmp IO buffers */
; 752  : 	if (readBuffer != NULL)

  00e4c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR readBuffer$1$[rsp]
  00e54	49 3b c7	 cmp	 rax, r15
  00e57	74 0e		 je	 SHORT $LN1@GSTOpenVol

; 753  : 		GSTfree (readBuffer);

  00e59	ba 54 43 4d 4d	 mov	 edx, 1296909140		; 4d4d4354H
  00e5e	48 8b c8	 mov	 rcx, rax
  00e61	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN1@GSTOpenVol:

; 754  : 
; 755  : 	return ntStatus;

  00e67	8b c7		 mov	 eax, edi
$LN108@GSTOpenVol:

; 756  : }

  00e69	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00e71	48 33 cc	 xor	 rcx, rsp
  00e74	e8 00 00 00 00	 call	 __security_check_cookie
  00e79	48 81 c4 b8 02
	00 00		 add	 rsp, 696		; 000002b8H
  00e80	41 5f		 pop	 r15
  00e82	41 5e		 pop	 r14
  00e84	41 5d		 pop	 r13
  00e86	41 5c		 pop	 r12
  00e88	5f		 pop	 rdi
  00e89	5e		 pop	 rsi
  00e8a	5d		 pop	 rbp
  00e8b	5b		 pop	 rbx
  00e8c	c3		 ret	 0
GSTOpenVolume ENDP
END
